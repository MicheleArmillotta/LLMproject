[
  {
    "function_name": "YCPBuiltinMisc",
    "container": "YCPBuiltinMisc",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "676-716",
    "snippet": "YCPBuiltinMisc::YCPBuiltinMisc ()\n{\n    // must be static, registerDeclarations saves a pointer to it!\n    static declaration_t declarations[] = {\n#define ETC 0, NULL, constTypePtr(), NULL\n#define ETCf   NULL, constTypePtr(), NULL\n\t{ \"time\",\t\"integer ()\",\t\t\t(void *)Time,       ETC },\n\t{ \"sleep\",\t\"void (integer)\",\t\t(void *)Sleep,\t    ETC },\n\t{ \"random\",\t\"integer (integer)\",\t\t(void *)Random,\t    ETC },\n        { \"setenv\",\t\"boolean (string,string)\", \t(void *)Setenv1,    ETC },\n\t{ \"setenv\",\t\"boolean (string,string,boolean)\", (void *)Setenv2, ETC },\n\t{ \"getenv\",\t\"string (string)\",\t\t(void *)Getenv,\t    ETC },\n\t{ \"srandom\",\t\"integer ()\",\t\t\t(void *)Srandom1,   ETC },\n\t{ \"srandom\",\t\"void (integer)\",\t\t(void *)Srandom2,   ETC },\n\t{ \"eval\",\t\"flex (block <flex>)\",\t\t(void *)Eval,\t\tDECL_NIL|DECL_FLEX,                ETCf },\n\t{ \"eval\",\t\"flex (const flex)\",\t\t(void *)Eval,\t\tDECL_NIL|DECL_FLEX,\t\t   ETCf },\n\t{ \"sformat\",\t\"string (string, ...)\",\t\t(void *)s_sformat,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n\t// ordinary logging\n\t{ \"y2debug\",\t\"void (string, ...)\",\t\t(void *)Y2Debug,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n\t{ \"y2milestone\",\"void (string, ...)\",\t\t(void *)Y2Milestone,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n\t{ \"y2warning\",\t\"void (string, ...)\",\t\t(void *)Y2Warning,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n\t{ \"y2error\",\t\"void (string, ...)\",\t\t(void *)Y2Error,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n\t{ \"y2security\", \"void (string, ...)\",\t\t(void *)Y2Security,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n\t{ \"y2internal\", \"void (string, ...)\",\t\t(void *)Y2Internal,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n\t// logging with a different call frame\n\t{ \"y2debug\",\t\"void (integer, string, ...)\",\t(void *)Y2FDebug,\tDECL_NIL|DECL_WILD,\t\t   ETCf },\n\t{ \"y2milestone\",\"void (integer, string, ...)\",\t(void *)Y2FMilestone,\tDECL_NIL|DECL_WILD,\t\t   ETCf },\n\t{ \"y2warning\",\t\"void (integer, string, ...)\",\t(void *)Y2FWarning,\tDECL_NIL|DECL_WILD,\t\t   ETCf },\n\t{ \"y2error\",\t\"void (integer, string, ...)\",\t(void *)Y2FError,\tDECL_NIL|DECL_WILD,                ETCf },\n\t{ \"y2security\", \"void (integer, string, ...)\",\t(void *)Y2FSecurity,\tDECL_NIL|DECL_WILD,\t\t   ETCf },\n\t{ \"y2internal\", \"void (integer, string, ...)\",\t(void *)Y2FInternal,\tDECL_NIL|DECL_WILD,\t\t   ETCf },\n\t// user-level logging\n\t{ \"y2useritem\", \"void (string, ...)\",\t\t(void *)Y2UserItem,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n\t{ \"y2usernote\", \"void (string, ...)\",\t\t(void *)Y2UserNote,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n\t{ NULL, NULL, NULL, ETC }\n#undef ETC\n#undef ETCf\n    };\n\n    static_declarations.registerDeclarations (\"YCPBuiltinMisc\", declarations);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [
      "#define ETCf   NULL, constTypePtr(), NULL",
      "#define ETC 0, NULL, constTypePtr(), NULL"
    ],
    "globals_used": [
      "extern StaticDeclaration static_declarations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_declarations.registerDeclarations",
          "args": [
            "\"YCPBuiltinMisc\"",
            "declarations"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "registerDeclarations",
          "container": "StaticDeclaration",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/StaticDeclaration.cc",
          "lines": "87-237",
          "snippet": "void\nStaticDeclaration::registerDeclarations (const char *filename,\n\t\t\t\t\t declaration_t *declarations)\n{\n    if (declarations == 0)\n    {\n\treturn;\n    }\n\n    SymbolTable *table = m_declTable;\n    const Y2Namespace *name_space = 0;\n    static const Point *builtin_point = new Point (\"<builtin>\");\n    const Point *namespace_point = builtin_point;\t\t// declarations default to builtin\n    declaration_t *namespace_decl = 0;\n\n    std::pair <std::string, Y2Namespace *> *track_info = 0;\n\n    while (declarations->name != 0)\n    {\n#if DO_DEBUG\n\ty2debug( \"Registering %s\", declarations->name );\n#endif\n\tconst char *name = declarations->name;\n\n\tif (*name == 0)\t\t// exit on empty name\n\t    break;\n\n\tif ((declarations->flags & (DECL_WILD|DECL_SYMBOL)) == (DECL_WILD|DECL_SYMBOL))\n\t{\n\t    y2internal (\"Declaration of %s::%s combines wildcard and symbol\\n\", filename, name);\n\t}\n\telse if ((declarations->flags & DECL_NAMESPACE) != 0)\t\t// switch namespace\n\t{\n\t    // new namespace, clear possibly old track_info\n\t    if (track_info != 0)\n\t    {\n\t\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n\t\tm_active_predefined.push_back (*track_info);\n\t\ttrack_info = 0;\n\t    }\n#if DO_DEBUG\n\t    y2debug (\"NAMESPACE (%s)\", name);\n#endif\n            declarations->name_space = namespace_decl;\n\n\t    TableEntry *tentry = table->find (name);\n\t    if (tentry != 0\t\t\t\t\t\t// name already exists\n\t\t&& tentry->sentry()->isNamespace())\t\t\t//   as namespace\n\t    {\n\t\tname_space = tentry->sentry()->nameSpace();\n\t    }\n\t    else if (*name == 0)\t\t\t\t\t// reset namespace\n\t    {\n\t\ttable = m_declTable;\n\t\tname_space = 0;\n\t\tnamespace_point = builtin_point;\n\t    }\n\t    else\t\t\t\t\t\t\t// open up new namespace\n\t    {\n\t\tbool is_predefined = false;\n\n\t\tif (tentry != 0\n\t\t    && tentry->sentry()->isPredefined())\t\t//   replace predefined\n\t\t{\n\t\t    table->remove (tentry);\n\t\t    is_predefined = true;\n\t\t}\n\n\t\t// create definition container for namespace\n\t\tYBlock *block = new YBlock (filename, YBlock::b_namespace);\n\t\tblock->setName (string (name));\n\n\t\tY2Namespace *namespaceNamespace = (Y2Namespace *)block;\n\t\tnamespaceNamespace->createTable();\n\t\tSymbolTable *namespaceTable = block->table();\n\n\t\t// create SymbolEntry::c_namespace for the namespace to be entered into the global table\n\t\tSymbolEntryPtr sentry = new YSymbolEntry (name, Type::Unspec, namespaceTable);\n\n#if DO_DEBUG\n\t\ty2debug (\"Entered Namespace '%s' (block %p) into namespaceTable %p\", name, block, namespaceTable);\n#endif\n\n\t\t// enter into global table\n\t\tnamespace_point = new Point (filename);\n\t\ttable->enter (name, sentry, namespace_point);\n\n\t\t// all further definitions go into this namespace\n\t\t//   -> make it the new global table\n\t\ttable = namespaceTable;\n\t\tnamespace_decl = declarations;\n\n\t\tif (is_predefined)\n\t\t{\n\t\t    // save tracking info, trigger 'Import' _after_ all symbols have been added\n\t\t    track_info = new std::pair<std::string, Y2Namespace *> (name, namespaceNamespace);\n\t\t}\n\t    }\n\t}\n\telse\t// normal entry, not namespace\n\t{\n\t    declarations->name_space = namespace_decl;\n\t    string signature = declarations->signature;\n\n\t    constTypePtr type = Type::fromSignature (signature);\n\t    if (type == 0\n\t\t|| type->isError()\n\t\t|| type->isUnspec()\n\t\t|| type->isWildcard())\n\t    {\n\t\ty2error (\"Invalid signature %s::%s:'%s'\\n\", filename, name, signature.c_str());\n\t\treturn;\n\t    }\n\n#if DO_DEBUG\ny2debug(\"%s sig[%s] type[%s]\", name, signature.c_str(), type->toString().c_str());\n#endif\n#if 0\n\t    if (type->hasFlex()\n\t\t&& (declarations->flags & DECL_FLEX) == 0)\n\t    {\n\t\ty2error (\"%s:'%s' without DECL_FLEX\", name, declarations->signature);\n\t\treturn;\n\t    }\n#endif\n\t    declarations->type = type;\n\n\t    SymbolEntryPtr sentry = new YSymbolEntry (name, type, declarations, name_space);\n\t    declarations->tentry = table->enter (name, sentry, new Point (sentry, 0, namespace_point));\n\n#ifdef BUILTIN_STATISTICS\n\t    FILE *fout = fopen (\"/tmp/builtin-register.txt\", \"a\");\n\t    if (fout) {\n\t\tfprintf (fout, \"%s %s\\n\", declarations->name, declarations->signature);\n\t\tfclose (fout);\n\t    }\n#endif\n\t}\n\tdeclarations++;\n    }\n\n    // clear possibly old track_info\n    if (track_info != 0)\n    {\n\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n\tm_active_predefined.push_back (*track_info);\n\ttrack_info = 0;\n    }\n\n    return;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Point.h\"",
            "#include \"ycp/Import.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YBlock.h\"",
            "#include \"ycp/YSymbolEntry.h\"",
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include <map>",
            "#include <string>",
            "#include <stdio.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [
            "#define DO_DEBUG 0"
          ],
          "globals_used": [
            "static const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/Point.h\"\n#include \"ycp/Import.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YBlock.h\"\n#include \"ycp/YSymbolEntry.h\"\n#include \"ycp/SymbolTable.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include <map>\n#include <string>\n#include <stdio.h>\n#include <unistd.h>\n\n#define DO_DEBUG 0\n\nstatic const char *predefined[] = {\n  \"UI\", \"WFM\", \"SCR\", \"Pkg\", 0\n};\n\nStaticDeclaration {\n  void\n  StaticDeclaration::registerDeclarations (const char *filename,\n  \t\t\t\t\t declaration_t *declarations)\n  {\n      if (declarations == 0)\n      {\n  \treturn;\n      }\n  \n      SymbolTable *table = m_declTable;\n      const Y2Namespace *name_space = 0;\n      static const Point *builtin_point = new Point (\"<builtin>\");\n      const Point *namespace_point = builtin_point;\t\t// declarations default to builtin\n      declaration_t *namespace_decl = 0;\n  \n      std::pair <std::string, Y2Namespace *> *track_info = 0;\n  \n      while (declarations->name != 0)\n      {\n  #if DO_DEBUG\n  \ty2debug( \"Registering %s\", declarations->name );\n  #endif\n  \tconst char *name = declarations->name;\n  \n  \tif (*name == 0)\t\t// exit on empty name\n  \t    break;\n  \n  \tif ((declarations->flags & (DECL_WILD|DECL_SYMBOL)) == (DECL_WILD|DECL_SYMBOL))\n  \t{\n  \t    y2internal (\"Declaration of %s::%s combines wildcard and symbol\\n\", filename, name);\n  \t}\n  \telse if ((declarations->flags & DECL_NAMESPACE) != 0)\t\t// switch namespace\n  \t{\n  \t    // new namespace, clear possibly old track_info\n  \t    if (track_info != 0)\n  \t    {\n  \t\tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n  \t\tm_active_predefined.push_back (*track_info);\n  \t\ttrack_info = 0;\n  \t    }\n  #if DO_DEBUG\n  \t    y2debug (\"NAMESPACE (%s)\", name);\n  #endif\n              declarations->name_space = namespace_decl;\n  \n  \t    TableEntry *tentry = table->find (name);\n  \t    if (tentry != 0\t\t\t\t\t\t// name already exists\n  \t\t&& tentry->sentry()->isNamespace())\t\t\t//   as namespace\n  \t    {\n  \t\tname_space = tentry->sentry()->nameSpace();\n  \t    }\n  \t    else if (*name == 0)\t\t\t\t\t// reset namespace\n  \t    {\n  \t\ttable = m_declTable;\n  \t\tname_space = 0;\n  \t\tnamespace_point = builtin_point;\n  \t    }\n  \t    else\t\t\t\t\t\t\t// open up new namespace\n  \t    {\n  \t\tbool is_predefined = false;\n  \n  \t\tif (tentry != 0\n  \t\t    && tentry->sentry()->isPredefined())\t\t//   replace predefined\n  \t\t{\n  \t\t    table->remove (tentry);\n  \t\t    is_predefined = true;\n  \t\t}\n  \n  \t\t// create definition container for namespace\n  \t\tYBlock *block = new YBlock (filename, YBlock::b_namespace);\n  \t\tblock->setName (string (name));\n  \n  \t\tY2Namespace *namespaceNamespace = (Y2Namespace *)block;\n  \t\tnamespaceNamespace->createTable();\n  \t\tSymbolTable *namespaceTable = block->table();\n  \n  \t\t// create SymbolEntry::c_namespace for the namespace to be entered into the global table\n  \t\tSymbolEntryPtr sentry = new YSymbolEntry (name, Type::Unspec, namespaceTable);\n  \n  #if DO_DEBUG\n  \t\ty2debug (\"Entered Namespace '%s' (block %p) into namespaceTable %p\", name, block, namespaceTable);\n  #endif\n  \n  \t\t// enter into global table\n  \t\tnamespace_point = new Point (filename);\n  \t\ttable->enter (name, sentry, namespace_point);\n  \n  \t\t// all further definitions go into this namespace\n  \t\t//   -> make it the new global table\n  \t\ttable = namespaceTable;\n  \t\tnamespace_decl = declarations;\n  \n  \t\tif (is_predefined)\n  \t\t{\n  \t\t    // save tracking info, trigger 'Import' _after_ all symbols have been added\n  \t\t    track_info = new std::pair<std::string, Y2Namespace *> (name, namespaceNamespace);\n  \t\t}\n  \t    }\n  \t}\n  \telse\t// normal entry, not namespace\n  \t{\n  \t    declarations->name_space = namespace_decl;\n  \t    string signature = declarations->signature;\n  \n  \t    constTypePtr type = Type::fromSignature (signature);\n  \t    if (type == 0\n  \t\t|| type->isError()\n  \t\t|| type->isUnspec()\n  \t\t|| type->isWildcard())\n  \t    {\n  \t\ty2error (\"Invalid signature %s::%s:'%s'\\n\", filename, name, signature.c_str());\n  \t\treturn;\n  \t    }\n  \n  #if DO_DEBUG\n  y2debug(\"%s sig[%s] type[%s]\", name, signature.c_str(), type->toString().c_str());\n  #endif\n  #if 0\n  \t    if (type->hasFlex()\n  \t\t&& (declarations->flags & DECL_FLEX) == 0)\n  \t    {\n  \t\ty2error (\"%s:'%s' without DECL_FLEX\", name, declarations->signature);\n  \t\treturn;\n  \t    }\n  #endif\n  \t    declarations->type = type;\n  \n  \t    SymbolEntryPtr sentry = new YSymbolEntry (name, type, declarations, name_space);\n  \t    declarations->tentry = table->enter (name, sentry, new Point (sentry, 0, namespace_point));\n  \n  #ifdef BUILTIN_STATISTICS\n  \t    FILE *fout = fopen (\"/tmp/builtin-register.txt\", \"a\");\n  \t    if (fout) {\n  \t\tfprintf (fout, \"%s %s\\n\", declarations->name, declarations->signature);\n  \t\tfclose (fout);\n  \t    }\n  #endif\n  \t}\n  \tdeclarations++;\n      }\n  \n      // clear possibly old track_info\n      if (track_info != 0)\n      {\n  \tnew Import (track_info->first, track_info->second);\t// remember which predefined got activated\n  \tm_active_predefined.push_back (*track_info);\n  \ttrack_info = 0;\n      }\n  \n      return;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#define ETCf   NULL, constTypePtr(), NULL\n#define ETC 0, NULL, constTypePtr(), NULL\n\nextern StaticDeclaration static_declarations;\n\nYCPBuiltinMisc {\n  YCPBuiltinMisc::YCPBuiltinMisc ()\n  {\n      // must be static, registerDeclarations saves a pointer to it!\n      static declaration_t declarations[] = {\n  #define ETC 0, NULL, constTypePtr(), NULL\n  #define ETCf   NULL, constTypePtr(), NULL\n  \t{ \"time\",\t\"integer ()\",\t\t\t(void *)Time,       ETC },\n  \t{ \"sleep\",\t\"void (integer)\",\t\t(void *)Sleep,\t    ETC },\n  \t{ \"random\",\t\"integer (integer)\",\t\t(void *)Random,\t    ETC },\n          { \"setenv\",\t\"boolean (string,string)\", \t(void *)Setenv1,    ETC },\n  \t{ \"setenv\",\t\"boolean (string,string,boolean)\", (void *)Setenv2, ETC },\n  \t{ \"getenv\",\t\"string (string)\",\t\t(void *)Getenv,\t    ETC },\n  \t{ \"srandom\",\t\"integer ()\",\t\t\t(void *)Srandom1,   ETC },\n  \t{ \"srandom\",\t\"void (integer)\",\t\t(void *)Srandom2,   ETC },\n  \t{ \"eval\",\t\"flex (block <flex>)\",\t\t(void *)Eval,\t\tDECL_NIL|DECL_FLEX,                ETCf },\n  \t{ \"eval\",\t\"flex (const flex)\",\t\t(void *)Eval,\t\tDECL_NIL|DECL_FLEX,\t\t   ETCf },\n  \t{ \"sformat\",\t\"string (string, ...)\",\t\t(void *)s_sformat,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n  \t// ordinary logging\n  \t{ \"y2debug\",\t\"void (string, ...)\",\t\t(void *)Y2Debug,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n  \t{ \"y2milestone\",\"void (string, ...)\",\t\t(void *)Y2Milestone,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n  \t{ \"y2warning\",\t\"void (string, ...)\",\t\t(void *)Y2Warning,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n  \t{ \"y2error\",\t\"void (string, ...)\",\t\t(void *)Y2Error,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n  \t{ \"y2security\", \"void (string, ...)\",\t\t(void *)Y2Security,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n  \t{ \"y2internal\", \"void (string, ...)\",\t\t(void *)Y2Internal,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n  \t// logging with a different call frame\n  \t{ \"y2debug\",\t\"void (integer, string, ...)\",\t(void *)Y2FDebug,\tDECL_NIL|DECL_WILD,\t\t   ETCf },\n  \t{ \"y2milestone\",\"void (integer, string, ...)\",\t(void *)Y2FMilestone,\tDECL_NIL|DECL_WILD,\t\t   ETCf },\n  \t{ \"y2warning\",\t\"void (integer, string, ...)\",\t(void *)Y2FWarning,\tDECL_NIL|DECL_WILD,\t\t   ETCf },\n  \t{ \"y2error\",\t\"void (integer, string, ...)\",\t(void *)Y2FError,\tDECL_NIL|DECL_WILD,                ETCf },\n  \t{ \"y2security\", \"void (integer, string, ...)\",\t(void *)Y2FSecurity,\tDECL_NIL|DECL_WILD,\t\t   ETCf },\n  \t{ \"y2internal\", \"void (integer, string, ...)\",\t(void *)Y2FInternal,\tDECL_NIL|DECL_WILD,\t\t   ETCf },\n  \t// user-level logging\n  \t{ \"y2useritem\", \"void (string, ...)\",\t\t(void *)Y2UserItem,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n  \t{ \"y2usernote\", \"void (string, ...)\",\t\t(void *)Y2UserNote,\tDECL_NIL|DECL_WILD|DECL_FORMATTED, ETCf },\n  \t{ NULL, NULL, NULL, ETC }\n  #undef ETC\n  #undef ETCf\n      };\n  \n      static_declarations.registerDeclarations (\"YCPBuiltinMisc\", declarations);\n  }\n}"
  },
  {
    "function_name": "Y2UserNote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "647-673",
    "snippet": "static YCPValue\nY2UserNote (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2usernote\n     * @short Log an user-level addional message to the y2changes\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2usernote(\"Starting module Bee\")\n     */\n\n    YCPString arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    y2usernote (\"%s\", arg->value().c_str());\n    \n    return YCPVoid();\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2usernote",
          "args": [
            "\"%s\"",
            "arg->value().c_str()"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->value",
          "args": [],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->isString",
          "args": [],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_sformat",
          "args": [
            "format",
            "args"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "s_sformat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "271-350",
          "snippet": "static YCPString\ns_sformat (const YCPValue &format, const YCPValue &_argv)\n{\n    /**\n     * @builtin  sformat\n     * @short Format a String\n     * @description\n     * FORM is a string that may contains placeholders %1, %2, ...\n     * Each placeholder is substituted with the argument converted\n     * to string whose number is after the %. Only 1-9 are allowed\n     * by now. The percentage sign is donated with %%.\n     *\n     * @param string FORM\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return string\n     * @usage sformat (\"%2 is greater %% than %1\", 3, \"five\") -> \"five is greater % than 3\"\n     */\n     \n    if (format.isNull ()\n\t|| !format->isString())\n    {\n\treturn YCPNull ();\n    }\t\n    if (_argv.isNull ()\n\t|| !_argv->isList())\n    {\n\treturn format->asString();\n    }\n    YCPList argv = _argv->asList();\n\n    const char *read = format->asString()->value ().c_str ();\n\n    string result = \"\";\n    while (*read)\n    {\n\tif (*read == '%')\n\t{\n\t    read++;\n\t    if (*read == '%')\n\t    {\n\t\tresult += \"%\";\n\t    }\n\t    else if (*read >= '1' && *read <= '9')\n\t    {\n\t\tint num = *read - '0' - 1;\n\t\tif (argv->size () <= num)\n\t\t{\n\t\t    y2warning (\"Illegal argument number %%%d (max %d) in formatstring '%s'\",\n\t\t\t       num+1, argv->size (), format->asString ()->value ().c_str ());\n\t\t}\n\t\telse if (argv->value (num).isNull())\n\t\t{\n\t\t    result += \"<NULL>\";\n\t\t}\n\t\telse if (argv->value (num)->isString ())\n\t\t{\n\t\t    result += argv->value (num)->asString ()->value ();\n\t\t}\n\t\telse\n\t\t{\n\t\t    result += argv->value (num)->toString ();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ty2warning (\"%% in formatstring %s missing a number\",\n\t\t\t   format->asString ()->value ().c_str ());\n\t    }\n\t    read++;\n\t}\n\telse\n\t{\n\t    result += *read++;\n\t}\n    }\n\n    return YCPString (result);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPString\ns_sformat (const YCPValue &format, const YCPValue &_argv)\n{\n    /**\n     * @builtin  sformat\n     * @short Format a String\n     * @description\n     * FORM is a string that may contains placeholders %1, %2, ...\n     * Each placeholder is substituted with the argument converted\n     * to string whose number is after the %. Only 1-9 are allowed\n     * by now. The percentage sign is donated with %%.\n     *\n     * @param string FORM\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return string\n     * @usage sformat (\"%2 is greater %% than %1\", 3, \"five\") -> \"five is greater % than 3\"\n     */\n     \n    if (format.isNull ()\n\t|| !format->isString())\n    {\n\treturn YCPNull ();\n    }\t\n    if (_argv.isNull ()\n\t|| !_argv->isList())\n    {\n\treturn format->asString();\n    }\n    YCPList argv = _argv->asList();\n\n    const char *read = format->asString()->value ().c_str ();\n\n    string result = \"\";\n    while (*read)\n    {\n\tif (*read == '%')\n\t{\n\t    read++;\n\t    if (*read == '%')\n\t    {\n\t\tresult += \"%\";\n\t    }\n\t    else if (*read >= '1' && *read <= '9')\n\t    {\n\t\tint num = *read - '0' - 1;\n\t\tif (argv->size () <= num)\n\t\t{\n\t\t    y2warning (\"Illegal argument number %%%d (max %d) in formatstring '%s'\",\n\t\t\t       num+1, argv->size (), format->asString ()->value ().c_str ());\n\t\t}\n\t\telse if (argv->value (num).isNull())\n\t\t{\n\t\t    result += \"<NULL>\";\n\t\t}\n\t\telse if (argv->value (num)->isString ())\n\t\t{\n\t\t    result += argv->value (num)->asString ()->value ();\n\t\t}\n\t\telse\n\t\t{\n\t\t    result += argv->value (num)->toString ();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ty2warning (\"%% in formatstring %s missing a number\",\n\t\t\t   format->asString ()->value ().c_str ());\n\t    }\n\t    read++;\n\t}\n\telse\n\t{\n\t    result += *read++;\n\t}\n    }\n\n    return YCPString (result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2UserNote (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2usernote\n     * @short Log an user-level addional message to the y2changes\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2usernote(\"Starting module Bee\")\n     */\n\n    YCPString arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    y2usernote (\"%s\", arg->value().c_str());\n    \n    return YCPVoid();\n}"
  },
  {
    "function_name": "Y2UserItem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "618-644",
    "snippet": "static YCPValue\nY2UserItem (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2useritem\n     * @short Log an user-level system message to the y2changes\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2useritem(\"Executing reboot\")\n     */\n\n    YCPString arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    y2useritem (\"%s\", arg->value().c_str());\n    \n    return YCPVoid();\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2useritem",
          "args": [
            "\"%s\"",
            "arg->value().c_str()"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->value",
          "args": [],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->isString",
          "args": [],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_sformat",
          "args": [
            "format",
            "args"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "s_sformat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "271-350",
          "snippet": "static YCPString\ns_sformat (const YCPValue &format, const YCPValue &_argv)\n{\n    /**\n     * @builtin  sformat\n     * @short Format a String\n     * @description\n     * FORM is a string that may contains placeholders %1, %2, ...\n     * Each placeholder is substituted with the argument converted\n     * to string whose number is after the %. Only 1-9 are allowed\n     * by now. The percentage sign is donated with %%.\n     *\n     * @param string FORM\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return string\n     * @usage sformat (\"%2 is greater %% than %1\", 3, \"five\") -> \"five is greater % than 3\"\n     */\n     \n    if (format.isNull ()\n\t|| !format->isString())\n    {\n\treturn YCPNull ();\n    }\t\n    if (_argv.isNull ()\n\t|| !_argv->isList())\n    {\n\treturn format->asString();\n    }\n    YCPList argv = _argv->asList();\n\n    const char *read = format->asString()->value ().c_str ();\n\n    string result = \"\";\n    while (*read)\n    {\n\tif (*read == '%')\n\t{\n\t    read++;\n\t    if (*read == '%')\n\t    {\n\t\tresult += \"%\";\n\t    }\n\t    else if (*read >= '1' && *read <= '9')\n\t    {\n\t\tint num = *read - '0' - 1;\n\t\tif (argv->size () <= num)\n\t\t{\n\t\t    y2warning (\"Illegal argument number %%%d (max %d) in formatstring '%s'\",\n\t\t\t       num+1, argv->size (), format->asString ()->value ().c_str ());\n\t\t}\n\t\telse if (argv->value (num).isNull())\n\t\t{\n\t\t    result += \"<NULL>\";\n\t\t}\n\t\telse if (argv->value (num)->isString ())\n\t\t{\n\t\t    result += argv->value (num)->asString ()->value ();\n\t\t}\n\t\telse\n\t\t{\n\t\t    result += argv->value (num)->toString ();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ty2warning (\"%% in formatstring %s missing a number\",\n\t\t\t   format->asString ()->value ().c_str ());\n\t    }\n\t    read++;\n\t}\n\telse\n\t{\n\t    result += *read++;\n\t}\n    }\n\n    return YCPString (result);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPString\ns_sformat (const YCPValue &format, const YCPValue &_argv)\n{\n    /**\n     * @builtin  sformat\n     * @short Format a String\n     * @description\n     * FORM is a string that may contains placeholders %1, %2, ...\n     * Each placeholder is substituted with the argument converted\n     * to string whose number is after the %. Only 1-9 are allowed\n     * by now. The percentage sign is donated with %%.\n     *\n     * @param string FORM\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return string\n     * @usage sformat (\"%2 is greater %% than %1\", 3, \"five\") -> \"five is greater % than 3\"\n     */\n     \n    if (format.isNull ()\n\t|| !format->isString())\n    {\n\treturn YCPNull ();\n    }\t\n    if (_argv.isNull ()\n\t|| !_argv->isList())\n    {\n\treturn format->asString();\n    }\n    YCPList argv = _argv->asList();\n\n    const char *read = format->asString()->value ().c_str ();\n\n    string result = \"\";\n    while (*read)\n    {\n\tif (*read == '%')\n\t{\n\t    read++;\n\t    if (*read == '%')\n\t    {\n\t\tresult += \"%\";\n\t    }\n\t    else if (*read >= '1' && *read <= '9')\n\t    {\n\t\tint num = *read - '0' - 1;\n\t\tif (argv->size () <= num)\n\t\t{\n\t\t    y2warning (\"Illegal argument number %%%d (max %d) in formatstring '%s'\",\n\t\t\t       num+1, argv->size (), format->asString ()->value ().c_str ());\n\t\t}\n\t\telse if (argv->value (num).isNull())\n\t\t{\n\t\t    result += \"<NULL>\";\n\t\t}\n\t\telse if (argv->value (num)->isString ())\n\t\t{\n\t\t    result += argv->value (num)->asString ()->value ();\n\t\t}\n\t\telse\n\t\t{\n\t\t    result += argv->value (num)->toString ();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ty2warning (\"%% in formatstring %s missing a number\",\n\t\t\t   format->asString ()->value ().c_str ());\n\t    }\n\t    read++;\n\t}\n\telse\n\t{\n\t    result += *read++;\n\t}\n    }\n\n    return YCPString (result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2UserItem (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2useritem\n     * @short Log an user-level system message to the y2changes\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2useritem(\"Executing reboot\")\n     */\n\n    YCPString arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    y2useritem (\"%s\", arg->value().c_str());\n    \n    return YCPVoid();\n}"
  },
  {
    "function_name": "Y2FInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "598-615",
    "snippet": "static YCPValue\nY2FInternal (const YCPInteger & f, const YCPString & format, const YCPList & args)\n{\n  // FIXME: positive: pretend one of our callers invoked the log\n  // negative: print backtrace\n    extern ExecutionEnvironment ee;\n\n    int frame = f->value ();\n  \n    Y2Internal (format, args);\n\n    if (frame < 0)\n    {\n\tee.backtrace (LOG_INTERNAL, 0);\n    }\n\n    return YCPVoid ();\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.backtrace",
          "args": [
            "LOG_INTERNAL",
            "0"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "backtrace",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "123-142",
          "snippet": "void\nExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n{\n    if (m_backtrace.empty ())\n\treturn;\n\t\n    // FIXME: omit\n    CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n\n    y2logger(level, \"------------- Backtrace begin -------------\");\n    \n    while (it != m_backtrace.rend())\n    {\n\tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n\t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n\t++it;\n    };\n\n    y2logger(level, \"------------- Backtrace end ---------------\");\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n  {\n      if (m_backtrace.empty ())\n  \treturn;\n  \t\n      // FIXME: omit\n      CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n  \n      y2logger(level, \"------------- Backtrace begin -------------\");\n      \n      while (it != m_backtrace.rend())\n      {\n  \tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n  \t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n  \t++it;\n      };\n  \n      y2logger(level, \"------------- Backtrace end ---------------\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2Internal",
          "args": [
            "format",
            "args"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "Y2Internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "480-498",
          "snippet": "static YCPValue\nY2Internal (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2internal\n     * @short Log an internal message to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2internal(\"This is a robbery!\") -> \"This is a robbery!\"\n     */\n\n    return Y2Log (LOG_INTERNAL, format, args);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Internal (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2internal\n     * @short Log an internal message to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2internal(\"This is a robbery!\") -> \"This is a robbery!\"\n     */\n\n    return Y2Log (LOG_INTERNAL, format, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->value",
          "args": [],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2FInternal (const YCPInteger & f, const YCPString & format, const YCPList & args)\n{\n  // FIXME: positive: pretend one of our callers invoked the log\n  // negative: print backtrace\n    extern ExecutionEnvironment ee;\n\n    int frame = f->value ();\n  \n    Y2Internal (format, args);\n\n    if (frame < 0)\n    {\n\tee.backtrace (LOG_INTERNAL, 0);\n    }\n\n    return YCPVoid ();\n}"
  },
  {
    "function_name": "Y2FSecurity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "579-596",
    "snippet": "static YCPValue\nY2FSecurity (const YCPInteger & f, const YCPString & format, const YCPList & args)\n{\n  // FIXME: positive: pretend one of our callers invoked the log\n  // negative: print backtrace\n    extern ExecutionEnvironment ee;\n\n    int frame = f->value ();\n  \n    Y2Security (format, args);\n\n    if (frame < 0)\n    {\n\tee.backtrace (LOG_SECURITY, 0);\n    }\n\n    return YCPVoid ();\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.backtrace",
          "args": [
            "LOG_SECURITY",
            "0"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "backtrace",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "123-142",
          "snippet": "void\nExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n{\n    if (m_backtrace.empty ())\n\treturn;\n\t\n    // FIXME: omit\n    CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n\n    y2logger(level, \"------------- Backtrace begin -------------\");\n    \n    while (it != m_backtrace.rend())\n    {\n\tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n\t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n\t++it;\n    };\n\n    y2logger(level, \"------------- Backtrace end ---------------\");\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n  {\n      if (m_backtrace.empty ())\n  \treturn;\n  \t\n      // FIXME: omit\n      CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n  \n      y2logger(level, \"------------- Backtrace begin -------------\");\n      \n      while (it != m_backtrace.rend())\n      {\n  \tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n  \t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n  \t++it;\n      };\n  \n      y2logger(level, \"------------- Backtrace end ---------------\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2Security",
          "args": [
            "format",
            "args"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "Y2Security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "459-477",
          "snippet": "static YCPValue\nY2Security (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2security\n     * @short Log a security message to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2security (\"Users on vacations: %1\", [\"josh\", \"joe\", \"pete\"]) -> \"Users on vacations: [\"josh\", \"joe\", \"pete\"]\"\n     */\n\n    return Y2Log (LOG_SECURITY, format, args);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Security (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2security\n     * @short Log a security message to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2security (\"Users on vacations: %1\", [\"josh\", \"joe\", \"pete\"]) -> \"Users on vacations: [\"josh\", \"joe\", \"pete\"]\"\n     */\n\n    return Y2Log (LOG_SECURITY, format, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->value",
          "args": [],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2FSecurity (const YCPInteger & f, const YCPString & format, const YCPList & args)\n{\n  // FIXME: positive: pretend one of our callers invoked the log\n  // negative: print backtrace\n    extern ExecutionEnvironment ee;\n\n    int frame = f->value ();\n  \n    Y2Security (format, args);\n\n    if (frame < 0)\n    {\n\tee.backtrace (LOG_SECURITY, 0);\n    }\n\n    return YCPVoid ();\n}"
  },
  {
    "function_name": "Y2FError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "560-577",
    "snippet": "static YCPValue\nY2FError (const YCPInteger & f, const YCPString & format, const YCPList & args)\n{\n  // FIXME: positive: pretend one of our callers invoked the log\n  // negative: print backtrace\n    extern ExecutionEnvironment ee;\n\n    int frame = f->value ();\n  \n    Y2Error (format, args);\n\n    if (frame < 0)\n    {\n\tee.backtrace (LOG_ERROR, 0);\n    }\n\n    return YCPVoid ();\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.backtrace",
          "args": [
            "LOG_ERROR",
            "0"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "backtrace",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "123-142",
          "snippet": "void\nExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n{\n    if (m_backtrace.empty ())\n\treturn;\n\t\n    // FIXME: omit\n    CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n\n    y2logger(level, \"------------- Backtrace begin -------------\");\n    \n    while (it != m_backtrace.rend())\n    {\n\tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n\t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n\t++it;\n    };\n\n    y2logger(level, \"------------- Backtrace end ---------------\");\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n  {\n      if (m_backtrace.empty ())\n  \treturn;\n  \t\n      // FIXME: omit\n      CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n  \n      y2logger(level, \"------------- Backtrace begin -------------\");\n      \n      while (it != m_backtrace.rend())\n      {\n  \tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n  \t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n  \t++it;\n      };\n  \n      y2logger(level, \"------------- Backtrace end ---------------\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2Error",
          "args": [
            "format",
            "args"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "Y2Error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "438-456",
          "snippet": "static YCPValue\nY2Error (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2error\n     * @short Log an error to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2error (\"Invalid format of IPv4 '%1'.\", \"333.10.20.1\") -> \"Invalid format of IPv4 '333.10.20.1'\"\n     */\n\n    return Y2Log (LOG_ERROR, format, args);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Error (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2error\n     * @short Log an error to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2error (\"Invalid format of IPv4 '%1'.\", \"333.10.20.1\") -> \"Invalid format of IPv4 '333.10.20.1'\"\n     */\n\n    return Y2Log (LOG_ERROR, format, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->value",
          "args": [],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2FError (const YCPInteger & f, const YCPString & format, const YCPList & args)\n{\n  // FIXME: positive: pretend one of our callers invoked the log\n  // negative: print backtrace\n    extern ExecutionEnvironment ee;\n\n    int frame = f->value ();\n  \n    Y2Error (format, args);\n\n    if (frame < 0)\n    {\n\tee.backtrace (LOG_ERROR, 0);\n    }\n\n    return YCPVoid ();\n}"
  },
  {
    "function_name": "Y2FWarning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "541-558",
    "snippet": "static YCPValue\nY2FWarning (const YCPInteger & f, const YCPString & format, const YCPList & args)\n{\n  // FIXME: positive: pretend one of our callers invoked the log\n  // negative: print backtrace\n    extern ExecutionEnvironment ee;\n\n    int frame = f->value ();\n  \n    Y2Warning (format, args);\n\n    if (frame < 0)\n    {\n\tee.backtrace (LOG_WARNING, 0);\n    }\n\n    return YCPVoid ();\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.backtrace",
          "args": [
            "LOG_WARNING",
            "0"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "backtrace",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "123-142",
          "snippet": "void\nExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n{\n    if (m_backtrace.empty ())\n\treturn;\n\t\n    // FIXME: omit\n    CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n\n    y2logger(level, \"------------- Backtrace begin -------------\");\n    \n    while (it != m_backtrace.rend())\n    {\n\tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n\t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n\t++it;\n    };\n\n    y2logger(level, \"------------- Backtrace end ---------------\");\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n  {\n      if (m_backtrace.empty ())\n  \treturn;\n  \t\n      // FIXME: omit\n      CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n  \n      y2logger(level, \"------------- Backtrace begin -------------\");\n      \n      while (it != m_backtrace.rend())\n      {\n  \tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n  \t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n  \t++it;\n      };\n  \n      y2logger(level, \"------------- Backtrace end ---------------\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2Warning",
          "args": [
            "format",
            "args"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "Y2Warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "416-435",
          "snippet": "static YCPValue\nY2Warning (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2warning\n     * @short Log a warning to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2warning (\"Breakers don't work!\") -> \"Breakers don't work!\"\n     * @usage y2warning (\"%1 %2 packets have been lost\", 12, \"UDP\") -> \"12 UDP packets have been lost\"\n     */\n\n    return Y2Log (LOG_WARNING, format, args);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Warning (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2warning\n     * @short Log a warning to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2warning (\"Breakers don't work!\") -> \"Breakers don't work!\"\n     * @usage y2warning (\"%1 %2 packets have been lost\", 12, \"UDP\") -> \"12 UDP packets have been lost\"\n     */\n\n    return Y2Log (LOG_WARNING, format, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->value",
          "args": [],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2FWarning (const YCPInteger & f, const YCPString & format, const YCPList & args)\n{\n  // FIXME: positive: pretend one of our callers invoked the log\n  // negative: print backtrace\n    extern ExecutionEnvironment ee;\n\n    int frame = f->value ();\n  \n    Y2Warning (format, args);\n\n    if (frame < 0)\n    {\n\tee.backtrace (LOG_WARNING, 0);\n    }\n\n    return YCPVoid ();\n}"
  },
  {
    "function_name": "Y2FMilestone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "522-539",
    "snippet": "static YCPValue\nY2FMilestone (const YCPInteger & f, const YCPString & format, const YCPList & args)\n{\n  // FIXME: positive: pretend one of our callers invoked the log\n  // negative: print backtrace\n    extern ExecutionEnvironment ee;\n\n    int frame = f->value ();\n  \n    Y2Milestone (format, args);\n\n    if (frame < 0)\n    {\n\tee.backtrace (LOG_MILESTONE, 0);\n    }\n\n    return YCPVoid ();\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.backtrace",
          "args": [
            "LOG_MILESTONE",
            "0"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "backtrace",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "123-142",
          "snippet": "void\nExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n{\n    if (m_backtrace.empty ())\n\treturn;\n\t\n    // FIXME: omit\n    CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n\n    y2logger(level, \"------------- Backtrace begin -------------\");\n    \n    while (it != m_backtrace.rend())\n    {\n\tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n\t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n\t++it;\n    };\n\n    y2logger(level, \"------------- Backtrace end ---------------\");\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n  {\n      if (m_backtrace.empty ())\n  \treturn;\n  \t\n      // FIXME: omit\n      CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n  \n      y2logger(level, \"------------- Backtrace begin -------------\");\n      \n      while (it != m_backtrace.rend())\n      {\n  \tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n  \t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n  \t++it;\n      };\n  \n      y2logger(level, \"------------- Backtrace end ---------------\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2Milestone",
          "args": [
            "format",
            "args"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "Y2Milestone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "395-413",
          "snippet": "static YCPValue\nY2Milestone (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2milestone\n     * @short Log a milestone to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2milestone(\"%1 - Humans detected!\", \"2038-02-12\") -> \"2038-02-12 - Humans detected!\"\n     */\n\n    return Y2Log (LOG_MILESTONE, format, args);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Milestone (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2milestone\n     * @short Log a milestone to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2milestone(\"%1 - Humans detected!\", \"2038-02-12\") -> \"2038-02-12 - Humans detected!\"\n     */\n\n    return Y2Log (LOG_MILESTONE, format, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->value",
          "args": [],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2FMilestone (const YCPInteger & f, const YCPString & format, const YCPList & args)\n{\n  // FIXME: positive: pretend one of our callers invoked the log\n  // negative: print backtrace\n    extern ExecutionEnvironment ee;\n\n    int frame = f->value ();\n  \n    Y2Milestone (format, args);\n\n    if (frame < 0)\n    {\n\tee.backtrace (LOG_MILESTONE, 0);\n    }\n\n    return YCPVoid ();\n}"
  },
  {
    "function_name": "Y2FDebug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "502-520",
    "snippet": "static YCPValue\nY2FDebug (const YCPInteger & f, const YCPString & format, const YCPList & args)\n{\n\n  // FIXME: positive: pretend one of our callers invoked the log\n  // negative: print backtrace\n    extern ExecutionEnvironment ee;\n\n    int frame = f->value ();\n  \n    Y2Debug (format, args);\n\n    if (frame < 0)\n    {\n\tee.backtrace (LOG_DEBUG, 0);\n    }\n\n    return YCPVoid ();\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.backtrace",
          "args": [
            "LOG_DEBUG",
            "0"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "backtrace",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "123-142",
          "snippet": "void\nExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n{\n    if (m_backtrace.empty ())\n\treturn;\n\t\n    // FIXME: omit\n    CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n\n    y2logger(level, \"------------- Backtrace begin -------------\");\n    \n    while (it != m_backtrace.rend())\n    {\n\tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n\t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n\t++it;\n    };\n\n    y2logger(level, \"------------- Backtrace end ---------------\");\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  void\n  ExecutionEnvironment::backtrace (loglevel_t level, uint omit) const\n  {\n      if (m_backtrace.empty ())\n  \treturn;\n  \t\n      // FIXME: omit\n      CallStack::const_reverse_iterator it = m_backtrace.rbegin();\n  \n      y2logger(level, \"------------- Backtrace begin -------------\");\n      \n      while (it != m_backtrace.rend())\n      {\n  \tycp2log (level, (*it)->filename.c_str (), (*it)->linenumber\n  \t\t , \"\", \"%s\", (*it)->function->entry()->toString().c_str());\n  \t++it;\n      };\n  \n      y2logger(level, \"------------- Backtrace end ---------------\");\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Y2Debug",
          "args": [
            "format",
            "args"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "Y2Debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "370-393",
          "snippet": "static YCPValue\nY2Debug (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2debug\n     * @short Log a message to the y2log.\n     *\n     * @description\n     * Arguments are same as for sformat() builtin.\n     * The y2log component is \"YCP\", so you can control these messages the\n     * same way as other y2log messages.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2debug (\"%1 is smaller than %2\", 7, \"13\");\n     */\n\n    return Y2Log (LOG_DEBUG, format, args);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Debug (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2debug\n     * @short Log a message to the y2log.\n     *\n     * @description\n     * Arguments are same as for sformat() builtin.\n     * The y2log component is \"YCP\", so you can control these messages the\n     * same way as other y2log messages.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2debug (\"%1 is smaller than %2\", 7, \"13\");\n     */\n\n    return Y2Log (LOG_DEBUG, format, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->value",
          "args": [],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2FDebug (const YCPInteger & f, const YCPString & format, const YCPList & args)\n{\n\n  // FIXME: positive: pretend one of our callers invoked the log\n  // negative: print backtrace\n    extern ExecutionEnvironment ee;\n\n    int frame = f->value ();\n  \n    Y2Debug (format, args);\n\n    if (frame < 0)\n    {\n\tee.backtrace (LOG_DEBUG, 0);\n    }\n\n    return YCPVoid ();\n}"
  },
  {
    "function_name": "Y2Internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "480-498",
    "snippet": "static YCPValue\nY2Internal (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2internal\n     * @short Log an internal message to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2internal(\"This is a robbery!\") -> \"This is a robbery!\"\n     */\n\n    return Y2Log (LOG_INTERNAL, format, args);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y2Log",
          "args": [
            "LOG_INTERNAL",
            "format",
            "args"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "Y2Log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "352-367",
          "snippet": "static YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Internal (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2internal\n     * @short Log an internal message to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2internal(\"This is a robbery!\") -> \"This is a robbery!\"\n     */\n\n    return Y2Log (LOG_INTERNAL, format, args);\n}"
  },
  {
    "function_name": "Y2Security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "459-477",
    "snippet": "static YCPValue\nY2Security (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2security\n     * @short Log a security message to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2security (\"Users on vacations: %1\", [\"josh\", \"joe\", \"pete\"]) -> \"Users on vacations: [\"josh\", \"joe\", \"pete\"]\"\n     */\n\n    return Y2Log (LOG_SECURITY, format, args);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y2Log",
          "args": [
            "LOG_SECURITY",
            "format",
            "args"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "Y2Log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "352-367",
          "snippet": "static YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Security (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2security\n     * @short Log a security message to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2security (\"Users on vacations: %1\", [\"josh\", \"joe\", \"pete\"]) -> \"Users on vacations: [\"josh\", \"joe\", \"pete\"]\"\n     */\n\n    return Y2Log (LOG_SECURITY, format, args);\n}"
  },
  {
    "function_name": "Y2Error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "438-456",
    "snippet": "static YCPValue\nY2Error (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2error\n     * @short Log an error to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2error (\"Invalid format of IPv4 '%1'.\", \"333.10.20.1\") -> \"Invalid format of IPv4 '333.10.20.1'\"\n     */\n\n    return Y2Log (LOG_ERROR, format, args);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y2Log",
          "args": [
            "LOG_ERROR",
            "format",
            "args"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "Y2Log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "352-367",
          "snippet": "static YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Error (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2error\n     * @short Log an error to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2error (\"Invalid format of IPv4 '%1'.\", \"333.10.20.1\") -> \"Invalid format of IPv4 '333.10.20.1'\"\n     */\n\n    return Y2Log (LOG_ERROR, format, args);\n}"
  },
  {
    "function_name": "Y2Warning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "416-435",
    "snippet": "static YCPValue\nY2Warning (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2warning\n     * @short Log a warning to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2warning (\"Breakers don't work!\") -> \"Breakers don't work!\"\n     * @usage y2warning (\"%1 %2 packets have been lost\", 12, \"UDP\") -> \"12 UDP packets have been lost\"\n     */\n\n    return Y2Log (LOG_WARNING, format, args);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y2Log",
          "args": [
            "LOG_WARNING",
            "format",
            "args"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "Y2Log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "352-367",
          "snippet": "static YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Warning (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2warning\n     * @short Log a warning to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2warning (\"Breakers don't work!\") -> \"Breakers don't work!\"\n     * @usage y2warning (\"%1 %2 packets have been lost\", 12, \"UDP\") -> \"12 UDP packets have been lost\"\n     */\n\n    return Y2Log (LOG_WARNING, format, args);\n}"
  },
  {
    "function_name": "Y2Milestone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "395-413",
    "snippet": "static YCPValue\nY2Milestone (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2milestone\n     * @short Log a milestone to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2milestone(\"%1 - Humans detected!\", \"2038-02-12\") -> \"2038-02-12 - Humans detected!\"\n     */\n\n    return Y2Log (LOG_MILESTONE, format, args);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y2Log",
          "args": [
            "LOG_MILESTONE",
            "format",
            "args"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "Y2Log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "352-367",
          "snippet": "static YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Milestone (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2milestone\n     * @short Log a milestone to the y2log.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2milestone(\"%1 - Humans detected!\", \"2038-02-12\") -> \"2038-02-12 - Humans detected!\"\n     */\n\n    return Y2Log (LOG_MILESTONE, format, args);\n}"
  },
  {
    "function_name": "Y2Debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "370-393",
    "snippet": "static YCPValue\nY2Debug (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2debug\n     * @short Log a message to the y2log.\n     *\n     * @description\n     * Arguments are same as for sformat() builtin.\n     * The y2log component is \"YCP\", so you can control these messages the\n     * same way as other y2log messages.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2debug (\"%1 is smaller than %2\", 7, \"13\");\n     */\n\n    return Y2Log (LOG_DEBUG, format, args);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Y2Log",
          "args": [
            "LOG_DEBUG",
            "format",
            "args"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "Y2Log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "352-367",
          "snippet": "static YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Debug (const YCPString & format, const YCPList & args)\n{\n    /**\n     * @builtin y2debug\n     * @short Log a message to the y2log.\n     *\n     * @description\n     * Arguments are same as for sformat() builtin.\n     * The y2log component is \"YCP\", so you can control these messages the\n     * same way as other y2log messages.\n     *\n     * @param string FORMAT\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return void\n     * @see sformat\n     *\n     * @usage y2debug (\"%1 is smaller than %2\", 7, \"13\");\n     */\n\n    return Y2Log (LOG_DEBUG, format, args);\n}"
  },
  {
    "function_name": "Y2Log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "352-367",
    "snippet": "static YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2log",
          "args": [
            "level",
            "ee.filename().c_str()",
            "ee.linenumber()",
            "\"\"",
            "\"%s\"",
            "arg->asString ()->value ().c_str ()"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->asString",
          "args": [],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.linenumber",
          "args": [],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "linenumber",
          "container": "ExecutionEnvironment",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/ExecutionEnvironment.cc",
          "lines": "41-45",
          "snippet": "int\nExecutionEnvironment::linenumber () const\n{\n    return m_linenumber;\n}",
          "includes": [
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/YStatement.h\"",
            "#include \"ycp/ExecutionEnvironment.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/y2log.h\"\n#include \"ycp/YStatement.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n\nExecutionEnvironment {\n  int\n  ExecutionEnvironment::linenumber () const\n  {\n      return m_linenumber;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ee.filename",
          "args": [],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "filename",
          "container": "Scanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/Scanner.cc",
          "lines": "335-339",
          "snippet": "string\nScanner::filename () const\n{\n    return m_filename;\n}",
          "includes": [
            "#include \"ycp/SymbolTable.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/Scanner.h\"",
            "#include <errno.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/SymbolTable.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/Scanner.h\"\n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <string>\n\nScanner {\n  string\n  Scanner::filename () const\n  {\n      return m_filename;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arg->isString",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg.isNull",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_sformat",
          "args": [
            "format",
            "args"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "s_sformat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "271-350",
          "snippet": "static YCPString\ns_sformat (const YCPValue &format, const YCPValue &_argv)\n{\n    /**\n     * @builtin  sformat\n     * @short Format a String\n     * @description\n     * FORM is a string that may contains placeholders %1, %2, ...\n     * Each placeholder is substituted with the argument converted\n     * to string whose number is after the %. Only 1-9 are allowed\n     * by now. The percentage sign is donated with %%.\n     *\n     * @param string FORM\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return string\n     * @usage sformat (\"%2 is greater %% than %1\", 3, \"five\") -> \"five is greater % than 3\"\n     */\n     \n    if (format.isNull ()\n\t|| !format->isString())\n    {\n\treturn YCPNull ();\n    }\t\n    if (_argv.isNull ()\n\t|| !_argv->isList())\n    {\n\treturn format->asString();\n    }\n    YCPList argv = _argv->asList();\n\n    const char *read = format->asString()->value ().c_str ();\n\n    string result = \"\";\n    while (*read)\n    {\n\tif (*read == '%')\n\t{\n\t    read++;\n\t    if (*read == '%')\n\t    {\n\t\tresult += \"%\";\n\t    }\n\t    else if (*read >= '1' && *read <= '9')\n\t    {\n\t\tint num = *read - '0' - 1;\n\t\tif (argv->size () <= num)\n\t\t{\n\t\t    y2warning (\"Illegal argument number %%%d (max %d) in formatstring '%s'\",\n\t\t\t       num+1, argv->size (), format->asString ()->value ().c_str ());\n\t\t}\n\t\telse if (argv->value (num).isNull())\n\t\t{\n\t\t    result += \"<NULL>\";\n\t\t}\n\t\telse if (argv->value (num)->isString ())\n\t\t{\n\t\t    result += argv->value (num)->asString ()->value ();\n\t\t}\n\t\telse\n\t\t{\n\t\t    result += argv->value (num)->toString ();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ty2warning (\"%% in formatstring %s missing a number\",\n\t\t\t   format->asString ()->value ().c_str ());\n\t    }\n\t    read++;\n\t}\n\telse\n\t{\n\t    result += *read++;\n\t}\n    }\n\n    return YCPString (result);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPString\ns_sformat (const YCPValue &format, const YCPValue &_argv)\n{\n    /**\n     * @builtin  sformat\n     * @short Format a String\n     * @description\n     * FORM is a string that may contains placeholders %1, %2, ...\n     * Each placeholder is substituted with the argument converted\n     * to string whose number is after the %. Only 1-9 are allowed\n     * by now. The percentage sign is donated with %%.\n     *\n     * @param string FORM\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return string\n     * @usage sformat (\"%2 is greater %% than %1\", 3, \"five\") -> \"five is greater % than 3\"\n     */\n     \n    if (format.isNull ()\n\t|| !format->isString())\n    {\n\treturn YCPNull ();\n    }\t\n    if (_argv.isNull ()\n\t|| !_argv->isList())\n    {\n\treturn format->asString();\n    }\n    YCPList argv = _argv->asList();\n\n    const char *read = format->asString()->value ().c_str ();\n\n    string result = \"\";\n    while (*read)\n    {\n\tif (*read == '%')\n\t{\n\t    read++;\n\t    if (*read == '%')\n\t    {\n\t\tresult += \"%\";\n\t    }\n\t    else if (*read >= '1' && *read <= '9')\n\t    {\n\t\tint num = *read - '0' - 1;\n\t\tif (argv->size () <= num)\n\t\t{\n\t\t    y2warning (\"Illegal argument number %%%d (max %d) in formatstring '%s'\",\n\t\t\t       num+1, argv->size (), format->asString ()->value ().c_str ());\n\t\t}\n\t\telse if (argv->value (num).isNull())\n\t\t{\n\t\t    result += \"<NULL>\";\n\t\t}\n\t\telse if (argv->value (num)->isString ())\n\t\t{\n\t\t    result += argv->value (num)->asString ()->value ();\n\t\t}\n\t\telse\n\t\t{\n\t\t    result += argv->value (num)->toString ();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ty2warning (\"%% in formatstring %s missing a number\",\n\t\t\t   format->asString ()->value ().c_str ());\n\t    }\n\t    read++;\n\t}\n\telse\n\t{\n\t    result += *read++;\n\t}\n    }\n\n    return YCPString (result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nY2Log (loglevel_t level, const YCPString & format, const YCPList & args)\n{\n    YCPValue arg = s_sformat (format, args);\n    if (arg.isNull () || !arg->isString ())\n    {\n\treturn YCPNull ();\n    }\n\n    extern ExecutionEnvironment ee;\n\n    // The \"\" is a function name. TODO.  It will be useful but may\n    // break ycp testsuites. Maybe it's the right time to do it.\n    ycp2log (level, ee.filename().c_str(), ee.linenumber(), \"\", \"%s\", arg->asString ()->value ().c_str ());\n    return YCPVoid ();\n}"
  },
  {
    "function_name": "s_sformat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "271-350",
    "snippet": "static YCPString\ns_sformat (const YCPValue &format, const YCPValue &_argv)\n{\n    /**\n     * @builtin  sformat\n     * @short Format a String\n     * @description\n     * FORM is a string that may contains placeholders %1, %2, ...\n     * Each placeholder is substituted with the argument converted\n     * to string whose number is after the %. Only 1-9 are allowed\n     * by now. The percentage sign is donated with %%.\n     *\n     * @param string FORM\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return string\n     * @usage sformat (\"%2 is greater %% than %1\", 3, \"five\") -> \"five is greater % than 3\"\n     */\n     \n    if (format.isNull ()\n\t|| !format->isString())\n    {\n\treturn YCPNull ();\n    }\t\n    if (_argv.isNull ()\n\t|| !_argv->isList())\n    {\n\treturn format->asString();\n    }\n    YCPList argv = _argv->asList();\n\n    const char *read = format->asString()->value ().c_str ();\n\n    string result = \"\";\n    while (*read)\n    {\n\tif (*read == '%')\n\t{\n\t    read++;\n\t    if (*read == '%')\n\t    {\n\t\tresult += \"%\";\n\t    }\n\t    else if (*read >= '1' && *read <= '9')\n\t    {\n\t\tint num = *read - '0' - 1;\n\t\tif (argv->size () <= num)\n\t\t{\n\t\t    y2warning (\"Illegal argument number %%%d (max %d) in formatstring '%s'\",\n\t\t\t       num+1, argv->size (), format->asString ()->value ().c_str ());\n\t\t}\n\t\telse if (argv->value (num).isNull())\n\t\t{\n\t\t    result += \"<NULL>\";\n\t\t}\n\t\telse if (argv->value (num)->isString ())\n\t\t{\n\t\t    result += argv->value (num)->asString ()->value ();\n\t\t}\n\t\telse\n\t\t{\n\t\t    result += argv->value (num)->toString ();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ty2warning (\"%% in formatstring %s missing a number\",\n\t\t\t   format->asString ()->value ().c_str ());\n\t    }\n\t    read++;\n\t}\n\telse\n\t{\n\t    result += *read++;\n\t}\n    }\n\n    return YCPString (result);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "result"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString",
          "container": "YCPString",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "152-155",
          "snippet": "YCPString::YCPString (bytecodeistream & str)\n    : YCPValue (new YCPStringRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPString {\n  YCPString::YCPString (bytecodeistream & str)\n      : YCPValue (new YCPStringRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"%% in formatstring %s missing a number\"",
            "format->asString ()->value ().c_str ()"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format->asString",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv->value",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv->value",
          "args": [
            "num"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "125-129",
          "snippet": "YCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  YCPValue\n  YCPTermRep::value (int n) const\n  {\n      return l->value(n);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "y2warning",
          "args": [
            "\"Illegal argument number %%%d (max %d) in formatstring '%s'\"",
            "num+1",
            "argv->size ()",
            "format->asString ()->value ().c_str ()"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv->size",
          "args": [],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "YCPTermRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPTerm.cc",
          "lines": "109-113",
          "snippet": "int\nYCPTermRep::size() const\n{\n    return l->size();\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/y2log.h\"\n\nYCPTermRep {\n  int\n  YCPTermRep::size() const\n  {\n      return l->size();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_argv->asList",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "asList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "179-189",
          "snippet": "YCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPList\n  YCPValueRep::asList() const\n  {\n      if (!isList())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPList (static_cast<const YCPListRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_argv->isList",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "69-69",
          "snippet": "bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_argv.isNull",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format->isString",
          "args": [],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "isString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "65-65",
          "snippet": "bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "format.isNull",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPString\ns_sformat (const YCPValue &format, const YCPValue &_argv)\n{\n    /**\n     * @builtin  sformat\n     * @short Format a String\n     * @description\n     * FORM is a string that may contains placeholders %1, %2, ...\n     * Each placeholder is substituted with the argument converted\n     * to string whose number is after the %. Only 1-9 are allowed\n     * by now. The percentage sign is donated with %%.\n     *\n     * @param string FORM\n     * @param any PAR1\n     * @param any PAR2\n     * @param any ...\n     * @return string\n     * @usage sformat (\"%2 is greater %% than %1\", 3, \"five\") -> \"five is greater % than 3\"\n     */\n     \n    if (format.isNull ()\n\t|| !format->isString())\n    {\n\treturn YCPNull ();\n    }\t\n    if (_argv.isNull ()\n\t|| !_argv->isList())\n    {\n\treturn format->asString();\n    }\n    YCPList argv = _argv->asList();\n\n    const char *read = format->asString()->value ().c_str ();\n\n    string result = \"\";\n    while (*read)\n    {\n\tif (*read == '%')\n\t{\n\t    read++;\n\t    if (*read == '%')\n\t    {\n\t\tresult += \"%\";\n\t    }\n\t    else if (*read >= '1' && *read <= '9')\n\t    {\n\t\tint num = *read - '0' - 1;\n\t\tif (argv->size () <= num)\n\t\t{\n\t\t    y2warning (\"Illegal argument number %%%d (max %d) in formatstring '%s'\",\n\t\t\t       num+1, argv->size (), format->asString ()->value ().c_str ());\n\t\t}\n\t\telse if (argv->value (num).isNull())\n\t\t{\n\t\t    result += \"<NULL>\";\n\t\t}\n\t\telse if (argv->value (num)->isString ())\n\t\t{\n\t\t    result += argv->value (num)->asString ()->value ();\n\t\t}\n\t\telse\n\t\t{\n\t\t    result += argv->value (num)->toString ();\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ty2warning (\"%% in formatstring %s missing a number\",\n\t\t\t   format->asString ()->value ().c_str ());\n\t    }\n\t    read++;\n\t}\n\telse\n\t{\n\t    result += *read++;\n\t}\n    }\n\n    return YCPString (result);\n}"
  },
  {
    "function_name": "Eval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "247-268",
    "snippet": "static YCPValue\nEval (const YCPValue & v)\n{\n    /**\n     * @builtin eval\n     * @short Evaluate a YCP value.\n     * @description\n     * See also the builtin ``, which is kind of the counterpart to eval.\n     *\n     * @usage eval (``(1+2)) -> 3\n     */\n\n    if (v.isNull ())\n    {\n\treturn YCPNull ();\n    }\n    if (!v->isCode())\n    {\n\treturn v;\n    }\n    return v->asCode()->evaluate();\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v->asCode",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "asCode",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "215-225",
          "snippet": "YCPCode\nYCPValueRep::asCode() const\n{\n    if (!isCode())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Code !\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPCode (static_cast<const YCPCodeRep*>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPCode\n  YCPValueRep::asCode() const\n  {\n      if (!isCode())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Code !\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPCode (static_cast<const YCPCodeRep*>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->isCode",
          "args": [],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "isCode",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "72-72",
          "snippet": "bool YCPValueRep::isCode()\t  const { return valuetype() == YT_CODE; }",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  bool YCPValueRep::isCode()\t  const { return valuetype() == YT_CODE; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.isNull",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nEval (const YCPValue & v)\n{\n    /**\n     * @builtin eval\n     * @short Evaluate a YCP value.\n     * @description\n     * See also the builtin ``, which is kind of the counterpart to eval.\n     *\n     * @usage eval (``(1+2)) -> 3\n     */\n\n    if (v.isNull ())\n    {\n\treturn YCPNull ();\n    }\n    if (!v->isCode())\n    {\n\treturn v;\n    }\n    return v->asCode()->evaluate();\n}"
  },
  {
    "function_name": "Getenv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "220-244",
    "snippet": "static YCPString\nGetenv (const YCPString & name)\n{\n     /**\n     * @builtin getenv\n     * @short Change or add an environment variable\n     * @description\n     * The getenv(variable) function returns the value of variable from\n     * environment. If variable doesn't exist\n     * the value is NULL.\n     *\n     * @param string name\n     * @return string value\n     * @usage getenv (\"USER\") -> \"root\"\n     * @usage getenv (\"LC_CTYPE\") -> \"en_US.UTF-8\"\n     */\n \n    char *value = getenv(name->value().c_str());\n    if (value) { \n        string ret (value);        \n        return YCPString(ret);\n    } else {\n        return YCPNull();\n    }\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YCPString",
          "args": [
            "ret"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "YCPString",
          "container": "YCPString",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "152-155",
          "snippet": "YCPString::YCPString (bytecodeistream & str)\n    : YCPValue (new YCPStringRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPString {\n  YCPString::YCPString (bytecodeistream & str)\n      : YCPValue (new YCPStringRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "name->value().c_str()"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name->value",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPString\nGetenv (const YCPString & name)\n{\n     /**\n     * @builtin getenv\n     * @short Change or add an environment variable\n     * @description\n     * The getenv(variable) function returns the value of variable from\n     * environment. If variable doesn't exist\n     * the value is NULL.\n     *\n     * @param string name\n     * @return string value\n     * @usage getenv (\"USER\") -> \"root\"\n     * @usage getenv (\"LC_CTYPE\") -> \"en_US.UTF-8\"\n     */\n \n    char *value = getenv(name->value().c_str());\n    if (value) { \n        string ret (value);        \n        return YCPString(ret);\n    } else {\n        return YCPNull();\n    }\n}"
  },
  {
    "function_name": "Setenv1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "196-217",
    "snippet": "static YCPBoolean\nSetenv1 (const YCPString & name, const YCPString & value)\n{\n    /**\n     * @builtin setenv\n     * @short Change or add an environment variable\n     * @description\n     * The setenv() function adds the variable to the\n     * environment with the value. If variable exist\n     * the value is changed.\n     *\n     * @param string variable\n     * @param string value\n     * @return boolean\n     * @id setenv-always\n     * @usage setenv(\"PATH\", \"/home/user\")\n     */\n    //3rd argument (1) means that value will be overwrite if it exist\n\n    return Setenv2(name, value, YCPBoolean(true));\n\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Setenv2",
          "args": [
            "name",
            "value",
            "YCPBoolean(true)"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "Setenv2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "167-193",
          "snippet": "static YCPBoolean\nSetenv2 (const YCPString & name, const YCPString & value, const YCPBoolean & overwrite)\n{\n    /**\n     * @builtin setenv\n     * @short Change or add an environment variable\n     * @description\n     * The setenv() function adds the variable to the\n     * environment with the value. If variable exist\n     * the value is changed.\n     *\n     * @param string variable\n     * @param string value\n     * @param boolean overwrite\n     * @return boolean\n     * @id setenv-choose\n     * @usage setenv(\"PATH\", \"/home/user\", true)\n     */\n    //3rd argument (1) means that value will be overwrite if it exist\n    int ret = setenv(name->value().c_str(), value->value().c_str(), (overwrite->value() ? 1:0) ); \n    if (ret == 0) {\n        return YCPBoolean(true);\n    } else { \n        ycp2error (\"[Setenv1] failed %s\",strerror(errno));\n        return YCPBoolean(false);\n    }\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPBoolean\nSetenv2 (const YCPString & name, const YCPString & value, const YCPBoolean & overwrite)\n{\n    /**\n     * @builtin setenv\n     * @short Change or add an environment variable\n     * @description\n     * The setenv() function adds the variable to the\n     * environment with the value. If variable exist\n     * the value is changed.\n     *\n     * @param string variable\n     * @param string value\n     * @param boolean overwrite\n     * @return boolean\n     * @id setenv-choose\n     * @usage setenv(\"PATH\", \"/home/user\", true)\n     */\n    //3rd argument (1) means that value will be overwrite if it exist\n    int ret = setenv(name->value().c_str(), value->value().c_str(), (overwrite->value() ? 1:0) ); \n    if (ret == 0) {\n        return YCPBoolean(true);\n    } else { \n        ycp2error (\"[Setenv1] failed %s\",strerror(errno));\n        return YCPBoolean(false);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "true"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPBoolean\nSetenv1 (const YCPString & name, const YCPString & value)\n{\n    /**\n     * @builtin setenv\n     * @short Change or add an environment variable\n     * @description\n     * The setenv() function adds the variable to the\n     * environment with the value. If variable exist\n     * the value is changed.\n     *\n     * @param string variable\n     * @param string value\n     * @return boolean\n     * @id setenv-always\n     * @usage setenv(\"PATH\", \"/home/user\")\n     */\n    //3rd argument (1) means that value will be overwrite if it exist\n\n    return Setenv2(name, value, YCPBoolean(true));\n\n}"
  },
  {
    "function_name": "Setenv2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "167-193",
    "snippet": "static YCPBoolean\nSetenv2 (const YCPString & name, const YCPString & value, const YCPBoolean & overwrite)\n{\n    /**\n     * @builtin setenv\n     * @short Change or add an environment variable\n     * @description\n     * The setenv() function adds the variable to the\n     * environment with the value. If variable exist\n     * the value is changed.\n     *\n     * @param string variable\n     * @param string value\n     * @param boolean overwrite\n     * @return boolean\n     * @id setenv-choose\n     * @usage setenv(\"PATH\", \"/home/user\", true)\n     */\n    //3rd argument (1) means that value will be overwrite if it exist\n    int ret = setenv(name->value().c_str(), value->value().c_str(), (overwrite->value() ? 1:0) ); \n    if (ret == 0) {\n        return YCPBoolean(true);\n    } else { \n        ycp2error (\"[Setenv1] failed %s\",strerror(errno));\n        return YCPBoolean(false);\n    }\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPBoolean",
          "args": [
            "false"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "YCPBoolean",
          "container": "YCPBoolean",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBoolean.cc",
          "lines": "99-107",
          "snippet": "YCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}",
          "includes": [
            "#include \"Xmlcode.h\"",
            "#include \"Bytecode.h\"",
            "#include \"YCPBoolean.h\"",
            "#include <ycp/y2log.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "YCPBoolean* YCPBoolean::trueboolean = NULL;",
            "YCPBoolean* YCPBoolean::falseboolean = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"Xmlcode.h\"\n#include \"Bytecode.h\"\n#include \"YCPBoolean.h\"\n#include <ycp/y2log.h>\n\nYCPBoolean* YCPBoolean::trueboolean = NULL;\nYCPBoolean* YCPBoolean::falseboolean = NULL;\n\nYCPBoolean {\n  YCPBoolean::YCPBoolean (bytecodeistream & str)\n      : YCPValue (*(\n  \tBytecode::readBool (str) ? \n  \ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n  \t:\n  \tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n      ))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"[Setenv1] failed %s\"",
            "strerror(errno)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "name->value().c_str()",
            "value->value().c_str()",
            "(overwrite->value() ? 1:0)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "overwrite->value",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPBoolean\nSetenv2 (const YCPString & name, const YCPString & value, const YCPBoolean & overwrite)\n{\n    /**\n     * @builtin setenv\n     * @short Change or add an environment variable\n     * @description\n     * The setenv() function adds the variable to the\n     * environment with the value. If variable exist\n     * the value is changed.\n     *\n     * @param string variable\n     * @param string value\n     * @param boolean overwrite\n     * @return boolean\n     * @id setenv-choose\n     * @usage setenv(\"PATH\", \"/home/user\", true)\n     */\n    //3rd argument (1) means that value will be overwrite if it exist\n    int ret = setenv(name->value().c_str(), value->value().c_str(), (overwrite->value() ? 1:0) ); \n    if (ret == 0) {\n        return YCPBoolean(true);\n    } else { \n        ycp2error (\"[Setenv1] failed %s\",strerror(errno));\n        return YCPBoolean(false);\n    }\n}"
  },
  {
    "function_name": "Srandom2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "144-164",
    "snippet": "static YCPValue\nSrandom2 (const YCPInteger & seed)\n{\n    /**\n     * @builtin srandom\n     * @short Initialize random number generator.\n     * @param integer SEED\n     * @return void\n     * @id srandom-integer\n     * @usage srandom(3355)\n     */\n\n    if (seed.isNull ())\n    {\n\tycp2error (\"Cannot initialize random generator using 'nil'\");\n\treturn YCPNull ();\n    }\n\n    srand (seed->value ());\n    return YCPVoid ();\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "srand",
          "args": [
            "seed->value ()"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seed->value",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ycp2error",
          "args": [
            "\"Cannot initialize random generator using 'nil'\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seed.isNull",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nSrandom2 (const YCPInteger & seed)\n{\n    /**\n     * @builtin srandom\n     * @short Initialize random number generator.\n     * @param integer SEED\n     * @return void\n     * @id srandom-integer\n     * @usage srandom(3355)\n     */\n\n    if (seed.isNull ())\n    {\n\tycp2error (\"Cannot initialize random generator using 'nil'\");\n\treturn YCPNull ();\n    }\n\n    srand (seed->value ());\n    return YCPVoid ();\n}"
  },
  {
    "function_name": "Srandom1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "123-141",
    "snippet": "static YCPInteger\nSrandom1 ()\n{\n    /**\n     * @builtin srandom\n     * @short Initialize random number generator\n     * @description\n     * Initialize random number generator with current date and\n     * time and returns the seed.\n     *\n     * @return integer\n     * @id srandom-time\n     * @usage srandom()\n     */\n\n    int ret = time (0);\n    srand (ret);\n    return YCPInteger (ret);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "ret"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "srand",
          "args": [
            "ret"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "0"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPInteger\nSrandom1 ()\n{\n    /**\n     * @builtin srandom\n     * @short Initialize random number generator\n     * @description\n     * Initialize random number generator with current date and\n     * time and returns the seed.\n     *\n     * @return integer\n     * @id srandom-time\n     * @usage srandom()\n     */\n\n    int ret = time (0);\n    srand (ret);\n    return YCPInteger (ret);\n}"
  },
  {
    "function_name": "Random",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "96-120",
    "snippet": "static YCPInteger\nRandom (const YCPInteger & max)\n{\n    /**\n     * @builtin random\n     * @short Random number generator.\n     * @description\n     * Returns a random integer in the interval [0,MAX).\n     * <tt>srandom</tt> must be activated to get really random\n     * numbers.\n     *\n     * @param integer MAX\n     * @return integer Returns integer in the interval [0,MAX).\n     * @usage random(100) -> 82\n     * @usage random(100) -> 36\n     */\n\n    if (max.isNull ())\n\treturn YCPNull ();\n\n    // see NOTES in man 3 rand,\n    // <1,10> 1+(int) (10.0*rand()/(RAND_MAX+1.0));\n    int ret = (int) (max->value () * rand () / (RAND_MAX + 1.0));\n    return YCPInteger (ret);\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "ret"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "Srandom1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
          "lines": "123-141",
          "snippet": "static YCPInteger\nSrandom1 ()\n{\n    /**\n     * @builtin srandom\n     * @short Initialize random number generator\n     * @description\n     * Initialize random number generator with current date and\n     * time and returns the seed.\n     *\n     * @return integer\n     * @id srandom-time\n     * @usage srandom()\n     */\n\n    int ret = time (0);\n    srand (ret);\n    return YCPInteger (ret);\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"y2util/y2changes.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"ycp/StaticDeclaration.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPBuiltinMisc.h\"",
            "#include <errno.h>",
            "#include <arpa/inet.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPInteger\nSrandom1 ()\n{\n    /**\n     * @builtin srandom\n     * @short Initialize random number generator\n     * @description\n     * Initialize random number generator with current date and\n     * time and returns the seed.\n     *\n     * @return integer\n     * @id srandom-time\n     * @usage srandom()\n     */\n\n    int ret = time (0);\n    srand (ret);\n    return YCPInteger (ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max->value",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max.isNull",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPInteger\nRandom (const YCPInteger & max)\n{\n    /**\n     * @builtin random\n     * @short Random number generator.\n     * @description\n     * Returns a random integer in the interval [0,MAX).\n     * <tt>srandom</tt> must be activated to get really random\n     * numbers.\n     *\n     * @param integer MAX\n     * @return integer Returns integer in the interval [0,MAX).\n     * @usage random(100) -> 82\n     * @usage random(100) -> 36\n     */\n\n    if (max.isNull ())\n\treturn YCPNull ();\n\n    // see NOTES in man 3 rand,\n    // <1,10> 1+(int) (10.0*rand()/(RAND_MAX+1.0));\n    int ret = (int) (max->value () * rand () / (RAND_MAX + 1.0));\n    return YCPInteger (ret);\n}"
  },
  {
    "function_name": "Sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "77-93",
    "snippet": "static YCPValue\nSleep (const YCPInteger & ms)\n{\n    /**\n     * @builtin sleep \n     * @short Sleeps a number of milliseconds.\n     * @param integer MILLISECONDS Time in milliseconds\n     * @return void\n     * @usage sleep(3000) -> sleeps 3 sec.\n     */\n     \n    if (ms.isNull ())\n\treturn YCPNull ();\n\n    usleep (ms->value () * 1000);\n    return YCPVoid ();\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPVoid",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "YCPVoid",
          "container": "YCPVoid",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPVoid.cc",
          "lines": "72-75",
          "snippet": "YCPVoid::YCPVoid ()\n    : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n{\n}",
          "includes": [
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "YCPVoid* YCPVoid::nil = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/y2log.h\"\n\nYCPVoid* YCPVoid::nil = NULL;\n\nYCPVoid {\n  YCPVoid::YCPVoid ()\n      : YCPValue( *(nil ? nil : (nil = new YCPVoid (new YCPVoidRep()) )))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms->value () * 1000"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ms->value",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "YCPStringRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPString.cc",
          "lines": "44-48",
          "snippet": "string\nYCPStringRep::value() const\n{\n    return v;\n}",
          "includes": [
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/y2log.h\"",
            "#include \"y2string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/y2log.h\"\n#include \"y2string.h\"\n\nYCPStringRep {\n  string\n  YCPStringRep::value() const\n  {\n      return v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "YCPNull",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ms.isNull",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPValue\nSleep (const YCPInteger & ms)\n{\n    /**\n     * @builtin sleep \n     * @short Sleeps a number of milliseconds.\n     * @param integer MILLISECONDS Time in milliseconds\n     * @return void\n     * @usage sleep(3000) -> sleeps 3 sec.\n     */\n     \n    if (ms.isNull ())\n\treturn YCPNull ();\n\n    usleep (ms->value () * 1000);\n    return YCPVoid ();\n}"
  },
  {
    "function_name": "Time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPBuiltinMisc.cc",
    "lines": "63-74",
    "snippet": "static YCPInteger\nTime ()\n{\n    /**\n     * @builtin time\n     * @short Return the number of seconds since 1.1.1970.\n     * @return integer\n     * @usage time() -> 1111207439\n     */\n\n    return YCPInteger (time (0));\n}",
    "includes": [
      "#include \"ycp/ExecutionEnvironment.h\"",
      "#include \"y2util/y2changes.h\"",
      "#include \"ycp/y2log.h\"",
      "#include \"ycp/StaticDeclaration.h\"",
      "#include \"ycp/YCPCode.h\"",
      "#include \"ycp/YCPString.h\"",
      "#include \"ycp/YCPVoid.h\"",
      "#include \"ycp/YCPInteger.h\"",
      "#include \"ycp/YCPBoolean.h\"",
      "#include \"ycp/YCPBuiltinMisc.h\"",
      "#include <errno.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <netinet/in.h>",
      "#include <sys/stat.h>",
      "#include <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "YCPInteger",
          "args": [
            "time (0)"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "YCPInteger",
          "container": "YCPInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPInteger.cc",
          "lines": "142-145",
          "snippet": "YCPInteger::YCPInteger (bytecodeistream & str)\n    : YCPValue (new YCPIntegerRep (fromStream (str)))\n{\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/y2log.h\"\n\nYCPInteger {\n  YCPInteger::YCPInteger (bytecodeistream & str)\n      : YCPValue (new YCPIntegerRep (fromStream (str)))\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "0"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"y2util/y2changes.h\"\n#include \"ycp/y2log.h\"\n#include \"ycp/StaticDeclaration.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPBuiltinMisc.h\"\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nstatic YCPInteger\nTime ()\n{\n    /**\n     * @builtin time\n     * @short Return the number of seconds since 1.1.1970.\n     * @return integer\n     * @usage time() -> 1111207439\n     */\n\n    return YCPInteger (time (0));\n}"
  }
]