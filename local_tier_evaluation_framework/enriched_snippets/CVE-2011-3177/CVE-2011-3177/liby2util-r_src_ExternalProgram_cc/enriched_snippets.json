[
  {
    "function_name": "renumber_fd",
    "container": "ExternalProgram",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
    "lines": "425-435",
    "snippet": "void ExternalProgram::renumber_fd (int origfd, int newfd)\n{\n    // It may happen that origfd is already the one we want\n    // (Although in our circumstances, that would mean somebody has closed\n    // our stdin or stdout... weird but has appened to Cray, #49797)\n    if (origfd != newfd)\n    {\n\tdup2 (origfd, newfd);\n\t::close (origfd);\n    }\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <cstring> // strsignal",
      "#include <termios.h> // tcsetattr()",
      "#include <stdlib.h> // setenv",
      "#include <pty.h> // openpty",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "origfd"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "origfd",
            "newfd"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  void ExternalProgram::renumber_fd (int origfd, int newfd)\n  {\n      // It may happen that origfd is already the one we want\n      // (Although in our circumstances, that would mean somebody has closed\n      // our stdin or stdout... weird but has appened to Cray, #49797)\n      if (origfd != newfd)\n      {\n  \tdup2 (origfd, newfd);\n  \t::close (origfd);\n      }\n  }\n}"
  },
  {
    "function_name": "running",
    "container": "ExternalProgram",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
    "lines": "401-422",
    "snippet": "bool\nExternalProgram::running()\n{\n    if ( pid < 0 ) return false;\n\n    int status = 0;\n    int p = waitpid( pid, &status, WNOHANG );\n    if ( p < 0 ) return false;\n\n    status = checkStatus( status );\n\n    if ( status == 0 )\n    {\n        return true;\n    }\n    else\n    {\n        _exitStatus = status;\n        pid = -1;\n        return false;\n    }\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <cstring> // strsignal",
      "#include <termios.h> // tcsetattr()",
      "#include <stdlib.h> // setenv",
      "#include <pty.h> // openpty",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "checkStatus",
          "args": [
            "status"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "checkStatus",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "354-387",
          "snippet": "int ExternalProgram::checkStatus( int status )\n{\n    if (WIFEXITED (status))\n    {\n\tstatus = WEXITSTATUS (status);\n\tif(status)\n\t{\n\t    DBG << \"pid \" << pid << \" exited with status \" << status << endl;\n\t}\n\telse\n\t{\n\t    // if 'launch' is logged, completion should be logged,\n\t    // even if successfull.\n\t    D__ << \"pid \" << pid << \" successfully completed\" << endl;\n\t}\n    }\n    else if (WIFSIGNALED (status))\n    {\n\tstatus = WTERMSIG (status);\n\tWAR << \"pid \" << pid << \" was killed by signal \" << status\n\t\t<< \" (\" << strsignal(status);\n\tif (WCOREDUMP (status))\n\t{\n\t    WAR << \", core dumped\";\n\t}\n\tWAR << \")\" << endl;\n\tstatus+=128;\n    }\n    else {\n\tERR << \"pid \" << pid << \" exited with unknown error\" << endl;\n    }\n\n    return status;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  int ExternalProgram::checkStatus( int status )\n  {\n      if (WIFEXITED (status))\n      {\n  \tstatus = WEXITSTATUS (status);\n  \tif(status)\n  \t{\n  \t    DBG << \"pid \" << pid << \" exited with status \" << status << endl;\n  \t}\n  \telse\n  \t{\n  \t    // if 'launch' is logged, completion should be logged,\n  \t    // even if successfull.\n  \t    D__ << \"pid \" << pid << \" successfully completed\" << endl;\n  \t}\n      }\n      else if (WIFSIGNALED (status))\n      {\n  \tstatus = WTERMSIG (status);\n  \tWAR << \"pid \" << pid << \" was killed by signal \" << status\n  \t\t<< \" (\" << strsignal(status);\n  \tif (WCOREDUMP (status))\n  \t{\n  \t    WAR << \", core dumped\";\n  \t}\n  \tWAR << \")\" << endl;\n  \tstatus+=128;\n      }\n      else {\n  \tERR << \"pid \" << pid << \" exited with unknown error\" << endl;\n      }\n  \n      return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "WNOHANG"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  bool\n  ExternalProgram::running()\n  {\n      if ( pid < 0 ) return false;\n  \n      int status = 0;\n      int p = waitpid( pid, &status, WNOHANG );\n      if ( p < 0 ) return false;\n  \n      status = checkStatus( status );\n  \n      if ( status == 0 )\n      {\n          return true;\n      }\n      else\n      {\n          _exitStatus = status;\n          pid = -1;\n          return false;\n      }\n  }\n}"
  },
  {
    "function_name": "kill",
    "container": "ExternalProgram",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
    "lines": "389-398",
    "snippet": "bool\nExternalProgram::kill()\n{\n    if (pid > 0)\n    {\n\t::kill(pid, SIGKILL);\n\tclose();\n    }\n    return true;\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <cstring> // strsignal",
      "#include <termios.h> // tcsetattr()",
      "#include <stdlib.h> // setenv",
      "#include <pty.h> // openpty",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "325-351",
          "snippet": "int\nExternalProgram::close()\n{\n    if (pid > 0)\n    {\n\tExternalDataSource::close();\n\t// Wait for child to exit\n\tint ret;\n        int status = 0;\n\tdo\n\t{\n\t    ret = waitpid(pid, &status, 0);\n\t}\n\twhile (ret == -1 && errno == EINTR);\n\n\tif (ret != -1)\n\t{\n\t    status = checkStatus( status );\n\t}\n        pid = -1;\n        return status;\n    }\n    else\n    {\n        return _exitStatus;\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  int\n  ExternalProgram::close()\n  {\n      if (pid > 0)\n      {\n  \tExternalDataSource::close();\n  \t// Wait for child to exit\n  \tint ret;\n          int status = 0;\n  \tdo\n  \t{\n  \t    ret = waitpid(pid, &status, 0);\n  \t}\n  \twhile (ret == -1 && errno == EINTR);\n  \n  \tif (ret != -1)\n  \t{\n  \t    status = checkStatus( status );\n  \t}\n          pid = -1;\n          return status;\n      }\n      else\n      {\n          return _exitStatus;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "::kill",
          "args": [
            "pid",
            "SIGKILL"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  bool\n  ExternalProgram::kill()\n  {\n      if (pid > 0)\n      {\n  \t::kill(pid, SIGKILL);\n  \tclose();\n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "checkStatus",
    "container": "ExternalProgram",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
    "lines": "354-387",
    "snippet": "int ExternalProgram::checkStatus( int status )\n{\n    if (WIFEXITED (status))\n    {\n\tstatus = WEXITSTATUS (status);\n\tif(status)\n\t{\n\t    DBG << \"pid \" << pid << \" exited with status \" << status << endl;\n\t}\n\telse\n\t{\n\t    // if 'launch' is logged, completion should be logged,\n\t    // even if successfull.\n\t    D__ << \"pid \" << pid << \" successfully completed\" << endl;\n\t}\n    }\n    else if (WIFSIGNALED (status))\n    {\n\tstatus = WTERMSIG (status);\n\tWAR << \"pid \" << pid << \" was killed by signal \" << status\n\t\t<< \" (\" << strsignal(status);\n\tif (WCOREDUMP (status))\n\t{\n\t    WAR << \", core dumped\";\n\t}\n\tWAR << \")\" << endl;\n\tstatus+=128;\n    }\n    else {\n\tERR << \"pid \" << pid << \" exited with unknown error\" << endl;\n    }\n\n    return status;\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <cstring> // strsignal",
      "#include <termios.h> // tcsetattr()",
      "#include <stdlib.h> // setenv",
      "#include <pty.h> // openpty",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WCOREDUMP",
          "args": [
            "status"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsignal",
          "args": [
            "status"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WTERMSIG",
          "args": [
            "status"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFSIGNALED",
          "args": [
            "status"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  int ExternalProgram::checkStatus( int status )\n  {\n      if (WIFEXITED (status))\n      {\n  \tstatus = WEXITSTATUS (status);\n  \tif(status)\n  \t{\n  \t    DBG << \"pid \" << pid << \" exited with status \" << status << endl;\n  \t}\n  \telse\n  \t{\n  \t    // if 'launch' is logged, completion should be logged,\n  \t    // even if successfull.\n  \t    D__ << \"pid \" << pid << \" successfully completed\" << endl;\n  \t}\n      }\n      else if (WIFSIGNALED (status))\n      {\n  \tstatus = WTERMSIG (status);\n  \tWAR << \"pid \" << pid << \" was killed by signal \" << status\n  \t\t<< \" (\" << strsignal(status);\n  \tif (WCOREDUMP (status))\n  \t{\n  \t    WAR << \", core dumped\";\n  \t}\n  \tWAR << \")\" << endl;\n  \tstatus+=128;\n      }\n      else {\n  \tERR << \"pid \" << pid << \" exited with unknown error\" << endl;\n      }\n  \n      return status;\n  }\n}"
  },
  {
    "function_name": "close",
    "container": "ExternalProgram",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
    "lines": "325-351",
    "snippet": "int\nExternalProgram::close()\n{\n    if (pid > 0)\n    {\n\tExternalDataSource::close();\n\t// Wait for child to exit\n\tint ret;\n        int status = 0;\n\tdo\n\t{\n\t    ret = waitpid(pid, &status, 0);\n\t}\n\twhile (ret == -1 && errno == EINTR);\n\n\tif (ret != -1)\n\t{\n\t    status = checkStatus( status );\n\t}\n        pid = -1;\n        return status;\n    }\n    else\n    {\n        return _exitStatus;\n    }\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <cstring> // strsignal",
      "#include <termios.h> // tcsetattr()",
      "#include <stdlib.h> // setenv",
      "#include <pty.h> // openpty",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "checkStatus",
          "args": [
            "status"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "checkStatus",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "354-387",
          "snippet": "int ExternalProgram::checkStatus( int status )\n{\n    if (WIFEXITED (status))\n    {\n\tstatus = WEXITSTATUS (status);\n\tif(status)\n\t{\n\t    DBG << \"pid \" << pid << \" exited with status \" << status << endl;\n\t}\n\telse\n\t{\n\t    // if 'launch' is logged, completion should be logged,\n\t    // even if successfull.\n\t    D__ << \"pid \" << pid << \" successfully completed\" << endl;\n\t}\n    }\n    else if (WIFSIGNALED (status))\n    {\n\tstatus = WTERMSIG (status);\n\tWAR << \"pid \" << pid << \" was killed by signal \" << status\n\t\t<< \" (\" << strsignal(status);\n\tif (WCOREDUMP (status))\n\t{\n\t    WAR << \", core dumped\";\n\t}\n\tWAR << \")\" << endl;\n\tstatus+=128;\n    }\n    else {\n\tERR << \"pid \" << pid << \" exited with unknown error\" << endl;\n    }\n\n    return status;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  int ExternalProgram::checkStatus( int status )\n  {\n      if (WIFEXITED (status))\n      {\n  \tstatus = WEXITSTATUS (status);\n  \tif(status)\n  \t{\n  \t    DBG << \"pid \" << pid << \" exited with status \" << status << endl;\n  \t}\n  \telse\n  \t{\n  \t    // if 'launch' is logged, completion should be logged,\n  \t    // even if successfull.\n  \t    D__ << \"pid \" << pid << \" successfully completed\" << endl;\n  \t}\n      }\n      else if (WIFSIGNALED (status))\n      {\n  \tstatus = WTERMSIG (status);\n  \tWAR << \"pid \" << pid << \" was killed by signal \" << status\n  \t\t<< \" (\" << strsignal(status);\n  \tif (WCOREDUMP (status))\n  \t{\n  \t    WAR << \", core dumped\";\n  \t}\n  \tWAR << \")\" << endl;\n  \tstatus+=128;\n      }\n      else {\n  \tERR << \"pid \" << pid << \" exited with unknown error\" << endl;\n      }\n  \n      return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExternalDataSource::close",
          "args": [],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "325-351",
          "snippet": "int\nExternalProgram::close()\n{\n    if (pid > 0)\n    {\n\tExternalDataSource::close();\n\t// Wait for child to exit\n\tint ret;\n        int status = 0;\n\tdo\n\t{\n\t    ret = waitpid(pid, &status, 0);\n\t}\n\twhile (ret == -1 && errno == EINTR);\n\n\tif (ret != -1)\n\t{\n\t    status = checkStatus( status );\n\t}\n        pid = -1;\n        return status;\n    }\n    else\n    {\n        return _exitStatus;\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  int\n  ExternalProgram::close()\n  {\n      if (pid > 0)\n      {\n  \tExternalDataSource::close();\n  \t// Wait for child to exit\n  \tint ret;\n          int status = 0;\n  \tdo\n  \t{\n  \t    ret = waitpid(pid, &status, 0);\n  \t}\n  \twhile (ret == -1 && errno == EINTR);\n  \n  \tif (ret != -1)\n  \t{\n  \t    status = checkStatus( status );\n  \t}\n          pid = -1;\n          return status;\n      }\n      else\n      {\n          return _exitStatus;\n      }\n  }\n}"
  },
  {
    "function_name": "start_program",
    "container": "ExternalProgram",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
    "lines": "157-322",
    "snippet": "void\nExternalProgram::start_program (const char *const *argv, const Environment & environment,\n\t\t\t\tStderr_Disposition stderr_disp,\n\t\t\t\tint stderr_fd, bool default_locale, const char* root)\n{\n    pid = -1;\n    _exitStatus = 0;\n    int to_external[2], from_external[2];  // fds for pair of pipes\n    int master_tty,\tslave_tty;\t   // fds for pair of ttys\n\n    if (use_pty)\n    {\n\t// Create pair of ttys\n        D__ << \"Using ttys for communication with \" << argv[0] << endl;\n\tif (openpty (&master_tty, &slave_tty, 0, 0, 0) != 0)\n\t{\n\t    ERR << \"openpty failed\" << endl;\n\t    return;\n\t}\n\n\tif (disable_pty_trans)\n\t{\n\t   disableCRLFTranslation(slave_tty);\n\t}\n    }\n    else\n    {\n\t// Create pair of pipes\n\tif (pipe (to_external) != 0 || pipe (from_external) != 0)\n\t{\n\t    ERR << \"pipe failed\" << endl;\n\t    return;\n\t}\n    }\n\n    // do not remove the single quotes around every argument, copy&paste of\n    // command to shell will not work otherwise!\n    DBG << \"Executing \";\n    for (int i = 0; argv[i]; i++)\n    {\n\tif (i>0) DBG << ' ';\n\tDBG << '\\'';\n\tDBG << argv[i];\n\tDBG << '\\'';\n    }\n    DBG << endl;\n\n    // Create module process\n    if ((pid = fork()) == 0)\n    {\n\tif (use_pty)\n\t{\n\t    setsid();\n\t    if(slave_tty != 1)\n\t\tdup2 (slave_tty, 1);\t  // set new stdout\n\t    renumber_fd (slave_tty, 0);\t  // set new stdin\n\t    ::close(master_tty);\t  // Belongs to father process\n\n\t    // We currently have no controlling terminal (due to setsid).\n\t    // The first open call will also set the new ctty (due to historical\n\t    // unix guru knowledge ;-) )\n\n\t    char name[512];\n\t    int err = ttyname_r(slave_tty, name, sizeof(name));\n\t    if (err == 0)\n\t\t::close(open(name, O_RDONLY));\n\t    // else error\n\t}\n\telse\n\t{\n\t    renumber_fd (to_external[0], 0); // set new stdin\n\t    ::close(from_external[0]);\t  // Belongs to father process\n\n\t    renumber_fd (from_external[1], 1); // set new stdout\n\t    ::close(to_external\t [1]);\t  // Belongs to father process\n\t}\n\n\t// Handle stderr\n\tif (stderr_disp == Discard_Stderr)\n\t{\n\t    int null_fd = open(\"/dev/null\", O_WRONLY);\n\t    dup2(null_fd, 2);\n\t    ::close(null_fd);\n\t}\n\telse if (stderr_disp == Stderr_To_Stdout)\n\t{\n\t    dup2(1, 2);\n\t}\n\telse if (stderr_disp == Stderr_To_FileDesc)\n\t{\n\t    // Note: We don't have to close anything regarding stderr_fd.\n\t    // Our caller is responsible for that.\n\t    dup2 (stderr_fd, 2);\n\t}\n\n\tfor ( Environment::const_iterator it = environment.begin(); it != environment.end(); ++it ) {\n\t  setenv( it->first.c_str(), it->second.c_str(), 1 );\n\t}\n\n\tif(default_locale)\n\t\tsetenv(\"LC_ALL\",\"C\",1);\n\n\tif(root)\n\t{\n\t    if(chroot(root) == -1)\n\t    {\n\t\tERR << \"chroot to \" << root << \" failed: \" << strerror(errno) << endl;\n\t\t_exit (3);\t\t\t// No sense in returning! I am forked away!!\n\t    }\n\t    if(chdir(\"/\") == -1)\n\t    {\n\t\tERR << \"chdir to / inside chroot failed: \" << strerror(errno) << endl;\n\t\t_exit (4);\t\t\t// No sense in returning! I am forked away!!\n\t    }\n\t}\n\n\t// close all filedesctiptors above stderr\n\tfor ( int i = ::getdtablesize() - 1; i > 2; --i ) {\n\t  ::close( i );\n\t}\n\n\texecvp(argv[0], const_cast<char *const *>(argv));\n\tERR << \"Cannot execute external program \"\n\t\t << argv[0] << \":\" << strerror(errno) << endl;\n\t_exit (5);\t\t\t// No sense in returning! I am forked away!!\n    }\n\n    else if (pid == -1)\t // Fork failed, close everything.\n    {\n\tif (use_pty) {\n\t    ::close(master_tty);\n\t    ::close(slave_tty);\n\t}\n\telse {\n\t    ::close(to_external[0]);\n\t    ::close(to_external[1]);\n\t    ::close(from_external[0]);\n\t    ::close(from_external[1]);\n\t}\n\tERR << \"Cannot fork \" << strerror(errno) << endl;\n    }\n\n    else {\n\tif (use_pty)\n\t{\n\t    ::close(slave_tty);\t       // belongs to child process\n\t    inputfile  = fdopen(master_tty, \"r\");\n\t    outputfile = fdopen(master_tty, \"w\");\n\t}\n\telse\n\t{\n\t    ::close(to_external[0]);   // belongs to child process\n\t    ::close(from_external[1]); // belongs to child process\n\t    inputfile = fdopen(from_external[0], \"r\");\n\t    outputfile = fdopen(to_external[1], \"w\");\n\t}\n\n\tD__ << \"pid \" << pid << \" launched\" << endl;\n\n\tif (!inputfile || !outputfile)\n\t{\n\t    ERR << \"Cannot create streams to external program \" << argv[0] << endl;\n\t    close();\n\t}\n    }\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <cstring> // strsignal",
      "#include <termios.h> // tcsetattr()",
      "#include <stdlib.h> // setenv",
      "#include <pty.h> // openpty",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "325-351",
          "snippet": "int\nExternalProgram::close()\n{\n    if (pid > 0)\n    {\n\tExternalDataSource::close();\n\t// Wait for child to exit\n\tint ret;\n        int status = 0;\n\tdo\n\t{\n\t    ret = waitpid(pid, &status, 0);\n\t}\n\twhile (ret == -1 && errno == EINTR);\n\n\tif (ret != -1)\n\t{\n\t    status = checkStatus( status );\n\t}\n        pid = -1;\n        return status;\n    }\n    else\n    {\n        return _exitStatus;\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  int\n  ExternalProgram::close()\n  {\n      if (pid > 0)\n      {\n  \tExternalDataSource::close();\n  \t// Wait for child to exit\n  \tint ret;\n          int status = 0;\n  \tdo\n  \t{\n  \t    ret = waitpid(pid, &status, 0);\n  \t}\n  \twhile (ret == -1 && errno == EINTR);\n  \n  \tif (ret != -1)\n  \t{\n  \t    status = checkStatus( status );\n  \t}\n          pid = -1;\n          return status;\n      }\n      else\n      {\n          return _exitStatus;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "to_external[1]",
            "\"w\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "from_external[0]",
            "\"r\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "from_external[1]"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "to_external[0]"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "master_tty",
            "\"w\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopen",
          "args": [
            "master_tty",
            "\"r\""
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "slave_tty"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "from_external[1]"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "from_external[0]"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "to_external[1]"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "to_external[0]"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "slave_tty"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "master_tty"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "5"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "argv[0]",
            "const_cast<char *const *>(argv)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<char *const *>",
          "args": [
            "argv"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "i"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::getdtablesize",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "4"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "3"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "root"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LC_ALL\"",
            "\"C\"",
            "1"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "it->first.c_str()",
            "it->second.c_str()",
            "1"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it->second.c_str",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it->first.c_str",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "environment.end",
          "args": [],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "43-47",
          "snippet": "YCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::end() const\n  {\n      return stl_map.end();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "environment.begin",
          "args": [],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "YCPMapRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPMap.cc",
          "lines": "36-40",
          "snippet": "YCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}",
          "includes": [
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/Xmlcode.h\"",
            "#include \"ycp/Bytecode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/Xmlcode.h\"\n#include \"ycp/Bytecode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/y2log.h\"\n\nYCPMapRep {\n  YCPMapIterator\n  YCPMapRep::begin() const\n  {\n      return stl_map.begin();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "stderr_fd",
            "2"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "1",
            "2"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "null_fd"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "null_fd",
            "2"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_WRONLY"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "to_external\t [1]"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "renumber_fd",
          "args": [
            "from_external[1]",
            "1"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "renumber_fd",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "425-435",
          "snippet": "void ExternalProgram::renumber_fd (int origfd, int newfd)\n{\n    // It may happen that origfd is already the one we want\n    // (Although in our circumstances, that would mean somebody has closed\n    // our stdin or stdout... weird but has appened to Cray, #49797)\n    if (origfd != newfd)\n    {\n\tdup2 (origfd, newfd);\n\t::close (origfd);\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  void ExternalProgram::renumber_fd (int origfd, int newfd)\n  {\n      // It may happen that origfd is already the one we want\n      // (Although in our circumstances, that would mean somebody has closed\n      // our stdin or stdout... weird but has appened to Cray, #49797)\n      if (origfd != newfd)\n      {\n  \tdup2 (origfd, newfd);\n  \t::close (origfd);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "from_external[0]"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "open(name, O_RDONLY)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "name",
            "O_RDONLY"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyname_r",
          "args": [
            "slave_tty",
            "name",
            "sizeof(name)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::close",
          "args": [
            "master_tty"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "slave_tty",
            "1"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "from_external"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "to_external"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disableCRLFTranslation",
          "args": [
            "slave_tty"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "disableCRLFTranslation",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "125-154",
          "snippet": "bool ExternalProgram::disableCRLFTranslation(int fd)\n{\n    if (!isatty(fd))\n    {\n\tERR << \"The file descriptor is not a terminal!\\n\";\n\treturn false;\n    }\n\n    // properties of the terminal\n    struct termios mode;\n\n    // get the current attributes\n    if (tcgetattr(fd, &mode))\n    {\n\tERR << \"tcgetattr() failed: \" << strerror(errno) << endl;\n\treturn false;\n    }\n\n    // disable the LF to CRLF translation in the output flag\n    mode.c_oflag = mode.c_oflag & ~ONLCR;\n\n    // TCSADRAIN should be used when changing output flags (see 'man termios')\n    if (tcsetattr(fd, TCSADRAIN, &mode))\n    {\n\tERR << \"tcsetattr() failed: \" << strerror(errno) << endl;\n\treturn false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  bool ExternalProgram::disableCRLFTranslation(int fd)\n  {\n      if (!isatty(fd))\n      {\n  \tERR << \"The file descriptor is not a terminal!\\n\";\n  \treturn false;\n      }\n  \n      // properties of the terminal\n      struct termios mode;\n  \n      // get the current attributes\n      if (tcgetattr(fd, &mode))\n      {\n  \tERR << \"tcgetattr() failed: \" << strerror(errno) << endl;\n  \treturn false;\n      }\n  \n      // disable the LF to CRLF translation in the output flag\n      mode.c_oflag = mode.c_oflag & ~ONLCR;\n  \n      // TCSADRAIN should be used when changing output flags (see 'man termios')\n      if (tcsetattr(fd, TCSADRAIN, &mode))\n      {\n  \tERR << \"tcsetattr() failed: \" << strerror(errno) << endl;\n  \treturn false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "openpty",
          "args": [
            "&master_tty",
            "&slave_tty",
            "0",
            "0",
            "0"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  void\n  ExternalProgram::start_program (const char *const *argv, const Environment & environment,\n  \t\t\t\tStderr_Disposition stderr_disp,\n  \t\t\t\tint stderr_fd, bool default_locale, const char* root)\n  {\n      pid = -1;\n      _exitStatus = 0;\n      int to_external[2], from_external[2];  // fds for pair of pipes\n      int master_tty,\tslave_tty;\t   // fds for pair of ttys\n  \n      if (use_pty)\n      {\n  \t// Create pair of ttys\n          D__ << \"Using ttys for communication with \" << argv[0] << endl;\n  \tif (openpty (&master_tty, &slave_tty, 0, 0, 0) != 0)\n  \t{\n  \t    ERR << \"openpty failed\" << endl;\n  \t    return;\n  \t}\n  \n  \tif (disable_pty_trans)\n  \t{\n  \t   disableCRLFTranslation(slave_tty);\n  \t}\n      }\n      else\n      {\n  \t// Create pair of pipes\n  \tif (pipe (to_external) != 0 || pipe (from_external) != 0)\n  \t{\n  \t    ERR << \"pipe failed\" << endl;\n  \t    return;\n  \t}\n      }\n  \n      // do not remove the single quotes around every argument, copy&paste of\n      // command to shell will not work otherwise!\n      DBG << \"Executing \";\n      for (int i = 0; argv[i]; i++)\n      {\n  \tif (i>0) DBG << ' ';\n  \tDBG << '\\'';\n  \tDBG << argv[i];\n  \tDBG << '\\'';\n      }\n      DBG << endl;\n  \n      // Create module process\n      if ((pid = fork()) == 0)\n      {\n  \tif (use_pty)\n  \t{\n  \t    setsid();\n  \t    if(slave_tty != 1)\n  \t\tdup2 (slave_tty, 1);\t  // set new stdout\n  \t    renumber_fd (slave_tty, 0);\t  // set new stdin\n  \t    ::close(master_tty);\t  // Belongs to father process\n  \n  \t    // We currently have no controlling terminal (due to setsid).\n  \t    // The first open call will also set the new ctty (due to historical\n  \t    // unix guru knowledge ;-) )\n  \n  \t    char name[512];\n  \t    int err = ttyname_r(slave_tty, name, sizeof(name));\n  \t    if (err == 0)\n  \t\t::close(open(name, O_RDONLY));\n  \t    // else error\n  \t}\n  \telse\n  \t{\n  \t    renumber_fd (to_external[0], 0); // set new stdin\n  \t    ::close(from_external[0]);\t  // Belongs to father process\n  \n  \t    renumber_fd (from_external[1], 1); // set new stdout\n  \t    ::close(to_external\t [1]);\t  // Belongs to father process\n  \t}\n  \n  \t// Handle stderr\n  \tif (stderr_disp == Discard_Stderr)\n  \t{\n  \t    int null_fd = open(\"/dev/null\", O_WRONLY);\n  \t    dup2(null_fd, 2);\n  \t    ::close(null_fd);\n  \t}\n  \telse if (stderr_disp == Stderr_To_Stdout)\n  \t{\n  \t    dup2(1, 2);\n  \t}\n  \telse if (stderr_disp == Stderr_To_FileDesc)\n  \t{\n  \t    // Note: We don't have to close anything regarding stderr_fd.\n  \t    // Our caller is responsible for that.\n  \t    dup2 (stderr_fd, 2);\n  \t}\n  \n  \tfor ( Environment::const_iterator it = environment.begin(); it != environment.end(); ++it ) {\n  \t  setenv( it->first.c_str(), it->second.c_str(), 1 );\n  \t}\n  \n  \tif(default_locale)\n  \t\tsetenv(\"LC_ALL\",\"C\",1);\n  \n  \tif(root)\n  \t{\n  \t    if(chroot(root) == -1)\n  \t    {\n  \t\tERR << \"chroot to \" << root << \" failed: \" << strerror(errno) << endl;\n  \t\t_exit (3);\t\t\t// No sense in returning! I am forked away!!\n  \t    }\n  \t    if(chdir(\"/\") == -1)\n  \t    {\n  \t\tERR << \"chdir to / inside chroot failed: \" << strerror(errno) << endl;\n  \t\t_exit (4);\t\t\t// No sense in returning! I am forked away!!\n  \t    }\n  \t}\n  \n  \t// close all filedesctiptors above stderr\n  \tfor ( int i = ::getdtablesize() - 1; i > 2; --i ) {\n  \t  ::close( i );\n  \t}\n  \n  \texecvp(argv[0], const_cast<char *const *>(argv));\n  \tERR << \"Cannot execute external program \"\n  \t\t << argv[0] << \":\" << strerror(errno) << endl;\n  \t_exit (5);\t\t\t// No sense in returning! I am forked away!!\n      }\n  \n      else if (pid == -1)\t // Fork failed, close everything.\n      {\n  \tif (use_pty) {\n  \t    ::close(master_tty);\n  \t    ::close(slave_tty);\n  \t}\n  \telse {\n  \t    ::close(to_external[0]);\n  \t    ::close(to_external[1]);\n  \t    ::close(from_external[0]);\n  \t    ::close(from_external[1]);\n  \t}\n  \tERR << \"Cannot fork \" << strerror(errno) << endl;\n      }\n  \n      else {\n  \tif (use_pty)\n  \t{\n  \t    ::close(slave_tty);\t       // belongs to child process\n  \t    inputfile  = fdopen(master_tty, \"r\");\n  \t    outputfile = fdopen(master_tty, \"w\");\n  \t}\n  \telse\n  \t{\n  \t    ::close(to_external[0]);   // belongs to child process\n  \t    ::close(from_external[1]); // belongs to child process\n  \t    inputfile = fdopen(from_external[0], \"r\");\n  \t    outputfile = fdopen(to_external[1], \"w\");\n  \t}\n  \n  \tD__ << \"pid \" << pid << \" launched\" << endl;\n  \n  \tif (!inputfile || !outputfile)\n  \t{\n  \t    ERR << \"Cannot create streams to external program \" << argv[0] << endl;\n  \t    close();\n  \t}\n      }\n  }\n}"
  },
  {
    "function_name": "disableCRLFTranslation",
    "container": "ExternalProgram",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
    "lines": "125-154",
    "snippet": "bool ExternalProgram::disableCRLFTranslation(int fd)\n{\n    if (!isatty(fd))\n    {\n\tERR << \"The file descriptor is not a terminal!\\n\";\n\treturn false;\n    }\n\n    // properties of the terminal\n    struct termios mode;\n\n    // get the current attributes\n    if (tcgetattr(fd, &mode))\n    {\n\tERR << \"tcgetattr() failed: \" << strerror(errno) << endl;\n\treturn false;\n    }\n\n    // disable the LF to CRLF translation in the output flag\n    mode.c_oflag = mode.c_oflag & ~ONLCR;\n\n    // TCSADRAIN should be used when changing output flags (see 'man termios')\n    if (tcsetattr(fd, TCSADRAIN, &mode))\n    {\n\tERR << \"tcsetattr() failed: \" << strerror(errno) << endl;\n\treturn false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <cstring> // strsignal",
      "#include <termios.h> // tcsetattr()",
      "#include <stdlib.h> // setenv",
      "#include <pty.h> // openpty",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "fd",
            "TCSADRAIN",
            "&mode"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcgetattr",
          "args": [
            "fd",
            "&mode"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "fd"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  bool ExternalProgram::disableCRLFTranslation(int fd)\n  {\n      if (!isatty(fd))\n      {\n  \tERR << \"The file descriptor is not a terminal!\\n\";\n  \treturn false;\n      }\n  \n      // properties of the terminal\n      struct termios mode;\n  \n      // get the current attributes\n      if (tcgetattr(fd, &mode))\n      {\n  \tERR << \"tcgetattr() failed: \" << strerror(errno) << endl;\n  \treturn false;\n      }\n  \n      // disable the LF to CRLF translation in the output flag\n      mode.c_oflag = mode.c_oflag & ~ONLCR;\n  \n      // TCSADRAIN should be used when changing output flags (see 'man termios')\n      if (tcsetattr(fd, TCSADRAIN, &mode))\n      {\n  \tERR << \"tcsetattr() failed: \" << strerror(errno) << endl;\n  \treturn false;\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "~ExternalProgram",
    "container": "ExternalProgram",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
    "lines": "119-121",
    "snippet": "ExternalProgram::~ExternalProgram()\n{\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <cstring> // strsignal",
      "#include <termios.h> // tcsetattr()",
      "#include <stdlib.h> // setenv",
      "#include <pty.h> // openpty",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  ExternalProgram::~ExternalProgram()\n  {\n  }\n}"
  },
  {
    "function_name": "ExternalProgram",
    "container": "ExternalProgram",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
    "lines": "105-116",
    "snippet": "ExternalProgram::ExternalProgram (const char *binpath, const char *const *argv_1, const Environment & environment,\n\t\t\t\t  bool use_pty, bool pty_trans)\n    : use_pty (use_pty), disable_pty_trans(!pty_trans)\n{\n    int i = 0;\n    while (argv_1[i++])\n\t;\n    const char *argv[i + 1];\n    argv[0] = binpath;\n    memcpy (&argv[1], argv_1, (i - 1) * sizeof (char *));\n    start_program (argv, environment);\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <cstring> // strsignal",
      "#include <termios.h> // tcsetattr()",
      "#include <stdlib.h> // setenv",
      "#include <pty.h> // openpty",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_program",
          "args": [
            "argv",
            "environment"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&argv[1]",
            "argv_1",
            "(i - 1) * sizeof (char *)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  ExternalProgram::ExternalProgram (const char *binpath, const char *const *argv_1, const Environment & environment,\n  \t\t\t\t  bool use_pty, bool pty_trans)\n      : use_pty (use_pty), disable_pty_trans(!pty_trans)\n  {\n      int i = 0;\n      while (argv_1[i++])\n  \t;\n      const char *argv[i + 1];\n      argv[0] = binpath;\n      memcpy (&argv[1], argv_1, (i - 1) * sizeof (char *));\n      start_program (argv, environment);\n  }\n}"
  },
  {
    "function_name": "ExternalProgram",
    "container": "ExternalProgram",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
    "lines": "90-102",
    "snippet": "ExternalProgram::ExternalProgram (const char *binpath, const char *const *argv_1,\n\t\t\t\t  bool use_pty, bool pty_trans)\n    : use_pty (use_pty), disable_pty_trans(!pty_trans)\n{\n    int i = 0;\n    while (argv_1[i++])\n\t;\n    const char *argv[i + 1];\n    argv[0] = binpath;\n    memcpy (&argv[1], argv_1, (i - 1) * sizeof (char *));\n    Environment environment;\n    start_program (argv, environment);\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <cstring> // strsignal",
      "#include <termios.h> // tcsetattr()",
      "#include <stdlib.h> // setenv",
      "#include <pty.h> // openpty",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_program",
          "args": [
            "argv",
            "environment"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&argv[1]",
            "argv_1",
            "(i - 1) * sizeof (char *)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  ExternalProgram::ExternalProgram (const char *binpath, const char *const *argv_1,\n  \t\t\t\t  bool use_pty, bool pty_trans)\n      : use_pty (use_pty), disable_pty_trans(!pty_trans)\n  {\n      int i = 0;\n      while (argv_1[i++])\n  \t;\n      const char *argv[i + 1];\n      argv[0] = binpath;\n      memcpy (&argv[1], argv_1, (i - 1) * sizeof (char *));\n      Environment environment;\n      start_program (argv, environment);\n  }\n}"
  },
  {
    "function_name": "ExternalProgram",
    "container": "ExternalProgram",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
    "lines": "75-87",
    "snippet": "ExternalProgram::ExternalProgram (const char *const *argv, const Environment & environment,\n\t\t\t\t  Stderr_Disposition stderr_disp, bool use_pty,\n\t\t\t\t  int stderr_fd, bool default_locale,\n\t\t\t\t  const Pathname& root, bool pty_trans)\n    : use_pty (use_pty), disable_pty_trans(!pty_trans)\n{\n    const char* rootdir = NULL;\n    if(!root.empty() && root != \"/\")\n    {\n\trootdir = root.asString().c_str();\n    }\n    start_program (argv, environment, stderr_disp, stderr_fd, default_locale, rootdir);\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <cstring> // strsignal",
      "#include <termios.h> // tcsetattr()",
      "#include <stdlib.h> // setenv",
      "#include <pty.h> // openpty",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_program",
          "args": [
            "argv",
            "environment",
            "stderr_disp",
            "stderr_fd",
            "default_locale",
            "rootdir"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "start_program",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "157-322",
          "snippet": "void\nExternalProgram::start_program (const char *const *argv, const Environment & environment,\n\t\t\t\tStderr_Disposition stderr_disp,\n\t\t\t\tint stderr_fd, bool default_locale, const char* root)\n{\n    pid = -1;\n    _exitStatus = 0;\n    int to_external[2], from_external[2];  // fds for pair of pipes\n    int master_tty,\tslave_tty;\t   // fds for pair of ttys\n\n    if (use_pty)\n    {\n\t// Create pair of ttys\n        D__ << \"Using ttys for communication with \" << argv[0] << endl;\n\tif (openpty (&master_tty, &slave_tty, 0, 0, 0) != 0)\n\t{\n\t    ERR << \"openpty failed\" << endl;\n\t    return;\n\t}\n\n\tif (disable_pty_trans)\n\t{\n\t   disableCRLFTranslation(slave_tty);\n\t}\n    }\n    else\n    {\n\t// Create pair of pipes\n\tif (pipe (to_external) != 0 || pipe (from_external) != 0)\n\t{\n\t    ERR << \"pipe failed\" << endl;\n\t    return;\n\t}\n    }\n\n    // do not remove the single quotes around every argument, copy&paste of\n    // command to shell will not work otherwise!\n    DBG << \"Executing \";\n    for (int i = 0; argv[i]; i++)\n    {\n\tif (i>0) DBG << ' ';\n\tDBG << '\\'';\n\tDBG << argv[i];\n\tDBG << '\\'';\n    }\n    DBG << endl;\n\n    // Create module process\n    if ((pid = fork()) == 0)\n    {\n\tif (use_pty)\n\t{\n\t    setsid();\n\t    if(slave_tty != 1)\n\t\tdup2 (slave_tty, 1);\t  // set new stdout\n\t    renumber_fd (slave_tty, 0);\t  // set new stdin\n\t    ::close(master_tty);\t  // Belongs to father process\n\n\t    // We currently have no controlling terminal (due to setsid).\n\t    // The first open call will also set the new ctty (due to historical\n\t    // unix guru knowledge ;-) )\n\n\t    char name[512];\n\t    int err = ttyname_r(slave_tty, name, sizeof(name));\n\t    if (err == 0)\n\t\t::close(open(name, O_RDONLY));\n\t    // else error\n\t}\n\telse\n\t{\n\t    renumber_fd (to_external[0], 0); // set new stdin\n\t    ::close(from_external[0]);\t  // Belongs to father process\n\n\t    renumber_fd (from_external[1], 1); // set new stdout\n\t    ::close(to_external\t [1]);\t  // Belongs to father process\n\t}\n\n\t// Handle stderr\n\tif (stderr_disp == Discard_Stderr)\n\t{\n\t    int null_fd = open(\"/dev/null\", O_WRONLY);\n\t    dup2(null_fd, 2);\n\t    ::close(null_fd);\n\t}\n\telse if (stderr_disp == Stderr_To_Stdout)\n\t{\n\t    dup2(1, 2);\n\t}\n\telse if (stderr_disp == Stderr_To_FileDesc)\n\t{\n\t    // Note: We don't have to close anything regarding stderr_fd.\n\t    // Our caller is responsible for that.\n\t    dup2 (stderr_fd, 2);\n\t}\n\n\tfor ( Environment::const_iterator it = environment.begin(); it != environment.end(); ++it ) {\n\t  setenv( it->first.c_str(), it->second.c_str(), 1 );\n\t}\n\n\tif(default_locale)\n\t\tsetenv(\"LC_ALL\",\"C\",1);\n\n\tif(root)\n\t{\n\t    if(chroot(root) == -1)\n\t    {\n\t\tERR << \"chroot to \" << root << \" failed: \" << strerror(errno) << endl;\n\t\t_exit (3);\t\t\t// No sense in returning! I am forked away!!\n\t    }\n\t    if(chdir(\"/\") == -1)\n\t    {\n\t\tERR << \"chdir to / inside chroot failed: \" << strerror(errno) << endl;\n\t\t_exit (4);\t\t\t// No sense in returning! I am forked away!!\n\t    }\n\t}\n\n\t// close all filedesctiptors above stderr\n\tfor ( int i = ::getdtablesize() - 1; i > 2; --i ) {\n\t  ::close( i );\n\t}\n\n\texecvp(argv[0], const_cast<char *const *>(argv));\n\tERR << \"Cannot execute external program \"\n\t\t << argv[0] << \":\" << strerror(errno) << endl;\n\t_exit (5);\t\t\t// No sense in returning! I am forked away!!\n    }\n\n    else if (pid == -1)\t // Fork failed, close everything.\n    {\n\tif (use_pty) {\n\t    ::close(master_tty);\n\t    ::close(slave_tty);\n\t}\n\telse {\n\t    ::close(to_external[0]);\n\t    ::close(to_external[1]);\n\t    ::close(from_external[0]);\n\t    ::close(from_external[1]);\n\t}\n\tERR << \"Cannot fork \" << strerror(errno) << endl;\n    }\n\n    else {\n\tif (use_pty)\n\t{\n\t    ::close(slave_tty);\t       // belongs to child process\n\t    inputfile  = fdopen(master_tty, \"r\");\n\t    outputfile = fdopen(master_tty, \"w\");\n\t}\n\telse\n\t{\n\t    ::close(to_external[0]);   // belongs to child process\n\t    ::close(from_external[1]); // belongs to child process\n\t    inputfile = fdopen(from_external[0], \"r\");\n\t    outputfile = fdopen(to_external[1], \"w\");\n\t}\n\n\tD__ << \"pid \" << pid << \" launched\" << endl;\n\n\tif (!inputfile || !outputfile)\n\t{\n\t    ERR << \"Cannot create streams to external program \" << argv[0] << endl;\n\t    close();\n\t}\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  void\n  ExternalProgram::start_program (const char *const *argv, const Environment & environment,\n  \t\t\t\tStderr_Disposition stderr_disp,\n  \t\t\t\tint stderr_fd, bool default_locale, const char* root)\n  {\n      pid = -1;\n      _exitStatus = 0;\n      int to_external[2], from_external[2];  // fds for pair of pipes\n      int master_tty,\tslave_tty;\t   // fds for pair of ttys\n  \n      if (use_pty)\n      {\n  \t// Create pair of ttys\n          D__ << \"Using ttys for communication with \" << argv[0] << endl;\n  \tif (openpty (&master_tty, &slave_tty, 0, 0, 0) != 0)\n  \t{\n  \t    ERR << \"openpty failed\" << endl;\n  \t    return;\n  \t}\n  \n  \tif (disable_pty_trans)\n  \t{\n  \t   disableCRLFTranslation(slave_tty);\n  \t}\n      }\n      else\n      {\n  \t// Create pair of pipes\n  \tif (pipe (to_external) != 0 || pipe (from_external) != 0)\n  \t{\n  \t    ERR << \"pipe failed\" << endl;\n  \t    return;\n  \t}\n      }\n  \n      // do not remove the single quotes around every argument, copy&paste of\n      // command to shell will not work otherwise!\n      DBG << \"Executing \";\n      for (int i = 0; argv[i]; i++)\n      {\n  \tif (i>0) DBG << ' ';\n  \tDBG << '\\'';\n  \tDBG << argv[i];\n  \tDBG << '\\'';\n      }\n      DBG << endl;\n  \n      // Create module process\n      if ((pid = fork()) == 0)\n      {\n  \tif (use_pty)\n  \t{\n  \t    setsid();\n  \t    if(slave_tty != 1)\n  \t\tdup2 (slave_tty, 1);\t  // set new stdout\n  \t    renumber_fd (slave_tty, 0);\t  // set new stdin\n  \t    ::close(master_tty);\t  // Belongs to father process\n  \n  \t    // We currently have no controlling terminal (due to setsid).\n  \t    // The first open call will also set the new ctty (due to historical\n  \t    // unix guru knowledge ;-) )\n  \n  \t    char name[512];\n  \t    int err = ttyname_r(slave_tty, name, sizeof(name));\n  \t    if (err == 0)\n  \t\t::close(open(name, O_RDONLY));\n  \t    // else error\n  \t}\n  \telse\n  \t{\n  \t    renumber_fd (to_external[0], 0); // set new stdin\n  \t    ::close(from_external[0]);\t  // Belongs to father process\n  \n  \t    renumber_fd (from_external[1], 1); // set new stdout\n  \t    ::close(to_external\t [1]);\t  // Belongs to father process\n  \t}\n  \n  \t// Handle stderr\n  \tif (stderr_disp == Discard_Stderr)\n  \t{\n  \t    int null_fd = open(\"/dev/null\", O_WRONLY);\n  \t    dup2(null_fd, 2);\n  \t    ::close(null_fd);\n  \t}\n  \telse if (stderr_disp == Stderr_To_Stdout)\n  \t{\n  \t    dup2(1, 2);\n  \t}\n  \telse if (stderr_disp == Stderr_To_FileDesc)\n  \t{\n  \t    // Note: We don't have to close anything regarding stderr_fd.\n  \t    // Our caller is responsible for that.\n  \t    dup2 (stderr_fd, 2);\n  \t}\n  \n  \tfor ( Environment::const_iterator it = environment.begin(); it != environment.end(); ++it ) {\n  \t  setenv( it->first.c_str(), it->second.c_str(), 1 );\n  \t}\n  \n  \tif(default_locale)\n  \t\tsetenv(\"LC_ALL\",\"C\",1);\n  \n  \tif(root)\n  \t{\n  \t    if(chroot(root) == -1)\n  \t    {\n  \t\tERR << \"chroot to \" << root << \" failed: \" << strerror(errno) << endl;\n  \t\t_exit (3);\t\t\t// No sense in returning! I am forked away!!\n  \t    }\n  \t    if(chdir(\"/\") == -1)\n  \t    {\n  \t\tERR << \"chdir to / inside chroot failed: \" << strerror(errno) << endl;\n  \t\t_exit (4);\t\t\t// No sense in returning! I am forked away!!\n  \t    }\n  \t}\n  \n  \t// close all filedesctiptors above stderr\n  \tfor ( int i = ::getdtablesize() - 1; i > 2; --i ) {\n  \t  ::close( i );\n  \t}\n  \n  \texecvp(argv[0], const_cast<char *const *>(argv));\n  \tERR << \"Cannot execute external program \"\n  \t\t << argv[0] << \":\" << strerror(errno) << endl;\n  \t_exit (5);\t\t\t// No sense in returning! I am forked away!!\n      }\n  \n      else if (pid == -1)\t // Fork failed, close everything.\n      {\n  \tif (use_pty) {\n  \t    ::close(master_tty);\n  \t    ::close(slave_tty);\n  \t}\n  \telse {\n  \t    ::close(to_external[0]);\n  \t    ::close(to_external[1]);\n  \t    ::close(from_external[0]);\n  \t    ::close(from_external[1]);\n  \t}\n  \tERR << \"Cannot fork \" << strerror(errno) << endl;\n      }\n  \n      else {\n  \tif (use_pty)\n  \t{\n  \t    ::close(slave_tty);\t       // belongs to child process\n  \t    inputfile  = fdopen(master_tty, \"r\");\n  \t    outputfile = fdopen(master_tty, \"w\");\n  \t}\n  \telse\n  \t{\n  \t    ::close(to_external[0]);   // belongs to child process\n  \t    ::close(from_external[1]); // belongs to child process\n  \t    inputfile = fdopen(from_external[0], \"r\");\n  \t    outputfile = fdopen(to_external[1], \"w\");\n  \t}\n  \n  \tD__ << \"pid \" << pid << \" launched\" << endl;\n  \n  \tif (!inputfile || !outputfile)\n  \t{\n  \t    ERR << \"Cannot create streams to external program \" << argv[0] << endl;\n  \t    close();\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "root.asString",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "root.empty",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  ExternalProgram::ExternalProgram (const char *const *argv, const Environment & environment,\n  \t\t\t\t  Stderr_Disposition stderr_disp, bool use_pty,\n  \t\t\t\t  int stderr_fd, bool default_locale,\n  \t\t\t\t  const Pathname& root, bool pty_trans)\n      : use_pty (use_pty), disable_pty_trans(!pty_trans)\n  {\n      const char* rootdir = NULL;\n      if(!root.empty() && root != \"/\")\n      {\n  \trootdir = root.asString().c_str();\n      }\n      start_program (argv, environment, stderr_disp, stderr_fd, default_locale, rootdir);\n  }\n}"
  },
  {
    "function_name": "ExternalProgram",
    "container": "ExternalProgram",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
    "lines": "59-72",
    "snippet": "ExternalProgram::ExternalProgram (const char *const *argv,\n\t\t\t\t  Stderr_Disposition stderr_disp, bool use_pty,\n\t\t\t\t  int stderr_fd, bool default_locale,\n\t\t\t\t  const Pathname& root, bool pty_trans)\n    : use_pty (use_pty), disable_pty_trans(!pty_trans)\n{\n    const char* rootdir = NULL;\n    if(!root.empty() && root != \"/\")\n    {\n\trootdir = root.asString().c_str();\n    }\n    Environment environment;\n    start_program (argv, environment, stderr_disp, stderr_fd, default_locale, rootdir);\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <cstring> // strsignal",
      "#include <termios.h> // tcsetattr()",
      "#include <stdlib.h> // setenv",
      "#include <pty.h> // openpty",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_program",
          "args": [
            "argv",
            "environment",
            "stderr_disp",
            "stderr_fd",
            "default_locale",
            "rootdir"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "start_program",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "157-322",
          "snippet": "void\nExternalProgram::start_program (const char *const *argv, const Environment & environment,\n\t\t\t\tStderr_Disposition stderr_disp,\n\t\t\t\tint stderr_fd, bool default_locale, const char* root)\n{\n    pid = -1;\n    _exitStatus = 0;\n    int to_external[2], from_external[2];  // fds for pair of pipes\n    int master_tty,\tslave_tty;\t   // fds for pair of ttys\n\n    if (use_pty)\n    {\n\t// Create pair of ttys\n        D__ << \"Using ttys for communication with \" << argv[0] << endl;\n\tif (openpty (&master_tty, &slave_tty, 0, 0, 0) != 0)\n\t{\n\t    ERR << \"openpty failed\" << endl;\n\t    return;\n\t}\n\n\tif (disable_pty_trans)\n\t{\n\t   disableCRLFTranslation(slave_tty);\n\t}\n    }\n    else\n    {\n\t// Create pair of pipes\n\tif (pipe (to_external) != 0 || pipe (from_external) != 0)\n\t{\n\t    ERR << \"pipe failed\" << endl;\n\t    return;\n\t}\n    }\n\n    // do not remove the single quotes around every argument, copy&paste of\n    // command to shell will not work otherwise!\n    DBG << \"Executing \";\n    for (int i = 0; argv[i]; i++)\n    {\n\tif (i>0) DBG << ' ';\n\tDBG << '\\'';\n\tDBG << argv[i];\n\tDBG << '\\'';\n    }\n    DBG << endl;\n\n    // Create module process\n    if ((pid = fork()) == 0)\n    {\n\tif (use_pty)\n\t{\n\t    setsid();\n\t    if(slave_tty != 1)\n\t\tdup2 (slave_tty, 1);\t  // set new stdout\n\t    renumber_fd (slave_tty, 0);\t  // set new stdin\n\t    ::close(master_tty);\t  // Belongs to father process\n\n\t    // We currently have no controlling terminal (due to setsid).\n\t    // The first open call will also set the new ctty (due to historical\n\t    // unix guru knowledge ;-) )\n\n\t    char name[512];\n\t    int err = ttyname_r(slave_tty, name, sizeof(name));\n\t    if (err == 0)\n\t\t::close(open(name, O_RDONLY));\n\t    // else error\n\t}\n\telse\n\t{\n\t    renumber_fd (to_external[0], 0); // set new stdin\n\t    ::close(from_external[0]);\t  // Belongs to father process\n\n\t    renumber_fd (from_external[1], 1); // set new stdout\n\t    ::close(to_external\t [1]);\t  // Belongs to father process\n\t}\n\n\t// Handle stderr\n\tif (stderr_disp == Discard_Stderr)\n\t{\n\t    int null_fd = open(\"/dev/null\", O_WRONLY);\n\t    dup2(null_fd, 2);\n\t    ::close(null_fd);\n\t}\n\telse if (stderr_disp == Stderr_To_Stdout)\n\t{\n\t    dup2(1, 2);\n\t}\n\telse if (stderr_disp == Stderr_To_FileDesc)\n\t{\n\t    // Note: We don't have to close anything regarding stderr_fd.\n\t    // Our caller is responsible for that.\n\t    dup2 (stderr_fd, 2);\n\t}\n\n\tfor ( Environment::const_iterator it = environment.begin(); it != environment.end(); ++it ) {\n\t  setenv( it->first.c_str(), it->second.c_str(), 1 );\n\t}\n\n\tif(default_locale)\n\t\tsetenv(\"LC_ALL\",\"C\",1);\n\n\tif(root)\n\t{\n\t    if(chroot(root) == -1)\n\t    {\n\t\tERR << \"chroot to \" << root << \" failed: \" << strerror(errno) << endl;\n\t\t_exit (3);\t\t\t// No sense in returning! I am forked away!!\n\t    }\n\t    if(chdir(\"/\") == -1)\n\t    {\n\t\tERR << \"chdir to / inside chroot failed: \" << strerror(errno) << endl;\n\t\t_exit (4);\t\t\t// No sense in returning! I am forked away!!\n\t    }\n\t}\n\n\t// close all filedesctiptors above stderr\n\tfor ( int i = ::getdtablesize() - 1; i > 2; --i ) {\n\t  ::close( i );\n\t}\n\n\texecvp(argv[0], const_cast<char *const *>(argv));\n\tERR << \"Cannot execute external program \"\n\t\t << argv[0] << \":\" << strerror(errno) << endl;\n\t_exit (5);\t\t\t// No sense in returning! I am forked away!!\n    }\n\n    else if (pid == -1)\t // Fork failed, close everything.\n    {\n\tif (use_pty) {\n\t    ::close(master_tty);\n\t    ::close(slave_tty);\n\t}\n\telse {\n\t    ::close(to_external[0]);\n\t    ::close(to_external[1]);\n\t    ::close(from_external[0]);\n\t    ::close(from_external[1]);\n\t}\n\tERR << \"Cannot fork \" << strerror(errno) << endl;\n    }\n\n    else {\n\tif (use_pty)\n\t{\n\t    ::close(slave_tty);\t       // belongs to child process\n\t    inputfile  = fdopen(master_tty, \"r\");\n\t    outputfile = fdopen(master_tty, \"w\");\n\t}\n\telse\n\t{\n\t    ::close(to_external[0]);   // belongs to child process\n\t    ::close(from_external[1]); // belongs to child process\n\t    inputfile = fdopen(from_external[0], \"r\");\n\t    outputfile = fdopen(to_external[1], \"w\");\n\t}\n\n\tD__ << \"pid \" << pid << \" launched\" << endl;\n\n\tif (!inputfile || !outputfile)\n\t{\n\t    ERR << \"Cannot create streams to external program \" << argv[0] << endl;\n\t    close();\n\t}\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  void\n  ExternalProgram::start_program (const char *const *argv, const Environment & environment,\n  \t\t\t\tStderr_Disposition stderr_disp,\n  \t\t\t\tint stderr_fd, bool default_locale, const char* root)\n  {\n      pid = -1;\n      _exitStatus = 0;\n      int to_external[2], from_external[2];  // fds for pair of pipes\n      int master_tty,\tslave_tty;\t   // fds for pair of ttys\n  \n      if (use_pty)\n      {\n  \t// Create pair of ttys\n          D__ << \"Using ttys for communication with \" << argv[0] << endl;\n  \tif (openpty (&master_tty, &slave_tty, 0, 0, 0) != 0)\n  \t{\n  \t    ERR << \"openpty failed\" << endl;\n  \t    return;\n  \t}\n  \n  \tif (disable_pty_trans)\n  \t{\n  \t   disableCRLFTranslation(slave_tty);\n  \t}\n      }\n      else\n      {\n  \t// Create pair of pipes\n  \tif (pipe (to_external) != 0 || pipe (from_external) != 0)\n  \t{\n  \t    ERR << \"pipe failed\" << endl;\n  \t    return;\n  \t}\n      }\n  \n      // do not remove the single quotes around every argument, copy&paste of\n      // command to shell will not work otherwise!\n      DBG << \"Executing \";\n      for (int i = 0; argv[i]; i++)\n      {\n  \tif (i>0) DBG << ' ';\n  \tDBG << '\\'';\n  \tDBG << argv[i];\n  \tDBG << '\\'';\n      }\n      DBG << endl;\n  \n      // Create module process\n      if ((pid = fork()) == 0)\n      {\n  \tif (use_pty)\n  \t{\n  \t    setsid();\n  \t    if(slave_tty != 1)\n  \t\tdup2 (slave_tty, 1);\t  // set new stdout\n  \t    renumber_fd (slave_tty, 0);\t  // set new stdin\n  \t    ::close(master_tty);\t  // Belongs to father process\n  \n  \t    // We currently have no controlling terminal (due to setsid).\n  \t    // The first open call will also set the new ctty (due to historical\n  \t    // unix guru knowledge ;-) )\n  \n  \t    char name[512];\n  \t    int err = ttyname_r(slave_tty, name, sizeof(name));\n  \t    if (err == 0)\n  \t\t::close(open(name, O_RDONLY));\n  \t    // else error\n  \t}\n  \telse\n  \t{\n  \t    renumber_fd (to_external[0], 0); // set new stdin\n  \t    ::close(from_external[0]);\t  // Belongs to father process\n  \n  \t    renumber_fd (from_external[1], 1); // set new stdout\n  \t    ::close(to_external\t [1]);\t  // Belongs to father process\n  \t}\n  \n  \t// Handle stderr\n  \tif (stderr_disp == Discard_Stderr)\n  \t{\n  \t    int null_fd = open(\"/dev/null\", O_WRONLY);\n  \t    dup2(null_fd, 2);\n  \t    ::close(null_fd);\n  \t}\n  \telse if (stderr_disp == Stderr_To_Stdout)\n  \t{\n  \t    dup2(1, 2);\n  \t}\n  \telse if (stderr_disp == Stderr_To_FileDesc)\n  \t{\n  \t    // Note: We don't have to close anything regarding stderr_fd.\n  \t    // Our caller is responsible for that.\n  \t    dup2 (stderr_fd, 2);\n  \t}\n  \n  \tfor ( Environment::const_iterator it = environment.begin(); it != environment.end(); ++it ) {\n  \t  setenv( it->first.c_str(), it->second.c_str(), 1 );\n  \t}\n  \n  \tif(default_locale)\n  \t\tsetenv(\"LC_ALL\",\"C\",1);\n  \n  \tif(root)\n  \t{\n  \t    if(chroot(root) == -1)\n  \t    {\n  \t\tERR << \"chroot to \" << root << \" failed: \" << strerror(errno) << endl;\n  \t\t_exit (3);\t\t\t// No sense in returning! I am forked away!!\n  \t    }\n  \t    if(chdir(\"/\") == -1)\n  \t    {\n  \t\tERR << \"chdir to / inside chroot failed: \" << strerror(errno) << endl;\n  \t\t_exit (4);\t\t\t// No sense in returning! I am forked away!!\n  \t    }\n  \t}\n  \n  \t// close all filedesctiptors above stderr\n  \tfor ( int i = ::getdtablesize() - 1; i > 2; --i ) {\n  \t  ::close( i );\n  \t}\n  \n  \texecvp(argv[0], const_cast<char *const *>(argv));\n  \tERR << \"Cannot execute external program \"\n  \t\t << argv[0] << \":\" << strerror(errno) << endl;\n  \t_exit (5);\t\t\t// No sense in returning! I am forked away!!\n      }\n  \n      else if (pid == -1)\t // Fork failed, close everything.\n      {\n  \tif (use_pty) {\n  \t    ::close(master_tty);\n  \t    ::close(slave_tty);\n  \t}\n  \telse {\n  \t    ::close(to_external[0]);\n  \t    ::close(to_external[1]);\n  \t    ::close(from_external[0]);\n  \t    ::close(from_external[1]);\n  \t}\n  \tERR << \"Cannot fork \" << strerror(errno) << endl;\n      }\n  \n      else {\n  \tif (use_pty)\n  \t{\n  \t    ::close(slave_tty);\t       // belongs to child process\n  \t    inputfile  = fdopen(master_tty, \"r\");\n  \t    outputfile = fdopen(master_tty, \"w\");\n  \t}\n  \telse\n  \t{\n  \t    ::close(to_external[0]);   // belongs to child process\n  \t    ::close(from_external[1]); // belongs to child process\n  \t    inputfile = fdopen(from_external[0], \"r\");\n  \t    outputfile = fdopen(to_external[1], \"w\");\n  \t}\n  \n  \tD__ << \"pid \" << pid << \" launched\" << endl;\n  \n  \tif (!inputfile || !outputfile)\n  \t{\n  \t    ERR << \"Cannot create streams to external program \" << argv[0] << endl;\n  \t    close();\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "root.asString",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "root.empty",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  ExternalProgram::ExternalProgram (const char *const *argv,\n  \t\t\t\t  Stderr_Disposition stderr_disp, bool use_pty,\n  \t\t\t\t  int stderr_fd, bool default_locale,\n  \t\t\t\t  const Pathname& root, bool pty_trans)\n      : use_pty (use_pty), disable_pty_trans(!pty_trans)\n  {\n      const char* rootdir = NULL;\n      if(!root.empty() && root != \"/\")\n      {\n  \trootdir = root.asString().c_str();\n      }\n      Environment environment;\n      start_program (argv, environment, stderr_disp, stderr_fd, default_locale, rootdir);\n  }\n}"
  },
  {
    "function_name": "ExternalProgram",
    "container": "ExternalProgram",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
    "lines": "37-56",
    "snippet": "ExternalProgram::ExternalProgram (string commandline,\n\t\t\t\t  Stderr_Disposition stderr_disp, bool use_pty,\n\t\t\t\t  int stderr_fd, bool default_locale,\n\t\t\t\t  const Pathname& root, bool pty_trans)\n    : use_pty (use_pty), disable_pty_trans(!pty_trans)\n{\n    const char *argv[4];\n    argv[0] = \"/bin/sh\";\n    argv[1] = \"-c\";\n    argv[2] = commandline.c_str();\n    argv[3] = 0;\n\n    const char* rootdir = NULL;\n    if(!root.empty() && root != \"/\")\n    {\n\trootdir = root.asString().c_str();\n    }\n    Environment environment;\n    start_program (argv, environment, stderr_disp, stderr_fd, default_locale, rootdir);\n}",
    "includes": [
      "#include <y2util/ExternalProgram.h>",
      "#include <y2util/Y2SLog.h>",
      "#include <cstring> // strsignal",
      "#include <termios.h> // tcsetattr()",
      "#include <stdlib.h> // setenv",
      "#include <pty.h> // openpty",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <unistd.h>",
      "#include <errno.h>",
      "#include <signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_program",
          "args": [
            "argv",
            "environment",
            "stderr_disp",
            "stderr_fd",
            "default_locale",
            "rootdir"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "start_program",
          "container": "ExternalProgram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/ExternalProgram.cc",
          "lines": "157-322",
          "snippet": "void\nExternalProgram::start_program (const char *const *argv, const Environment & environment,\n\t\t\t\tStderr_Disposition stderr_disp,\n\t\t\t\tint stderr_fd, bool default_locale, const char* root)\n{\n    pid = -1;\n    _exitStatus = 0;\n    int to_external[2], from_external[2];  // fds for pair of pipes\n    int master_tty,\tslave_tty;\t   // fds for pair of ttys\n\n    if (use_pty)\n    {\n\t// Create pair of ttys\n        D__ << \"Using ttys for communication with \" << argv[0] << endl;\n\tif (openpty (&master_tty, &slave_tty, 0, 0, 0) != 0)\n\t{\n\t    ERR << \"openpty failed\" << endl;\n\t    return;\n\t}\n\n\tif (disable_pty_trans)\n\t{\n\t   disableCRLFTranslation(slave_tty);\n\t}\n    }\n    else\n    {\n\t// Create pair of pipes\n\tif (pipe (to_external) != 0 || pipe (from_external) != 0)\n\t{\n\t    ERR << \"pipe failed\" << endl;\n\t    return;\n\t}\n    }\n\n    // do not remove the single quotes around every argument, copy&paste of\n    // command to shell will not work otherwise!\n    DBG << \"Executing \";\n    for (int i = 0; argv[i]; i++)\n    {\n\tif (i>0) DBG << ' ';\n\tDBG << '\\'';\n\tDBG << argv[i];\n\tDBG << '\\'';\n    }\n    DBG << endl;\n\n    // Create module process\n    if ((pid = fork()) == 0)\n    {\n\tif (use_pty)\n\t{\n\t    setsid();\n\t    if(slave_tty != 1)\n\t\tdup2 (slave_tty, 1);\t  // set new stdout\n\t    renumber_fd (slave_tty, 0);\t  // set new stdin\n\t    ::close(master_tty);\t  // Belongs to father process\n\n\t    // We currently have no controlling terminal (due to setsid).\n\t    // The first open call will also set the new ctty (due to historical\n\t    // unix guru knowledge ;-) )\n\n\t    char name[512];\n\t    int err = ttyname_r(slave_tty, name, sizeof(name));\n\t    if (err == 0)\n\t\t::close(open(name, O_RDONLY));\n\t    // else error\n\t}\n\telse\n\t{\n\t    renumber_fd (to_external[0], 0); // set new stdin\n\t    ::close(from_external[0]);\t  // Belongs to father process\n\n\t    renumber_fd (from_external[1], 1); // set new stdout\n\t    ::close(to_external\t [1]);\t  // Belongs to father process\n\t}\n\n\t// Handle stderr\n\tif (stderr_disp == Discard_Stderr)\n\t{\n\t    int null_fd = open(\"/dev/null\", O_WRONLY);\n\t    dup2(null_fd, 2);\n\t    ::close(null_fd);\n\t}\n\telse if (stderr_disp == Stderr_To_Stdout)\n\t{\n\t    dup2(1, 2);\n\t}\n\telse if (stderr_disp == Stderr_To_FileDesc)\n\t{\n\t    // Note: We don't have to close anything regarding stderr_fd.\n\t    // Our caller is responsible for that.\n\t    dup2 (stderr_fd, 2);\n\t}\n\n\tfor ( Environment::const_iterator it = environment.begin(); it != environment.end(); ++it ) {\n\t  setenv( it->first.c_str(), it->second.c_str(), 1 );\n\t}\n\n\tif(default_locale)\n\t\tsetenv(\"LC_ALL\",\"C\",1);\n\n\tif(root)\n\t{\n\t    if(chroot(root) == -1)\n\t    {\n\t\tERR << \"chroot to \" << root << \" failed: \" << strerror(errno) << endl;\n\t\t_exit (3);\t\t\t// No sense in returning! I am forked away!!\n\t    }\n\t    if(chdir(\"/\") == -1)\n\t    {\n\t\tERR << \"chdir to / inside chroot failed: \" << strerror(errno) << endl;\n\t\t_exit (4);\t\t\t// No sense in returning! I am forked away!!\n\t    }\n\t}\n\n\t// close all filedesctiptors above stderr\n\tfor ( int i = ::getdtablesize() - 1; i > 2; --i ) {\n\t  ::close( i );\n\t}\n\n\texecvp(argv[0], const_cast<char *const *>(argv));\n\tERR << \"Cannot execute external program \"\n\t\t << argv[0] << \":\" << strerror(errno) << endl;\n\t_exit (5);\t\t\t// No sense in returning! I am forked away!!\n    }\n\n    else if (pid == -1)\t // Fork failed, close everything.\n    {\n\tif (use_pty) {\n\t    ::close(master_tty);\n\t    ::close(slave_tty);\n\t}\n\telse {\n\t    ::close(to_external[0]);\n\t    ::close(to_external[1]);\n\t    ::close(from_external[0]);\n\t    ::close(from_external[1]);\n\t}\n\tERR << \"Cannot fork \" << strerror(errno) << endl;\n    }\n\n    else {\n\tif (use_pty)\n\t{\n\t    ::close(slave_tty);\t       // belongs to child process\n\t    inputfile  = fdopen(master_tty, \"r\");\n\t    outputfile = fdopen(master_tty, \"w\");\n\t}\n\telse\n\t{\n\t    ::close(to_external[0]);   // belongs to child process\n\t    ::close(from_external[1]); // belongs to child process\n\t    inputfile = fdopen(from_external[0], \"r\");\n\t    outputfile = fdopen(to_external[1], \"w\");\n\t}\n\n\tD__ << \"pid \" << pid << \" launched\" << endl;\n\n\tif (!inputfile || !outputfile)\n\t{\n\t    ERR << \"Cannot create streams to external program \" << argv[0] << endl;\n\t    close();\n\t}\n    }\n}",
          "includes": [
            "#include <y2util/ExternalProgram.h>",
            "#include <y2util/Y2SLog.h>",
            "#include <cstring> // strsignal",
            "#include <termios.h> // tcsetattr()",
            "#include <stdlib.h> // setenv",
            "#include <pty.h> // openpty",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  void\n  ExternalProgram::start_program (const char *const *argv, const Environment & environment,\n  \t\t\t\tStderr_Disposition stderr_disp,\n  \t\t\t\tint stderr_fd, bool default_locale, const char* root)\n  {\n      pid = -1;\n      _exitStatus = 0;\n      int to_external[2], from_external[2];  // fds for pair of pipes\n      int master_tty,\tslave_tty;\t   // fds for pair of ttys\n  \n      if (use_pty)\n      {\n  \t// Create pair of ttys\n          D__ << \"Using ttys for communication with \" << argv[0] << endl;\n  \tif (openpty (&master_tty, &slave_tty, 0, 0, 0) != 0)\n  \t{\n  \t    ERR << \"openpty failed\" << endl;\n  \t    return;\n  \t}\n  \n  \tif (disable_pty_trans)\n  \t{\n  \t   disableCRLFTranslation(slave_tty);\n  \t}\n      }\n      else\n      {\n  \t// Create pair of pipes\n  \tif (pipe (to_external) != 0 || pipe (from_external) != 0)\n  \t{\n  \t    ERR << \"pipe failed\" << endl;\n  \t    return;\n  \t}\n      }\n  \n      // do not remove the single quotes around every argument, copy&paste of\n      // command to shell will not work otherwise!\n      DBG << \"Executing \";\n      for (int i = 0; argv[i]; i++)\n      {\n  \tif (i>0) DBG << ' ';\n  \tDBG << '\\'';\n  \tDBG << argv[i];\n  \tDBG << '\\'';\n      }\n      DBG << endl;\n  \n      // Create module process\n      if ((pid = fork()) == 0)\n      {\n  \tif (use_pty)\n  \t{\n  \t    setsid();\n  \t    if(slave_tty != 1)\n  \t\tdup2 (slave_tty, 1);\t  // set new stdout\n  \t    renumber_fd (slave_tty, 0);\t  // set new stdin\n  \t    ::close(master_tty);\t  // Belongs to father process\n  \n  \t    // We currently have no controlling terminal (due to setsid).\n  \t    // The first open call will also set the new ctty (due to historical\n  \t    // unix guru knowledge ;-) )\n  \n  \t    char name[512];\n  \t    int err = ttyname_r(slave_tty, name, sizeof(name));\n  \t    if (err == 0)\n  \t\t::close(open(name, O_RDONLY));\n  \t    // else error\n  \t}\n  \telse\n  \t{\n  \t    renumber_fd (to_external[0], 0); // set new stdin\n  \t    ::close(from_external[0]);\t  // Belongs to father process\n  \n  \t    renumber_fd (from_external[1], 1); // set new stdout\n  \t    ::close(to_external\t [1]);\t  // Belongs to father process\n  \t}\n  \n  \t// Handle stderr\n  \tif (stderr_disp == Discard_Stderr)\n  \t{\n  \t    int null_fd = open(\"/dev/null\", O_WRONLY);\n  \t    dup2(null_fd, 2);\n  \t    ::close(null_fd);\n  \t}\n  \telse if (stderr_disp == Stderr_To_Stdout)\n  \t{\n  \t    dup2(1, 2);\n  \t}\n  \telse if (stderr_disp == Stderr_To_FileDesc)\n  \t{\n  \t    // Note: We don't have to close anything regarding stderr_fd.\n  \t    // Our caller is responsible for that.\n  \t    dup2 (stderr_fd, 2);\n  \t}\n  \n  \tfor ( Environment::const_iterator it = environment.begin(); it != environment.end(); ++it ) {\n  \t  setenv( it->first.c_str(), it->second.c_str(), 1 );\n  \t}\n  \n  \tif(default_locale)\n  \t\tsetenv(\"LC_ALL\",\"C\",1);\n  \n  \tif(root)\n  \t{\n  \t    if(chroot(root) == -1)\n  \t    {\n  \t\tERR << \"chroot to \" << root << \" failed: \" << strerror(errno) << endl;\n  \t\t_exit (3);\t\t\t// No sense in returning! I am forked away!!\n  \t    }\n  \t    if(chdir(\"/\") == -1)\n  \t    {\n  \t\tERR << \"chdir to / inside chroot failed: \" << strerror(errno) << endl;\n  \t\t_exit (4);\t\t\t// No sense in returning! I am forked away!!\n  \t    }\n  \t}\n  \n  \t// close all filedesctiptors above stderr\n  \tfor ( int i = ::getdtablesize() - 1; i > 2; --i ) {\n  \t  ::close( i );\n  \t}\n  \n  \texecvp(argv[0], const_cast<char *const *>(argv));\n  \tERR << \"Cannot execute external program \"\n  \t\t << argv[0] << \":\" << strerror(errno) << endl;\n  \t_exit (5);\t\t\t// No sense in returning! I am forked away!!\n      }\n  \n      else if (pid == -1)\t // Fork failed, close everything.\n      {\n  \tif (use_pty) {\n  \t    ::close(master_tty);\n  \t    ::close(slave_tty);\n  \t}\n  \telse {\n  \t    ::close(to_external[0]);\n  \t    ::close(to_external[1]);\n  \t    ::close(from_external[0]);\n  \t    ::close(from_external[1]);\n  \t}\n  \tERR << \"Cannot fork \" << strerror(errno) << endl;\n      }\n  \n      else {\n  \tif (use_pty)\n  \t{\n  \t    ::close(slave_tty);\t       // belongs to child process\n  \t    inputfile  = fdopen(master_tty, \"r\");\n  \t    outputfile = fdopen(master_tty, \"w\");\n  \t}\n  \telse\n  \t{\n  \t    ::close(to_external[0]);   // belongs to child process\n  \t    ::close(from_external[1]); // belongs to child process\n  \t    inputfile = fdopen(from_external[0], \"r\");\n  \t    outputfile = fdopen(to_external[1], \"w\");\n  \t}\n  \n  \tD__ << \"pid \" << pid << \" launched\" << endl;\n  \n  \tif (!inputfile || !outputfile)\n  \t{\n  \t    ERR << \"Cannot create streams to external program \" << argv[0] << endl;\n  \t    close();\n  \t}\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "root.asString",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "asString",
          "container": "YCPValueRep",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/libycp/src/YCPValue.cc",
          "lines": "130-140",
          "snippet": "YCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}",
          "includes": [
            "#include \"ycp/YCPExternal.h\"",
            "#include \"ycp/YCPCode.h\"",
            "#include \"ycp/YCPMap.h\"",
            "#include \"ycp/YCPTerm.h\"",
            "#include \"ycp/YCPList.h\"",
            "#include \"ycp/YCPSymbol.h\"",
            "#include \"ycp/YCPPath.h\"",
            "#include \"ycp/YCPByteblock.h\"",
            "#include \"ycp/YCPString.h\"",
            "#include \"ycp/YCPFloat.h\"",
            "#include \"ycp/YCPInteger.h\"",
            "#include \"ycp/YCPBoolean.h\"",
            "#include \"ycp/YCPVoid.h\"",
            "#include \"ycp/ExecutionEnvironment.h\"",
            "#include \"ycp/y2log.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ycp/YCPExternal.h\"\n#include \"ycp/YCPCode.h\"\n#include \"ycp/YCPMap.h\"\n#include \"ycp/YCPTerm.h\"\n#include \"ycp/YCPList.h\"\n#include \"ycp/YCPSymbol.h\"\n#include \"ycp/YCPPath.h\"\n#include \"ycp/YCPByteblock.h\"\n#include \"ycp/YCPString.h\"\n#include \"ycp/YCPFloat.h\"\n#include \"ycp/YCPInteger.h\"\n#include \"ycp/YCPBoolean.h\"\n#include \"ycp/YCPVoid.h\"\n#include \"ycp/ExecutionEnvironment.h\"\n#include \"ycp/y2log.h\"\n\nYCPValueRep {\n  YCPString\n  YCPValueRep::asString() const\n  {\n      if (!isString())\n      {\n  \tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n  \t      toString().c_str());\n  \tabort();\n      }\n      return YCPString (static_cast<const YCPStringRep *>(this));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "root.empty",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Pathname",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/liby2util-r/src/include/y2util/Pathname.h",
          "lines": "66-66",
          "snippet": "bool empty()    const { return !name_t.size(); }",
          "includes": [
            "#include <string>",
            "#include <iosfwd>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <iosfwd>\n\nPathname {\n  bool empty()    const { return !name_t.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "commandline.c_str",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <y2util/ExternalProgram.h>\n#include <y2util/Y2SLog.h>\n#include <cstring> // strsignal\n#include <termios.h> // tcsetattr()\n#include <stdlib.h> // setenv\n#include <pty.h> // openpty\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n\nExternalProgram {\n  ExternalProgram::ExternalProgram (string commandline,\n  \t\t\t\t  Stderr_Disposition stderr_disp, bool use_pty,\n  \t\t\t\t  int stderr_fd, bool default_locale,\n  \t\t\t\t  const Pathname& root, bool pty_trans)\n      : use_pty (use_pty), disable_pty_trans(!pty_trans)\n  {\n      const char *argv[4];\n      argv[0] = \"/bin/sh\";\n      argv[1] = \"-c\";\n      argv[2] = commandline.c_str();\n      argv[3] = 0;\n  \n      const char* rootdir = NULL;\n      if(!root.empty() && root != \"/\")\n      {\n  \trootdir = root.asString().c_str();\n      }\n      Environment environment;\n      start_program (argv, environment, stderr_disp, stderr_fd, default_locale, rootdir);\n  }\n}"
  }
]