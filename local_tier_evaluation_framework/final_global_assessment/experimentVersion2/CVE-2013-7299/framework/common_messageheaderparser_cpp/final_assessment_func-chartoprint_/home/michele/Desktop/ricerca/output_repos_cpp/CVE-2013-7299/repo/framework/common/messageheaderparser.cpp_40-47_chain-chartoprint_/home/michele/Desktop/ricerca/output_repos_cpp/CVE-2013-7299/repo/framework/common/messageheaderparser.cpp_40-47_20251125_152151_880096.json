{
  "assessment_type": "combined",
  "id": [
    "chartoprint",
    "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "40-47"
  ],
  "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
  "function_name": "chartoprint",
  "function_code": "#include <cxxtools/log.h>\n#include <cctype>\n#include <tnt/http.h>\n#include <tnt/httperror.h>\n#include <tnt/messageheaderparser.h>\n\nstd::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n",
  "chain_code": "---- CALL CHAIN SNIPPETS ----\n\n---- TARGET FUNCTION ----\nstd::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }\n\n---- CALLER 1 ----\nbool HttpRequest::Parser::state_version_minor(char ch)\n  {\n    if (ch == '\\n')\n      SET_STATE(state_header);\n    else if (ch == ' ' || ch == '\\t' || ch == '\\r')\n      SET_STATE(state_end0);\n    else if (std::isdigit(ch))\n      message.setVersion(message.getMajorVersion(), message.getMinorVersion() * 10 + (ch - '0'));\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in version-minor\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n    return failedFlag;\n  }\n\n---- CALLER 2 ----\nbool HttpRequest::Parser::state_version_minor0(char ch)\n  {\n    return ch == ' ' || ch == '\\t' ? failedFlag\n                                   : state_version_minor(ch);\n  }",
  "False_positive_reason": "",
  "Preconditions": [
    "The HTTP request contains a non-printable character with a signed char value where the high bit is set (e.g., 0x80).",
    "The character is passed to chartoprint() via the HTTP parser (state_version_minor0 \u2192 state_version_minor \u2192 chartoprint)."
  ],
  "Trigger_actions": [
    "An attacker sends an HTTP request with a malicious byte value that triggers the invalid character handling path in state_version_minor()."
  ],
  "Dangerous_post_conditions": [
    "hex[ch >> 4] evaluates to a negative index (due to sign-extended signed char bitshift), causing an out-of-bounds memory read of arbitrary bytes before the hex[] array.",
    "The vulnerability leaks memory locations adjacent to the hex[] array in the log message output."
  ],
  "Initial_conditions": [
    "The HTTP parser must execute in a path that reaches state_version_minor(), such as during HTTP version parsing.",
    "The server must include the chartoprint() output in logs or error responses for the memory leak to be observable."
  ]
}