{
  "assessment_type": "function_only",
  "id": [
    "Messageheader::Parser::state_fieldbody_crlf",
    "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "190-235"
  ],
  "file_path": "/home/michele/Desktop/ricerca/agents/local_tier_evaluation_framework/enriched_snippets/CVE-2013-7299/framework/common_messageheaderparser_cpp/enriched_snippets.json",
  "function_name": "Messageheader::Parser::state_fieldbody_crlf",
  "function_code": "#include <cxxtools/log.h>\n#include <cctype>\n#include <tnt/http.h>\n#include <tnt/httperror.h>\n#include <tnt/messageheaderparser.h>\n\nbool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      // continuation line\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: checkHeaderspace\nvoid Messageheader::Parser::checkHeaderspace(unsigned chars) const\n  {\n    if (headerdataPtr + chars >= header.rawdata + sizeof(header.rawdata))\n      throw HttpError(HTTP_REQUEST_ENTITY_TOO_LARGE, \"header too large\");\n  }\n\nCallee: chartoprint\nstd::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }\n\nCallee: header.onField\nMessageheader::return_type Messageheader::onField(const char* name, const char* value)\n  {\n    log_debug(name << ' ' << value);\n    return OK;\n  }\n",
  "chain_code": null,
  "False_positive_reason": "",
  "Preconditions": [
    "headerdataPtr points to the start of the buffer"
  ],
  "Trigger_actions": [
    "An attacker sends a crafted HTTP header containing continuation lines that force the parser into the state_fieldbody_crlf state with headerdataPtr at buffer start"
  ],
  "Dangerous_post_conditions": [
    "Buffer underflow occurs by writing to *(headerdataPtr - 1), corrupting adjacent memory",
    "Potential for arbitrary memory write or information disclosure"
  ],
  "Initial_conditions": [
    "Parsing HTTP headers is active",
    "headerdataPtr is initialized to point at the beginning of the rawdata buffer"
  ]
}