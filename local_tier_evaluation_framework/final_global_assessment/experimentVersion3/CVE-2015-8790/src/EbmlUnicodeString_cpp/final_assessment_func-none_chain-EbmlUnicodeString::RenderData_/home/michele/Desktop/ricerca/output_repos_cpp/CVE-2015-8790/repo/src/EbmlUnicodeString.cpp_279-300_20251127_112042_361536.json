{
  "assessment_type": "chain_only",
  "id": [
    "EbmlUnicodeString::RenderData",
    "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "279-300"
  ],
  "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
  "function_name": "EbmlUnicodeString::RenderData",
  "function_code": null,
  "chain_code": "---- CALL CHAIN SNIPPETS ----\n\n---- TARGET FUNCTION ----\nfilepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}\n\n---- CALLER 1 ----\nfilepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender,\n\n---- CALLER 2 ----\nvoid EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
  "False_positive_reason": "",
  "Preconditions": [
    "Sensitive data is stored in `EbmlUnicodeString::Value`",
    "Call to `EbmlCrc32::AddElementCRC32` with an `EbmlElement` containing sensitive `EbmlUnicodeString` data"
  ],
  "Trigger_actions": [
    "Invoking `Render` on an `EbmlElement` containing sensitive `EbmlUnicodeString` data within `AddElementCRC32`",
    "Use of `MemIOCallback` to capture raw string data into memory buffer"
  ],
  "Dangerous_post_conditions": [
    "Sensitive UTF-8 string data is stored in `memoryBuffer`'s unprotected buffer via `memoryBuffer.GetDataBuffer()`",
    "Buffer remains accessible after CRC computation"
  ],
  "Initial_conditions": [
    "`EbmlUnicodeString::Value` must contain sensitive information",
    "Subsequent code must transmit/store `MemIOCallback` buffer without encryption/access controls"
  ]
}