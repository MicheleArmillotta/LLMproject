[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "PidFile::releasePidFile",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 3,
      "snippets": [
        {
          "qualified_name": "PidFile::releasePidFile",
          "snippet": "void releasePidFile()  { pidFileName.clear(); }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/runtime/process.cpp",
          "lines": "108-108"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The target function 'Messageheader::Parser::reset()' is not vulnerable as it performs safe state-resetting operations. The provided caller functions (HttpReply::Impl::Pool::clear(), releasePidFile()) do not invoke the target function, and no data flows from external sources into the target function. No unsafe input handling, memory operations, or undefined behaviors are present in the target function itself. The macro 'SET_STATE' is considered safe based on available context.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "SET_STATE",
      "HttpReply::Impl::Pool::clear()",
      "releasePidFile()"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "Dispatcher::mapCompNext",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 3,
      "snippets": [
        {
          "qualified_name": "Dispatcher::mapCompNext",
          "snippet": "Maptarget Dispatcher::mapCompNext(const HttpRequest& request,\n  Dispatcher::urlmap_type::size_type& pos) const\n{\n  std::string vhost = request.getHost();\n  std::string compUrl = request.getUrl();\n\n  if (pos < urlmap.size())\n  {\n    // check cache\n    cxxtools::ReadLock lock(urlMapCacheMutex, false);\n\n    urlMapCacheType::key_type cacheKey(request, pos);\n    log_debug(\"host=\\\"\" << cacheKey.getHost() << \"\\\" url=\\\"\" << cacheKey.getUrl() << \"\\\" method=\\\"\" << cacheKey.getMethod() << \"\\\" ssl=\" << cacheKey.getSsl() << \" pos=\" << cacheKey.getPos());\n\n    if (TntConfig::it().maxUrlMapCache > 0)\n    {\n ",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/dispatcher.cpp",
          "lines": "136-211"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The caller chain does not introduce vulnerabilities into the target function 'Messageheader::Parser::reset()'. The two callers provided are unrelated to the reset() function's invocation. One manages object deletion, and the other processes HTTP request routing, but neither directly or indirectly pass untrusted data into reset(). Since the target function itself is not vulnerable and the callers do not alter its safe usage patterns, the chain remains not vulnerable.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "HttpReply::Impl::Pool::clear()",
      "failedFlag",
      "headerdataPtr",
      "SET_STATE",
      "header.rawdata",
      "poolMutex",
      "pool",
      "request.getHost()",
      "request.getUrl()"
    ],
    "Hallucinated_entities": [
      "Maptarget Dispatcher::mapCompNext"
    ],
    "Coverage": 0.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "MessageattributeParser::parse",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 3,
      "snippets": [
        {
          "qualified_name": "MessageattributeParser::parse",
          "snippet": "void MessageattributeParser::parse(std::istream& in)\n  {\n    enum state_type\n    {\n      state_0,\n      state_type0,\n      state_type_sp,\n      state_subtype0,\n      state_subtype,\n      state_subtype_sp,\n      state_attribute0,\n      state_attribute,\n      state_attribute_sp,\n      state_value0,\n      state_value,\n      state_qvalue,\n      state_end\n    };\n\n    state_type state = state_0;\n    std::streambuf* buf = in.rdbuf();\n\n    std::string type, subtype, attribute, value;\n\n    while (state != state_end && buf->sgetc() != std::ios::traits_type::eof())\n    {\n      char ch = buf->sgetc();\n   ",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageattribute.cpp",
          "lines": "53-307"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The caller chain for 'Messageheader::Parser::reset()' does not introduce vulnerabilities. The function is called without passing untrusted or external data, and its invocation (e.g., in 'HttpReply::Impl::Pool::clear()' and 'MessageattributeParser::parse') solely resets internal state. The target function processes no external input, and the caller chain lacks unsafe data-flow patterns.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "HttpReply::Impl::Pool::clear()",
      "MessageattributeParser::parse()",
      "failedFlag",
      "headerdataPtr",
      "header.rawdata",
      "SET_STATE",
      "state_0"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "HttpRequest::HttpRequest",
        "MessageattributeParser::parse",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 4,
      "snippets": [
        {
          "qualified_name": "HttpRequest::HttpRequest",
          "snippet": "HttpRequest::HttpRequest(Tntnet& application_, const SocketIf* socketIf_)\n    : socketIf(socketIf_),\n      locale_init(false),\n      encodingRead(false),\n      requestScope(0),\n      applicationScope(0),\n      sessionScope(0),\n      secureSessionScope(0),\n      threadContext(0),\n      applicationScopeLocked(false),\n      sessionScopeLocked(false),\n      secureSessionScopeLocked(false),\n      application(application_)\n  {\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httprequest.cpp",
          "lines": "56-70"
        },
        {
          "qualified_name": "MessageattributeParser::parse",
          "snippet": "void MessageattributeParser::parse(std::istream& in)\n  {\n    enum state_type\n    {\n      state_0,\n      state_type0,\n      state_type_sp,\n      state_subtype0,\n      state_subtype,\n      state_subtype_sp,\n      state_attribute0,\n      state_attribute,\n      state_attribute_sp,\n      state_value0,\n      state_value,\n      state_qvalue,\n      state_end\n    };\n\n    state_type state = state_0;\n    std::streambuf* buf = in.rdbuf();\n\n    std::string type, subtype, attribute, value;\n\n    while (state != state_end && buf->sgetc() != std::ios::traits_type::eof())\n    {\n      char ch = buf->sgetc();\n   ",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageattribute.cpp",
          "lines": "53-307"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The target function 'Messageheader::Parser::reset()' is safely invoked across its caller chain. None of the callers introduce untrusted or external data into the function, and all uses of the function are confined to resetting internal state variables (e.g., pointers, flags) without interacting with external inputs. The 'HttpRequest' constructor initializes parser state without exposing it to unvalidated data, and neither 'HttpReply::Impl::Pool::clear()' nor 'MessageattributeParser::parse()' flow tainted or untrusted inputs into the target function.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "failedFlag",
      "headerdataPtr",
      "SET_STATE",
      "state_0",
      "HttpReply::Impl::Pool::clear()",
      "MessageattributeParser::parse()",
      "HttpRequest::HttpRequest()"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_header",
        "MessageattributeParser::parse",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 4,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_header",
          "snippet": "bool HttpRequest::Parser::state_header(char ch)\n  {\n    if (headerParser.parse(ch))\n    {\n      if (headerParser.failed())\n      {\n        httpCode = HTTP_BAD_REQUEST;\n        failedFlag = true;\n        return true;\n      }\n\n      const char* content_length_header = message.getHeader(httpheader::contentLength);\n      if (*content_length_header)\n      {\n        bodySize = 0;\n        for (const char* c = content_length_header; *c; ++c)\n        {\n          if (*c > '9' || *c < '0')\n            throw HttpError(HTTP_BAD_REQUEST, \"invalid Content-Length\");\n          bodySize = bodySize * 10 + *c - '",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "394-438"
        },
        {
          "qualified_name": "MessageattributeParser::parse",
          "snippet": "void MessageattributeParser::parse(std::istream& in)\n  {\n    enum state_type\n    {\n      state_0,\n      state_type0,\n      state_type_sp,\n      state_subtype0,\n      state_subtype,\n      state_subtype_sp,\n      state_attribute0,\n      state_attribute,\n      state_attribute_sp,\n      state_value0,\n      state_value,\n      state_qvalue,\n      state_end\n    };\n\n    state_type state = state_0;\n    std::streambuf* buf = in.rdbuf();\n\n    std::string type, subtype, attribute, value;\n\n    while (state != state_end && buf->sgetc() != std::ios::traits_type::eof())\n    {\n      char ch = buf->sgetc();\n   ",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageattribute.cpp",
          "lines": "53-307"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The target function 'Messageheader::Parser::reset()' is not vulnerable. The caller chain involves parser state management but does not pass untrusted data into the target function. The reset() function solely reinitializes internal state variables (failedFlag, headerdataPtr, and state via SET_STATE) without processing input or performing unsafe operations. Since the function has no parameters and only sets known-safe initial values, the invocation chain does not introduce security risks.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "failedFlag",
      "headerdataPtr",
      "header.rawdata",
      "SET_STATE",
      "state_0"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "Encoding::Encoding",
        "MessageattributeParser::parse",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 4,
      "snippets": [
        {
          "qualified_name": "Encoding::Encoding",
          "snippet": "Encoding()  { }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/tnt/encoding.h",
          "lines": "44-44"
        },
        {
          "qualified_name": "MessageattributeParser::parse",
          "snippet": "void MessageattributeParser::parse(std::istream& in)\n  {\n    enum state_type\n    {\n      state_0,\n      state_type0,\n      state_type_sp,\n      state_subtype0,\n      state_subtype,\n      state_subtype_sp,\n      state_attribute0,\n      state_attribute,\n      state_attribute_sp,\n      state_value0,\n      state_value,\n      state_qvalue,\n      state_end\n    };\n\n    state_type state = state_0;\n    std::streambuf* buf = in.rdbuf();\n\n    std::string type, subtype, attribute, value;\n\n    while (state != state_end && buf->sgetc() != std::ios::traits_type::eof())\n    {\n      char ch = buf->sgetc();\n   ",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageattribute.cpp",
          "lines": "53-307"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The target function 'Messageheader::Parser::reset()' is not called with any unsafe input or data from untrusted sources through its callers. None of the provided callers (HttpReply::Impl::Pool::clear(), MessageattributeParser::parse, or Encoding) propagate tainted or external data into the target function. The target function’s state-reset logic, which includes the macro 'SET_STATE', is used internally without risk as it does not process untrusted inputs.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "HttpReply::Impl::Pool::clear()",
      "MessageattributeParser::parse",
      "SET_STATE"
    ],
    "Hallucinated_entities": [
      "Encoding"
    ],
    "Coverage": 0.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "MessageattributeParser::parse",
        "CookieParser::process_nv",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 4,
      "snippets": [
        {
          "qualified_name": "MessageattributeParser::parse",
          "snippet": "void MessageattributeParser::parse(std::istream& in)\n  {\n    enum state_type\n    {\n      state_0,\n      state_type0,\n      state_type_sp,\n      state_subtype0,\n      state_subtype,\n      state_subtype_sp,\n      state_attribute0,\n      state_attribute,\n      state_attribute_sp,\n      state_value0,\n      state_value,\n      state_qvalue,\n      state_end\n    };\n\n    state_type state = state_0;\n    std::streambuf* buf = in.rdbuf();\n\n    std::string type, subtype, attribute, value;\n\n    while (state != state_end && buf->sgetc() != std::ios::traits_type::eof())\n    {\n      char ch = buf->sgetc();\n   ",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageattribute.cpp",
          "lines": "53-307"
        },
        {
          "qualified_name": "CookieParser::process_nv",
          "snippet": "void CookieParser::process_nv()\n  {\n    if (attr)\n    {\n      if (name == Cookie::secure)\n      {\n        log_debug(\"attribute: secure\");\n        current_cookie.secureFlag = true;\n      }\n      else\n      {\n        log_debug(\"attribute: \" << name << '=' << value);\n        current_attrs->insert(\n          Cookie::attrs_type::value_type(name, value));\n      }\n    }\n    else\n    {\n      if (!current_cookie_name.empty())\n        store_cookie();\n\n      log_debug(\"Cookie: \" << name << '=' << value);\n\n      current_cookie_name = name;\n      current_cookie.value = value;\n      current_cookie.secureFla",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/cookie.cpp",
          "lines": "166-196"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The target function 'Messageheader::Parser::reset()' is called in a context where it receives no external or untrusted inputs. Its callers (HttpReply::Impl::Pool::clear(), CookieParser::process_nv(), and MessageattributeParser::parse()) do not propagate tainted data into it, and the function itself contains no unsafe operations. The state reset logic (setting flags, pointers, and the parser state) is self-contained and does not depend on user-controlled data. The absence of memory operations, input validation requirements, or undefined behaviors makes the chain not vulnerable.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "HttpReply::Impl::Pool::clear()",
      "CookieParser::process_nv()",
      "MessageattributeParser::parse()",
      "SET_STATE",
      "state_0",
      "failedFlag",
      "headerdataPtr",
      "header.rawdata",
      "current_cookie.secureFlag",
      "current_cookie_name",
      "state_type"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "MessageattributeParser::parse",
        "CookieParser::store_cookie",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 4,
      "snippets": [
        {
          "qualified_name": "MessageattributeParser::parse",
          "snippet": "void MessageattributeParser::parse(std::istream& in)\n  {\n    enum state_type\n    {\n      state_0,\n      state_type0,\n      state_type_sp,\n      state_subtype0,\n      state_subtype,\n      state_subtype_sp,\n      state_attribute0,\n      state_attribute,\n      state_attribute_sp,\n      state_value0,\n      state_value,\n      state_qvalue,\n      state_end\n    };\n\n    state_type state = state_0;\n    std::streambuf* buf = in.rdbuf();\n\n    std::string type, subtype, attribute, value;\n\n    while (state != state_end && buf->sgetc() != std::ios::traits_type::eof())\n    {\n      char ch = buf->sgetc();\n   ",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageattribute.cpp",
          "lines": "53-307"
        },
        {
          "qualified_name": "CookieParser::store_cookie",
          "snippet": "void CookieParser::store_cookie()\n  {\n    if (!mycookies.hasCookie(current_cookie_name))\n      mycookies.setCookie(current_cookie_name, current_cookie);\n    current_cookie.value.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/cookie.cpp",
          "lines": "159-164"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The target function 'Messageheader::Parser::reset()' is not vulnerable as it solely manages internal state (e.g., headerdataPtr, flags) without processing untrusted input. Callers like CookieParser::store_cookie() and HttpReply::Impl::Pool::clear() interact with reset() only to clean internal state, not passing external data. While CookieParser handles user-controlled cookies, the reset() function itself does not process this data directly, relying on its own safe state-reset logic. No unsafe data flows or invocation patterns affect the target function in this chain.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "headerdataPtr",
      "failedFlag",
      "SET_STATE",
      "state_0",
      "CookieParser::store_cookie()",
      "HttpReply::Impl::Pool::clear()"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_protocol_host",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 3,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_protocol_host",
          "snippet": "bool HttpRequest::Parser::state_protocol_host(char ch)\n  {\n    if (ch == '/')\n    {\n      message.url.clear();\n      message.url.reserve(32);\n      message.url += ch;\n      SET_STATE(state_url);\n    }\n    else if (!std::isalpha(ch)\n           && !std::isdigit(ch)\n           && ch != '['\n           && ch != ']'\n           && ch != '.'\n           && ch != ':')\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in url\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n\n    return failedFlag;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "212-234"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The caller chain does not introduce vulnerabilities. The target function 'Messageheader::Parser::reset()' is called in isolation, handling only internal state management without exposure to untrusted data. Callers (HttpReply::Impl::Pool::clear(), HttpRequest::Parser::state_protocol_host()) neither pass external/invalidated inputs to reset() nor create unsafe usage patterns. All variables (failedFlag, headerdataPtr, SET_STATE) are internally initialized and validated within their contexts.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "HttpReply::Impl::Pool::clear()",
      "HttpRequest::Parser::state_protocol_host()",
      "failedFlag",
      "headerdataPtr",
      "SET_STATE"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_url0",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 3,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_url0",
          "snippet": "bool HttpRequest::Parser::state_url0(char ch)\n  {\n    if (ch == ' ' || ch == '\\t')\n    {\n    }\n    else if (ch == '/')\n    {\n      message.url.clear();\n      message.url.reserve(32);\n      message.url += ch;\n      SET_STATE(state_url);\n    }\n    else if (std::isalpha(ch))\n    {\n      SET_STATE(state_protocol);\n    }\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in url\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n\n    return failedFlag;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "144-168"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The chain is NOT VULNERABLE. The caller functions do not introduce unsafe input propagation, unvalidated data flows, or dangerous invocation patterns into the target function 'Messageheader::Parser::reset()'. The callers primarily perform HTTP request/response pooling operations and URL parsing state transitions without interacting with the target function's state or data. No external or untrusted data is shown to reach the target function through this chain.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "HttpReply::Impl::Pool::clear()",
      "HttpRequest::Parser::state_url0()",
      "failedFlag",
      "SET_STATE",
      "headerdataPtr",
      "header.rawdata",
      "state_0",
      "poolMutex",
      "pool",
      "message.url",
      "state_url",
      "state_protocol"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The caller chain does not introduce vulnerabilities to the target function. The 'HttpReply::Impl::Pool::clear()' function manages resource cleanup (deletion of pooled objects) but does not interact with or pass any untrusted data to the target 'Messageheader::Parser::reset()' function. The target function’s invocation occurs in a context where it operates solely on internal state variables (e.g., 'failedFlag', 'headerdataPtr'), with no exposure to tainted inputs or unsafe data flows through the provided caller chain. The macro 'SET_STATE' is assumed safe per the function-level assessment.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "HttpReply::Impl::Pool::clear()",
      "failedFlag",
      "headerdataPtr",
      "header.rawdata",
      "SET_STATE",
      "state_0"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "main",
        "PollerImpl::run",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 4,
      "snippets": [
        {
          "qualified_name": "main",
          "snippet": "int main(int argc, char* argv[])\n{\n  std::ios::sync_with_stdio(false);\n\n  try\n  {\n    cxxtools::Arg<bool> version(argc, argv, \"--version\");\n    if (version)\n    {\n      std::cout << PACKAGE_STRING \"\\n\" << std::flush;\n      return 0;\n    }\n\n    cxxtools::Arg<bool> help1(argc, argv, 'h');\n    cxxtools::Arg<bool> help2(argc, argv, '?');\n\n    if (help1 || help2)\n    {\n      std::cout << \"usage: \" << argv[0] << \" configurationfile (default: \" TNTNET_CONF \")\"\n                << std::endl;\n      return 0;\n    }\n\n    cxxtools::Arg<bool> cmd(argc, argv, 'C');\n    if (cmd)\n    {\n      log_init(\"tntnet.x",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/runtime/main.cpp",
          "lines": "220-279"
        },
        {
          "qualified_name": "PollerImpl::run",
          "snippet": "void PollerImpl::run()\n  {\n    epoll_event events[16];\n\n    time_t pollTime;\n    time(&pollTime);\n    while (!Tntnet::shouldStop())\n    {\n      usleep(100);\n\n      append_new_jobs();\n\n      if (jobs.size() == 0)\n        poll_timeout = -1;\n\n      int ret = ::epoll_wait(pollFd, events, 16, poll_timeout);\n\n      if (ret < 0)\n      {\n        if (errno != EINTR)\n          throw cxxtools::SystemError(\"epoll_wait\");\n      }\n      else if (ret == 0)\n      {\n        // timeout reached - check for timed out requests and get next timeout\n\n        poll_timeout = -1;\n        time_t currentTime;\n        tim",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/poller.cpp",
          "lines": "141-257"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The target function 'Messageheader::Parser::reset()' is not vulnerable as it operates on internal state variables without handling untrusted input. The caller chain does not propagate tainted or external data into the function, nor do the callers exhibit unsafe invocation patterns. The absence of parameters in the target function further reduces the attack surface, and available evidence shows the callers manage resources (mutex, epoll, main logic) without directly interacting with the parser's state in a way that introduces vulnerabilities.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "failedFlag",
      "headerdataPtr",
      "header.rawdata",
      "SET_STATE",
      "HttpReply::Impl::Pool::clear()",
      "PollerImpl::run()",
      "main"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "MimeDb::read",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 3,
      "snippets": [
        {
          "qualified_name": "MimeDb::read",
          "snippet": "void MimeDb::read(const std::string& mimefile)\n{\n  std::ifstream in(mimefile.c_str());\n  read(in);\n}",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/mimedb.cpp",
          "lines": "44-48"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The target function 'Messageheader::Parser::reset()' is not vulnerable as its callers do not introduce unsafe patterns. The function is used to reset internal state variables (e.g., failedFlag, headerdataPtr) without handling external input or untrusted data. Callers like HttpReply::Impl::Pool::clear() (object cleanup) and MimeDb::read() (file parsing) do not propagate tainted data into the target function. There is no evidence of unvalidated or unsafe usage in the calling chain.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "failedFlag",
      "headerdataPtr",
      "SET_STATE",
      "state_0",
      "HttpReply::Impl::Pool::clear()",
      "MimeDb::read()"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "pull_func",
        "MimeDb::read",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 4,
      "snippets": [
        {
          "qualified_name": "pull_func",
          "snippet": "ssize_t pull_func(gnutls_transport_ptr_t ptr, void* buffer, size_t bufsize)\n    {\n      const GnuTlsStream::FdInfo& fdInfo = *static_cast<const GnuTlsStream::FdInfo*>(ptr);\n\n      while (true)\n      {\n        log_debug(\"read fd=\" << fdInfo.fd << \"; size=\" << bufsize);\n        ssize_t n = ::read(fdInfo.fd, buffer, bufsize);\n        log_debug(\"read returns \" << n << \" errno=\" << errno);\n\n        if (n > 0)\n          return n;\n        else if (n == 0 || errno == ECONNRESET)\n          return 0;\n        else if (errno == EAGAIN)\n        {\n          // poll\n          struct pollfd fds;\n          fds",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/gnutls.cpp",
          "lines": "48-84"
        },
        {
          "qualified_name": "MimeDb::read",
          "snippet": "void MimeDb::read(const std::string& mimefile)\n{\n  std::ifstream in(mimefile.c_str());\n  read(in);\n}",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/mimedb.cpp",
          "lines": "44-48"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The caller chain does not introduce vulnerabilities for 'Messageheader::Parser::reset()'. None of the callers propagate untrusted data to the target function, and the target function itself does not handle unsafe operations. Data flows within the caller functions (e.g., file reads, socket reads) do not reach the target function, which remains isolated to state-reset operations with no external input dependency.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "SET_STATE",
      "HttpReply::Impl::Pool::clear()",
      "MimeDb::read(const std::string&)"
    ],
    "Hallucinated_entities": [
      "pull_func"
    ],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "MimeDb::MimeDb",
        "MimeDb::read",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 4,
      "snippets": [
        {
          "qualified_name": "MimeDb::MimeDb",
          "snippet": "MimeDb()  {}",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/tnt/mimedb.h",
          "lines": "46-46"
        },
        {
          "qualified_name": "MimeDb::read",
          "snippet": "void MimeDb::read(const std::string& mimefile)\n{\n  std::ifstream in(mimefile.c_str());\n  read(in);\n}",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/mimedb.cpp",
          "lines": "44-48"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The caller chain does not introduce vulnerabilities to the target function. Callers perform unrelated operations (resource cleanup, file reading, empty constructor) that do not propagate untrusted data into the 'Messageheader::Parser::reset()' function. The function's internal state modifications (failedFlag, headerdataPtr) are unaffected by external inputs through these callers.",
    "Used_entities": [
      "Messageheader::Parser::reset",
      "failedFlag",
      "headerdataPtr",
      "HttpReply::Impl::Pool::clear",
      "MimeDb::read",
      "MimeDb()"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "HttpReply::~HttpReply",
        "HttpReply::Impl::Pool::releaseInstance",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 4,
      "snippets": [
        {
          "qualified_name": "HttpReply::~HttpReply",
          "snippet": "HttpReply::~HttpReply()\n  {\n    Impl::pool.releaseInstance(impl);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "201-204"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::releaseInstance",
          "snippet": "void HttpReply::Impl::Pool::releaseInstance(Impl* inst)\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    if (pool.size() < 64)\n    {\n      inst->outstream.clear();\n      inst->outstream.str(std::string());\n      inst->safe_outstream.clear();\n      inst->url_outstream.clear();\n      pool.push_back(inst);\n    }\n    else\n    {\n      delete inst;\n    }\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "154-169"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The caller chain does not introduce vulnerabilities to the target function. The target function 'reset()' is not invoked with unvalidated or tainted data, and its internal operations (state flags, pointer reinitialization) are not influenced by unsafe inputs from its callers. The Pool and destructor manage object lifecycle operations independently of the Parser's reset logic, which handles only internal state. No data flow exists from external sources to the reset() function through these callers.",
    "Used_entities": [
      "Messageheader::Parser::reset()",
      "failedFlag",
      "headerdataPtr",
      "header.rawdata",
      "HttpReply::Impl::Pool::clear()",
      "cxxtools::MutexLock",
      "pool.size()",
      "pool.clear()",
      "pool.push_back(...)",
      "delete pool[n]",
      "HttpReply::Impl::Pool::releaseInstance(Impl* inst)",
      "inst->outstream.clear()",
      "inst->outstream.str()",
      "inst->safe_outstream",
      "inst->url_outstream",
      "HttpReply::~HttpReply()",
      "Impl::pool.releaseInstance(impl)"
    ],
    "Hallucinated_entities": [
      "SET_STATE",
      "state_0"
    ],
    "Coverage": 0.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::reset",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "265-270"
    ],
    "function_name": "Messageheader::Parser::reset",
    "chains": {
      "call_sequence": [
        "Messageheader::Messageheader",
        "HttpReply::Impl::Pool::clear",
        "Messageheader::Parser::reset"
      ],
      "length": 3,
      "snippets": [
        {
          "qualified_name": "Messageheader::Messageheader",
          "snippet": "Messageheader()\n        { clear(); }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/tnt/messageheader.h",
          "lines": "123-124"
        },
        {
          "qualified_name": "HttpReply::Impl::Pool::clear",
          "snippet": "void HttpReply::Impl::Pool::clear()\n  {\n    cxxtools::MutexLock lock(poolMutex);\n    for (unsigned n = 0; n < pool.size(); ++n)\n      delete pool[n];\n    pool.clear();\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpreply.cpp",
          "lines": "171-177"
        },
        {
          "qualified_name": "Messageheader::Parser::reset",
          "snippet": "void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "265-270"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The caller chain does not introduce vulnerabilities. The target function 'Messageheader::Parser::reset()' is invoked by lifecycle-management functions (constructors and object-clearing routines) without interacting with untrusted input. Since the function itself contains no security weaknesses (as confirmed by the function-level assessment), there is no unsafe data flow or invocation pattern in the chain. The calls to 'reset()' are purely internal state management and do not process external data.",
    "Used_entities": [
      "Messageheader::Parser::reset",
      "failedFlag",
      "headerdataPtr",
      "header.rawdata",
      "SET_STATE",
      "state_0",
      "HttpReply::Impl::Pool::clear",
      "Messageheader"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "Messageheader::Parser::state_end_cr",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "237-257"
    ],
    "function_name": "Messageheader::Parser::state_end_cr",
    "chains": {
      "call_sequence": [
        "Messageheader::Parser::state_end_cr"
      ],
      "length": 1,
      "snippets": [
        {
          "qualified_name": "Messageheader::Parser::state_end_cr",
          "snippet": "bool Messageheader::Parser::state_end_cr(char ch)\n  {\n    if (ch == '\\n')\n    {\n      if (header.onField(fieldnamePtr, fieldbodyPtr) == FAIL)\n      {\n        log_warn(\"invalid header \" << fieldnamePtr << ' ' << fieldbodyPtr);\n        failedFlag = true;\n      }\n\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in end-cr\");\n      failedFlag = true;\n      return true;\n    }\n    return false;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "237-257"
        }
      ]
    },
    "Vulnerable": false,
    "Description": "The function correctly validates input through character checks and header processing. The onField handler only executes for valid headers, and invalid inputs trigger error logging and failedFlag without unsafe operations. No caller introduces untrusted data or bypasses validation.",
    "Used_entities": [
      "fieldnamePtr",
      "fieldbodyPtr",
      "failedFlag",
      "onField",
      "log_warn",
      "headerdataPtr"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_end0",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_end0",
          "snippet": "bool HttpRequest::Parser::state_end0(char ch)\n  {\n    if (ch == '\\n')\n      SET_STATE(state_header);\n    else if (ch != ' ' && ch != '\\t')\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in end\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n    return failedFlag;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "381-392"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The caller chain is vulnerable because 'HttpRequest::Parser::state_end0' passes untrusted input 'ch' (from HTTP requests) directly to 'chartoprint' without validating or promoting it to an unsigned type. This allows attackers to supply malicious characters (e.g., signed chars with high bits set) that cause undefined behavior and memory disclosure in 'chartoprint'. The lack of input sanitization in the caller chain exacerbates the vulnerability.",
    "Used_entities": [
      "chartoprint",
      "ch",
      "hex",
      "HttpRequest::Parser::state_end0"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_version_minor0",
        "HttpRequest::Parser::state_version_minor",
        "chartoprint"
      ],
      "length": 3,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_version_minor0",
          "snippet": "bool HttpRequest::Parser::state_version_minor0(char ch)\n  {\n    return ch == ' ' || ch == '\\t' ? failedFlag\n                                   : state_version_minor(ch);\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "358-362"
        },
        {
          "qualified_name": "HttpRequest::Parser::state_version_minor",
          "snippet": "bool HttpRequest::Parser::state_version_minor(char ch)\n  {\n    if (ch == '\\n')\n      SET_STATE(state_header);\n    else if (ch == ' ' || ch == '\\t' || ch == '\\r')\n      SET_STATE(state_end0);\n    else if (std::isdigit(ch))\n      message.setVersion(message.getMajorVersion(), message.getMinorVersion() * 10 + (ch - '0'));\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in version-minor\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n    return failedFlag;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "364-379"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The caller chain is vulnerable because the chartoprint function processes untrusted input from HTTP parsing without type promotion or bounds checks. In state_version_minor, the raw character 'ch' (from user-controlled HTTP messages) bypassing the digit check is passed directly to chartoprint. Since 'ch' can contain signed values with the high bit set, this triggers the out-of-bounds read vulnerability during hex[] array access, enabling potential memory disclosure in log messages. The state_version_minor0 function allows this tainted data to propagate to the vulnerable function with no validation.",
    "Used_entities": [
      "chartoprint",
      "hex",
      "state_version_minor",
      "ch",
      "log_warn",
      "failedFlag",
      "httpCode",
      "state_version_minor0"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_version_major_sp",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_version_major_sp",
          "snippet": "bool HttpRequest::Parser::state_version_major_sp(char ch)\n  {\n    if (ch == '.')\n      SET_STATE(state_version_minor0);\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in version-major\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n    return failedFlag;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "345-356"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The chain is vulnerable because HttpRequest::Parser::state_version_major_sp passes unvalidated external input 'ch' directly to chartoprint. If 'ch' is a signed char with the high bit set (e.g., 0x80-0xff stored as -128 to -1), the out-of-bounds array accesses in chartoprint will read memory outside the 'hex' array. This occurs when HTTP clients send non-ASCII bytes to trigger HTTP version parsing failures, leading to memory disclosure vulnerabilities.",
    "Used_entities": [
      "chartoprint",
      "hex",
      "ch",
      "signed char",
      "HttpRequest::Parser::state_version_major_sp"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_version_major",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_version_major",
          "snippet": "bool HttpRequest::Parser::state_version_major(char ch)\n  {\n    if (ch == '.')\n      SET_STATE(state_version_minor0);\n    else if (std::isdigit(ch))\n      message.setVersion(message.getMajorVersion() * 10 + (ch - '0'), message.getMinorVersion());\n    else if (ch == ' ' || ch == '\\t')\n      SET_STATE(state_version_major_sp);\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in version-major\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n    return failedFlag;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "328-343"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The caller chain is vulnerable because HttpRequest::Parser::state_version_major passes untrusted input 'ch' (from HTTP parsing) directly to chartoprint without validating or type-casting it. This allows out-of-bounds hex array accesses when processing negative signed char values in HTTP messages.",
    "Used_entities": [
      "chartoprint(char ch)",
      "hex[]",
      "ch",
      "HttpRequest::Parser::state_version_major(char ch)",
      "log_warn"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_version",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_version",
          "snippet": "bool HttpRequest::Parser::state_version(char ch)\n  {\n    if (ch == '/')\n    {\n      message.setVersion(0, 0);\n      skipWs(&Parser::state_version_major);\n    }\n    else if (ch == '\\r')\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in version\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n    return failedFlag;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "312-326"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The caller chain is vulnerable because the 'state_version' function in 'HttpRequest::Parser' passes the raw HTTP input character 'ch' (from untrusted external data) directly to 'chartoprint' without validation or mitigation. Since 'ch' is a signed char from HTTP request parsing, it can have negative values with high bit set. This propagates untrusted data into the vulnerable 'chartoprint' function, triggering undefined behavior and potential memory disclosure when processing non-printable characters. No input sanitization or type promotion occurs before the unsafe array index calculation in 'chartoprint'.",
    "Used_entities": [
      "chartoprint",
      "hex",
      "ch",
      "state_version",
      "HttpRequest::Parser",
      "failedFlag"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_urlesc",
        "HttpRequest::Parser::state_url",
        "chartoprint"
      ],
      "length": 3,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_urlesc",
          "snippet": "bool HttpRequest::Parser::state_urlesc(char ch)\n  {\n    if (isHexDigit(ch))\n    {\n      if (message.url.size() >= 2 && message.url[message.url.size() - 2] == '%')\n      {\n        unsigned v = (valueOfHexDigit(message.url[message.url.size() - 1]) << 4) | valueOfHexDigit(ch);\n        if (v == 0)\n          throw HttpError(HTTP_BAD_REQUEST, \"invalid value in url\");\n        message.url[message.url.size() - 2] = static_cast<char>(v);\n        message.url.resize(message.url.size() - 1);\n        SET_STATE(state_url);\n      }\n      else\n      {\n        message.url += ch;\n      }\n      return false;\n    ",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "274-298"
        },
        {
          "qualified_name": "HttpRequest::Parser::state_url",
          "snippet": "bool HttpRequest::Parser::state_url(char ch)\n  {\n    if (ch == '?')\n    {\n      log_debug(\"url=\" << message.url);\n      SET_STATE(state_qparam);\n    }\n    else if (ch == '\\r')\n    {\n      log_debug(\"url=\" << message.url);\n      SET_STATE(state_end0);\n    }\n    else if (ch == '\\n')\n    {\n      log_debug(\"url=\" << message.url);\n      SET_STATE(state_header);\n    }\n    else if (ch == ' ' || ch == '\\t')\n    {\n      log_debug(\"url=\" << message.url);\n      SET_STATE(state_version);\n    }\n    else if (ch == '%')\n    {\n      SET_STATE(state_urlesc);\n      message.url += ch;\n    }\n    else if (ch > ' '",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "236-272"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The caller chain is vulnerable because HttpRequest::Parser's URL decoding in state_urlesc can pass decoded bytes with high-bit set (treated as negative signed chars) to chartoprint. This untrusted data bypasses safe handling by not being promoted to unsigned char before bitwise operations, directly triggering the out-of-bounds read vulnerability in chartoprint. The propagation of decoded URL bytes (message.url's char values) through the caller chain introduces the unsafe data flow.",
    "Used_entities": [
      "chartoprint",
      "hex",
      "ch",
      "HttpRequest::Parser::state_url",
      "HttpRequest::Parser::state_urlesc",
      "message.url",
      "isHexDigit",
      "valueOfHexDigit",
      "HttpError",
      "SET_STATE"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_protocol_host",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_protocol_host",
          "snippet": "bool HttpRequest::Parser::state_protocol_host(char ch)\n  {\n    if (ch == '/')\n    {\n      message.url.clear();\n      message.url.reserve(32);\n      message.url += ch;\n      SET_STATE(state_url);\n    }\n    else if (!std::isalpha(ch)\n           && !std::isdigit(ch)\n           && ch != '['\n           && ch != ']'\n           && ch != '.'\n           && ch != ':')\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in url\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n\n    return failedFlag;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "212-234"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The chain is vulnerable because untrusted input 'ch' from HTTP parsing flows directly into 'chartoprint' without validation. The negative signed char values in 'ch' can cause out-of-bounds accesses due to the absence of type promotion to unsigned char in the caller. No mitigations exist in the caller to sanitize or validate input before passing it to the vulnerable function.",
    "Used_entities": [
      "chartoprint",
      "hex",
      "ch",
      "hex[ch >> 4]",
      "hex[ch & 0xf]",
      "HttpRequest::Parser::state_protocol_host"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_protocol_slash2",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_protocol_slash2",
          "snippet": "bool HttpRequest::Parser::state_protocol_slash2(char ch)\n  {\n    if (ch == '/')\n      SET_STATE(state_protocol_host);\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in url\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n\n    return failedFlag;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "198-210"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The caller chain is vulnerable because external input 'ch' (from URL parsing) is passed directly to 'chartoprint' without validation. Since 'ch' is a signed char from untrusted data, it can trigger the out-of-bounds read vulnerability in 'chartoprint' by causing invalid indices in the 'hex' array. The caller 'state_protocol_slash2' does not sanitize input or check for high-bit characters, allowing exploitation.",
    "Used_entities": [
      "chartoprint",
      "hex",
      "ch",
      "std::isprint",
      "state_protocol_slash2",
      "HttpRequest::Parser::state_protocol_slash2",
      "log_warn",
      "HTTP_BAD_REQUEST",
      "failedFlag"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_protocol_slash1",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_protocol_slash1",
          "snippet": "bool HttpRequest::Parser::state_protocol_slash1(char ch)\n  {\n    if (ch == '/')\n      SET_STATE(state_protocol_slash2);\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in url\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n\n    return failedFlag;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "184-196"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The caller chain is vulnerable because the 'ch' parameter in 'state_protocol_slash1' passes unvalidated external input to 'chartoprint' as a signed char. Since HTTP protocol parsing allows arbitrary byte values (including high-bit-set characters), this enables undefined behavior in 'chartoprint' when shifting/masking a negative signed char. The lack of input validation or type promotion in the caller chain allows untrusted data to exploit the unsigned indexing vulnerability in the target function.",
    "Used_entities": [
      "chartoprint",
      "hex",
      "ch",
      "state_protocol_slash1",
      "std::isprint"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_protocol",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_protocol",
          "snippet": "bool HttpRequest::Parser::state_protocol(char ch)\n  {\n    if (ch == ':')\n      SET_STATE(state_protocol_slash1);\n    else if (!std::isalpha(ch))\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in url\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n\n    return failedFlag;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "170-182"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The 'state_protocol' function passes HTTP-parsed characters (external input) directly to 'chartoprint' without mitigating the signed char vulnerability. The untrusted 'ch' parameter, when a negative signed char, leads to out-of-bounds array access in 'hex' due to undefined behavior from bit manipulation.",
    "Used_entities": [
      "chartoprint",
      "hex",
      "ch"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_url0",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_url0",
          "snippet": "bool HttpRequest::Parser::state_url0(char ch)\n  {\n    if (ch == ' ' || ch == '\\t')\n    {\n    }\n    else if (ch == '/')\n    {\n      message.url.clear();\n      message.url.reserve(32);\n      message.url += ch;\n      SET_STATE(state_url);\n    }\n    else if (std::isalpha(ch))\n    {\n      SET_STATE(state_protocol);\n    }\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in url\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n\n    return failedFlag;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "144-168"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The caller chain is vulnerable because HttpRequest::Parser::state_url0 passes unvalidated user-controlled input 'ch' directly to chartoprint() without ensuring it is an unsigned char. When 'ch' has its high bit set (e.g., signed char values <0), chartoprint() processes it via bitwise operations that produce out-of-bounds indices for the hex[] array, exposing arbitrary memory contents in error logs. The lack of input sanitization or type conversion in the caller chain exposes the underlying vulnerability in the target function.",
    "Used_entities": [
      "chartoprint",
      "hex",
      "ch",
      "HttpRequest::Parser::state_url0",
      "std::isprint",
      "std::isalpha"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_cmd",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_cmd",
          "snippet": "bool HttpRequest::Parser::state_cmd(char ch)\n  {\n    if (istokenchar(ch))\n    {\n      if (message.methodLen >= sizeof(message.method) - 1)\n      {\n        log_debug(\"invalid method field; method=\" << std::string(message.method, message.methodLen) << \", len=\" << message.methodLen);\n        throw HttpError(HTTP_BAD_REQUEST, \"invalid method field\");\n      }\n      message.method[message.methodLen++] = ch;\n    }\n    else if (ch == ' ')\n    {\n      message.method[message.methodLen] = '\\0';\n      log_debug(\"method=\" << message.method);\n      SET_STATE(state_url0);\n    }\n    else\n    {\n      log_warn(",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "118-142"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The 'state_cmd' function in the caller chain may pass unvalidated characters from HTTP requests (e.g., signed char values with the high bit set) to 'chartoprint' during error handling (e.g., logging invalid characters). Since 'chartoprint' performs unchecked bitwise operations on the signed char, this leads to out-of-bounds reads in the hexadecimal lookup array, exposing the vulnerability. The critical flaw lies in the unchecked propagation of potentially malicious input from the HTTP parser to the unsafe target function.",
    "Used_entities": [
      "chartoprint",
      "state_cmd",
      "char ch",
      "hex[]",
      "ch >> 4",
      "ch & 0xf",
      "signed char"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "HttpRequest::Parser::state_cmd0",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "HttpRequest::Parser::state_cmd0",
          "snippet": "bool HttpRequest::Parser::state_cmd0(char ch)\n  {\n    if (istokenchar(ch))\n    {\n      message.method[0] = ch;\n      message.methodLen = 1;\n      SET_STATE(state_cmd);\n    }\n    else if (ch != ' ' && ch != '\\t')\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in method\");\n      httpCode = HTTP_BAD_REQUEST;\n      failedFlag = true;\n    }\n    return failedFlag;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/httpparser.cpp",
          "lines": "101-116"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The caller chain is vulnerable because the HttpRequest::Parser::state_cmd0 function passes unvalidated input 'ch' (derived from HTTP request data) to 'chartoprint' without ensuring it is a valid non-negative char. This allows signed char values with high bits set to trigger the out-of-bounds read in 'chartoprint' when logging malformed requests. The untrusted input propagation and lack of sanitization before bit operations make the chain vulnerable.",
    "Used_entities": [
      "chartoprint",
      "hex",
      "ch",
      "HttpRequest::Parser::state_cmd0",
      "log_warn",
      "failedFlag",
      "message.method[0]",
      "message.methodLen",
      "SET_STATE",
      "std::isprint",
      "HTTP_BAD_REQUEST"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "Messageheader::Parser::state_end_cr",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "Messageheader::Parser::state_end_cr",
          "snippet": "bool Messageheader::Parser::state_end_cr(char ch)\n  {\n    if (ch == '\\n')\n    {\n      if (header.onField(fieldnamePtr, fieldbodyPtr) == FAIL)\n      {\n        log_warn(\"invalid header \" << fieldnamePtr << ' ' << fieldbodyPtr);\n        failedFlag = true;\n      }\n\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in end-cr\");\n      failedFlag = true;\n      return true;\n    }\n    return false;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "237-257"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The chain is vulnerable because the caller passes unvalidated external input (ch) directly to chartoprint() without ensuring it's an unsigned char value. Since ch is a char parameter in the caller (which could be signed or unsigned based on platform/system defaults), high-bit-set values (>=0x80) may be passed as negative signed char values. These negative values, when passed to chartoprint(), perform unsafe bitwise operations on a signed char, allowing array index calculations with values outside 0-15. The untrusted data (ch) flows through state_end_cr() into the vulnerable chartoprint() function without any mitigation.",
    "Used_entities": [
      "chartoprint",
      "hex",
      "ch",
      "std::isprint",
      "state_end_cr",
      "Messageheader::Parser::state_end_cr"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "Messageheader::Parser::state_fieldbody_crlf",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "Messageheader::Parser::state_fieldbody_crlf",
          "snippet": "bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      // continuation l",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "190-235"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The caller chain is vulnerable because the function 'state_fieldbody_crlf' passes unvalidated input (e.g., maliciously crafted 'ch' values from header fields) directly to 'chartoprint'. Since 'ch' is a signed char, values with the high bit set (e.g., negative char literals) trigger the out-of-bounds read in 'chartoprint' via unchecked bitwise operations. This allows attackers to disclose sensitive memory contents by injecting such characters into the header parser. No data validation or type promotion occurs in the caller chain to mitigate this risk.",
    "Used_entities": [
      "chartoprint",
      "state_fieldbody_crlf",
      "ch"
    ],
    "Hallucinated_entities": [
      "signed char"
    ],
    "Coverage": 0.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "Messageheader::Parser::state_fieldbody_cr",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "Messageheader::Parser::state_fieldbody_cr",
          "snippet": "bool Messageheader::Parser::state_fieldbody_cr(char ch)\n  {\n    if (ch == '\\n')\n      SET_STATE(state_fieldbody_crlf);\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody-cr\");\n      failedFlag = true;\n      return true;\n    }\n    return false;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "177-188"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The chain is vulnerable because the 'ch' parameter from the caller is a signed char that may have the high bit set (e.g., negative values). This flows directly into 'chartoprint', where unvalidated bitwise operations lead to out-of-bounds array accesses. The caller fails to validate or cast the input to an unsigned type before passing it, exacerbating the function's vulnerability.",
    "Used_entities": [
      "chartoprint",
      "hex",
      "ch",
      "state_fieldbody_cr",
      "log_warn",
      "failedFlag"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "Messageheader::Parser::state_fieldnamespace",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "Messageheader::Parser::state_fieldnamespace",
          "snippet": "bool Messageheader::Parser::state_fieldnamespace(char ch)\n  {\n    if (ch == ':')                   // \"Field-name :\"\n      SET_STATE(state_fieldbody0);\n    else if (!std::isspace(ch))\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldname-space\");\n      failedFlag = true;\n      return true;\n    }\n    return false;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "119-130"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The caller 'state_fieldnamespace' passes a 'char ch' directly to 'chartoprint(ch)' without validating or casting it to an unsigned type. Since 'char' is signed by default in many implementations, non-printable characters with the high bit set (e.g., negative values) will propagate into the target function. This results in undefined behavior during array indexing in 'hex[ch >> 4]' and 'hex[ch & 0xf]', confirming the vulnerability.",
    "Used_entities": [
      "chartoprint",
      "state_fieldnamespace",
      "char ch",
      "hex",
      "ch >> 4",
      "ch & 0xf"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "Messageheader::Parser::state_fieldname",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "Messageheader::Parser::state_fieldname",
          "snippet": "bool Messageheader::Parser::state_fieldname(char ch)\n  {\n    if (ch == ':')            // Field-name:\n    {\n      checkHeaderspace(2);\n      *headerdataPtr++ = ch;\n      *headerdataPtr++ = '\\0';\n      fieldbodyPtr = headerdataPtr;\n      SET_STATE(state_fieldbody0);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    else if (std::isspace(ch))\n    {\n      checkHeaderspace(2);\n      *headerdataPtr++ = ':';\n      *headerdataPtr++ = '\\0';\n      fieldbodyPtr = headerdataPtr;\n      SET_STATE(state_fieldnamespace);\n    }\n    else\n    {\n   ",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "87-117"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The chain is vulnerable because 'Messageheader::Parser::state_fieldname' passes untrusted input (char 'ch') to 'chartoprint' without validating or sanitizing it. When 'ch' is a non-printable character with a negative signed value (high bit set), bitwise operations in 'chartoprint' lead to out-of-bounds memory access. Since 'ch' originates from message header parsing (a potential attacker-controlled input), this enables memory disclosure. The lack of input validation in the caller chain directly exploits the function-level vulnerability.",
    "Used_entities": [
      "Messageheader::Parser::state_fieldname",
      "chartoprint",
      "ch",
      "hex"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "Messageheader::Parser::state_cr",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "Messageheader::Parser::state_cr",
          "snippet": "bool Messageheader::Parser::state_cr(char ch)\n  {\n    if (ch != '\\n')\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in state-cr\");\n      failedFlag = true;\n    }\n    return true;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "77-85"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The chain is vulnerable because the caller function state_cr passes a potentially unvalidated signed char 'ch' directly to chartoprint. This allows negative char values to propagate into the target function, triggering the out-of-bounds array access vulnerability documented in the function-level assessment. The signed-to-unsigned promotion (missing in both functions) enables masked indices outside [0,15], risking memory disclosure when processing malicious inputs.",
    "Used_entities": [
      "chartoprint",
      "ch",
      "hex",
      "state_cr",
      "Messageheader::Parser::state_cr"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
    "id": [
      "chartoprint",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "40-47"
    ],
    "function_name": "chartoprint",
    "chains": {
      "call_sequence": [
        "Messageheader::Parser::state_0",
        "chartoprint"
      ],
      "length": 2,
      "snippets": [
        {
          "qualified_name": "Messageheader::Parser::state_0",
          "snippet": "bool Messageheader::Parser::state_0(char ch)\n  {\n    if (ch >= 33 && ch <= 126 && ch != ':')\n    {\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldname);\n    }\n    else if (ch == '\\n')\n      return true;\n    else if (ch == '\\r')\n      SET_STATE(state_cr);\n    else if (!std::isspace(ch))\n    {\n      log_warn(\"invalid character \" << chartoprint(ch));\n      failedFlag = true;\n      return true;\n    }\n\n    return false;\n  }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "54-75"
        },
        {
          "qualified_name": "chartoprint",
          "snippet": "std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
          "lines": "40-47"
        }
      ]
    },
    "Vulnerable": true,
    "Description": "The 'chartoprint' function's vulnerability is triggered via the caller chain. In 'state_0', the function is called with 'ch' without validation of its range. Since 'ch' (a signed char) can hold values < 0, bitwise operations in 'chartoprint' cause out-of-bounds access (via 'hex[ch >> 4]' and 'hex[ch & 0xf]'). The caller does not sanitize or validate 'ch' before logging, propagating untrusted input directly to the unsafe function.",
    "Used_entities": [
      "chartoprint",
      "ch",
      "hex",
      "state_0"
    ],
    "Hallucinated_entities": [],
    "Coverage": 1.0
  }
]