[
  {
    "function_name": "tomoyo_mount_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/mount.c",
    "lines": "188-237",
    "snippet": "int tomoyo_mount_permission(const char *dev_name, const struct path *path,\n\t\t\t    const char *type, unsigned long flags,\n\t\t\t    void *data_page)\n{\n\tstruct tomoyo_request_info r;\n\tint error;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_MOUNT)\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)\n\t\tflags &= ~MS_MGC_MSK;\n\tif (flags & MS_REMOUNT) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_REMOUNT];\n\t\tflags &= ~MS_REMOUNT;\n\t} else if (flags & MS_BIND) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_BIND];\n\t\tflags &= ~MS_BIND;\n\t} else if (flags & MS_SHARED) {\n\t\tif (flags & (MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_SHARED];\n\t\tflags &= ~MS_SHARED;\n\t} else if (flags & MS_PRIVATE) {\n\t\tif (flags & (MS_SHARED | MS_SLAVE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_PRIVATE];\n\t\tflags &= ~MS_PRIVATE;\n\t} else if (flags & MS_SLAVE) {\n\t\tif (flags & (MS_SHARED | MS_PRIVATE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_SLAVE];\n\t\tflags &= ~MS_SLAVE;\n\t} else if (flags & MS_UNBINDABLE) {\n\t\tif (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_UNBINDABLE];\n\t\tflags &= ~MS_UNBINDABLE;\n\t} else if (flags & MS_MOVE) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MOVE];\n\t\tflags &= ~MS_MOVE;\n\t}\n\tif (!type)\n\t\ttype = \"<NULL>\";\n\tidx = tomoyo_read_lock();\n\terror = tomoyo_mount_acl(&r, dev_name, path, type, flags);\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const tomoyo_mounts[TOMOYO_MAX_SPECIAL_MOUNT] = {\n\t[TOMOYO_MOUNT_BIND]            = \"--bind\",\n\t[TOMOYO_MOUNT_MOVE]            = \"--move\",\n\t[TOMOYO_MOUNT_REMOUNT]         = \"--remount\",\n\t[TOMOYO_MOUNT_MAKE_UNBINDABLE] = \"--make-unbindable\",\n\t[TOMOYO_MOUNT_MAKE_PRIVATE]    = \"--make-private\",\n\t[TOMOYO_MOUNT_MAKE_SLAVE]      = \"--make-slave\",\n\t[TOMOYO_MOUNT_MAKE_SHARED]     = \"--make-shared\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_read_unlock",
          "args": [
            "idx"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_mount_acl",
          "args": [
            "&r",
            "dev_name",
            "path",
            "type",
            "flags"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_mount_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/mount.c",
          "lines": "75-175",
          "snippet": "static int tomoyo_mount_acl(struct tomoyo_request_info *r,\n\t\t\t    const char *dev_name,\n\t\t\t    const struct path *dir, const char *type,\n\t\t\t    unsigned long flags)\n{\n\tstruct tomoyo_obj_info obj = { };\n\tstruct path path;\n\tstruct file_system_type *fstype = NULL;\n\tconst char *requested_type = NULL;\n\tconst char *requested_dir_name = NULL;\n\tconst char *requested_dev_name = NULL;\n\tstruct tomoyo_path_info rtype;\n\tstruct tomoyo_path_info rdev;\n\tstruct tomoyo_path_info rdir;\n\tint need_dev = 0;\n\tint error = -ENOMEM;\n\tr->obj = &obj;\n\n\t/* Get fstype. */\n\trequested_type = tomoyo_encode(type);\n\tif (!requested_type)\n\t\tgoto out;\n\trtype.name = requested_type;\n\ttomoyo_fill_path_info(&rtype);\n\n\t/* Get mount point. */\n\tobj.path2 = *dir;\n\trequested_dir_name = tomoyo_realpath_from_path(dir);\n\tif (!requested_dir_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\trdir.name = requested_dir_name;\n\ttomoyo_fill_path_info(&rdir);\n\n\t/* Compare fs name. */\n\tif (type == tomoyo_mounts[TOMOYO_MOUNT_REMOUNT]) {\n\t\t/* dev_name is ignored. */\n\t} else if (type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_UNBINDABLE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_PRIVATE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_SLAVE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_SHARED]) {\n\t\t/* dev_name is ignored. */\n\t} else if (type == tomoyo_mounts[TOMOYO_MOUNT_BIND] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MOVE]) {\n\t\tneed_dev = -1; /* dev_name is a directory */\n\t} else {\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fstype->fs_flags & FS_REQUIRES_DEV)\n\t\t\t/* dev_name is a block device file. */\n\t\t\tneed_dev = 1;\n\t}\n\tif (need_dev) {\n\t\t/* Get mount point or device file. */\n\t\tif (!dev_name || kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tobj.path1 = path;\n\t\trequested_dev_name = tomoyo_realpath_from_path(&path);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* Map dev_name to \"<NULL>\" if no dev_name given. */\n\t\tif (!dev_name)\n\t\t\tdev_name = \"<NULL>\";\n\t\trequested_dev_name = tomoyo_encode(dev_name);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trdev.name = requested_dev_name;\n\ttomoyo_fill_path_info(&rdev);\n\tr->param_type = TOMOYO_TYPE_MOUNT_ACL;\n\tr->param.mount.need_dev = need_dev;\n\tr->param.mount.dev = &rdev;\n\tr->param.mount.dir = &rdir;\n\tr->param.mount.type = &rtype;\n\tr->param.mount.flags = flags;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_mount_acl);\n\t\terror = tomoyo_audit_mount_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(requested_dev_name);\n\tkfree(requested_dir_name);\n\tif (fstype)\n\t\tput_filesystem(fstype);\n\tkfree(requested_type);\n\t/* Drop refcount obtained by kern_path(). */\n\tif (obj.path1.dentry)\n\t\tpath_put(&obj.path1);\n\treturn error;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const tomoyo_mounts[TOMOYO_MAX_SPECIAL_MOUNT] = {\n\t[TOMOYO_MOUNT_BIND]            = \"--bind\",\n\t[TOMOYO_MOUNT_MOVE]            = \"--move\",\n\t[TOMOYO_MOUNT_REMOUNT]         = \"--remount\",\n\t[TOMOYO_MOUNT_MAKE_UNBINDABLE] = \"--make-unbindable\",\n\t[TOMOYO_MOUNT_MAKE_PRIVATE]    = \"--make-private\",\n\t[TOMOYO_MOUNT_MAKE_SLAVE]      = \"--make-slave\",\n\t[TOMOYO_MOUNT_MAKE_SHARED]     = \"--make-shared\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n\nstatic const char * const tomoyo_mounts[TOMOYO_MAX_SPECIAL_MOUNT] = {\n\t[TOMOYO_MOUNT_BIND]            = \"--bind\",\n\t[TOMOYO_MOUNT_MOVE]            = \"--move\",\n\t[TOMOYO_MOUNT_REMOUNT]         = \"--remount\",\n\t[TOMOYO_MOUNT_MAKE_UNBINDABLE] = \"--make-unbindable\",\n\t[TOMOYO_MOUNT_MAKE_PRIVATE]    = \"--make-private\",\n\t[TOMOYO_MOUNT_MAKE_SLAVE]      = \"--make-slave\",\n\t[TOMOYO_MOUNT_MAKE_SHARED]     = \"--make-shared\",\n};\n\nstatic int tomoyo_mount_acl(struct tomoyo_request_info *r,\n\t\t\t    const char *dev_name,\n\t\t\t    const struct path *dir, const char *type,\n\t\t\t    unsigned long flags)\n{\n\tstruct tomoyo_obj_info obj = { };\n\tstruct path path;\n\tstruct file_system_type *fstype = NULL;\n\tconst char *requested_type = NULL;\n\tconst char *requested_dir_name = NULL;\n\tconst char *requested_dev_name = NULL;\n\tstruct tomoyo_path_info rtype;\n\tstruct tomoyo_path_info rdev;\n\tstruct tomoyo_path_info rdir;\n\tint need_dev = 0;\n\tint error = -ENOMEM;\n\tr->obj = &obj;\n\n\t/* Get fstype. */\n\trequested_type = tomoyo_encode(type);\n\tif (!requested_type)\n\t\tgoto out;\n\trtype.name = requested_type;\n\ttomoyo_fill_path_info(&rtype);\n\n\t/* Get mount point. */\n\tobj.path2 = *dir;\n\trequested_dir_name = tomoyo_realpath_from_path(dir);\n\tif (!requested_dir_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\trdir.name = requested_dir_name;\n\ttomoyo_fill_path_info(&rdir);\n\n\t/* Compare fs name. */\n\tif (type == tomoyo_mounts[TOMOYO_MOUNT_REMOUNT]) {\n\t\t/* dev_name is ignored. */\n\t} else if (type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_UNBINDABLE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_PRIVATE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_SLAVE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_SHARED]) {\n\t\t/* dev_name is ignored. */\n\t} else if (type == tomoyo_mounts[TOMOYO_MOUNT_BIND] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MOVE]) {\n\t\tneed_dev = -1; /* dev_name is a directory */\n\t} else {\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fstype->fs_flags & FS_REQUIRES_DEV)\n\t\t\t/* dev_name is a block device file. */\n\t\t\tneed_dev = 1;\n\t}\n\tif (need_dev) {\n\t\t/* Get mount point or device file. */\n\t\tif (!dev_name || kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tobj.path1 = path;\n\t\trequested_dev_name = tomoyo_realpath_from_path(&path);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* Map dev_name to \"<NULL>\" if no dev_name given. */\n\t\tif (!dev_name)\n\t\t\tdev_name = \"<NULL>\";\n\t\trequested_dev_name = tomoyo_encode(dev_name);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trdev.name = requested_dev_name;\n\ttomoyo_fill_path_info(&rdev);\n\tr->param_type = TOMOYO_TYPE_MOUNT_ACL;\n\tr->param.mount.need_dev = need_dev;\n\tr->param.mount.dev = &rdev;\n\tr->param.mount.dir = &rdir;\n\tr->param.mount.type = &rtype;\n\tr->param.mount.flags = flags;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_mount_acl);\n\t\terror = tomoyo_audit_mount_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(requested_dev_name);\n\tkfree(requested_dir_name);\n\tif (fstype)\n\t\tput_filesystem(fstype);\n\tkfree(requested_type);\n\t/* Drop refcount obtained by kern_path(). */\n\tif (obj.path1.dentry)\n\t\tpath_put(&obj.path1);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_lock",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1096-1099",
          "snippet": "static inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_init_request_info",
          "args": [
            "&r",
            "NULL",
            "TOMOYO_MAC_FILE_MOUNT"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_init_request_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "984-997",
          "snippet": "int tomoyo_init_request_info(struct tomoyo_request_info *r,\n\t\t\t     struct tomoyo_domain_info *domain, const u8 index)\n{\n\tu8 profile;\n\tmemset(r, 0, sizeof(*r));\n\tif (!domain)\n\t\tdomain = tomoyo_domain();\n\tr->domain = domain;\n\tprofile = domain->profile;\n\tr->profile = profile;\n\tr->type = index;\n\tr->mode = tomoyo_get_mode(domain->ns, profile, index);\n\treturn r->mode;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nint tomoyo_init_request_info(struct tomoyo_request_info *r,\n\t\t\t     struct tomoyo_domain_info *domain, const u8 index)\n{\n\tu8 profile;\n\tmemset(r, 0, sizeof(*r));\n\tif (!domain)\n\t\tdomain = tomoyo_domain();\n\tr->domain = domain;\n\tprofile = domain->profile;\n\tr->profile = profile;\n\tr->type = index;\n\tr->mode = tomoyo_get_mode(domain->ns, profile, index);\n\treturn r->mode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n\nstatic const char * const tomoyo_mounts[TOMOYO_MAX_SPECIAL_MOUNT] = {\n\t[TOMOYO_MOUNT_BIND]            = \"--bind\",\n\t[TOMOYO_MOUNT_MOVE]            = \"--move\",\n\t[TOMOYO_MOUNT_REMOUNT]         = \"--remount\",\n\t[TOMOYO_MOUNT_MAKE_UNBINDABLE] = \"--make-unbindable\",\n\t[TOMOYO_MOUNT_MAKE_PRIVATE]    = \"--make-private\",\n\t[TOMOYO_MOUNT_MAKE_SLAVE]      = \"--make-slave\",\n\t[TOMOYO_MOUNT_MAKE_SHARED]     = \"--make-shared\",\n};\n\nint tomoyo_mount_permission(const char *dev_name, const struct path *path,\n\t\t\t    const char *type, unsigned long flags,\n\t\t\t    void *data_page)\n{\n\tstruct tomoyo_request_info r;\n\tint error;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_MOUNT)\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)\n\t\tflags &= ~MS_MGC_MSK;\n\tif (flags & MS_REMOUNT) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_REMOUNT];\n\t\tflags &= ~MS_REMOUNT;\n\t} else if (flags & MS_BIND) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_BIND];\n\t\tflags &= ~MS_BIND;\n\t} else if (flags & MS_SHARED) {\n\t\tif (flags & (MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_SHARED];\n\t\tflags &= ~MS_SHARED;\n\t} else if (flags & MS_PRIVATE) {\n\t\tif (flags & (MS_SHARED | MS_SLAVE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_PRIVATE];\n\t\tflags &= ~MS_PRIVATE;\n\t} else if (flags & MS_SLAVE) {\n\t\tif (flags & (MS_SHARED | MS_PRIVATE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_SLAVE];\n\t\tflags &= ~MS_SLAVE;\n\t} else if (flags & MS_UNBINDABLE) {\n\t\tif (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_UNBINDABLE];\n\t\tflags &= ~MS_UNBINDABLE;\n\t} else if (flags & MS_MOVE) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MOVE];\n\t\tflags &= ~MS_MOVE;\n\t}\n\tif (!type)\n\t\ttype = \"<NULL>\";\n\tidx = tomoyo_read_lock();\n\terror = tomoyo_mount_acl(&r, dev_name, path, type, flags);\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_mount_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/mount.c",
    "lines": "75-175",
    "snippet": "static int tomoyo_mount_acl(struct tomoyo_request_info *r,\n\t\t\t    const char *dev_name,\n\t\t\t    const struct path *dir, const char *type,\n\t\t\t    unsigned long flags)\n{\n\tstruct tomoyo_obj_info obj = { };\n\tstruct path path;\n\tstruct file_system_type *fstype = NULL;\n\tconst char *requested_type = NULL;\n\tconst char *requested_dir_name = NULL;\n\tconst char *requested_dev_name = NULL;\n\tstruct tomoyo_path_info rtype;\n\tstruct tomoyo_path_info rdev;\n\tstruct tomoyo_path_info rdir;\n\tint need_dev = 0;\n\tint error = -ENOMEM;\n\tr->obj = &obj;\n\n\t/* Get fstype. */\n\trequested_type = tomoyo_encode(type);\n\tif (!requested_type)\n\t\tgoto out;\n\trtype.name = requested_type;\n\ttomoyo_fill_path_info(&rtype);\n\n\t/* Get mount point. */\n\tobj.path2 = *dir;\n\trequested_dir_name = tomoyo_realpath_from_path(dir);\n\tif (!requested_dir_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\trdir.name = requested_dir_name;\n\ttomoyo_fill_path_info(&rdir);\n\n\t/* Compare fs name. */\n\tif (type == tomoyo_mounts[TOMOYO_MOUNT_REMOUNT]) {\n\t\t/* dev_name is ignored. */\n\t} else if (type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_UNBINDABLE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_PRIVATE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_SLAVE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_SHARED]) {\n\t\t/* dev_name is ignored. */\n\t} else if (type == tomoyo_mounts[TOMOYO_MOUNT_BIND] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MOVE]) {\n\t\tneed_dev = -1; /* dev_name is a directory */\n\t} else {\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fstype->fs_flags & FS_REQUIRES_DEV)\n\t\t\t/* dev_name is a block device file. */\n\t\t\tneed_dev = 1;\n\t}\n\tif (need_dev) {\n\t\t/* Get mount point or device file. */\n\t\tif (!dev_name || kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tobj.path1 = path;\n\t\trequested_dev_name = tomoyo_realpath_from_path(&path);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* Map dev_name to \"<NULL>\" if no dev_name given. */\n\t\tif (!dev_name)\n\t\t\tdev_name = \"<NULL>\";\n\t\trequested_dev_name = tomoyo_encode(dev_name);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trdev.name = requested_dev_name;\n\ttomoyo_fill_path_info(&rdev);\n\tr->param_type = TOMOYO_TYPE_MOUNT_ACL;\n\tr->param.mount.need_dev = need_dev;\n\tr->param.mount.dev = &rdev;\n\tr->param.mount.dir = &rdir;\n\tr->param.mount.type = &rtype;\n\tr->param.mount.flags = flags;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_mount_acl);\n\t\terror = tomoyo_audit_mount_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(requested_dev_name);\n\tkfree(requested_dir_name);\n\tif (fstype)\n\t\tput_filesystem(fstype);\n\tkfree(requested_type);\n\t/* Drop refcount obtained by kern_path(). */\n\tif (obj.path1.dentry)\n\t\tpath_put(&obj.path1);\n\treturn error;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const tomoyo_mounts[TOMOYO_MAX_SPECIAL_MOUNT] = {\n\t[TOMOYO_MOUNT_BIND]            = \"--bind\",\n\t[TOMOYO_MOUNT_MOVE]            = \"--move\",\n\t[TOMOYO_MOUNT_REMOUNT]         = \"--remount\",\n\t[TOMOYO_MOUNT_MAKE_UNBINDABLE] = \"--make-unbindable\",\n\t[TOMOYO_MOUNT_MAKE_PRIVATE]    = \"--make-private\",\n\t[TOMOYO_MOUNT_MAKE_SLAVE]      = \"--make-slave\",\n\t[TOMOYO_MOUNT_MAKE_SHARED]     = \"--make-shared\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&obj.path1"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "requested_type"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_filesystem",
          "args": [
            "fstype"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "requested_dir_name"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "requested_dev_name"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_audit_mount_log",
          "args": [
            "r"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_audit_mount_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/mount.c",
          "lines": "29-36",
          "snippet": "static int tomoyo_audit_mount_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_supervisor(r, \"file mount %s %s %s 0x%lX\\n\",\n\t\t\t\t r->param.mount.dev->name,\n\t\t\t\t r->param.mount.dir->name,\n\t\t\t\t r->param.mount.type->name,\n\t\t\t\t r->param.mount.flags);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n\nstatic int tomoyo_audit_mount_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_supervisor(r, \"file mount %s %s %s 0x%lX\\n\",\n\t\t\t\t r->param.mount.dev->name,\n\t\t\t\t r->param.mount.dir->name,\n\t\t\t\t r->param.mount.type->name,\n\t\t\t\t r->param.mount.flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_check_acl",
          "args": [
            "r",
            "tomoyo_check_mount_acl"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "159-186",
          "snippet": "void tomoyo_check_acl(struct tomoyo_request_info *r,\n\t\t      bool (*check_entry) (struct tomoyo_request_info *,\n\t\t\t\t\t   const struct tomoyo_acl_info *))\n{\n\tconst struct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\tbool retried = false;\n\tconst struct list_head *list = &domain->acl_info_list;\n\nretry:\n\tlist_for_each_entry_rcu(ptr, list, list) {\n\t\tif (ptr->is_deleted || ptr->type != r->param_type)\n\t\t\tcontinue;\n\t\tif (!check_entry(r, ptr))\n\t\t\tcontinue;\n\t\tif (!tomoyo_condition(r, ptr->cond))\n\t\t\tcontinue;\n\t\tr->matched_acl = ptr;\n\t\tr->granted = true;\n\t\treturn;\n\t}\n\tif (!retried) {\n\t\tretried = true;\n\t\tlist = &domain->ns->acl_group[domain->group];\n\t\tgoto retry;\n\t}\n\tr->granted = false;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nvoid tomoyo_check_acl(struct tomoyo_request_info *r,\n\t\t      bool (*check_entry) (struct tomoyo_request_info *,\n\t\t\t\t\t   const struct tomoyo_acl_info *))\n{\n\tconst struct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\tbool retried = false;\n\tconst struct list_head *list = &domain->acl_info_list;\n\nretry:\n\tlist_for_each_entry_rcu(ptr, list, list) {\n\t\tif (ptr->is_deleted || ptr->type != r->param_type)\n\t\t\tcontinue;\n\t\tif (!check_entry(r, ptr))\n\t\t\tcontinue;\n\t\tif (!tomoyo_condition(r, ptr->cond))\n\t\t\tcontinue;\n\t\tr->matched_acl = ptr;\n\t\tr->granted = true;\n\t\treturn;\n\t}\n\tif (!retried) {\n\t\tretried = true;\n\t\tlist = &domain->ns->acl_group[domain->group];\n\t\tgoto retry;\n\t}\n\tr->granted = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_fill_path_info",
          "args": [
            "&rdev"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_fill_path_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "643-652",
          "snippet": "void tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_encode",
          "args": [
            "dev_name"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "77-80",
          "snippet": "char *tomoyo_encode(const char *str)\n{\n\treturn str ? tomoyo_encode2(str, strlen(str)) : NULL;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nchar *tomoyo_encode(const char *str)\n{\n\treturn str ? tomoyo_encode2(str, strlen(str)) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_realpath_from_path",
          "args": [
            "&path"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_realpath_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "251-311",
          "snippet": "char *tomoyo_realpath_from_path(const struct path *path)\n{\n\tchar *buf = NULL;\n\tchar *name = NULL;\n\tunsigned int buf_len = PAGE_SIZE / 2;\n\tstruct dentry *dentry = path->dentry;\n\tstruct super_block *sb;\n\tif (!dentry)\n\t\treturn NULL;\n\tsb = dentry->d_sb;\n\twhile (1) {\n\t\tchar *pos;\n\t\tstruct inode *inode;\n\t\tbuf_len <<= 1;\n\t\tkfree(buf);\n\t\tbuf = kmalloc(buf_len, GFP_NOFS);\n\t\tif (!buf)\n\t\t\tbreak;\n\t\t/* To make sure that pos is '\\0' terminated. */\n\t\tbuf[buf_len - 1] = '\\0';\n\t\t/* Get better name for socket. */\n\t\tif (sb->s_magic == SOCKFS_MAGIC) {\n\t\t\tpos = tomoyo_get_socket_name(path, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\t/* For \"pipe:[\\$]\". */\n\t\tif (dentry->d_op && dentry->d_op->d_dname) {\n\t\t\tpos = dentry->d_op->d_dname(dentry, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\tinode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Get local name for filesystems without rename() operation\n\t\t * or dentry without vfsmount.\n\t\t */\n\t\tif (!path->mnt ||\n\t\t    (!inode->i_op->rename))\n\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t    buf_len - 1);\n\t\t/* Get absolute name for the rest. */\n\t\telse {\n\t\t\tpos = tomoyo_get_absolute_path(path, buf, buf_len - 1);\n\t\t\t/*\n\t\t\t * Fall back to local name if absolute name is not\n\t\t\t * available.\n\t\t\t */\n\t\t\tif (pos == ERR_PTR(-EINVAL))\n\t\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t\t    buf_len - 1);\n\t\t}\nencode:\n\t\tif (IS_ERR(pos))\n\t\t\tcontinue;\n\t\tname = tomoyo_encode(pos);\n\t\tbreak;\n\t}\n\tkfree(buf);\n\tif (!name)\n\t\ttomoyo_warn_oom(__func__);\n\treturn name;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nchar *tomoyo_realpath_from_path(const struct path *path)\n{\n\tchar *buf = NULL;\n\tchar *name = NULL;\n\tunsigned int buf_len = PAGE_SIZE / 2;\n\tstruct dentry *dentry = path->dentry;\n\tstruct super_block *sb;\n\tif (!dentry)\n\t\treturn NULL;\n\tsb = dentry->d_sb;\n\twhile (1) {\n\t\tchar *pos;\n\t\tstruct inode *inode;\n\t\tbuf_len <<= 1;\n\t\tkfree(buf);\n\t\tbuf = kmalloc(buf_len, GFP_NOFS);\n\t\tif (!buf)\n\t\t\tbreak;\n\t\t/* To make sure that pos is '\\0' terminated. */\n\t\tbuf[buf_len - 1] = '\\0';\n\t\t/* Get better name for socket. */\n\t\tif (sb->s_magic == SOCKFS_MAGIC) {\n\t\t\tpos = tomoyo_get_socket_name(path, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\t/* For \"pipe:[\\$]\". */\n\t\tif (dentry->d_op && dentry->d_op->d_dname) {\n\t\t\tpos = dentry->d_op->d_dname(dentry, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\tinode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Get local name for filesystems without rename() operation\n\t\t * or dentry without vfsmount.\n\t\t */\n\t\tif (!path->mnt ||\n\t\t    (!inode->i_op->rename))\n\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t    buf_len - 1);\n\t\t/* Get absolute name for the rest. */\n\t\telse {\n\t\t\tpos = tomoyo_get_absolute_path(path, buf, buf_len - 1);\n\t\t\t/*\n\t\t\t * Fall back to local name if absolute name is not\n\t\t\t * available.\n\t\t\t */\n\t\t\tif (pos == ERR_PTR(-EINVAL))\n\t\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t\t    buf_len - 1);\n\t\t}\nencode:\n\t\tif (IS_ERR(pos))\n\t\t\tcontinue;\n\t\tname = tomoyo_encode(pos);\n\t\tbreak;\n\t}\n\tkfree(buf);\n\tif (!name)\n\t\ttomoyo_warn_oom(__func__);\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "dev_name",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs_type",
          "args": [
            "type"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n\nstatic const char * const tomoyo_mounts[TOMOYO_MAX_SPECIAL_MOUNT] = {\n\t[TOMOYO_MOUNT_BIND]            = \"--bind\",\n\t[TOMOYO_MOUNT_MOVE]            = \"--move\",\n\t[TOMOYO_MOUNT_REMOUNT]         = \"--remount\",\n\t[TOMOYO_MOUNT_MAKE_UNBINDABLE] = \"--make-unbindable\",\n\t[TOMOYO_MOUNT_MAKE_PRIVATE]    = \"--make-private\",\n\t[TOMOYO_MOUNT_MAKE_SLAVE]      = \"--make-slave\",\n\t[TOMOYO_MOUNT_MAKE_SHARED]     = \"--make-shared\",\n};\n\nstatic int tomoyo_mount_acl(struct tomoyo_request_info *r,\n\t\t\t    const char *dev_name,\n\t\t\t    const struct path *dir, const char *type,\n\t\t\t    unsigned long flags)\n{\n\tstruct tomoyo_obj_info obj = { };\n\tstruct path path;\n\tstruct file_system_type *fstype = NULL;\n\tconst char *requested_type = NULL;\n\tconst char *requested_dir_name = NULL;\n\tconst char *requested_dev_name = NULL;\n\tstruct tomoyo_path_info rtype;\n\tstruct tomoyo_path_info rdev;\n\tstruct tomoyo_path_info rdir;\n\tint need_dev = 0;\n\tint error = -ENOMEM;\n\tr->obj = &obj;\n\n\t/* Get fstype. */\n\trequested_type = tomoyo_encode(type);\n\tif (!requested_type)\n\t\tgoto out;\n\trtype.name = requested_type;\n\ttomoyo_fill_path_info(&rtype);\n\n\t/* Get mount point. */\n\tobj.path2 = *dir;\n\trequested_dir_name = tomoyo_realpath_from_path(dir);\n\tif (!requested_dir_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\trdir.name = requested_dir_name;\n\ttomoyo_fill_path_info(&rdir);\n\n\t/* Compare fs name. */\n\tif (type == tomoyo_mounts[TOMOYO_MOUNT_REMOUNT]) {\n\t\t/* dev_name is ignored. */\n\t} else if (type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_UNBINDABLE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_PRIVATE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_SLAVE] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MAKE_SHARED]) {\n\t\t/* dev_name is ignored. */\n\t} else if (type == tomoyo_mounts[TOMOYO_MOUNT_BIND] ||\n\t\t   type == tomoyo_mounts[TOMOYO_MOUNT_MOVE]) {\n\t\tneed_dev = -1; /* dev_name is a directory */\n\t} else {\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fstype->fs_flags & FS_REQUIRES_DEV)\n\t\t\t/* dev_name is a block device file. */\n\t\t\tneed_dev = 1;\n\t}\n\tif (need_dev) {\n\t\t/* Get mount point or device file. */\n\t\tif (!dev_name || kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tobj.path1 = path;\n\t\trequested_dev_name = tomoyo_realpath_from_path(&path);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* Map dev_name to \"<NULL>\" if no dev_name given. */\n\t\tif (!dev_name)\n\t\t\tdev_name = \"<NULL>\";\n\t\trequested_dev_name = tomoyo_encode(dev_name);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trdev.name = requested_dev_name;\n\ttomoyo_fill_path_info(&rdev);\n\tr->param_type = TOMOYO_TYPE_MOUNT_ACL;\n\tr->param.mount.need_dev = need_dev;\n\tr->param.mount.dev = &rdev;\n\tr->param.mount.dir = &rdir;\n\tr->param.mount.type = &rtype;\n\tr->param.mount.flags = flags;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_mount_acl);\n\t\terror = tomoyo_audit_mount_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(requested_dev_name);\n\tkfree(requested_dir_name);\n\tif (fstype)\n\t\tput_filesystem(fstype);\n\tkfree(requested_type);\n\t/* Drop refcount obtained by kern_path(). */\n\tif (obj.path1.dentry)\n\t\tpath_put(&obj.path1);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_check_mount_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/mount.c",
    "lines": "46-60",
    "snippet": "static bool tomoyo_check_mount_acl(struct tomoyo_request_info *r,\n\t\t\t\t   const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_mount_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\treturn tomoyo_compare_number_union(r->param.mount.flags,\n\t\t\t\t\t   &acl->flags) &&\n\t\ttomoyo_compare_name_union(r->param.mount.type,\n\t\t\t\t\t  &acl->fs_type) &&\n\t\ttomoyo_compare_name_union(r->param.mount.dir,\n\t\t\t\t\t  &acl->dir_name) &&\n\t\t(!r->param.mount.need_dev ||\n\t\t tomoyo_compare_name_union(r->param.mount.dev,\n\t\t\t\t\t   &acl->dev_name));\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_compare_name_union",
          "args": [
            "r->param.mount.dev",
            "&acl->dev_name"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_compare_name_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "81-90",
          "snippet": "const struct tomoyo_path_info *\ntomoyo_compare_name_union(const struct tomoyo_path_info *name,\n\t\t\t  const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_path_matches_group(name, ptr->group);\n\tif (tomoyo_path_matches_pattern(name, ptr->filename))\n\t\treturn ptr->filename;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst struct tomoyo_path_info *\ntomoyo_compare_name_union(const struct tomoyo_path_info *name,\n\t\t\t  const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_path_matches_group(name, ptr->group);\n\tif (tomoyo_path_matches_pattern(name, ptr->filename))\n\t\treturn ptr->filename;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_compare_number_union",
          "args": [
            "r->param.mount.flags",
            "&acl->flags"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_compare_number_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "112-118",
          "snippet": "bool tomoyo_compare_number_union(const unsigned long value,\n\t\t\t\t const struct tomoyo_number_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_number_matches_group(value, value, ptr->group);\n\treturn value >= ptr->values[0] && value <= ptr->values[1];\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nbool tomoyo_compare_number_union(const unsigned long value,\n\t\t\t\t const struct tomoyo_number_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_number_matches_group(value, value, ptr->group);\n\treturn value >= ptr->values[0] && value <= ptr->values[1];\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ptr",
            "typeof(*acl)",
            "head"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*acl"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n\nstatic bool tomoyo_check_mount_acl(struct tomoyo_request_info *r,\n\t\t\t\t   const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_mount_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\treturn tomoyo_compare_number_union(r->param.mount.flags,\n\t\t\t\t\t   &acl->flags) &&\n\t\ttomoyo_compare_name_union(r->param.mount.type,\n\t\t\t\t\t  &acl->fs_type) &&\n\t\ttomoyo_compare_name_union(r->param.mount.dir,\n\t\t\t\t\t  &acl->dir_name) &&\n\t\t(!r->param.mount.need_dev ||\n\t\t tomoyo_compare_name_union(r->param.mount.dev,\n\t\t\t\t\t   &acl->dev_name));\n}"
  },
  {
    "function_name": "tomoyo_audit_mount_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/mount.c",
    "lines": "29-36",
    "snippet": "static int tomoyo_audit_mount_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_supervisor(r, \"file mount %s %s %s 0x%lX\\n\",\n\t\t\t\t r->param.mount.dev->name,\n\t\t\t\t r->param.mount.dir->name,\n\t\t\t\t r->param.mount.type->name,\n\t\t\t\t r->param.mount.flags);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_supervisor",
          "args": [
            "r",
            "\"file mount %s %s %s 0x%lX\\n\"",
            "r->param.mount.dev->name",
            "r->param.mount.dir->name",
            "r->param.mount.type->name",
            "r->param.mount.flags"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_supervisor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1996-2088",
          "snippet": "int tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint error;\n\tint len;\n\tstatic unsigned int tomoyo_serial;\n\tstruct tomoyo_query entry = { };\n\tbool quota_exceeded = false;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\t/* Write /sys/kernel/security/tomoyo/audit. */\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n\t/* Nothing more to do if granted. */\n\tif (r->granted)\n\t\treturn 0;\n\tif (r->mode)\n\t\ttomoyo_update_stat(r->mode);\n\tswitch (r->mode) {\n\tcase TOMOYO_CONFIG_ENFORCING:\n\t\terror = -EPERM;\n\t\tif (atomic_read(&tomoyo_query_observers))\n\t\t\tbreak;\n\t\tgoto out;\n\tcase TOMOYO_CONFIG_LEARNING:\n\t\terror = 0;\n\t\t/* Check max_learning_entry parameter. */\n\t\tif (tomoyo_domain_quota_is_ok(r))\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* Get message. */\n\tva_start(args, fmt);\n\tentry.query = tomoyo_init_log(r, len, fmt, args);\n\tva_end(args);\n\tif (!entry.query)\n\t\tgoto out;\n\tentry.query_len = strlen(entry.query) + 1;\n\tif (!error) {\n\t\ttomoyo_add_entry(r->domain, entry.query);\n\t\tgoto out;\n\t}\n\tlen = tomoyo_round2(entry.query_len);\n\tentry.domain = r->domain;\n\tspin_lock(&tomoyo_query_list_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_QUERY] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_QUERY] + len\n\t    >= tomoyo_memory_quota[TOMOYO_MEMORY_QUERY]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\tentry.serial = tomoyo_serial++;\n\t\tentry.retry = r->retry;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] += len;\n\t\tlist_add_tail(&entry.list, &tomoyo_query_list);\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (quota_exceeded)\n\t\tgoto out;\n\t/* Give 10 seconds for supervisor's opinion. */\n\twhile (entry.timer < 10) {\n\t\twake_up_all(&tomoyo_query_wait);\n\t\tif (wait_event_interruptible_timeout\n\t\t    (tomoyo_answer_wait, entry.answer ||\n\t\t     !atomic_read(&tomoyo_query_observers), HZ))\n\t\t\tbreak;\n\t\telse\n\t\t\tentry.timer++;\n\t}\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_del(&entry.list);\n\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] -= len;\n\tspin_unlock(&tomoyo_query_list_lock);\n\tswitch (entry.answer) {\n\tcase 3: /* Asked to retry by administrator. */\n\t\terror = TOMOYO_RETRY_REQUEST;\n\t\tr->retry++;\n\t\tbreak;\n\tcase 1:\n\t\t/* Granted by administrator. */\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\t/* Timed out or rejected by administrator. */\n\t\tbreak;\n\t}\nout:\n\tkfree(entry.query);\n\treturn error;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);",
            "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_query_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_answer_wait);",
            "static LIST_HEAD(tomoyo_query_list);",
            "static DEFINE_SPINLOCK(tomoyo_query_list_lock);",
            "static atomic_t tomoyo_query_observers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_query_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_answer_wait);\nstatic LIST_HEAD(tomoyo_query_list);\nstatic DEFINE_SPINLOCK(tomoyo_query_list_lock);\nstatic atomic_t tomoyo_query_observers = ATOMIC_INIT(0);\n\nint tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint error;\n\tint len;\n\tstatic unsigned int tomoyo_serial;\n\tstruct tomoyo_query entry = { };\n\tbool quota_exceeded = false;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\t/* Write /sys/kernel/security/tomoyo/audit. */\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n\t/* Nothing more to do if granted. */\n\tif (r->granted)\n\t\treturn 0;\n\tif (r->mode)\n\t\ttomoyo_update_stat(r->mode);\n\tswitch (r->mode) {\n\tcase TOMOYO_CONFIG_ENFORCING:\n\t\terror = -EPERM;\n\t\tif (atomic_read(&tomoyo_query_observers))\n\t\t\tbreak;\n\t\tgoto out;\n\tcase TOMOYO_CONFIG_LEARNING:\n\t\terror = 0;\n\t\t/* Check max_learning_entry parameter. */\n\t\tif (tomoyo_domain_quota_is_ok(r))\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* Get message. */\n\tva_start(args, fmt);\n\tentry.query = tomoyo_init_log(r, len, fmt, args);\n\tva_end(args);\n\tif (!entry.query)\n\t\tgoto out;\n\tentry.query_len = strlen(entry.query) + 1;\n\tif (!error) {\n\t\ttomoyo_add_entry(r->domain, entry.query);\n\t\tgoto out;\n\t}\n\tlen = tomoyo_round2(entry.query_len);\n\tentry.domain = r->domain;\n\tspin_lock(&tomoyo_query_list_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_QUERY] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_QUERY] + len\n\t    >= tomoyo_memory_quota[TOMOYO_MEMORY_QUERY]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\tentry.serial = tomoyo_serial++;\n\t\tentry.retry = r->retry;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] += len;\n\t\tlist_add_tail(&entry.list, &tomoyo_query_list);\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (quota_exceeded)\n\t\tgoto out;\n\t/* Give 10 seconds for supervisor's opinion. */\n\twhile (entry.timer < 10) {\n\t\twake_up_all(&tomoyo_query_wait);\n\t\tif (wait_event_interruptible_timeout\n\t\t    (tomoyo_answer_wait, entry.answer ||\n\t\t     !atomic_read(&tomoyo_query_observers), HZ))\n\t\t\tbreak;\n\t\telse\n\t\t\tentry.timer++;\n\t}\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_del(&entry.list);\n\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] -= len;\n\tspin_unlock(&tomoyo_query_list_lock);\n\tswitch (entry.answer) {\n\tcase 3: /* Asked to retry by administrator. */\n\t\terror = TOMOYO_RETRY_REQUEST;\n\t\tr->retry++;\n\t\tbreak;\n\tcase 1:\n\t\t/* Granted by administrator. */\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\t/* Timed out or rejected by administrator. */\n\t\tbreak;\n\t}\nout:\n\tkfree(entry.query);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n\nstatic int tomoyo_audit_mount_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_supervisor(r, \"file mount %s %s %s 0x%lX\\n\",\n\t\t\t\t r->param.mount.dev->name,\n\t\t\t\t r->param.mount.dir->name,\n\t\t\t\t r->param.mount.type->name,\n\t\t\t\t r->param.mount.flags);\n}"
  }
]