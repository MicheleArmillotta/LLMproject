[
  {
    "function_name": "ima_eventsig_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "378-393",
    "snippet": "int ima_eventsig_init(struct ima_event_data *event_data,\n\t\t      struct ima_field_data *field_data)\n{\n\tenum data_formats fmt = DATA_FMT_HEX;\n\tstruct evm_ima_xattr_data *xattr_value = event_data->xattr_value;\n\tint xattr_len = event_data->xattr_len;\n\tint rc = 0;\n\n\tif ((!xattr_value) || (xattr_value->type != EVM_IMA_XATTR_DIGSIG))\n\t\tgoto out;\n\n\trc = ima_write_template_field_data(xattr_value, xattr_len, fmt,\n\t\t\t\t\t   field_data);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_write_template_field_data",
          "args": [
            "xattr_value",
            "xattr_len",
            "fmt",
            "field_data"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "ima_write_template_field_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "33-65",
          "snippet": "static int ima_write_template_field_data(const void *data, const u32 datalen,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf, *buf_ptr;\n\tu32 buflen = datalen;\n\n\tif (datafmt == DATA_FMT_STRING)\n\t\tbuflen = datalen + 1;\n\n\tbuf = kzalloc(buflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, data, datalen);\n\n\t/*\n\t * Replace all space characters with underscore for event names and\n\t * strings. This avoid that, during the parsing of a measurements list,\n\t * filenames with spaces or that end with the suffix ' (deleted)' are\n\t * split into multiple template fields (the space is the delimitator\n\t * character for measurements lists in ASCII format).\n\t */\n\tif (datafmt == DATA_FMT_STRING) {\n\t\tfor (buf_ptr = buf; buf_ptr - buf < datalen; buf_ptr++)\n\t\t\tif (*buf_ptr == ' ')\n\t\t\t\t*buf_ptr = '_';\n\t}\n\n\tfield_data->data = buf;\n\tfield_data->len = buflen;\n\treturn 0;\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic int ima_write_template_field_data(const void *data, const u32 datalen,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf, *buf_ptr;\n\tu32 buflen = datalen;\n\n\tif (datafmt == DATA_FMT_STRING)\n\t\tbuflen = datalen + 1;\n\n\tbuf = kzalloc(buflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, data, datalen);\n\n\t/*\n\t * Replace all space characters with underscore for event names and\n\t * strings. This avoid that, during the parsing of a measurements list,\n\t * filenames with spaces or that end with the suffix ' (deleted)' are\n\t * split into multiple template fields (the space is the delimitator\n\t * character for measurements lists in ASCII format).\n\t */\n\tif (datafmt == DATA_FMT_STRING) {\n\t\tfor (buf_ptr = buf; buf_ptr - buf < datalen; buf_ptr++)\n\t\t\tif (*buf_ptr == ' ')\n\t\t\t\t*buf_ptr = '_';\n\t}\n\n\tfield_data->data = buf;\n\tfield_data->len = buflen;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nint ima_eventsig_init(struct ima_event_data *event_data,\n\t\t      struct ima_field_data *field_data)\n{\n\tenum data_formats fmt = DATA_FMT_HEX;\n\tstruct evm_ima_xattr_data *xattr_value = event_data->xattr_value;\n\tint xattr_len = event_data->xattr_len;\n\tint rc = 0;\n\n\tif ((!xattr_value) || (xattr_value->type != EVM_IMA_XATTR_DIGSIG))\n\t\tgoto out;\n\n\trc = ima_write_template_field_data(xattr_value, xattr_len, fmt,\n\t\t\t\t\t   field_data);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ima_eventname_ng_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "369-373",
    "snippet": "int ima_eventname_ng_init(struct ima_event_data *event_data,\n\t\t\t  struct ima_field_data *field_data)\n{\n\treturn ima_eventname_init_common(event_data, field_data, false);\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_eventname_init_common",
          "args": [
            "event_data",
            "field_data",
            "false"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "ima_eventname_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "326-355",
          "snippet": "static int ima_eventname_init_common(struct ima_event_data *event_data,\n\t\t\t\t     struct ima_field_data *field_data,\n\t\t\t\t     bool size_limit)\n{\n\tconst char *cur_filename = NULL;\n\tu32 cur_filename_len = 0;\n\n\tBUG_ON(event_data->filename == NULL && event_data->file == NULL);\n\n\tif (event_data->filename) {\n\t\tcur_filename = event_data->filename;\n\t\tcur_filename_len = strlen(event_data->filename);\n\n\t\tif (!size_limit || cur_filename_len <= IMA_EVENT_NAME_LEN_MAX)\n\t\t\tgoto out;\n\t}\n\n\tif (event_data->file) {\n\t\tcur_filename = event_data->file->f_path.dentry->d_name.name;\n\t\tcur_filename_len = strlen(cur_filename);\n\t} else\n\t\t/*\n\t\t * Truncate filename if the latter is too long and\n\t\t * the file descriptor is not available.\n\t\t */\n\t\tcur_filename_len = IMA_EVENT_NAME_LEN_MAX;\nout:\n\treturn ima_write_template_field_data(cur_filename, cur_filename_len,\n\t\t\t\t\t     DATA_FMT_STRING, field_data);\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic int ima_eventname_init_common(struct ima_event_data *event_data,\n\t\t\t\t     struct ima_field_data *field_data,\n\t\t\t\t     bool size_limit)\n{\n\tconst char *cur_filename = NULL;\n\tu32 cur_filename_len = 0;\n\n\tBUG_ON(event_data->filename == NULL && event_data->file == NULL);\n\n\tif (event_data->filename) {\n\t\tcur_filename = event_data->filename;\n\t\tcur_filename_len = strlen(event_data->filename);\n\n\t\tif (!size_limit || cur_filename_len <= IMA_EVENT_NAME_LEN_MAX)\n\t\t\tgoto out;\n\t}\n\n\tif (event_data->file) {\n\t\tcur_filename = event_data->file->f_path.dentry->d_name.name;\n\t\tcur_filename_len = strlen(cur_filename);\n\t} else\n\t\t/*\n\t\t * Truncate filename if the latter is too long and\n\t\t * the file descriptor is not available.\n\t\t */\n\t\tcur_filename_len = IMA_EVENT_NAME_LEN_MAX;\nout:\n\treturn ima_write_template_field_data(cur_filename, cur_filename_len,\n\t\t\t\t\t     DATA_FMT_STRING, field_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nint ima_eventname_ng_init(struct ima_event_data *event_data,\n\t\t\t  struct ima_field_data *field_data)\n{\n\treturn ima_eventname_init_common(event_data, field_data, false);\n}"
  },
  {
    "function_name": "ima_eventname_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "360-364",
    "snippet": "int ima_eventname_init(struct ima_event_data *event_data,\n\t\t       struct ima_field_data *field_data)\n{\n\treturn ima_eventname_init_common(event_data, field_data, true);\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_eventname_init_common",
          "args": [
            "event_data",
            "field_data",
            "true"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ima_eventname_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "326-355",
          "snippet": "static int ima_eventname_init_common(struct ima_event_data *event_data,\n\t\t\t\t     struct ima_field_data *field_data,\n\t\t\t\t     bool size_limit)\n{\n\tconst char *cur_filename = NULL;\n\tu32 cur_filename_len = 0;\n\n\tBUG_ON(event_data->filename == NULL && event_data->file == NULL);\n\n\tif (event_data->filename) {\n\t\tcur_filename = event_data->filename;\n\t\tcur_filename_len = strlen(event_data->filename);\n\n\t\tif (!size_limit || cur_filename_len <= IMA_EVENT_NAME_LEN_MAX)\n\t\t\tgoto out;\n\t}\n\n\tif (event_data->file) {\n\t\tcur_filename = event_data->file->f_path.dentry->d_name.name;\n\t\tcur_filename_len = strlen(cur_filename);\n\t} else\n\t\t/*\n\t\t * Truncate filename if the latter is too long and\n\t\t * the file descriptor is not available.\n\t\t */\n\t\tcur_filename_len = IMA_EVENT_NAME_LEN_MAX;\nout:\n\treturn ima_write_template_field_data(cur_filename, cur_filename_len,\n\t\t\t\t\t     DATA_FMT_STRING, field_data);\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic int ima_eventname_init_common(struct ima_event_data *event_data,\n\t\t\t\t     struct ima_field_data *field_data,\n\t\t\t\t     bool size_limit)\n{\n\tconst char *cur_filename = NULL;\n\tu32 cur_filename_len = 0;\n\n\tBUG_ON(event_data->filename == NULL && event_data->file == NULL);\n\n\tif (event_data->filename) {\n\t\tcur_filename = event_data->filename;\n\t\tcur_filename_len = strlen(event_data->filename);\n\n\t\tif (!size_limit || cur_filename_len <= IMA_EVENT_NAME_LEN_MAX)\n\t\t\tgoto out;\n\t}\n\n\tif (event_data->file) {\n\t\tcur_filename = event_data->file->f_path.dentry->d_name.name;\n\t\tcur_filename_len = strlen(cur_filename);\n\t} else\n\t\t/*\n\t\t * Truncate filename if the latter is too long and\n\t\t * the file descriptor is not available.\n\t\t */\n\t\tcur_filename_len = IMA_EVENT_NAME_LEN_MAX;\nout:\n\treturn ima_write_template_field_data(cur_filename, cur_filename_len,\n\t\t\t\t\t     DATA_FMT_STRING, field_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nint ima_eventname_init(struct ima_event_data *event_data,\n\t\t       struct ima_field_data *field_data)\n{\n\treturn ima_eventname_init_common(event_data, field_data, true);\n}"
  },
  {
    "function_name": "ima_eventname_init_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "326-355",
    "snippet": "static int ima_eventname_init_common(struct ima_event_data *event_data,\n\t\t\t\t     struct ima_field_data *field_data,\n\t\t\t\t     bool size_limit)\n{\n\tconst char *cur_filename = NULL;\n\tu32 cur_filename_len = 0;\n\n\tBUG_ON(event_data->filename == NULL && event_data->file == NULL);\n\n\tif (event_data->filename) {\n\t\tcur_filename = event_data->filename;\n\t\tcur_filename_len = strlen(event_data->filename);\n\n\t\tif (!size_limit || cur_filename_len <= IMA_EVENT_NAME_LEN_MAX)\n\t\t\tgoto out;\n\t}\n\n\tif (event_data->file) {\n\t\tcur_filename = event_data->file->f_path.dentry->d_name.name;\n\t\tcur_filename_len = strlen(cur_filename);\n\t} else\n\t\t/*\n\t\t * Truncate filename if the latter is too long and\n\t\t * the file descriptor is not available.\n\t\t */\n\t\tcur_filename_len = IMA_EVENT_NAME_LEN_MAX;\nout:\n\treturn ima_write_template_field_data(cur_filename, cur_filename_len,\n\t\t\t\t\t     DATA_FMT_STRING, field_data);\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_write_template_field_data",
          "args": [
            "cur_filename",
            "cur_filename_len",
            "DATA_FMT_STRING",
            "field_data"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "ima_write_template_field_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "33-65",
          "snippet": "static int ima_write_template_field_data(const void *data, const u32 datalen,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf, *buf_ptr;\n\tu32 buflen = datalen;\n\n\tif (datafmt == DATA_FMT_STRING)\n\t\tbuflen = datalen + 1;\n\n\tbuf = kzalloc(buflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, data, datalen);\n\n\t/*\n\t * Replace all space characters with underscore for event names and\n\t * strings. This avoid that, during the parsing of a measurements list,\n\t * filenames with spaces or that end with the suffix ' (deleted)' are\n\t * split into multiple template fields (the space is the delimitator\n\t * character for measurements lists in ASCII format).\n\t */\n\tif (datafmt == DATA_FMT_STRING) {\n\t\tfor (buf_ptr = buf; buf_ptr - buf < datalen; buf_ptr++)\n\t\t\tif (*buf_ptr == ' ')\n\t\t\t\t*buf_ptr = '_';\n\t}\n\n\tfield_data->data = buf;\n\tfield_data->len = buflen;\n\treturn 0;\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic int ima_write_template_field_data(const void *data, const u32 datalen,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf, *buf_ptr;\n\tu32 buflen = datalen;\n\n\tif (datafmt == DATA_FMT_STRING)\n\t\tbuflen = datalen + 1;\n\n\tbuf = kzalloc(buflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, data, datalen);\n\n\t/*\n\t * Replace all space characters with underscore for event names and\n\t * strings. This avoid that, during the parsing of a measurements list,\n\t * filenames with spaces or that end with the suffix ' (deleted)' are\n\t * split into multiple template fields (the space is the delimitator\n\t * character for measurements lists in ASCII format).\n\t */\n\tif (datafmt == DATA_FMT_STRING) {\n\t\tfor (buf_ptr = buf; buf_ptr - buf < datalen; buf_ptr++)\n\t\t\tif (*buf_ptr == ' ')\n\t\t\t\t*buf_ptr = '_';\n\t}\n\n\tfield_data->data = buf;\n\tfield_data->len = buflen;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cur_filename"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "event_data->filename"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "event_data->filename == NULL && event_data->file == NULL"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic int ima_eventname_init_common(struct ima_event_data *event_data,\n\t\t\t\t     struct ima_field_data *field_data,\n\t\t\t\t     bool size_limit)\n{\n\tconst char *cur_filename = NULL;\n\tu32 cur_filename_len = 0;\n\n\tBUG_ON(event_data->filename == NULL && event_data->file == NULL);\n\n\tif (event_data->filename) {\n\t\tcur_filename = event_data->filename;\n\t\tcur_filename_len = strlen(event_data->filename);\n\n\t\tif (!size_limit || cur_filename_len <= IMA_EVENT_NAME_LEN_MAX)\n\t\t\tgoto out;\n\t}\n\n\tif (event_data->file) {\n\t\tcur_filename = event_data->file->f_path.dentry->d_name.name;\n\t\tcur_filename_len = strlen(cur_filename);\n\t} else\n\t\t/*\n\t\t * Truncate filename if the latter is too long and\n\t\t * the file descriptor is not available.\n\t\t */\n\t\tcur_filename_len = IMA_EVENT_NAME_LEN_MAX;\nout:\n\treturn ima_write_template_field_data(cur_filename, cur_filename_len,\n\t\t\t\t\t     DATA_FMT_STRING, field_data);\n}"
  },
  {
    "function_name": "ima_eventdigest_ng_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "308-324",
    "snippet": "int ima_eventdigest_ng_init(struct ima_event_data *event_data,\n\t\t\t    struct ima_field_data *field_data)\n{\n\tu8 *cur_digest = NULL, hash_algo = HASH_ALGO_SHA1;\n\tu32 cur_digestsize = 0;\n\n\tif (event_data->violation)\t/* recording a violation. */\n\t\tgoto out;\n\n\tcur_digest = event_data->iint->ima_hash->digest;\n\tcur_digestsize = event_data->iint->ima_hash->length;\n\n\thash_algo = event_data->iint->ima_hash->algo;\nout:\n\treturn ima_eventdigest_init_common(cur_digest, cur_digestsize,\n\t\t\t\t\t   hash_algo, field_data);\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_eventdigest_init_common",
          "args": [
            "cur_digest",
            "cur_digestsize",
            "hash_algo",
            "field_data"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "ima_eventdigest_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "223-257",
          "snippet": "static int ima_eventdigest_init_common(u8 *digest, u32 digestsize, u8 hash_algo,\n\t\t\t\t       struct ima_field_data *field_data)\n{\n\t/*\n\t * digest formats:\n\t *  - DATA_FMT_DIGEST: digest\n\t *  - DATA_FMT_DIGEST_WITH_ALGO: [<hash algo>] + ':' + '\\0' + digest,\n\t *    where <hash algo> is provided if the hash algoritm is not\n\t *    SHA1 or MD5\n\t */\n\tu8 buffer[CRYPTO_MAX_ALG_NAME + 2 + IMA_MAX_DIGEST_SIZE] = { 0 };\n\tenum data_formats fmt = DATA_FMT_DIGEST;\n\tu32 offset = 0;\n\n\tif (hash_algo < HASH_ALGO__LAST) {\n\t\tfmt = DATA_FMT_DIGEST_WITH_ALGO;\n\t\toffset += snprintf(buffer, CRYPTO_MAX_ALG_NAME + 1, \"%s\",\n\t\t\t\t   hash_algo_name[hash_algo]);\n\t\tbuffer[offset] = ':';\n\t\toffset += 2;\n\t}\n\n\tif (digest)\n\t\tmemcpy(buffer + offset, digest, digestsize);\n\telse\n\t\t/*\n\t\t * If digest is NULL, the event being recorded is a violation.\n\t\t * Make room for the digest by increasing the offset of\n\t\t * IMA_DIGEST_SIZE.\n\t\t */\n\t\toffset += IMA_DIGEST_SIZE;\n\n\treturn ima_write_template_field_data(buffer, offset + digestsize,\n\t\t\t\t\t     fmt, field_data);\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic int ima_eventdigest_init_common(u8 *digest, u32 digestsize, u8 hash_algo,\n\t\t\t\t       struct ima_field_data *field_data)\n{\n\t/*\n\t * digest formats:\n\t *  - DATA_FMT_DIGEST: digest\n\t *  - DATA_FMT_DIGEST_WITH_ALGO: [<hash algo>] + ':' + '\\0' + digest,\n\t *    where <hash algo> is provided if the hash algoritm is not\n\t *    SHA1 or MD5\n\t */\n\tu8 buffer[CRYPTO_MAX_ALG_NAME + 2 + IMA_MAX_DIGEST_SIZE] = { 0 };\n\tenum data_formats fmt = DATA_FMT_DIGEST;\n\tu32 offset = 0;\n\n\tif (hash_algo < HASH_ALGO__LAST) {\n\t\tfmt = DATA_FMT_DIGEST_WITH_ALGO;\n\t\toffset += snprintf(buffer, CRYPTO_MAX_ALG_NAME + 1, \"%s\",\n\t\t\t\t   hash_algo_name[hash_algo]);\n\t\tbuffer[offset] = ':';\n\t\toffset += 2;\n\t}\n\n\tif (digest)\n\t\tmemcpy(buffer + offset, digest, digestsize);\n\telse\n\t\t/*\n\t\t * If digest is NULL, the event being recorded is a violation.\n\t\t * Make room for the digest by increasing the offset of\n\t\t * IMA_DIGEST_SIZE.\n\t\t */\n\t\toffset += IMA_DIGEST_SIZE;\n\n\treturn ima_write_template_field_data(buffer, offset + digestsize,\n\t\t\t\t\t     fmt, field_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nint ima_eventdigest_ng_init(struct ima_event_data *event_data,\n\t\t\t    struct ima_field_data *field_data)\n{\n\tu8 *cur_digest = NULL, hash_algo = HASH_ALGO_SHA1;\n\tu32 cur_digestsize = 0;\n\n\tif (event_data->violation)\t/* recording a violation. */\n\t\tgoto out;\n\n\tcur_digest = event_data->iint->ima_hash->digest;\n\tcur_digestsize = event_data->iint->ima_hash->length;\n\n\thash_algo = event_data->iint->ima_hash->algo;\nout:\n\treturn ima_eventdigest_init_common(cur_digest, cur_digestsize,\n\t\t\t\t\t   hash_algo, field_data);\n}"
  },
  {
    "function_name": "ima_eventdigest_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "262-303",
    "snippet": "int ima_eventdigest_init(struct ima_event_data *event_data,\n\t\t\t struct ima_field_data *field_data)\n{\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[IMA_MAX_DIGEST_SIZE];\n\t} hash;\n\tu8 *cur_digest = NULL;\n\tu32 cur_digestsize = 0;\n\tstruct inode *inode;\n\tint result;\n\n\tmemset(&hash, 0, sizeof(hash));\n\n\tif (event_data->violation)\t/* recording a violation. */\n\t\tgoto out;\n\n\tif (ima_template_hash_algo_allowed(event_data->iint->ima_hash->algo)) {\n\t\tcur_digest = event_data->iint->ima_hash->digest;\n\t\tcur_digestsize = event_data->iint->ima_hash->length;\n\t\tgoto out;\n\t}\n\n\tif (!event_data->file)\t/* missing info to re-calculate the digest */\n\t\treturn -EINVAL;\n\n\tinode = file_inode(event_data->file);\n\thash.hdr.algo = ima_template_hash_algo_allowed(ima_hash_algo) ?\n\t    ima_hash_algo : HASH_ALGO_SHA1;\n\tresult = ima_calc_file_hash(event_data->file, &hash.hdr);\n\tif (result) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,\n\t\t\t\t    event_data->filename, \"collect_data\",\n\t\t\t\t    \"failed\", result, 0);\n\t\treturn result;\n\t}\n\tcur_digest = hash.hdr.digest;\n\tcur_digestsize = hash.hdr.length;\nout:\n\treturn ima_eventdigest_init_common(cur_digest, cur_digestsize,\n\t\t\t\t\t   HASH_ALGO__LAST, field_data);\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_eventdigest_init_common",
          "args": [
            "cur_digest",
            "cur_digestsize",
            "HASH_ALGO__LAST",
            "field_data"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "ima_eventdigest_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "223-257",
          "snippet": "static int ima_eventdigest_init_common(u8 *digest, u32 digestsize, u8 hash_algo,\n\t\t\t\t       struct ima_field_data *field_data)\n{\n\t/*\n\t * digest formats:\n\t *  - DATA_FMT_DIGEST: digest\n\t *  - DATA_FMT_DIGEST_WITH_ALGO: [<hash algo>] + ':' + '\\0' + digest,\n\t *    where <hash algo> is provided if the hash algoritm is not\n\t *    SHA1 or MD5\n\t */\n\tu8 buffer[CRYPTO_MAX_ALG_NAME + 2 + IMA_MAX_DIGEST_SIZE] = { 0 };\n\tenum data_formats fmt = DATA_FMT_DIGEST;\n\tu32 offset = 0;\n\n\tif (hash_algo < HASH_ALGO__LAST) {\n\t\tfmt = DATA_FMT_DIGEST_WITH_ALGO;\n\t\toffset += snprintf(buffer, CRYPTO_MAX_ALG_NAME + 1, \"%s\",\n\t\t\t\t   hash_algo_name[hash_algo]);\n\t\tbuffer[offset] = ':';\n\t\toffset += 2;\n\t}\n\n\tif (digest)\n\t\tmemcpy(buffer + offset, digest, digestsize);\n\telse\n\t\t/*\n\t\t * If digest is NULL, the event being recorded is a violation.\n\t\t * Make room for the digest by increasing the offset of\n\t\t * IMA_DIGEST_SIZE.\n\t\t */\n\t\toffset += IMA_DIGEST_SIZE;\n\n\treturn ima_write_template_field_data(buffer, offset + digestsize,\n\t\t\t\t\t     fmt, field_data);\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic int ima_eventdigest_init_common(u8 *digest, u32 digestsize, u8 hash_algo,\n\t\t\t\t       struct ima_field_data *field_data)\n{\n\t/*\n\t * digest formats:\n\t *  - DATA_FMT_DIGEST: digest\n\t *  - DATA_FMT_DIGEST_WITH_ALGO: [<hash algo>] + ':' + '\\0' + digest,\n\t *    where <hash algo> is provided if the hash algoritm is not\n\t *    SHA1 or MD5\n\t */\n\tu8 buffer[CRYPTO_MAX_ALG_NAME + 2 + IMA_MAX_DIGEST_SIZE] = { 0 };\n\tenum data_formats fmt = DATA_FMT_DIGEST;\n\tu32 offset = 0;\n\n\tif (hash_algo < HASH_ALGO__LAST) {\n\t\tfmt = DATA_FMT_DIGEST_WITH_ALGO;\n\t\toffset += snprintf(buffer, CRYPTO_MAX_ALG_NAME + 1, \"%s\",\n\t\t\t\t   hash_algo_name[hash_algo]);\n\t\tbuffer[offset] = ':';\n\t\toffset += 2;\n\t}\n\n\tif (digest)\n\t\tmemcpy(buffer + offset, digest, digestsize);\n\telse\n\t\t/*\n\t\t * If digest is NULL, the event being recorded is a violation.\n\t\t * Make room for the digest by increasing the offset of\n\t\t * IMA_DIGEST_SIZE.\n\t\t */\n\t\toffset += IMA_DIGEST_SIZE;\n\n\treturn ima_write_template_field_data(buffer, offset + digestsize,\n\t\t\t\t\t     fmt, field_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "integrity_audit_msg",
          "args": [
            "AUDIT_INTEGRITY_DATA",
            "inode",
            "event_data->filename",
            "\"collect_data\"",
            "\"failed\"",
            "result",
            "0"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "183-188",
          "snippet": "static inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct integrity_iint_cache *integrity_iint_find(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode);\n\nstatic inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_calc_file_hash",
          "args": [
            "event_data->file",
            "&hash.hdr"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "ima_calc_file_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "417-441",
          "snippet": "int ima_calc_file_hash(struct file *file, struct ima_digest_data *hash)\n{\n\tloff_t i_size;\n\tint rc;\n\n\t/*\n\t * For consistency, fail file's opened with the O_DIRECT flag on\n\t * filesystems mounted with/without DAX option.\n\t */\n\tif (file->f_flags & O_DIRECT) {\n\t\thash->length = hash_digest_size[ima_hash_algo];\n\t\thash->algo = ima_hash_algo;\n\t\treturn -EINVAL;\n\t}\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (ima_ahash_minsize && i_size >= ima_ahash_minsize) {\n\t\trc = ima_calc_file_ahash(file, hash);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\treturn ima_calc_file_shash(file, hash);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long ima_ahash_minsize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic unsigned long ima_ahash_minsize;\n\nint ima_calc_file_hash(struct file *file, struct ima_digest_data *hash)\n{\n\tloff_t i_size;\n\tint rc;\n\n\t/*\n\t * For consistency, fail file's opened with the O_DIRECT flag on\n\t * filesystems mounted with/without DAX option.\n\t */\n\tif (file->f_flags & O_DIRECT) {\n\t\thash->length = hash_digest_size[ima_hash_algo];\n\t\thash->algo = ima_hash_algo;\n\t\treturn -EINVAL;\n\t}\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (ima_ahash_minsize && i_size >= ima_ahash_minsize) {\n\t\trc = ima_calc_file_ahash(file, hash);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\treturn ima_calc_file_shash(file, hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_template_hash_algo_allowed",
          "args": [
            "ima_hash_algo"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "ima_template_hash_algo_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "18-24",
          "snippet": "static bool ima_template_hash_algo_allowed(u8 algo)\n{\n\tif (algo == HASH_ALGO_SHA1 || algo == HASH_ALGO_MD5)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic bool ima_template_hash_algo_allowed(u8 algo)\n{\n\tif (algo == HASH_ALGO_SHA1 || algo == HASH_ALGO_MD5)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "event_data->file"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hash",
            "0",
            "sizeof(hash)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nint ima_eventdigest_init(struct ima_event_data *event_data,\n\t\t\t struct ima_field_data *field_data)\n{\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[IMA_MAX_DIGEST_SIZE];\n\t} hash;\n\tu8 *cur_digest = NULL;\n\tu32 cur_digestsize = 0;\n\tstruct inode *inode;\n\tint result;\n\n\tmemset(&hash, 0, sizeof(hash));\n\n\tif (event_data->violation)\t/* recording a violation. */\n\t\tgoto out;\n\n\tif (ima_template_hash_algo_allowed(event_data->iint->ima_hash->algo)) {\n\t\tcur_digest = event_data->iint->ima_hash->digest;\n\t\tcur_digestsize = event_data->iint->ima_hash->length;\n\t\tgoto out;\n\t}\n\n\tif (!event_data->file)\t/* missing info to re-calculate the digest */\n\t\treturn -EINVAL;\n\n\tinode = file_inode(event_data->file);\n\thash.hdr.algo = ima_template_hash_algo_allowed(ima_hash_algo) ?\n\t    ima_hash_algo : HASH_ALGO_SHA1;\n\tresult = ima_calc_file_hash(event_data->file, &hash.hdr);\n\tif (result) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,\n\t\t\t\t    event_data->filename, \"collect_data\",\n\t\t\t\t    \"failed\", result, 0);\n\t\treturn result;\n\t}\n\tcur_digest = hash.hdr.digest;\n\tcur_digestsize = hash.hdr.length;\nout:\n\treturn ima_eventdigest_init_common(cur_digest, cur_digestsize,\n\t\t\t\t\t   HASH_ALGO__LAST, field_data);\n}"
  },
  {
    "function_name": "ima_eventdigest_init_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "223-257",
    "snippet": "static int ima_eventdigest_init_common(u8 *digest, u32 digestsize, u8 hash_algo,\n\t\t\t\t       struct ima_field_data *field_data)\n{\n\t/*\n\t * digest formats:\n\t *  - DATA_FMT_DIGEST: digest\n\t *  - DATA_FMT_DIGEST_WITH_ALGO: [<hash algo>] + ':' + '\\0' + digest,\n\t *    where <hash algo> is provided if the hash algoritm is not\n\t *    SHA1 or MD5\n\t */\n\tu8 buffer[CRYPTO_MAX_ALG_NAME + 2 + IMA_MAX_DIGEST_SIZE] = { 0 };\n\tenum data_formats fmt = DATA_FMT_DIGEST;\n\tu32 offset = 0;\n\n\tif (hash_algo < HASH_ALGO__LAST) {\n\t\tfmt = DATA_FMT_DIGEST_WITH_ALGO;\n\t\toffset += snprintf(buffer, CRYPTO_MAX_ALG_NAME + 1, \"%s\",\n\t\t\t\t   hash_algo_name[hash_algo]);\n\t\tbuffer[offset] = ':';\n\t\toffset += 2;\n\t}\n\n\tif (digest)\n\t\tmemcpy(buffer + offset, digest, digestsize);\n\telse\n\t\t/*\n\t\t * If digest is NULL, the event being recorded is a violation.\n\t\t * Make room for the digest by increasing the offset of\n\t\t * IMA_DIGEST_SIZE.\n\t\t */\n\t\toffset += IMA_DIGEST_SIZE;\n\n\treturn ima_write_template_field_data(buffer, offset + digestsize,\n\t\t\t\t\t     fmt, field_data);\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_write_template_field_data",
          "args": [
            "buffer",
            "offset + digestsize",
            "fmt",
            "field_data"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "ima_write_template_field_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "33-65",
          "snippet": "static int ima_write_template_field_data(const void *data, const u32 datalen,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf, *buf_ptr;\n\tu32 buflen = datalen;\n\n\tif (datafmt == DATA_FMT_STRING)\n\t\tbuflen = datalen + 1;\n\n\tbuf = kzalloc(buflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, data, datalen);\n\n\t/*\n\t * Replace all space characters with underscore for event names and\n\t * strings. This avoid that, during the parsing of a measurements list,\n\t * filenames with spaces or that end with the suffix ' (deleted)' are\n\t * split into multiple template fields (the space is the delimitator\n\t * character for measurements lists in ASCII format).\n\t */\n\tif (datafmt == DATA_FMT_STRING) {\n\t\tfor (buf_ptr = buf; buf_ptr - buf < datalen; buf_ptr++)\n\t\t\tif (*buf_ptr == ' ')\n\t\t\t\t*buf_ptr = '_';\n\t}\n\n\tfield_data->data = buf;\n\tfield_data->len = buflen;\n\treturn 0;\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic int ima_write_template_field_data(const void *data, const u32 datalen,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf, *buf_ptr;\n\tu32 buflen = datalen;\n\n\tif (datafmt == DATA_FMT_STRING)\n\t\tbuflen = datalen + 1;\n\n\tbuf = kzalloc(buflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, data, datalen);\n\n\t/*\n\t * Replace all space characters with underscore for event names and\n\t * strings. This avoid that, during the parsing of a measurements list,\n\t * filenames with spaces or that end with the suffix ' (deleted)' are\n\t * split into multiple template fields (the space is the delimitator\n\t * character for measurements lists in ASCII format).\n\t */\n\tif (datafmt == DATA_FMT_STRING) {\n\t\tfor (buf_ptr = buf; buf_ptr - buf < datalen; buf_ptr++)\n\t\t\tif (*buf_ptr == ' ')\n\t\t\t\t*buf_ptr = '_';\n\t}\n\n\tfield_data->data = buf;\n\tfield_data->len = buflen;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer + offset",
            "digest",
            "digestsize"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "CRYPTO_MAX_ALG_NAME + 1",
            "\"%s\"",
            "hash_algo_name[hash_algo]"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic int ima_eventdigest_init_common(u8 *digest, u32 digestsize, u8 hash_algo,\n\t\t\t\t       struct ima_field_data *field_data)\n{\n\t/*\n\t * digest formats:\n\t *  - DATA_FMT_DIGEST: digest\n\t *  - DATA_FMT_DIGEST_WITH_ALGO: [<hash algo>] + ':' + '\\0' + digest,\n\t *    where <hash algo> is provided if the hash algoritm is not\n\t *    SHA1 or MD5\n\t */\n\tu8 buffer[CRYPTO_MAX_ALG_NAME + 2 + IMA_MAX_DIGEST_SIZE] = { 0 };\n\tenum data_formats fmt = DATA_FMT_DIGEST;\n\tu32 offset = 0;\n\n\tif (hash_algo < HASH_ALGO__LAST) {\n\t\tfmt = DATA_FMT_DIGEST_WITH_ALGO;\n\t\toffset += snprintf(buffer, CRYPTO_MAX_ALG_NAME + 1, \"%s\",\n\t\t\t\t   hash_algo_name[hash_algo]);\n\t\tbuffer[offset] = ':';\n\t\toffset += 2;\n\t}\n\n\tif (digest)\n\t\tmemcpy(buffer + offset, digest, digestsize);\n\telse\n\t\t/*\n\t\t * If digest is NULL, the event being recorded is a violation.\n\t\t * Make room for the digest by increasing the offset of\n\t\t * IMA_DIGEST_SIZE.\n\t\t */\n\t\toffset += IMA_DIGEST_SIZE;\n\n\treturn ima_write_template_field_data(buffer, offset + digestsize,\n\t\t\t\t\t     fmt, field_data);\n}"
  },
  {
    "function_name": "ima_parse_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "176-221",
    "snippet": "int ima_parse_buf(void *bufstartp, void *bufendp, void **bufcurp,\n\t\t  int maxfields, struct ima_field_data *fields, int *curfields,\n\t\t  unsigned long *len_mask, int enforce_mask, char *bufname)\n{\n\tvoid *bufp = bufstartp;\n\tint i;\n\n\tfor (i = 0; i < maxfields; i++) {\n\t\tif (len_mask == NULL || !test_bit(i, len_mask)) {\n\t\t\tif (bufp > (bufendp - sizeof(u32)))\n\t\t\t\tbreak;\n\n\t\t\tfields[i].len = *(u32 *)bufp;\n\t\t\tif (ima_canonical_fmt)\n\t\t\t\tfields[i].len = le32_to_cpu(fields[i].len);\n\n\t\t\tbufp += sizeof(u32);\n\t\t}\n\n\t\tif (bufp > (bufendp - fields[i].len))\n\t\t\tbreak;\n\n\t\tfields[i].data = bufp;\n\t\tbufp += fields[i].len;\n\t}\n\n\tif ((enforce_mask & ENFORCE_FIELDS) && i != maxfields) {\n\t\tpr_err(\"%s: nr of fields mismatch: expected: %d, current: %d\\n\",\n\t\t       bufname, maxfields, i);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((enforce_mask & ENFORCE_BUFEND) && bufp != bufendp) {\n\t\tpr_err(\"%s: buf end mismatch: expected: %p, current: %p\\n\",\n\t\t       bufname, bufendp, bufp);\n\t\treturn -EINVAL;\n\t}\n\n\tif (curfields)\n\t\t*curfields = i;\n\n\tif (bufcurp)\n\t\t*bufcurp = bufp;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: buf end mismatch: expected: %p, current: %p\\n\"",
            "bufname",
            "bufendp",
            "bufp"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: nr of fields mismatch: expected: %d, current: %d\\n\"",
            "bufname",
            "maxfields",
            "i"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fields[i].len"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "len_mask"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nint ima_parse_buf(void *bufstartp, void *bufendp, void **bufcurp,\n\t\t  int maxfields, struct ima_field_data *fields, int *curfields,\n\t\t  unsigned long *len_mask, int enforce_mask, char *bufname)\n{\n\tvoid *bufp = bufstartp;\n\tint i;\n\n\tfor (i = 0; i < maxfields; i++) {\n\t\tif (len_mask == NULL || !test_bit(i, len_mask)) {\n\t\t\tif (bufp > (bufendp - sizeof(u32)))\n\t\t\t\tbreak;\n\n\t\t\tfields[i].len = *(u32 *)bufp;\n\t\t\tif (ima_canonical_fmt)\n\t\t\t\tfields[i].len = le32_to_cpu(fields[i].len);\n\n\t\t\tbufp += sizeof(u32);\n\t\t}\n\n\t\tif (bufp > (bufendp - fields[i].len))\n\t\t\tbreak;\n\n\t\tfields[i].data = bufp;\n\t\tbufp += fields[i].len;\n\t}\n\n\tif ((enforce_mask & ENFORCE_FIELDS) && i != maxfields) {\n\t\tpr_err(\"%s: nr of fields mismatch: expected: %d, current: %d\\n\",\n\t\t       bufname, maxfields, i);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((enforce_mask & ENFORCE_BUFEND) && bufp != bufendp) {\n\t\tpr_err(\"%s: buf end mismatch: expected: %p, current: %p\\n\",\n\t\t       bufname, bufendp, bufp);\n\t\treturn -EINVAL;\n\t}\n\n\tif (curfields)\n\t\t*curfields = i;\n\n\tif (bufcurp)\n\t\t*bufcurp = bufp;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ima_show_template_sig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "156-160",
    "snippet": "void ima_show_template_sig(struct seq_file *m, enum ima_show_type show,\n\t\t\t   struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_HEX, field_data);\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_show_template_field_data",
          "args": [
            "m",
            "show",
            "DATA_FMT_HEX",
            "field_data"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "ima_show_template_field_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "118-135",
          "snippet": "static void ima_show_template_field_data(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tswitch (show) {\n\tcase IMA_SHOW_ASCII:\n\t\tima_show_template_data_ascii(m, show, datafmt, field_data);\n\t\tbreak;\n\tcase IMA_SHOW_BINARY:\n\tcase IMA_SHOW_BINARY_NO_FIELD_LEN:\n\tcase IMA_SHOW_BINARY_OLD_STRING_FMT:\n\t\tima_show_template_data_binary(m, show, datafmt, field_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic void ima_show_template_field_data(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tswitch (show) {\n\tcase IMA_SHOW_ASCII:\n\t\tima_show_template_data_ascii(m, show, datafmt, field_data);\n\t\tbreak;\n\tcase IMA_SHOW_BINARY:\n\tcase IMA_SHOW_BINARY_NO_FIELD_LEN:\n\tcase IMA_SHOW_BINARY_OLD_STRING_FMT:\n\t\tima_show_template_data_binary(m, show, datafmt, field_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nvoid ima_show_template_sig(struct seq_file *m, enum ima_show_type show,\n\t\t\t   struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_HEX, field_data);\n}"
  },
  {
    "function_name": "ima_show_template_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "150-154",
    "snippet": "void ima_show_template_string(struct seq_file *m, enum ima_show_type show,\n\t\t\t      struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_STRING, field_data);\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_show_template_field_data",
          "args": [
            "m",
            "show",
            "DATA_FMT_STRING",
            "field_data"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "ima_show_template_field_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "118-135",
          "snippet": "static void ima_show_template_field_data(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tswitch (show) {\n\tcase IMA_SHOW_ASCII:\n\t\tima_show_template_data_ascii(m, show, datafmt, field_data);\n\t\tbreak;\n\tcase IMA_SHOW_BINARY:\n\tcase IMA_SHOW_BINARY_NO_FIELD_LEN:\n\tcase IMA_SHOW_BINARY_OLD_STRING_FMT:\n\t\tima_show_template_data_binary(m, show, datafmt, field_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic void ima_show_template_field_data(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tswitch (show) {\n\tcase IMA_SHOW_ASCII:\n\t\tima_show_template_data_ascii(m, show, datafmt, field_data);\n\t\tbreak;\n\tcase IMA_SHOW_BINARY:\n\tcase IMA_SHOW_BINARY_NO_FIELD_LEN:\n\tcase IMA_SHOW_BINARY_OLD_STRING_FMT:\n\t\tima_show_template_data_binary(m, show, datafmt, field_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nvoid ima_show_template_string(struct seq_file *m, enum ima_show_type show,\n\t\t\t      struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_STRING, field_data);\n}"
  },
  {
    "function_name": "ima_show_template_digest_ng",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "143-148",
    "snippet": "void ima_show_template_digest_ng(struct seq_file *m, enum ima_show_type show,\n\t\t\t\t struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_DIGEST_WITH_ALGO,\n\t\t\t\t     field_data);\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_show_template_field_data",
          "args": [
            "m",
            "show",
            "DATA_FMT_DIGEST_WITH_ALGO",
            "field_data"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ima_show_template_field_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "118-135",
          "snippet": "static void ima_show_template_field_data(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tswitch (show) {\n\tcase IMA_SHOW_ASCII:\n\t\tima_show_template_data_ascii(m, show, datafmt, field_data);\n\t\tbreak;\n\tcase IMA_SHOW_BINARY:\n\tcase IMA_SHOW_BINARY_NO_FIELD_LEN:\n\tcase IMA_SHOW_BINARY_OLD_STRING_FMT:\n\t\tima_show_template_data_binary(m, show, datafmt, field_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic void ima_show_template_field_data(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tswitch (show) {\n\tcase IMA_SHOW_ASCII:\n\t\tima_show_template_data_ascii(m, show, datafmt, field_data);\n\t\tbreak;\n\tcase IMA_SHOW_BINARY:\n\tcase IMA_SHOW_BINARY_NO_FIELD_LEN:\n\tcase IMA_SHOW_BINARY_OLD_STRING_FMT:\n\t\tima_show_template_data_binary(m, show, datafmt, field_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nvoid ima_show_template_digest_ng(struct seq_file *m, enum ima_show_type show,\n\t\t\t\t struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_DIGEST_WITH_ALGO,\n\t\t\t\t     field_data);\n}"
  },
  {
    "function_name": "ima_show_template_digest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "137-141",
    "snippet": "void ima_show_template_digest(struct seq_file *m, enum ima_show_type show,\n\t\t\t      struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_DIGEST, field_data);\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_show_template_field_data",
          "args": [
            "m",
            "show",
            "DATA_FMT_DIGEST",
            "field_data"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "ima_show_template_field_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "118-135",
          "snippet": "static void ima_show_template_field_data(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tswitch (show) {\n\tcase IMA_SHOW_ASCII:\n\t\tima_show_template_data_ascii(m, show, datafmt, field_data);\n\t\tbreak;\n\tcase IMA_SHOW_BINARY:\n\tcase IMA_SHOW_BINARY_NO_FIELD_LEN:\n\tcase IMA_SHOW_BINARY_OLD_STRING_FMT:\n\t\tima_show_template_data_binary(m, show, datafmt, field_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic void ima_show_template_field_data(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tswitch (show) {\n\tcase IMA_SHOW_ASCII:\n\t\tima_show_template_data_ascii(m, show, datafmt, field_data);\n\t\tbreak;\n\tcase IMA_SHOW_BINARY:\n\tcase IMA_SHOW_BINARY_NO_FIELD_LEN:\n\tcase IMA_SHOW_BINARY_OLD_STRING_FMT:\n\t\tima_show_template_data_binary(m, show, datafmt, field_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nvoid ima_show_template_digest(struct seq_file *m, enum ima_show_type show,\n\t\t\t      struct ima_field_data *field_data)\n{\n\tima_show_template_field_data(m, show, DATA_FMT_DIGEST, field_data);\n}"
  },
  {
    "function_name": "ima_show_template_field_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "118-135",
    "snippet": "static void ima_show_template_field_data(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tswitch (show) {\n\tcase IMA_SHOW_ASCII:\n\t\tima_show_template_data_ascii(m, show, datafmt, field_data);\n\t\tbreak;\n\tcase IMA_SHOW_BINARY:\n\tcase IMA_SHOW_BINARY_NO_FIELD_LEN:\n\tcase IMA_SHOW_BINARY_OLD_STRING_FMT:\n\t\tima_show_template_data_binary(m, show, datafmt, field_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_show_template_data_binary",
          "args": [
            "m",
            "show",
            "datafmt",
            "field_data"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "ima_show_template_data_binary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "98-116",
          "snippet": "static void ima_show_template_data_binary(struct seq_file *m,\n\t\t\t\t\t  enum ima_show_type show,\n\t\t\t\t\t  enum data_formats datafmt,\n\t\t\t\t\t  struct ima_field_data *field_data)\n{\n\tu32 len = (show == IMA_SHOW_BINARY_OLD_STRING_FMT) ?\n\t    strlen(field_data->data) : field_data->len;\n\n\tif (show != IMA_SHOW_BINARY_NO_FIELD_LEN) {\n\t\tu32 field_len = !ima_canonical_fmt ? len : cpu_to_le32(len);\n\n\t\tima_putc(m, &field_len, sizeof(field_len));\n\t}\n\n\tif (!len)\n\t\treturn;\n\n\tima_putc(m, field_data->data, len);\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic void ima_show_template_data_binary(struct seq_file *m,\n\t\t\t\t\t  enum ima_show_type show,\n\t\t\t\t\t  enum data_formats datafmt,\n\t\t\t\t\t  struct ima_field_data *field_data)\n{\n\tu32 len = (show == IMA_SHOW_BINARY_OLD_STRING_FMT) ?\n\t    strlen(field_data->data) : field_data->len;\n\n\tif (show != IMA_SHOW_BINARY_NO_FIELD_LEN) {\n\t\tu32 field_len = !ima_canonical_fmt ? len : cpu_to_le32(len);\n\n\t\tima_putc(m, &field_len, sizeof(field_len));\n\t}\n\n\tif (!len)\n\t\treturn;\n\n\tima_putc(m, field_data->data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_show_template_data_ascii",
          "args": [
            "m",
            "show",
            "datafmt",
            "field_data"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "ima_show_template_data_ascii",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "67-96",
          "snippet": "static void ima_show_template_data_ascii(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf_ptr = field_data->data;\n\tu32 buflen = field_data->len;\n\n\tswitch (datafmt) {\n\tcase DATA_FMT_DIGEST_WITH_ALGO:\n\t\tbuf_ptr = strnchr(field_data->data, buflen, ':');\n\t\tif (buf_ptr != field_data->data)\n\t\t\tseq_printf(m, \"%s\", field_data->data);\n\n\t\t/* skip ':' and '\\0' */\n\t\tbuf_ptr += 2;\n\t\tbuflen -= buf_ptr - field_data->data;\n\tcase DATA_FMT_DIGEST:\n\tcase DATA_FMT_HEX:\n\t\tif (!buflen)\n\t\t\tbreak;\n\t\tima_print_digest(m, buf_ptr, buflen);\n\t\tbreak;\n\tcase DATA_FMT_STRING:\n\t\tseq_printf(m, \"%s\", buf_ptr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic void ima_show_template_data_ascii(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf_ptr = field_data->data;\n\tu32 buflen = field_data->len;\n\n\tswitch (datafmt) {\n\tcase DATA_FMT_DIGEST_WITH_ALGO:\n\t\tbuf_ptr = strnchr(field_data->data, buflen, ':');\n\t\tif (buf_ptr != field_data->data)\n\t\t\tseq_printf(m, \"%s\", field_data->data);\n\n\t\t/* skip ':' and '\\0' */\n\t\tbuf_ptr += 2;\n\t\tbuflen -= buf_ptr - field_data->data;\n\tcase DATA_FMT_DIGEST:\n\tcase DATA_FMT_HEX:\n\t\tif (!buflen)\n\t\t\tbreak;\n\t\tima_print_digest(m, buf_ptr, buflen);\n\t\tbreak;\n\tcase DATA_FMT_STRING:\n\t\tseq_printf(m, \"%s\", buf_ptr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic void ima_show_template_field_data(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tswitch (show) {\n\tcase IMA_SHOW_ASCII:\n\t\tima_show_template_data_ascii(m, show, datafmt, field_data);\n\t\tbreak;\n\tcase IMA_SHOW_BINARY:\n\tcase IMA_SHOW_BINARY_NO_FIELD_LEN:\n\tcase IMA_SHOW_BINARY_OLD_STRING_FMT:\n\t\tima_show_template_data_binary(m, show, datafmt, field_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "ima_show_template_data_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "98-116",
    "snippet": "static void ima_show_template_data_binary(struct seq_file *m,\n\t\t\t\t\t  enum ima_show_type show,\n\t\t\t\t\t  enum data_formats datafmt,\n\t\t\t\t\t  struct ima_field_data *field_data)\n{\n\tu32 len = (show == IMA_SHOW_BINARY_OLD_STRING_FMT) ?\n\t    strlen(field_data->data) : field_data->len;\n\n\tif (show != IMA_SHOW_BINARY_NO_FIELD_LEN) {\n\t\tu32 field_len = !ima_canonical_fmt ? len : cpu_to_le32(len);\n\n\t\tima_putc(m, &field_len, sizeof(field_len));\n\t}\n\n\tif (!len)\n\t\treturn;\n\n\tima_putc(m, field_data->data, len);\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_putc",
          "args": [
            "m",
            "field_data->data",
            "len"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "ima_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
          "lines": "115-119",
          "snippet": "void ima_putc(struct seq_file *m, void *data, int datalen)\n{\n\twhile (datalen--)\n\t\tseq_putc(m, *(char *)data++);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/parser.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rculist.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nvoid ima_putc(struct seq_file *m, void *data, int datalen)\n{\n\twhile (datalen--)\n\t\tseq_putc(m, *(char *)data++);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "field_data->data"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic void ima_show_template_data_binary(struct seq_file *m,\n\t\t\t\t\t  enum ima_show_type show,\n\t\t\t\t\t  enum data_formats datafmt,\n\t\t\t\t\t  struct ima_field_data *field_data)\n{\n\tu32 len = (show == IMA_SHOW_BINARY_OLD_STRING_FMT) ?\n\t    strlen(field_data->data) : field_data->len;\n\n\tif (show != IMA_SHOW_BINARY_NO_FIELD_LEN) {\n\t\tu32 field_len = !ima_canonical_fmt ? len : cpu_to_le32(len);\n\n\t\tima_putc(m, &field_len, sizeof(field_len));\n\t}\n\n\tif (!len)\n\t\treturn;\n\n\tima_putc(m, field_data->data, len);\n}"
  },
  {
    "function_name": "ima_show_template_data_ascii",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "67-96",
    "snippet": "static void ima_show_template_data_ascii(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf_ptr = field_data->data;\n\tu32 buflen = field_data->len;\n\n\tswitch (datafmt) {\n\tcase DATA_FMT_DIGEST_WITH_ALGO:\n\t\tbuf_ptr = strnchr(field_data->data, buflen, ':');\n\t\tif (buf_ptr != field_data->data)\n\t\t\tseq_printf(m, \"%s\", field_data->data);\n\n\t\t/* skip ':' and '\\0' */\n\t\tbuf_ptr += 2;\n\t\tbuflen -= buf_ptr - field_data->data;\n\tcase DATA_FMT_DIGEST:\n\tcase DATA_FMT_HEX:\n\t\tif (!buflen)\n\t\t\tbreak;\n\t\tima_print_digest(m, buf_ptr, buflen);\n\t\tbreak;\n\tcase DATA_FMT_STRING:\n\t\tseq_printf(m, \"%s\", buf_ptr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\"",
            "buf_ptr"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_print_digest",
          "args": [
            "m",
            "buf_ptr",
            "buflen"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "ima_print_digest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
          "lines": "209-215",
          "snippet": "void ima_print_digest(struct seq_file *m, u8 *digest, u32 size)\n{\n\tu32 i;\n\n\tfor (i = 0; i < size; i++)\n\t\tseq_printf(m, \"%02x\", *(digest + i));\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/parser.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rculist.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nvoid ima_print_digest(struct seq_file *m, u8 *digest, u32 size)\n{\n\tu32 i;\n\n\tfor (i = 0; i < size; i++)\n\t\tseq_printf(m, \"%02x\", *(digest + i));\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\"",
            "field_data->data"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnchr",
          "args": [
            "field_data->data",
            "buflen",
            "':'"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic void ima_show_template_data_ascii(struct seq_file *m,\n\t\t\t\t\t enum ima_show_type show,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf_ptr = field_data->data;\n\tu32 buflen = field_data->len;\n\n\tswitch (datafmt) {\n\tcase DATA_FMT_DIGEST_WITH_ALGO:\n\t\tbuf_ptr = strnchr(field_data->data, buflen, ':');\n\t\tif (buf_ptr != field_data->data)\n\t\t\tseq_printf(m, \"%s\", field_data->data);\n\n\t\t/* skip ':' and '\\0' */\n\t\tbuf_ptr += 2;\n\t\tbuflen -= buf_ptr - field_data->data;\n\tcase DATA_FMT_DIGEST:\n\tcase DATA_FMT_HEX:\n\t\tif (!buflen)\n\t\t\tbreak;\n\t\tima_print_digest(m, buf_ptr, buflen);\n\t\tbreak;\n\tcase DATA_FMT_STRING:\n\t\tseq_printf(m, \"%s\", buf_ptr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "ima_write_template_field_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "33-65",
    "snippet": "static int ima_write_template_field_data(const void *data, const u32 datalen,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf, *buf_ptr;\n\tu32 buflen = datalen;\n\n\tif (datafmt == DATA_FMT_STRING)\n\t\tbuflen = datalen + 1;\n\n\tbuf = kzalloc(buflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, data, datalen);\n\n\t/*\n\t * Replace all space characters with underscore for event names and\n\t * strings. This avoid that, during the parsing of a measurements list,\n\t * filenames with spaces or that end with the suffix ' (deleted)' are\n\t * split into multiple template fields (the space is the delimitator\n\t * character for measurements lists in ASCII format).\n\t */\n\tif (datafmt == DATA_FMT_STRING) {\n\t\tfor (buf_ptr = buf; buf_ptr - buf < datalen; buf_ptr++)\n\t\t\tif (*buf_ptr == ' ')\n\t\t\t\t*buf_ptr = '_';\n\t}\n\n\tfield_data->data = buf;\n\tfield_data->len = buflen;\n\treturn 0;\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "data",
            "datalen"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "buflen",
            "GFP_KERNEL"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic int ima_write_template_field_data(const void *data, const u32 datalen,\n\t\t\t\t\t enum data_formats datafmt,\n\t\t\t\t\t struct ima_field_data *field_data)\n{\n\tu8 *buf, *buf_ptr;\n\tu32 buflen = datalen;\n\n\tif (datafmt == DATA_FMT_STRING)\n\t\tbuflen = datalen + 1;\n\n\tbuf = kzalloc(buflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, data, datalen);\n\n\t/*\n\t * Replace all space characters with underscore for event names and\n\t * strings. This avoid that, during the parsing of a measurements list,\n\t * filenames with spaces or that end with the suffix ' (deleted)' are\n\t * split into multiple template fields (the space is the delimitator\n\t * character for measurements lists in ASCII format).\n\t */\n\tif (datafmt == DATA_FMT_STRING) {\n\t\tfor (buf_ptr = buf; buf_ptr - buf < datalen; buf_ptr++)\n\t\t\tif (*buf_ptr == ' ')\n\t\t\t\t*buf_ptr = '_';\n\t}\n\n\tfield_data->data = buf;\n\tfield_data->len = buflen;\n\treturn 0;\n}"
  },
  {
    "function_name": "ima_template_hash_algo_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
    "lines": "18-24",
    "snippet": "static bool ima_template_hash_algo_allowed(u8 algo)\n{\n\tif (algo == HASH_ALGO_SHA1 || algo == HASH_ALGO_MD5)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"ima_template_lib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n\nstatic bool ima_template_hash_algo_allowed(u8 algo)\n{\n\tif (algo == HASH_ALGO_SHA1 || algo == HASH_ALGO_MD5)\n\t\treturn true;\n\n\treturn false;\n}"
  }
]