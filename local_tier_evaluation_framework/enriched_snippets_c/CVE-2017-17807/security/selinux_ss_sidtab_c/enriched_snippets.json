[
  {
    "function_name": "sidtab_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "300-307",
    "snippet": "void sidtab_shutdown(struct sidtab *s)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\ts->shutdown = 1;\n\tspin_unlock_irqrestore(&s->lock, flags);\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&s->lock",
            "flags"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&s->lock",
            "flags"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid sidtab_shutdown(struct sidtab *s)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\ts->shutdown = 1;\n\tspin_unlock_irqrestore(&s->lock, flags);\n}"
  },
  {
    "function_name": "sidtab_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "285-298",
    "snippet": "void sidtab_set(struct sidtab *dst, struct sidtab *src)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&src->lock, flags);\n\tdst->htable = src->htable;\n\tdst->nel = src->nel;\n\tdst->next_sid = src->next_sid;\n\tdst->shutdown = 0;\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++)\n\t\tdst->cache[i] = NULL;\n\tspin_unlock_irqrestore(&src->lock, flags);\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&src->lock",
            "flags"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&src->lock",
            "flags"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid sidtab_set(struct sidtab *dst, struct sidtab *src)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&src->lock, flags);\n\tdst->htable = src->htable;\n\tdst->nel = src->nel;\n\tdst->next_sid = src->next_sid;\n\tdst->shutdown = 0;\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++)\n\t\tdst->cache[i] = NULL;\n\tspin_unlock_irqrestore(&src->lock, flags);\n}"
  },
  {
    "function_name": "sidtab_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "261-283",
    "snippet": "void sidtab_destroy(struct sidtab *s)\n{\n\tint i;\n\tstruct sidtab_node *cur, *temp;\n\n\tif (!s)\n\t\treturn;\n\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = s->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tcontext_destroy(&temp->context);\n\t\t\tkfree(temp);\n\t\t}\n\t\ts->htable[i] = NULL;\n\t}\n\tkfree(s->htable);\n\ts->htable = NULL;\n\ts->nel = 0;\n\ts->next_sid = 1;\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s->htable"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "temp"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_destroy",
          "args": [
            "&temp->context"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "context_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "142-149",
          "snippet": "static inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid sidtab_destroy(struct sidtab *s)\n{\n\tint i;\n\tstruct sidtab_node *cur, *temp;\n\n\tif (!s)\n\t\treturn;\n\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = s->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tcontext_destroy(&temp->context);\n\t\t\tkfree(temp);\n\t\t}\n\t\ts->htable[i] = NULL;\n\t}\n\tkfree(s->htable);\n\ts->htable = NULL;\n\ts->nel = 0;\n\ts->next_sid = 1;\n}"
  },
  {
    "function_name": "sidtab_hash_eval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "234-259",
    "snippet": "void sidtab_hash_eval(struct sidtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tstruct sidtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = h->htable[i];\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"%s:  %d entries and %d/%d buckets used, longest \"\n\t       \"chain length %d\\n\", tag, h->nel, slots_used, SIDTAB_SIZE,\n\t       max_chain_len);\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%s:  %d entries and %d/%d buckets used, longest \"\n\t       \"chain length %d\\n\"",
            "tag",
            "h->nel",
            "slots_used",
            "SIDTAB_SIZE",
            "max_chain_len"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid sidtab_hash_eval(struct sidtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tstruct sidtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = h->htable[i];\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"%s:  %d entries and %d/%d buckets used, longest \"\n\t       \"chain length %d\\n\", tag, h->nel, slots_used, SIDTAB_SIZE,\n\t       max_chain_len);\n}"
  },
  {
    "function_name": "sidtab_context_to_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "191-232",
    "snippet": "int sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&s->lock",
            "flags"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_insert",
          "args": [
            "s",
            "sid",
            "context"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "34-77",
          "snippet": "int sidtab_insert(struct sidtab *s, u32 sid, struct context *context)\n{\n\tint hvalue;\n\tstruct sidtab_node *prev, *cur, *newnode;\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\thvalue = SIDTAB_HASH(sid);\n\tprev = NULL;\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && sid == cur->sid)\n\t\treturn -EEXIST;\n\n\tnewnode = kmalloc(sizeof(*newnode), GFP_ATOMIC);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\n\tnewnode->sid = sid;\n\tif (context_cpy(&newnode->context, context)) {\n\t\tkfree(newnode);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\twmb();\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = s->htable[hvalue];\n\t\twmb();\n\t\ts->htable[hvalue] = newnode;\n\t}\n\n\ts->nel++;\n\tif (sid >= s->next_sid)\n\t\ts->next_sid = sid + 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_insert(struct sidtab *s, u32 sid, struct context *context)\n{\n\tint hvalue;\n\tstruct sidtab_node *prev, *cur, *newnode;\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\thvalue = SIDTAB_HASH(sid);\n\tprev = NULL;\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && sid == cur->sid)\n\t\treturn -EEXIST;\n\n\tnewnode = kmalloc(sizeof(*newnode), GFP_ATOMIC);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\n\tnewnode->sid = sid;\n\tif (context_cpy(&newnode->context, context)) {\n\t\tkfree(newnode);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\twmb();\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = s->htable[hvalue];\n\t\twmb();\n\t\ts->htable[hvalue] = newnode;\n\t}\n\n\ts->nel++;\n\tif (sid >= s->next_sid)\n\t\ts->next_sid = sid + 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\"",
            "context->str"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_search_context",
          "args": [
            "s",
            "context"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "155-172",
          "snippet": "static inline u32 sidtab_search_context(struct sidtab *s,\n\t\t\t\t\t\t  struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *cur;\n\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = s->htable[i];\n\t\twhile (cur) {\n\t\t\tif (context_cmp(&cur->context, context)) {\n\t\t\t\tsidtab_update_cache(s, cur, SIDTAB_CACHE_LEN - 1);\n\t\t\t\treturn cur->sid;\n\t\t\t}\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_context(struct sidtab *s,\n\t\t\t\t\t\t  struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *cur;\n\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = s->htable[i];\n\t\twhile (cur) {\n\t\t\tif (context_cmp(&cur->context, context)) {\n\t\t\t\tsidtab_update_cache(s, cur, SIDTAB_CACHE_LEN - 1);\n\t\t\t\treturn cur->sid;\n\t\t\t}\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&s->lock",
            "flags"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_search_cache",
          "args": [
            "s",
            "context"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}"
  },
  {
    "function_name": "sidtab_search_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "174-189",
    "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sidtab_update_cache",
          "args": [
            "s",
            "node",
            "i"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_update_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "144-153",
          "snippet": "static void sidtab_update_cache(struct sidtab *s, struct sidtab_node *n, int loc)\n{\n\tBUG_ON(loc >= SIDTAB_CACHE_LEN);\n\n\twhile (loc > 0) {\n\t\ts->cache[loc] = s->cache[loc - 1];\n\t\tloc--;\n\t}\n\ts->cache[0] = n;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void sidtab_update_cache(struct sidtab *s, struct sidtab_node *n, int loc)\n{\n\tBUG_ON(loc >= SIDTAB_CACHE_LEN);\n\n\twhile (loc > 0) {\n\t\ts->cache[loc] = s->cache[loc - 1];\n\t\tloc--;\n\t}\n\ts->cache[0] = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_cmp",
          "args": [
            "&node->context",
            "context"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "context_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "151-161",
          "snippet": "static inline int context_cmp(struct context *c1, struct context *c2)\n{\n\tif (c1->len && c2->len)\n\t\treturn (c1->len == c2->len && !strcmp(c1->str, c2->str));\n\tif (c1->len || c2->len)\n\t\treturn 0;\n\treturn ((c1->user == c2->user) &&\n\t\t(c1->role == c2->role) &&\n\t\t(c1->type == c2->type) &&\n\t\tmls_context_cmp(c1, c2));\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline int context_cmp(struct context *c1, struct context *c2)\n{\n\tif (c1->len && c2->len)\n\t\treturn (c1->len == c2->len && !strcmp(c1->str, c2->str));\n\tif (c1->len || c2->len)\n\t\treturn 0;\n\treturn ((c1->user == c2->user) &&\n\t\t(c1->role == c2->role) &&\n\t\t(c1->type == c2->type) &&\n\t\tmls_context_cmp(c1, c2));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!node"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sidtab_search_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "155-172",
    "snippet": "static inline u32 sidtab_search_context(struct sidtab *s,\n\t\t\t\t\t\t  struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *cur;\n\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = s->htable[i];\n\t\twhile (cur) {\n\t\t\tif (context_cmp(&cur->context, context)) {\n\t\t\t\tsidtab_update_cache(s, cur, SIDTAB_CACHE_LEN - 1);\n\t\t\t\treturn cur->sid;\n\t\t\t}\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sidtab_update_cache",
          "args": [
            "s",
            "cur",
            "SIDTAB_CACHE_LEN - 1"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_update_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "144-153",
          "snippet": "static void sidtab_update_cache(struct sidtab *s, struct sidtab_node *n, int loc)\n{\n\tBUG_ON(loc >= SIDTAB_CACHE_LEN);\n\n\twhile (loc > 0) {\n\t\ts->cache[loc] = s->cache[loc - 1];\n\t\tloc--;\n\t}\n\ts->cache[0] = n;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void sidtab_update_cache(struct sidtab *s, struct sidtab_node *n, int loc)\n{\n\tBUG_ON(loc >= SIDTAB_CACHE_LEN);\n\n\twhile (loc > 0) {\n\t\ts->cache[loc] = s->cache[loc - 1];\n\t\tloc--;\n\t}\n\ts->cache[0] = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_cmp",
          "args": [
            "&cur->context",
            "context"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "context_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "151-161",
          "snippet": "static inline int context_cmp(struct context *c1, struct context *c2)\n{\n\tif (c1->len && c2->len)\n\t\treturn (c1->len == c2->len && !strcmp(c1->str, c2->str));\n\tif (c1->len || c2->len)\n\t\treturn 0;\n\treturn ((c1->user == c2->user) &&\n\t\t(c1->role == c2->role) &&\n\t\t(c1->type == c2->type) &&\n\t\tmls_context_cmp(c1, c2));\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline int context_cmp(struct context *c1, struct context *c2)\n{\n\tif (c1->len && c2->len)\n\t\treturn (c1->len == c2->len && !strcmp(c1->str, c2->str));\n\tif (c1->len || c2->len)\n\t\treturn 0;\n\treturn ((c1->user == c2->user) &&\n\t\t(c1->role == c2->role) &&\n\t\t(c1->type == c2->type) &&\n\t\tmls_context_cmp(c1, c2));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_context(struct sidtab *s,\n\t\t\t\t\t\t  struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *cur;\n\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = s->htable[i];\n\t\twhile (cur) {\n\t\t\tif (context_cmp(&cur->context, context)) {\n\t\t\t\tsidtab_update_cache(s, cur, SIDTAB_CACHE_LEN - 1);\n\t\t\t\treturn cur->sid;\n\t\t\t}\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sidtab_update_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "144-153",
    "snippet": "static void sidtab_update_cache(struct sidtab *s, struct sidtab_node *n, int loc)\n{\n\tBUG_ON(loc >= SIDTAB_CACHE_LEN);\n\n\twhile (loc > 0) {\n\t\ts->cache[loc] = s->cache[loc - 1];\n\t\tloc--;\n\t}\n\ts->cache[0] = n;\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "loc >= SIDTAB_CACHE_LEN"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void sidtab_update_cache(struct sidtab *s, struct sidtab_node *n, int loc)\n{\n\tBUG_ON(loc >= SIDTAB_CACHE_LEN);\n\n\twhile (loc > 0) {\n\t\ts->cache[loc] = s->cache[loc - 1];\n\t\tloc--;\n\t}\n\ts->cache[0] = n;\n}"
  },
  {
    "function_name": "sidtab_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "119-142",
    "snippet": "int sidtab_map(struct sidtab *s,\n\t       int (*apply) (u32 sid,\n\t\t\t     struct context *context,\n\t\t\t     void *args),\n\t       void *args)\n{\n\tint i, rc = 0;\n\tstruct sidtab_node *cur;\n\n\tif (!s)\n\t\tgoto out;\n\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = s->htable[i];\n\t\twhile (cur) {\n\t\t\trc = apply(cur->sid, &cur->context, args);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply",
          "args": [
            "cur->sid",
            "&cur->context",
            "args"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_map(struct sidtab *s,\n\t       int (*apply) (u32 sid,\n\t\t\t     struct context *context,\n\t\t\t     void *args),\n\t       void *args)\n{\n\tint i, rc = 0;\n\tstruct sidtab_node *cur;\n\n\tif (!s)\n\t\tgoto out;\n\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = s->htable[i];\n\t\twhile (cur) {\n\t\t\trc = apply(cur->sid, &cur->context, args);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "sidtab_search_force",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "114-117",
    "snippet": "struct context *sidtab_search_force(struct sidtab *s, u32 sid)\n{\n\treturn sidtab_search_core(s, sid, 1);\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sidtab_search_core",
          "args": [
            "s",
            "sid",
            "1"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "79-107",
          "snippet": "static struct context *sidtab_search_core(struct sidtab *s, u32 sid, int force)\n{\n\tint hvalue;\n\tstruct sidtab_node *cur;\n\n\tif (!s)\n\t\treturn NULL;\n\n\thvalue = SIDTAB_HASH(sid);\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid)\n\t\tcur = cur->next;\n\n\tif (force && cur && sid == cur->sid && cur->context.len)\n\t\treturn &cur->context;\n\n\tif (!cur || sid != cur->sid || cur->context.len) {\n\t\t/* Remap invalid SIDs to the unlabeled SID. */\n\t\tsid = SECINITSID_UNLABELED;\n\t\thvalue = SIDTAB_HASH(sid);\n\t\tcur = s->htable[hvalue];\n\t\twhile (cur && sid > cur->sid)\n\t\t\tcur = cur->next;\n\t\tif (!cur || sid != cur->sid)\n\t\t\treturn NULL;\n\t}\n\n\treturn &cur->context;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct context *sidtab_search_core(struct sidtab *s, u32 sid, int force)\n{\n\tint hvalue;\n\tstruct sidtab_node *cur;\n\n\tif (!s)\n\t\treturn NULL;\n\n\thvalue = SIDTAB_HASH(sid);\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid)\n\t\tcur = cur->next;\n\n\tif (force && cur && sid == cur->sid && cur->context.len)\n\t\treturn &cur->context;\n\n\tif (!cur || sid != cur->sid || cur->context.len) {\n\t\t/* Remap invalid SIDs to the unlabeled SID. */\n\t\tsid = SECINITSID_UNLABELED;\n\t\thvalue = SIDTAB_HASH(sid);\n\t\tcur = s->htable[hvalue];\n\t\twhile (cur && sid > cur->sid)\n\t\t\tcur = cur->next;\n\t\tif (!cur || sid != cur->sid)\n\t\t\treturn NULL;\n\t}\n\n\treturn &cur->context;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct context *sidtab_search_force(struct sidtab *s, u32 sid)\n{\n\treturn sidtab_search_core(s, sid, 1);\n}"
  },
  {
    "function_name": "sidtab_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "109-112",
    "snippet": "struct context *sidtab_search(struct sidtab *s, u32 sid)\n{\n\treturn sidtab_search_core(s, sid, 0);\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sidtab_search_core",
          "args": [
            "s",
            "sid",
            "0"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "79-107",
          "snippet": "static struct context *sidtab_search_core(struct sidtab *s, u32 sid, int force)\n{\n\tint hvalue;\n\tstruct sidtab_node *cur;\n\n\tif (!s)\n\t\treturn NULL;\n\n\thvalue = SIDTAB_HASH(sid);\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid)\n\t\tcur = cur->next;\n\n\tif (force && cur && sid == cur->sid && cur->context.len)\n\t\treturn &cur->context;\n\n\tif (!cur || sid != cur->sid || cur->context.len) {\n\t\t/* Remap invalid SIDs to the unlabeled SID. */\n\t\tsid = SECINITSID_UNLABELED;\n\t\thvalue = SIDTAB_HASH(sid);\n\t\tcur = s->htable[hvalue];\n\t\twhile (cur && sid > cur->sid)\n\t\t\tcur = cur->next;\n\t\tif (!cur || sid != cur->sid)\n\t\t\treturn NULL;\n\t}\n\n\treturn &cur->context;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct context *sidtab_search_core(struct sidtab *s, u32 sid, int force)\n{\n\tint hvalue;\n\tstruct sidtab_node *cur;\n\n\tif (!s)\n\t\treturn NULL;\n\n\thvalue = SIDTAB_HASH(sid);\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid)\n\t\tcur = cur->next;\n\n\tif (force && cur && sid == cur->sid && cur->context.len)\n\t\treturn &cur->context;\n\n\tif (!cur || sid != cur->sid || cur->context.len) {\n\t\t/* Remap invalid SIDs to the unlabeled SID. */\n\t\tsid = SECINITSID_UNLABELED;\n\t\thvalue = SIDTAB_HASH(sid);\n\t\tcur = s->htable[hvalue];\n\t\twhile (cur && sid > cur->sid)\n\t\t\tcur = cur->next;\n\t\tif (!cur || sid != cur->sid)\n\t\t\treturn NULL;\n\t}\n\n\treturn &cur->context;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct context *sidtab_search(struct sidtab *s, u32 sid)\n{\n\treturn sidtab_search_core(s, sid, 0);\n}"
  },
  {
    "function_name": "sidtab_search_core",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "79-107",
    "snippet": "static struct context *sidtab_search_core(struct sidtab *s, u32 sid, int force)\n{\n\tint hvalue;\n\tstruct sidtab_node *cur;\n\n\tif (!s)\n\t\treturn NULL;\n\n\thvalue = SIDTAB_HASH(sid);\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid)\n\t\tcur = cur->next;\n\n\tif (force && cur && sid == cur->sid && cur->context.len)\n\t\treturn &cur->context;\n\n\tif (!cur || sid != cur->sid || cur->context.len) {\n\t\t/* Remap invalid SIDs to the unlabeled SID. */\n\t\tsid = SECINITSID_UNLABELED;\n\t\thvalue = SIDTAB_HASH(sid);\n\t\tcur = s->htable[hvalue];\n\t\twhile (cur && sid > cur->sid)\n\t\t\tcur = cur->next;\n\t\tif (!cur || sid != cur->sid)\n\t\t\treturn NULL;\n\t}\n\n\treturn &cur->context;\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SIDTAB_HASH",
          "args": [
            "sid"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIDTAB_HASH",
          "args": [
            "sid"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct context *sidtab_search_core(struct sidtab *s, u32 sid, int force)\n{\n\tint hvalue;\n\tstruct sidtab_node *cur;\n\n\tif (!s)\n\t\treturn NULL;\n\n\thvalue = SIDTAB_HASH(sid);\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid)\n\t\tcur = cur->next;\n\n\tif (force && cur && sid == cur->sid && cur->context.len)\n\t\treturn &cur->context;\n\n\tif (!cur || sid != cur->sid || cur->context.len) {\n\t\t/* Remap invalid SIDs to the unlabeled SID. */\n\t\tsid = SECINITSID_UNLABELED;\n\t\thvalue = SIDTAB_HASH(sid);\n\t\tcur = s->htable[hvalue];\n\t\twhile (cur && sid > cur->sid)\n\t\t\tcur = cur->next;\n\t\tif (!cur || sid != cur->sid)\n\t\t\treturn NULL;\n\t}\n\n\treturn &cur->context;\n}"
  },
  {
    "function_name": "sidtab_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "34-77",
    "snippet": "int sidtab_insert(struct sidtab *s, u32 sid, struct context *context)\n{\n\tint hvalue;\n\tstruct sidtab_node *prev, *cur, *newnode;\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\thvalue = SIDTAB_HASH(sid);\n\tprev = NULL;\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && sid == cur->sid)\n\t\treturn -EEXIST;\n\n\tnewnode = kmalloc(sizeof(*newnode), GFP_ATOMIC);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\n\tnewnode->sid = sid;\n\tif (context_cpy(&newnode->context, context)) {\n\t\tkfree(newnode);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\twmb();\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = s->htable[hvalue];\n\t\twmb();\n\t\ts->htable[hvalue] = newnode;\n\t}\n\n\ts->nel++;\n\tif (sid >= s->next_sid)\n\t\ts->next_sid = sid + 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newnode"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_cpy",
          "args": [
            "&newnode->context",
            "context"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "context_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "118-140",
          "snippet": "static inline int context_cpy(struct context *dst, struct context *src)\n{\n\tint rc;\n\n\tdst->user = src->user;\n\tdst->role = src->role;\n\tdst->type = src->type;\n\tif (src->str) {\n\t\tdst->str = kstrdup(src->str, GFP_ATOMIC);\n\t\tif (!dst->str)\n\t\t\treturn -ENOMEM;\n\t\tdst->len = src->len;\n\t} else {\n\t\tdst->str = NULL;\n\t\tdst->len = 0;\n\t}\n\trc = mls_context_cpy(dst, src);\n\tif (rc) {\n\t\tkfree(dst->str);\n\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline int context_cpy(struct context *dst, struct context *src)\n{\n\tint rc;\n\n\tdst->user = src->user;\n\tdst->role = src->role;\n\tdst->type = src->type;\n\tif (src->str) {\n\t\tdst->str = kstrdup(src->str, GFP_ATOMIC);\n\t\tif (!dst->str)\n\t\t\treturn -ENOMEM;\n\t\tdst->len = src->len;\n\t} else {\n\t\tdst->str = NULL;\n\t\tdst->len = 0;\n\t}\n\trc = mls_context_cpy(dst, src);\n\tif (rc) {\n\t\tkfree(dst->str);\n\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*newnode)",
            "GFP_ATOMIC"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIDTAB_HASH",
          "args": [
            "sid"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_insert(struct sidtab *s, u32 sid, struct context *context)\n{\n\tint hvalue;\n\tstruct sidtab_node *prev, *cur, *newnode;\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\thvalue = SIDTAB_HASH(sid);\n\tprev = NULL;\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && sid == cur->sid)\n\t\treturn -EEXIST;\n\n\tnewnode = kmalloc(sizeof(*newnode), GFP_ATOMIC);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\n\tnewnode->sid = sid;\n\tif (context_cpy(&newnode->context, context)) {\n\t\tkfree(newnode);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\twmb();\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = s->htable[hvalue];\n\t\twmb();\n\t\ts->htable[hvalue] = newnode;\n\t}\n\n\ts->nel++;\n\tif (sid >= s->next_sid)\n\t\ts->next_sid = sid + 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "sidtab_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
    "lines": "18-32",
    "snippet": "int sidtab_init(struct sidtab *s)\n{\n\tint i;\n\n\ts->htable = kmalloc_array(SIDTAB_SIZE, sizeof(*s->htable), GFP_ATOMIC);\n\tif (!s->htable)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < SIDTAB_SIZE; i++)\n\t\ts->htable[i] = NULL;\n\ts->nel = 0;\n\ts->next_sid = 1;\n\ts->shutdown = 0;\n\tspin_lock_init(&s->lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"sidtab.h\"",
      "#include \"security.h\"",
      "#include \"flask.h\"",
      "#include <linux/errno.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&s->lock"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "SIDTAB_SIZE",
            "sizeof(*s->htable)",
            "GFP_ATOMIC"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_init(struct sidtab *s)\n{\n\tint i;\n\n\ts->htable = kmalloc_array(SIDTAB_SIZE, sizeof(*s->htable), GFP_ATOMIC);\n\tif (!s->htable)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < SIDTAB_SIZE; i++)\n\t\ts->htable[i] = NULL;\n\ts->nel = 0;\n\ts->next_sid = 1;\n\ts->shutdown = 0;\n\tspin_lock_init(&s->lock);\n\treturn 0;\n}"
  }
]