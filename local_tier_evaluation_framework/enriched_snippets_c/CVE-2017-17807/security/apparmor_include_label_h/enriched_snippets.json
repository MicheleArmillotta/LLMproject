[
  {
    "function_name": "aa_put_proxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
    "lines": "434-438",
    "snippet": "static inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}",
    "includes": [
      "#include \"lib.h\"",
      "#include \"apparmor.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/audit.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&proxy->count",
            "aa_proxy_kref"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}"
  },
  {
    "function_name": "aa_get_proxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
    "lines": "426-432",
    "snippet": "static inline struct aa_proxy *aa_get_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_get(&(proxy->count));\n\n\treturn proxy;\n}",
    "includes": [
      "#include \"lib.h\"",
      "#include \"apparmor.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/audit.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&(proxy->count)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_proxy *aa_get_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_get(&(proxy->count));\n\n\treturn proxy;\n}"
  },
  {
    "function_name": "aa_put_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
    "lines": "416-420",
    "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
    "includes": [
      "#include \"lib.h\"",
      "#include \"apparmor.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/audit.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&l->count",
            "aa_label_kref"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
  },
  {
    "function_name": "aa_get_newest_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
    "lines": "393-414",
    "snippet": "static inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}",
    "includes": [
      "#include \"lib.h\"",
      "#include \"apparmor.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/audit.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "l"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!tmp"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!l->proxy->label"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!l->proxy"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_is_stale",
          "args": [
            "l"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}"
  },
  {
    "function_name": "aa_get_label_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
    "lines": "372-383",
    "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
    "includes": [
      "#include \"lib.h\"",
      "#include \"apparmor.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/audit.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get_unless_zero",
          "args": [
            "&c->count"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "*l"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
  },
  {
    "function_name": "aa_get_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
    "lines": "356-362",
    "snippet": "static inline struct aa_label *aa_get_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_get(&(l->count));\n\n\treturn l;\n}",
    "includes": [
      "#include \"lib.h\"",
      "#include \"apparmor.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/audit.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&(l->count)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_get(&(l->count));\n\n\treturn l;\n}"
  },
  {
    "function_name": "__aa_get_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
    "lines": "348-354",
    "snippet": "static inline struct aa_label *__aa_get_label(struct aa_label *l)\n{\n\tif (l && kref_get_unless_zero(&l->count))\n\t\treturn l;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"lib.h\"",
      "#include \"apparmor.h\"",
      "#include <linux/rcupdate.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/audit.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get_unless_zero",
          "args": [
            "&l->count"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *__aa_get_label(struct aa_label *l)\n{\n\tif (l && kref_get_unless_zero(&l->count))\n\t\treturn l;\n\n\treturn NULL;\n}"
  }
]