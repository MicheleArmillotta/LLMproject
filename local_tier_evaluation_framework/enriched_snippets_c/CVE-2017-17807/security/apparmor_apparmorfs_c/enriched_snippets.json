[
  {
    "function_name": "aa_create_aafs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2437-2523",
    "snippet": "static int __init aa_create_aafs(void)\n{\n\tstruct dentry *dent;\n\tint error;\n\n\tif (!apparmor_initialized)\n\t\treturn 0;\n\n\tif (aa_sfs_entry.dentry) {\n\t\tAA_ERROR(\"%s: AppArmor securityfs already exists\\n\", __func__);\n\t\treturn -EEXIST;\n\t}\n\n\t/* setup apparmorfs used to virtualize policy/ */\n\taafs_mnt = kern_mount(&aafs_ops);\n\tif (IS_ERR(aafs_mnt))\n\t\tpanic(\"can't set apparmorfs up\\n\");\n\taafs_mnt->mnt_sb->s_flags &= ~SB_NOUSER;\n\n\t/* Populate fs tree. */\n\terror = entry_create_dir(&aa_sfs_entry, NULL);\n\tif (error)\n\t\tgoto error;\n\n\tdent = securityfs_create_file(\".load\", 0666, aa_sfs_entry.dentry,\n\t\t\t\t      NULL, &aa_fs_profile_load);\n\tif (IS_ERR(dent)) {\n\t\terror = PTR_ERR(dent);\n\t\tgoto error;\n\t}\n\tns_subload(root_ns) = dent;\n\n\tdent = securityfs_create_file(\".replace\", 0666, aa_sfs_entry.dentry,\n\t\t\t\t      NULL, &aa_fs_profile_replace);\n\tif (IS_ERR(dent)) {\n\t\terror = PTR_ERR(dent);\n\t\tgoto error;\n\t}\n\tns_subreplace(root_ns) = dent;\n\n\tdent = securityfs_create_file(\".remove\", 0666, aa_sfs_entry.dentry,\n\t\t\t\t      NULL, &aa_fs_profile_remove);\n\tif (IS_ERR(dent)) {\n\t\terror = PTR_ERR(dent);\n\t\tgoto error;\n\t}\n\tns_subremove(root_ns) = dent;\n\n\tdent = securityfs_create_file(\"revision\", 0444, aa_sfs_entry.dentry,\n\t\t\t\t      NULL, &aa_fs_ns_revision_fops);\n\tif (IS_ERR(dent)) {\n\t\terror = PTR_ERR(dent);\n\t\tgoto error;\n\t}\n\tns_subrevision(root_ns) = dent;\n\n\t/* policy tree referenced by magic policy symlink */\n\tmutex_lock_nested(&root_ns->lock, root_ns->level);\n\terror = __aafs_ns_mkdir(root_ns, aafs_mnt->mnt_root, \".policy\",\n\t\t\t\taafs_mnt->mnt_root);\n\tmutex_unlock(&root_ns->lock);\n\tif (error)\n\t\tgoto error;\n\n\t/* magic symlink similar to nsfs redirects based on task policy */\n\tdent = securityfs_create_symlink(\"policy\", aa_sfs_entry.dentry,\n\t\t\t\t\t NULL, &policy_link_iops);\n\tif (IS_ERR(dent)) {\n\t\terror = PTR_ERR(dent);\n\t\tgoto error;\n\t}\n\n\terror = aa_mk_null_file(aa_sfs_entry.dentry);\n\tif (error)\n\t\tgoto error;\n\n\t/* TODO: add default profile to apparmorfs */\n\n\t/* Report that AppArmor fs is enabled */\n\taa_info_message(\"AppArmor Filesystem Enabled\");\n\treturn 0;\n\nerror:\n\taa_destroy_aafs();\n\tAA_ERROR(\"Error creating AppArmor securityfs\\n\");\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *aafs_mnt;",
      "static struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};",
      "static const struct file_operations aa_fs_profile_load = {\n\t.write = profile_load,\n\t.llseek = default_llseek,\n};",
      "static const struct file_operations aa_fs_profile_replace = {\n\t.write = profile_replace,\n\t.llseek = default_llseek,\n};",
      "static const struct file_operations aa_fs_profile_remove = {\n\t.write = profile_remove,\n\t.llseek = default_llseek,\n};",
      "static const struct file_operations aa_fs_ns_revision_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ns_revision_open,\n\t.poll\t\t= ns_revision_poll,\n\t.read\t\t= ns_revision_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= ns_revision_release,\n};",
      "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);",
      "static const struct inode_operations policy_link_iops = {\n\t.readlink\t= policy_readlink,\n\t.get_link\t= policy_get_link,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AA_ERROR",
          "args": [
            "\"Error creating AppArmor securityfs\\n\""
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_destroy_aafs",
          "args": [],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "aa_destroy_aafs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "2326-2329",
          "snippet": "void __init aa_destroy_aafs(void)\n{\n\tentry_remove_dir(&aa_sfs_entry);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\n\nvoid __init aa_destroy_aafs(void)\n{\n\tentry_remove_dir(&aa_sfs_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_info_message",
          "args": [
            "\"AppArmor Filesystem Enabled\""
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "aa_info_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "126-135",
          "snippet": "void aa_info_message(const char *str)\n{\n\tif (audit_enabled) {\n\t\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, NULL);\n\n\t\taad(&sa)->info = str;\n\t\taa_audit_msg(AUDIT_APPARMOR_STATUS, &sa, NULL);\n\t}\n\tprintk(KERN_INFO \"AppArmor: %s\\n\", str);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_info_message(const char *str)\n{\n\tif (audit_enabled) {\n\t\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, NULL);\n\n\t\taad(&sa)->info = str;\n\t\taa_audit_msg(AUDIT_APPARMOR_STATUS, &sa, NULL);\n\t}\n\tprintk(KERN_INFO \"AppArmor: %s\\n\", str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_mk_null_file",
          "args": [
            "aa_sfs_entry.dentry"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "aa_mk_null_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "2335-2375",
          "snippet": "static int aa_mk_null_file(struct dentry *parent)\n{\n\tstruct vfsmount *mount = NULL;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint count = 0;\n\tint error = simple_pin_fs(parent->d_sb->s_type, &mount, &count);\n\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(d_inode(parent));\n\tdentry = lookup_one_len(NULL_FILE_NAME, parent, strlen(NULL_FILE_NAME));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\tinode = new_inode(parent->d_inode->i_sb);\n\tif (!inode) {\n\t\terror = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = S_IFCHR | S_IRUGO | S_IWUGO;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinit_special_inode(inode, S_IFCHR | S_IRUGO | S_IWUGO,\n\t\t\t   MKDEV(MEM_MAJOR, 3));\n\td_instantiate(dentry, inode);\n\taa_null.dentry = dget(dentry);\n\taa_null.mnt = mntget(mount);\n\n\terror = 0;\n\nout1:\n\tdput(dentry);\nout:\n\tinode_unlock(d_inode(parent));\n\tsimple_release_fs(&mount, &count);\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define NULL_FILE_NAME \".null\""
          ],
          "globals_used": [
            "struct path aa_null;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\n#define NULL_FILE_NAME \".null\"\n\nstruct path aa_null;\n\nstatic int aa_mk_null_file(struct dentry *parent)\n{\n\tstruct vfsmount *mount = NULL;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint count = 0;\n\tint error = simple_pin_fs(parent->d_sb->s_type, &mount, &count);\n\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(d_inode(parent));\n\tdentry = lookup_one_len(NULL_FILE_NAME, parent, strlen(NULL_FILE_NAME));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\tinode = new_inode(parent->d_inode->i_sb);\n\tif (!inode) {\n\t\terror = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = S_IFCHR | S_IRUGO | S_IWUGO;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinit_special_inode(inode, S_IFCHR | S_IRUGO | S_IWUGO,\n\t\t\t   MKDEV(MEM_MAJOR, 3));\n\td_instantiate(dentry, inode);\n\taa_null.dentry = dget(dentry);\n\taa_null.mnt = mntget(mount);\n\n\terror = 0;\n\nout1:\n\tdput(dentry);\nout:\n\tinode_unlock(d_inode(parent));\n\tsimple_release_fs(&mount, &count);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "securityfs_create_symlink",
          "args": [
            "\"policy\"",
            "aa_sfs_entry.dentry",
            "NULL",
            "&policy_link_iops"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "254-273",
          "snippet": "struct dentry *securityfs_create_symlink(const char *name,\n\t\t\t\t\t struct dentry *parent,\n\t\t\t\t\t const char *target,\n\t\t\t\t\t const struct inode_operations *iops)\n{\n\tstruct dentry *dent;\n\tchar *link = NULL;\n\n\tif (target) {\n\t\tlink = kstrdup(target, GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tdent = securityfs_create_dentry(name, S_IFLNK | 0444, parent,\n\t\t\t\t\tlink, NULL, iops);\n\tif (IS_ERR(dent))\n\t\tkfree(link);\n\n\treturn dent;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_symlink(const char *name,\n\t\t\t\t\t struct dentry *parent,\n\t\t\t\t\t const char *target,\n\t\t\t\t\t const struct inode_operations *iops)\n{\n\tstruct dentry *dent;\n\tchar *link = NULL;\n\n\tif (target) {\n\t\tlink = kstrdup(target, GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tdent = securityfs_create_dentry(name, S_IFLNK | 0444, parent,\n\t\t\t\t\tlink, NULL, iops);\n\tif (IS_ERR(dent))\n\t\tkfree(link);\n\n\treturn dent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root_ns->lock"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aafs_ns_mkdir",
          "args": [
            "root_ns",
            "aafs_mnt->mnt_root",
            "\".policy\"",
            "aafs_mnt->mnt_root"
          ],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "__aafs_ns_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1844-1896",
          "snippet": "int __aafs_ns_mkdir(struct aa_ns *ns, struct dentry *parent, const char *name,\n\t\t    struct dentry *dent)\n{\n\tstruct aa_ns *sub;\n\tstruct aa_profile *child;\n\tstruct dentry *dir;\n\tint error;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!parent);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tif (!name)\n\t\tname = ns->base.name;\n\n\tif (!dent) {\n\t\t/* create ns dir if it doesn't already exist */\n\t\tdent = aafs_create_dir(name, parent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t} else\n\t\tdget(dent);\n\tns_dir(ns) = dir = dent;\n\terror = __aafs_ns_mkdir_entries(ns, dir);\n\tif (error)\n\t\tgoto fail2;\n\n\t/* profiles */\n\tlist_for_each_entry(child, &ns->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, ns_subprofs_dir(ns));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\t/* subnamespaces */\n\tlist_for_each_entry(sub, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&sub->lock, sub->level);\n\t\terror = __aafs_ns_mkdir(sub, ns_subns_dir(ns), NULL, NULL);\n\t\tmutex_unlock(&sub->lock);\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_ns_rmdir(ns);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nint __aafs_ns_mkdir(struct aa_ns *ns, struct dentry *parent, const char *name,\n\t\t    struct dentry *dent)\n{\n\tstruct aa_ns *sub;\n\tstruct aa_profile *child;\n\tstruct dentry *dir;\n\tint error;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!parent);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tif (!name)\n\t\tname = ns->base.name;\n\n\tif (!dent) {\n\t\t/* create ns dir if it doesn't already exist */\n\t\tdent = aafs_create_dir(name, parent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t} else\n\t\tdget(dent);\n\tns_dir(ns) = dir = dent;\n\terror = __aafs_ns_mkdir_entries(ns, dir);\n\tif (error)\n\t\tgoto fail2;\n\n\t/* profiles */\n\tlist_for_each_entry(child, &ns->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, ns_subprofs_dir(ns));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\t/* subnamespaces */\n\tlist_for_each_entry(sub, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&sub->lock, sub->level);\n\t\terror = __aafs_ns_mkdir(sub, ns_subns_dir(ns), NULL, NULL);\n\t\tmutex_unlock(&sub->lock);\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_ns_rmdir(ns);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&root_ns->lock",
            "root_ns->level"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subrevision",
          "args": [
            "root_ns"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "securityfs_create_file",
          "args": [
            "\"revision\"",
            "0444",
            "aa_sfs_entry.dentry",
            "NULL",
            "&aa_fs_ns_revision_fops"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "194-199",
          "snippet": "struct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_subremove",
          "args": [
            "root_ns"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subreplace",
          "args": [
            "root_ns"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subload",
          "args": [
            "root_ns"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry_create_dir",
          "args": [
            "&aa_sfs_entry",
            "NULL"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "entry_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "2261-2288",
          "snippet": "static int __init entry_create_dir(struct aa_sfs_entry *fs_dir,\n\t\t\t\t   struct dentry *parent)\n{\n\tstruct aa_sfs_entry *fs_file;\n\tstruct dentry *dir;\n\tint error;\n\n\tdir = securityfs_create_dir(fs_dir->name, parent);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\tfs_dir->dentry = dir;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\terror = entry_create_dir(fs_file, fs_dir->dentry);\n\t\telse\n\t\t\terror = entry_create_file(fs_file, fs_dir->dentry);\n\t\tif (error)\n\t\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tentry_remove_dir(fs_dir);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);",
            "static void __init entry_remove_dir(struct aa_sfs_entry *fs_dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\nstatic void __init entry_remove_dir(struct aa_sfs_entry *fs_dir);\n\nstatic int __init entry_create_dir(struct aa_sfs_entry *fs_dir,\n\t\t\t\t   struct dentry *parent)\n{\n\tstruct aa_sfs_entry *fs_file;\n\tstruct dentry *dir;\n\tint error;\n\n\tdir = securityfs_create_dir(fs_dir->name, parent);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\tfs_dir->dentry = dir;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\terror = entry_create_dir(fs_file, fs_dir->dentry);\n\t\telse\n\t\t\terror = entry_create_file(fs_file, fs_dir->dentry);\n\t\tif (error)\n\t\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tentry_remove_dir(fs_dir);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"can't set apparmorfs up\\n\""
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "aafs_mnt"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "&aafs_ops"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_ERROR",
          "args": [
            "\"%s: AppArmor securityfs already exists\\n\"",
            "__func__"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct vfsmount *aafs_mnt;\nstatic struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};\nstatic const struct file_operations aa_fs_profile_load = {\n\t.write = profile_load,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations aa_fs_profile_replace = {\n\t.write = profile_replace,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations aa_fs_profile_remove = {\n\t.write = profile_remove,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations aa_fs_ns_revision_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ns_revision_open,\n\t.poll\t\t= ns_revision_poll,\n\t.read\t\t= ns_revision_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= ns_revision_release,\n};\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\nstatic const struct inode_operations policy_link_iops = {\n\t.readlink\t= policy_readlink,\n\t.get_link\t= policy_get_link,\n};\n\nstatic int __init aa_create_aafs(void)\n{\n\tstruct dentry *dent;\n\tint error;\n\n\tif (!apparmor_initialized)\n\t\treturn 0;\n\n\tif (aa_sfs_entry.dentry) {\n\t\tAA_ERROR(\"%s: AppArmor securityfs already exists\\n\", __func__);\n\t\treturn -EEXIST;\n\t}\n\n\t/* setup apparmorfs used to virtualize policy/ */\n\taafs_mnt = kern_mount(&aafs_ops);\n\tif (IS_ERR(aafs_mnt))\n\t\tpanic(\"can't set apparmorfs up\\n\");\n\taafs_mnt->mnt_sb->s_flags &= ~SB_NOUSER;\n\n\t/* Populate fs tree. */\n\terror = entry_create_dir(&aa_sfs_entry, NULL);\n\tif (error)\n\t\tgoto error;\n\n\tdent = securityfs_create_file(\".load\", 0666, aa_sfs_entry.dentry,\n\t\t\t\t      NULL, &aa_fs_profile_load);\n\tif (IS_ERR(dent)) {\n\t\terror = PTR_ERR(dent);\n\t\tgoto error;\n\t}\n\tns_subload(root_ns) = dent;\n\n\tdent = securityfs_create_file(\".replace\", 0666, aa_sfs_entry.dentry,\n\t\t\t\t      NULL, &aa_fs_profile_replace);\n\tif (IS_ERR(dent)) {\n\t\terror = PTR_ERR(dent);\n\t\tgoto error;\n\t}\n\tns_subreplace(root_ns) = dent;\n\n\tdent = securityfs_create_file(\".remove\", 0666, aa_sfs_entry.dentry,\n\t\t\t\t      NULL, &aa_fs_profile_remove);\n\tif (IS_ERR(dent)) {\n\t\terror = PTR_ERR(dent);\n\t\tgoto error;\n\t}\n\tns_subremove(root_ns) = dent;\n\n\tdent = securityfs_create_file(\"revision\", 0444, aa_sfs_entry.dentry,\n\t\t\t\t      NULL, &aa_fs_ns_revision_fops);\n\tif (IS_ERR(dent)) {\n\t\terror = PTR_ERR(dent);\n\t\tgoto error;\n\t}\n\tns_subrevision(root_ns) = dent;\n\n\t/* policy tree referenced by magic policy symlink */\n\tmutex_lock_nested(&root_ns->lock, root_ns->level);\n\terror = __aafs_ns_mkdir(root_ns, aafs_mnt->mnt_root, \".policy\",\n\t\t\t\taafs_mnt->mnt_root);\n\tmutex_unlock(&root_ns->lock);\n\tif (error)\n\t\tgoto error;\n\n\t/* magic symlink similar to nsfs redirects based on task policy */\n\tdent = securityfs_create_symlink(\"policy\", aa_sfs_entry.dentry,\n\t\t\t\t\t NULL, &policy_link_iops);\n\tif (IS_ERR(dent)) {\n\t\terror = PTR_ERR(dent);\n\t\tgoto error;\n\t}\n\n\terror = aa_mk_null_file(aa_sfs_entry.dentry);\n\tif (error)\n\t\tgoto error;\n\n\t/* TODO: add default profile to apparmorfs */\n\n\t/* Report that AppArmor fs is enabled */\n\taa_info_message(\"AppArmor Filesystem Enabled\");\n\treturn 0;\n\nerror:\n\taa_destroy_aafs();\n\tAA_ERROR(\"Error creating AppArmor securityfs\\n\");\n\treturn error;\n}"
  },
  {
    "function_name": "policy_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2408-2422",
    "snippet": "static int policy_readlink(struct dentry *dentry, char __user *buffer,\n\t\t\t   int buflen)\n{\n\tstruct aa_ns *ns;\n\tchar name[32];\n\tint res;\n\n\tns = aa_get_current_ns();\n\tres = ns_get_name(name, sizeof(name), ns, d_inode(dentry));\n\tif (res >= 0)\n\t\tres = readlink_copy(buffer, buflen, name);\n\taa_put_ns(ns);\n\n\treturn res;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "ns"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "readlink_copy",
          "args": [
            "buffer",
            "buflen",
            "name"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_get_name",
          "args": [
            "name",
            "sizeof(name)",
            "ns",
            "d_inode(dentry)"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "ns_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "2397-2406",
          "snippet": "static int ns_get_name(char *buf, size_t size, struct aa_ns *ns,\n\t\t       struct inode *inode)\n{\n\tint res = snprintf(buf, size, \"%s:[%lu]\", AAFS_NAME, inode->i_ino);\n\n\tif (res < 0 || res >= size)\n\t\tres = -ENOENT;\n\n\treturn res;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define AAFS_NAME\t\t\"apparmorfs\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\n#define AAFS_NAME\t\t\"apparmorfs\"\n\nstatic int ns_get_name(char *buf, size_t size, struct aa_ns *ns,\n\t\t       struct inode *inode)\n{\n\tint res = snprintf(buf, size, \"%s:[%lu]\", AAFS_NAME, inode->i_ino);\n\n\tif (res < 0 || res >= size)\n\t\tres = -ENOENT;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_current_ns",
          "args": [],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_current_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "204-214",
          "snippet": "static inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int policy_readlink(struct dentry *dentry, char __user *buffer,\n\t\t\t   int buflen)\n{\n\tstruct aa_ns *ns;\n\tchar name[32];\n\tint res;\n\n\tns = aa_get_current_ns();\n\tres = ns_get_name(name, sizeof(name), ns, d_inode(dentry));\n\tif (res >= 0)\n\t\tres = readlink_copy(buffer, buflen, name);\n\taa_put_ns(ns);\n\n\treturn res;\n}"
  },
  {
    "function_name": "ns_get_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2397-2406",
    "snippet": "static int ns_get_name(char *buf, size_t size, struct aa_ns *ns,\n\t\t       struct inode *inode)\n{\n\tint res = snprintf(buf, size, \"%s:[%lu]\", AAFS_NAME, inode->i_ino);\n\n\tif (res < 0 || res >= size)\n\t\tres = -ENOENT;\n\n\treturn res;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define AAFS_NAME\t\t\"apparmorfs\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "size",
            "\"%s:[%lu]\"",
            "AAFS_NAME",
            "inode->i_ino"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\n#define AAFS_NAME\t\t\"apparmorfs\"\n\nstatic int ns_get_name(char *buf, size_t size, struct aa_ns *ns,\n\t\t       struct inode *inode)\n{\n\tint res = snprintf(buf, size, \"%s:[%lu]\", AAFS_NAME, inode->i_ino);\n\n\tif (res < 0 || res >= size)\n\t\tres = -ENOENT;\n\n\treturn res;\n}"
  },
  {
    "function_name": "policy_get_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2379-2395",
    "snippet": "static const char *policy_get_link(struct dentry *dentry,\n\t\t\t\t   struct inode *inode,\n\t\t\t\t   struct delayed_call *done)\n{\n\tstruct aa_ns *ns;\n\tstruct path path;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\tns = aa_get_current_ns();\n\tpath.mnt = mntget(aafs_mnt);\n\tpath.dentry = dget(ns_dir(ns));\n\tnd_jump_link(&path);\n\taa_put_ns(ns);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *aafs_mnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "ns"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nd_jump_link",
          "args": [
            "&path"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "ns_dir(ns)"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_dir",
          "args": [
            "ns"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "aafs_mnt"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_current_ns",
          "args": [],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_current_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "204-214",
          "snippet": "static inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ECHILD"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct vfsmount *aafs_mnt;\n\nstatic const char *policy_get_link(struct dentry *dentry,\n\t\t\t\t   struct inode *inode,\n\t\t\t\t   struct delayed_call *done)\n{\n\tstruct aa_ns *ns;\n\tstruct path path;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ECHILD);\n\tns = aa_get_current_ns();\n\tpath.mnt = mntget(aafs_mnt);\n\tpath.dentry = dget(ns_dir(ns));\n\tnd_jump_link(&path);\n\taa_put_ns(ns);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "aa_mk_null_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2335-2375",
    "snippet": "static int aa_mk_null_file(struct dentry *parent)\n{\n\tstruct vfsmount *mount = NULL;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint count = 0;\n\tint error = simple_pin_fs(parent->d_sb->s_type, &mount, &count);\n\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(d_inode(parent));\n\tdentry = lookup_one_len(NULL_FILE_NAME, parent, strlen(NULL_FILE_NAME));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\tinode = new_inode(parent->d_inode->i_sb);\n\tif (!inode) {\n\t\terror = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = S_IFCHR | S_IRUGO | S_IWUGO;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinit_special_inode(inode, S_IFCHR | S_IRUGO | S_IWUGO,\n\t\t\t   MKDEV(MEM_MAJOR, 3));\n\td_instantiate(dentry, inode);\n\taa_null.dentry = dget(dentry);\n\taa_null.mnt = mntget(mount);\n\n\terror = 0;\n\nout1:\n\tdput(dentry);\nout:\n\tinode_unlock(d_inode(parent));\n\tsimple_release_fs(&mount, &count);\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define NULL_FILE_NAME \".null\""
    ],
    "globals_used": [
      "struct path aa_null;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_release_fs",
          "args": [
            "&mount",
            "&count"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "d_inode(parent)"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "parent"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "mount"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "security_d_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "1249-1254",
          "snippet": "void security_d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tif (unlikely(inode && IS_PRIVATE(inode)))\n\t\treturn;\n\tcall_void_hook(d_instantiate, dentry, inode);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nvoid security_d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tif (unlikely(inode && IS_PRIVATE(inode)))\n\t\treturn;\n\tcall_void_hook(d_instantiate, dentry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "S_IFCHR | S_IRUGO | S_IWUGO",
            "MKDEV(MEM_MAJOR, 3)"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "MEM_MAJOR",
            "3"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "parent->d_inode->i_sb"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_smack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "295-308",
          "snippet": "static struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *smack_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct kmem_cache *smack_inode_cache;\n\nstatic struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "NULL_FILE_NAME",
            "parent",
            "strlen(NULL_FILE_NAME)"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "NULL_FILE_NAME"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "d_inode(parent)"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "parent"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_pin_fs",
          "args": [
            "parent->d_sb->s_type",
            "&mount",
            "&count"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\n#define NULL_FILE_NAME \".null\"\n\nstruct path aa_null;\n\nstatic int aa_mk_null_file(struct dentry *parent)\n{\n\tstruct vfsmount *mount = NULL;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint count = 0;\n\tint error = simple_pin_fs(parent->d_sb->s_type, &mount, &count);\n\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(d_inode(parent));\n\tdentry = lookup_one_len(NULL_FILE_NAME, parent, strlen(NULL_FILE_NAME));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\tinode = new_inode(parent->d_inode->i_sb);\n\tif (!inode) {\n\t\terror = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = S_IFCHR | S_IRUGO | S_IWUGO;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinit_special_inode(inode, S_IFCHR | S_IRUGO | S_IWUGO,\n\t\t\t   MKDEV(MEM_MAJOR, 3));\n\td_instantiate(dentry, inode);\n\taa_null.dentry = dget(dentry);\n\taa_null.mnt = mntget(mount);\n\n\terror = 0;\n\nout1:\n\tdput(dentry);\nout:\n\tinode_unlock(d_inode(parent));\n\tsimple_release_fs(&mount, &count);\n\treturn error;\n}"
  },
  {
    "function_name": "aa_destroy_aafs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2326-2329",
    "snippet": "void __init aa_destroy_aafs(void)\n{\n\tentry_remove_dir(&aa_sfs_entry);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "entry_remove_dir",
          "args": [
            "&aa_sfs_entry"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "entry_remove_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "2307-2319",
          "snippet": "static void __init entry_remove_dir(struct aa_sfs_entry *fs_dir)\n{\n\tstruct aa_sfs_entry *fs_file;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\tentry_remove_dir(fs_file);\n\t\telse\n\t\t\tentry_remove_file(fs_file);\n\t}\n\n\tentry_remove_file(fs_dir);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);",
            "static void __init entry_remove_dir(struct aa_sfs_entry *fs_dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\nstatic void __init entry_remove_dir(struct aa_sfs_entry *fs_dir);\n\nstatic void __init entry_remove_dir(struct aa_sfs_entry *fs_dir)\n{\n\tstruct aa_sfs_entry *fs_file;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\tentry_remove_dir(fs_file);\n\t\telse\n\t\t\tentry_remove_file(fs_file);\n\t}\n\n\tentry_remove_file(fs_dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\n\nvoid __init aa_destroy_aafs(void)\n{\n\tentry_remove_dir(&aa_sfs_entry);\n}"
  },
  {
    "function_name": "entry_remove_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2307-2319",
    "snippet": "static void __init entry_remove_dir(struct aa_sfs_entry *fs_dir)\n{\n\tstruct aa_sfs_entry *fs_file;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\tentry_remove_dir(fs_file);\n\t\telse\n\t\t\tentry_remove_file(fs_file);\n\t}\n\n\tentry_remove_file(fs_dir);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);",
      "static void __init entry_remove_dir(struct aa_sfs_entry *fs_dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "entry_remove_file",
          "args": [
            "fs_dir"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "entry_remove_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "2294-2301",
          "snippet": "static void __init entry_remove_file(struct aa_sfs_entry *fs_file)\n{\n\tif (!fs_file->dentry)\n\t\treturn;\n\n\tsecurityfs_remove(fs_file->dentry);\n\tfs_file->dentry = NULL;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\n\nstatic void __init entry_remove_file(struct aa_sfs_entry *fs_file)\n{\n\tif (!fs_file->dentry)\n\t\treturn;\n\n\tsecurityfs_remove(fs_file->dentry);\n\tfs_file->dentry = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry_remove_dir",
          "args": [
            "fs_file"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "entry_remove_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "2307-2319",
          "snippet": "static void __init entry_remove_dir(struct aa_sfs_entry *fs_dir)\n{\n\tstruct aa_sfs_entry *fs_file;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\tentry_remove_dir(fs_file);\n\t\telse\n\t\t\tentry_remove_file(fs_file);\n\t}\n\n\tentry_remove_file(fs_dir);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\nstatic void __init entry_remove_dir(struct aa_sfs_entry *fs_dir);\n\nstatic void __init entry_remove_dir(struct aa_sfs_entry *fs_dir)\n{\n\tstruct aa_sfs_entry *fs_file;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\tentry_remove_dir(fs_file);\n\t\telse\n\t\t\tentry_remove_file(fs_file);\n\t}\n\n\tentry_remove_file(fs_dir);\n}"
  },
  {
    "function_name": "entry_remove_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2294-2301",
    "snippet": "static void __init entry_remove_file(struct aa_sfs_entry *fs_file)\n{\n\tif (!fs_file->dentry)\n\t\treturn;\n\n\tsecurityfs_remove(fs_file->dentry);\n\tfs_file->dentry = NULL;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "securityfs_remove",
          "args": [
            "fs_file->dentry"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "289-307",
          "snippet": "void securityfs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *mount;",
            "static int mount_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *mount;\nstatic int mount_count;\n\nvoid securityfs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\n\nstatic void __init entry_remove_file(struct aa_sfs_entry *fs_file)\n{\n\tif (!fs_file->dentry)\n\t\treturn;\n\n\tsecurityfs_remove(fs_file->dentry);\n\tfs_file->dentry = NULL;\n}"
  },
  {
    "function_name": "entry_create_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2261-2288",
    "snippet": "static int __init entry_create_dir(struct aa_sfs_entry *fs_dir,\n\t\t\t\t   struct dentry *parent)\n{\n\tstruct aa_sfs_entry *fs_file;\n\tstruct dentry *dir;\n\tint error;\n\n\tdir = securityfs_create_dir(fs_dir->name, parent);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\tfs_dir->dentry = dir;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\terror = entry_create_dir(fs_file, fs_dir->dentry);\n\t\telse\n\t\t\terror = entry_create_file(fs_file, fs_dir->dentry);\n\t\tif (error)\n\t\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tentry_remove_dir(fs_dir);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);",
      "static void __init entry_remove_dir(struct aa_sfs_entry *fs_dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "entry_remove_dir",
          "args": [
            "fs_dir"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "entry_remove_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "2307-2319",
          "snippet": "static void __init entry_remove_dir(struct aa_sfs_entry *fs_dir)\n{\n\tstruct aa_sfs_entry *fs_file;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\tentry_remove_dir(fs_file);\n\t\telse\n\t\t\tentry_remove_file(fs_file);\n\t}\n\n\tentry_remove_file(fs_dir);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);",
            "static void __init entry_remove_dir(struct aa_sfs_entry *fs_dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\nstatic void __init entry_remove_dir(struct aa_sfs_entry *fs_dir);\n\nstatic void __init entry_remove_dir(struct aa_sfs_entry *fs_dir)\n{\n\tstruct aa_sfs_entry *fs_file;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\tentry_remove_dir(fs_file);\n\t\telse\n\t\t\tentry_remove_file(fs_file);\n\t}\n\n\tentry_remove_file(fs_dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry_create_file",
          "args": [
            "fs_file",
            "fs_dir->dentry"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "entry_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "2237-2251",
          "snippet": "static int __init entry_create_file(struct aa_sfs_entry *fs_file,\n\t\t\t\t    struct dentry *parent)\n{\n\tint error = 0;\n\n\tfs_file->dentry = securityfs_create_file(fs_file->name,\n\t\t\t\t\t\t S_IFREG | fs_file->mode,\n\t\t\t\t\t\t parent, fs_file,\n\t\t\t\t\t\t fs_file->file_ops);\n\tif (IS_ERR(fs_file->dentry)) {\n\t\terror = PTR_ERR(fs_file->dentry);\n\t\tfs_file->dentry = NULL;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\n\nstatic int __init entry_create_file(struct aa_sfs_entry *fs_file,\n\t\t\t\t    struct dentry *parent)\n{\n\tint error = 0;\n\n\tfs_file->dentry = securityfs_create_file(fs_file->name,\n\t\t\t\t\t\t S_IFREG | fs_file->mode,\n\t\t\t\t\t\t parent, fs_file,\n\t\t\t\t\t\t fs_file->file_ops);\n\tif (IS_ERR(fs_file->dentry)) {\n\t\terror = PTR_ERR(fs_file->dentry);\n\t\tfs_file->dentry = NULL;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry_create_dir",
          "args": [
            "fs_file",
            "fs_dir->dentry"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "entry_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "2261-2288",
          "snippet": "static int __init entry_create_dir(struct aa_sfs_entry *fs_dir,\n\t\t\t\t   struct dentry *parent)\n{\n\tstruct aa_sfs_entry *fs_file;\n\tstruct dentry *dir;\n\tint error;\n\n\tdir = securityfs_create_dir(fs_dir->name, parent);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\tfs_dir->dentry = dir;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\terror = entry_create_dir(fs_file, fs_dir->dentry);\n\t\telse\n\t\t\terror = entry_create_file(fs_file, fs_dir->dentry);\n\t\tif (error)\n\t\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tentry_remove_dir(fs_dir);\n\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "securityfs_create_dir",
          "args": [
            "fs_dir->name",
            "parent"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "222-225",
          "snippet": "struct dentry *securityfs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn securityfs_create_file(name, S_IFDIR | 0755, parent, NULL, NULL);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn securityfs_create_file(name, S_IFDIR | 0755, parent, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\nstatic void __init entry_remove_dir(struct aa_sfs_entry *fs_dir);\n\nstatic int __init entry_create_dir(struct aa_sfs_entry *fs_dir,\n\t\t\t\t   struct dentry *parent)\n{\n\tstruct aa_sfs_entry *fs_file;\n\tstruct dentry *dir;\n\tint error;\n\n\tdir = securityfs_create_dir(fs_dir->name, parent);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\tfs_dir->dentry = dir;\n\n\tfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\n\t\tif (fs_file->v_type == AA_SFS_TYPE_DIR)\n\t\t\terror = entry_create_dir(fs_file, fs_dir->dentry);\n\t\telse\n\t\t\terror = entry_create_file(fs_file, fs_dir->dentry);\n\t\tif (error)\n\t\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tentry_remove_dir(fs_dir);\n\n\treturn error;\n}"
  },
  {
    "function_name": "entry_create_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2237-2251",
    "snippet": "static int __init entry_create_file(struct aa_sfs_entry *fs_file,\n\t\t\t\t    struct dentry *parent)\n{\n\tint error = 0;\n\n\tfs_file->dentry = securityfs_create_file(fs_file->name,\n\t\t\t\t\t\t S_IFREG | fs_file->mode,\n\t\t\t\t\t\t parent, fs_file,\n\t\t\t\t\t\t fs_file->file_ops);\n\tif (IS_ERR(fs_file->dentry)) {\n\t\terror = PTR_ERR(fs_file->dentry);\n\t\tfs_file->dentry = NULL;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fs_file->dentry"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_file->dentry"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "securityfs_create_file",
          "args": [
            "fs_file->name",
            "S_IFREG | fs_file->mode",
            "parent",
            "fs_file",
            "fs_file->file_ops"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "194-199",
          "snippet": "struct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\n\nstatic int __init entry_create_file(struct aa_sfs_entry *fs_file,\n\t\t\t\t    struct dentry *parent)\n{\n\tint error = 0;\n\n\tfs_file->dentry = securityfs_create_file(fs_file->name,\n\t\t\t\t\t\t S_IFREG | fs_file->mode,\n\t\t\t\t\t\t parent, fs_file,\n\t\t\t\t\t\t fs_file->file_ops);\n\tif (IS_ERR(fs_file->dentry)) {\n\t\terror = PTR_ERR(fs_file->dentry);\n\t\tfs_file->dentry = NULL;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "profiles_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2125-2128",
    "snippet": "static int profiles_release(struct inode *inode, struct file *file)\n{\n\treturn seq_release(inode, file);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int profiles_release(struct inode *inode, struct file *file)\n{\n\treturn seq_release(inode, file);\n}"
  },
  {
    "function_name": "profiles_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2117-2123",
    "snippet": "static int profiles_open(struct inode *inode, struct file *file)\n{\n\tif (!policy_view_capable(NULL))\n\t\treturn -EACCES;\n\n\treturn seq_open(file, &aa_sfs_profiles_op);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations aa_sfs_profiles_op = {\n\t.start = p_start,\n\t.next = p_next,\n\t.stop = p_stop,\n\t.show = seq_show_profile,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&aa_sfs_profiles_op"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy_view_capable",
          "args": [
            "NULL"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "policy_view_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "640-658",
          "snippet": "bool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int unprivileged_userns_apparmor_policy = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint unprivileged_userns_apparmor_policy = 1;\n\nbool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic const struct seq_operations aa_sfs_profiles_op = {\n\t.start = p_start,\n\t.next = p_next,\n\t.stop = p_stop,\n\t.show = seq_show_profile,\n};\n\nstatic int profiles_open(struct inode *inode, struct file *file)\n{\n\tif (!policy_view_capable(NULL))\n\t\treturn -EACCES;\n\n\treturn seq_open(file, &aa_sfs_profiles_op);\n}"
  },
  {
    "function_name": "seq_show_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2098-2108",
    "snippet": "static int seq_show_profile(struct seq_file *f, void *p)\n{\n\tstruct aa_profile *profile = (struct aa_profile *)p;\n\tstruct aa_ns *root = f->private;\n\n\taa_label_seq_xprint(f, root, &profile->label,\n\t\t\t    FLAG_SHOW_MODE | FLAG_VIEW_SUBNS, GFP_KERNEL);\n\tseq_putc(f, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "f",
            "'\\n'"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_seq_xprint",
          "args": [
            "f",
            "root",
            "&profile->label",
            "FLAG_SHOW_MODE | FLAG_VIEW_SUBNS",
            "GFP_KERNEL"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_seq_xprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1740-1762",
          "snippet": "void aa_label_seq_xprint(struct seq_file *f, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp)\n{\n\tAA_BUG(!f);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tseq_printf(f, \"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tseq_printf(f, \"%s (%s)\", label->hname,\n\t\t\t   label_modename(ns, label, flags));\n\telse\n\t\tseq_printf(f, \"%s\", label->hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_seq_xprint(struct seq_file *f, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp)\n{\n\tAA_BUG(!f);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tseq_printf(f, \"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tseq_printf(f, \"%s (%s)\", label->hname,\n\t\t\t   label_modename(ns, label, flags));\n\telse\n\t\tseq_printf(f, \"%s\", label->hname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_show_profile(struct seq_file *f, void *p)\n{\n\tstruct aa_profile *profile = (struct aa_profile *)p;\n\tstruct aa_ns *root = f->private;\n\n\taa_label_seq_xprint(f, root, &profile->label,\n\t\t\t    FLAG_SHOW_MODE | FLAG_VIEW_SUBNS, GFP_KERNEL);\n\tseq_putc(f, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "p_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2078-2089",
    "snippet": "static void p_stop(struct seq_file *f, void *p)\n{\n\tstruct aa_profile *profile = p;\n\tstruct aa_ns *root = f->private, *ns;\n\n\tif (profile) {\n\t\tfor (ns = profile->ns; ns && ns != root; ns = ns->parent)\n\t\t\tmutex_unlock(&ns->lock);\n\t}\n\tmutex_unlock(&root->lock);\n\taa_put_ns(root);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "root"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->lock"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ns->lock"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void p_stop(struct seq_file *f, void *p)\n{\n\tstruct aa_profile *profile = p;\n\tstruct aa_ns *root = f->private, *ns;\n\n\tif (profile) {\n\t\tfor (ns = profile->ns; ns && ns != root; ns = ns->parent)\n\t\t\tmutex_unlock(&ns->lock);\n\t}\n\tmutex_unlock(&root->lock);\n\taa_put_ns(root);\n}"
  },
  {
    "function_name": "p_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2062-2069",
    "snippet": "static void *p_next(struct seq_file *f, void *p, loff_t *pos)\n{\n\tstruct aa_profile *profile = p;\n\tstruct aa_ns *ns = f->private;\n\t(*pos)++;\n\n\treturn next_profile(ns, profile);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_profile",
          "args": [
            "ns",
            "profile"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "next_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "2014-2023",
          "snippet": "static struct aa_profile *next_profile(struct aa_ns *root,\n\t\t\t\t       struct aa_profile *profile)\n{\n\tstruct aa_profile *next = __next_profile(profile);\n\tif (next)\n\t\treturn next;\n\n\t/* finished all profiles in namespace move to next namespace */\n\treturn __first_profile(root, __next_ns(root, profile->ns));\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_profile *next_profile(struct aa_ns *root,\n\t\t\t\t       struct aa_profile *profile)\n{\n\tstruct aa_profile *next = __next_profile(profile);\n\tif (next)\n\t\treturn next;\n\n\t/* finished all profiles in namespace move to next namespace */\n\treturn __first_profile(root, __next_ns(root, profile->ns));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void *p_next(struct seq_file *f, void *p, loff_t *pos)\n{\n\tstruct aa_profile *profile = p;\n\tstruct aa_ns *ns = f->private;\n\t(*pos)++;\n\n\treturn next_profile(ns, profile);\n}"
  },
  {
    "function_name": "p_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2034-2050",
    "snippet": "static void *p_start(struct seq_file *f, loff_t *pos)\n{\n\tstruct aa_profile *profile = NULL;\n\tstruct aa_ns *root = aa_get_current_ns();\n\tloff_t l = *pos;\n\tf->private = root;\n\n\t/* find the first profile */\n\tmutex_lock_nested(&root->lock, root->level);\n\tprofile = __first_profile(root, root);\n\n\t/* skip to position */\n\tfor (; profile && l > 0; l--)\n\t\tprofile = next_profile(root, profile);\n\n\treturn profile;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_profile",
          "args": [
            "root",
            "profile"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "next_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "2014-2023",
          "snippet": "static struct aa_profile *next_profile(struct aa_ns *root,\n\t\t\t\t       struct aa_profile *profile)\n{\n\tstruct aa_profile *next = __next_profile(profile);\n\tif (next)\n\t\treturn next;\n\n\t/* finished all profiles in namespace move to next namespace */\n\treturn __first_profile(root, __next_ns(root, profile->ns));\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_profile *next_profile(struct aa_ns *root,\n\t\t\t\t       struct aa_profile *profile)\n{\n\tstruct aa_profile *next = __next_profile(profile);\n\tif (next)\n\t\treturn next;\n\n\t/* finished all profiles in namespace move to next namespace */\n\treturn __first_profile(root, __next_ns(root, profile->ns));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__first_profile",
          "args": [
            "root",
            "root"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "__first_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1952-1964",
          "snippet": "static struct aa_profile *__first_profile(struct aa_ns *root,\n\t\t\t\t\t  struct aa_ns *ns)\n{\n\tAA_BUG(!root);\n\tAA_BUG(ns && !mutex_is_locked(&ns->lock));\n\n\tfor (; ns; ns = __next_ns(root, ns)) {\n\t\tif (!list_empty(&ns->base.profiles))\n\t\t\treturn list_first_entry(&ns->base.profiles,\n\t\t\t\t\t\tstruct aa_profile, base.list);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_profile *__first_profile(struct aa_ns *root,\n\t\t\t\t\t  struct aa_ns *ns)\n{\n\tAA_BUG(!root);\n\tAA_BUG(ns && !mutex_is_locked(&ns->lock));\n\n\tfor (; ns; ns = __next_ns(root, ns)) {\n\t\tif (!list_empty(&ns->base.profiles))\n\t\t\treturn list_first_entry(&ns->base.profiles,\n\t\t\t\t\t\tstruct aa_profile, base.list);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&root->lock",
            "root->level"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_current_ns",
          "args": [],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_current_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "204-214",
          "snippet": "static inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void *p_start(struct seq_file *f, loff_t *pos)\n{\n\tstruct aa_profile *profile = NULL;\n\tstruct aa_ns *root = aa_get_current_ns();\n\tloff_t l = *pos;\n\tf->private = root;\n\n\t/* find the first profile */\n\tmutex_lock_nested(&root->lock, root->level);\n\tprofile = __first_profile(root, root);\n\n\t/* skip to position */\n\tfor (; profile && l > 0; l--)\n\t\tprofile = next_profile(root, profile);\n\n\treturn profile;\n}"
  },
  {
    "function_name": "next_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "2014-2023",
    "snippet": "static struct aa_profile *next_profile(struct aa_ns *root,\n\t\t\t\t       struct aa_profile *profile)\n{\n\tstruct aa_profile *next = __next_profile(profile);\n\tif (next)\n\t\treturn next;\n\n\t/* finished all profiles in namespace move to next namespace */\n\treturn __first_profile(root, __next_ns(root, profile->ns));\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__first_profile",
          "args": [
            "root",
            "__next_ns(root, profile->ns)"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "__first_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1952-1964",
          "snippet": "static struct aa_profile *__first_profile(struct aa_ns *root,\n\t\t\t\t\t  struct aa_ns *ns)\n{\n\tAA_BUG(!root);\n\tAA_BUG(ns && !mutex_is_locked(&ns->lock));\n\n\tfor (; ns; ns = __next_ns(root, ns)) {\n\t\tif (!list_empty(&ns->base.profiles))\n\t\t\treturn list_first_entry(&ns->base.profiles,\n\t\t\t\t\t\tstruct aa_profile, base.list);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_profile *__first_profile(struct aa_ns *root,\n\t\t\t\t\t  struct aa_ns *ns)\n{\n\tAA_BUG(!root);\n\tAA_BUG(ns && !mutex_is_locked(&ns->lock));\n\n\tfor (; ns; ns = __next_ns(root, ns)) {\n\t\tif (!list_empty(&ns->base.profiles))\n\t\t\treturn list_first_entry(&ns->base.profiles,\n\t\t\t\t\t\tstruct aa_profile, base.list);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__next_ns",
          "args": [
            "root",
            "profile->ns"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "__next_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1913-1942",
          "snippet": "static struct aa_ns *__next_ns(struct aa_ns *root, struct aa_ns *ns)\n{\n\tstruct aa_ns *parent, *next;\n\n\tAA_BUG(!root);\n\tAA_BUG(!ns);\n\tAA_BUG(ns != root && !mutex_is_locked(&ns->parent->lock));\n\n\t/* is next namespace a child */\n\tif (!list_empty(&ns->sub_ns)) {\n\t\tnext = list_first_entry(&ns->sub_ns, typeof(*ns), base.list);\n\t\tmutex_lock_nested(&next->lock, next->level);\n\t\treturn next;\n\t}\n\n\t/* check if the next ns is a sibling, parent, gp, .. */\n\tparent = ns->parent;\n\twhile (ns != root) {\n\t\tmutex_unlock(&ns->lock);\n\t\tnext = list_next_entry(ns, base.list);\n\t\tif (!list_entry_is_head(next, &parent->sub_ns, base.list)) {\n\t\t\tmutex_lock_nested(&next->lock, next->level);\n\t\t\treturn next;\n\t\t}\n\t\tns = parent;\n\t\tparent = parent->parent;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_ns *__next_ns(struct aa_ns *root, struct aa_ns *ns)\n{\n\tstruct aa_ns *parent, *next;\n\n\tAA_BUG(!root);\n\tAA_BUG(!ns);\n\tAA_BUG(ns != root && !mutex_is_locked(&ns->parent->lock));\n\n\t/* is next namespace a child */\n\tif (!list_empty(&ns->sub_ns)) {\n\t\tnext = list_first_entry(&ns->sub_ns, typeof(*ns), base.list);\n\t\tmutex_lock_nested(&next->lock, next->level);\n\t\treturn next;\n\t}\n\n\t/* check if the next ns is a sibling, parent, gp, .. */\n\tparent = ns->parent;\n\twhile (ns != root) {\n\t\tmutex_unlock(&ns->lock);\n\t\tnext = list_next_entry(ns, base.list);\n\t\tif (!list_entry_is_head(next, &parent->sub_ns, base.list)) {\n\t\t\tmutex_lock_nested(&next->lock, next->level);\n\t\t\treturn next;\n\t\t}\n\t\tns = parent;\n\t\tparent = parent->parent;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__next_profile",
          "args": [
            "profile"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "__next_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1975-2005",
          "snippet": "static struct aa_profile *__next_profile(struct aa_profile *p)\n{\n\tstruct aa_profile *parent;\n\tstruct aa_ns *ns = p->ns;\n\n\tAA_BUG(!mutex_is_locked(&profiles_ns(p)->lock));\n\n\t/* is next profile a child */\n\tif (!list_empty(&p->base.profiles))\n\t\treturn list_first_entry(&p->base.profiles, typeof(*p),\n\t\t\t\t\tbase.list);\n\n\t/* is next profile a sibling, parent sibling, gp, sibling, .. */\n\tparent = rcu_dereference_protected(p->parent,\n\t\t\t\t\t   mutex_is_locked(&p->ns->lock));\n\twhile (parent) {\n\t\tp = list_next_entry(p, base.list);\n\t\tif (!list_entry_is_head(p, &parent->base.profiles, base.list))\n\t\t\treturn p;\n\t\tp = parent;\n\t\tparent = rcu_dereference_protected(parent->parent,\n\t\t\t\t\t    mutex_is_locked(&parent->ns->lock));\n\t}\n\n\t/* is next another profile in the namespace */\n\tp = list_next_entry(p, base.list);\n\tif (!list_entry_is_head(p, &ns->base.profiles, base.list))\n\t\treturn p;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_profile *__next_profile(struct aa_profile *p)\n{\n\tstruct aa_profile *parent;\n\tstruct aa_ns *ns = p->ns;\n\n\tAA_BUG(!mutex_is_locked(&profiles_ns(p)->lock));\n\n\t/* is next profile a child */\n\tif (!list_empty(&p->base.profiles))\n\t\treturn list_first_entry(&p->base.profiles, typeof(*p),\n\t\t\t\t\tbase.list);\n\n\t/* is next profile a sibling, parent sibling, gp, sibling, .. */\n\tparent = rcu_dereference_protected(p->parent,\n\t\t\t\t\t   mutex_is_locked(&p->ns->lock));\n\twhile (parent) {\n\t\tp = list_next_entry(p, base.list);\n\t\tif (!list_entry_is_head(p, &parent->base.profiles, base.list))\n\t\t\treturn p;\n\t\tp = parent;\n\t\tparent = rcu_dereference_protected(parent->parent,\n\t\t\t\t\t    mutex_is_locked(&parent->ns->lock));\n\t}\n\n\t/* is next another profile in the namespace */\n\tp = list_next_entry(p, base.list);\n\tif (!list_entry_is_head(p, &ns->base.profiles, base.list))\n\t\treturn p;\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_profile *next_profile(struct aa_ns *root,\n\t\t\t\t       struct aa_profile *profile)\n{\n\tstruct aa_profile *next = __next_profile(profile);\n\tif (next)\n\t\treturn next;\n\n\t/* finished all profiles in namespace move to next namespace */\n\treturn __first_profile(root, __next_ns(root, profile->ns));\n}"
  },
  {
    "function_name": "__next_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1975-2005",
    "snippet": "static struct aa_profile *__next_profile(struct aa_profile *p)\n{\n\tstruct aa_profile *parent;\n\tstruct aa_ns *ns = p->ns;\n\n\tAA_BUG(!mutex_is_locked(&profiles_ns(p)->lock));\n\n\t/* is next profile a child */\n\tif (!list_empty(&p->base.profiles))\n\t\treturn list_first_entry(&p->base.profiles, typeof(*p),\n\t\t\t\t\tbase.list);\n\n\t/* is next profile a sibling, parent sibling, gp, sibling, .. */\n\tparent = rcu_dereference_protected(p->parent,\n\t\t\t\t\t   mutex_is_locked(&p->ns->lock));\n\twhile (parent) {\n\t\tp = list_next_entry(p, base.list);\n\t\tif (!list_entry_is_head(p, &parent->base.profiles, base.list))\n\t\t\treturn p;\n\t\tp = parent;\n\t\tparent = rcu_dereference_protected(parent->parent,\n\t\t\t\t\t    mutex_is_locked(&parent->ns->lock));\n\t}\n\n\t/* is next another profile in the namespace */\n\tp = list_next_entry(p, base.list);\n\tif (!list_entry_is_head(p, &ns->base.profiles, base.list))\n\t\treturn p;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry_is_head",
          "args": [
            "p",
            "&ns->base.profiles",
            "base.list"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "p",
            "base.list"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "parent->parent",
            "mutex_is_locked(&parent->ns->lock)"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&parent->ns->lock"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_is_head",
          "args": [
            "p",
            "&parent->base.profiles",
            "base.list"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "p",
            "base.list"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "p->parent",
            "mutex_is_locked(&p->ns->lock)"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&p->ns->lock"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&p->base.profiles",
            "typeof(*p)",
            "base.list"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&p->base.profiles"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!mutex_is_locked(&profiles_ns(p)->lock)"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&profiles_ns(p)->lock"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profiles_ns",
          "args": [
            "p"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_profile *__next_profile(struct aa_profile *p)\n{\n\tstruct aa_profile *parent;\n\tstruct aa_ns *ns = p->ns;\n\n\tAA_BUG(!mutex_is_locked(&profiles_ns(p)->lock));\n\n\t/* is next profile a child */\n\tif (!list_empty(&p->base.profiles))\n\t\treturn list_first_entry(&p->base.profiles, typeof(*p),\n\t\t\t\t\tbase.list);\n\n\t/* is next profile a sibling, parent sibling, gp, sibling, .. */\n\tparent = rcu_dereference_protected(p->parent,\n\t\t\t\t\t   mutex_is_locked(&p->ns->lock));\n\twhile (parent) {\n\t\tp = list_next_entry(p, base.list);\n\t\tif (!list_entry_is_head(p, &parent->base.profiles, base.list))\n\t\t\treturn p;\n\t\tp = parent;\n\t\tparent = rcu_dereference_protected(parent->parent,\n\t\t\t\t\t    mutex_is_locked(&parent->ns->lock));\n\t}\n\n\t/* is next another profile in the namespace */\n\tp = list_next_entry(p, base.list);\n\tif (!list_entry_is_head(p, &ns->base.profiles, base.list))\n\t\treturn p;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "__first_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1952-1964",
    "snippet": "static struct aa_profile *__first_profile(struct aa_ns *root,\n\t\t\t\t\t  struct aa_ns *ns)\n{\n\tAA_BUG(!root);\n\tAA_BUG(ns && !mutex_is_locked(&ns->lock));\n\n\tfor (; ns; ns = __next_ns(root, ns)) {\n\t\tif (!list_empty(&ns->base.profiles))\n\t\t\treturn list_first_entry(&ns->base.profiles,\n\t\t\t\t\t\tstruct aa_profile, base.list);\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&ns->base.profiles",
            "structaa_profile",
            "base.list"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ns->base.profiles"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__next_ns",
          "args": [
            "root",
            "ns"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "__next_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1913-1942",
          "snippet": "static struct aa_ns *__next_ns(struct aa_ns *root, struct aa_ns *ns)\n{\n\tstruct aa_ns *parent, *next;\n\n\tAA_BUG(!root);\n\tAA_BUG(!ns);\n\tAA_BUG(ns != root && !mutex_is_locked(&ns->parent->lock));\n\n\t/* is next namespace a child */\n\tif (!list_empty(&ns->sub_ns)) {\n\t\tnext = list_first_entry(&ns->sub_ns, typeof(*ns), base.list);\n\t\tmutex_lock_nested(&next->lock, next->level);\n\t\treturn next;\n\t}\n\n\t/* check if the next ns is a sibling, parent, gp, .. */\n\tparent = ns->parent;\n\twhile (ns != root) {\n\t\tmutex_unlock(&ns->lock);\n\t\tnext = list_next_entry(ns, base.list);\n\t\tif (!list_entry_is_head(next, &parent->sub_ns, base.list)) {\n\t\t\tmutex_lock_nested(&next->lock, next->level);\n\t\t\treturn next;\n\t\t}\n\t\tns = parent;\n\t\tparent = parent->parent;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_ns *__next_ns(struct aa_ns *root, struct aa_ns *ns)\n{\n\tstruct aa_ns *parent, *next;\n\n\tAA_BUG(!root);\n\tAA_BUG(!ns);\n\tAA_BUG(ns != root && !mutex_is_locked(&ns->parent->lock));\n\n\t/* is next namespace a child */\n\tif (!list_empty(&ns->sub_ns)) {\n\t\tnext = list_first_entry(&ns->sub_ns, typeof(*ns), base.list);\n\t\tmutex_lock_nested(&next->lock, next->level);\n\t\treturn next;\n\t}\n\n\t/* check if the next ns is a sibling, parent, gp, .. */\n\tparent = ns->parent;\n\twhile (ns != root) {\n\t\tmutex_unlock(&ns->lock);\n\t\tnext = list_next_entry(ns, base.list);\n\t\tif (!list_entry_is_head(next, &parent->sub_ns, base.list)) {\n\t\t\tmutex_lock_nested(&next->lock, next->level);\n\t\t\treturn next;\n\t\t}\n\t\tns = parent;\n\t\tparent = parent->parent;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "ns && !mutex_is_locked(&ns->lock)"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&ns->lock"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!root"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_profile *__first_profile(struct aa_ns *root,\n\t\t\t\t\t  struct aa_ns *ns)\n{\n\tAA_BUG(!root);\n\tAA_BUG(ns && !mutex_is_locked(&ns->lock));\n\n\tfor (; ns; ns = __next_ns(root, ns)) {\n\t\tif (!list_empty(&ns->base.profiles))\n\t\t\treturn list_first_entry(&ns->base.profiles,\n\t\t\t\t\t\tstruct aa_profile, base.list);\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "__next_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1913-1942",
    "snippet": "static struct aa_ns *__next_ns(struct aa_ns *root, struct aa_ns *ns)\n{\n\tstruct aa_ns *parent, *next;\n\n\tAA_BUG(!root);\n\tAA_BUG(!ns);\n\tAA_BUG(ns != root && !mutex_is_locked(&ns->parent->lock));\n\n\t/* is next namespace a child */\n\tif (!list_empty(&ns->sub_ns)) {\n\t\tnext = list_first_entry(&ns->sub_ns, typeof(*ns), base.list);\n\t\tmutex_lock_nested(&next->lock, next->level);\n\t\treturn next;\n\t}\n\n\t/* check if the next ns is a sibling, parent, gp, .. */\n\tparent = ns->parent;\n\twhile (ns != root) {\n\t\tmutex_unlock(&ns->lock);\n\t\tnext = list_next_entry(ns, base.list);\n\t\tif (!list_entry_is_head(next, &parent->sub_ns, base.list)) {\n\t\t\tmutex_lock_nested(&next->lock, next->level);\n\t\t\treturn next;\n\t\t}\n\t\tns = parent;\n\t\tparent = parent->parent;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&next->lock",
            "next->level"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_is_head",
          "args": [
            "next",
            "&parent->sub_ns",
            "base.list"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "ns",
            "base.list"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ns->lock"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&next->lock",
            "next->level"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&ns->sub_ns",
            "typeof(*ns)",
            "base.list"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ns"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ns->sub_ns"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "ns != root && !mutex_is_locked(&ns->parent->lock)"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&ns->parent->lock"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ns"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!root"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_ns *__next_ns(struct aa_ns *root, struct aa_ns *ns)\n{\n\tstruct aa_ns *parent, *next;\n\n\tAA_BUG(!root);\n\tAA_BUG(!ns);\n\tAA_BUG(ns != root && !mutex_is_locked(&ns->parent->lock));\n\n\t/* is next namespace a child */\n\tif (!list_empty(&ns->sub_ns)) {\n\t\tnext = list_first_entry(&ns->sub_ns, typeof(*ns), base.list);\n\t\tmutex_lock_nested(&next->lock, next->level);\n\t\treturn next;\n\t}\n\n\t/* check if the next ns is a sibling, parent, gp, .. */\n\tparent = ns->parent;\n\twhile (ns != root) {\n\t\tmutex_unlock(&ns->lock);\n\t\tnext = list_next_entry(ns, base.list);\n\t\tif (!list_entry_is_head(next, &parent->sub_ns, base.list)) {\n\t\t\tmutex_lock_nested(&next->lock, next->level);\n\t\t\treturn next;\n\t\t}\n\t\tns = parent;\n\t\tparent = parent->parent;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "__aafs_ns_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1844-1896",
    "snippet": "int __aafs_ns_mkdir(struct aa_ns *ns, struct dentry *parent, const char *name,\n\t\t    struct dentry *dent)\n{\n\tstruct aa_ns *sub;\n\tstruct aa_profile *child;\n\tstruct dentry *dir;\n\tint error;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!parent);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tif (!name)\n\t\tname = ns->base.name;\n\n\tif (!dent) {\n\t\t/* create ns dir if it doesn't already exist */\n\t\tdent = aafs_create_dir(name, parent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t} else\n\t\tdget(dent);\n\tns_dir(ns) = dir = dent;\n\terror = __aafs_ns_mkdir_entries(ns, dir);\n\tif (error)\n\t\tgoto fail2;\n\n\t/* profiles */\n\tlist_for_each_entry(child, &ns->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, ns_subprofs_dir(ns));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\t/* subnamespaces */\n\tlist_for_each_entry(sub, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&sub->lock, sub->level);\n\t\terror = __aafs_ns_mkdir(sub, ns_subns_dir(ns), NULL, NULL);\n\t\tmutex_unlock(&sub->lock);\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_ns_rmdir(ns);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__aafs_ns_rmdir",
          "args": [
            "ns"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "__aafs_ns_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1736-1782",
          "snippet": "void __aafs_ns_rmdir(struct aa_ns *ns)\n{\n\tstruct aa_ns *sub;\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!ns)\n\t\treturn;\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tlist_for_each_entry(child, &ns->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tlist_for_each_entry(sub, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&sub->lock, sub->level);\n\t\t__aafs_ns_rmdir(sub);\n\t\tmutex_unlock(&sub->lock);\n\t}\n\n\t__aa_fs_list_remove_rawdata(ns);\n\n\tif (ns_subns_dir(ns)) {\n\t\tsub = d_inode(ns_subns_dir(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subload(ns)) {\n\t\tsub = d_inode(ns_subload(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subreplace(ns)) {\n\t\tsub = d_inode(ns_subreplace(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subremove(ns)) {\n\t\tsub = d_inode(ns_subremove(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subrevision(ns)) {\n\t\tsub = d_inode(ns_subrevision(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\n\tfor (i = AAFS_NS_SIZEOF - 1; i >= 0; --i) {\n\t\taafs_remove(ns->dents[i]);\n\t\tns->dents[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nvoid __aafs_ns_rmdir(struct aa_ns *ns)\n{\n\tstruct aa_ns *sub;\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!ns)\n\t\treturn;\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tlist_for_each_entry(child, &ns->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tlist_for_each_entry(sub, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&sub->lock, sub->level);\n\t\t__aafs_ns_rmdir(sub);\n\t\tmutex_unlock(&sub->lock);\n\t}\n\n\t__aa_fs_list_remove_rawdata(ns);\n\n\tif (ns_subns_dir(ns)) {\n\t\tsub = d_inode(ns_subns_dir(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subload(ns)) {\n\t\tsub = d_inode(ns_subload(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subreplace(ns)) {\n\t\tsub = d_inode(ns_subreplace(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subremove(ns)) {\n\t\tsub = d_inode(ns_subremove(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subrevision(ns)) {\n\t\tsub = d_inode(ns_subrevision(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\n\tfor (i = AAFS_NS_SIZEOF - 1; i >= 0; --i) {\n\t\taafs_remove(ns->dents[i]);\n\t\tns->dents[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sub->lock"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aafs_ns_mkdir",
          "args": [
            "sub",
            "ns_subns_dir(ns)",
            "NULL",
            "NULL"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "__aafs_ns_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1844-1896",
          "snippet": "int __aafs_ns_mkdir(struct aa_ns *ns, struct dentry *parent, const char *name,\n\t\t    struct dentry *dent)\n{\n\tstruct aa_ns *sub;\n\tstruct aa_profile *child;\n\tstruct dentry *dir;\n\tint error;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!parent);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tif (!name)\n\t\tname = ns->base.name;\n\n\tif (!dent) {\n\t\t/* create ns dir if it doesn't already exist */\n\t\tdent = aafs_create_dir(name, parent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t} else\n\t\tdget(dent);\n\tns_dir(ns) = dir = dent;\n\terror = __aafs_ns_mkdir_entries(ns, dir);\n\tif (error)\n\t\tgoto fail2;\n\n\t/* profiles */\n\tlist_for_each_entry(child, &ns->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, ns_subprofs_dir(ns));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\t/* subnamespaces */\n\tlist_for_each_entry(sub, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&sub->lock, sub->level);\n\t\terror = __aafs_ns_mkdir(sub, ns_subns_dir(ns), NULL, NULL);\n\t\tmutex_unlock(&sub->lock);\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_ns_rmdir(ns);\n\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ns_subns_dir",
          "args": [
            "ns"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&sub->lock",
            "sub->level"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sub",
            "&ns->sub_ns",
            "base.list"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aafs_profile_mkdir",
          "args": [
            "child",
            "ns_subprofs_dir(ns)"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "__aafs_profile_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1510-1623",
          "snippet": "int __aafs_profile_mkdir(struct aa_profile *profile, struct dentry *parent)\n{\n\tstruct aa_profile *child;\n\tstruct dentry *dent = NULL, *dir;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mutex_is_locked(&profiles_ns(profile)->lock));\n\n\tif (!parent) {\n\t\tstruct aa_profile *p;\n\t\tp = aa_deref_parent(profile);\n\t\tdent = prof_dir(p);\n\t\t/* adding to parent that previously didn't have children */\n\t\tdent = aafs_create_dir(\"profiles\", dent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprof_child_dir(p) = parent = dent;\n\t}\n\n\tif (!profile->dirname) {\n\t\tint len, id_len;\n\t\tlen = mangle_name(profile->base.name, NULL);\n\t\tid_len = snprintf(NULL, 0, \".%ld\", profile->ns->uniq_id);\n\n\t\tprofile->dirname = kmalloc(len + id_len + 1, GFP_KERNEL);\n\t\tif (!profile->dirname) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tmangle_name(profile->base.name, profile->dirname);\n\t\tsprintf(profile->dirname + len, \".%ld\", profile->ns->uniq_id++);\n\t}\n\n\tdent = aafs_create_dir(profile->dirname, parent);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprof_dir(profile) = dir = dent;\n\n\tdent = create_profile_file(dir, \"name\", profile,\n\t\t\t\t   &seq_profile_name_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_NAME] = dent;\n\n\tdent = create_profile_file(dir, \"mode\", profile,\n\t\t\t\t   &seq_profile_mode_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_MODE] = dent;\n\n\tdent = create_profile_file(dir, \"attach\", profile,\n\t\t\t\t   &seq_profile_attach_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_ATTACH] = dent;\n\n\tif (profile->hash) {\n\t\tdent = create_profile_file(dir, \"sha1\", profile,\n\t\t\t\t\t   &seq_profile_hash_fops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_HASH] = dent;\n\t}\n\n\tif (profile->rawdata) {\n\t\tchar target[64];\n\t\tint depth = profile_depth(profile);\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"sha1\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_sha1\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_HASH] = dent;\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"abi\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_abi\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_ABI] = dent;\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"raw_data\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_data\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_DATA] = dent;\n\t}\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, prof_child_dir(profile));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_profile_rmdir(profile);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nint __aafs_profile_mkdir(struct aa_profile *profile, struct dentry *parent)\n{\n\tstruct aa_profile *child;\n\tstruct dentry *dent = NULL, *dir;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mutex_is_locked(&profiles_ns(profile)->lock));\n\n\tif (!parent) {\n\t\tstruct aa_profile *p;\n\t\tp = aa_deref_parent(profile);\n\t\tdent = prof_dir(p);\n\t\t/* adding to parent that previously didn't have children */\n\t\tdent = aafs_create_dir(\"profiles\", dent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprof_child_dir(p) = parent = dent;\n\t}\n\n\tif (!profile->dirname) {\n\t\tint len, id_len;\n\t\tlen = mangle_name(profile->base.name, NULL);\n\t\tid_len = snprintf(NULL, 0, \".%ld\", profile->ns->uniq_id);\n\n\t\tprofile->dirname = kmalloc(len + id_len + 1, GFP_KERNEL);\n\t\tif (!profile->dirname) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tmangle_name(profile->base.name, profile->dirname);\n\t\tsprintf(profile->dirname + len, \".%ld\", profile->ns->uniq_id++);\n\t}\n\n\tdent = aafs_create_dir(profile->dirname, parent);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprof_dir(profile) = dir = dent;\n\n\tdent = create_profile_file(dir, \"name\", profile,\n\t\t\t\t   &seq_profile_name_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_NAME] = dent;\n\n\tdent = create_profile_file(dir, \"mode\", profile,\n\t\t\t\t   &seq_profile_mode_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_MODE] = dent;\n\n\tdent = create_profile_file(dir, \"attach\", profile,\n\t\t\t\t   &seq_profile_attach_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_ATTACH] = dent;\n\n\tif (profile->hash) {\n\t\tdent = create_profile_file(dir, \"sha1\", profile,\n\t\t\t\t\t   &seq_profile_hash_fops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_HASH] = dent;\n\t}\n\n\tif (profile->rawdata) {\n\t\tchar target[64];\n\t\tint depth = profile_depth(profile);\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"sha1\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_sha1\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_HASH] = dent;\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"abi\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_abi\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_ABI] = dent;\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"raw_data\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_data\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_DATA] = dent;\n\t}\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, prof_child_dir(profile));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_profile_rmdir(profile);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_subprofs_dir",
          "args": [
            "ns"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&ns->base.profiles",
            "base.list"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aafs_ns_mkdir_entries",
          "args": [
            "ns",
            "dir"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "__aafs_ns_mkdir_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1785-1839",
          "snippet": "static int __aafs_ns_mkdir_entries(struct aa_ns *ns, struct dentry *dir)\n{\n\tstruct dentry *dent;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!dir);\n\n\tdent = aafs_create_dir(\"profiles\", dir);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\tns_subprofs_dir(ns) = dent;\n\n\tdent = aafs_create_dir(\"raw_data\", dir);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\tns_subdata_dir(ns) = dent;\n\n\tdent = aafs_create_file(\"revision\", 0444, dir, ns,\n\t\t\t\t&aa_fs_ns_revision_fops);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subrevision(ns) = dent;\n\n\tdent = aafs_create_file(\".load\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_load);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subload(ns) = dent;\n\n\tdent = aafs_create_file(\".replace\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_replace);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subreplace(ns) = dent;\n\n\tdent = aafs_create_file(\".remove\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_remove);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subremove(ns) = dent;\n\n\t  /* use create_dentry so we can supply private data */\n\tdent = aafs_create(\"namespaces\", S_IFDIR | 0755, dir, ns, NULL, NULL,\n\t\t\t   &ns_dir_inode_operations);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subns_dir(ns) = dent;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations aa_fs_profile_load = {\n\t.write = profile_load,\n\t.llseek = default_llseek,\n};",
            "static const struct file_operations aa_fs_profile_replace = {\n\t.write = profile_replace,\n\t.llseek = default_llseek,\n};",
            "static const struct file_operations aa_fs_profile_remove = {\n\t.write = profile_remove,\n\t.llseek = default_llseek,\n};",
            "static const struct file_operations aa_fs_ns_revision_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ns_revision_open,\n\t.poll\t\t= ns_revision_poll,\n\t.read\t\t= ns_revision_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= ns_revision_release,\n};",
            "static const struct inode_operations ns_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.mkdir\t\t= ns_mkdir_op,\n\t.rmdir\t\t= ns_rmdir_op,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic const struct file_operations aa_fs_profile_load = {\n\t.write = profile_load,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations aa_fs_profile_replace = {\n\t.write = profile_replace,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations aa_fs_profile_remove = {\n\t.write = profile_remove,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations aa_fs_ns_revision_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ns_revision_open,\n\t.poll\t\t= ns_revision_poll,\n\t.read\t\t= ns_revision_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= ns_revision_release,\n};\nstatic const struct inode_operations ns_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.mkdir\t\t= ns_mkdir_op,\n\t.rmdir\t\t= ns_rmdir_op,\n};\n\nstatic int __aafs_ns_mkdir_entries(struct aa_ns *ns, struct dentry *dir)\n{\n\tstruct dentry *dent;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!dir);\n\n\tdent = aafs_create_dir(\"profiles\", dir);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\tns_subprofs_dir(ns) = dent;\n\n\tdent = aafs_create_dir(\"raw_data\", dir);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\tns_subdata_dir(ns) = dent;\n\n\tdent = aafs_create_file(\"revision\", 0444, dir, ns,\n\t\t\t\t&aa_fs_ns_revision_fops);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subrevision(ns) = dent;\n\n\tdent = aafs_create_file(\".load\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_load);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subload(ns) = dent;\n\n\tdent = aafs_create_file(\".replace\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_replace);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subreplace(ns) = dent;\n\n\tdent = aafs_create_file(\".remove\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_remove);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subremove(ns) = dent;\n\n\t  /* use create_dentry so we can supply private data */\n\tdent = aafs_create(\"namespaces\", S_IFDIR | 0755, dir, ns, NULL, NULL,\n\t\t\t   &ns_dir_inode_operations);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subns_dir(ns) = dent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_dir",
          "args": [
            "ns"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dent"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aafs_create_dir",
          "args": [
            "name",
            "parent"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "305-309",
          "snippet": "static struct dentry *aafs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn aafs_create(name, S_IFDIR | 0755, parent, NULL, NULL, NULL,\n\t\t\t   NULL);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *aafs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn aafs_create(name, S_IFDIR | 0755, parent, NULL, NULL, NULL,\n\t\t\t   NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!mutex_is_locked(&ns->lock)"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&ns->lock"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!parent"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ns"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nint __aafs_ns_mkdir(struct aa_ns *ns, struct dentry *parent, const char *name,\n\t\t    struct dentry *dent)\n{\n\tstruct aa_ns *sub;\n\tstruct aa_profile *child;\n\tstruct dentry *dir;\n\tint error;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!parent);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tif (!name)\n\t\tname = ns->base.name;\n\n\tif (!dent) {\n\t\t/* create ns dir if it doesn't already exist */\n\t\tdent = aafs_create_dir(name, parent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t} else\n\t\tdget(dent);\n\tns_dir(ns) = dir = dent;\n\terror = __aafs_ns_mkdir_entries(ns, dir);\n\tif (error)\n\t\tgoto fail2;\n\n\t/* profiles */\n\tlist_for_each_entry(child, &ns->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, ns_subprofs_dir(ns));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\t/* subnamespaces */\n\tlist_for_each_entry(sub, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&sub->lock, sub->level);\n\t\terror = __aafs_ns_mkdir(sub, ns_subns_dir(ns), NULL, NULL);\n\t\tmutex_unlock(&sub->lock);\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_ns_rmdir(ns);\n\n\treturn error;\n}"
  },
  {
    "function_name": "__aafs_ns_mkdir_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1785-1839",
    "snippet": "static int __aafs_ns_mkdir_entries(struct aa_ns *ns, struct dentry *dir)\n{\n\tstruct dentry *dent;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!dir);\n\n\tdent = aafs_create_dir(\"profiles\", dir);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\tns_subprofs_dir(ns) = dent;\n\n\tdent = aafs_create_dir(\"raw_data\", dir);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\tns_subdata_dir(ns) = dent;\n\n\tdent = aafs_create_file(\"revision\", 0444, dir, ns,\n\t\t\t\t&aa_fs_ns_revision_fops);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subrevision(ns) = dent;\n\n\tdent = aafs_create_file(\".load\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_load);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subload(ns) = dent;\n\n\tdent = aafs_create_file(\".replace\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_replace);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subreplace(ns) = dent;\n\n\tdent = aafs_create_file(\".remove\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_remove);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subremove(ns) = dent;\n\n\t  /* use create_dentry so we can supply private data */\n\tdent = aafs_create(\"namespaces\", S_IFDIR | 0755, dir, ns, NULL, NULL,\n\t\t\t   &ns_dir_inode_operations);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subns_dir(ns) = dent;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations aa_fs_profile_load = {\n\t.write = profile_load,\n\t.llseek = default_llseek,\n};",
      "static const struct file_operations aa_fs_profile_replace = {\n\t.write = profile_replace,\n\t.llseek = default_llseek,\n};",
      "static const struct file_operations aa_fs_profile_remove = {\n\t.write = profile_remove,\n\t.llseek = default_llseek,\n};",
      "static const struct file_operations aa_fs_ns_revision_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ns_revision_open,\n\t.poll\t\t= ns_revision_poll,\n\t.read\t\t= ns_revision_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= ns_revision_release,\n};",
      "static const struct inode_operations ns_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.mkdir\t\t= ns_mkdir_op,\n\t.rmdir\t\t= ns_rmdir_op,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_subns_dir",
          "args": [
            "ns"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_ns",
          "args": [
            "ns"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "116-122",
          "snippet": "static inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aafs_create",
          "args": [
            "\"namespaces\"",
            "S_IFDIR | 0755",
            "dir",
            "ns",
            "NULL",
            "NULL",
            "&ns_dir_inode_operations"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "229-277",
          "snippet": "static struct dentry *aafs_create(const char *name, umode_t mode,\n\t\t\t\t  struct dentry *parent, void *data, void *link,\n\t\t\t\t  const struct file_operations *fops,\n\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tint error;\n\n\tAA_BUG(!name);\n\tAA_BUG(!parent);\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto fail_lock;\n\t}\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto fail_dentry;\n\t}\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode, data, link, fops, iops);\n\tif (error)\n\t\tgoto fail_dentry;\n\tinode_unlock(dir);\n\n\treturn dentry;\n\nfail_dentry:\n\tdput(dentry);\n\nfail_lock:\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *aafs_mnt;",
            "static int aafs_count;",
            "static struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct vfsmount *aafs_mnt;\nstatic int aafs_count;\nstatic struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};\n\nstatic struct dentry *aafs_create(const char *name, umode_t mode,\n\t\t\t\t  struct dentry *parent, void *data, void *link,\n\t\t\t\t  const struct file_operations *fops,\n\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tint error;\n\n\tAA_BUG(!name);\n\tAA_BUG(!parent);\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto fail_lock;\n\t}\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto fail_dentry;\n\t}\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode, data, link, fops, iops);\n\tif (error)\n\t\tgoto fail_dentry;\n\tinode_unlock(dir);\n\n\treturn dentry;\n\nfail_dentry:\n\tdput(dentry);\n\nfail_lock:\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_subremove",
          "args": [
            "ns"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aafs_create_file",
          "args": [
            "\".remove\"",
            "0640",
            "dir",
            "ns",
            "&aa_fs_profile_remove"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "290-295",
          "snippet": "static struct dentry *aafs_create_file(const char *name, umode_t mode,\n\t\t\t\t       struct dentry *parent, void *data,\n\t\t\t\t       const struct file_operations *fops)\n{\n\treturn aafs_create(name, mode, parent, data, NULL, fops, NULL);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *aafs_create_file(const char *name, umode_t mode,\n\t\t\t\t       struct dentry *parent, void *data,\n\t\t\t\t       const struct file_operations *fops)\n{\n\treturn aafs_create(name, mode, parent, data, NULL, fops, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_subreplace",
          "args": [
            "ns"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subload",
          "args": [
            "ns"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subrevision",
          "args": [
            "ns"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subdata_dir",
          "args": [
            "ns"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aafs_create_dir",
          "args": [
            "\"raw_data\"",
            "dir"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "305-309",
          "snippet": "static struct dentry *aafs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn aafs_create(name, S_IFDIR | 0755, parent, NULL, NULL, NULL,\n\t\t\t   NULL);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *aafs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn aafs_create(name, S_IFDIR | 0755, parent, NULL, NULL, NULL,\n\t\t\t   NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_subprofs_dir",
          "args": [
            "ns"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!dir"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ns"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic const struct file_operations aa_fs_profile_load = {\n\t.write = profile_load,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations aa_fs_profile_replace = {\n\t.write = profile_replace,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations aa_fs_profile_remove = {\n\t.write = profile_remove,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations aa_fs_ns_revision_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ns_revision_open,\n\t.poll\t\t= ns_revision_poll,\n\t.read\t\t= ns_revision_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= ns_revision_release,\n};\nstatic const struct inode_operations ns_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n\t.mkdir\t\t= ns_mkdir_op,\n\t.rmdir\t\t= ns_rmdir_op,\n};\n\nstatic int __aafs_ns_mkdir_entries(struct aa_ns *ns, struct dentry *dir)\n{\n\tstruct dentry *dent;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!dir);\n\n\tdent = aafs_create_dir(\"profiles\", dir);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\tns_subprofs_dir(ns) = dent;\n\n\tdent = aafs_create_dir(\"raw_data\", dir);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\tns_subdata_dir(ns) = dent;\n\n\tdent = aafs_create_file(\"revision\", 0444, dir, ns,\n\t\t\t\t&aa_fs_ns_revision_fops);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subrevision(ns) = dent;\n\n\tdent = aafs_create_file(\".load\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_load);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subload(ns) = dent;\n\n\tdent = aafs_create_file(\".replace\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_replace);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subreplace(ns) = dent;\n\n\tdent = aafs_create_file(\".remove\", 0640, dir, ns,\n\t\t\t\t      &aa_fs_profile_remove);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subremove(ns) = dent;\n\n\t  /* use create_dentry so we can supply private data */\n\tdent = aafs_create(\"namespaces\", S_IFDIR | 0755, dir, ns, NULL, NULL,\n\t\t\t   &ns_dir_inode_operations);\n\tif (IS_ERR(dent))\n\t\treturn PTR_ERR(dent);\n\taa_get_ns(ns);\n\tns_subns_dir(ns) = dent;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__aafs_ns_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1736-1782",
    "snippet": "void __aafs_ns_rmdir(struct aa_ns *ns)\n{\n\tstruct aa_ns *sub;\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!ns)\n\t\treturn;\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tlist_for_each_entry(child, &ns->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tlist_for_each_entry(sub, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&sub->lock, sub->level);\n\t\t__aafs_ns_rmdir(sub);\n\t\tmutex_unlock(&sub->lock);\n\t}\n\n\t__aa_fs_list_remove_rawdata(ns);\n\n\tif (ns_subns_dir(ns)) {\n\t\tsub = d_inode(ns_subns_dir(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subload(ns)) {\n\t\tsub = d_inode(ns_subload(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subreplace(ns)) {\n\t\tsub = d_inode(ns_subreplace(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subremove(ns)) {\n\t\tsub = d_inode(ns_subremove(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subrevision(ns)) {\n\t\tsub = d_inode(ns_subrevision(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\n\tfor (i = AAFS_NS_SIZEOF - 1; i >= 0; --i) {\n\t\taafs_remove(ns->dents[i]);\n\t\tns->dents[i] = NULL;\n\t}\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aafs_remove",
          "args": [
            "ns->dents[i]"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "347-365",
          "snippet": "static void aafs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *aafs_mnt;",
            "static int aafs_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct vfsmount *aafs_mnt;\nstatic int aafs_count;\n\nstatic void aafs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "sub"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "ns_subrevision(ns)"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subrevision",
          "args": [
            "ns"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subrevision",
          "args": [
            "ns"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "ns_subremove(ns)"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subremove",
          "args": [
            "ns"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subremove",
          "args": [
            "ns"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "ns_subreplace(ns)"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subreplace",
          "args": [
            "ns"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subreplace",
          "args": [
            "ns"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "ns_subload(ns)"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subload",
          "args": [
            "ns"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subload",
          "args": [
            "ns"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "ns_subns_dir(ns)"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subns_dir",
          "args": [
            "ns"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subns_dir",
          "args": [
            "ns"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aa_fs_list_remove_rawdata",
          "args": [
            "ns"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_fs_list_remove_rawdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1722-1730",
          "snippet": "static void __aa_fs_list_remove_rawdata(struct aa_ns *ns)\n{\n\tstruct aa_loaddata *ent, *tmp;\n\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tlist_for_each_entry_safe(ent, tmp, &ns->rawdata_list, list)\n\t\t__aa_fs_remove_rawdata(ent);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void __aa_fs_list_remove_rawdata(struct aa_ns *ns)\n{\n\tstruct aa_loaddata *ent, *tmp;\n\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tlist_for_each_entry_safe(ent, tmp, &ns->rawdata_list, list)\n\t\t__aa_fs_remove_rawdata(ent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sub->lock"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aafs_ns_rmdir",
          "args": [
            "sub"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "__aafs_ns_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1736-1782",
          "snippet": "void __aafs_ns_rmdir(struct aa_ns *ns)\n{\n\tstruct aa_ns *sub;\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!ns)\n\t\treturn;\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tlist_for_each_entry(child, &ns->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tlist_for_each_entry(sub, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&sub->lock, sub->level);\n\t\t__aafs_ns_rmdir(sub);\n\t\tmutex_unlock(&sub->lock);\n\t}\n\n\t__aa_fs_list_remove_rawdata(ns);\n\n\tif (ns_subns_dir(ns)) {\n\t\tsub = d_inode(ns_subns_dir(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subload(ns)) {\n\t\tsub = d_inode(ns_subload(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subreplace(ns)) {\n\t\tsub = d_inode(ns_subreplace(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subremove(ns)) {\n\t\tsub = d_inode(ns_subremove(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subrevision(ns)) {\n\t\tsub = d_inode(ns_subrevision(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\n\tfor (i = AAFS_NS_SIZEOF - 1; i >= 0; --i) {\n\t\taafs_remove(ns->dents[i]);\n\t\tns->dents[i] = NULL;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&sub->lock",
            "sub->level"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sub",
            "&ns->sub_ns",
            "base.list"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aafs_profile_rmdir",
          "args": [
            "child"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "__aafs_profile_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1417-1438",
          "snippet": "void __aafs_profile_rmdir(struct aa_profile *profile)\n{\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!profile)\n\t\treturn;\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tfor (i = AAFS_PROF_SIZEOF - 1; i >= 0; --i) {\n\t\tstruct aa_proxy *proxy;\n\t\tif (!profile->dents[i])\n\t\t\tcontinue;\n\n\t\tproxy = d_inode(profile->dents[i])->i_private;\n\t\taafs_remove(profile->dents[i]);\n\t\taa_put_proxy(proxy);\n\t\tprofile->dents[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nvoid __aafs_profile_rmdir(struct aa_profile *profile)\n{\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!profile)\n\t\treturn;\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tfor (i = AAFS_PROF_SIZEOF - 1; i >= 0; --i) {\n\t\tstruct aa_proxy *proxy;\n\t\tif (!profile->dents[i])\n\t\t\tcontinue;\n\n\t\tproxy = d_inode(profile->dents[i])->i_private;\n\t\taafs_remove(profile->dents[i]);\n\t\taa_put_proxy(proxy);\n\t\tprofile->dents[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&ns->base.profiles",
            "base.list"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!mutex_is_locked(&ns->lock)"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&ns->lock"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nvoid __aafs_ns_rmdir(struct aa_ns *ns)\n{\n\tstruct aa_ns *sub;\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!ns)\n\t\treturn;\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tlist_for_each_entry(child, &ns->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tlist_for_each_entry(sub, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&sub->lock, sub->level);\n\t\t__aafs_ns_rmdir(sub);\n\t\tmutex_unlock(&sub->lock);\n\t}\n\n\t__aa_fs_list_remove_rawdata(ns);\n\n\tif (ns_subns_dir(ns)) {\n\t\tsub = d_inode(ns_subns_dir(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subload(ns)) {\n\t\tsub = d_inode(ns_subload(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subreplace(ns)) {\n\t\tsub = d_inode(ns_subreplace(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subremove(ns)) {\n\t\tsub = d_inode(ns_subremove(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\tif (ns_subrevision(ns)) {\n\t\tsub = d_inode(ns_subrevision(ns))->i_private;\n\t\taa_put_ns(sub);\n\t}\n\n\tfor (i = AAFS_NS_SIZEOF - 1; i >= 0; --i) {\n\t\taafs_remove(ns->dents[i]);\n\t\tns->dents[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "__aa_fs_list_remove_rawdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1722-1730",
    "snippet": "static void __aa_fs_list_remove_rawdata(struct aa_ns *ns)\n{\n\tstruct aa_loaddata *ent, *tmp;\n\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tlist_for_each_entry_safe(ent, tmp, &ns->rawdata_list, list)\n\t\t__aa_fs_remove_rawdata(ent);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__aa_fs_remove_rawdata",
          "args": [
            "ent"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_fs_remove_rawdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1336-1346",
          "snippet": "void __aa_fs_remove_rawdata(struct aa_loaddata *rawdata)\n{\n\tAA_BUG(rawdata->ns && !mutex_is_locked(&rawdata->ns->lock));\n\n\tif (rawdata->ns) {\n\t\tremove_rawdata_dents(rawdata);\n\t\tlist_del_init(&rawdata->list);\n\t\taa_put_ns(rawdata->ns);\n\t\trawdata->ns = NULL;\n\t}\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nvoid __aa_fs_remove_rawdata(struct aa_loaddata *rawdata)\n{\n\tAA_BUG(rawdata->ns && !mutex_is_locked(&rawdata->ns->lock));\n\n\tif (rawdata->ns) {\n\t\tremove_rawdata_dents(rawdata);\n\t\tlist_del_init(&rawdata->list);\n\t\taa_put_ns(rawdata->ns);\n\t\trawdata->ns = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ent",
            "tmp",
            "&ns->rawdata_list",
            "list"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!mutex_is_locked(&ns->lock)"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&ns->lock"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void __aa_fs_list_remove_rawdata(struct aa_ns *ns)\n{\n\tstruct aa_loaddata *ent, *tmp;\n\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tlist_for_each_entry_safe(ent, tmp, &ns->rawdata_list, list)\n\t\t__aa_fs_remove_rawdata(ent);\n}"
  },
  {
    "function_name": "ns_rmdir_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1674-1714",
    "snippet": "static int ns_rmdir_op(struct inode *dir, struct dentry *dentry)\n{\n\tstruct aa_ns *ns, *parent;\n\t/* TODO: improve permission check */\n\tstruct aa_label *label;\n\tint error;\n\n\tlabel = begin_current_label_crit_section();\n\terror = aa_may_manage_policy(label, NULL, AA_MAY_LOAD_POLICY);\n\tend_current_label_crit_section(label);\n\tif (error)\n\t\treturn error;\n\n\t parent = aa_get_ns(dir->i_private);\n\t/* rmdir calls the generic securityfs functions to remove files\n\t * from the apparmor dir. It is up to the apparmor ns locking\n\t * to avoid races.\n\t */\n\tinode_unlock(dir);\n\tinode_unlock(dentry->d_inode);\n\n\tmutex_lock_nested(&parent->lock, parent->level);\n\tns = aa_get_ns(__aa_findn_ns(&parent->sub_ns, dentry->d_name.name,\n\t\t\t\t     dentry->d_name.len));\n\tif (!ns) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\tAA_BUG(ns_dir(ns) != dentry);\n\n\t__aa_remove_ns(ns);\n\taa_put_ns(ns);\n\nout:\n\tmutex_unlock(&parent->lock);\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tinode_lock(dentry->d_inode);\n\taa_put_ns(parent);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "parent"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock_nested",
          "args": [
            "dir",
            "I_MUTEX_PARENT"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&parent->lock"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aa_remove_ns",
          "args": [
            "ns"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_remove_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "364-370",
          "snippet": "void __aa_remove_ns(struct aa_ns *ns)\n{\n\t/* remove ns from namespace list */\n\tlist_del_rcu(&ns->base.list);\n\tdestroy_ns(ns);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nvoid __aa_remove_ns(struct aa_ns *ns)\n{\n\t/* remove ns from namespace list */\n\tlist_del_rcu(&ns->base.list);\n\tdestroy_ns(ns);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "ns_dir(ns) != dentry"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_dir",
          "args": [
            "ns"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_ns",
          "args": [
            "__aa_findn_ns(&parent->sub_ns, dentry->d_name.name,\n\t\t\t\t     dentry->d_name.len)"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "116-122",
          "snippet": "static inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__aa_findn_ns",
          "args": [
            "&parent->sub_ns",
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_findn_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "145-149",
          "snippet": "static inline struct aa_ns *__aa_findn_ns(struct list_head *head,\n\t\t\t\t\t  const char *name, size_t n)\n{\n\treturn (struct aa_ns *)__policy_strn_find(head, name, n);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline struct aa_ns *__aa_findn_ns(struct list_head *head,\n\t\t\t\t\t  const char *name, size_t n)\n{\n\treturn (struct aa_ns *)__policy_strn_find(head, name, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&parent->lock",
            "parent->level"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "dir"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_may_manage_policy",
          "args": [
            "label",
            "NULL",
            "AA_MAY_LOAD_POLICY"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "aa_may_manage_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "678-700",
          "snippet": "int aa_may_manage_policy(struct aa_label *label, struct aa_ns *ns, u32 mask)\n{\n\tconst char *op;\n\n\tif (mask & AA_MAY_REMOVE_POLICY)\n\t\top = OP_PROF_RM;\n\telse if (mask & AA_MAY_REPLACE_POLICY)\n\t\top = OP_PROF_REPL;\n\telse\n\t\top = OP_PROF_LOAD;\n\n\t/* check if loading policy is locked out */\n\tif (aa_g_lock_policy)\n\t\treturn audit_policy(label, op, NULL, NULL, \"policy_locked\",\n\t\t\t\t    -EACCES);\n\n\tif (!policy_admin_capable(ns))\n\t\treturn audit_policy(label, op, NULL, NULL, \"not policy admin\",\n\t\t\t\t    -EACCES);\n\n\t/* TODO: add fine grained mediation of policy loads */\n\treturn 0;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint aa_may_manage_policy(struct aa_label *label, struct aa_ns *ns, u32 mask)\n{\n\tconst char *op;\n\n\tif (mask & AA_MAY_REMOVE_POLICY)\n\t\top = OP_PROF_RM;\n\telse if (mask & AA_MAY_REPLACE_POLICY)\n\t\top = OP_PROF_REPL;\n\telse\n\t\top = OP_PROF_LOAD;\n\n\t/* check if loading policy is locked out */\n\tif (aa_g_lock_policy)\n\t\treturn audit_policy(label, op, NULL, NULL, \"policy_locked\",\n\t\t\t\t    -EACCES);\n\n\tif (!policy_admin_capable(ns))\n\t\treturn audit_policy(label, op, NULL, NULL, \"not policy admin\",\n\t\t\t\t    -EACCES);\n\n\t/* TODO: add fine grained mediation of policy loads */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int ns_rmdir_op(struct inode *dir, struct dentry *dentry)\n{\n\tstruct aa_ns *ns, *parent;\n\t/* TODO: improve permission check */\n\tstruct aa_label *label;\n\tint error;\n\n\tlabel = begin_current_label_crit_section();\n\terror = aa_may_manage_policy(label, NULL, AA_MAY_LOAD_POLICY);\n\tend_current_label_crit_section(label);\n\tif (error)\n\t\treturn error;\n\n\t parent = aa_get_ns(dir->i_private);\n\t/* rmdir calls the generic securityfs functions to remove files\n\t * from the apparmor dir. It is up to the apparmor ns locking\n\t * to avoid races.\n\t */\n\tinode_unlock(dir);\n\tinode_unlock(dentry->d_inode);\n\n\tmutex_lock_nested(&parent->lock, parent->level);\n\tns = aa_get_ns(__aa_findn_ns(&parent->sub_ns, dentry->d_name.name,\n\t\t\t\t     dentry->d_name.len));\n\tif (!ns) {\n\t\terror = -ENOENT;\n\t\tgoto out;\n\t}\n\tAA_BUG(ns_dir(ns) != dentry);\n\n\t__aa_remove_ns(ns);\n\taa_put_ns(ns);\n\nout:\n\tmutex_unlock(&parent->lock);\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tinode_lock(dentry->d_inode);\n\taa_put_ns(parent);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ns_mkdir_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1625-1672",
    "snippet": "static int ns_mkdir_op(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct aa_ns *ns, *parent;\n\t/* TODO: improve permission check */\n\tstruct aa_label *label;\n\tint error;\n\n\tlabel = begin_current_label_crit_section();\n\terror = aa_may_manage_policy(label, NULL, AA_MAY_LOAD_POLICY);\n\tend_current_label_crit_section(label);\n\tif (error)\n\t\treturn error;\n\n\tparent = aa_get_ns(dir->i_private);\n\tAA_BUG(d_inode(ns_subns_dir(parent)) != dir);\n\n\t/* we have to unlock and then relock to get locking order right\n\t * for pin_fs\n\t */\n\tinode_unlock(dir);\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tmutex_lock_nested(&parent->lock, parent->level);\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tif (error)\n\t\tgoto out;\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode | S_IFDIR,  NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\tif (error)\n\t\tgoto out_pin;\n\n\tns = __aa_find_or_create_ns(parent, READ_ONCE(dentry->d_name.name),\n\t\t\t\t    dentry);\n\tif (IS_ERR(ns)) {\n\t\terror = PTR_ERR(ns);\n\t\tns = NULL;\n\t}\n\n\taa_put_ns(ns);\t\t/* list ref remains */\nout_pin:\n\tif (error)\n\t\tsimple_release_fs(&aafs_mnt, &aafs_count);\nout:\n\tmutex_unlock(&parent->lock);\n\taa_put_ns(parent);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *aafs_mnt;",
      "static int aafs_count;",
      "static struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "parent"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&parent->lock"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_release_fs",
          "args": [
            "&aafs_mnt",
            "&aafs_count"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ns"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ns"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aa_find_or_create_ns",
          "args": [
            "parent",
            "READ_ONCE(dentry->d_name.name)",
            "dentry"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_find_or_create_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "286-303",
          "snippet": "struct aa_ns *__aa_find_or_create_ns(struct aa_ns *parent, const char *name,\n\t\t\t\t     struct dentry *dir)\n{\n\tstruct aa_ns *ns;\n\n\tAA_BUG(!mutex_is_locked(&parent->lock));\n\n\t/* try and find the specified ns */\n\t/* released by caller */\n\tns = aa_get_ns(__aa_find_ns(&parent->sub_ns, name));\n\tif (!ns)\n\t\tns = __aa_create_ns(parent, name, dir);\n\telse\n\t\tns = ERR_PTR(-EEXIST);\n\n\t/* return ref */\n\treturn ns;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nstruct aa_ns *__aa_find_or_create_ns(struct aa_ns *parent, const char *name,\n\t\t\t\t     struct dentry *dir)\n{\n\tstruct aa_ns *ns;\n\n\tAA_BUG(!mutex_is_locked(&parent->lock));\n\n\t/* try and find the specified ns */\n\t/* released by caller */\n\tns = aa_get_ns(__aa_find_ns(&parent->sub_ns, name));\n\tif (!ns)\n\t\tns = __aa_create_ns(parent, name, dir);\n\telse\n\t\tns = ERR_PTR(-EEXIST);\n\n\t/* return ref */\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "dentry->d_name.name"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aafs_setup_d_inode",
          "args": [
            "dir",
            "dentry",
            "mode | S_IFDIR",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "__aafs_setup_d_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "179-211",
          "snippet": "static int __aafs_setup_d_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, void *data, char *link,\n\t\t\t       const struct file_operations *fops,\n\t\t\t       const struct inode_operations *iops)\n{\n\tstruct inode *inode = new_inode(dir->i_sb);\n\n\tAA_BUG(!dir);\n\tAA_BUG(!dentry);\n\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = link;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int __aafs_setup_d_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, void *data, char *link,\n\t\t\t       const struct file_operations *fops,\n\t\t\t       const struct inode_operations *iops)\n{\n\tstruct inode *inode = new_inode(dir->i_sb);\n\n\tAA_BUG(!dir);\n\tAA_BUG(!dentry);\n\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = link;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock_nested",
          "args": [
            "dir",
            "I_MUTEX_PARENT"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&parent->lock",
            "parent->level"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_pin_fs",
          "args": [
            "&aafs_ops",
            "&aafs_mnt",
            "&aafs_count"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "dir"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "d_inode(ns_subns_dir(parent)) != dir"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "ns_subns_dir(parent)"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subns_dir",
          "args": [
            "parent"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_ns",
          "args": [
            "dir->i_private"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "116-122",
          "snippet": "static inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_may_manage_policy",
          "args": [
            "label",
            "NULL",
            "AA_MAY_LOAD_POLICY"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "aa_may_manage_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "678-700",
          "snippet": "int aa_may_manage_policy(struct aa_label *label, struct aa_ns *ns, u32 mask)\n{\n\tconst char *op;\n\n\tif (mask & AA_MAY_REMOVE_POLICY)\n\t\top = OP_PROF_RM;\n\telse if (mask & AA_MAY_REPLACE_POLICY)\n\t\top = OP_PROF_REPL;\n\telse\n\t\top = OP_PROF_LOAD;\n\n\t/* check if loading policy is locked out */\n\tif (aa_g_lock_policy)\n\t\treturn audit_policy(label, op, NULL, NULL, \"policy_locked\",\n\t\t\t\t    -EACCES);\n\n\tif (!policy_admin_capable(ns))\n\t\treturn audit_policy(label, op, NULL, NULL, \"not policy admin\",\n\t\t\t\t    -EACCES);\n\n\t/* TODO: add fine grained mediation of policy loads */\n\treturn 0;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint aa_may_manage_policy(struct aa_label *label, struct aa_ns *ns, u32 mask)\n{\n\tconst char *op;\n\n\tif (mask & AA_MAY_REMOVE_POLICY)\n\t\top = OP_PROF_RM;\n\telse if (mask & AA_MAY_REPLACE_POLICY)\n\t\top = OP_PROF_REPL;\n\telse\n\t\top = OP_PROF_LOAD;\n\n\t/* check if loading policy is locked out */\n\tif (aa_g_lock_policy)\n\t\treturn audit_policy(label, op, NULL, NULL, \"policy_locked\",\n\t\t\t\t    -EACCES);\n\n\tif (!policy_admin_capable(ns))\n\t\treturn audit_policy(label, op, NULL, NULL, \"not policy admin\",\n\t\t\t\t    -EACCES);\n\n\t/* TODO: add fine grained mediation of policy loads */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct vfsmount *aafs_mnt;\nstatic int aafs_count;\nstatic struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};\n\nstatic int ns_mkdir_op(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct aa_ns *ns, *parent;\n\t/* TODO: improve permission check */\n\tstruct aa_label *label;\n\tint error;\n\n\tlabel = begin_current_label_crit_section();\n\terror = aa_may_manage_policy(label, NULL, AA_MAY_LOAD_POLICY);\n\tend_current_label_crit_section(label);\n\tif (error)\n\t\treturn error;\n\n\tparent = aa_get_ns(dir->i_private);\n\tAA_BUG(d_inode(ns_subns_dir(parent)) != dir);\n\n\t/* we have to unlock and then relock to get locking order right\n\t * for pin_fs\n\t */\n\tinode_unlock(dir);\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tmutex_lock_nested(&parent->lock, parent->level);\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tif (error)\n\t\tgoto out;\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode | S_IFDIR,  NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\tif (error)\n\t\tgoto out_pin;\n\n\tns = __aa_find_or_create_ns(parent, READ_ONCE(dentry->d_name.name),\n\t\t\t\t    dentry);\n\tif (IS_ERR(ns)) {\n\t\terror = PTR_ERR(ns);\n\t\tns = NULL;\n\t}\n\n\taa_put_ns(ns);\t\t/* list ref remains */\nout_pin:\n\tif (error)\n\t\tsimple_release_fs(&aafs_mnt, &aafs_count);\nout:\n\tmutex_unlock(&parent->lock);\n\taa_put_ns(parent);\n\n\treturn error;\n}"
  },
  {
    "function_name": "__aafs_profile_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1510-1623",
    "snippet": "int __aafs_profile_mkdir(struct aa_profile *profile, struct dentry *parent)\n{\n\tstruct aa_profile *child;\n\tstruct dentry *dent = NULL, *dir;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mutex_is_locked(&profiles_ns(profile)->lock));\n\n\tif (!parent) {\n\t\tstruct aa_profile *p;\n\t\tp = aa_deref_parent(profile);\n\t\tdent = prof_dir(p);\n\t\t/* adding to parent that previously didn't have children */\n\t\tdent = aafs_create_dir(\"profiles\", dent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprof_child_dir(p) = parent = dent;\n\t}\n\n\tif (!profile->dirname) {\n\t\tint len, id_len;\n\t\tlen = mangle_name(profile->base.name, NULL);\n\t\tid_len = snprintf(NULL, 0, \".%ld\", profile->ns->uniq_id);\n\n\t\tprofile->dirname = kmalloc(len + id_len + 1, GFP_KERNEL);\n\t\tif (!profile->dirname) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tmangle_name(profile->base.name, profile->dirname);\n\t\tsprintf(profile->dirname + len, \".%ld\", profile->ns->uniq_id++);\n\t}\n\n\tdent = aafs_create_dir(profile->dirname, parent);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprof_dir(profile) = dir = dent;\n\n\tdent = create_profile_file(dir, \"name\", profile,\n\t\t\t\t   &seq_profile_name_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_NAME] = dent;\n\n\tdent = create_profile_file(dir, \"mode\", profile,\n\t\t\t\t   &seq_profile_mode_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_MODE] = dent;\n\n\tdent = create_profile_file(dir, \"attach\", profile,\n\t\t\t\t   &seq_profile_attach_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_ATTACH] = dent;\n\n\tif (profile->hash) {\n\t\tdent = create_profile_file(dir, \"sha1\", profile,\n\t\t\t\t\t   &seq_profile_hash_fops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_HASH] = dent;\n\t}\n\n\tif (profile->rawdata) {\n\t\tchar target[64];\n\t\tint depth = profile_depth(profile);\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"sha1\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_sha1\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_HASH] = dent;\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"abi\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_abi\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_ABI] = dent;\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"raw_data\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_data\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_DATA] = dent;\n\t}\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, prof_child_dir(profile));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_profile_rmdir(profile);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__aafs_profile_rmdir",
          "args": [
            "profile"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "__aafs_profile_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1417-1438",
          "snippet": "void __aafs_profile_rmdir(struct aa_profile *profile)\n{\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!profile)\n\t\treturn;\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tfor (i = AAFS_PROF_SIZEOF - 1; i >= 0; --i) {\n\t\tstruct aa_proxy *proxy;\n\t\tif (!profile->dents[i])\n\t\t\tcontinue;\n\n\t\tproxy = d_inode(profile->dents[i])->i_private;\n\t\taafs_remove(profile->dents[i]);\n\t\taa_put_proxy(proxy);\n\t\tprofile->dents[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nvoid __aafs_profile_rmdir(struct aa_profile *profile)\n{\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!profile)\n\t\treturn;\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tfor (i = AAFS_PROF_SIZEOF - 1; i >= 0; --i) {\n\t\tstruct aa_proxy *proxy;\n\t\tif (!profile->dents[i])\n\t\t\tcontinue;\n\n\t\tproxy = d_inode(profile->dents[i])->i_private;\n\t\taafs_remove(profile->dents[i]);\n\t\taa_put_proxy(proxy);\n\t\tprofile->dents[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aafs_profile_mkdir",
          "args": [
            "child",
            "prof_child_dir(profile)"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "__aafs_profile_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1510-1623",
          "snippet": "int __aafs_profile_mkdir(struct aa_profile *profile, struct dentry *parent)\n{\n\tstruct aa_profile *child;\n\tstruct dentry *dent = NULL, *dir;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mutex_is_locked(&profiles_ns(profile)->lock));\n\n\tif (!parent) {\n\t\tstruct aa_profile *p;\n\t\tp = aa_deref_parent(profile);\n\t\tdent = prof_dir(p);\n\t\t/* adding to parent that previously didn't have children */\n\t\tdent = aafs_create_dir(\"profiles\", dent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprof_child_dir(p) = parent = dent;\n\t}\n\n\tif (!profile->dirname) {\n\t\tint len, id_len;\n\t\tlen = mangle_name(profile->base.name, NULL);\n\t\tid_len = snprintf(NULL, 0, \".%ld\", profile->ns->uniq_id);\n\n\t\tprofile->dirname = kmalloc(len + id_len + 1, GFP_KERNEL);\n\t\tif (!profile->dirname) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tmangle_name(profile->base.name, profile->dirname);\n\t\tsprintf(profile->dirname + len, \".%ld\", profile->ns->uniq_id++);\n\t}\n\n\tdent = aafs_create_dir(profile->dirname, parent);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprof_dir(profile) = dir = dent;\n\n\tdent = create_profile_file(dir, \"name\", profile,\n\t\t\t\t   &seq_profile_name_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_NAME] = dent;\n\n\tdent = create_profile_file(dir, \"mode\", profile,\n\t\t\t\t   &seq_profile_mode_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_MODE] = dent;\n\n\tdent = create_profile_file(dir, \"attach\", profile,\n\t\t\t\t   &seq_profile_attach_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_ATTACH] = dent;\n\n\tif (profile->hash) {\n\t\tdent = create_profile_file(dir, \"sha1\", profile,\n\t\t\t\t\t   &seq_profile_hash_fops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_HASH] = dent;\n\t}\n\n\tif (profile->rawdata) {\n\t\tchar target[64];\n\t\tint depth = profile_depth(profile);\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"sha1\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_sha1\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_HASH] = dent;\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"abi\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_abi\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_ABI] = dent;\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"raw_data\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_data\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_DATA] = dent;\n\t}\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, prof_child_dir(profile));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_profile_rmdir(profile);\n\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "prof_child_dir",
          "args": [
            "profile"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&profile->base.profiles",
            "base.list"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aafs_create_symlink",
          "args": [
            "\"raw_data\"",
            "dir",
            "target",
            "NULL"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_create_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "321-340",
          "snippet": "static struct dentry *aafs_create_symlink(const char *name,\n\t\t\t\t\t  struct dentry *parent,\n\t\t\t\t\t  const char *target,\n\t\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dent;\n\tchar *link = NULL;\n\n\tif (target) {\n\t\tlink = kstrdup(target, GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tdent = aafs_create(name, S_IFLNK | 0444, parent, NULL, link, NULL,\n\t\t\t   iops);\n\tif (IS_ERR(dent))\n\t\tkfree(link);\n\n\treturn dent;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *aafs_create_symlink(const char *name,\n\t\t\t\t\t  struct dentry *parent,\n\t\t\t\t\t  const char *target,\n\t\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dent;\n\tchar *link = NULL;\n\n\tif (target) {\n\t\tlink = kstrdup(target, GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tdent = aafs_create(name, S_IFLNK | 0444, parent, NULL, link, NULL,\n\t\t\t   iops);\n\tif (IS_ERR(dent))\n\t\tkfree(link);\n\n\treturn dent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_symlink_name",
          "args": [
            "target",
            "sizeof(target)",
            "depth",
            "profile->rawdata->name",
            "\"raw_data\""
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "gen_symlink_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1487-1505",
          "snippet": "static int gen_symlink_name(char *buffer, size_t bsize, int depth,\n\t\t\t    const char *dirname, const char *fname)\n{\n\tint error;\n\n\tfor (; depth > 0; depth--) {\n\t\tif (bsize < 7)\n\t\t\treturn -ENAMETOOLONG;\n\t\tstrcpy(buffer, \"../../\");\n\t\tbuffer += 6;\n\t\tbsize -= 6;\n\t}\n\n\terror = snprintf(buffer, bsize, \"raw_data/%s/%s\", dirname, fname);\n\tif (error >= bsize || error < 0)\n\t\treturn -ENAMETOOLONG;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int gen_symlink_name(char *buffer, size_t bsize, int depth,\n\t\t\t    const char *dirname, const char *fname)\n{\n\tint error;\n\n\tfor (; depth > 0; depth--) {\n\t\tif (bsize < 7)\n\t\t\treturn -ENAMETOOLONG;\n\t\tstrcpy(buffer, \"../../\");\n\t\tbuffer += 6;\n\t\tbsize -= 6;\n\t}\n\n\terror = snprintf(buffer, bsize, \"raw_data/%s/%s\", dirname, fname);\n\tif (error >= bsize || error < 0)\n\t\treturn -ENAMETOOLONG;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_depth",
          "args": [
            "profile"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "profile_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1475-1485",
          "snippet": "static int profile_depth(struct aa_profile *profile)\n{\n\tint depth = 0;\n\n\trcu_read_lock();\n\tfor (depth = 0; profile; profile = rcu_access_pointer(profile->parent))\n\t\tdepth++;\n\trcu_read_unlock();\n\n\treturn depth;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int profile_depth(struct aa_profile *profile)\n{\n\tint depth = 0;\n\n\trcu_read_lock();\n\tfor (depth = 0; profile; profile = rcu_access_pointer(profile->parent))\n\t\tdepth++;\n\trcu_read_unlock();\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_profile_file",
          "args": [
            "dir",
            "\"sha1\"",
            "profile",
            "&seq_profile_hash_fops"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "create_profile_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1461-1473",
          "snippet": "static struct dentry *create_profile_file(struct dentry *dir, const char *name,\n\t\t\t\t\t  struct aa_profile *profile,\n\t\t\t\t\t  const struct file_operations *fops)\n{\n\tstruct aa_proxy *proxy = aa_get_proxy(profile->label.proxy);\n\tstruct dentry *dent;\n\n\tdent = aafs_create_file(name, S_IFREG | 0444, dir, proxy, fops);\n\tif (IS_ERR(dent))\n\t\taa_put_proxy(proxy);\n\n\treturn dent;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *create_profile_file(struct dentry *dir, const char *name,\n\t\t\t\t\t  struct aa_profile *profile,\n\t\t\t\t\t  const struct file_operations *fops)\n{\n\tstruct aa_proxy *proxy = aa_get_proxy(profile->label.proxy);\n\tstruct dentry *dent;\n\n\tdent = aafs_create_file(name, S_IFREG | 0444, dir, proxy, fops);\n\tif (IS_ERR(dent))\n\t\taa_put_proxy(proxy);\n\n\treturn dent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prof_dir",
          "args": [
            "profile"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aafs_create_dir",
          "args": [
            "profile->dirname",
            "parent"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "305-309",
          "snippet": "static struct dentry *aafs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn aafs_create(name, S_IFDIR | 0755, parent, NULL, NULL, NULL,\n\t\t\t   NULL);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *aafs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn aafs_create(name, S_IFDIR | 0755, parent, NULL, NULL, NULL,\n\t\t\t   NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "profile->dirname + len",
            "\".%ld\"",
            "profile->ns->uniq_id++"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mangle_name",
          "args": [
            "profile->base.name",
            "profile->dirname"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "mangle_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "79-109",
          "snippet": "static int mangle_name(const char *name, char *target)\n{\n\tchar *t = target;\n\n\twhile (*name == '/' || *name == '.')\n\t\tname++;\n\n\tif (target) {\n\t\tfor (; *name; name++) {\n\t\t\tif (*name == '/')\n\t\t\t\t*(t)++ = '.';\n\t\t\telse if (isspace(*name))\n\t\t\t\t*(t)++ = '_';\n\t\t\telse if (isalnum(*name) || strchr(\"._-\", *name))\n\t\t\t\t*(t)++ = *name;\n\t\t}\n\n\t\t*t = 0;\n\t} else {\n\t\tint len = 0;\n\t\tfor (; *name; name++) {\n\t\t\tif (isalnum(*name) || isspace(*name) ||\n\t\t\t    strchr(\"/._-\", *name))\n\t\t\t\tlen++;\n\t\t}\n\n\t\treturn len;\n\t}\n\n\treturn t - target;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int mangle_name(const char *name, char *target)\n{\n\tchar *t = target;\n\n\twhile (*name == '/' || *name == '.')\n\t\tname++;\n\n\tif (target) {\n\t\tfor (; *name; name++) {\n\t\t\tif (*name == '/')\n\t\t\t\t*(t)++ = '.';\n\t\t\telse if (isspace(*name))\n\t\t\t\t*(t)++ = '_';\n\t\t\telse if (isalnum(*name) || strchr(\"._-\", *name))\n\t\t\t\t*(t)++ = *name;\n\t\t}\n\n\t\t*t = 0;\n\t} else {\n\t\tint len = 0;\n\t\tfor (; *name; name++) {\n\t\t\tif (isalnum(*name) || isspace(*name) ||\n\t\t\t    strchr(\"/._-\", *name))\n\t\t\t\tlen++;\n\t\t}\n\n\t\treturn len;\n\t}\n\n\treturn t - target;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + id_len + 1",
            "GFP_KERNEL"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "NULL",
            "0",
            "\".%ld\"",
            "profile->ns->uniq_id"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prof_child_dir",
          "args": [
            "p"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prof_dir",
          "args": [
            "p"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_deref_parent",
          "args": [
            "profile"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "aa_deref_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "103-107",
          "snippet": "static inline struct aa_profile *aa_deref_parent(struct aa_profile *p)\n{\n\treturn rcu_dereference_protected(p->parent,\n\t\t\t\t\t mutex_is_locked(&p->ns->lock));\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline struct aa_profile *aa_deref_parent(struct aa_profile *p)\n{\n\treturn rcu_dereference_protected(p->parent,\n\t\t\t\t\t mutex_is_locked(&p->ns->lock));\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!mutex_is_locked(&profiles_ns(profile)->lock)"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&profiles_ns(profile)->lock"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profiles_ns",
          "args": [
            "profile"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!profile"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nint __aafs_profile_mkdir(struct aa_profile *profile, struct dentry *parent)\n{\n\tstruct aa_profile *child;\n\tstruct dentry *dent = NULL, *dir;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mutex_is_locked(&profiles_ns(profile)->lock));\n\n\tif (!parent) {\n\t\tstruct aa_profile *p;\n\t\tp = aa_deref_parent(profile);\n\t\tdent = prof_dir(p);\n\t\t/* adding to parent that previously didn't have children */\n\t\tdent = aafs_create_dir(\"profiles\", dent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprof_child_dir(p) = parent = dent;\n\t}\n\n\tif (!profile->dirname) {\n\t\tint len, id_len;\n\t\tlen = mangle_name(profile->base.name, NULL);\n\t\tid_len = snprintf(NULL, 0, \".%ld\", profile->ns->uniq_id);\n\n\t\tprofile->dirname = kmalloc(len + id_len + 1, GFP_KERNEL);\n\t\tif (!profile->dirname) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tmangle_name(profile->base.name, profile->dirname);\n\t\tsprintf(profile->dirname + len, \".%ld\", profile->ns->uniq_id++);\n\t}\n\n\tdent = aafs_create_dir(profile->dirname, parent);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprof_dir(profile) = dir = dent;\n\n\tdent = create_profile_file(dir, \"name\", profile,\n\t\t\t\t   &seq_profile_name_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_NAME] = dent;\n\n\tdent = create_profile_file(dir, \"mode\", profile,\n\t\t\t\t   &seq_profile_mode_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_MODE] = dent;\n\n\tdent = create_profile_file(dir, \"attach\", profile,\n\t\t\t\t   &seq_profile_attach_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_ATTACH] = dent;\n\n\tif (profile->hash) {\n\t\tdent = create_profile_file(dir, \"sha1\", profile,\n\t\t\t\t\t   &seq_profile_hash_fops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_HASH] = dent;\n\t}\n\n\tif (profile->rawdata) {\n\t\tchar target[64];\n\t\tint depth = profile_depth(profile);\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"sha1\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_sha1\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_HASH] = dent;\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"abi\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_abi\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_ABI] = dent;\n\n\t\terror = gen_symlink_name(target, sizeof(target), depth,\n\t\t\t\t\t profile->rawdata->name, \"raw_data\");\n\t\tif (error < 0)\n\t\t\tgoto fail2;\n\t\tdent = aafs_create_symlink(\"raw_data\", dir, target, NULL);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_RAW_DATA] = dent;\n\t}\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, prof_child_dir(profile));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_profile_rmdir(profile);\n\n\treturn error;\n}"
  },
  {
    "function_name": "gen_symlink_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1487-1505",
    "snippet": "static int gen_symlink_name(char *buffer, size_t bsize, int depth,\n\t\t\t    const char *dirname, const char *fname)\n{\n\tint error;\n\n\tfor (; depth > 0; depth--) {\n\t\tif (bsize < 7)\n\t\t\treturn -ENAMETOOLONG;\n\t\tstrcpy(buffer, \"../../\");\n\t\tbuffer += 6;\n\t\tbsize -= 6;\n\t}\n\n\terror = snprintf(buffer, bsize, \"raw_data/%s/%s\", dirname, fname);\n\tif (error >= bsize || error < 0)\n\t\treturn -ENAMETOOLONG;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "bsize",
            "\"raw_data/%s/%s\"",
            "dirname",
            "fname"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "\"../../\""
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int gen_symlink_name(char *buffer, size_t bsize, int depth,\n\t\t\t    const char *dirname, const char *fname)\n{\n\tint error;\n\n\tfor (; depth > 0; depth--) {\n\t\tif (bsize < 7)\n\t\t\treturn -ENAMETOOLONG;\n\t\tstrcpy(buffer, \"../../\");\n\t\tbuffer += 6;\n\t\tbsize -= 6;\n\t}\n\n\terror = snprintf(buffer, bsize, \"raw_data/%s/%s\", dirname, fname);\n\tif (error >= bsize || error < 0)\n\t\treturn -ENAMETOOLONG;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "profile_depth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1475-1485",
    "snippet": "static int profile_depth(struct aa_profile *profile)\n{\n\tint depth = 0;\n\n\trcu_read_lock();\n\tfor (depth = 0; profile; profile = rcu_access_pointer(profile->parent))\n\t\tdepth++;\n\trcu_read_unlock();\n\n\treturn depth;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "profile->parent"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int profile_depth(struct aa_profile *profile)\n{\n\tint depth = 0;\n\n\trcu_read_lock();\n\tfor (depth = 0; profile; profile = rcu_access_pointer(profile->parent))\n\t\tdepth++;\n\trcu_read_unlock();\n\n\treturn depth;\n}"
  },
  {
    "function_name": "create_profile_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1461-1473",
    "snippet": "static struct dentry *create_profile_file(struct dentry *dir, const char *name,\n\t\t\t\t\t  struct aa_profile *profile,\n\t\t\t\t\t  const struct file_operations *fops)\n{\n\tstruct aa_proxy *proxy = aa_get_proxy(profile->label.proxy);\n\tstruct dentry *dent;\n\n\tdent = aafs_create_file(name, S_IFREG | 0444, dir, proxy, fops);\n\tif (IS_ERR(dent))\n\t\taa_put_proxy(proxy);\n\n\treturn dent;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_proxy",
          "args": [
            "proxy"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "434-438",
          "snippet": "static inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aafs_create_file",
          "args": [
            "name",
            "S_IFREG | 0444",
            "dir",
            "proxy",
            "fops"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "290-295",
          "snippet": "static struct dentry *aafs_create_file(const char *name, umode_t mode,\n\t\t\t\t       struct dentry *parent, void *data,\n\t\t\t\t       const struct file_operations *fops)\n{\n\treturn aafs_create(name, mode, parent, data, NULL, fops, NULL);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *aafs_create_file(const char *name, umode_t mode,\n\t\t\t\t       struct dentry *parent, void *data,\n\t\t\t\t       const struct file_operations *fops)\n{\n\treturn aafs_create(name, mode, parent, data, NULL, fops, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_proxy",
          "args": [
            "profile->label.proxy"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "426-432",
          "snippet": "static inline struct aa_proxy *aa_get_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_get(&(proxy->count));\n\n\treturn proxy;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_proxy *aa_get_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_get(&(proxy->count));\n\n\treturn proxy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *create_profile_file(struct dentry *dir, const char *name,\n\t\t\t\t\t  struct aa_profile *profile,\n\t\t\t\t\t  const struct file_operations *fops)\n{\n\tstruct aa_proxy *proxy = aa_get_proxy(profile->label.proxy);\n\tstruct dentry *dent;\n\n\tdent = aafs_create_file(name, S_IFREG | 0444, dir, proxy, fops);\n\tif (IS_ERR(dent))\n\t\taa_put_proxy(proxy);\n\n\treturn dent;\n}"
  },
  {
    "function_name": "__aafs_profile_migrate_dents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1444-1459",
    "snippet": "void __aafs_profile_migrate_dents(struct aa_profile *old,\n\t\t\t\t  struct aa_profile *new)\n{\n\tint i;\n\n\tAA_BUG(!old);\n\tAA_BUG(!new);\n\tAA_BUG(!mutex_is_locked(&profiles_ns(old)->lock));\n\n\tfor (i = 0; i < AAFS_PROF_SIZEOF; i++) {\n\t\tnew->dents[i] = old->dents[i];\n\t\tif (new->dents[i])\n\t\t\tnew->dents[i]->d_inode->i_mtime = current_time(new->dents[i]->d_inode);\n\t\told->dents[i] = NULL;\n\t}\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "new->dents[i]->d_inode"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!mutex_is_locked(&profiles_ns(old)->lock)"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&profiles_ns(old)->lock"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profiles_ns",
          "args": [
            "old"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!new"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!old"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nvoid __aafs_profile_migrate_dents(struct aa_profile *old,\n\t\t\t\t  struct aa_profile *new)\n{\n\tint i;\n\n\tAA_BUG(!old);\n\tAA_BUG(!new);\n\tAA_BUG(!mutex_is_locked(&profiles_ns(old)->lock));\n\n\tfor (i = 0; i < AAFS_PROF_SIZEOF; i++) {\n\t\tnew->dents[i] = old->dents[i];\n\t\tif (new->dents[i])\n\t\t\tnew->dents[i]->d_inode->i_mtime = current_time(new->dents[i]->d_inode);\n\t\told->dents[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "__aafs_profile_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1417-1438",
    "snippet": "void __aafs_profile_rmdir(struct aa_profile *profile)\n{\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!profile)\n\t\treturn;\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tfor (i = AAFS_PROF_SIZEOF - 1; i >= 0; --i) {\n\t\tstruct aa_proxy *proxy;\n\t\tif (!profile->dents[i])\n\t\t\tcontinue;\n\n\t\tproxy = d_inode(profile->dents[i])->i_private;\n\t\taafs_remove(profile->dents[i]);\n\t\taa_put_proxy(proxy);\n\t\tprofile->dents[i] = NULL;\n\t}\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_proxy",
          "args": [
            "proxy"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "434-438",
          "snippet": "static inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aafs_remove",
          "args": [
            "profile->dents[i]"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "347-365",
          "snippet": "static void aafs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *aafs_mnt;",
            "static int aafs_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct vfsmount *aafs_mnt;\nstatic int aafs_count;\n\nstatic void aafs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "profile->dents[i]"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aafs_profile_rmdir",
          "args": [
            "child"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "__aafs_profile_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1417-1438",
          "snippet": "void __aafs_profile_rmdir(struct aa_profile *profile)\n{\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!profile)\n\t\treturn;\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tfor (i = AAFS_PROF_SIZEOF - 1; i >= 0; --i) {\n\t\tstruct aa_proxy *proxy;\n\t\tif (!profile->dents[i])\n\t\t\tcontinue;\n\n\t\tproxy = d_inode(profile->dents[i])->i_private;\n\t\taafs_remove(profile->dents[i]);\n\t\taa_put_proxy(proxy);\n\t\tprofile->dents[i] = NULL;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&profile->base.profiles",
            "base.list"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nvoid __aafs_profile_rmdir(struct aa_profile *profile)\n{\n\tstruct aa_profile *child;\n\tint i;\n\n\tif (!profile)\n\t\treturn;\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list)\n\t\t__aafs_profile_rmdir(child);\n\n\tfor (i = AAFS_PROF_SIZEOF - 1; i >= 0; --i) {\n\t\tstruct aa_proxy *proxy;\n\t\tif (!profile->dents[i])\n\t\t\tcontinue;\n\n\t\tproxy = d_inode(profile->dents[i])->i_private;\n\t\taafs_remove(profile->dents[i]);\n\t\taa_put_proxy(proxy);\n\t\tprofile->dents[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "__aa_fs_create_rawdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1348-1409",
    "snippet": "int __aa_fs_create_rawdata(struct aa_ns *ns, struct aa_loaddata *rawdata)\n{\n\tstruct dentry *dent, *dir;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!rawdata);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\tAA_BUG(!ns_subdata_dir(ns));\n\n\t/*\n\t * just use ns revision dir was originally created at. This is\n\t * under ns->lock and if load is successful revision will be\n\t * bumped and is guaranteed to be unique\n\t */\n\trawdata->name = kasprintf(GFP_KERNEL, \"%ld\", ns->revision);\n\tif (!rawdata->name)\n\t\treturn -ENOMEM;\n\n\tdir = aafs_create_dir(rawdata->name, ns_subdata_dir(ns));\n\tif (IS_ERR(dir))\n\t\t/* ->name freed when rawdata freed */\n\t\treturn PTR_ERR(dir);\n\trawdata->dents[AAFS_LOADDATA_DIR] = dir;\n\n\tdent = aafs_create_file(\"abi\", S_IFREG | 0444, dir, rawdata,\n\t\t\t\t      &seq_rawdata_abi_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\trawdata->dents[AAFS_LOADDATA_ABI] = dent;\n\n\tdent = aafs_create_file(\"revision\", S_IFREG | 0444, dir, rawdata,\n\t\t\t\t      &seq_rawdata_revision_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\trawdata->dents[AAFS_LOADDATA_REVISION] = dent;\n\n\tif (aa_g_hash_policy) {\n\t\tdent = aafs_create_file(\"sha1\", S_IFREG | 0444, dir,\n\t\t\t\t\t      rawdata, &seq_rawdata_hash_fops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\trawdata->dents[AAFS_LOADDATA_HASH] = dent;\n\t}\n\n\tdent = aafs_create_file(\"raw_data\", S_IFREG | 0444,\n\t\t\t\t      dir, rawdata, &rawdata_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\trawdata->dents[AAFS_LOADDATA_DATA] = dent;\n\td_inode(dent)->i_size = rawdata->size;\n\n\trawdata->ns = aa_get_ns(ns);\n\tlist_add(&rawdata->list, &ns->rawdata_list);\n\t/* no refcount on inode rawdata */\n\n\treturn 0;\n\nfail:\n\tremove_rawdata_dents(rawdata);\n\n\treturn PTR_ERR(dent);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations rawdata_fops = {\n\t.open = rawdata_open,\n\t.read = rawdata_read,\n\t.llseek = generic_file_llseek,\n\t.release = rawdata_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dent"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_rawdata_dents",
          "args": [
            "rawdata"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "remove_rawdata_dents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1323-1334",
          "snippet": "static void remove_rawdata_dents(struct aa_loaddata *rawdata)\n{\n\tint i;\n\n\tfor (i = 0; i < AAFS_LOADDATA_NDENTS; i++) {\n\t\tif (!IS_ERR_OR_NULL(rawdata->dents[i])) {\n\t\t\t/* no refcounts on i_private */\n\t\t\taafs_remove(rawdata->dents[i]);\n\t\t\trawdata->dents[i] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void remove_rawdata_dents(struct aa_loaddata *rawdata)\n{\n\tint i;\n\n\tfor (i = 0; i < AAFS_LOADDATA_NDENTS; i++) {\n\t\tif (!IS_ERR_OR_NULL(rawdata->dents[i])) {\n\t\t\t/* no refcounts on i_private */\n\t\t\taafs_remove(rawdata->dents[i]);\n\t\t\trawdata->dents[i] = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&rawdata->list",
            "&ns->rawdata_list"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_ns",
          "args": [
            "ns"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "116-122",
          "snippet": "static inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dent"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aafs_create_file",
          "args": [
            "\"raw_data\"",
            "S_IFREG | 0444",
            "dir",
            "rawdata",
            "&rawdata_fops"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "290-295",
          "snippet": "static struct dentry *aafs_create_file(const char *name, umode_t mode,\n\t\t\t\t       struct dentry *parent, void *data,\n\t\t\t\t       const struct file_operations *fops)\n{\n\treturn aafs_create(name, mode, parent, data, NULL, fops, NULL);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *aafs_create_file(const char *name, umode_t mode,\n\t\t\t\t       struct dentry *parent, void *data,\n\t\t\t\t       const struct file_operations *fops)\n{\n\treturn aafs_create(name, mode, parent, data, NULL, fops, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aafs_create_dir",
          "args": [
            "rawdata->name",
            "ns_subdata_dir(ns)"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "305-309",
          "snippet": "static struct dentry *aafs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn aafs_create(name, S_IFDIR | 0755, parent, NULL, NULL, NULL,\n\t\t\t   NULL);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *aafs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn aafs_create(name, S_IFDIR | 0755, parent, NULL, NULL, NULL,\n\t\t\t   NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_subdata_dir",
          "args": [
            "ns"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%ld\"",
            "ns->revision"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ns_subdata_dir(ns)"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_subdata_dir",
          "args": [
            "ns"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!mutex_is_locked(&ns->lock)"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&ns->lock"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!rawdata"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ns"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic const struct file_operations rawdata_fops = {\n\t.open = rawdata_open,\n\t.read = rawdata_read,\n\t.llseek = generic_file_llseek,\n\t.release = rawdata_release,\n};\n\nint __aa_fs_create_rawdata(struct aa_ns *ns, struct aa_loaddata *rawdata)\n{\n\tstruct dentry *dent, *dir;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!rawdata);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\tAA_BUG(!ns_subdata_dir(ns));\n\n\t/*\n\t * just use ns revision dir was originally created at. This is\n\t * under ns->lock and if load is successful revision will be\n\t * bumped and is guaranteed to be unique\n\t */\n\trawdata->name = kasprintf(GFP_KERNEL, \"%ld\", ns->revision);\n\tif (!rawdata->name)\n\t\treturn -ENOMEM;\n\n\tdir = aafs_create_dir(rawdata->name, ns_subdata_dir(ns));\n\tif (IS_ERR(dir))\n\t\t/* ->name freed when rawdata freed */\n\t\treturn PTR_ERR(dir);\n\trawdata->dents[AAFS_LOADDATA_DIR] = dir;\n\n\tdent = aafs_create_file(\"abi\", S_IFREG | 0444, dir, rawdata,\n\t\t\t\t      &seq_rawdata_abi_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\trawdata->dents[AAFS_LOADDATA_ABI] = dent;\n\n\tdent = aafs_create_file(\"revision\", S_IFREG | 0444, dir, rawdata,\n\t\t\t\t      &seq_rawdata_revision_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\trawdata->dents[AAFS_LOADDATA_REVISION] = dent;\n\n\tif (aa_g_hash_policy) {\n\t\tdent = aafs_create_file(\"sha1\", S_IFREG | 0444, dir,\n\t\t\t\t\t      rawdata, &seq_rawdata_hash_fops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\trawdata->dents[AAFS_LOADDATA_HASH] = dent;\n\t}\n\n\tdent = aafs_create_file(\"raw_data\", S_IFREG | 0444,\n\t\t\t\t      dir, rawdata, &rawdata_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\trawdata->dents[AAFS_LOADDATA_DATA] = dent;\n\td_inode(dent)->i_size = rawdata->size;\n\n\trawdata->ns = aa_get_ns(ns);\n\tlist_add(&rawdata->list, &ns->rawdata_list);\n\t/* no refcount on inode rawdata */\n\n\treturn 0;\n\nfail:\n\tremove_rawdata_dents(rawdata);\n\n\treturn PTR_ERR(dent);\n}"
  },
  {
    "function_name": "__aa_fs_remove_rawdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1336-1346",
    "snippet": "void __aa_fs_remove_rawdata(struct aa_loaddata *rawdata)\n{\n\tAA_BUG(rawdata->ns && !mutex_is_locked(&rawdata->ns->lock));\n\n\tif (rawdata->ns) {\n\t\tremove_rawdata_dents(rawdata);\n\t\tlist_del_init(&rawdata->list);\n\t\taa_put_ns(rawdata->ns);\n\t\trawdata->ns = NULL;\n\t}\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "rawdata->ns"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&rawdata->list"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_rawdata_dents",
          "args": [
            "rawdata"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "remove_rawdata_dents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1323-1334",
          "snippet": "static void remove_rawdata_dents(struct aa_loaddata *rawdata)\n{\n\tint i;\n\n\tfor (i = 0; i < AAFS_LOADDATA_NDENTS; i++) {\n\t\tif (!IS_ERR_OR_NULL(rawdata->dents[i])) {\n\t\t\t/* no refcounts on i_private */\n\t\t\taafs_remove(rawdata->dents[i]);\n\t\t\trawdata->dents[i] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void remove_rawdata_dents(struct aa_loaddata *rawdata)\n{\n\tint i;\n\n\tfor (i = 0; i < AAFS_LOADDATA_NDENTS; i++) {\n\t\tif (!IS_ERR_OR_NULL(rawdata->dents[i])) {\n\t\t\t/* no refcounts on i_private */\n\t\t\taafs_remove(rawdata->dents[i]);\n\t\t\trawdata->dents[i] = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "rawdata->ns && !mutex_is_locked(&rawdata->ns->lock)"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&rawdata->ns->lock"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nvoid __aa_fs_remove_rawdata(struct aa_loaddata *rawdata)\n{\n\tAA_BUG(rawdata->ns && !mutex_is_locked(&rawdata->ns->lock));\n\n\tif (rawdata->ns) {\n\t\tremove_rawdata_dents(rawdata);\n\t\tlist_del_init(&rawdata->list);\n\t\taa_put_ns(rawdata->ns);\n\t\trawdata->ns = NULL;\n\t}\n}"
  },
  {
    "function_name": "remove_rawdata_dents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1323-1334",
    "snippet": "static void remove_rawdata_dents(struct aa_loaddata *rawdata)\n{\n\tint i;\n\n\tfor (i = 0; i < AAFS_LOADDATA_NDENTS; i++) {\n\t\tif (!IS_ERR_OR_NULL(rawdata->dents[i])) {\n\t\t\t/* no refcounts on i_private */\n\t\t\taafs_remove(rawdata->dents[i]);\n\t\t\trawdata->dents[i] = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aafs_remove",
          "args": [
            "rawdata->dents[i]"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "347-365",
          "snippet": "static void aafs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *aafs_mnt;",
            "static int aafs_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct vfsmount *aafs_mnt;\nstatic int aafs_count;\n\nstatic void aafs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "rawdata->dents[i]"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void remove_rawdata_dents(struct aa_loaddata *rawdata)\n{\n\tint i;\n\n\tfor (i = 0; i < AAFS_LOADDATA_NDENTS; i++) {\n\t\tif (!IS_ERR_OR_NULL(rawdata->dents[i])) {\n\t\t\t/* no refcounts on i_private */\n\t\t\taafs_remove(rawdata->dents[i]);\n\t\t\trawdata->dents[i] = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rawdata_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1304-1314",
    "snippet": "static int rawdata_open(struct inode *inode, struct file *file)\n{\n\tif (!policy_view_capable(NULL))\n\t\treturn -EACCES;\n\tfile->private_data = __aa_get_loaddata(inode->i_private);\n\tif (!file->private_data)\n\t\t/* lost race: this entry is being reaped */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__aa_get_loaddata",
          "args": [
            "inode->i_private"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_get_loaddata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_unpack.h",
          "lines": "88-95",
          "snippet": "static inline struct aa_loaddata *\n__aa_get_loaddata(struct aa_loaddata *data)\n{\n\tif (data && kref_get_unless_zero(&(data->count)))\n\t\treturn data;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/dcache.h>",
            "#include <linux/kref.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/dcache.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n\nstatic inline struct aa_loaddata *\n__aa_get_loaddata(struct aa_loaddata *data)\n{\n\tif (data && kref_get_unless_zero(&(data->count)))\n\t\treturn data;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy_view_capable",
          "args": [
            "NULL"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "policy_view_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "640-658",
          "snippet": "bool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int unprivileged_userns_apparmor_policy = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint unprivileged_userns_apparmor_policy = 1;\n\nbool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int rawdata_open(struct inode *inode, struct file *file)\n{\n\tif (!policy_view_capable(NULL))\n\t\treturn -EACCES;\n\tfile->private_data = __aa_get_loaddata(inode->i_private);\n\tif (!file->private_data)\n\t\t/* lost race: this entry is being reaped */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rawdata_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1297-1302",
    "snippet": "static int rawdata_release(struct inode *inode, struct file *file)\n{\n\taa_put_loaddata(file->private_data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_loaddata",
          "args": [
            "file->private_data"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_loaddata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_unpack.h",
          "lines": "119-123",
          "snippet": "static inline void aa_put_loaddata(struct aa_loaddata *data)\n{\n\tif (data)\n\t\tkref_put(&data->count, aa_loaddata_kref);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/dcache.h>",
            "#include <linux/kref.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/dcache.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n\nstatic inline void aa_put_loaddata(struct aa_loaddata *data)\n{\n\tif (data)\n\t\tkref_put(&data->count, aa_loaddata_kref);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int rawdata_release(struct inode *inode, struct file *file)\n{\n\taa_put_loaddata(file->private_data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rawdata_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1288-1295",
    "snippet": "static ssize_t rawdata_read(struct file *file, char __user *buf, size_t size,\n\t\t\t    loff_t *ppos)\n{\n\tstruct aa_loaddata *rawdata = file->private_data;\n\n\treturn simple_read_from_buffer(buf, size, ppos, rawdata->data,\n\t\t\t\t       rawdata->size);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "size",
            "ppos",
            "rawdata->data",
            "rawdata->size"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic ssize_t rawdata_read(struct file *file, char __user *buf, size_t size,\n\t\t\t    loff_t *ppos)\n{\n\tstruct aa_loaddata *rawdata = file->private_data;\n\n\treturn simple_read_from_buffer(buf, size, ppos, rawdata->data,\n\t\t\t\t       rawdata->size);\n}"
  },
  {
    "function_name": "seq_rawdata_hash_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1270-1282",
    "snippet": "static int seq_rawdata_hash_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_loaddata *data = seq->private;\n\tunsigned int i, size = aa_hash_size();\n\n\tif (data->hash) {\n\t\tfor (i = 0; i < size; i++)\n\t\t\tseq_printf(seq, \"%.2x\", data->hash[i]);\n\t\tseq_putc(seq, '\\n');\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "seq",
            "'\\n'"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%.2x\"",
            "data->hash[i]"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_hash_size",
          "args": [],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "aa_hash_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/crypto.c",
          "lines": "27-30",
          "snippet": "unsigned int aa_hash_size(void)\n{\n\treturn apparmor_hash_size;\n}",
          "includes": [
            "#include \"include/crypto.h\"",
            "#include \"include/apparmor.h\"",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int apparmor_hash_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/crypto.h\"\n#include \"include/apparmor.h\"\n#include <crypto/hash.h>\n\nstatic unsigned int apparmor_hash_size;\n\nunsigned int aa_hash_size(void)\n{\n\treturn apparmor_hash_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_rawdata_hash_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_loaddata *data = seq->private;\n\tunsigned int i, size = aa_hash_size();\n\n\tif (data->hash) {\n\t\tfor (i = 0; i < size; i++)\n\t\t\tseq_printf(seq, \"%.2x\", data->hash[i]);\n\t\tseq_putc(seq, '\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_rawdata_revision_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1261-1268",
    "snippet": "static int seq_rawdata_revision_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_loaddata *data = seq->private;\n\n\tseq_printf(seq, \"%ld\\n\", data->revision);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%ld\\n\"",
            "data->revision"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_rawdata_revision_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_loaddata *data = seq->private;\n\n\tseq_printf(seq, \"%ld\\n\", data->revision);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_rawdata_abi_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1252-1259",
    "snippet": "static int seq_rawdata_abi_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_loaddata *data = seq->private;\n\n\tseq_printf(seq, \"v%d\\n\", data->abi);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"v%d\\n\"",
            "data->abi"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_rawdata_abi_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_loaddata *data = seq->private;\n\n\tseq_printf(seq, \"v%d\\n\", data->abi);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_rawdata_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1242-1250",
    "snippet": "static int seq_rawdata_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = (struct seq_file *) file->private_data;\n\n\tif (seq)\n\t\taa_put_loaddata(seq->private);\n\n\treturn single_release(inode, file);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_loaddata",
          "args": [
            "seq->private"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_loaddata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_unpack.h",
          "lines": "119-123",
          "snippet": "static inline void aa_put_loaddata(struct aa_loaddata *data)\n{\n\tif (data)\n\t\tkref_put(&data->count, aa_loaddata_kref);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/dcache.h>",
            "#include <linux/kref.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/dcache.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n\nstatic inline void aa_put_loaddata(struct aa_loaddata *data)\n{\n\tif (data)\n\t\tkref_put(&data->count, aa_loaddata_kref);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_rawdata_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = (struct seq_file *) file->private_data;\n\n\tif (seq)\n\t\taa_put_loaddata(seq->private);\n\n\treturn single_release(inode, file);\n}"
  },
  {
    "function_name": "seq_rawdata_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1222-1240",
    "snippet": "static int seq_rawdata_open(struct inode *inode, struct file *file,\n\t\t\t    int (*show)(struct seq_file *, void *))\n{\n\tstruct aa_loaddata *data = __aa_get_loaddata(inode->i_private);\n\tint error;\n\n\tif (!data)\n\t\t/* lost race this ent is being reaped */\n\t\treturn -ENOENT;\n\n\terror = single_open(file, show, data);\n\tif (error) {\n\t\tAA_BUG(file->private_data &&\n\t\t       ((struct seq_file *)file->private_data)->private);\n\t\taa_put_loaddata(data);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_loaddata",
          "args": [
            "data"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_loaddata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_unpack.h",
          "lines": "119-123",
          "snippet": "static inline void aa_put_loaddata(struct aa_loaddata *data)\n{\n\tif (data)\n\t\tkref_put(&data->count, aa_loaddata_kref);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/dcache.h>",
            "#include <linux/kref.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/dcache.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n\nstatic inline void aa_put_loaddata(struct aa_loaddata *data)\n{\n\tif (data)\n\t\tkref_put(&data->count, aa_loaddata_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "file->private_data &&\n\t\t       ((struct seq_file *)file->private_data)->private"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "show",
            "data"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aa_get_loaddata",
          "args": [
            "inode->i_private"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_get_loaddata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_unpack.h",
          "lines": "88-95",
          "snippet": "static inline struct aa_loaddata *\n__aa_get_loaddata(struct aa_loaddata *data)\n{\n\tif (data && kref_get_unless_zero(&(data->count)))\n\t\treturn data;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/dcache.h>",
            "#include <linux/kref.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/dcache.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n\nstatic inline struct aa_loaddata *\n__aa_get_loaddata(struct aa_loaddata *data)\n{\n\tif (data && kref_get_unless_zero(&(data->count)))\n\t\treturn data;\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_rawdata_open(struct inode *inode, struct file *file,\n\t\t\t    int (*show)(struct seq_file *, void *))\n{\n\tstruct aa_loaddata *data = __aa_get_loaddata(inode->i_private);\n\tint error;\n\n\tif (!data)\n\t\t/* lost race this ent is being reaped */\n\t\treturn -ENOENT;\n\n\terror = single_open(file, show, data);\n\tif (error) {\n\t\tAA_BUG(file->private_data &&\n\t\t       ((struct seq_file *)file->private_data)->private);\n\t\taa_put_loaddata(data);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "seq_ns_name_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1189-1198",
    "snippet": "static int seq_ns_name_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_label *label = begin_current_label_crit_section();\n\n\tseq_printf(seq, \"%s\\n\", aa_ns_name(labels_ns(label),\n\t\t\t\t\t   labels_ns(label), true));\n\tend_current_label_crit_section(label);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%s\\n\"",
            "aa_ns_name(labels_ns(label),\n\t\t\t\t\t   labels_ns(label), true)"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_ns_name",
          "args": [
            "labels_ns(label)",
            "labels_ns(label)",
            "true"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "aa_ns_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "65-82",
          "snippet": "const char *aa_ns_name(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\t/* if view == curr then the namespace name isn't displayed */\n\tif (curr == view)\n\t\treturn \"\";\n\n\tif (aa_ns_visible(curr, view, subns)) {\n\t\t/* at this point if a ns is visible it is in a view ns\n\t\t * thus the curr ns.hname is a prefix of its name.\n\t\t * Only output the virtualized portion of the name\n\t\t * Add + 2 to skip over // separating curr hname prefix\n\t\t * from the visible tail of the views hname\n\t\t */\n\t\treturn view->base.hname + strlen(curr->base.hname) + 2;\n\t}\n\n\treturn aa_hidden_ns_name;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const char *aa_hidden_ns_name = \"---\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nconst char *aa_hidden_ns_name = \"---\";\n\nconst char *aa_ns_name(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\t/* if view == curr then the namespace name isn't displayed */\n\tif (curr == view)\n\t\treturn \"\";\n\n\tif (aa_ns_visible(curr, view, subns)) {\n\t\t/* at this point if a ns is visible it is in a view ns\n\t\t * thus the curr ns.hname is a prefix of its name.\n\t\t * Only output the virtualized portion of the name\n\t\t * Add + 2 to skip over // separating curr hname prefix\n\t\t * from the visible tail of the views hname\n\t\t */\n\t\treturn view->base.hname + strlen(curr->base.hname) + 2;\n\t}\n\n\treturn aa_hidden_ns_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_ns_name_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_label *label = begin_current_label_crit_section();\n\n\tseq_printf(seq, \"%s\\n\", aa_ns_name(labels_ns(label),\n\t\t\t\t\t   labels_ns(label), true));\n\tend_current_label_crit_section(label);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_ns_level_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1178-1187",
    "snippet": "static int seq_ns_level_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_label *label;\n\n\tlabel = begin_current_label_crit_section();\n\tseq_printf(seq, \"%d\\n\", labels_ns(label)->level);\n\tend_current_label_crit_section(label);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%d\\n\"",
            "labels_ns(label)->level"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_ns_level_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_label *label;\n\n\tlabel = begin_current_label_crit_section();\n\tseq_printf(seq, \"%d\\n\", labels_ns(label)->level);\n\tend_current_label_crit_section(label);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_ns_nsstacked_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1155-1176",
    "snippet": "static int seq_ns_nsstacked_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_label *label;\n\tstruct aa_profile *profile;\n\tstruct label_it it;\n\tint count = 1;\n\n\tlabel = begin_current_label_crit_section();\n\n\tif (label->size > 1) {\n\t\tlabel_for_each(it, label, profile)\n\t\t\tif (profile->ns != labels_ns(label)) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\tseq_printf(seq, \"%s\\n\", count > 1 ? \"yes\" : \"no\");\n\tend_current_label_crit_section(label);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%s\\n\"",
            "count > 1 ? \"yes\" : \"no\""
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_for_each",
          "args": [
            "it",
            "label",
            "profile"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_ns_nsstacked_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_label *label;\n\tstruct aa_profile *profile;\n\tstruct label_it it;\n\tint count = 1;\n\n\tlabel = begin_current_label_crit_section();\n\n\tif (label->size > 1) {\n\t\tlabel_for_each(it, label, profile)\n\t\t\tif (profile->ns != labels_ns(label)) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\tseq_printf(seq, \"%s\\n\", count > 1 ? \"yes\" : \"no\");\n\tend_current_label_crit_section(label);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_ns_stacked_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1144-1153",
    "snippet": "static int seq_ns_stacked_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_label *label;\n\n\tlabel = begin_current_label_crit_section();\n\tseq_printf(seq, \"%s\\n\", label->size > 1 ? \"yes\" : \"no\");\n\tend_current_label_crit_section(label);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%s\\n\"",
            "label->size > 1 ? \"yes\" : \"no\""
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_ns_stacked_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_label *label;\n\n\tlabel = begin_current_label_crit_section();\n\tseq_printf(seq, \"%s\\n\", label->size > 1 ? \"yes\" : \"no\");\n\tend_current_label_crit_section(label);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_profile_hash_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1102-1117",
    "snippet": "static int seq_profile_hash_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_proxy *proxy = seq->private;\n\tstruct aa_label *label = aa_get_label_rcu(&proxy->label);\n\tstruct aa_profile *profile = labels_profile(label);\n\tunsigned int i, size = aa_hash_size();\n\n\tif (profile->hash) {\n\t\tfor (i = 0; i < size; i++)\n\t\t\tseq_printf(seq, \"%.2x\", profile->hash[i]);\n\t\tseq_putc(seq, '\\n');\n\t}\n\taa_put_label(label);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "seq",
            "'\\n'"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%.2x\"",
            "profile->hash[i]"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_hash_size",
          "args": [],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "aa_hash_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/crypto.c",
          "lines": "27-30",
          "snippet": "unsigned int aa_hash_size(void)\n{\n\treturn apparmor_hash_size;\n}",
          "includes": [
            "#include \"include/crypto.h\"",
            "#include \"include/apparmor.h\"",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int apparmor_hash_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/crypto.h\"\n#include \"include/apparmor.h\"\n#include <crypto/hash.h>\n\nstatic unsigned int apparmor_hash_size;\n\nunsigned int aa_hash_size(void)\n{\n\treturn apparmor_hash_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_profile",
          "args": [
            "label"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_label_rcu",
          "args": [
            "&proxy->label"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_profile_hash_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_proxy *proxy = seq->private;\n\tstruct aa_label *label = aa_get_label_rcu(&proxy->label);\n\tstruct aa_profile *profile = labels_profile(label);\n\tunsigned int i, size = aa_hash_size();\n\n\tif (profile->hash) {\n\t\tfor (i = 0; i < size; i++)\n\t\t\tseq_printf(seq, \"%.2x\", profile->hash[i]);\n\t\tseq_putc(seq, '\\n');\n\t}\n\taa_put_label(label);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_profile_attach_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1086-1100",
    "snippet": "static int seq_profile_attach_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_proxy *proxy = seq->private;\n\tstruct aa_label *label = aa_get_label_rcu(&proxy->label);\n\tstruct aa_profile *profile = labels_profile(label);\n\tif (profile->attach)\n\t\tseq_printf(seq, \"%s\\n\", profile->attach);\n\telse if (profile->xmatch)\n\t\tseq_puts(seq, \"<unknown>\\n\");\n\telse\n\t\tseq_printf(seq, \"%s\\n\", profile->base.name);\n\taa_put_label(label);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%s\\n\"",
            "profile->base.name"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"<unknown>\\n\""
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%s\\n\"",
            "profile->attach"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_profile",
          "args": [
            "label"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_label_rcu",
          "args": [
            "&proxy->label"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_profile_attach_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_proxy *proxy = seq->private;\n\tstruct aa_label *label = aa_get_label_rcu(&proxy->label);\n\tstruct aa_profile *profile = labels_profile(label);\n\tif (profile->attach)\n\t\tseq_printf(seq, \"%s\\n\", profile->attach);\n\telse if (profile->xmatch)\n\t\tseq_puts(seq, \"<unknown>\\n\");\n\telse\n\t\tseq_printf(seq, \"%s\\n\", profile->base.name);\n\taa_put_label(label);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_profile_mode_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1075-1084",
    "snippet": "static int seq_profile_mode_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_proxy *proxy = seq->private;\n\tstruct aa_label *label = aa_get_label_rcu(&proxy->label);\n\tstruct aa_profile *profile = labels_profile(label);\n\tseq_printf(seq, \"%s\\n\", aa_profile_mode_names[profile->mode]);\n\taa_put_label(label);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%s\\n\"",
            "aa_profile_mode_names[profile->mode]"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_profile",
          "args": [
            "label"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_label_rcu",
          "args": [
            "&proxy->label"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_profile_mode_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_proxy *proxy = seq->private;\n\tstruct aa_label *label = aa_get_label_rcu(&proxy->label);\n\tstruct aa_profile *profile = labels_profile(label);\n\tseq_printf(seq, \"%s\\n\", aa_profile_mode_names[profile->mode]);\n\taa_put_label(label);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_profile_name_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1064-1073",
    "snippet": "static int seq_profile_name_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_proxy *proxy = seq->private;\n\tstruct aa_label *label = aa_get_label_rcu(&proxy->label);\n\tstruct aa_profile *profile = labels_profile(label);\n\tseq_printf(seq, \"%s\\n\", profile->base.name);\n\taa_put_label(label);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%s\\n\"",
            "profile->base.name"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_profile",
          "args": [
            "label"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_label_rcu",
          "args": [
            "&proxy->label"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_profile_name_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_proxy *proxy = seq->private;\n\tstruct aa_label *label = aa_get_label_rcu(&proxy->label);\n\tstruct aa_profile *profile = labels_profile(label);\n\tseq_printf(seq, \"%s\\n\", profile->base.name);\n\taa_put_label(label);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_profile_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1056-1062",
    "snippet": "static int seq_profile_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = (struct seq_file *) file->private_data;\n\tif (seq)\n\t\taa_put_proxy(seq->private);\n\treturn single_release(inode, file);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_proxy",
          "args": [
            "seq->private"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "434-438",
          "snippet": "static inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_profile_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = (struct seq_file *) file->private_data;\n\tif (seq)\n\t\taa_put_proxy(seq->private);\n\treturn single_release(inode, file);\n}"
  },
  {
    "function_name": "seq_profile_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1042-1054",
    "snippet": "static int seq_profile_open(struct inode *inode, struct file *file,\n\t\t\t    int (*show)(struct seq_file *, void *))\n{\n\tstruct aa_proxy *proxy = aa_get_proxy(inode->i_private);\n\tint error = single_open(file, show, proxy);\n\n\tif (error) {\n\t\tfile->private_data = NULL;\n\t\taa_put_proxy(proxy);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_proxy",
          "args": [
            "proxy"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "434-438",
          "snippet": "static inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "show",
            "proxy"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_proxy",
          "args": [
            "inode->i_private"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "426-432",
          "snippet": "static inline struct aa_proxy *aa_get_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_get(&(proxy->count));\n\n\treturn proxy;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_proxy *aa_get_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_get(&(proxy->count));\n\n\treturn proxy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int seq_profile_open(struct inode *inode, struct file *file,\n\t\t\t    int (*show)(struct seq_file *, void *))\n{\n\tstruct aa_proxy *proxy = aa_get_proxy(inode->i_private);\n\tint error = single_open(file, show, proxy);\n\n\tif (error) {\n\t\tfile->private_data = NULL;\n\t\taa_put_proxy(proxy);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "aa_sfs_seq_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "1010-1013",
    "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "aa_sfs_seq_show",
            "inode->i_private"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
  },
  {
    "function_name": "aa_sfs_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "985-1008",
    "snippet": "static int aa_sfs_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_sfs_entry *fs_file = seq->private;\n\n\tif (!fs_file)\n\t\treturn 0;\n\n\tswitch (fs_file->v_type) {\n\tcase AA_SFS_TYPE_BOOLEAN:\n\t\tseq_printf(seq, \"%s\\n\", fs_file->v.boolean ? \"yes\" : \"no\");\n\t\tbreak;\n\tcase AA_SFS_TYPE_STRING:\n\t\tseq_printf(seq, \"%s\\n\", fs_file->v.string);\n\t\tbreak;\n\tcase AA_SFS_TYPE_U64:\n\t\tseq_printf(seq, \"%#08lx\\n\", fs_file->v.u64);\n\t\tbreak;\n\tdefault:\n\t\t/* Ignore unpritable entry types. */\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%#08lx\\n\"",
            "fs_file->v.u64"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%s\\n\"",
            "fs_file->v.string"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%s\\n\"",
            "fs_file->v.boolean ? \"yes\" : \"no\""
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\n\nstatic int aa_sfs_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct aa_sfs_entry *fs_file = seq->private;\n\n\tif (!fs_file)\n\t\treturn 0;\n\n\tswitch (fs_file->v_type) {\n\tcase AA_SFS_TYPE_BOOLEAN:\n\t\tseq_printf(seq, \"%s\\n\", fs_file->v.boolean ? \"yes\" : \"no\");\n\t\tbreak;\n\tcase AA_SFS_TYPE_STRING:\n\t\tseq_printf(seq, \"%s\\n\", fs_file->v.string);\n\t\tbreak;\n\tcase AA_SFS_TYPE_U64:\n\t\tseq_printf(seq, \"%#08lx\\n\", fs_file->v.u64);\n\t\tbreak;\n\tdefault:\n\t\t/* Ignore unpritable entry types. */\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "aa_write_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "931-976",
    "snippet": "static ssize_t aa_write_access(struct file *file, const char __user *ubuf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct multi_transaction *t;\n\tssize_t len;\n\n\tif (*ppos)\n\t\treturn -ESPIPE;\n\n\tt = multi_transaction_new(file, ubuf, count);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\tif (count > QUERY_CMD_PROFILE_LEN &&\n\t    !memcmp(t->data, QUERY_CMD_PROFILE, QUERY_CMD_PROFILE_LEN)) {\n\t\tlen = query_label(t->data, MULTI_TRANSACTION_LIMIT,\n\t\t\t\t  t->data + QUERY_CMD_PROFILE_LEN,\n\t\t\t\t  count - QUERY_CMD_PROFILE_LEN, true);\n\t} else if (count > QUERY_CMD_LABEL_LEN &&\n\t\t   !memcmp(t->data, QUERY_CMD_LABEL, QUERY_CMD_LABEL_LEN)) {\n\t\tlen = query_label(t->data, MULTI_TRANSACTION_LIMIT,\n\t\t\t\t  t->data + QUERY_CMD_LABEL_LEN,\n\t\t\t\t  count - QUERY_CMD_LABEL_LEN, true);\n\t} else if (count > QUERY_CMD_LABELALL_LEN &&\n\t\t   !memcmp(t->data, QUERY_CMD_LABELALL,\n\t\t\t   QUERY_CMD_LABELALL_LEN)) {\n\t\tlen = query_label(t->data, MULTI_TRANSACTION_LIMIT,\n\t\t\t\t  t->data + QUERY_CMD_LABELALL_LEN,\n\t\t\t\t  count - QUERY_CMD_LABELALL_LEN, false);\n\t} else if (count > QUERY_CMD_DATA_LEN &&\n\t\t   !memcmp(t->data, QUERY_CMD_DATA, QUERY_CMD_DATA_LEN)) {\n\t\tlen = query_data(t->data, MULTI_TRANSACTION_LIMIT,\n\t\t\t\t t->data + QUERY_CMD_DATA_LEN,\n\t\t\t\t count - QUERY_CMD_DATA_LEN);\n\t} else\n\t\tlen = -EINVAL;\n\n\tif (len < 0) {\n\t\tput_multi_transaction(t);\n\t\treturn len;\n\t}\n\n\tmulti_transaction_set(file, t, len);\n\n\treturn count;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define QUERY_CMD_DATA_LEN\t5",
      "#define QUERY_CMD_DATA\t\t\"data\\0\"",
      "#define QUERY_CMD_LABELALL_LEN\t9",
      "#define QUERY_CMD_LABELALL\t\"labelall\\0\"",
      "#define QUERY_CMD_PROFILE_LEN\t8",
      "#define QUERY_CMD_PROFILE\t\"profile\\0\"",
      "#define QUERY_CMD_LABEL_LEN\t6",
      "#define QUERY_CMD_LABEL\t\t\"label\\0\"",
      "#define MULTI_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct multi_transaction))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "multi_transaction_set",
          "args": [
            "file",
            "t",
            "len"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "multi_transaction_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "842-855",
          "snippet": "static void multi_transaction_set(struct file *file,\n\t\t\t\t  struct multi_transaction *new, size_t n)\n{\n\tstruct multi_transaction *old;\n\n\tAA_BUG(n > MULTI_TRANSACTION_LIMIT);\n\n\tnew->size = n;\n\tspin_lock(&multi_transaction_lock);\n\told = (struct multi_transaction *) file->private_data;\n\tfile->private_data = new;\n\tspin_unlock(&multi_transaction_lock);\n\tput_multi_transaction(old);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define MULTI_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct multi_transaction))"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(multi_transaction_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\n#define MULTI_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct multi_transaction))\n\nstatic DEFINE_SPINLOCK(multi_transaction_lock);\n\nstatic void multi_transaction_set(struct file *file,\n\t\t\t\t  struct multi_transaction *new, size_t n)\n{\n\tstruct multi_transaction *old;\n\n\tAA_BUG(n > MULTI_TRANSACTION_LIMIT);\n\n\tnew->size = n;\n\tspin_lock(&multi_transaction_lock);\n\told = (struct multi_transaction *) file->private_data;\n\tfile->private_data = new;\n\tspin_unlock(&multi_transaction_lock);\n\tput_multi_transaction(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_multi_transaction",
          "args": [
            "t"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "put_multi_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "835-839",
          "snippet": "static void put_multi_transaction(struct multi_transaction *t)\n{\n\tif (t)\n\t\tkref_put(&(t->count), multi_transaction_kref);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void put_multi_transaction(struct multi_transaction *t)\n{\n\tif (t)\n\t\tkref_put(&(t->count), multi_transaction_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "query_data",
          "args": [
            "t->data",
            "MULTI_TRANSACTION_LIMIT",
            "t->data + QUERY_CMD_DATA_LEN",
            "count - QUERY_CMD_DATA_LEN"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "query_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "658-729",
          "snippet": "static ssize_t query_data(char *buf, size_t buf_len,\n\t\t\t  char *query, size_t query_len)\n{\n\tchar *out;\n\tconst char *key;\n\tstruct label_it i;\n\tstruct aa_label *label, *curr;\n\tstruct aa_profile *profile;\n\tstruct aa_data *data;\n\tu32 bytes, blocks;\n\t__le32 outle32;\n\n\tif (!query_len)\n\t\treturn -EINVAL; /* need a query */\n\n\tkey = query + strnlen(query, query_len) + 1;\n\tif (key + 1 >= query + query_len)\n\t\treturn -EINVAL; /* not enough space for a non-empty key */\n\tif (key + strnlen(key, query + query_len - key) >= query + query_len)\n\t\treturn -EINVAL; /* must end with NUL */\n\n\tif (buf_len < sizeof(bytes) + sizeof(blocks))\n\t\treturn -EINVAL; /* not enough space */\n\n\tcurr = begin_current_label_crit_section();\n\tlabel = aa_label_parse(curr, query, GFP_KERNEL, false, false);\n\tend_current_label_crit_section(curr);\n\tif (IS_ERR(label))\n\t\treturn PTR_ERR(label);\n\n\t/* We are going to leave space for two numbers. The first is the total\n\t * number of bytes we are writing after the first number. This is so\n\t * users can read the full output without reallocation.\n\t *\n\t * The second number is the number of data blocks we're writing. An\n\t * application might be confined by multiple policies having data in\n\t * the same key.\n\t */\n\tmemset(buf, 0, sizeof(bytes) + sizeof(blocks));\n\tout = buf + sizeof(bytes) + sizeof(blocks);\n\n\tblocks = 0;\n\tlabel_for_each_confined(i, label, profile) {\n\t\tif (!profile->data)\n\t\t\tcontinue;\n\n\t\tdata = rhashtable_lookup_fast(profile->data, &key,\n\t\t\t\t\t      profile->data->p);\n\n\t\tif (data) {\n\t\t\tif (out + sizeof(outle32) + data->size > buf +\n\t\t\t    buf_len) {\n\t\t\t\taa_put_label(label);\n\t\t\t\treturn -EINVAL; /* not enough space */\n\t\t\t}\n\t\t\toutle32 = __cpu_to_le32(data->size);\n\t\t\tmemcpy(out, &outle32, sizeof(outle32));\n\t\t\tout += sizeof(outle32);\n\t\t\tmemcpy(out, data->data, data->size);\n\t\t\tout += data->size;\n\t\t\tblocks++;\n\t\t}\n\t}\n\taa_put_label(label);\n\n\toutle32 = __cpu_to_le32(out - buf - sizeof(bytes));\n\tmemcpy(buf, &outle32, sizeof(outle32));\n\toutle32 = __cpu_to_le32(blocks);\n\tmemcpy(buf + sizeof(bytes), &outle32, sizeof(outle32));\n\n\treturn out - buf;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic ssize_t query_data(char *buf, size_t buf_len,\n\t\t\t  char *query, size_t query_len)\n{\n\tchar *out;\n\tconst char *key;\n\tstruct label_it i;\n\tstruct aa_label *label, *curr;\n\tstruct aa_profile *profile;\n\tstruct aa_data *data;\n\tu32 bytes, blocks;\n\t__le32 outle32;\n\n\tif (!query_len)\n\t\treturn -EINVAL; /* need a query */\n\n\tkey = query + strnlen(query, query_len) + 1;\n\tif (key + 1 >= query + query_len)\n\t\treturn -EINVAL; /* not enough space for a non-empty key */\n\tif (key + strnlen(key, query + query_len - key) >= query + query_len)\n\t\treturn -EINVAL; /* must end with NUL */\n\n\tif (buf_len < sizeof(bytes) + sizeof(blocks))\n\t\treturn -EINVAL; /* not enough space */\n\n\tcurr = begin_current_label_crit_section();\n\tlabel = aa_label_parse(curr, query, GFP_KERNEL, false, false);\n\tend_current_label_crit_section(curr);\n\tif (IS_ERR(label))\n\t\treturn PTR_ERR(label);\n\n\t/* We are going to leave space for two numbers. The first is the total\n\t * number of bytes we are writing after the first number. This is so\n\t * users can read the full output without reallocation.\n\t *\n\t * The second number is the number of data blocks we're writing. An\n\t * application might be confined by multiple policies having data in\n\t * the same key.\n\t */\n\tmemset(buf, 0, sizeof(bytes) + sizeof(blocks));\n\tout = buf + sizeof(bytes) + sizeof(blocks);\n\n\tblocks = 0;\n\tlabel_for_each_confined(i, label, profile) {\n\t\tif (!profile->data)\n\t\t\tcontinue;\n\n\t\tdata = rhashtable_lookup_fast(profile->data, &key,\n\t\t\t\t\t      profile->data->p);\n\n\t\tif (data) {\n\t\t\tif (out + sizeof(outle32) + data->size > buf +\n\t\t\t    buf_len) {\n\t\t\t\taa_put_label(label);\n\t\t\t\treturn -EINVAL; /* not enough space */\n\t\t\t}\n\t\t\toutle32 = __cpu_to_le32(data->size);\n\t\t\tmemcpy(out, &outle32, sizeof(outle32));\n\t\t\tout += sizeof(outle32);\n\t\t\tmemcpy(out, data->data, data->size);\n\t\t\tout += data->size;\n\t\t\tblocks++;\n\t\t}\n\t}\n\taa_put_label(label);\n\n\toutle32 = __cpu_to_le32(out - buf - sizeof(bytes));\n\tmemcpy(buf, &outle32, sizeof(outle32));\n\toutle32 = __cpu_to_le32(blocks);\n\tmemcpy(buf + sizeof(bytes), &outle32, sizeof(outle32));\n\n\treturn out - buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "t->data",
            "QUERY_CMD_DATA",
            "QUERY_CMD_DATA_LEN"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "query_label",
          "args": [
            "t->data",
            "MULTI_TRANSACTION_LIMIT",
            "t->data + QUERY_CMD_LABELALL_LEN",
            "count - QUERY_CMD_LABELALL_LEN",
            "false"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "query_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "751-799",
          "snippet": "static ssize_t query_label(char *buf, size_t buf_len,\n\t\t\t   char *query, size_t query_len, bool view_only)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *label, *curr;\n\tchar *label_name, *match_str;\n\tsize_t label_name_len, match_len;\n\tstruct aa_perms perms;\n\tstruct label_it i;\n\n\tif (!query_len)\n\t\treturn -EINVAL;\n\n\tlabel_name = query;\n\tlabel_name_len = strnlen(query, query_len);\n\tif (!label_name_len || label_name_len == query_len)\n\t\treturn -EINVAL;\n\n\t/**\n\t * The extra byte is to account for the null byte between the\n\t * profile name and dfa string. profile_name_len is greater\n\t * than zero and less than query_len, so a byte can be safely\n\t * added or subtracted.\n\t */\n\tmatch_str = label_name + label_name_len + 1;\n\tmatch_len = query_len - label_name_len - 1;\n\n\tcurr = begin_current_label_crit_section();\n\tlabel = aa_label_parse(curr, label_name, GFP_KERNEL, false, false);\n\tend_current_label_crit_section(curr);\n\tif (IS_ERR(label))\n\t\treturn PTR_ERR(label);\n\n\tperms = allperms;\n\tif (view_only) {\n\t\tlabel_for_each_in_ns(i, labels_ns(label), label, profile) {\n\t\t\tprofile_query_cb(profile, &perms, match_str, match_len);\n\t\t}\n\t} else {\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tprofile_query_cb(profile, &perms, match_str, match_len);\n\t\t}\n\t}\n\taa_put_label(label);\n\n\treturn scnprintf(buf, buf_len,\n\t\t      \"allow 0x%08x\\ndeny 0x%08x\\naudit 0x%08x\\nquiet 0x%08x\\n\",\n\t\t      perms.allow, perms.deny, perms.audit, perms.quiet);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic ssize_t query_label(char *buf, size_t buf_len,\n\t\t\t   char *query, size_t query_len, bool view_only)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *label, *curr;\n\tchar *label_name, *match_str;\n\tsize_t label_name_len, match_len;\n\tstruct aa_perms perms;\n\tstruct label_it i;\n\n\tif (!query_len)\n\t\treturn -EINVAL;\n\n\tlabel_name = query;\n\tlabel_name_len = strnlen(query, query_len);\n\tif (!label_name_len || label_name_len == query_len)\n\t\treturn -EINVAL;\n\n\t/**\n\t * The extra byte is to account for the null byte between the\n\t * profile name and dfa string. profile_name_len is greater\n\t * than zero and less than query_len, so a byte can be safely\n\t * added or subtracted.\n\t */\n\tmatch_str = label_name + label_name_len + 1;\n\tmatch_len = query_len - label_name_len - 1;\n\n\tcurr = begin_current_label_crit_section();\n\tlabel = aa_label_parse(curr, label_name, GFP_KERNEL, false, false);\n\tend_current_label_crit_section(curr);\n\tif (IS_ERR(label))\n\t\treturn PTR_ERR(label);\n\n\tperms = allperms;\n\tif (view_only) {\n\t\tlabel_for_each_in_ns(i, labels_ns(label), label, profile) {\n\t\t\tprofile_query_cb(profile, &perms, match_str, match_len);\n\t\t}\n\t} else {\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tprofile_query_cb(profile, &perms, match_str, match_len);\n\t\t}\n\t}\n\taa_put_label(label);\n\n\treturn scnprintf(buf, buf_len,\n\t\t      \"allow 0x%08x\\ndeny 0x%08x\\naudit 0x%08x\\nquiet 0x%08x\\n\",\n\t\t      perms.allow, perms.deny, perms.audit, perms.quiet);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "t->data",
            "QUERY_CMD_LABELALL",
            "QUERY_CMD_LABELALL_LEN"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "t->data",
            "QUERY_CMD_LABEL",
            "QUERY_CMD_LABEL_LEN"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "t->data",
            "QUERY_CMD_PROFILE",
            "QUERY_CMD_PROFILE_LEN"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "t"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "t"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multi_transaction_new",
          "args": [
            "file",
            "ubuf",
            "count"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "multi_transaction_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "857-874",
          "snippet": "static struct multi_transaction *multi_transaction_new(struct file *file,\n\t\t\t\t\t\t       const char __user *buf,\n\t\t\t\t\t\t       size_t size)\n{\n\tstruct multi_transaction *t;\n\n\tif (size > MULTI_TRANSACTION_LIMIT - 1)\n\t\treturn ERR_PTR(-EFBIG);\n\n\tt = (struct multi_transaction *)get_zeroed_page(GFP_KERNEL);\n\tif (!t)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkref_init(&t->count);\n\tif (copy_from_user(t->data, buf, size))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn t;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define MULTI_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct multi_transaction))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\n#define MULTI_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct multi_transaction))\n\nstatic struct multi_transaction *multi_transaction_new(struct file *file,\n\t\t\t\t\t\t       const char __user *buf,\n\t\t\t\t\t\t       size_t size)\n{\n\tstruct multi_transaction *t;\n\n\tif (size > MULTI_TRANSACTION_LIMIT - 1)\n\t\treturn ERR_PTR(-EFBIG);\n\n\tt = (struct multi_transaction *)get_zeroed_page(GFP_KERNEL);\n\tif (!t)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkref_init(&t->count);\n\tif (copy_from_user(t->data, buf, size))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn t;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\n#define QUERY_CMD_DATA_LEN\t5\n#define QUERY_CMD_DATA\t\t\"data\\0\"\n#define QUERY_CMD_LABELALL_LEN\t9\n#define QUERY_CMD_LABELALL\t\"labelall\\0\"\n#define QUERY_CMD_PROFILE_LEN\t8\n#define QUERY_CMD_PROFILE\t\"profile\\0\"\n#define QUERY_CMD_LABEL_LEN\t6\n#define QUERY_CMD_LABEL\t\t\"label\\0\"\n#define MULTI_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct multi_transaction))\n\nstatic ssize_t aa_write_access(struct file *file, const char __user *ubuf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct multi_transaction *t;\n\tssize_t len;\n\n\tif (*ppos)\n\t\treturn -ESPIPE;\n\n\tt = multi_transaction_new(file, ubuf, count);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\tif (count > QUERY_CMD_PROFILE_LEN &&\n\t    !memcmp(t->data, QUERY_CMD_PROFILE, QUERY_CMD_PROFILE_LEN)) {\n\t\tlen = query_label(t->data, MULTI_TRANSACTION_LIMIT,\n\t\t\t\t  t->data + QUERY_CMD_PROFILE_LEN,\n\t\t\t\t  count - QUERY_CMD_PROFILE_LEN, true);\n\t} else if (count > QUERY_CMD_LABEL_LEN &&\n\t\t   !memcmp(t->data, QUERY_CMD_LABEL, QUERY_CMD_LABEL_LEN)) {\n\t\tlen = query_label(t->data, MULTI_TRANSACTION_LIMIT,\n\t\t\t\t  t->data + QUERY_CMD_LABEL_LEN,\n\t\t\t\t  count - QUERY_CMD_LABEL_LEN, true);\n\t} else if (count > QUERY_CMD_LABELALL_LEN &&\n\t\t   !memcmp(t->data, QUERY_CMD_LABELALL,\n\t\t\t   QUERY_CMD_LABELALL_LEN)) {\n\t\tlen = query_label(t->data, MULTI_TRANSACTION_LIMIT,\n\t\t\t\t  t->data + QUERY_CMD_LABELALL_LEN,\n\t\t\t\t  count - QUERY_CMD_LABELALL_LEN, false);\n\t} else if (count > QUERY_CMD_DATA_LEN &&\n\t\t   !memcmp(t->data, QUERY_CMD_DATA, QUERY_CMD_DATA_LEN)) {\n\t\tlen = query_data(t->data, MULTI_TRANSACTION_LIMIT,\n\t\t\t\t t->data + QUERY_CMD_DATA_LEN,\n\t\t\t\t count - QUERY_CMD_DATA_LEN);\n\t} else\n\t\tlen = -EINVAL;\n\n\tif (len < 0) {\n\t\tput_multi_transaction(t);\n\t\treturn len;\n\t}\n\n\tmulti_transaction_set(file, t, len);\n\n\treturn count;\n}"
  },
  {
    "function_name": "multi_transaction_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "894-899",
    "snippet": "static int multi_transaction_release(struct inode *inode, struct file *file)\n{\n\tput_multi_transaction(file->private_data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_multi_transaction",
          "args": [
            "file->private_data"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "put_multi_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "835-839",
          "snippet": "static void put_multi_transaction(struct multi_transaction *t)\n{\n\tif (t)\n\t\tkref_put(&(t->count), multi_transaction_kref);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void put_multi_transaction(struct multi_transaction *t)\n{\n\tif (t)\n\t\tkref_put(&(t->count), multi_transaction_kref);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int multi_transaction_release(struct inode *inode, struct file *file)\n{\n\tput_multi_transaction(file->private_data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "multi_transaction_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "876-892",
    "snippet": "static ssize_t multi_transaction_read(struct file *file, char __user *buf,\n\t\t\t\t       size_t size, loff_t *pos)\n{\n\tstruct multi_transaction *t;\n\tssize_t ret;\n\n\tspin_lock(&multi_transaction_lock);\n\tt = get_multi_transaction(file->private_data);\n\tspin_unlock(&multi_transaction_lock);\n\tif (!t)\n\t\treturn 0;\n\n\tret = simple_read_from_buffer(buf, size, pos, t->data, t->size);\n\tput_multi_transaction(t);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(multi_transaction_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_multi_transaction",
          "args": [
            "t"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "put_multi_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "835-839",
          "snippet": "static void put_multi_transaction(struct multi_transaction *t)\n{\n\tif (t)\n\t\tkref_put(&(t->count), multi_transaction_kref);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void put_multi_transaction(struct multi_transaction *t)\n{\n\tif (t)\n\t\tkref_put(&(t->count), multi_transaction_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "size",
            "pos",
            "t->data",
            "t->size"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&multi_transaction_lock"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_multi_transaction",
          "args": [
            "file->private_data"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "get_multi_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "826-833",
          "snippet": "static struct multi_transaction *\nget_multi_transaction(struct multi_transaction *t)\n{\n\tif  (t)\n\t\tkref_get(&(t->count));\n\n\treturn t;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct multi_transaction *\nget_multi_transaction(struct multi_transaction *t)\n{\n\tif  (t)\n\t\tkref_get(&(t->count));\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&multi_transaction_lock"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic DEFINE_SPINLOCK(multi_transaction_lock);\n\nstatic ssize_t multi_transaction_read(struct file *file, char __user *buf,\n\t\t\t\t       size_t size, loff_t *pos)\n{\n\tstruct multi_transaction *t;\n\tssize_t ret;\n\n\tspin_lock(&multi_transaction_lock);\n\tt = get_multi_transaction(file->private_data);\n\tspin_unlock(&multi_transaction_lock);\n\tif (!t)\n\t\treturn 0;\n\n\tret = simple_read_from_buffer(buf, size, pos, t->data, t->size);\n\tput_multi_transaction(t);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "multi_transaction_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "857-874",
    "snippet": "static struct multi_transaction *multi_transaction_new(struct file *file,\n\t\t\t\t\t\t       const char __user *buf,\n\t\t\t\t\t\t       size_t size)\n{\n\tstruct multi_transaction *t;\n\n\tif (size > MULTI_TRANSACTION_LIMIT - 1)\n\t\treturn ERR_PTR(-EFBIG);\n\n\tt = (struct multi_transaction *)get_zeroed_page(GFP_KERNEL);\n\tif (!t)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkref_init(&t->count);\n\tif (copy_from_user(t->data, buf, size))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn t;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define MULTI_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct multi_transaction))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "t->data",
            "buf",
            "size"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&t->count"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFBIG"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\n#define MULTI_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct multi_transaction))\n\nstatic struct multi_transaction *multi_transaction_new(struct file *file,\n\t\t\t\t\t\t       const char __user *buf,\n\t\t\t\t\t\t       size_t size)\n{\n\tstruct multi_transaction *t;\n\n\tif (size > MULTI_TRANSACTION_LIMIT - 1)\n\t\treturn ERR_PTR(-EFBIG);\n\n\tt = (struct multi_transaction *)get_zeroed_page(GFP_KERNEL);\n\tif (!t)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkref_init(&t->count);\n\tif (copy_from_user(t->data, buf, size))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn t;\n}"
  },
  {
    "function_name": "multi_transaction_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "842-855",
    "snippet": "static void multi_transaction_set(struct file *file,\n\t\t\t\t  struct multi_transaction *new, size_t n)\n{\n\tstruct multi_transaction *old;\n\n\tAA_BUG(n > MULTI_TRANSACTION_LIMIT);\n\n\tnew->size = n;\n\tspin_lock(&multi_transaction_lock);\n\told = (struct multi_transaction *) file->private_data;\n\tfile->private_data = new;\n\tspin_unlock(&multi_transaction_lock);\n\tput_multi_transaction(old);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define MULTI_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct multi_transaction))"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(multi_transaction_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_multi_transaction",
          "args": [
            "old"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "put_multi_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "835-839",
          "snippet": "static void put_multi_transaction(struct multi_transaction *t)\n{\n\tif (t)\n\t\tkref_put(&(t->count), multi_transaction_kref);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void put_multi_transaction(struct multi_transaction *t)\n{\n\tif (t)\n\t\tkref_put(&(t->count), multi_transaction_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&multi_transaction_lock"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&multi_transaction_lock"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "n > MULTI_TRANSACTION_LIMIT"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\n#define MULTI_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct multi_transaction))\n\nstatic DEFINE_SPINLOCK(multi_transaction_lock);\n\nstatic void multi_transaction_set(struct file *file,\n\t\t\t\t  struct multi_transaction *new, size_t n)\n{\n\tstruct multi_transaction *old;\n\n\tAA_BUG(n > MULTI_TRANSACTION_LIMIT);\n\n\tnew->size = n;\n\tspin_lock(&multi_transaction_lock);\n\told = (struct multi_transaction *) file->private_data;\n\tfile->private_data = new;\n\tspin_unlock(&multi_transaction_lock);\n\tput_multi_transaction(old);\n}"
  },
  {
    "function_name": "put_multi_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "835-839",
    "snippet": "static void put_multi_transaction(struct multi_transaction *t)\n{\n\tif (t)\n\t\tkref_put(&(t->count), multi_transaction_kref);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&(t->count)",
            "multi_transaction_kref"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void put_multi_transaction(struct multi_transaction *t)\n{\n\tif (t)\n\t\tkref_put(&(t->count), multi_transaction_kref);\n}"
  },
  {
    "function_name": "get_multi_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "826-833",
    "snippet": "static struct multi_transaction *\nget_multi_transaction(struct multi_transaction *t)\n{\n\tif  (t)\n\t\tkref_get(&(t->count));\n\n\treturn t;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&(t->count)"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct multi_transaction *\nget_multi_transaction(struct multi_transaction *t)\n{\n\tif  (t)\n\t\tkref_get(&(t->count));\n\n\treturn t;\n}"
  },
  {
    "function_name": "multi_transaction_kref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "818-824",
    "snippet": "static void multi_transaction_kref(struct kref *kref)\n{\n\tstruct multi_transaction *t;\n\n\tt = container_of(kref, struct multi_transaction, count);\n\tfree_page((unsigned long) t);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) t"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structmulti_transaction",
            "count"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void multi_transaction_kref(struct kref *kref)\n{\n\tstruct multi_transaction *t;\n\n\tt = container_of(kref, struct multi_transaction, count);\n\tfree_page((unsigned long) t);\n}"
  },
  {
    "function_name": "query_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "751-799",
    "snippet": "static ssize_t query_label(char *buf, size_t buf_len,\n\t\t\t   char *query, size_t query_len, bool view_only)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *label, *curr;\n\tchar *label_name, *match_str;\n\tsize_t label_name_len, match_len;\n\tstruct aa_perms perms;\n\tstruct label_it i;\n\n\tif (!query_len)\n\t\treturn -EINVAL;\n\n\tlabel_name = query;\n\tlabel_name_len = strnlen(query, query_len);\n\tif (!label_name_len || label_name_len == query_len)\n\t\treturn -EINVAL;\n\n\t/**\n\t * The extra byte is to account for the null byte between the\n\t * profile name and dfa string. profile_name_len is greater\n\t * than zero and less than query_len, so a byte can be safely\n\t * added or subtracted.\n\t */\n\tmatch_str = label_name + label_name_len + 1;\n\tmatch_len = query_len - label_name_len - 1;\n\n\tcurr = begin_current_label_crit_section();\n\tlabel = aa_label_parse(curr, label_name, GFP_KERNEL, false, false);\n\tend_current_label_crit_section(curr);\n\tif (IS_ERR(label))\n\t\treturn PTR_ERR(label);\n\n\tperms = allperms;\n\tif (view_only) {\n\t\tlabel_for_each_in_ns(i, labels_ns(label), label, profile) {\n\t\t\tprofile_query_cb(profile, &perms, match_str, match_len);\n\t\t}\n\t} else {\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tprofile_query_cb(profile, &perms, match_str, match_len);\n\t\t}\n\t}\n\taa_put_label(label);\n\n\treturn scnprintf(buf, buf_len,\n\t\t      \"allow 0x%08x\\ndeny 0x%08x\\naudit 0x%08x\\nquiet 0x%08x\\n\",\n\t\t      perms.allow, perms.deny, perms.audit, perms.quiet);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "buf_len",
            "\"allow 0x%08x\\ndeny 0x%08x\\naudit 0x%08x\\nquiet 0x%08x\\n\"",
            "perms.allow",
            "perms.deny",
            "perms.audit",
            "perms.quiet"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_query_cb",
          "args": [
            "profile",
            "&perms",
            "match_str",
            "match_len"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "profile_query_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "605-637",
          "snippet": "static void profile_query_cb(struct aa_profile *profile, struct aa_perms *perms,\n\t\t\t     const char *match_str, size_t match_len)\n{\n\tstruct aa_perms tmp;\n\tstruct aa_dfa *dfa;\n\tunsigned int state = 0;\n\n\tif (profile_unconfined(profile))\n\t\treturn;\n\tif (profile->file.dfa && *match_str == AA_CLASS_FILE) {\n\t\tdfa = profile->file.dfa;\n\t\tstate = aa_dfa_match_len(dfa, profile->file.start,\n\t\t\t\t\t match_str + 1, match_len - 1);\n\t\ttmp = nullperms;\n\t\tif (state) {\n\t\t\tstruct path_cond cond = { };\n\n\t\t\ttmp = aa_compute_fperms(dfa, state, &cond);\n\t\t}\n\t} else if (profile->policy.dfa) {\n\t\tif (!PROFILE_MEDIATES_SAFE(profile, *match_str))\n\t\t\treturn;\t/* no change to current perms */\n\t\tdfa = profile->policy.dfa;\n\t\tstate = aa_dfa_match_len(dfa, profile->policy.start[0],\n\t\t\t\t\t match_str, match_len);\n\t\tif (state)\n\t\t\taa_compute_perms(dfa, state, &tmp);\n\t\telse\n\t\t\ttmp = nullperms;\n\t}\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum_raw(perms, &tmp);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void profile_query_cb(struct aa_profile *profile, struct aa_perms *perms,\n\t\t\t     const char *match_str, size_t match_len)\n{\n\tstruct aa_perms tmp;\n\tstruct aa_dfa *dfa;\n\tunsigned int state = 0;\n\n\tif (profile_unconfined(profile))\n\t\treturn;\n\tif (profile->file.dfa && *match_str == AA_CLASS_FILE) {\n\t\tdfa = profile->file.dfa;\n\t\tstate = aa_dfa_match_len(dfa, profile->file.start,\n\t\t\t\t\t match_str + 1, match_len - 1);\n\t\ttmp = nullperms;\n\t\tif (state) {\n\t\t\tstruct path_cond cond = { };\n\n\t\t\ttmp = aa_compute_fperms(dfa, state, &cond);\n\t\t}\n\t} else if (profile->policy.dfa) {\n\t\tif (!PROFILE_MEDIATES_SAFE(profile, *match_str))\n\t\t\treturn;\t/* no change to current perms */\n\t\tdfa = profile->policy.dfa;\n\t\tstate = aa_dfa_match_len(dfa, profile->policy.start[0],\n\t\t\t\t\t match_str, match_len);\n\t\tif (state)\n\t\t\taa_compute_perms(dfa, state, &tmp);\n\t\telse\n\t\t\ttmp = nullperms;\n\t}\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum_raw(perms, &tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_for_each",
          "args": [
            "i",
            "label",
            "profile"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_for_each_in_ns",
          "args": [
            "i",
            "labels_ns(label)",
            "label",
            "profile"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "label"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "label"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "curr"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_parse",
          "args": [
            "curr",
            "label_name",
            "GFP_KERNEL",
            "false",
            "false"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1856-1931",
          "snippet": "struct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack)\n{\n\tDEFINE_VEC(profile, vec);\n\tstruct aa_label *label, *currbase = base;\n\tint i, len, stack = 0, error;\n\tchar *split;\n\n\tAA_BUG(!base);\n\tAA_BUG(!str);\n\n\tstr = skip_spaces(str);\n\tlen = label_count_str_entries(str);\n\tif (*str == '&' || force_stack) {\n\t\t/* stack on top of base */\n\t\tstack = base->size;\n\t\tlen += stack;\n\t\tif (*str == '&')\n\t\t\tstr++;\n\t}\n\tif (*str == '=')\n\t\tbase = &root_ns->unconfined->label;\n\n\terror = vec_setup(profile, vec, len, gfp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tfor (i = 0; i < stack; i++)\n\t\tvec[i] = aa_get_profile(base->vec[i]);\n\n\tfor (split = strstr(str, \"//&\"), i = stack; split && i < len; i++) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, split - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t\t/*\n\t\t * if component specified a new ns it becomes the new base\n\t\t * so that subsequent lookups are relative to it\n\t\t */\n\t\tif (vec[i]->ns != labels_ns(currbase))\n\t\t\tcurrbase = &vec[i]->label;\n\t\tstr = split + 3;\n\t\tsplit = strstr(str, \"//&\");\n\t}\n\t/* last element doesn't have a split */\n\tif (i < len) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, strlen(str));\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t}\n\tif (len == 1)\n\t\t/* no need to free vec as len < LOCAL_VEC_ENTRIES */\n\t\treturn &vec[0]->label;\n\n\tlen -= aa_vec_unique(vec, len, VEC_FLAG_TERMINATE);\n\t/* TODO: deal with reference labels */\n\tif (len == 1) {\n\t\tlabel = aa_get_label(&vec[0]->label);\n\t\tgoto out;\n\t}\n\n\tif (create)\n\t\tlabel = aa_vec_find_or_create_label(vec, len, gfp);\n\telse\n\t\tlabel = vec_find(vec, len);\n\tif (!label)\n\t\tgoto fail;\n\nout:\n\t/* use adjusted len from after vec_unique, not original */\n\tvec_cleanup(profile, vec, len);\n\treturn label;\n\nfail:\n\tlabel = ERR_PTR(-ENOENT);\n\tgoto out;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack)\n{\n\tDEFINE_VEC(profile, vec);\n\tstruct aa_label *label, *currbase = base;\n\tint i, len, stack = 0, error;\n\tchar *split;\n\n\tAA_BUG(!base);\n\tAA_BUG(!str);\n\n\tstr = skip_spaces(str);\n\tlen = label_count_str_entries(str);\n\tif (*str == '&' || force_stack) {\n\t\t/* stack on top of base */\n\t\tstack = base->size;\n\t\tlen += stack;\n\t\tif (*str == '&')\n\t\t\tstr++;\n\t}\n\tif (*str == '=')\n\t\tbase = &root_ns->unconfined->label;\n\n\terror = vec_setup(profile, vec, len, gfp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tfor (i = 0; i < stack; i++)\n\t\tvec[i] = aa_get_profile(base->vec[i]);\n\n\tfor (split = strstr(str, \"//&\"), i = stack; split && i < len; i++) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, split - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t\t/*\n\t\t * if component specified a new ns it becomes the new base\n\t\t * so that subsequent lookups are relative to it\n\t\t */\n\t\tif (vec[i]->ns != labels_ns(currbase))\n\t\t\tcurrbase = &vec[i]->label;\n\t\tstr = split + 3;\n\t\tsplit = strstr(str, \"//&\");\n\t}\n\t/* last element doesn't have a split */\n\tif (i < len) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, strlen(str));\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t}\n\tif (len == 1)\n\t\t/* no need to free vec as len < LOCAL_VEC_ENTRIES */\n\t\treturn &vec[0]->label;\n\n\tlen -= aa_vec_unique(vec, len, VEC_FLAG_TERMINATE);\n\t/* TODO: deal with reference labels */\n\tif (len == 1) {\n\t\tlabel = aa_get_label(&vec[0]->label);\n\t\tgoto out;\n\t}\n\n\tif (create)\n\t\tlabel = aa_vec_find_or_create_label(vec, len, gfp);\n\telse\n\t\tlabel = vec_find(vec, len);\n\tif (!label)\n\t\tgoto fail;\n\nout:\n\t/* use adjusted len from after vec_unique, not original */\n\tvec_cleanup(profile, vec, len);\n\treturn label;\n\nfail:\n\tlabel = ERR_PTR(-ENOENT);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "query",
            "query_len"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic ssize_t query_label(char *buf, size_t buf_len,\n\t\t\t   char *query, size_t query_len, bool view_only)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *label, *curr;\n\tchar *label_name, *match_str;\n\tsize_t label_name_len, match_len;\n\tstruct aa_perms perms;\n\tstruct label_it i;\n\n\tif (!query_len)\n\t\treturn -EINVAL;\n\n\tlabel_name = query;\n\tlabel_name_len = strnlen(query, query_len);\n\tif (!label_name_len || label_name_len == query_len)\n\t\treturn -EINVAL;\n\n\t/**\n\t * The extra byte is to account for the null byte between the\n\t * profile name and dfa string. profile_name_len is greater\n\t * than zero and less than query_len, so a byte can be safely\n\t * added or subtracted.\n\t */\n\tmatch_str = label_name + label_name_len + 1;\n\tmatch_len = query_len - label_name_len - 1;\n\n\tcurr = begin_current_label_crit_section();\n\tlabel = aa_label_parse(curr, label_name, GFP_KERNEL, false, false);\n\tend_current_label_crit_section(curr);\n\tif (IS_ERR(label))\n\t\treturn PTR_ERR(label);\n\n\tperms = allperms;\n\tif (view_only) {\n\t\tlabel_for_each_in_ns(i, labels_ns(label), label, profile) {\n\t\t\tprofile_query_cb(profile, &perms, match_str, match_len);\n\t\t}\n\t} else {\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tprofile_query_cb(profile, &perms, match_str, match_len);\n\t\t}\n\t}\n\taa_put_label(label);\n\n\treturn scnprintf(buf, buf_len,\n\t\t      \"allow 0x%08x\\ndeny 0x%08x\\naudit 0x%08x\\nquiet 0x%08x\\n\",\n\t\t      perms.allow, perms.deny, perms.audit, perms.quiet);\n}"
  },
  {
    "function_name": "query_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "658-729",
    "snippet": "static ssize_t query_data(char *buf, size_t buf_len,\n\t\t\t  char *query, size_t query_len)\n{\n\tchar *out;\n\tconst char *key;\n\tstruct label_it i;\n\tstruct aa_label *label, *curr;\n\tstruct aa_profile *profile;\n\tstruct aa_data *data;\n\tu32 bytes, blocks;\n\t__le32 outle32;\n\n\tif (!query_len)\n\t\treturn -EINVAL; /* need a query */\n\n\tkey = query + strnlen(query, query_len) + 1;\n\tif (key + 1 >= query + query_len)\n\t\treturn -EINVAL; /* not enough space for a non-empty key */\n\tif (key + strnlen(key, query + query_len - key) >= query + query_len)\n\t\treturn -EINVAL; /* must end with NUL */\n\n\tif (buf_len < sizeof(bytes) + sizeof(blocks))\n\t\treturn -EINVAL; /* not enough space */\n\n\tcurr = begin_current_label_crit_section();\n\tlabel = aa_label_parse(curr, query, GFP_KERNEL, false, false);\n\tend_current_label_crit_section(curr);\n\tif (IS_ERR(label))\n\t\treturn PTR_ERR(label);\n\n\t/* We are going to leave space for two numbers. The first is the total\n\t * number of bytes we are writing after the first number. This is so\n\t * users can read the full output without reallocation.\n\t *\n\t * The second number is the number of data blocks we're writing. An\n\t * application might be confined by multiple policies having data in\n\t * the same key.\n\t */\n\tmemset(buf, 0, sizeof(bytes) + sizeof(blocks));\n\tout = buf + sizeof(bytes) + sizeof(blocks);\n\n\tblocks = 0;\n\tlabel_for_each_confined(i, label, profile) {\n\t\tif (!profile->data)\n\t\t\tcontinue;\n\n\t\tdata = rhashtable_lookup_fast(profile->data, &key,\n\t\t\t\t\t      profile->data->p);\n\n\t\tif (data) {\n\t\t\tif (out + sizeof(outle32) + data->size > buf +\n\t\t\t    buf_len) {\n\t\t\t\taa_put_label(label);\n\t\t\t\treturn -EINVAL; /* not enough space */\n\t\t\t}\n\t\t\toutle32 = __cpu_to_le32(data->size);\n\t\t\tmemcpy(out, &outle32, sizeof(outle32));\n\t\t\tout += sizeof(outle32);\n\t\t\tmemcpy(out, data->data, data->size);\n\t\t\tout += data->size;\n\t\t\tblocks++;\n\t\t}\n\t}\n\taa_put_label(label);\n\n\toutle32 = __cpu_to_le32(out - buf - sizeof(bytes));\n\tmemcpy(buf, &outle32, sizeof(outle32));\n\toutle32 = __cpu_to_le32(blocks);\n\tmemcpy(buf + sizeof(bytes), &outle32, sizeof(outle32));\n\n\treturn out - buf;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + sizeof(bytes)",
            "&outle32",
            "sizeof(outle32)"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cpu_to_le32",
          "args": [
            "blocks"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&outle32",
            "sizeof(outle32)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cpu_to_le32",
          "args": [
            "out - buf - sizeof(bytes)"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out",
            "data->data",
            "data->size"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out",
            "&outle32",
            "sizeof(outle32)"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cpu_to_le32",
          "args": [
            "data->size"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rhashtable_lookup_fast",
          "args": [
            "profile->data",
            "&key",
            "profile->data->p"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_for_each_confined",
          "args": [
            "i",
            "label",
            "profile"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(bytes) + sizeof(blocks)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "label"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "label"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "curr"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_parse",
          "args": [
            "curr",
            "query",
            "GFP_KERNEL",
            "false",
            "false"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1856-1931",
          "snippet": "struct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack)\n{\n\tDEFINE_VEC(profile, vec);\n\tstruct aa_label *label, *currbase = base;\n\tint i, len, stack = 0, error;\n\tchar *split;\n\n\tAA_BUG(!base);\n\tAA_BUG(!str);\n\n\tstr = skip_spaces(str);\n\tlen = label_count_str_entries(str);\n\tif (*str == '&' || force_stack) {\n\t\t/* stack on top of base */\n\t\tstack = base->size;\n\t\tlen += stack;\n\t\tif (*str == '&')\n\t\t\tstr++;\n\t}\n\tif (*str == '=')\n\t\tbase = &root_ns->unconfined->label;\n\n\terror = vec_setup(profile, vec, len, gfp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tfor (i = 0; i < stack; i++)\n\t\tvec[i] = aa_get_profile(base->vec[i]);\n\n\tfor (split = strstr(str, \"//&\"), i = stack; split && i < len; i++) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, split - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t\t/*\n\t\t * if component specified a new ns it becomes the new base\n\t\t * so that subsequent lookups are relative to it\n\t\t */\n\t\tif (vec[i]->ns != labels_ns(currbase))\n\t\t\tcurrbase = &vec[i]->label;\n\t\tstr = split + 3;\n\t\tsplit = strstr(str, \"//&\");\n\t}\n\t/* last element doesn't have a split */\n\tif (i < len) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, strlen(str));\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t}\n\tif (len == 1)\n\t\t/* no need to free vec as len < LOCAL_VEC_ENTRIES */\n\t\treturn &vec[0]->label;\n\n\tlen -= aa_vec_unique(vec, len, VEC_FLAG_TERMINATE);\n\t/* TODO: deal with reference labels */\n\tif (len == 1) {\n\t\tlabel = aa_get_label(&vec[0]->label);\n\t\tgoto out;\n\t}\n\n\tif (create)\n\t\tlabel = aa_vec_find_or_create_label(vec, len, gfp);\n\telse\n\t\tlabel = vec_find(vec, len);\n\tif (!label)\n\t\tgoto fail;\n\nout:\n\t/* use adjusted len from after vec_unique, not original */\n\tvec_cleanup(profile, vec, len);\n\treturn label;\n\nfail:\n\tlabel = ERR_PTR(-ENOENT);\n\tgoto out;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack)\n{\n\tDEFINE_VEC(profile, vec);\n\tstruct aa_label *label, *currbase = base;\n\tint i, len, stack = 0, error;\n\tchar *split;\n\n\tAA_BUG(!base);\n\tAA_BUG(!str);\n\n\tstr = skip_spaces(str);\n\tlen = label_count_str_entries(str);\n\tif (*str == '&' || force_stack) {\n\t\t/* stack on top of base */\n\t\tstack = base->size;\n\t\tlen += stack;\n\t\tif (*str == '&')\n\t\t\tstr++;\n\t}\n\tif (*str == '=')\n\t\tbase = &root_ns->unconfined->label;\n\n\terror = vec_setup(profile, vec, len, gfp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tfor (i = 0; i < stack; i++)\n\t\tvec[i] = aa_get_profile(base->vec[i]);\n\n\tfor (split = strstr(str, \"//&\"), i = stack; split && i < len; i++) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, split - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t\t/*\n\t\t * if component specified a new ns it becomes the new base\n\t\t * so that subsequent lookups are relative to it\n\t\t */\n\t\tif (vec[i]->ns != labels_ns(currbase))\n\t\t\tcurrbase = &vec[i]->label;\n\t\tstr = split + 3;\n\t\tsplit = strstr(str, \"//&\");\n\t}\n\t/* last element doesn't have a split */\n\tif (i < len) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, strlen(str));\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t}\n\tif (len == 1)\n\t\t/* no need to free vec as len < LOCAL_VEC_ENTRIES */\n\t\treturn &vec[0]->label;\n\n\tlen -= aa_vec_unique(vec, len, VEC_FLAG_TERMINATE);\n\t/* TODO: deal with reference labels */\n\tif (len == 1) {\n\t\tlabel = aa_get_label(&vec[0]->label);\n\t\tgoto out;\n\t}\n\n\tif (create)\n\t\tlabel = aa_vec_find_or_create_label(vec, len, gfp);\n\telse\n\t\tlabel = vec_find(vec, len);\n\tif (!label)\n\t\tgoto fail;\n\nout:\n\t/* use adjusted len from after vec_unique, not original */\n\tvec_cleanup(profile, vec, len);\n\treturn label;\n\nfail:\n\tlabel = ERR_PTR(-ENOENT);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "key",
            "query + query_len - key"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "query",
            "query_len"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic ssize_t query_data(char *buf, size_t buf_len,\n\t\t\t  char *query, size_t query_len)\n{\n\tchar *out;\n\tconst char *key;\n\tstruct label_it i;\n\tstruct aa_label *label, *curr;\n\tstruct aa_profile *profile;\n\tstruct aa_data *data;\n\tu32 bytes, blocks;\n\t__le32 outle32;\n\n\tif (!query_len)\n\t\treturn -EINVAL; /* need a query */\n\n\tkey = query + strnlen(query, query_len) + 1;\n\tif (key + 1 >= query + query_len)\n\t\treturn -EINVAL; /* not enough space for a non-empty key */\n\tif (key + strnlen(key, query + query_len - key) >= query + query_len)\n\t\treturn -EINVAL; /* must end with NUL */\n\n\tif (buf_len < sizeof(bytes) + sizeof(blocks))\n\t\treturn -EINVAL; /* not enough space */\n\n\tcurr = begin_current_label_crit_section();\n\tlabel = aa_label_parse(curr, query, GFP_KERNEL, false, false);\n\tend_current_label_crit_section(curr);\n\tif (IS_ERR(label))\n\t\treturn PTR_ERR(label);\n\n\t/* We are going to leave space for two numbers. The first is the total\n\t * number of bytes we are writing after the first number. This is so\n\t * users can read the full output without reallocation.\n\t *\n\t * The second number is the number of data blocks we're writing. An\n\t * application might be confined by multiple policies having data in\n\t * the same key.\n\t */\n\tmemset(buf, 0, sizeof(bytes) + sizeof(blocks));\n\tout = buf + sizeof(bytes) + sizeof(blocks);\n\n\tblocks = 0;\n\tlabel_for_each_confined(i, label, profile) {\n\t\tif (!profile->data)\n\t\t\tcontinue;\n\n\t\tdata = rhashtable_lookup_fast(profile->data, &key,\n\t\t\t\t\t      profile->data->p);\n\n\t\tif (data) {\n\t\t\tif (out + sizeof(outle32) + data->size > buf +\n\t\t\t    buf_len) {\n\t\t\t\taa_put_label(label);\n\t\t\t\treturn -EINVAL; /* not enough space */\n\t\t\t}\n\t\t\toutle32 = __cpu_to_le32(data->size);\n\t\t\tmemcpy(out, &outle32, sizeof(outle32));\n\t\t\tout += sizeof(outle32);\n\t\t\tmemcpy(out, data->data, data->size);\n\t\t\tout += data->size;\n\t\t\tblocks++;\n\t\t}\n\t}\n\taa_put_label(label);\n\n\toutle32 = __cpu_to_le32(out - buf - sizeof(bytes));\n\tmemcpy(buf, &outle32, sizeof(outle32));\n\toutle32 = __cpu_to_le32(blocks);\n\tmemcpy(buf + sizeof(bytes), &outle32, sizeof(outle32));\n\n\treturn out - buf;\n}"
  },
  {
    "function_name": "profile_query_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "605-637",
    "snippet": "static void profile_query_cb(struct aa_profile *profile, struct aa_perms *perms,\n\t\t\t     const char *match_str, size_t match_len)\n{\n\tstruct aa_perms tmp;\n\tstruct aa_dfa *dfa;\n\tunsigned int state = 0;\n\n\tif (profile_unconfined(profile))\n\t\treturn;\n\tif (profile->file.dfa && *match_str == AA_CLASS_FILE) {\n\t\tdfa = profile->file.dfa;\n\t\tstate = aa_dfa_match_len(dfa, profile->file.start,\n\t\t\t\t\t match_str + 1, match_len - 1);\n\t\ttmp = nullperms;\n\t\tif (state) {\n\t\t\tstruct path_cond cond = { };\n\n\t\t\ttmp = aa_compute_fperms(dfa, state, &cond);\n\t\t}\n\t} else if (profile->policy.dfa) {\n\t\tif (!PROFILE_MEDIATES_SAFE(profile, *match_str))\n\t\t\treturn;\t/* no change to current perms */\n\t\tdfa = profile->policy.dfa;\n\t\tstate = aa_dfa_match_len(dfa, profile->policy.start[0],\n\t\t\t\t\t match_str, match_len);\n\t\tif (state)\n\t\t\taa_compute_perms(dfa, state, &tmp);\n\t\telse\n\t\t\ttmp = nullperms;\n\t}\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum_raw(perms, &tmp);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_perms_accum_raw",
          "args": [
            "perms",
            "&tmp"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "aa_perms_accum_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "340-352",
          "snippet": "void aa_perms_accum_raw(struct aa_perms *accum, struct aa_perms *addend)\n{\n\taccum->deny |= addend->deny;\n\taccum->allow &= addend->allow & ~addend->deny;\n\taccum->audit |= addend->audit & addend->allow;\n\taccum->quiet &= addend->quiet & ~addend->allow;\n\taccum->kill |= addend->kill & ~addend->allow;\n\taccum->stop |= addend->stop & ~addend->allow;\n\taccum->complain |= addend->complain & ~addend->allow & ~addend->deny;\n\taccum->cond |= addend->cond & ~addend->allow & ~addend->deny;\n\taccum->hide &= addend->hide & ~addend->allow;\n\taccum->prompt |= addend->prompt & ~addend->allow & ~addend->deny;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_perms_accum_raw(struct aa_perms *accum, struct aa_perms *addend)\n{\n\taccum->deny |= addend->deny;\n\taccum->allow &= addend->allow & ~addend->deny;\n\taccum->audit |= addend->audit & addend->allow;\n\taccum->quiet &= addend->quiet & ~addend->allow;\n\taccum->kill |= addend->kill & ~addend->allow;\n\taccum->stop |= addend->stop & ~addend->allow;\n\taccum->complain |= addend->complain & ~addend->allow & ~addend->deny;\n\taccum->cond |= addend->cond & ~addend->allow & ~addend->deny;\n\taccum->hide &= addend->hide & ~addend->allow;\n\taccum->prompt |= addend->prompt & ~addend->allow & ~addend->deny;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_apply_modes_to_perms",
          "args": [
            "profile",
            "&tmp"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "aa_apply_modes_to_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "282-308",
          "snippet": "void aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_compute_perms",
          "args": [
            "dfa",
            "state",
            "&tmp"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "aa_compute_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "317-333",
          "snippet": "void aa_compute_perms(struct aa_dfa *dfa, unsigned int state,\n\t\t      struct aa_perms *perms)\n{\n\t*perms = (struct aa_perms) {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t};\n\n\t/* for v5 perm mapping in the policydb, the other set is used\n\t * to extend the general perm set\n\t */\n\tperms->allow |= map_other(dfa_other_allow(dfa, state));\n\tperms->audit |= map_other(dfa_other_audit(dfa, state));\n\tperms->quiet |= map_other(dfa_other_quiet(dfa, state));\n//\tperms->xindex = dfa_user_xindex(dfa, state);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_compute_perms(struct aa_dfa *dfa, unsigned int state,\n\t\t      struct aa_perms *perms)\n{\n\t*perms = (struct aa_perms) {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t};\n\n\t/* for v5 perm mapping in the policydb, the other set is used\n\t * to extend the general perm set\n\t */\n\tperms->allow |= map_other(dfa_other_allow(dfa, state));\n\tperms->audit |= map_other(dfa_other_audit(dfa, state));\n\tperms->quiet |= map_other(dfa_other_quiet(dfa, state));\n//\tperms->xindex = dfa_user_xindex(dfa, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_match_len",
          "args": [
            "dfa",
            "profile->policy.start[0]",
            "match_str",
            "match_len"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_match_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "331-367",
          "snippet": "unsigned int aa_dfa_match_len(struct aa_dfa *dfa, unsigned int start,\n\t\t\t      const char *str, int len)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match_len(struct aa_dfa *dfa, unsigned int start,\n\t\t\t      const char *str, int len)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROFILE_MEDIATES_SAFE",
          "args": [
            "profile",
            "*match_str"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "PROFILE_MEDIATES_SAFE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "214-221",
          "snippet": "static inline unsigned int PROFILE_MEDIATES_SAFE(struct aa_profile *profile,\n\t\t\t\t\t\t unsigned char class)\n{\n\tif (profile->policy.dfa)\n\t\treturn aa_dfa_match_len(profile->policy.dfa,\n\t\t\t\t\tprofile->policy.start[0], &class, 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline unsigned int PROFILE_MEDIATES_SAFE(struct aa_profile *profile,\n\t\t\t\t\t\t unsigned char class)\n{\n\tif (profile->policy.dfa)\n\t\treturn aa_dfa_match_len(profile->policy.dfa,\n\t\t\t\t\tprofile->policy.start[0], &class, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_compute_fperms",
          "args": [
            "dfa",
            "state",
            "&cond"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "aa_compute_fperms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "226-256",
          "snippet": "struct aa_perms aa_compute_fperms(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t  struct path_cond *cond)\n{\n\t/* FIXME: change over to new dfa format\n\t * currently file perms are encoded in the dfa, new format\n\t * splits the permissions from the dfa.  This mapping can be\n\t * done at profile load\n\t */\n\tstruct aa_perms perms = { };\n\n\tif (uid_eq(current_fsuid(), cond->uid)) {\n\t\tperms.allow = map_old_perms(dfa_user_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_user_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_user_quiet(dfa, state));\n\t\tperms.xindex = dfa_user_xindex(dfa, state);\n\t} else {\n\t\tperms.allow = map_old_perms(dfa_other_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_other_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_other_quiet(dfa, state));\n\t\tperms.xindex = dfa_other_xindex(dfa, state);\n\t}\n\tperms.allow |= AA_MAY_GETATTR;\n\n\t/* change_profile wasn't determined by ownership in old mapping */\n\tif (ACCEPT_TABLE(dfa)[state] & 0x80000000)\n\t\tperms.allow |= AA_MAY_CHANGE_PROFILE;\n\tif (ACCEPT_TABLE(dfa)[state] & 0x40000000)\n\t\tperms.allow |= AA_MAY_ONEXEC;\n\n\treturn perms;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstruct aa_perms aa_compute_fperms(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t  struct path_cond *cond)\n{\n\t/* FIXME: change over to new dfa format\n\t * currently file perms are encoded in the dfa, new format\n\t * splits the permissions from the dfa.  This mapping can be\n\t * done at profile load\n\t */\n\tstruct aa_perms perms = { };\n\n\tif (uid_eq(current_fsuid(), cond->uid)) {\n\t\tperms.allow = map_old_perms(dfa_user_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_user_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_user_quiet(dfa, state));\n\t\tperms.xindex = dfa_user_xindex(dfa, state);\n\t} else {\n\t\tperms.allow = map_old_perms(dfa_other_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_other_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_other_quiet(dfa, state));\n\t\tperms.xindex = dfa_other_xindex(dfa, state);\n\t}\n\tperms.allow |= AA_MAY_GETATTR;\n\n\t/* change_profile wasn't determined by ownership in old mapping */\n\tif (ACCEPT_TABLE(dfa)[state] & 0x80000000)\n\t\tperms.allow |= AA_MAY_CHANGE_PROFILE;\n\tif (ACCEPT_TABLE(dfa)[state] & 0x40000000)\n\t\tperms.allow |= AA_MAY_ONEXEC;\n\n\treturn perms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void profile_query_cb(struct aa_profile *profile, struct aa_perms *perms,\n\t\t\t     const char *match_str, size_t match_len)\n{\n\tstruct aa_perms tmp;\n\tstruct aa_dfa *dfa;\n\tunsigned int state = 0;\n\n\tif (profile_unconfined(profile))\n\t\treturn;\n\tif (profile->file.dfa && *match_str == AA_CLASS_FILE) {\n\t\tdfa = profile->file.dfa;\n\t\tstate = aa_dfa_match_len(dfa, profile->file.start,\n\t\t\t\t\t match_str + 1, match_len - 1);\n\t\ttmp = nullperms;\n\t\tif (state) {\n\t\t\tstruct path_cond cond = { };\n\n\t\t\ttmp = aa_compute_fperms(dfa, state, &cond);\n\t\t}\n\t} else if (profile->policy.dfa) {\n\t\tif (!PROFILE_MEDIATES_SAFE(profile, *match_str))\n\t\t\treturn;\t/* no change to current perms */\n\t\tdfa = profile->policy.dfa;\n\t\tstate = aa_dfa_match_len(dfa, profile->policy.start[0],\n\t\t\t\t\t match_str, match_len);\n\t\tif (state)\n\t\t\taa_compute_perms(dfa, state, &tmp);\n\t\telse\n\t\t\ttmp = nullperms;\n\t}\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum_raw(perms, &tmp);\n}"
  },
  {
    "function_name": "__aa_bump_ns_revision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "590-594",
    "snippet": "void __aa_bump_ns_revision(struct aa_ns *ns)\n{\n\tns->revision++;\n\twake_up_interruptible(&ns->wait);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&ns->wait"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nvoid __aa_bump_ns_revision(struct aa_ns *ns)\n{\n\tns->revision++;\n\twake_up_interruptible(&ns->wait);\n}"
  },
  {
    "function_name": "ns_revision_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "574-588",
    "snippet": "static unsigned int ns_revision_poll(struct file *file, poll_table *pt)\n{\n\tstruct aa_revision *rev = file->private_data;\n\tunsigned int mask = 0;\n\n\tif (rev) {\n\t\tmutex_lock_nested(&rev->ns->lock, rev->ns->level);\n\t\tpoll_wait(file, &rev->ns->wait, pt);\n\t\tif (rev->last_read < rev->ns->revision)\n\t\t\tmask |= POLLIN | POLLRDNORM;\n\t\tmutex_unlock(&rev->ns->lock);\n\t}\n\n\treturn mask;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rev->ns->lock"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&rev->ns->wait",
            "pt"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&rev->ns->lock",
            "rev->ns->level"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic unsigned int ns_revision_poll(struct file *file, poll_table *pt)\n{\n\tstruct aa_revision *rev = file->private_data;\n\tunsigned int mask = 0;\n\n\tif (rev) {\n\t\tmutex_lock_nested(&rev->ns->lock, rev->ns->level);\n\t\tpoll_wait(file, &rev->ns->wait, pt);\n\t\tif (rev->last_read < rev->ns->revision)\n\t\t\tmask |= POLLIN | POLLRDNORM;\n\t\tmutex_unlock(&rev->ns->lock);\n\t}\n\n\treturn mask;\n}"
  },
  {
    "function_name": "ns_revision_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "559-572",
    "snippet": "static int ns_revision_open(struct inode *inode, struct file *file)\n{\n\tstruct aa_revision *rev = kzalloc(sizeof(*rev), GFP_KERNEL);\n\n\tif (!rev)\n\t\treturn -ENOMEM;\n\n\trev->ns = aa_get_ns(inode->i_private);\n\tif (!rev->ns)\n\t\trev->ns = aa_get_current_ns();\n\tfile->private_data = rev;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_get_current_ns",
          "args": [],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_current_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "204-214",
          "snippet": "static inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_ns",
          "args": [
            "inode->i_private"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "116-122",
          "snippet": "static inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*rev)",
            "GFP_KERNEL"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int ns_revision_open(struct inode *inode, struct file *file)\n{\n\tstruct aa_revision *rev = kzalloc(sizeof(*rev), GFP_KERNEL);\n\n\tif (!rev)\n\t\treturn -ENOMEM;\n\n\trev->ns = aa_get_ns(inode->i_private);\n\tif (!rev->ns)\n\t\trev->ns = aa_get_current_ns();\n\tfile->private_data = rev;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ns_revision_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "528-557",
    "snippet": "static ssize_t ns_revision_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t size, loff_t *ppos)\n{\n\tstruct aa_revision *rev = file->private_data;\n\tchar buffer[32];\n\tlong last_read;\n\tint avail;\n\n\tmutex_lock_nested(&rev->ns->lock, rev->ns->level);\n\tlast_read = rev->last_read;\n\tif (last_read == rev->ns->revision) {\n\t\tmutex_unlock(&rev->ns->lock);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tif (wait_event_interruptible(rev->ns->wait,\n\t\t\t\t\t     last_read !=\n\t\t\t\t\t     READ_ONCE(rev->ns->revision)))\n\t\t\treturn -ERESTARTSYS;\n\t\tmutex_lock_nested(&rev->ns->lock, rev->ns->level);\n\t}\n\n\tavail = sprintf(buffer, \"%ld\\n\", rev->ns->revision);\n\tif (*ppos + size > avail) {\n\t\trev->last_read = rev->ns->revision;\n\t\t*ppos = 0;\n\t}\n\tmutex_unlock(&rev->ns->lock);\n\n\treturn simple_read_from_buffer(buf, size, ppos, buffer, avail);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "size",
            "ppos",
            "buffer",
            "avail"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rev->ns->lock"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer",
            "\"%ld\\n\"",
            "rev->ns->revision"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&rev->ns->lock",
            "rev->ns->level"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "rev->ns->wait",
            "last_read !=\n\t\t\t\t\t     READ_ONCE(rev->ns->revision)"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rev->ns->revision"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rev->ns->lock"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&rev->ns->lock",
            "rev->ns->level"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic ssize_t ns_revision_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t size, loff_t *ppos)\n{\n\tstruct aa_revision *rev = file->private_data;\n\tchar buffer[32];\n\tlong last_read;\n\tint avail;\n\n\tmutex_lock_nested(&rev->ns->lock, rev->ns->level);\n\tlast_read = rev->last_read;\n\tif (last_read == rev->ns->revision) {\n\t\tmutex_unlock(&rev->ns->lock);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tif (wait_event_interruptible(rev->ns->wait,\n\t\t\t\t\t     last_read !=\n\t\t\t\t\t     READ_ONCE(rev->ns->revision)))\n\t\t\treturn -ERESTARTSYS;\n\t\tmutex_lock_nested(&rev->ns->lock, rev->ns->level);\n\t}\n\n\tavail = sprintf(buffer, \"%ld\\n\", rev->ns->revision);\n\tif (*ppos + size > avail) {\n\t\trev->last_read = rev->ns->revision;\n\t\t*ppos = 0;\n\t}\n\tmutex_unlock(&rev->ns->lock);\n\n\treturn simple_read_from_buffer(buf, size, ppos, buffer, avail);\n}"
  },
  {
    "function_name": "ns_revision_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "516-526",
    "snippet": "static int ns_revision_release(struct inode *inode, struct file *file)\n{\n\tstruct aa_revision *rev = file->private_data;\n\n\tif (rev) {\n\t\taa_put_ns(rev->ns);\n\t\tkfree(rev);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rev"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "rev->ns"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int ns_revision_release(struct inode *inode, struct file *file)\n{\n\tstruct aa_revision *rev = file->private_data;\n\n\tif (rev) {\n\t\taa_put_ns(rev->ns);\n\t\tkfree(rev);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "profile_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "471-503",
    "snippet": "static ssize_t profile_remove(struct file *f, const char __user *buf,\n\t\t\t      size_t size, loff_t *pos)\n{\n\tstruct aa_loaddata *data;\n\tstruct aa_label *label;\n\tssize_t error;\n\tstruct aa_ns *ns = aa_get_ns(f->f_inode->i_private);\n\n\tlabel = begin_current_label_crit_section();\n\t/* high level check about policy management - fine grained in\n\t * below after unpack\n\t */\n\terror = aa_may_manage_policy(label, ns, AA_MAY_REMOVE_POLICY);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * aa_remove_profile needs a null terminated string so 1 extra\n\t * byte is allocated and the copied data is null terminated.\n\t */\n\tdata = aa_simple_write_to_buffer(buf, size + 1, size, pos);\n\n\terror = PTR_ERR(data);\n\tif (!IS_ERR(data)) {\n\t\tdata->data[size] = 0;\n\t\terror = aa_remove_profiles(ns, label, data->data, size);\n\t\taa_put_loaddata(data);\n\t}\n out:\n\tend_current_label_crit_section(label);\n\taa_put_ns(ns);\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "ns"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_put_loaddata",
          "args": [
            "data"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_loaddata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_unpack.h",
          "lines": "119-123",
          "snippet": "static inline void aa_put_loaddata(struct aa_loaddata *data)\n{\n\tif (data)\n\t\tkref_put(&data->count, aa_loaddata_kref);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/dcache.h>",
            "#include <linux/kref.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/dcache.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n\nstatic inline void aa_put_loaddata(struct aa_loaddata *data)\n{\n\tif (data)\n\t\tkref_put(&data->count, aa_loaddata_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_remove_profiles",
          "args": [
            "ns",
            "label",
            "data->data",
            "size"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "aa_remove_profiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "1087-1155",
          "snippet": "ssize_t aa_remove_profiles(struct aa_ns *policy_ns, struct aa_label *subj,\n\t\t\t   char *fqname, size_t size)\n{\n\tstruct aa_ns *ns = NULL;\n\tstruct aa_profile *profile = NULL;\n\tconst char *name = fqname, *info = NULL;\n\tconst char *ns_name = NULL;\n\tssize_t error = 0;\n\n\tif (*fqname == 0) {\n\t\tinfo = \"no profile specified\";\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tif (fqname[0] == ':') {\n\t\tsize_t ns_len;\n\n\t\tname = aa_splitn_fqname(fqname, size, &ns_name, &ns_len);\n\t\t/* released below */\n\t\tns = aa_lookupn_ns(policy_ns ? policy_ns : labels_ns(subj),\n\t\t\t\t   ns_name, ns_len);\n\t\tif (!ns) {\n\t\t\tinfo = \"namespace does not exist\";\n\t\t\terror = -ENOENT;\n\t\t\tgoto fail;\n\t\t}\n\t} else\n\t\t/* released below */\n\t\tns = aa_get_ns(policy_ns ? policy_ns : labels_ns(subj));\n\n\tif (!name) {\n\t\t/* remove namespace - can only happen if fqname[0] == ':' */\n\t\tmutex_lock_nested(&ns->parent->lock, ns->level);\n\t\t__aa_remove_ns(ns);\n\t\t__aa_bump_ns_revision(ns);\n\t\tmutex_unlock(&ns->parent->lock);\n\t} else {\n\t\t/* remove profile */\n\t\tmutex_lock_nested(&ns->lock, ns->level);\n\t\tprofile = aa_get_profile(__lookup_profile(&ns->base, name));\n\t\tif (!profile) {\n\t\t\terror = -ENOENT;\n\t\t\tinfo = \"profile does not exist\";\n\t\t\tgoto fail_ns_lock;\n\t\t}\n\t\tname = profile->base.hname;\n\t\t__remove_profile(profile);\n\t\t__aa_labelset_update_subtree(ns);\n\t\t__aa_bump_ns_revision(ns);\n\t\tmutex_unlock(&ns->lock);\n\t}\n\n\t/* don't fail removal if audit fails */\n\t(void) audit_policy(subj, OP_PROF_RM, ns_name, name, info,\n\t\t\t    error);\n\taa_put_ns(ns);\n\taa_put_profile(profile);\n\treturn size;\n\nfail_ns_lock:\n\tmutex_unlock(&ns->lock);\n\taa_put_ns(ns);\n\nfail:\n\t(void) audit_policy(subj, OP_PROF_RM, ns_name, name, info,\n\t\t\t    error);\n\treturn error;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nssize_t aa_remove_profiles(struct aa_ns *policy_ns, struct aa_label *subj,\n\t\t\t   char *fqname, size_t size)\n{\n\tstruct aa_ns *ns = NULL;\n\tstruct aa_profile *profile = NULL;\n\tconst char *name = fqname, *info = NULL;\n\tconst char *ns_name = NULL;\n\tssize_t error = 0;\n\n\tif (*fqname == 0) {\n\t\tinfo = \"no profile specified\";\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tif (fqname[0] == ':') {\n\t\tsize_t ns_len;\n\n\t\tname = aa_splitn_fqname(fqname, size, &ns_name, &ns_len);\n\t\t/* released below */\n\t\tns = aa_lookupn_ns(policy_ns ? policy_ns : labels_ns(subj),\n\t\t\t\t   ns_name, ns_len);\n\t\tif (!ns) {\n\t\t\tinfo = \"namespace does not exist\";\n\t\t\terror = -ENOENT;\n\t\t\tgoto fail;\n\t\t}\n\t} else\n\t\t/* released below */\n\t\tns = aa_get_ns(policy_ns ? policy_ns : labels_ns(subj));\n\n\tif (!name) {\n\t\t/* remove namespace - can only happen if fqname[0] == ':' */\n\t\tmutex_lock_nested(&ns->parent->lock, ns->level);\n\t\t__aa_remove_ns(ns);\n\t\t__aa_bump_ns_revision(ns);\n\t\tmutex_unlock(&ns->parent->lock);\n\t} else {\n\t\t/* remove profile */\n\t\tmutex_lock_nested(&ns->lock, ns->level);\n\t\tprofile = aa_get_profile(__lookup_profile(&ns->base, name));\n\t\tif (!profile) {\n\t\t\terror = -ENOENT;\n\t\t\tinfo = \"profile does not exist\";\n\t\t\tgoto fail_ns_lock;\n\t\t}\n\t\tname = profile->base.hname;\n\t\t__remove_profile(profile);\n\t\t__aa_labelset_update_subtree(ns);\n\t\t__aa_bump_ns_revision(ns);\n\t\tmutex_unlock(&ns->lock);\n\t}\n\n\t/* don't fail removal if audit fails */\n\t(void) audit_policy(subj, OP_PROF_RM, ns_name, name, info,\n\t\t\t    error);\n\taa_put_ns(ns);\n\taa_put_profile(profile);\n\treturn size;\n\nfail_ns_lock:\n\tmutex_unlock(&ns->lock);\n\taa_put_ns(ns);\n\nfail:\n\t(void) audit_policy(subj, OP_PROF_RM, ns_name, name, info,\n\t\t\t    error);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_simple_write_to_buffer",
          "args": [
            "buf",
            "size + 1",
            "size",
            "pos"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "aa_simple_write_to_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "382-407",
          "snippet": "static struct aa_loaddata *aa_simple_write_to_buffer(const char __user *userbuf,\n\t\t\t\t\t\t     size_t alloc_size,\n\t\t\t\t\t\t     size_t copy_size,\n\t\t\t\t\t\t     loff_t *pos)\n{\n\tstruct aa_loaddata *data;\n\n\tAA_BUG(copy_size > alloc_size);\n\n\tif (*pos != 0)\n\t\t/* only writes from pos 0, that is complete writes */\n\t\treturn ERR_PTR(-ESPIPE);\n\n\t/* freed by caller to simple_write_to_buffer */\n\tdata = aa_loaddata_alloc(alloc_size);\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\tdata->size = copy_size;\n\tif (copy_from_user(data->data, userbuf, copy_size)) {\n\t\tkvfree(data);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\treturn data;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_loaddata *aa_simple_write_to_buffer(const char __user *userbuf,\n\t\t\t\t\t\t     size_t alloc_size,\n\t\t\t\t\t\t     size_t copy_size,\n\t\t\t\t\t\t     loff_t *pos)\n{\n\tstruct aa_loaddata *data;\n\n\tAA_BUG(copy_size > alloc_size);\n\n\tif (*pos != 0)\n\t\t/* only writes from pos 0, that is complete writes */\n\t\treturn ERR_PTR(-ESPIPE);\n\n\t/* freed by caller to simple_write_to_buffer */\n\tdata = aa_loaddata_alloc(alloc_size);\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\tdata->size = copy_size;\n\tif (copy_from_user(data->data, userbuf, copy_size)) {\n\t\tkvfree(data);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_may_manage_policy",
          "args": [
            "label",
            "ns",
            "AA_MAY_REMOVE_POLICY"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "aa_may_manage_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "678-700",
          "snippet": "int aa_may_manage_policy(struct aa_label *label, struct aa_ns *ns, u32 mask)\n{\n\tconst char *op;\n\n\tif (mask & AA_MAY_REMOVE_POLICY)\n\t\top = OP_PROF_RM;\n\telse if (mask & AA_MAY_REPLACE_POLICY)\n\t\top = OP_PROF_REPL;\n\telse\n\t\top = OP_PROF_LOAD;\n\n\t/* check if loading policy is locked out */\n\tif (aa_g_lock_policy)\n\t\treturn audit_policy(label, op, NULL, NULL, \"policy_locked\",\n\t\t\t\t    -EACCES);\n\n\tif (!policy_admin_capable(ns))\n\t\treturn audit_policy(label, op, NULL, NULL, \"not policy admin\",\n\t\t\t\t    -EACCES);\n\n\t/* TODO: add fine grained mediation of policy loads */\n\treturn 0;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint aa_may_manage_policy(struct aa_label *label, struct aa_ns *ns, u32 mask)\n{\n\tconst char *op;\n\n\tif (mask & AA_MAY_REMOVE_POLICY)\n\t\top = OP_PROF_RM;\n\telse if (mask & AA_MAY_REPLACE_POLICY)\n\t\top = OP_PROF_REPL;\n\telse\n\t\top = OP_PROF_LOAD;\n\n\t/* check if loading policy is locked out */\n\tif (aa_g_lock_policy)\n\t\treturn audit_policy(label, op, NULL, NULL, \"policy_locked\",\n\t\t\t\t    -EACCES);\n\n\tif (!policy_admin_capable(ns))\n\t\treturn audit_policy(label, op, NULL, NULL, \"not policy admin\",\n\t\t\t\t    -EACCES);\n\n\t/* TODO: add fine grained mediation of policy loads */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_ns",
          "args": [
            "f->f_inode->i_private"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "116-122",
          "snippet": "static inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic ssize_t profile_remove(struct file *f, const char __user *buf,\n\t\t\t      size_t size, loff_t *pos)\n{\n\tstruct aa_loaddata *data;\n\tstruct aa_label *label;\n\tssize_t error;\n\tstruct aa_ns *ns = aa_get_ns(f->f_inode->i_private);\n\n\tlabel = begin_current_label_crit_section();\n\t/* high level check about policy management - fine grained in\n\t * below after unpack\n\t */\n\terror = aa_may_manage_policy(label, ns, AA_MAY_REMOVE_POLICY);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * aa_remove_profile needs a null terminated string so 1 extra\n\t * byte is allocated and the copied data is null terminated.\n\t */\n\tdata = aa_simple_write_to_buffer(buf, size + 1, size, pos);\n\n\terror = PTR_ERR(data);\n\tif (!IS_ERR(data)) {\n\t\tdata->data[size] = 0;\n\t\terror = aa_remove_profiles(ns, label, data->data, size);\n\t\taa_put_loaddata(data);\n\t}\n out:\n\tend_current_label_crit_section(label);\n\taa_put_ns(ns);\n\treturn error;\n}"
  },
  {
    "function_name": "profile_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "454-463",
    "snippet": "static ssize_t profile_replace(struct file *f, const char __user *buf,\n\t\t\t       size_t size, loff_t *pos)\n{\n\tstruct aa_ns *ns = aa_get_ns(f->f_inode->i_private);\n\tint error = policy_update(AA_MAY_LOAD_POLICY | AA_MAY_REPLACE_POLICY,\n\t\t\t\t  buf, size, pos, ns);\n\taa_put_ns(ns);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "ns"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy_update",
          "args": [
            "AA_MAY_LOAD_POLICY | AA_MAY_REPLACE_POLICY",
            "buf",
            "size",
            "pos",
            "ns"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "policy_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "409-434",
          "snippet": "static ssize_t policy_update(u32 mask, const char __user *buf, size_t size,\n\t\t\t     loff_t *pos, struct aa_ns *ns)\n{\n\tstruct aa_loaddata *data;\n\tstruct aa_label *label;\n\tssize_t error;\n\n\tlabel = begin_current_label_crit_section();\n\n\t/* high level check about policy management - fine grained in\n\t * below after unpack\n\t */\n\terror = aa_may_manage_policy(label, ns, mask);\n\tif (error)\n\t\treturn error;\n\n\tdata = aa_simple_write_to_buffer(buf, size, size, pos);\n\terror = PTR_ERR(data);\n\tif (!IS_ERR(data)) {\n\t\terror = aa_replace_profiles(ns, label, mask, data);\n\t\taa_put_loaddata(data);\n\t}\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic ssize_t policy_update(u32 mask, const char __user *buf, size_t size,\n\t\t\t     loff_t *pos, struct aa_ns *ns)\n{\n\tstruct aa_loaddata *data;\n\tstruct aa_label *label;\n\tssize_t error;\n\n\tlabel = begin_current_label_crit_section();\n\n\t/* high level check about policy management - fine grained in\n\t * below after unpack\n\t */\n\terror = aa_may_manage_policy(label, ns, mask);\n\tif (error)\n\t\treturn error;\n\n\tdata = aa_simple_write_to_buffer(buf, size, size, pos);\n\terror = PTR_ERR(data);\n\tif (!IS_ERR(data)) {\n\t\terror = aa_replace_profiles(ns, label, mask, data);\n\t\taa_put_loaddata(data);\n\t}\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_ns",
          "args": [
            "f->f_inode->i_private"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "116-122",
          "snippet": "static inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic ssize_t profile_replace(struct file *f, const char __user *buf,\n\t\t\t       size_t size, loff_t *pos)\n{\n\tstruct aa_ns *ns = aa_get_ns(f->f_inode->i_private);\n\tint error = policy_update(AA_MAY_LOAD_POLICY | AA_MAY_REPLACE_POLICY,\n\t\t\t\t  buf, size, pos, ns);\n\taa_put_ns(ns);\n\n\treturn error;\n}"
  },
  {
    "function_name": "profile_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "437-446",
    "snippet": "static ssize_t profile_load(struct file *f, const char __user *buf, size_t size,\n\t\t\t    loff_t *pos)\n{\n\tstruct aa_ns *ns = aa_get_ns(f->f_inode->i_private);\n\tint error = policy_update(AA_MAY_LOAD_POLICY, buf, size, pos, ns);\n\n\taa_put_ns(ns);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "ns"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy_update",
          "args": [
            "AA_MAY_LOAD_POLICY",
            "buf",
            "size",
            "pos",
            "ns"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "policy_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "409-434",
          "snippet": "static ssize_t policy_update(u32 mask, const char __user *buf, size_t size,\n\t\t\t     loff_t *pos, struct aa_ns *ns)\n{\n\tstruct aa_loaddata *data;\n\tstruct aa_label *label;\n\tssize_t error;\n\n\tlabel = begin_current_label_crit_section();\n\n\t/* high level check about policy management - fine grained in\n\t * below after unpack\n\t */\n\terror = aa_may_manage_policy(label, ns, mask);\n\tif (error)\n\t\treturn error;\n\n\tdata = aa_simple_write_to_buffer(buf, size, size, pos);\n\terror = PTR_ERR(data);\n\tif (!IS_ERR(data)) {\n\t\terror = aa_replace_profiles(ns, label, mask, data);\n\t\taa_put_loaddata(data);\n\t}\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic ssize_t policy_update(u32 mask, const char __user *buf, size_t size,\n\t\t\t     loff_t *pos, struct aa_ns *ns)\n{\n\tstruct aa_loaddata *data;\n\tstruct aa_label *label;\n\tssize_t error;\n\n\tlabel = begin_current_label_crit_section();\n\n\t/* high level check about policy management - fine grained in\n\t * below after unpack\n\t */\n\terror = aa_may_manage_policy(label, ns, mask);\n\tif (error)\n\t\treturn error;\n\n\tdata = aa_simple_write_to_buffer(buf, size, size, pos);\n\terror = PTR_ERR(data);\n\tif (!IS_ERR(data)) {\n\t\terror = aa_replace_profiles(ns, label, mask, data);\n\t\taa_put_loaddata(data);\n\t}\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_ns",
          "args": [
            "f->f_inode->i_private"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "116-122",
          "snippet": "static inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic ssize_t profile_load(struct file *f, const char __user *buf, size_t size,\n\t\t\t    loff_t *pos)\n{\n\tstruct aa_ns *ns = aa_get_ns(f->f_inode->i_private);\n\tint error = policy_update(AA_MAY_LOAD_POLICY, buf, size, pos, ns);\n\n\taa_put_ns(ns);\n\n\treturn error;\n}"
  },
  {
    "function_name": "policy_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "409-434",
    "snippet": "static ssize_t policy_update(u32 mask, const char __user *buf, size_t size,\n\t\t\t     loff_t *pos, struct aa_ns *ns)\n{\n\tstruct aa_loaddata *data;\n\tstruct aa_label *label;\n\tssize_t error;\n\n\tlabel = begin_current_label_crit_section();\n\n\t/* high level check about policy management - fine grained in\n\t * below after unpack\n\t */\n\terror = aa_may_manage_policy(label, ns, mask);\n\tif (error)\n\t\treturn error;\n\n\tdata = aa_simple_write_to_buffer(buf, size, size, pos);\n\terror = PTR_ERR(data);\n\tif (!IS_ERR(data)) {\n\t\terror = aa_replace_profiles(ns, label, mask, data);\n\t\taa_put_loaddata(data);\n\t}\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_put_loaddata",
          "args": [
            "data"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_loaddata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_unpack.h",
          "lines": "119-123",
          "snippet": "static inline void aa_put_loaddata(struct aa_loaddata *data)\n{\n\tif (data)\n\t\tkref_put(&data->count, aa_loaddata_kref);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/dcache.h>",
            "#include <linux/kref.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/dcache.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n\nstatic inline void aa_put_loaddata(struct aa_loaddata *data)\n{\n\tif (data)\n\t\tkref_put(&data->count, aa_loaddata_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_replace_profiles",
          "args": [
            "ns",
            "label",
            "mask",
            "data"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "aa_replace_profiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "853-1071",
          "snippet": "ssize_t aa_replace_profiles(struct aa_ns *policy_ns, struct aa_label *label,\n\t\t\t    u32 mask, struct aa_loaddata *udata)\n{\n\tconst char *ns_name, *info = NULL;\n\tstruct aa_ns *ns = NULL;\n\tstruct aa_load_ent *ent, *tmp;\n\tstruct aa_loaddata *rawdata_ent;\n\tconst char *op;\n\tssize_t count, error;\n\tLIST_HEAD(lh);\n\n\top = mask & AA_MAY_REPLACE_POLICY ? OP_PROF_REPL : OP_PROF_LOAD;\n\taa_get_loaddata(udata);\n\t/* released below */\n\terror = aa_unpack(udata, &lh, &ns_name);\n\tif (error)\n\t\tgoto out;\n\n\t/* ensure that profiles are all for the same ns\n\t * TODO: update locking to remove this constaint. All profiles in\n\t *       the load set must succeed as a set or the load will\n\t *       fail. Sort ent list and take ns locks in hierarchy order\n\t */\n\tcount = 0;\n\tlist_for_each_entry(ent, &lh, list) {\n\t\tif (ns_name) {\n\t\t\tif (ent->ns_name &&\n\t\t\t    strcmp(ent->ns_name, ns_name) != 0) {\n\t\t\t\tinfo = \"policy load has mixed namespaces\";\n\t\t\t\terror = -EACCES;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else if (ent->ns_name) {\n\t\t\tif (count) {\n\t\t\t\tinfo = \"policy load has mixed namespaces\";\n\t\t\t\terror = -EACCES;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tns_name = ent->ns_name;\n\t\t} else\n\t\t\tcount++;\n\t}\n\tif (ns_name) {\n\t\tns = aa_prepare_ns(policy_ns ? policy_ns : labels_ns(label),\n\t\t\t\t   ns_name);\n\t\tif (IS_ERR(ns)) {\n\t\t\top = OP_PROF_LOAD;\n\t\t\tinfo = \"failed to prepare namespace\";\n\t\t\terror = PTR_ERR(ns);\n\t\t\tns = NULL;\n\t\t\tent = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t} else\n\t\tns = aa_get_ns(policy_ns ? policy_ns : labels_ns(label));\n\n\tmutex_lock_nested(&ns->lock, ns->level);\n\t/* check for duplicate rawdata blobs: space and file dedup */\n\tlist_for_each_entry(rawdata_ent, &ns->rawdata_list, list) {\n\t\tif (aa_rawdata_eq(rawdata_ent, udata)) {\n\t\t\tstruct aa_loaddata *tmp;\n\n\t\t\ttmp = __aa_get_loaddata(rawdata_ent);\n\t\t\t/* check we didn't fail the race */\n\t\t\tif (tmp) {\n\t\t\t\taa_put_loaddata(udata);\n\t\t\t\tudata = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* setup parent and ns info */\n\tlist_for_each_entry(ent, &lh, list) {\n\t\tstruct aa_policy *policy;\n\n\t\tent->new->rawdata = aa_get_loaddata(udata);\n\t\terror = __lookup_replace(ns, ent->new->base.hname,\n\t\t\t\t\t !(mask & AA_MAY_REPLACE_POLICY),\n\t\t\t\t\t &ent->old, &info);\n\t\tif (error)\n\t\t\tgoto fail_lock;\n\n\t\tif (ent->new->rename) {\n\t\t\terror = __lookup_replace(ns, ent->new->rename,\n\t\t\t\t\t\t!(mask & AA_MAY_REPLACE_POLICY),\n\t\t\t\t\t\t&ent->rename, &info);\n\t\t\tif (error)\n\t\t\t\tgoto fail_lock;\n\t\t}\n\n\t\t/* released when @new is freed */\n\t\tent->new->ns = aa_get_ns(ns);\n\n\t\tif (ent->old || ent->rename)\n\t\t\tcontinue;\n\n\t\t/* no ref on policy only use inside lock */\n\t\tpolicy = __lookup_parent(ns, ent->new->base.hname);\n\t\tif (!policy) {\n\t\t\tstruct aa_profile *p;\n\t\t\tp = __list_lookup_parent(&lh, ent->new);\n\t\t\tif (!p) {\n\t\t\t\terror = -ENOENT;\n\t\t\t\tinfo = \"parent does not exist\";\n\t\t\t\tgoto fail_lock;\n\t\t\t}\n\t\t\trcu_assign_pointer(ent->new->parent, aa_get_profile(p));\n\t\t} else if (policy != &ns->base) {\n\t\t\t/* released on profile replacement or free_profile */\n\t\t\tstruct aa_profile *p = (struct aa_profile *) policy;\n\t\t\trcu_assign_pointer(ent->new->parent, aa_get_profile(p));\n\t\t}\n\t}\n\n\t/* create new fs entries for introspection if needed */\n\tif (!udata->dents[AAFS_LOADDATA_DIR]) {\n\t\terror = __aa_fs_create_rawdata(ns, udata);\n\t\tif (error) {\n\t\t\tinfo = \"failed to create raw_data dir and files\";\n\t\t\tent = NULL;\n\t\t\tgoto fail_lock;\n\t\t}\n\t}\n\tlist_for_each_entry(ent, &lh, list) {\n\t\tif (!ent->old) {\n\t\t\tstruct dentry *parent;\n\t\t\tif (rcu_access_pointer(ent->new->parent)) {\n\t\t\t\tstruct aa_profile *p;\n\t\t\t\tp = aa_deref_parent(ent->new);\n\t\t\t\tparent = prof_child_dir(p);\n\t\t\t} else\n\t\t\t\tparent = ns_subprofs_dir(ent->new->ns);\n\t\t\terror = __aafs_profile_mkdir(ent->new, parent);\n\t\t}\n\n\t\tif (error) {\n\t\t\tinfo = \"failed to create\";\n\t\t\tgoto fail_lock;\n\t\t}\n\t}\n\n\t/* Done with checks that may fail - do actual replacement */\n\t__aa_bump_ns_revision(ns);\n\t__aa_loaddata_update(udata, ns->revision);\n\tlist_for_each_entry_safe(ent, tmp, &lh, list) {\n\t\tlist_del_init(&ent->list);\n\t\top = (!ent->old && !ent->rename) ? OP_PROF_LOAD : OP_PROF_REPL;\n\n\t\tif (ent->old && ent->old->rawdata == ent->new->rawdata) {\n\t\t\t/* dedup actual profile replacement */\n\t\t\taudit_policy(label, op, ns_name, ent->new->base.hname,\n\t\t\t\t     \"same as current profile, skipping\",\n\t\t\t\t     error);\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/*\n\t\t * TODO: finer dedup based on profile range in data. Load set\n\t\t * can differ but profile may remain unchanged\n\t\t */\n\t\taudit_policy(label, op, ns_name, ent->new->base.hname, NULL,\n\t\t\t     error);\n\n\t\tif (ent->old) {\n\t\t\tshare_name(ent->old, ent->new);\n\t\t\t__replace_profile(ent->old, ent->new);\n\t\t} else {\n\t\t\tstruct list_head *lh;\n\n\t\t\tif (rcu_access_pointer(ent->new->parent)) {\n\t\t\t\tstruct aa_profile *parent;\n\n\t\t\t\tparent = update_to_newest_parent(ent->new);\n\t\t\t\tlh = &parent->base.profiles;\n\t\t\t} else\n\t\t\t\tlh = &ns->base.profiles;\n\t\t\t__add_profile(lh, ent->new);\n\t\t}\n\tskip:\n\t\taa_load_ent_free(ent);\n\t}\n\t__aa_labelset_update_subtree(ns);\n\tmutex_unlock(&ns->lock);\n\nout:\n\taa_put_ns(ns);\n\taa_put_loaddata(udata);\n\n\tif (error)\n\t\treturn error;\n\treturn udata->size;\n\nfail_lock:\n\tmutex_unlock(&ns->lock);\n\n\t/* audit cause of failure */\n\top = (ent && !ent->old) ? OP_PROF_LOAD : OP_PROF_REPL;\nfail:\n\t  audit_policy(label, op, ns_name, ent ? ent->new->base.hname : NULL,\n\t\t       info, error);\n\t/* audit status that rest of profiles in the atomic set failed too */\n\tinfo = \"valid profile in failed atomic policy load\";\n\tlist_for_each_entry(tmp, &lh, list) {\n\t\tif (tmp == ent) {\n\t\t\tinfo = \"unchecked profile in failed atomic policy load\";\n\t\t\t/* skip entry that caused failure */\n\t\t\tcontinue;\n\t\t}\n\t\top = (!tmp->old) ? OP_PROF_LOAD : OP_PROF_REPL;\n\t\taudit_policy(label, op, ns_name, tmp->new->base.hname, info,\n\t\t\t     error);\n\t}\n\tlist_for_each_entry_safe(ent, tmp, &lh, list) {\n\t\tlist_del_init(&ent->list);\n\t\taa_load_ent_free(ent);\n\t}\n\n\tgoto out;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nssize_t aa_replace_profiles(struct aa_ns *policy_ns, struct aa_label *label,\n\t\t\t    u32 mask, struct aa_loaddata *udata)\n{\n\tconst char *ns_name, *info = NULL;\n\tstruct aa_ns *ns = NULL;\n\tstruct aa_load_ent *ent, *tmp;\n\tstruct aa_loaddata *rawdata_ent;\n\tconst char *op;\n\tssize_t count, error;\n\tLIST_HEAD(lh);\n\n\top = mask & AA_MAY_REPLACE_POLICY ? OP_PROF_REPL : OP_PROF_LOAD;\n\taa_get_loaddata(udata);\n\t/* released below */\n\terror = aa_unpack(udata, &lh, &ns_name);\n\tif (error)\n\t\tgoto out;\n\n\t/* ensure that profiles are all for the same ns\n\t * TODO: update locking to remove this constaint. All profiles in\n\t *       the load set must succeed as a set or the load will\n\t *       fail. Sort ent list and take ns locks in hierarchy order\n\t */\n\tcount = 0;\n\tlist_for_each_entry(ent, &lh, list) {\n\t\tif (ns_name) {\n\t\t\tif (ent->ns_name &&\n\t\t\t    strcmp(ent->ns_name, ns_name) != 0) {\n\t\t\t\tinfo = \"policy load has mixed namespaces\";\n\t\t\t\terror = -EACCES;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else if (ent->ns_name) {\n\t\t\tif (count) {\n\t\t\t\tinfo = \"policy load has mixed namespaces\";\n\t\t\t\terror = -EACCES;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tns_name = ent->ns_name;\n\t\t} else\n\t\t\tcount++;\n\t}\n\tif (ns_name) {\n\t\tns = aa_prepare_ns(policy_ns ? policy_ns : labels_ns(label),\n\t\t\t\t   ns_name);\n\t\tif (IS_ERR(ns)) {\n\t\t\top = OP_PROF_LOAD;\n\t\t\tinfo = \"failed to prepare namespace\";\n\t\t\terror = PTR_ERR(ns);\n\t\t\tns = NULL;\n\t\t\tent = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t} else\n\t\tns = aa_get_ns(policy_ns ? policy_ns : labels_ns(label));\n\n\tmutex_lock_nested(&ns->lock, ns->level);\n\t/* check for duplicate rawdata blobs: space and file dedup */\n\tlist_for_each_entry(rawdata_ent, &ns->rawdata_list, list) {\n\t\tif (aa_rawdata_eq(rawdata_ent, udata)) {\n\t\t\tstruct aa_loaddata *tmp;\n\n\t\t\ttmp = __aa_get_loaddata(rawdata_ent);\n\t\t\t/* check we didn't fail the race */\n\t\t\tif (tmp) {\n\t\t\t\taa_put_loaddata(udata);\n\t\t\t\tudata = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* setup parent and ns info */\n\tlist_for_each_entry(ent, &lh, list) {\n\t\tstruct aa_policy *policy;\n\n\t\tent->new->rawdata = aa_get_loaddata(udata);\n\t\terror = __lookup_replace(ns, ent->new->base.hname,\n\t\t\t\t\t !(mask & AA_MAY_REPLACE_POLICY),\n\t\t\t\t\t &ent->old, &info);\n\t\tif (error)\n\t\t\tgoto fail_lock;\n\n\t\tif (ent->new->rename) {\n\t\t\terror = __lookup_replace(ns, ent->new->rename,\n\t\t\t\t\t\t!(mask & AA_MAY_REPLACE_POLICY),\n\t\t\t\t\t\t&ent->rename, &info);\n\t\t\tif (error)\n\t\t\t\tgoto fail_lock;\n\t\t}\n\n\t\t/* released when @new is freed */\n\t\tent->new->ns = aa_get_ns(ns);\n\n\t\tif (ent->old || ent->rename)\n\t\t\tcontinue;\n\n\t\t/* no ref on policy only use inside lock */\n\t\tpolicy = __lookup_parent(ns, ent->new->base.hname);\n\t\tif (!policy) {\n\t\t\tstruct aa_profile *p;\n\t\t\tp = __list_lookup_parent(&lh, ent->new);\n\t\t\tif (!p) {\n\t\t\t\terror = -ENOENT;\n\t\t\t\tinfo = \"parent does not exist\";\n\t\t\t\tgoto fail_lock;\n\t\t\t}\n\t\t\trcu_assign_pointer(ent->new->parent, aa_get_profile(p));\n\t\t} else if (policy != &ns->base) {\n\t\t\t/* released on profile replacement or free_profile */\n\t\t\tstruct aa_profile *p = (struct aa_profile *) policy;\n\t\t\trcu_assign_pointer(ent->new->parent, aa_get_profile(p));\n\t\t}\n\t}\n\n\t/* create new fs entries for introspection if needed */\n\tif (!udata->dents[AAFS_LOADDATA_DIR]) {\n\t\terror = __aa_fs_create_rawdata(ns, udata);\n\t\tif (error) {\n\t\t\tinfo = \"failed to create raw_data dir and files\";\n\t\t\tent = NULL;\n\t\t\tgoto fail_lock;\n\t\t}\n\t}\n\tlist_for_each_entry(ent, &lh, list) {\n\t\tif (!ent->old) {\n\t\t\tstruct dentry *parent;\n\t\t\tif (rcu_access_pointer(ent->new->parent)) {\n\t\t\t\tstruct aa_profile *p;\n\t\t\t\tp = aa_deref_parent(ent->new);\n\t\t\t\tparent = prof_child_dir(p);\n\t\t\t} else\n\t\t\t\tparent = ns_subprofs_dir(ent->new->ns);\n\t\t\terror = __aafs_profile_mkdir(ent->new, parent);\n\t\t}\n\n\t\tif (error) {\n\t\t\tinfo = \"failed to create\";\n\t\t\tgoto fail_lock;\n\t\t}\n\t}\n\n\t/* Done with checks that may fail - do actual replacement */\n\t__aa_bump_ns_revision(ns);\n\t__aa_loaddata_update(udata, ns->revision);\n\tlist_for_each_entry_safe(ent, tmp, &lh, list) {\n\t\tlist_del_init(&ent->list);\n\t\top = (!ent->old && !ent->rename) ? OP_PROF_LOAD : OP_PROF_REPL;\n\n\t\tif (ent->old && ent->old->rawdata == ent->new->rawdata) {\n\t\t\t/* dedup actual profile replacement */\n\t\t\taudit_policy(label, op, ns_name, ent->new->base.hname,\n\t\t\t\t     \"same as current profile, skipping\",\n\t\t\t\t     error);\n\t\t\tgoto skip;\n\t\t}\n\n\t\t/*\n\t\t * TODO: finer dedup based on profile range in data. Load set\n\t\t * can differ but profile may remain unchanged\n\t\t */\n\t\taudit_policy(label, op, ns_name, ent->new->base.hname, NULL,\n\t\t\t     error);\n\n\t\tif (ent->old) {\n\t\t\tshare_name(ent->old, ent->new);\n\t\t\t__replace_profile(ent->old, ent->new);\n\t\t} else {\n\t\t\tstruct list_head *lh;\n\n\t\t\tif (rcu_access_pointer(ent->new->parent)) {\n\t\t\t\tstruct aa_profile *parent;\n\n\t\t\t\tparent = update_to_newest_parent(ent->new);\n\t\t\t\tlh = &parent->base.profiles;\n\t\t\t} else\n\t\t\t\tlh = &ns->base.profiles;\n\t\t\t__add_profile(lh, ent->new);\n\t\t}\n\tskip:\n\t\taa_load_ent_free(ent);\n\t}\n\t__aa_labelset_update_subtree(ns);\n\tmutex_unlock(&ns->lock);\n\nout:\n\taa_put_ns(ns);\n\taa_put_loaddata(udata);\n\n\tif (error)\n\t\treturn error;\n\treturn udata->size;\n\nfail_lock:\n\tmutex_unlock(&ns->lock);\n\n\t/* audit cause of failure */\n\top = (ent && !ent->old) ? OP_PROF_LOAD : OP_PROF_REPL;\nfail:\n\t  audit_policy(label, op, ns_name, ent ? ent->new->base.hname : NULL,\n\t\t       info, error);\n\t/* audit status that rest of profiles in the atomic set failed too */\n\tinfo = \"valid profile in failed atomic policy load\";\n\tlist_for_each_entry(tmp, &lh, list) {\n\t\tif (tmp == ent) {\n\t\t\tinfo = \"unchecked profile in failed atomic policy load\";\n\t\t\t/* skip entry that caused failure */\n\t\t\tcontinue;\n\t\t}\n\t\top = (!tmp->old) ? OP_PROF_LOAD : OP_PROF_REPL;\n\t\taudit_policy(label, op, ns_name, tmp->new->base.hname, info,\n\t\t\t     error);\n\t}\n\tlist_for_each_entry_safe(ent, tmp, &lh, list) {\n\t\tlist_del_init(&ent->list);\n\t\taa_load_ent_free(ent);\n\t}\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_simple_write_to_buffer",
          "args": [
            "buf",
            "size",
            "size",
            "pos"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "aa_simple_write_to_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "382-407",
          "snippet": "static struct aa_loaddata *aa_simple_write_to_buffer(const char __user *userbuf,\n\t\t\t\t\t\t     size_t alloc_size,\n\t\t\t\t\t\t     size_t copy_size,\n\t\t\t\t\t\t     loff_t *pos)\n{\n\tstruct aa_loaddata *data;\n\n\tAA_BUG(copy_size > alloc_size);\n\n\tif (*pos != 0)\n\t\t/* only writes from pos 0, that is complete writes */\n\t\treturn ERR_PTR(-ESPIPE);\n\n\t/* freed by caller to simple_write_to_buffer */\n\tdata = aa_loaddata_alloc(alloc_size);\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\tdata->size = copy_size;\n\tif (copy_from_user(data->data, userbuf, copy_size)) {\n\t\tkvfree(data);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\treturn data;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_loaddata *aa_simple_write_to_buffer(const char __user *userbuf,\n\t\t\t\t\t\t     size_t alloc_size,\n\t\t\t\t\t\t     size_t copy_size,\n\t\t\t\t\t\t     loff_t *pos)\n{\n\tstruct aa_loaddata *data;\n\n\tAA_BUG(copy_size > alloc_size);\n\n\tif (*pos != 0)\n\t\t/* only writes from pos 0, that is complete writes */\n\t\treturn ERR_PTR(-ESPIPE);\n\n\t/* freed by caller to simple_write_to_buffer */\n\tdata = aa_loaddata_alloc(alloc_size);\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\tdata->size = copy_size;\n\tif (copy_from_user(data->data, userbuf, copy_size)) {\n\t\tkvfree(data);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_may_manage_policy",
          "args": [
            "label",
            "ns",
            "mask"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "aa_may_manage_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "678-700",
          "snippet": "int aa_may_manage_policy(struct aa_label *label, struct aa_ns *ns, u32 mask)\n{\n\tconst char *op;\n\n\tif (mask & AA_MAY_REMOVE_POLICY)\n\t\top = OP_PROF_RM;\n\telse if (mask & AA_MAY_REPLACE_POLICY)\n\t\top = OP_PROF_REPL;\n\telse\n\t\top = OP_PROF_LOAD;\n\n\t/* check if loading policy is locked out */\n\tif (aa_g_lock_policy)\n\t\treturn audit_policy(label, op, NULL, NULL, \"policy_locked\",\n\t\t\t\t    -EACCES);\n\n\tif (!policy_admin_capable(ns))\n\t\treturn audit_policy(label, op, NULL, NULL, \"not policy admin\",\n\t\t\t\t    -EACCES);\n\n\t/* TODO: add fine grained mediation of policy loads */\n\treturn 0;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint aa_may_manage_policy(struct aa_label *label, struct aa_ns *ns, u32 mask)\n{\n\tconst char *op;\n\n\tif (mask & AA_MAY_REMOVE_POLICY)\n\t\top = OP_PROF_RM;\n\telse if (mask & AA_MAY_REPLACE_POLICY)\n\t\top = OP_PROF_REPL;\n\telse\n\t\top = OP_PROF_LOAD;\n\n\t/* check if loading policy is locked out */\n\tif (aa_g_lock_policy)\n\t\treturn audit_policy(label, op, NULL, NULL, \"policy_locked\",\n\t\t\t\t    -EACCES);\n\n\tif (!policy_admin_capable(ns))\n\t\treturn audit_policy(label, op, NULL, NULL, \"not policy admin\",\n\t\t\t\t    -EACCES);\n\n\t/* TODO: add fine grained mediation of policy loads */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic ssize_t policy_update(u32 mask, const char __user *buf, size_t size,\n\t\t\t     loff_t *pos, struct aa_ns *ns)\n{\n\tstruct aa_loaddata *data;\n\tstruct aa_label *label;\n\tssize_t error;\n\n\tlabel = begin_current_label_crit_section();\n\n\t/* high level check about policy management - fine grained in\n\t * below after unpack\n\t */\n\terror = aa_may_manage_policy(label, ns, mask);\n\tif (error)\n\t\treturn error;\n\n\tdata = aa_simple_write_to_buffer(buf, size, size, pos);\n\terror = PTR_ERR(data);\n\tif (!IS_ERR(data)) {\n\t\terror = aa_replace_profiles(ns, label, mask, data);\n\t\taa_put_loaddata(data);\n\t}\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "aa_simple_write_to_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "382-407",
    "snippet": "static struct aa_loaddata *aa_simple_write_to_buffer(const char __user *userbuf,\n\t\t\t\t\t\t     size_t alloc_size,\n\t\t\t\t\t\t     size_t copy_size,\n\t\t\t\t\t\t     loff_t *pos)\n{\n\tstruct aa_loaddata *data;\n\n\tAA_BUG(copy_size > alloc_size);\n\n\tif (*pos != 0)\n\t\t/* only writes from pos 0, that is complete writes */\n\t\treturn ERR_PTR(-ESPIPE);\n\n\t/* freed by caller to simple_write_to_buffer */\n\tdata = aa_loaddata_alloc(alloc_size);\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\tdata->size = copy_size;\n\tif (copy_from_user(data->data, userbuf, copy_size)) {\n\t\tkvfree(data);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\treturn data;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "data"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "data->data",
            "userbuf",
            "copy_size"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_loaddata_alloc",
          "args": [
            "alloc_size"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "aa_loaddata_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "181-191",
          "snippet": "struct aa_loaddata *aa_loaddata_alloc(size_t size)\n{\n\tstruct aa_loaddata *d = kvzalloc(sizeof(*d) + size, GFP_KERNEL);\n\n\tif (d == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkref_init(&d->count);\n\tINIT_LIST_HEAD(&d->list);\n\n\treturn d;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstruct aa_loaddata *aa_loaddata_alloc(size_t size)\n{\n\tstruct aa_loaddata *d = kvzalloc(sizeof(*d) + size, GFP_KERNEL);\n\n\tif (d == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkref_init(&d->count);\n\tINIT_LIST_HEAD(&d->list);\n\n\treturn d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESPIPE"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "copy_size > alloc_size"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_loaddata *aa_simple_write_to_buffer(const char __user *userbuf,\n\t\t\t\t\t\t     size_t alloc_size,\n\t\t\t\t\t\t     size_t copy_size,\n\t\t\t\t\t\t     loff_t *pos)\n{\n\tstruct aa_loaddata *data;\n\n\tAA_BUG(copy_size > alloc_size);\n\n\tif (*pos != 0)\n\t\t/* only writes from pos 0, that is complete writes */\n\t\treturn ERR_PTR(-ESPIPE);\n\n\t/* freed by caller to simple_write_to_buffer */\n\tdata = aa_loaddata_alloc(alloc_size);\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\tdata->size = copy_size;\n\tif (copy_from_user(data->data, userbuf, copy_size)) {\n\t\tkvfree(data);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\treturn data;\n}"
  },
  {
    "function_name": "aafs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "347-365",
    "snippet": "static void aafs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *aafs_mnt;",
      "static int aafs_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_release_fs",
          "args": [
            "&aafs_mnt",
            "&aafs_count"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "dir"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_rmdir",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_positive",
          "args": [
            "dentry"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "dir"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry->d_parent"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct vfsmount *aafs_mnt;\nstatic int aafs_count;\n\nstatic void aafs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n}"
  },
  {
    "function_name": "aafs_create_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "321-340",
    "snippet": "static struct dentry *aafs_create_symlink(const char *name,\n\t\t\t\t\t  struct dentry *parent,\n\t\t\t\t\t  const char *target,\n\t\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dent;\n\tchar *link = NULL;\n\n\tif (target) {\n\t\tlink = kstrdup(target, GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tdent = aafs_create(name, S_IFLNK | 0444, parent, NULL, link, NULL,\n\t\t\t   iops);\n\tif (IS_ERR(dent))\n\t\tkfree(link);\n\n\treturn dent;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aafs_create",
          "args": [
            "name",
            "S_IFLNK | 0444",
            "parent",
            "NULL",
            "link",
            "NULL",
            "iops"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "229-277",
          "snippet": "static struct dentry *aafs_create(const char *name, umode_t mode,\n\t\t\t\t  struct dentry *parent, void *data, void *link,\n\t\t\t\t  const struct file_operations *fops,\n\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tint error;\n\n\tAA_BUG(!name);\n\tAA_BUG(!parent);\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto fail_lock;\n\t}\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto fail_dentry;\n\t}\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode, data, link, fops, iops);\n\tif (error)\n\t\tgoto fail_dentry;\n\tinode_unlock(dir);\n\n\treturn dentry;\n\nfail_dentry:\n\tdput(dentry);\n\nfail_lock:\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *aafs_mnt;",
            "static int aafs_count;",
            "static struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct vfsmount *aafs_mnt;\nstatic int aafs_count;\nstatic struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};\n\nstatic struct dentry *aafs_create(const char *name, umode_t mode,\n\t\t\t\t  struct dentry *parent, void *data, void *link,\n\t\t\t\t  const struct file_operations *fops,\n\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tint error;\n\n\tAA_BUG(!name);\n\tAA_BUG(!parent);\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto fail_lock;\n\t}\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto fail_dentry;\n\t}\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode, data, link, fops, iops);\n\tif (error)\n\t\tgoto fail_dentry;\n\tinode_unlock(dir);\n\n\treturn dentry;\n\nfail_dentry:\n\tdput(dentry);\n\nfail_lock:\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "target",
            "GFP_KERNEL"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *aafs_create_symlink(const char *name,\n\t\t\t\t\t  struct dentry *parent,\n\t\t\t\t\t  const char *target,\n\t\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dent;\n\tchar *link = NULL;\n\n\tif (target) {\n\t\tlink = kstrdup(target, GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tdent = aafs_create(name, S_IFLNK | 0444, parent, NULL, link, NULL,\n\t\t\t   iops);\n\tif (IS_ERR(dent))\n\t\tkfree(link);\n\n\treturn dent;\n}"
  },
  {
    "function_name": "aafs_create_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "305-309",
    "snippet": "static struct dentry *aafs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn aafs_create(name, S_IFDIR | 0755, parent, NULL, NULL, NULL,\n\t\t\t   NULL);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aafs_create",
          "args": [
            "name",
            "S_IFDIR | 0755",
            "parent",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "229-277",
          "snippet": "static struct dentry *aafs_create(const char *name, umode_t mode,\n\t\t\t\t  struct dentry *parent, void *data, void *link,\n\t\t\t\t  const struct file_operations *fops,\n\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tint error;\n\n\tAA_BUG(!name);\n\tAA_BUG(!parent);\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto fail_lock;\n\t}\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto fail_dentry;\n\t}\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode, data, link, fops, iops);\n\tif (error)\n\t\tgoto fail_dentry;\n\tinode_unlock(dir);\n\n\treturn dentry;\n\nfail_dentry:\n\tdput(dentry);\n\nfail_lock:\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *aafs_mnt;",
            "static int aafs_count;",
            "static struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct vfsmount *aafs_mnt;\nstatic int aafs_count;\nstatic struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};\n\nstatic struct dentry *aafs_create(const char *name, umode_t mode,\n\t\t\t\t  struct dentry *parent, void *data, void *link,\n\t\t\t\t  const struct file_operations *fops,\n\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tint error;\n\n\tAA_BUG(!name);\n\tAA_BUG(!parent);\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto fail_lock;\n\t}\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto fail_dentry;\n\t}\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode, data, link, fops, iops);\n\tif (error)\n\t\tgoto fail_dentry;\n\tinode_unlock(dir);\n\n\treturn dentry;\n\nfail_dentry:\n\tdput(dentry);\n\nfail_lock:\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n\n\treturn ERR_PTR(error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *aafs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn aafs_create(name, S_IFDIR | 0755, parent, NULL, NULL, NULL,\n\t\t\t   NULL);\n}"
  },
  {
    "function_name": "aafs_create_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "290-295",
    "snippet": "static struct dentry *aafs_create_file(const char *name, umode_t mode,\n\t\t\t\t       struct dentry *parent, void *data,\n\t\t\t\t       const struct file_operations *fops)\n{\n\treturn aafs_create(name, mode, parent, data, NULL, fops, NULL);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aafs_create",
          "args": [
            "name",
            "mode",
            "parent",
            "data",
            "NULL",
            "fops",
            "NULL"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "aafs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "229-277",
          "snippet": "static struct dentry *aafs_create(const char *name, umode_t mode,\n\t\t\t\t  struct dentry *parent, void *data, void *link,\n\t\t\t\t  const struct file_operations *fops,\n\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tint error;\n\n\tAA_BUG(!name);\n\tAA_BUG(!parent);\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto fail_lock;\n\t}\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto fail_dentry;\n\t}\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode, data, link, fops, iops);\n\tif (error)\n\t\tgoto fail_dentry;\n\tinode_unlock(dir);\n\n\treturn dentry;\n\nfail_dentry:\n\tdput(dentry);\n\nfail_lock:\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *aafs_mnt;",
            "static int aafs_count;",
            "static struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct vfsmount *aafs_mnt;\nstatic int aafs_count;\nstatic struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};\n\nstatic struct dentry *aafs_create(const char *name, umode_t mode,\n\t\t\t\t  struct dentry *parent, void *data, void *link,\n\t\t\t\t  const struct file_operations *fops,\n\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tint error;\n\n\tAA_BUG(!name);\n\tAA_BUG(!parent);\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto fail_lock;\n\t}\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto fail_dentry;\n\t}\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode, data, link, fops, iops);\n\tif (error)\n\t\tgoto fail_dentry;\n\tinode_unlock(dir);\n\n\treturn dentry;\n\nfail_dentry:\n\tdput(dentry);\n\nfail_lock:\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n\n\treturn ERR_PTR(error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *aafs_create_file(const char *name, umode_t mode,\n\t\t\t\t       struct dentry *parent, void *data,\n\t\t\t\t       const struct file_operations *fops)\n{\n\treturn aafs_create(name, mode, parent, data, NULL, fops, NULL);\n}"
  },
  {
    "function_name": "aafs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "229-277",
    "snippet": "static struct dentry *aafs_create(const char *name, umode_t mode,\n\t\t\t\t  struct dentry *parent, void *data, void *link,\n\t\t\t\t  const struct file_operations *fops,\n\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tint error;\n\n\tAA_BUG(!name);\n\tAA_BUG(!parent);\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto fail_lock;\n\t}\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto fail_dentry;\n\t}\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode, data, link, fops, iops);\n\tif (error)\n\t\tgoto fail_dentry;\n\tinode_unlock(dir);\n\n\treturn dentry;\n\nfail_dentry:\n\tdput(dentry);\n\nfail_lock:\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *aafs_mnt;",
      "static int aafs_count;",
      "static struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_release_fs",
          "args": [
            "&aafs_mnt",
            "&aafs_count"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "dir"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "dir"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aafs_setup_d_inode",
          "args": [
            "dir",
            "dentry",
            "mode",
            "data",
            "link",
            "fops",
            "iops"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "__aafs_setup_d_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "179-211",
          "snippet": "static int __aafs_setup_d_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, void *data, char *link,\n\t\t\t       const struct file_operations *fops,\n\t\t\t       const struct inode_operations *iops)\n{\n\tstruct inode *inode = new_inode(dir->i_sb);\n\n\tAA_BUG(!dir);\n\tAA_BUG(!dentry);\n\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = link;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int __aafs_setup_d_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, void *data, char *link,\n\t\t\t       const struct file_operations *fops,\n\t\t\t       const struct inode_operations *iops)\n{\n\tstruct inode *inode = new_inode(dir->i_sb);\n\n\tAA_BUG(!dir);\n\tAA_BUG(!dentry);\n\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = link;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_really_is_positive",
          "args": [
            "dentry"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "parent",
            "strlen(name)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "dir"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "parent"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_pin_fs",
          "args": [
            "&aafs_ops",
            "&aafs_mnt",
            "&aafs_count"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!parent"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!name"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct vfsmount *aafs_mnt;\nstatic int aafs_count;\nstatic struct file_system_type aafs_ops = {\n\t.owner = THIS_MODULE,\n\t.name = AAFS_NAME,\n\t.mount = aafs_mount,\n\t.kill_sb = kill_anon_super,\n};\n\nstatic struct dentry *aafs_create(const char *name, umode_t mode,\n\t\t\t\t  struct dentry *parent, void *data, void *link,\n\t\t\t\t  const struct file_operations *fops,\n\t\t\t\t  const struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tint error;\n\n\tAA_BUG(!name);\n\tAA_BUG(!parent);\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\terror = simple_pin_fs(&aafs_ops, &aafs_mnt, &aafs_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto fail_lock;\n\t}\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto fail_dentry;\n\t}\n\n\terror = __aafs_setup_d_inode(dir, dentry, mode, data, link, fops, iops);\n\tif (error)\n\t\tgoto fail_dentry;\n\tinode_unlock(dir);\n\n\treturn dentry;\n\nfail_dentry:\n\tdput(dentry);\n\nfail_lock:\n\tinode_unlock(dir);\n\tsimple_release_fs(&aafs_mnt, &aafs_count);\n\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "__aafs_setup_d_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "179-211",
    "snippet": "static int __aafs_setup_d_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, void *data, char *link,\n\t\t\t       const struct file_operations *fops,\n\t\t\t       const struct inode_operations *iops)\n{\n\tstruct inode *inode = new_inode(dir->i_sb);\n\n\tAA_BUG(!dir);\n\tAA_BUG(!dentry);\n\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = link;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "security_d_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "1249-1254",
          "snippet": "void security_d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tif (unlikely(inode && IS_PRIVATE(inode)))\n\t\treturn;\n\tcall_void_hook(d_instantiate, dentry, inode);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nvoid security_d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tif (unlikely(inode && IS_PRIVATE(inode)))\n\t\treturn;\n\tcall_void_hook(d_instantiate, dentry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!dentry"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!dir"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "dir->i_sb"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_smack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "295-308",
          "snippet": "static struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *smack_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct kmem_cache *smack_inode_cache;\n\nstatic struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int __aafs_setup_d_inode(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, void *data, char *link,\n\t\t\t       const struct file_operations *fops,\n\t\t\t       const struct inode_operations *iops)\n{\n\tstruct inode *inode = new_inode(dir->i_sb);\n\n\tAA_BUG(!dir);\n\tAA_BUG(!dentry);\n\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = link;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "aafs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "156-160",
    "snippet": "static struct dentry *aafs_mount(struct file_system_type *fs_type,\n\t\t\t\t int flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, fill_super);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_single",
          "args": [
            "fs_type",
            "flags",
            "data",
            "fill_super"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct dentry *aafs_mount(struct file_system_type *fs_type,\n\t\t\t\t int flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, fill_super);\n}"
  },
  {
    "function_name": "fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "143-154",
    "snippet": "static int fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstatic struct tree_descr files[] = { {\"\"} };\n\tint error;\n\n\terror = simple_fill_super(sb, AAFS_MAGIC, files);\n\tif (error)\n\t\treturn error;\n\tsb->s_op = &aafs_super_ops;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations aafs_super_ops = {\n\t.statfs = simple_statfs,\n\t.evict_inode = aafs_evict_inode,\n\t.show_path = aafs_show_path,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_fill_super",
          "args": [
            "sb",
            "AAFS_MAGIC",
            "files"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic const struct super_operations aafs_super_ops = {\n\t.statfs = simple_statfs,\n\t.evict_inode = aafs_evict_inode,\n\t.show_path = aafs_show_path,\n};\n\nstatic int fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstatic struct tree_descr files[] = { {\"\"} };\n\tint error;\n\n\terror = simple_fill_super(sb, AAFS_MAGIC, files);\n\tif (error)\n\t\treturn error;\n\tsb->s_op = &aafs_super_ops;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "aafs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "129-135",
    "snippet": "static void aafs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(inode->i_link);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "inode->i_link"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic void aafs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(inode->i_link);\n}"
  },
  {
    "function_name": "aafs_show_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "121-127",
    "snippet": "static int aafs_show_path(struct seq_file *seq, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tseq_printf(seq, \"%s:[%lu]\", AAFS_NAME, inode->i_ino);\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define AAFS_NAME\t\t\"apparmorfs\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%s:[%lu]\"",
            "AAFS_NAME",
            "inode->i_ino"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\n#define AAFS_NAME\t\t\"apparmorfs\"\n\nstatic int aafs_show_path(struct seq_file *seq, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tseq_printf(seq, \"%s:[%lu]\", AAFS_NAME, inode->i_ino);\n\treturn 0;\n}"
  },
  {
    "function_name": "mangle_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
    "lines": "79-109",
    "snippet": "static int mangle_name(const char *name, char *target)\n{\n\tchar *t = target;\n\n\twhile (*name == '/' || *name == '.')\n\t\tname++;\n\n\tif (target) {\n\t\tfor (; *name; name++) {\n\t\t\tif (*name == '/')\n\t\t\t\t*(t)++ = '.';\n\t\t\telse if (isspace(*name))\n\t\t\t\t*(t)++ = '_';\n\t\t\telse if (isalnum(*name) || strchr(\"._-\", *name))\n\t\t\t\t*(t)++ = *name;\n\t\t}\n\n\t\t*t = 0;\n\t} else {\n\t\tint len = 0;\n\t\tfor (; *name; name++) {\n\t\t\tif (isalnum(*name) || isspace(*name) ||\n\t\t\t    strchr(\"/._-\", *name))\n\t\t\t\tlen++;\n\t\t}\n\n\t\treturn len;\n\t}\n\n\treturn t - target;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <uapi/linux/magic.h>",
      "#include <uapi/linux/major.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/capability.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/security.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\"/._-\"",
            "*name"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*name"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "*name"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\"._-\"",
            "*name"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "*name"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*name"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int mangle_name(const char *name, char *target)\n{\n\tchar *t = target;\n\n\twhile (*name == '/' || *name == '.')\n\t\tname++;\n\n\tif (target) {\n\t\tfor (; *name; name++) {\n\t\t\tif (*name == '/')\n\t\t\t\t*(t)++ = '.';\n\t\t\telse if (isspace(*name))\n\t\t\t\t*(t)++ = '_';\n\t\t\telse if (isalnum(*name) || strchr(\"._-\", *name))\n\t\t\t\t*(t)++ = *name;\n\t\t}\n\n\t\t*t = 0;\n\t} else {\n\t\tint len = 0;\n\t\tfor (; *name; name++) {\n\t\t\tif (isalnum(*name) || isspace(*name) ||\n\t\t\t    strchr(\"/._-\", *name))\n\t\t\t\tlen++;\n\t\t}\n\n\t\treturn len;\n\t}\n\n\treturn t - target;\n}"
  }
]