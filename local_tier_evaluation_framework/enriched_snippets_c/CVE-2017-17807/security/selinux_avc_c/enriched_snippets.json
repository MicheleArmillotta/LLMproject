[
  {
    "function_name": "avc_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "1173-1190",
    "snippet": "void avc_disable(void)\n{\n\t/*\n\t * If you are looking at this because you have realized that we are\n\t * not destroying the avc_node_cachep it might be easy to fix, but\n\t * I don't know the memory barrier semantics well enough to know.  It's\n\t * possible that some other task dereferenced security_ops when\n\t * it still pointed to selinux operations.  If that is the case it's\n\t * possible that it is about to use the avc and is about to need the\n\t * avc_node_cachep.  I know I could wrap the security.c security_ops call\n\t * in an rcu_lock, but seriously, it's not worth it.  Instead I just flush\n\t * the cache and get that memory back.\n\t */\n\tif (avc_node_cachep) {\n\t\tavc_flush();\n\t\t/* kmem_cache_destroy(avc_node_cachep); */\n\t}\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *avc_node_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_flush",
          "args": [],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "avc_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "907-930",
          "snippet": "static void avc_flush(void)\n{\n\tstruct hlist_head *head;\n\tstruct avc_node *node;\n\tspinlock_t *lock;\n\tunsigned long flag;\n\tint i;\n\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\thead = &avc_cache.slots[i];\n\t\tlock = &avc_cache.slots_lock[i];\n\n\t\tspin_lock_irqsave(lock, flag);\n\t\t/*\n\t\t * With preemptable RCU, the outer spinlock does not\n\t\t * prevent RCU grace periods from ending.\n\t\t */\n\t\trcu_read_lock();\n\t\thlist_for_each_entry(node, head, list)\n\t\t\tavc_node_delete(node);\n\t\trcu_read_unlock();\n\t\tspin_unlock_irqrestore(lock, flag);\n\t}\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define AVC_CACHE_SLOTS\t\t\t512"
          ],
          "globals_used": [
            "static struct avc_cache avc_cache;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#define AVC_CACHE_SLOTS\t\t\t512\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nstatic void avc_flush(void)\n{\n\tstruct hlist_head *head;\n\tstruct avc_node *node;\n\tspinlock_t *lock;\n\tunsigned long flag;\n\tint i;\n\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\thead = &avc_cache.slots[i];\n\t\tlock = &avc_cache.slots_lock[i];\n\n\t\tspin_lock_irqsave(lock, flag);\n\t\t/*\n\t\t * With preemptable RCU, the outer spinlock does not\n\t\t * prevent RCU grace periods from ending.\n\t\t */\n\t\trcu_read_lock();\n\t\thlist_for_each_entry(node, head, list)\n\t\t\tavc_node_delete(node);\n\t\trcu_read_unlock();\n\t\tspin_unlock_irqrestore(lock, flag);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_node_cachep;\n\nvoid avc_disable(void)\n{\n\t/*\n\t * If you are looking at this because you have realized that we are\n\t * not destroying the avc_node_cachep it might be easy to fix, but\n\t * I don't know the memory barrier semantics well enough to know.  It's\n\t * possible that some other task dereferenced security_ops when\n\t * it still pointed to selinux operations.  If that is the case it's\n\t * possible that it is about to use the avc and is about to need the\n\t * avc_node_cachep.  I know I could wrap the security.c security_ops call\n\t * in an rcu_lock, but seriously, it's not worth it.  Instead I just flush\n\t * the cache and get that memory back.\n\t */\n\tif (avc_node_cachep) {\n\t\tavc_flush();\n\t\t/* kmem_cache_destroy(avc_node_cachep); */\n\t}\n}"
  },
  {
    "function_name": "avc_policy_seqno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "1168-1171",
    "snippet": "u32 avc_policy_seqno(void)\n{\n\treturn avc_cache.latest_notif;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct avc_cache avc_cache;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\n\nu32 avc_policy_seqno(void)\n{\n\treturn avc_cache.latest_notif;\n}"
  },
  {
    "function_name": "avc_has_perm_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "1152-1166",
    "snippet": "int avc_has_perm_flags(u32 ssid, u32 tsid, u16 tclass,\n\t\t       u32 requested, struct common_audit_data *auditdata,\n\t\t       int flags)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc,\n\t\t\tauditdata, flags);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_audit",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "requested",
            "&avd",
            "rc",
            "auditdata",
            "flags"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "avc_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/avc.h",
          "lines": "130-144",
          "snippet": "static inline int avc_audit(u32 ssid, u32 tsid,\n\t\t\t    u16 tclass, u32 requested,\n\t\t\t    struct av_decision *avd,\n\t\t\t    int result,\n\t\t\t    struct common_audit_data *a,\n\t\t\t    int flags)\n{\n\tu32 audited, denied;\n\taudited = avc_audit_required(requested, avd, result, 0, &denied);\n\tif (likely(!audited))\n\t\treturn 0;\n\treturn slow_avc_audit(ssid, tsid, tclass,\n\t\t\t      requested, audited, denied, result,\n\t\t\t      a, flags);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"av_permissions.h\"",
            "#include \"flask.h\"",
            "#include <linux/in6.h>",
            "#include <linux/lsm_audit.h>",
            "#include <linux/audit.h>",
            "#include <linux/init.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"av_permissions.h\"\n#include \"flask.h\"\n#include <linux/in6.h>\n#include <linux/lsm_audit.h>\n#include <linux/audit.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/kdev_t.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n\nstatic inline int avc_audit(u32 ssid, u32 tsid,\n\t\t\t    u16 tclass, u32 requested,\n\t\t\t    struct av_decision *avd,\n\t\t\t    int result,\n\t\t\t    struct common_audit_data *a,\n\t\t\t    int flags)\n{\n\tu32 audited, denied;\n\taudited = avc_audit_required(requested, avd, result, 0, &denied);\n\tif (likely(!audited))\n\t\treturn 0;\n\treturn slow_avc_audit(ssid, tsid, tclass,\n\t\t\t      requested, audited, denied, result,\n\t\t\t      a, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_has_perm_noaudit",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "requested",
            "0",
            "&avd"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1094-1120",
          "snippet": "inline int avc_has_perm_noaudit(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, u32 requested,\n\t\t\t unsigned flags,\n\t\t\t struct av_decision *avd)\n{\n\tstruct avc_node *node;\n\tstruct avc_xperms_node xp_node;\n\tint rc = 0;\n\tu32 denied;\n\n\tBUG_ON(!requested);\n\n\trcu_read_lock();\n\n\tnode = avc_lookup(ssid, tsid, tclass);\n\tif (unlikely(!node))\n\t\tnode = avc_compute_av(ssid, tsid, tclass, avd, &xp_node);\n\telse\n\t\tmemcpy(avd, &node->ae.avd, sizeof(*avd));\n\n\tdenied = requested & ~(avd->allowed);\n\tif (unlikely(denied))\n\t\trc = avc_denied(ssid, tsid, tclass, requested, 0, 0, flags, avd);\n\n\trcu_read_unlock();\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\ninline int avc_has_perm_noaudit(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, u32 requested,\n\t\t\t unsigned flags,\n\t\t\t struct av_decision *avd)\n{\n\tstruct avc_node *node;\n\tstruct avc_xperms_node xp_node;\n\tint rc = 0;\n\tu32 denied;\n\n\tBUG_ON(!requested);\n\n\trcu_read_lock();\n\n\tnode = avc_lookup(ssid, tsid, tclass);\n\tif (unlikely(!node))\n\t\tnode = avc_compute_av(ssid, tsid, tclass, avd, &xp_node);\n\telse\n\t\tmemcpy(avd, &node->ae.avd, sizeof(*avd));\n\n\tdenied = requested & ~(avd->allowed);\n\tif (unlikely(denied))\n\t\trc = avc_denied(ssid, tsid, tclass, requested, 0, 0, flags, avd);\n\n\trcu_read_unlock();\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm_flags(u32 ssid, u32 tsid, u16 tclass,\n\t\t       u32 requested, struct common_audit_data *auditdata,\n\t\t       int flags)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc,\n\t\t\tauditdata, flags);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
  },
  {
    "function_name": "avc_has_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "1138-1150",
    "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_audit",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "requested",
            "&avd",
            "rc",
            "auditdata",
            "0"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "avc_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/avc.h",
          "lines": "130-144",
          "snippet": "static inline int avc_audit(u32 ssid, u32 tsid,\n\t\t\t    u16 tclass, u32 requested,\n\t\t\t    struct av_decision *avd,\n\t\t\t    int result,\n\t\t\t    struct common_audit_data *a,\n\t\t\t    int flags)\n{\n\tu32 audited, denied;\n\taudited = avc_audit_required(requested, avd, result, 0, &denied);\n\tif (likely(!audited))\n\t\treturn 0;\n\treturn slow_avc_audit(ssid, tsid, tclass,\n\t\t\t      requested, audited, denied, result,\n\t\t\t      a, flags);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"av_permissions.h\"",
            "#include \"flask.h\"",
            "#include <linux/in6.h>",
            "#include <linux/lsm_audit.h>",
            "#include <linux/audit.h>",
            "#include <linux/init.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"av_permissions.h\"\n#include \"flask.h\"\n#include <linux/in6.h>\n#include <linux/lsm_audit.h>\n#include <linux/audit.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/kdev_t.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n\nstatic inline int avc_audit(u32 ssid, u32 tsid,\n\t\t\t    u16 tclass, u32 requested,\n\t\t\t    struct av_decision *avd,\n\t\t\t    int result,\n\t\t\t    struct common_audit_data *a,\n\t\t\t    int flags)\n{\n\tu32 audited, denied;\n\taudited = avc_audit_required(requested, avd, result, 0, &denied);\n\tif (likely(!audited))\n\t\treturn 0;\n\treturn slow_avc_audit(ssid, tsid, tclass,\n\t\t\t      requested, audited, denied, result,\n\t\t\t      a, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_has_perm_noaudit",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "requested",
            "0",
            "&avd"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1094-1120",
          "snippet": "inline int avc_has_perm_noaudit(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, u32 requested,\n\t\t\t unsigned flags,\n\t\t\t struct av_decision *avd)\n{\n\tstruct avc_node *node;\n\tstruct avc_xperms_node xp_node;\n\tint rc = 0;\n\tu32 denied;\n\n\tBUG_ON(!requested);\n\n\trcu_read_lock();\n\n\tnode = avc_lookup(ssid, tsid, tclass);\n\tif (unlikely(!node))\n\t\tnode = avc_compute_av(ssid, tsid, tclass, avd, &xp_node);\n\telse\n\t\tmemcpy(avd, &node->ae.avd, sizeof(*avd));\n\n\tdenied = requested & ~(avd->allowed);\n\tif (unlikely(denied))\n\t\trc = avc_denied(ssid, tsid, tclass, requested, 0, 0, flags, avd);\n\n\trcu_read_unlock();\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\ninline int avc_has_perm_noaudit(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, u32 requested,\n\t\t\t unsigned flags,\n\t\t\t struct av_decision *avd)\n{\n\tstruct avc_node *node;\n\tstruct avc_xperms_node xp_node;\n\tint rc = 0;\n\tu32 denied;\n\n\tBUG_ON(!requested);\n\n\trcu_read_lock();\n\n\tnode = avc_lookup(ssid, tsid, tclass);\n\tif (unlikely(!node))\n\t\tnode = avc_compute_av(ssid, tsid, tclass, avd, &xp_node);\n\telse\n\t\tmemcpy(avd, &node->ae.avd, sizeof(*avd));\n\n\tdenied = requested & ~(avd->allowed);\n\tif (unlikely(denied))\n\t\trc = avc_denied(ssid, tsid, tclass, requested, 0, 0, flags, avd);\n\n\trcu_read_unlock();\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
  },
  {
    "function_name": "avc_has_perm_noaudit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "1094-1120",
    "snippet": "inline int avc_has_perm_noaudit(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, u32 requested,\n\t\t\t unsigned flags,\n\t\t\t struct av_decision *avd)\n{\n\tstruct avc_node *node;\n\tstruct avc_xperms_node xp_node;\n\tint rc = 0;\n\tu32 denied;\n\n\tBUG_ON(!requested);\n\n\trcu_read_lock();\n\n\tnode = avc_lookup(ssid, tsid, tclass);\n\tif (unlikely(!node))\n\t\tnode = avc_compute_av(ssid, tsid, tclass, avd, &xp_node);\n\telse\n\t\tmemcpy(avd, &node->ae.avd, sizeof(*avd));\n\n\tdenied = requested & ~(avd->allowed);\n\tif (unlikely(denied))\n\t\trc = avc_denied(ssid, tsid, tclass, requested, 0, 0, flags, avd);\n\n\trcu_read_unlock();\n\treturn rc;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_denied",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "requested",
            "0",
            "0",
            "flags",
            "avd"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "avc_denied",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "977-991",
          "snippet": "static noinline int avc_denied(u32 ssid, u32 tsid,\n\t\t\t\tu16 tclass, u32 requested,\n\t\t\t\tu8 driver, u8 xperm, unsigned flags,\n\t\t\t\tstruct av_decision *avd)\n{\n\tif (flags & AVC_STRICT)\n\t\treturn -EACCES;\n\n\tif (selinux_enforcing && !(avd->flags & AVD_FLAGS_PERMISSIVE))\n\t\treturn -EACCES;\n\n\tavc_update_node(AVC_CALLBACK_GRANT, requested, driver, xperm, ssid,\n\t\t\t\ttsid, tclass, avd->seqno, NULL, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic noinline int avc_denied(u32 ssid, u32 tsid,\n\t\t\t\tu16 tclass, u32 requested,\n\t\t\t\tu8 driver, u8 xperm, unsigned flags,\n\t\t\t\tstruct av_decision *avd)\n{\n\tif (flags & AVC_STRICT)\n\t\treturn -EACCES;\n\n\tif (selinux_enforcing && !(avd->flags & AVD_FLAGS_PERMISSIVE))\n\t\treturn -EACCES;\n\n\tavc_update_node(AVC_CALLBACK_GRANT, requested, driver, xperm, ssid,\n\t\t\t\ttsid, tclass, avd->seqno, NULL, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "denied"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "avd",
            "&node->ae.avd",
            "sizeof(*avd)"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_compute_av",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "avd",
            "&xp_node"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "avc_compute_av",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "966-975",
          "snippet": "avc_node *avc_compute_av(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, struct av_decision *avd,\n\t\t\t struct avc_xperms_node *xp_node)\n{\n\trcu_read_unlock();\n\tINIT_LIST_HEAD(&xp_node->xpd_head);\n\tsecurity_compute_av(ssid, tsid, tclass, avd, &xp_node->xp);\n\trcu_read_lock();\n\treturn avc_insert(ssid, tsid, tclass, avd, xp_node);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\navc_node *avc_compute_av(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, struct av_decision *avd,\n\t\t\t struct avc_xperms_node *xp_node)\n{\n\trcu_read_unlock();\n\tINIT_LIST_HEAD(&xp_node->xpd_head);\n\tsecurity_compute_av(ssid, tsid, tclass, avd, &xp_node->xp);\n\trcu_read_lock();\n\treturn avc_insert(ssid, tsid, tclass, avd, xp_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!node"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_lookup",
          "args": [
            "ssid",
            "tsid",
            "tclass"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "avc_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "603-615",
          "snippet": "static struct avc_node *avc_lookup(u32 ssid, u32 tsid, u16 tclass)\n{\n\tstruct avc_node *node;\n\n\tavc_cache_stats_incr(lookups);\n\tnode = avc_search_node(ssid, tsid, tclass);\n\n\tif (node)\n\t\treturn node;\n\n\tavc_cache_stats_incr(misses);\n\treturn NULL;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic struct avc_node *avc_lookup(u32 ssid, u32 tsid, u16 tclass)\n{\n\tstruct avc_node *node;\n\n\tavc_cache_stats_incr(lookups);\n\tnode = avc_search_node(ssid, tsid, tclass);\n\n\tif (node)\n\t\treturn node;\n\n\tavc_cache_stats_incr(misses);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!requested"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\ninline int avc_has_perm_noaudit(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, u32 requested,\n\t\t\t unsigned flags,\n\t\t\t struct av_decision *avd)\n{\n\tstruct avc_node *node;\n\tstruct avc_xperms_node xp_node;\n\tint rc = 0;\n\tu32 denied;\n\n\tBUG_ON(!requested);\n\n\trcu_read_lock();\n\n\tnode = avc_lookup(ssid, tsid, tclass);\n\tif (unlikely(!node))\n\t\tnode = avc_compute_av(ssid, tsid, tclass, avd, &xp_node);\n\telse\n\t\tmemcpy(avd, &node->ae.avd, sizeof(*avd));\n\n\tdenied = requested & ~(avd->allowed);\n\tif (unlikely(denied))\n\t\trc = avc_denied(ssid, tsid, tclass, requested, 0, 0, flags, avd);\n\n\trcu_read_unlock();\n\treturn rc;\n}"
  },
  {
    "function_name": "avc_has_extended_perms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "1000-1072",
    "snippet": "int avc_has_extended_perms(u32 ssid, u32 tsid, u16 tclass, u32 requested,\n\t\t\tu8 driver, u8 xperm, struct common_audit_data *ad)\n{\n\tstruct avc_node *node;\n\tstruct av_decision avd;\n\tu32 denied;\n\tstruct extended_perms_decision local_xpd;\n\tstruct extended_perms_decision *xpd = NULL;\n\tstruct extended_perms_data allowed;\n\tstruct extended_perms_data auditallow;\n\tstruct extended_perms_data dontaudit;\n\tstruct avc_xperms_node local_xp_node;\n\tstruct avc_xperms_node *xp_node;\n\tint rc = 0, rc2;\n\n\txp_node = &local_xp_node;\n\tBUG_ON(!requested);\n\n\trcu_read_lock();\n\n\tnode = avc_lookup(ssid, tsid, tclass);\n\tif (unlikely(!node)) {\n\t\tnode = avc_compute_av(ssid, tsid, tclass, &avd, xp_node);\n\t} else {\n\t\tmemcpy(&avd, &node->ae.avd, sizeof(avd));\n\t\txp_node = node->ae.xp_node;\n\t}\n\t/* if extended permissions are not defined, only consider av_decision */\n\tif (!xp_node || !xp_node->xp.len)\n\t\tgoto decision;\n\n\tlocal_xpd.allowed = &allowed;\n\tlocal_xpd.auditallow = &auditallow;\n\tlocal_xpd.dontaudit = &dontaudit;\n\n\txpd = avc_xperms_decision_lookup(driver, xp_node);\n\tif (unlikely(!xpd)) {\n\t\t/*\n\t\t * Compute the extended_perms_decision only if the driver\n\t\t * is flagged\n\t\t */\n\t\tif (!security_xperm_test(xp_node->xp.drivers.p, driver)) {\n\t\t\tavd.allowed &= ~requested;\n\t\t\tgoto decision;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsecurity_compute_xperms_decision(ssid, tsid, tclass, driver,\n\t\t\t\t\t\t&local_xpd);\n\t\trcu_read_lock();\n\t\tavc_update_node(AVC_CALLBACK_ADD_XPERMS, requested, driver, xperm,\n\t\t\t\tssid, tsid, tclass, avd.seqno, &local_xpd, 0);\n\t} else {\n\t\tavc_quick_copy_xperms_decision(xperm, &local_xpd, xpd);\n\t}\n\txpd = &local_xpd;\n\n\tif (!avc_xperms_has_perm(xpd, xperm, XPERMS_ALLOWED))\n\t\tavd.allowed &= ~requested;\n\ndecision:\n\tdenied = requested & ~(avd.allowed);\n\tif (unlikely(denied))\n\t\trc = avc_denied(ssid, tsid, tclass, requested, driver, xperm,\n\t\t\t\tAVC_EXTENDED_PERMS, &avd);\n\n\trcu_read_unlock();\n\n\trc2 = avc_xperms_audit(ssid, tsid, tclass, requested,\n\t\t\t&avd, xpd, xperm, rc, ad);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_xperms_audit",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "requested",
            "&avd",
            "xpd",
            "xperm",
            "rc",
            "ad"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "465-479",
          "snippet": "static inline int avc_xperms_audit(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\tu32 requested, struct av_decision *avd,\n\t\t\t\tstruct extended_perms_decision *xpd,\n\t\t\t\tu8 perm, int result,\n\t\t\t\tstruct common_audit_data *ad)\n{\n\tu32 audited, denied;\n\n\taudited = avc_xperms_audit_required(\n\t\t\trequested, avd, xpd, perm, result, &denied);\n\tif (likely(!audited))\n\t\treturn 0;\n\treturn slow_avc_audit(ssid, tsid, tclass, requested,\n\t\t\taudited, denied, result, ad, 0);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic inline int avc_xperms_audit(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\tu32 requested, struct av_decision *avd,\n\t\t\t\tstruct extended_perms_decision *xpd,\n\t\t\t\tu8 perm, int result,\n\t\t\t\tstruct common_audit_data *ad)\n{\n\tu32 audited, denied;\n\n\taudited = avc_xperms_audit_required(\n\t\t\trequested, avd, xpd, perm, result, &denied);\n\tif (likely(!audited))\n\t\treturn 0;\n\treturn slow_avc_audit(ssid, tsid, tclass, requested,\n\t\t\taudited, denied, result, ad, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_denied",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "requested",
            "driver",
            "xperm",
            "AVC_EXTENDED_PERMS",
            "&avd"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "avc_denied",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "977-991",
          "snippet": "static noinline int avc_denied(u32 ssid, u32 tsid,\n\t\t\t\tu16 tclass, u32 requested,\n\t\t\t\tu8 driver, u8 xperm, unsigned flags,\n\t\t\t\tstruct av_decision *avd)\n{\n\tif (flags & AVC_STRICT)\n\t\treturn -EACCES;\n\n\tif (selinux_enforcing && !(avd->flags & AVD_FLAGS_PERMISSIVE))\n\t\treturn -EACCES;\n\n\tavc_update_node(AVC_CALLBACK_GRANT, requested, driver, xperm, ssid,\n\t\t\t\ttsid, tclass, avd->seqno, NULL, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic noinline int avc_denied(u32 ssid, u32 tsid,\n\t\t\t\tu16 tclass, u32 requested,\n\t\t\t\tu8 driver, u8 xperm, unsigned flags,\n\t\t\t\tstruct av_decision *avd)\n{\n\tif (flags & AVC_STRICT)\n\t\treturn -EACCES;\n\n\tif (selinux_enforcing && !(avd->flags & AVD_FLAGS_PERMISSIVE))\n\t\treturn -EACCES;\n\n\tavc_update_node(AVC_CALLBACK_GRANT, requested, driver, xperm, ssid,\n\t\t\t\ttsid, tclass, avd->seqno, NULL, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "denied"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_xperms_has_perm",
          "args": [
            "xpd",
            "xperm",
            "XPERMS_ALLOWED"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "248-264",
          "snippet": "static inline unsigned int\navc_xperms_has_perm(struct extended_perms_decision *xpd,\n\t\t\t\t\tu8 perm, u8 which)\n{\n\tunsigned int rc = 0;\n\n\tif ((which == XPERMS_ALLOWED) &&\n\t\t\t(xpd->used & XPERMS_ALLOWED))\n\t\trc = security_xperm_test(xpd->allowed->p, perm);\n\telse if ((which == XPERMS_AUDITALLOW) &&\n\t\t\t(xpd->used & XPERMS_AUDITALLOW))\n\t\trc = security_xperm_test(xpd->auditallow->p, perm);\n\telse if ((which == XPERMS_DONTAUDIT) &&\n\t\t\t(xpd->used & XPERMS_DONTAUDIT))\n\t\trc = security_xperm_test(xpd->dontaudit->p, perm);\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int\navc_xperms_has_perm(struct extended_perms_decision *xpd,\n\t\t\t\t\tu8 perm, u8 which)\n{\n\tunsigned int rc = 0;\n\n\tif ((which == XPERMS_ALLOWED) &&\n\t\t\t(xpd->used & XPERMS_ALLOWED))\n\t\trc = security_xperm_test(xpd->allowed->p, perm);\n\telse if ((which == XPERMS_AUDITALLOW) &&\n\t\t\t(xpd->used & XPERMS_AUDITALLOW))\n\t\trc = security_xperm_test(xpd->auditallow->p, perm);\n\telse if ((which == XPERMS_DONTAUDIT) &&\n\t\t\t(xpd->used & XPERMS_DONTAUDIT))\n\t\trc = security_xperm_test(xpd->dontaudit->p, perm);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_quick_copy_xperms_decision",
          "args": [
            "xperm",
            "&local_xpd",
            "xpd"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "avc_quick_copy_xperms_decision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "324-341",
          "snippet": "static inline void avc_quick_copy_xperms_decision(u8 perm,\n\t\t\tstruct extended_perms_decision *dest,\n\t\t\tstruct extended_perms_decision *src)\n{\n\t/*\n\t * compute index of the u32 of the 256 bits (8 u32s) that contain this\n\t * command permission\n\t */\n\tu8 i = perm >> 5;\n\n\tdest->used = src->used;\n\tif (dest->used & XPERMS_ALLOWED)\n\t\tdest->allowed->p[i] = src->allowed->p[i];\n\tif (dest->used & XPERMS_AUDITALLOW)\n\t\tdest->auditallow->p[i] = src->auditallow->p[i];\n\tif (dest->used & XPERMS_DONTAUDIT)\n\t\tdest->dontaudit->p[i] = src->dontaudit->p[i];\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic inline void avc_quick_copy_xperms_decision(u8 perm,\n\t\t\tstruct extended_perms_decision *dest,\n\t\t\tstruct extended_perms_decision *src)\n{\n\t/*\n\t * compute index of the u32 of the 256 bits (8 u32s) that contain this\n\t * command permission\n\t */\n\tu8 i = perm >> 5;\n\n\tdest->used = src->used;\n\tif (dest->used & XPERMS_ALLOWED)\n\t\tdest->allowed->p[i] = src->allowed->p[i];\n\tif (dest->used & XPERMS_AUDITALLOW)\n\t\tdest->auditallow->p[i] = src->auditallow->p[i];\n\tif (dest->used & XPERMS_DONTAUDIT)\n\t\tdest->dontaudit->p[i] = src->dontaudit->p[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_update_node",
          "args": [
            "AVC_CALLBACK_ADD_XPERMS",
            "requested",
            "driver",
            "xperm",
            "ssid",
            "tsid",
            "tclass",
            "avd.seqno",
            "&local_xpd",
            "0"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "avc_update_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "816-902",
          "snippet": "static int avc_update_node(u32 event, u32 perms, u8 driver, u8 xperm, u32 ssid,\n\t\t\tu32 tsid, u16 tclass, u32 seqno,\n\t\t\tstruct extended_perms_decision *xpd,\n\t\t\tu32 flags)\n{\n\tint hvalue, rc = 0;\n\tunsigned long flag;\n\tstruct avc_node *pos, *node, *orig = NULL;\n\tstruct hlist_head *head;\n\tspinlock_t *lock;\n\n\tnode = avc_alloc_node();\n\tif (!node) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Lock the target slot */\n\thvalue = avc_hash(ssid, tsid, tclass);\n\n\thead = &avc_cache.slots[hvalue];\n\tlock = &avc_cache.slots_lock[hvalue];\n\n\tspin_lock_irqsave(lock, flag);\n\n\thlist_for_each_entry(pos, head, list) {\n\t\tif (ssid == pos->ae.ssid &&\n\t\t    tsid == pos->ae.tsid &&\n\t\t    tclass == pos->ae.tclass &&\n\t\t    seqno == pos->ae.avd.seqno){\n\t\t\torig = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!orig) {\n\t\trc = -ENOENT;\n\t\tavc_node_kill(node);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Copy and replace original node.\n\t */\n\n\tavc_node_populate(node, ssid, tsid, tclass, &orig->ae.avd);\n\n\tif (orig->ae.xp_node) {\n\t\trc = avc_xperms_populate(node, orig->ae.xp_node);\n\t\tif (rc) {\n\t\t\tkmem_cache_free(avc_node_cachep, node);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tswitch (event) {\n\tcase AVC_CALLBACK_GRANT:\n\t\tnode->ae.avd.allowed |= perms;\n\t\tif (node->ae.xp_node && (flags & AVC_EXTENDED_PERMS))\n\t\t\tavc_xperms_allow_perm(node->ae.xp_node, driver, xperm);\n\t\tbreak;\n\tcase AVC_CALLBACK_TRY_REVOKE:\n\tcase AVC_CALLBACK_REVOKE:\n\t\tnode->ae.avd.allowed &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_ENABLE:\n\t\tnode->ae.avd.auditallow |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_DISABLE:\n\t\tnode->ae.avd.auditallow &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_ENABLE:\n\t\tnode->ae.avd.auditdeny |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_DISABLE:\n\t\tnode->ae.avd.auditdeny &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_ADD_XPERMS:\n\t\tavc_add_xperms_decision(node, xpd);\n\t\tbreak;\n\t}\n\tavc_node_replace(node, orig);\nout_unlock:\n\tspin_unlock_irqrestore(lock, flag);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_cache avc_cache;",
            "static struct kmem_cache *avc_node_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic struct kmem_cache *avc_node_cachep;\nstatic noinline struct;\n\nstatic int avc_update_node(u32 event, u32 perms, u8 driver, u8 xperm, u32 ssid,\n\t\t\tu32 tsid, u16 tclass, u32 seqno,\n\t\t\tstruct extended_perms_decision *xpd,\n\t\t\tu32 flags)\n{\n\tint hvalue, rc = 0;\n\tunsigned long flag;\n\tstruct avc_node *pos, *node, *orig = NULL;\n\tstruct hlist_head *head;\n\tspinlock_t *lock;\n\n\tnode = avc_alloc_node();\n\tif (!node) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Lock the target slot */\n\thvalue = avc_hash(ssid, tsid, tclass);\n\n\thead = &avc_cache.slots[hvalue];\n\tlock = &avc_cache.slots_lock[hvalue];\n\n\tspin_lock_irqsave(lock, flag);\n\n\thlist_for_each_entry(pos, head, list) {\n\t\tif (ssid == pos->ae.ssid &&\n\t\t    tsid == pos->ae.tsid &&\n\t\t    tclass == pos->ae.tclass &&\n\t\t    seqno == pos->ae.avd.seqno){\n\t\t\torig = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!orig) {\n\t\trc = -ENOENT;\n\t\tavc_node_kill(node);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Copy and replace original node.\n\t */\n\n\tavc_node_populate(node, ssid, tsid, tclass, &orig->ae.avd);\n\n\tif (orig->ae.xp_node) {\n\t\trc = avc_xperms_populate(node, orig->ae.xp_node);\n\t\tif (rc) {\n\t\t\tkmem_cache_free(avc_node_cachep, node);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tswitch (event) {\n\tcase AVC_CALLBACK_GRANT:\n\t\tnode->ae.avd.allowed |= perms;\n\t\tif (node->ae.xp_node && (flags & AVC_EXTENDED_PERMS))\n\t\t\tavc_xperms_allow_perm(node->ae.xp_node, driver, xperm);\n\t\tbreak;\n\tcase AVC_CALLBACK_TRY_REVOKE:\n\tcase AVC_CALLBACK_REVOKE:\n\t\tnode->ae.avd.allowed &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_ENABLE:\n\t\tnode->ae.avd.auditallow |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_DISABLE:\n\t\tnode->ae.avd.auditallow &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_ENABLE:\n\t\tnode->ae.avd.auditdeny |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_DISABLE:\n\t\tnode->ae.avd.auditdeny &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_ADD_XPERMS:\n\t\tavc_add_xperms_decision(node, xpd);\n\t\tbreak;\n\t}\n\tavc_node_replace(node, orig);\nout_unlock:\n\tspin_unlock_irqrestore(lock, flag);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_compute_xperms_decision",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "driver",
            "&local_xpd"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "security_compute_xperms_decision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1000-1078",
          "snippet": "void security_compute_xperms_decision(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu8 driver,\n\t\t\t\tstruct extended_perms_decision *xpermd)\n{\n\tu16 tclass;\n\tstruct context *scontext, *tcontext;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\txpermd->driver = driver;\n\txpermd->used = 0;\n\tmemset(xpermd->allowed->p, 0, sizeof(xpermd->allowed->p));\n\tmemset(xpermd->auditallow->p, 0, sizeof(xpermd->auditallow->p));\n\tmemset(xpermd->dontaudit->p, 0, sizeof(xpermd->dontaudit->p));\n\n\tread_lock(&policy_rwlock);\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\ttclass = unmap_class(orig_tclass);\n\tif (unlikely(orig_tclass && !tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tpr_warn_ratelimited(\"SELinux:  Invalid class %hu\\n\", tclass);\n\t\tgoto out;\n\t}\n\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_XPERMS;\n\tsattr = flex_array_get(policydb.type_attr_map_array,\n\t\t\t\tscontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array,\n\t\t\t\ttcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified))\n\t\t\t\tservices_compute_xperms_decision(xpermd, node);\n\n\t\t\tcond_compute_xperms(&policydb.te_cond_avtab,\n\t\t\t\t\t\t&avkey, xpermd);\n\t\t}\n\t}\nout:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tmemset(xpermd->allowed->p, 0xff, sizeof(xpermd->allowed->p));\n\tgoto out;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;",
            "static int security_preserve_bools(struct policydb *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\nstatic int security_preserve_bools(struct policydb *p);\n\nvoid security_compute_xperms_decision(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu8 driver,\n\t\t\t\tstruct extended_perms_decision *xpermd)\n{\n\tu16 tclass;\n\tstruct context *scontext, *tcontext;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\txpermd->driver = driver;\n\txpermd->used = 0;\n\tmemset(xpermd->allowed->p, 0, sizeof(xpermd->allowed->p));\n\tmemset(xpermd->auditallow->p, 0, sizeof(xpermd->auditallow->p));\n\tmemset(xpermd->dontaudit->p, 0, sizeof(xpermd->dontaudit->p));\n\n\tread_lock(&policy_rwlock);\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\ttclass = unmap_class(orig_tclass);\n\tif (unlikely(orig_tclass && !tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tpr_warn_ratelimited(\"SELinux:  Invalid class %hu\\n\", tclass);\n\t\tgoto out;\n\t}\n\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_XPERMS;\n\tsattr = flex_array_get(policydb.type_attr_map_array,\n\t\t\t\tscontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array,\n\t\t\t\ttcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified))\n\t\t\t\tservices_compute_xperms_decision(xpermd, node);\n\n\t\t\tcond_compute_xperms(&policydb.te_cond_avtab,\n\t\t\t\t\t\t&avkey, xpermd);\n\t\t}\n\t}\nout:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tmemset(xpermd->allowed->p, 0xff, sizeof(xpermd->allowed->p));\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_xperm_test",
          "args": [
            "xp_node->xp.drivers.p",
            "driver"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!xpd"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_xperms_decision_lookup",
          "args": [
            "driver",
            "xp_node"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_decision_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "236-246",
          "snippet": "static struct extended_perms_decision *avc_xperms_decision_lookup(u8 driver,\n\t\t\t\t\tstruct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\n\tlist_for_each_entry(xpd_node, &xp_node->xpd_head, xpd_list) {\n\t\tif (xpd_node->xpd.driver == driver)\n\t\t\treturn &xpd_node->xpd;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic struct extended_perms_decision *avc_xperms_decision_lookup(u8 driver,\n\t\t\t\t\tstruct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\n\tlist_for_each_entry(xpd_node, &xp_node->xpd_head, xpd_list) {\n\t\tif (xpd_node->xpd.driver == driver)\n\t\t\treturn &xpd_node->xpd;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&avd",
            "&node->ae.avd",
            "sizeof(avd)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_compute_av",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "&avd",
            "xp_node"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "avc_compute_av",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "966-975",
          "snippet": "avc_node *avc_compute_av(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, struct av_decision *avd,\n\t\t\t struct avc_xperms_node *xp_node)\n{\n\trcu_read_unlock();\n\tINIT_LIST_HEAD(&xp_node->xpd_head);\n\tsecurity_compute_av(ssid, tsid, tclass, avd, &xp_node->xp);\n\trcu_read_lock();\n\treturn avc_insert(ssid, tsid, tclass, avd, xp_node);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\navc_node *avc_compute_av(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, struct av_decision *avd,\n\t\t\t struct avc_xperms_node *xp_node)\n{\n\trcu_read_unlock();\n\tINIT_LIST_HEAD(&xp_node->xpd_head);\n\tsecurity_compute_av(ssid, tsid, tclass, avd, &xp_node->xp);\n\trcu_read_lock();\n\treturn avc_insert(ssid, tsid, tclass, avd, xp_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!node"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_lookup",
          "args": [
            "ssid",
            "tsid",
            "tclass"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "avc_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "603-615",
          "snippet": "static struct avc_node *avc_lookup(u32 ssid, u32 tsid, u16 tclass)\n{\n\tstruct avc_node *node;\n\n\tavc_cache_stats_incr(lookups);\n\tnode = avc_search_node(ssid, tsid, tclass);\n\n\tif (node)\n\t\treturn node;\n\n\tavc_cache_stats_incr(misses);\n\treturn NULL;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic struct avc_node *avc_lookup(u32 ssid, u32 tsid, u16 tclass)\n{\n\tstruct avc_node *node;\n\n\tavc_cache_stats_incr(lookups);\n\tnode = avc_search_node(ssid, tsid, tclass);\n\n\tif (node)\n\t\treturn node;\n\n\tavc_cache_stats_incr(misses);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!requested"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_extended_perms(u32 ssid, u32 tsid, u16 tclass, u32 requested,\n\t\t\tu8 driver, u8 xperm, struct common_audit_data *ad)\n{\n\tstruct avc_node *node;\n\tstruct av_decision avd;\n\tu32 denied;\n\tstruct extended_perms_decision local_xpd;\n\tstruct extended_perms_decision *xpd = NULL;\n\tstruct extended_perms_data allowed;\n\tstruct extended_perms_data auditallow;\n\tstruct extended_perms_data dontaudit;\n\tstruct avc_xperms_node local_xp_node;\n\tstruct avc_xperms_node *xp_node;\n\tint rc = 0, rc2;\n\n\txp_node = &local_xp_node;\n\tBUG_ON(!requested);\n\n\trcu_read_lock();\n\n\tnode = avc_lookup(ssid, tsid, tclass);\n\tif (unlikely(!node)) {\n\t\tnode = avc_compute_av(ssid, tsid, tclass, &avd, xp_node);\n\t} else {\n\t\tmemcpy(&avd, &node->ae.avd, sizeof(avd));\n\t\txp_node = node->ae.xp_node;\n\t}\n\t/* if extended permissions are not defined, only consider av_decision */\n\tif (!xp_node || !xp_node->xp.len)\n\t\tgoto decision;\n\n\tlocal_xpd.allowed = &allowed;\n\tlocal_xpd.auditallow = &auditallow;\n\tlocal_xpd.dontaudit = &dontaudit;\n\n\txpd = avc_xperms_decision_lookup(driver, xp_node);\n\tif (unlikely(!xpd)) {\n\t\t/*\n\t\t * Compute the extended_perms_decision only if the driver\n\t\t * is flagged\n\t\t */\n\t\tif (!security_xperm_test(xp_node->xp.drivers.p, driver)) {\n\t\t\tavd.allowed &= ~requested;\n\t\t\tgoto decision;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsecurity_compute_xperms_decision(ssid, tsid, tclass, driver,\n\t\t\t\t\t\t&local_xpd);\n\t\trcu_read_lock();\n\t\tavc_update_node(AVC_CALLBACK_ADD_XPERMS, requested, driver, xperm,\n\t\t\t\tssid, tsid, tclass, avd.seqno, &local_xpd, 0);\n\t} else {\n\t\tavc_quick_copy_xperms_decision(xperm, &local_xpd, xpd);\n\t}\n\txpd = &local_xpd;\n\n\tif (!avc_xperms_has_perm(xpd, xperm, XPERMS_ALLOWED))\n\t\tavd.allowed &= ~requested;\n\ndecision:\n\tdenied = requested & ~(avd.allowed);\n\tif (unlikely(denied))\n\t\trc = avc_denied(ssid, tsid, tclass, requested, driver, xperm,\n\t\t\t\tAVC_EXTENDED_PERMS, &avd);\n\n\trcu_read_unlock();\n\n\trc2 = avc_xperms_audit(ssid, tsid, tclass, requested,\n\t\t\t&avd, xpd, xperm, rc, ad);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
  },
  {
    "function_name": "avc_denied",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "977-991",
    "snippet": "static noinline int avc_denied(u32 ssid, u32 tsid,\n\t\t\t\tu16 tclass, u32 requested,\n\t\t\t\tu8 driver, u8 xperm, unsigned flags,\n\t\t\t\tstruct av_decision *avd)\n{\n\tif (flags & AVC_STRICT)\n\t\treturn -EACCES;\n\n\tif (selinux_enforcing && !(avd->flags & AVD_FLAGS_PERMISSIVE))\n\t\treturn -EACCES;\n\n\tavc_update_node(AVC_CALLBACK_GRANT, requested, driver, xperm, ssid,\n\t\t\t\ttsid, tclass, avd->seqno, NULL, flags);\n\treturn 0;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_update_node",
          "args": [
            "AVC_CALLBACK_GRANT",
            "requested",
            "driver",
            "xperm",
            "ssid",
            "tsid",
            "tclass",
            "avd->seqno",
            "NULL",
            "flags"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "avc_update_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "816-902",
          "snippet": "static int avc_update_node(u32 event, u32 perms, u8 driver, u8 xperm, u32 ssid,\n\t\t\tu32 tsid, u16 tclass, u32 seqno,\n\t\t\tstruct extended_perms_decision *xpd,\n\t\t\tu32 flags)\n{\n\tint hvalue, rc = 0;\n\tunsigned long flag;\n\tstruct avc_node *pos, *node, *orig = NULL;\n\tstruct hlist_head *head;\n\tspinlock_t *lock;\n\n\tnode = avc_alloc_node();\n\tif (!node) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Lock the target slot */\n\thvalue = avc_hash(ssid, tsid, tclass);\n\n\thead = &avc_cache.slots[hvalue];\n\tlock = &avc_cache.slots_lock[hvalue];\n\n\tspin_lock_irqsave(lock, flag);\n\n\thlist_for_each_entry(pos, head, list) {\n\t\tif (ssid == pos->ae.ssid &&\n\t\t    tsid == pos->ae.tsid &&\n\t\t    tclass == pos->ae.tclass &&\n\t\t    seqno == pos->ae.avd.seqno){\n\t\t\torig = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!orig) {\n\t\trc = -ENOENT;\n\t\tavc_node_kill(node);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Copy and replace original node.\n\t */\n\n\tavc_node_populate(node, ssid, tsid, tclass, &orig->ae.avd);\n\n\tif (orig->ae.xp_node) {\n\t\trc = avc_xperms_populate(node, orig->ae.xp_node);\n\t\tif (rc) {\n\t\t\tkmem_cache_free(avc_node_cachep, node);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tswitch (event) {\n\tcase AVC_CALLBACK_GRANT:\n\t\tnode->ae.avd.allowed |= perms;\n\t\tif (node->ae.xp_node && (flags & AVC_EXTENDED_PERMS))\n\t\t\tavc_xperms_allow_perm(node->ae.xp_node, driver, xperm);\n\t\tbreak;\n\tcase AVC_CALLBACK_TRY_REVOKE:\n\tcase AVC_CALLBACK_REVOKE:\n\t\tnode->ae.avd.allowed &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_ENABLE:\n\t\tnode->ae.avd.auditallow |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_DISABLE:\n\t\tnode->ae.avd.auditallow &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_ENABLE:\n\t\tnode->ae.avd.auditdeny |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_DISABLE:\n\t\tnode->ae.avd.auditdeny &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_ADD_XPERMS:\n\t\tavc_add_xperms_decision(node, xpd);\n\t\tbreak;\n\t}\n\tavc_node_replace(node, orig);\nout_unlock:\n\tspin_unlock_irqrestore(lock, flag);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_cache avc_cache;",
            "static struct kmem_cache *avc_node_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic struct kmem_cache *avc_node_cachep;\nstatic noinline struct;\n\nstatic int avc_update_node(u32 event, u32 perms, u8 driver, u8 xperm, u32 ssid,\n\t\t\tu32 tsid, u16 tclass, u32 seqno,\n\t\t\tstruct extended_perms_decision *xpd,\n\t\t\tu32 flags)\n{\n\tint hvalue, rc = 0;\n\tunsigned long flag;\n\tstruct avc_node *pos, *node, *orig = NULL;\n\tstruct hlist_head *head;\n\tspinlock_t *lock;\n\n\tnode = avc_alloc_node();\n\tif (!node) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Lock the target slot */\n\thvalue = avc_hash(ssid, tsid, tclass);\n\n\thead = &avc_cache.slots[hvalue];\n\tlock = &avc_cache.slots_lock[hvalue];\n\n\tspin_lock_irqsave(lock, flag);\n\n\thlist_for_each_entry(pos, head, list) {\n\t\tif (ssid == pos->ae.ssid &&\n\t\t    tsid == pos->ae.tsid &&\n\t\t    tclass == pos->ae.tclass &&\n\t\t    seqno == pos->ae.avd.seqno){\n\t\t\torig = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!orig) {\n\t\trc = -ENOENT;\n\t\tavc_node_kill(node);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Copy and replace original node.\n\t */\n\n\tavc_node_populate(node, ssid, tsid, tclass, &orig->ae.avd);\n\n\tif (orig->ae.xp_node) {\n\t\trc = avc_xperms_populate(node, orig->ae.xp_node);\n\t\tif (rc) {\n\t\t\tkmem_cache_free(avc_node_cachep, node);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tswitch (event) {\n\tcase AVC_CALLBACK_GRANT:\n\t\tnode->ae.avd.allowed |= perms;\n\t\tif (node->ae.xp_node && (flags & AVC_EXTENDED_PERMS))\n\t\t\tavc_xperms_allow_perm(node->ae.xp_node, driver, xperm);\n\t\tbreak;\n\tcase AVC_CALLBACK_TRY_REVOKE:\n\tcase AVC_CALLBACK_REVOKE:\n\t\tnode->ae.avd.allowed &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_ENABLE:\n\t\tnode->ae.avd.auditallow |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_DISABLE:\n\t\tnode->ae.avd.auditallow &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_ENABLE:\n\t\tnode->ae.avd.auditdeny |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_DISABLE:\n\t\tnode->ae.avd.auditdeny &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_ADD_XPERMS:\n\t\tavc_add_xperms_decision(node, xpd);\n\t\tbreak;\n\t}\n\tavc_node_replace(node, orig);\nout_unlock:\n\tspin_unlock_irqrestore(lock, flag);\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic noinline int avc_denied(u32 ssid, u32 tsid,\n\t\t\t\tu16 tclass, u32 requested,\n\t\t\t\tu8 driver, u8 xperm, unsigned flags,\n\t\t\t\tstruct av_decision *avd)\n{\n\tif (flags & AVC_STRICT)\n\t\treturn -EACCES;\n\n\tif (selinux_enforcing && !(avd->flags & AVD_FLAGS_PERMISSIVE))\n\t\treturn -EACCES;\n\n\tavc_update_node(AVC_CALLBACK_GRANT, requested, driver, xperm, ssid,\n\t\t\t\ttsid, tclass, avd->seqno, NULL, flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "avc_compute_av",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "966-975",
    "snippet": "avc_node *avc_compute_av(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, struct av_decision *avd,\n\t\t\t struct avc_xperms_node *xp_node)\n{\n\trcu_read_unlock();\n\tINIT_LIST_HEAD(&xp_node->xpd_head);\n\tsecurity_compute_av(ssid, tsid, tclass, avd, &xp_node->xp);\n\trcu_read_lock();\n\treturn avc_insert(ssid, tsid, tclass, avd, xp_node);\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_insert",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "avd",
            "xp_node"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "avc_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "657-699",
          "snippet": "static struct avc_node *avc_insert(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\tstruct av_decision *avd,\n\t\t\t\tstruct avc_xperms_node *xp_node)\n{\n\tstruct avc_node *pos, *node = NULL;\n\tint hvalue;\n\tunsigned long flag;\n\n\tif (avc_latest_notif_update(avd->seqno, 1))\n\t\tgoto out;\n\n\tnode = avc_alloc_node();\n\tif (node) {\n\t\tstruct hlist_head *head;\n\t\tspinlock_t *lock;\n\t\tint rc = 0;\n\n\t\thvalue = avc_hash(ssid, tsid, tclass);\n\t\tavc_node_populate(node, ssid, tsid, tclass, avd);\n\t\trc = avc_xperms_populate(node, xp_node);\n\t\tif (rc) {\n\t\t\tkmem_cache_free(avc_node_cachep, node);\n\t\t\treturn NULL;\n\t\t}\n\t\thead = &avc_cache.slots[hvalue];\n\t\tlock = &avc_cache.slots_lock[hvalue];\n\n\t\tspin_lock_irqsave(lock, flag);\n\t\thlist_for_each_entry(pos, head, list) {\n\t\t\tif (pos->ae.ssid == ssid &&\n\t\t\t    pos->ae.tsid == tsid &&\n\t\t\t    pos->ae.tclass == tclass) {\n\t\t\t\tavc_node_replace(node, pos);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\thlist_add_head_rcu(&node->list, head);\nfound:\n\t\tspin_unlock_irqrestore(lock, flag);\n\t}\nout:\n\treturn node;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_cache avc_cache;",
            "static struct kmem_cache *avc_node_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic struct kmem_cache *avc_node_cachep;\nstatic noinline struct;\n\nstatic struct avc_node *avc_insert(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\tstruct av_decision *avd,\n\t\t\t\tstruct avc_xperms_node *xp_node)\n{\n\tstruct avc_node *pos, *node = NULL;\n\tint hvalue;\n\tunsigned long flag;\n\n\tif (avc_latest_notif_update(avd->seqno, 1))\n\t\tgoto out;\n\n\tnode = avc_alloc_node();\n\tif (node) {\n\t\tstruct hlist_head *head;\n\t\tspinlock_t *lock;\n\t\tint rc = 0;\n\n\t\thvalue = avc_hash(ssid, tsid, tclass);\n\t\tavc_node_populate(node, ssid, tsid, tclass, avd);\n\t\trc = avc_xperms_populate(node, xp_node);\n\t\tif (rc) {\n\t\t\tkmem_cache_free(avc_node_cachep, node);\n\t\t\treturn NULL;\n\t\t}\n\t\thead = &avc_cache.slots[hvalue];\n\t\tlock = &avc_cache.slots_lock[hvalue];\n\n\t\tspin_lock_irqsave(lock, flag);\n\t\thlist_for_each_entry(pos, head, list) {\n\t\t\tif (pos->ae.ssid == ssid &&\n\t\t\t    pos->ae.tsid == tsid &&\n\t\t\t    pos->ae.tclass == tclass) {\n\t\t\t\tavc_node_replace(node, pos);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\thlist_add_head_rcu(&node->list, head);\nfound:\n\t\tspin_unlock_irqrestore(lock, flag);\n\t}\nout:\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_compute_av",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "avd",
            "&xp_node->xp"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "security_compute_av",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1091-1138",
          "snippet": "void security_compute_av(u32 ssid,\n\t\t\t u32 tsid,\n\t\t\t u16 orig_tclass,\n\t\t\t struct av_decision *avd,\n\t\t\t struct extended_perms *xperms)\n{\n\tu16 tclass;\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\tread_lock(&policy_rwlock);\n\tavd_init(avd);\n\txperms->len = 0;\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t/* permissive domain? */\n\tif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\ttclass = unmap_class(orig_tclass);\n\tif (unlikely(orig_tclass && !tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\tcontext_struct_compute_av(scontext, tcontext, tclass, avd, xperms);\n\tmap_decision(orig_tclass, avd, policydb.allow_unknown);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;",
            "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);\n\nvoid security_compute_av(u32 ssid,\n\t\t\t u32 tsid,\n\t\t\t u16 orig_tclass,\n\t\t\t struct av_decision *avd,\n\t\t\t struct extended_perms *xperms)\n{\n\tu16 tclass;\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\tread_lock(&policy_rwlock);\n\tavd_init(avd);\n\txperms->len = 0;\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t/* permissive domain? */\n\tif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\ttclass = unmap_class(orig_tclass);\n\tif (unlikely(orig_tclass && !tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\tcontext_struct_compute_av(scontext, tcontext, tclass, avd, xperms);\n\tmap_decision(orig_tclass, avd, policydb.allow_unknown);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&xp_node->xpd_head"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\navc_node *avc_compute_av(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, struct av_decision *avd,\n\t\t\t struct avc_xperms_node *xp_node)\n{\n\trcu_read_unlock();\n\tINIT_LIST_HEAD(&xp_node->xpd_head);\n\tsecurity_compute_av(ssid, tsid, tclass, avd, &xp_node->xp);\n\trcu_read_lock();\n\treturn avc_insert(ssid, tsid, tclass, avd, xp_node);\n}"
  },
  {
    "function_name": "avc_ss_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "936-955",
    "snippet": "int avc_ss_reset(u32 seqno)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0, tmprc;\n\n\tavc_flush();\n\n\tfor (c = avc_callbacks; c; c = c->next) {\n\t\tif (c->events & AVC_CALLBACK_RESET) {\n\t\t\ttmprc = c->callback(AVC_CALLBACK_RESET);\n\t\t\t/* save the first error encountered for the return\n\t\t\t   value and continue processing the callbacks */\n\t\t\tif (!rc)\n\t\t\t\trc = tmprc;\n\t\t}\n\t}\n\n\tavc_latest_notif_update(seqno, 0);\n\treturn rc;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct avc_callback_node *avc_callbacks;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_latest_notif_update",
          "args": [
            "seqno",
            "0"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "avc_latest_notif_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "617-637",
          "snippet": "static int avc_latest_notif_update(int seqno, int is_insert)\n{\n\tint ret = 0;\n\tstatic DEFINE_SPINLOCK(notif_lock);\n\tunsigned long flag;\n\n\tspin_lock_irqsave(&notif_lock, flag);\n\tif (is_insert) {\n\t\tif (seqno < avc_cache.latest_notif) {\n\t\t\tprintk(KERN_WARNING \"SELinux: avc:  seqno %d < latest_notif %d\\n\",\n\t\t\t       seqno, avc_cache.latest_notif);\n\t\t\tret = -EAGAIN;\n\t\t}\n\t} else {\n\t\tif (seqno > avc_cache.latest_notif)\n\t\t\tavc_cache.latest_notif = seqno;\n\t}\n\tspin_unlock_irqrestore(&notif_lock, flag);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_cache avc_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\n\nstatic int avc_latest_notif_update(int seqno, int is_insert)\n{\n\tint ret = 0;\n\tstatic DEFINE_SPINLOCK(notif_lock);\n\tunsigned long flag;\n\n\tspin_lock_irqsave(&notif_lock, flag);\n\tif (is_insert) {\n\t\tif (seqno < avc_cache.latest_notif) {\n\t\t\tprintk(KERN_WARNING \"SELinux: avc:  seqno %d < latest_notif %d\\n\",\n\t\t\t       seqno, avc_cache.latest_notif);\n\t\t\tret = -EAGAIN;\n\t\t}\n\t} else {\n\t\tif (seqno > avc_cache.latest_notif)\n\t\t\tavc_cache.latest_notif = seqno;\n\t}\n\tspin_unlock_irqrestore(&notif_lock, flag);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->callback",
          "args": [
            "AVC_CALLBACK_RESET"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_flush",
          "args": [],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "avc_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "907-930",
          "snippet": "static void avc_flush(void)\n{\n\tstruct hlist_head *head;\n\tstruct avc_node *node;\n\tspinlock_t *lock;\n\tunsigned long flag;\n\tint i;\n\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\thead = &avc_cache.slots[i];\n\t\tlock = &avc_cache.slots_lock[i];\n\n\t\tspin_lock_irqsave(lock, flag);\n\t\t/*\n\t\t * With preemptable RCU, the outer spinlock does not\n\t\t * prevent RCU grace periods from ending.\n\t\t */\n\t\trcu_read_lock();\n\t\thlist_for_each_entry(node, head, list)\n\t\t\tavc_node_delete(node);\n\t\trcu_read_unlock();\n\t\tspin_unlock_irqrestore(lock, flag);\n\t}\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define AVC_CACHE_SLOTS\t\t\t512"
          ],
          "globals_used": [
            "static struct avc_cache avc_cache;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#define AVC_CACHE_SLOTS\t\t\t512\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nstatic void avc_flush(void)\n{\n\tstruct hlist_head *head;\n\tstruct avc_node *node;\n\tspinlock_t *lock;\n\tunsigned long flag;\n\tint i;\n\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\thead = &avc_cache.slots[i];\n\t\tlock = &avc_cache.slots_lock[i];\n\n\t\tspin_lock_irqsave(lock, flag);\n\t\t/*\n\t\t * With preemptable RCU, the outer spinlock does not\n\t\t * prevent RCU grace periods from ending.\n\t\t */\n\t\trcu_read_lock();\n\t\thlist_for_each_entry(node, head, list)\n\t\t\tavc_node_delete(node);\n\t\trcu_read_unlock();\n\t\tspin_unlock_irqrestore(lock, flag);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_callback_node *avc_callbacks;\nstatic noinline struct;\n\nint avc_ss_reset(u32 seqno)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0, tmprc;\n\n\tavc_flush();\n\n\tfor (c = avc_callbacks; c; c = c->next) {\n\t\tif (c->events & AVC_CALLBACK_RESET) {\n\t\t\ttmprc = c->callback(AVC_CALLBACK_RESET);\n\t\t\t/* save the first error encountered for the return\n\t\t\t   value and continue processing the callbacks */\n\t\t\tif (!rc)\n\t\t\t\trc = tmprc;\n\t\t}\n\t}\n\n\tavc_latest_notif_update(seqno, 0);\n\treturn rc;\n}"
  },
  {
    "function_name": "avc_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "907-930",
    "snippet": "static void avc_flush(void)\n{\n\tstruct hlist_head *head;\n\tstruct avc_node *node;\n\tspinlock_t *lock;\n\tunsigned long flag;\n\tint i;\n\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\thead = &avc_cache.slots[i];\n\t\tlock = &avc_cache.slots_lock[i];\n\n\t\tspin_lock_irqsave(lock, flag);\n\t\t/*\n\t\t * With preemptable RCU, the outer spinlock does not\n\t\t * prevent RCU grace periods from ending.\n\t\t */\n\t\trcu_read_lock();\n\t\thlist_for_each_entry(node, head, list)\n\t\t\tavc_node_delete(node);\n\t\trcu_read_unlock();\n\t\tspin_unlock_irqrestore(lock, flag);\n\t}\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define AVC_CACHE_SLOTS\t\t\t512"
    ],
    "globals_used": [
      "static struct avc_cache avc_cache;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "lock",
            "flag"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_node_delete",
          "args": [
            "node"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "avc_node_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "489-494",
          "snippet": "static void avc_node_delete(struct avc_node *node)\n{\n\thlist_del_rcu(&node->list);\n\tcall_rcu(&node->rhead, avc_node_free);\n\tatomic_dec(&avc_cache.active_nodes);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_cache avc_cache;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nstatic void avc_node_delete(struct avc_node *node)\n{\n\thlist_del_rcu(&node->list);\n\tcall_rcu(&node->rhead, avc_node_free);\n\tatomic_dec(&avc_cache.active_nodes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "node",
            "head",
            "list"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "lock",
            "flag"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#define AVC_CACHE_SLOTS\t\t\t512\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nstatic void avc_flush(void)\n{\n\tstruct hlist_head *head;\n\tstruct avc_node *node;\n\tspinlock_t *lock;\n\tunsigned long flag;\n\tint i;\n\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\thead = &avc_cache.slots[i];\n\t\tlock = &avc_cache.slots_lock[i];\n\n\t\tspin_lock_irqsave(lock, flag);\n\t\t/*\n\t\t * With preemptable RCU, the outer spinlock does not\n\t\t * prevent RCU grace periods from ending.\n\t\t */\n\t\trcu_read_lock();\n\t\thlist_for_each_entry(node, head, list)\n\t\t\tavc_node_delete(node);\n\t\trcu_read_unlock();\n\t\tspin_unlock_irqrestore(lock, flag);\n\t}\n}"
  },
  {
    "function_name": "avc_update_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "816-902",
    "snippet": "static int avc_update_node(u32 event, u32 perms, u8 driver, u8 xperm, u32 ssid,\n\t\t\tu32 tsid, u16 tclass, u32 seqno,\n\t\t\tstruct extended_perms_decision *xpd,\n\t\t\tu32 flags)\n{\n\tint hvalue, rc = 0;\n\tunsigned long flag;\n\tstruct avc_node *pos, *node, *orig = NULL;\n\tstruct hlist_head *head;\n\tspinlock_t *lock;\n\n\tnode = avc_alloc_node();\n\tif (!node) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Lock the target slot */\n\thvalue = avc_hash(ssid, tsid, tclass);\n\n\thead = &avc_cache.slots[hvalue];\n\tlock = &avc_cache.slots_lock[hvalue];\n\n\tspin_lock_irqsave(lock, flag);\n\n\thlist_for_each_entry(pos, head, list) {\n\t\tif (ssid == pos->ae.ssid &&\n\t\t    tsid == pos->ae.tsid &&\n\t\t    tclass == pos->ae.tclass &&\n\t\t    seqno == pos->ae.avd.seqno){\n\t\t\torig = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!orig) {\n\t\trc = -ENOENT;\n\t\tavc_node_kill(node);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Copy and replace original node.\n\t */\n\n\tavc_node_populate(node, ssid, tsid, tclass, &orig->ae.avd);\n\n\tif (orig->ae.xp_node) {\n\t\trc = avc_xperms_populate(node, orig->ae.xp_node);\n\t\tif (rc) {\n\t\t\tkmem_cache_free(avc_node_cachep, node);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tswitch (event) {\n\tcase AVC_CALLBACK_GRANT:\n\t\tnode->ae.avd.allowed |= perms;\n\t\tif (node->ae.xp_node && (flags & AVC_EXTENDED_PERMS))\n\t\t\tavc_xperms_allow_perm(node->ae.xp_node, driver, xperm);\n\t\tbreak;\n\tcase AVC_CALLBACK_TRY_REVOKE:\n\tcase AVC_CALLBACK_REVOKE:\n\t\tnode->ae.avd.allowed &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_ENABLE:\n\t\tnode->ae.avd.auditallow |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_DISABLE:\n\t\tnode->ae.avd.auditallow &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_ENABLE:\n\t\tnode->ae.avd.auditdeny |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_DISABLE:\n\t\tnode->ae.avd.auditdeny &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_ADD_XPERMS:\n\t\tavc_add_xperms_decision(node, xpd);\n\t\tbreak;\n\t}\n\tavc_node_replace(node, orig);\nout_unlock:\n\tspin_unlock_irqrestore(lock, flag);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct avc_cache avc_cache;",
      "static struct kmem_cache *avc_node_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "lock",
            "flag"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_node_replace",
          "args": [
            "node",
            "orig"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "avc_node_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "504-509",
          "snippet": "static void avc_node_replace(struct avc_node *new, struct avc_node *old)\n{\n\thlist_replace_rcu(&old->list, &new->list);\n\tcall_rcu(&old->rhead, avc_node_free);\n\tatomic_dec(&avc_cache.active_nodes);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_cache avc_cache;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nstatic void avc_node_replace(struct avc_node *new, struct avc_node *old)\n{\n\thlist_replace_rcu(&old->list, &new->list);\n\tcall_rcu(&old->rhead, avc_node_free);\n\tatomic_dec(&avc_cache.active_nodes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_add_xperms_decision",
          "args": [
            "node",
            "xpd"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "avc_add_xperms_decision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "378-390",
          "snippet": "static int avc_add_xperms_decision(struct avc_node *node,\n\t\t\tstruct extended_perms_decision *src)\n{\n\tstruct avc_xperms_decision_node *dest_xpd;\n\n\tnode->ae.xp_node->xp.len++;\n\tdest_xpd = avc_xperms_decision_alloc(src->used);\n\tif (!dest_xpd)\n\t\treturn -ENOMEM;\n\tavc_copy_xperms_decision(&dest_xpd->xpd, src);\n\tlist_add(&dest_xpd->xpd_list, &node->ae.xp_node->xpd_head);\n\treturn 0;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic int avc_add_xperms_decision(struct avc_node *node,\n\t\t\tstruct extended_perms_decision *src)\n{\n\tstruct avc_xperms_decision_node *dest_xpd;\n\n\tnode->ae.xp_node->xp.len++;\n\tdest_xpd = avc_xperms_decision_alloc(src->used);\n\tif (!dest_xpd)\n\t\treturn -ENOMEM;\n\tavc_copy_xperms_decision(&dest_xpd->xpd, src);\n\tlist_add(&dest_xpd->xpd_list, &node->ae.xp_node->xpd_head);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_xperms_allow_perm",
          "args": [
            "node->ae.xp_node",
            "driver",
            "xperm"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_allow_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "266-274",
          "snippet": "static void avc_xperms_allow_perm(struct avc_xperms_node *xp_node,\n\t\t\t\tu8 driver, u8 perm)\n{\n\tstruct extended_perms_decision *xpd;\n\tsecurity_xperm_set(xp_node->xp.drivers.p, driver);\n\txpd = avc_xperms_decision_lookup(driver, xp_node);\n\tif (xpd && xpd->allowed)\n\t\tsecurity_xperm_set(xpd->allowed->p, perm);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_xperms_allow_perm(struct avc_xperms_node *xp_node,\n\t\t\t\tu8 driver, u8 perm)\n{\n\tstruct extended_perms_decision *xpd;\n\tsecurity_xperm_set(xp_node->xp.drivers.p, driver);\n\txpd = avc_xperms_decision_lookup(driver, xp_node);\n\tif (xpd && xpd->allowed)\n\t\tsecurity_xperm_set(xpd->allowed->p, perm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "avc_node_cachep",
            "node"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_xperms_populate",
          "args": [
            "node",
            "orig->ae.xp_node"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "403-433",
          "snippet": "static int avc_xperms_populate(struct avc_node *node,\n\t\t\t\tstruct avc_xperms_node *src)\n{\n\tstruct avc_xperms_node *dest;\n\tstruct avc_xperms_decision_node *dest_xpd;\n\tstruct avc_xperms_decision_node *src_xpd;\n\n\tif (src->xp.len == 0)\n\t\treturn 0;\n\tdest = avc_xperms_alloc();\n\tif (!dest)\n\t\treturn -ENOMEM;\n\n\tmemcpy(dest->xp.drivers.p, src->xp.drivers.p, sizeof(dest->xp.drivers.p));\n\tdest->xp.len = src->xp.len;\n\n\t/* for each source xpd allocate a destination xpd and copy */\n\tlist_for_each_entry(src_xpd, &src->xpd_head, xpd_list) {\n\t\tdest_xpd = avc_xperms_decision_alloc(src_xpd->xpd.used);\n\t\tif (!dest_xpd)\n\t\t\tgoto error;\n\t\tavc_copy_xperms_decision(&dest_xpd->xpd, &src_xpd->xpd);\n\t\tlist_add(&dest_xpd->xpd_list, &dest->xpd_head);\n\t}\n\tnode->ae.xp_node = dest;\n\treturn 0;\nerror:\n\tavc_xperms_free(dest);\n\treturn -ENOMEM;\n\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic int avc_xperms_populate(struct avc_node *node,\n\t\t\t\tstruct avc_xperms_node *src)\n{\n\tstruct avc_xperms_node *dest;\n\tstruct avc_xperms_decision_node *dest_xpd;\n\tstruct avc_xperms_decision_node *src_xpd;\n\n\tif (src->xp.len == 0)\n\t\treturn 0;\n\tdest = avc_xperms_alloc();\n\tif (!dest)\n\t\treturn -ENOMEM;\n\n\tmemcpy(dest->xp.drivers.p, src->xp.drivers.p, sizeof(dest->xp.drivers.p));\n\tdest->xp.len = src->xp.len;\n\n\t/* for each source xpd allocate a destination xpd and copy */\n\tlist_for_each_entry(src_xpd, &src->xpd_head, xpd_list) {\n\t\tdest_xpd = avc_xperms_decision_alloc(src_xpd->xpd.used);\n\t\tif (!dest_xpd)\n\t\t\tgoto error;\n\t\tavc_copy_xperms_decision(&dest_xpd->xpd, &src_xpd->xpd);\n\t\tlist_add(&dest_xpd->xpd_list, &dest->xpd_head);\n\t}\n\tnode->ae.xp_node = dest;\n\treturn 0;\nerror:\n\tavc_xperms_free(dest);\n\treturn -ENOMEM;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_node_populate",
          "args": [
            "node",
            "ssid",
            "tsid",
            "tclass",
            "&orig->ae.avd"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "avc_node_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "563-569",
          "snippet": "static void avc_node_populate(struct avc_node *node, u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd)\n{\n\tnode->ae.ssid = ssid;\n\tnode->ae.tsid = tsid;\n\tnode->ae.tclass = tclass;\n\tmemcpy(&node->ae.avd, avd, sizeof(node->ae.avd));\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_node_populate(struct avc_node *node, u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd)\n{\n\tnode->ae.ssid = ssid;\n\tnode->ae.tsid = tsid;\n\tnode->ae.tclass = tclass;\n\tmemcpy(&node->ae.avd, avd, sizeof(node->ae.avd));\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_node_kill",
          "args": [
            "node"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "avc_node_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "496-502",
          "snippet": "static void avc_node_kill(struct avc_node *node)\n{\n\tavc_xperms_free(node->ae.xp_node);\n\tkmem_cache_free(avc_node_cachep, node);\n\tavc_cache_stats_incr(frees);\n\tatomic_dec(&avc_cache.active_nodes);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_cache avc_cache;",
            "static struct kmem_cache *avc_node_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic struct kmem_cache *avc_node_cachep;\nstatic noinline struct;\n\nstatic void avc_node_kill(struct avc_node *node)\n{\n\tavc_xperms_free(node->ae.xp_node);\n\tkmem_cache_free(avc_node_cachep, node);\n\tavc_cache_stats_incr(frees);\n\tatomic_dec(&avc_cache.active_nodes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "pos",
            "head",
            "list"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "lock",
            "flag"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_hash",
          "args": [
            "ssid",
            "tsid",
            "tclass"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "avc_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "99-102",
          "snippet": "static inline int avc_hash(u32 ssid, u32 tsid, u16 tclass)\n{\n\treturn (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define AVC_CACHE_SLOTS\t\t\t512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#define AVC_CACHE_SLOTS\t\t\t512\n\nstatic inline int avc_hash(u32 ssid, u32 tsid, u16 tclass)\n{\n\treturn (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_alloc_node",
          "args": [],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "avc_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "545-561",
          "snippet": "static struct avc_node *avc_alloc_node(void)\n{\n\tstruct avc_node *node;\n\n\tnode = kmem_cache_zalloc(avc_node_cachep, GFP_NOWAIT);\n\tif (!node)\n\t\tgoto out;\n\n\tINIT_HLIST_NODE(&node->list);\n\tavc_cache_stats_incr(allocations);\n\n\tif (atomic_inc_return(&avc_cache.active_nodes) > avc_cache_threshold)\n\t\tavc_reclaim_node();\n\nout:\n\treturn node;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int avc_cache_threshold = AVC_DEF_CACHE_THRESHOLD;",
            "static struct avc_cache avc_cache;",
            "static struct kmem_cache *avc_node_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nunsigned int avc_cache_threshold = AVC_DEF_CACHE_THRESHOLD;\nstatic struct avc_cache avc_cache;\nstatic struct kmem_cache *avc_node_cachep;\nstatic noinline struct;\n\nstatic struct avc_node *avc_alloc_node(void)\n{\n\tstruct avc_node *node;\n\n\tnode = kmem_cache_zalloc(avc_node_cachep, GFP_NOWAIT);\n\tif (!node)\n\t\tgoto out;\n\n\tINIT_HLIST_NODE(&node->list);\n\tavc_cache_stats_incr(allocations);\n\n\tif (atomic_inc_return(&avc_cache.active_nodes) > avc_cache_threshold)\n\t\tavc_reclaim_node();\n\nout:\n\treturn node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic struct kmem_cache *avc_node_cachep;\nstatic noinline struct;\n\nstatic int avc_update_node(u32 event, u32 perms, u8 driver, u8 xperm, u32 ssid,\n\t\t\tu32 tsid, u16 tclass, u32 seqno,\n\t\t\tstruct extended_perms_decision *xpd,\n\t\t\tu32 flags)\n{\n\tint hvalue, rc = 0;\n\tunsigned long flag;\n\tstruct avc_node *pos, *node, *orig = NULL;\n\tstruct hlist_head *head;\n\tspinlock_t *lock;\n\n\tnode = avc_alloc_node();\n\tif (!node) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Lock the target slot */\n\thvalue = avc_hash(ssid, tsid, tclass);\n\n\thead = &avc_cache.slots[hvalue];\n\tlock = &avc_cache.slots_lock[hvalue];\n\n\tspin_lock_irqsave(lock, flag);\n\n\thlist_for_each_entry(pos, head, list) {\n\t\tif (ssid == pos->ae.ssid &&\n\t\t    tsid == pos->ae.tsid &&\n\t\t    tclass == pos->ae.tclass &&\n\t\t    seqno == pos->ae.avd.seqno){\n\t\t\torig = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!orig) {\n\t\trc = -ENOENT;\n\t\tavc_node_kill(node);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Copy and replace original node.\n\t */\n\n\tavc_node_populate(node, ssid, tsid, tclass, &orig->ae.avd);\n\n\tif (orig->ae.xp_node) {\n\t\trc = avc_xperms_populate(node, orig->ae.xp_node);\n\t\tif (rc) {\n\t\t\tkmem_cache_free(avc_node_cachep, node);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tswitch (event) {\n\tcase AVC_CALLBACK_GRANT:\n\t\tnode->ae.avd.allowed |= perms;\n\t\tif (node->ae.xp_node && (flags & AVC_EXTENDED_PERMS))\n\t\t\tavc_xperms_allow_perm(node->ae.xp_node, driver, xperm);\n\t\tbreak;\n\tcase AVC_CALLBACK_TRY_REVOKE:\n\tcase AVC_CALLBACK_REVOKE:\n\t\tnode->ae.avd.allowed &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_ENABLE:\n\t\tnode->ae.avd.auditallow |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITALLOW_DISABLE:\n\t\tnode->ae.avd.auditallow &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_ENABLE:\n\t\tnode->ae.avd.auditdeny |= perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_AUDITDENY_DISABLE:\n\t\tnode->ae.avd.auditdeny &= ~perms;\n\t\tbreak;\n\tcase AVC_CALLBACK_ADD_XPERMS:\n\t\tavc_add_xperms_decision(node, xpd);\n\t\tbreak;\n\t}\n\tavc_node_replace(node, orig);\nout_unlock:\n\tspin_unlock_irqrestore(lock, flag);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "avc_add_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "784-801",
    "snippet": "int __init avc_add_callback(int (*callback)(u32 event), u32 events)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0;\n\n\tc = kmalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tc->callback = callback;\n\tc->events = events;\n\tc->next = avc_callbacks;\n\tavc_callbacks = c;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct avc_callback_node *avc_callbacks;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*c)",
            "GFP_KERNEL"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_callback_node *avc_callbacks;\nstatic noinline struct;\n\nint __init avc_add_callback(int (*callback)(u32 event), u32 events)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0;\n\n\tc = kmalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tc->callback = callback;\n\tc->events = events;\n\tc->next = avc_callbacks;\n\tavc_callbacks = c;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "slow_avc_audit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "737-773",
    "snippet": "noinline int slow_avc_audit(u32 ssid, u32 tsid, u16 tclass,\n\t\tu32 requested, u32 audited, u32 denied, int result,\n\t\tstruct common_audit_data *a,\n\t\tunsigned flags)\n{\n\tstruct common_audit_data stack_data;\n\tstruct selinux_audit_data sad;\n\n\tif (!a) {\n\t\ta = &stack_data;\n\t\ta->type = LSM_AUDIT_DATA_NONE;\n\t}\n\n\t/*\n\t * When in a RCU walk do the audit on the RCU retry.  This is because\n\t * the collection of the dname in an inode audit message is not RCU\n\t * safe.  Note this may drop some audits when the situation changes\n\t * during retry. However this is logically just as if the operation\n\t * happened a little later.\n\t */\n\tif ((a->type == LSM_AUDIT_DATA_INODE) &&\n\t    (flags & MAY_NOT_BLOCK))\n\t\treturn -ECHILD;\n\n\tsad.tclass = tclass;\n\tsad.requested = requested;\n\tsad.ssid = ssid;\n\tsad.tsid = tsid;\n\tsad.audited = audited;\n\tsad.denied = denied;\n\tsad.result = result;\n\n\ta->selinux_audit_data = &sad;\n\n\tcommon_lsm_audit(a, avc_audit_pre_callback, avc_audit_post_callback);\n\treturn 0;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_lsm_audit",
          "args": [
            "a",
            "avc_audit_pre_callback",
            "avc_audit_post_callback"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "common_lsm_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/lsm_audit.c",
          "lines": "441-465",
          "snippet": "void common_lsm_audit(struct common_audit_data *a,\n\tvoid (*pre_audit)(struct audit_buffer *, void *),\n\tvoid (*post_audit)(struct audit_buffer *, void *))\n{\n\tstruct audit_buffer *ab;\n\n\tif (a == NULL)\n\t\treturn;\n\t/* we use GFP_ATOMIC so we won't sleep */\n\tab = audit_log_start(current->audit_context, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t     AUDIT_AVC);\n\n\tif (ab == NULL)\n\t\treturn;\n\n\tif (pre_audit)\n\t\tpre_audit(ab, a);\n\n\tdump_common_audit_data(ab, a);\n\n\tif (post_audit)\n\t\tpost_audit(ab, a);\n\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/sctp.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <linux/ip.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/sctp.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nvoid common_lsm_audit(struct common_audit_data *a,\n\tvoid (*pre_audit)(struct audit_buffer *, void *),\n\tvoid (*post_audit)(struct audit_buffer *, void *))\n{\n\tstruct audit_buffer *ab;\n\n\tif (a == NULL)\n\t\treturn;\n\t/* we use GFP_ATOMIC so we won't sleep */\n\tab = audit_log_start(current->audit_context, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t     AUDIT_AVC);\n\n\tif (ab == NULL)\n\t\treturn;\n\n\tif (pre_audit)\n\t\tpre_audit(ab, a);\n\n\tdump_common_audit_data(ab, a);\n\n\tif (post_audit)\n\t\tpost_audit(ab, a);\n\n\taudit_log_end(ab);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nnoinline int slow_avc_audit(u32 ssid, u32 tsid, u16 tclass,\n\t\tu32 requested, u32 audited, u32 denied, int result,\n\t\tstruct common_audit_data *a,\n\t\tunsigned flags)\n{\n\tstruct common_audit_data stack_data;\n\tstruct selinux_audit_data sad;\n\n\tif (!a) {\n\t\ta = &stack_data;\n\t\ta->type = LSM_AUDIT_DATA_NONE;\n\t}\n\n\t/*\n\t * When in a RCU walk do the audit on the RCU retry.  This is because\n\t * the collection of the dname in an inode audit message is not RCU\n\t * safe.  Note this may drop some audits when the situation changes\n\t * during retry. However this is logically just as if the operation\n\t * happened a little later.\n\t */\n\tif ((a->type == LSM_AUDIT_DATA_INODE) &&\n\t    (flags & MAY_NOT_BLOCK))\n\t\treturn -ECHILD;\n\n\tsad.tclass = tclass;\n\tsad.requested = requested;\n\tsad.ssid = ssid;\n\tsad.tsid = tsid;\n\tsad.audited = audited;\n\tsad.denied = denied;\n\tsad.result = result;\n\n\ta->selinux_audit_data = &sad;\n\n\tcommon_lsm_audit(a, avc_audit_pre_callback, avc_audit_post_callback);\n\treturn 0;\n}"
  },
  {
    "function_name": "avc_audit_post_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "723-734",
    "snippet": "static void avc_audit_post_callback(struct audit_buffer *ab, void *a)\n{\n\tstruct common_audit_data *ad = a;\n\taudit_log_format(ab, \" \");\n\tavc_dump_query(ab, ad->selinux_audit_data->ssid,\n\t\t\t   ad->selinux_audit_data->tsid,\n\t\t\t   ad->selinux_audit_data->tclass);\n\tif (ad->selinux_audit_data->denied) {\n\t\taudit_log_format(ab, \" permissive=%u\",\n\t\t\t\t ad->selinux_audit_data->result ? 0 : 1);\n\t}\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" permissive=%u\"",
            "ad->selinux_audit_data->result ? 0 : 1"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_dump_query",
          "args": [
            "ab",
            "ad->selinux_audit_data->ssid",
            "ad->selinux_audit_data->tsid",
            "ad->selinux_audit_data->tclass"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "avc_dump_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "146-170",
          "snippet": "static void avc_dump_query(struct audit_buffer *ab, u32 ssid, u32 tsid, u16 tclass)\n{\n\tint rc;\n\tchar *scontext;\n\tu32 scontext_len;\n\n\trc = security_sid_to_context(ssid, &scontext, &scontext_len);\n\tif (rc)\n\t\taudit_log_format(ab, \"ssid=%d\", ssid);\n\telse {\n\t\taudit_log_format(ab, \"scontext=%s\", scontext);\n\t\tkfree(scontext);\n\t}\n\n\trc = security_sid_to_context(tsid, &scontext, &scontext_len);\n\tif (rc)\n\t\taudit_log_format(ab, \" tsid=%d\", tsid);\n\telse {\n\t\taudit_log_format(ab, \" tcontext=%s\", scontext);\n\t\tkfree(scontext);\n\t}\n\n\tBUG_ON(!tclass || tclass >= ARRAY_SIZE(secclass_map));\n\taudit_log_format(ab, \" tclass=%s\", secclass_map[tclass-1].name);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_dump_query(struct audit_buffer *ab, u32 ssid, u32 tsid, u16 tclass)\n{\n\tint rc;\n\tchar *scontext;\n\tu32 scontext_len;\n\n\trc = security_sid_to_context(ssid, &scontext, &scontext_len);\n\tif (rc)\n\t\taudit_log_format(ab, \"ssid=%d\", ssid);\n\telse {\n\t\taudit_log_format(ab, \"scontext=%s\", scontext);\n\t\tkfree(scontext);\n\t}\n\n\trc = security_sid_to_context(tsid, &scontext, &scontext_len);\n\tif (rc)\n\t\taudit_log_format(ab, \" tsid=%d\", tsid);\n\telse {\n\t\taudit_log_format(ab, \" tcontext=%s\", scontext);\n\t\tkfree(scontext);\n\t}\n\n\tBUG_ON(!tclass || tclass >= ARRAY_SIZE(secclass_map));\n\taudit_log_format(ab, \" tclass=%s\", secclass_map[tclass-1].name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" \""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_audit_post_callback(struct audit_buffer *ab, void *a)\n{\n\tstruct common_audit_data *ad = a;\n\taudit_log_format(ab, \" \");\n\tavc_dump_query(ab, ad->selinux_audit_data->ssid,\n\t\t\t   ad->selinux_audit_data->tsid,\n\t\t\t   ad->selinux_audit_data->tclass);\n\tif (ad->selinux_audit_data->denied) {\n\t\taudit_log_format(ab, \" permissive=%u\",\n\t\t\t\t ad->selinux_audit_data->result ? 0 : 1);\n\t}\n}"
  },
  {
    "function_name": "avc_audit_pre_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "707-715",
    "snippet": "static void avc_audit_pre_callback(struct audit_buffer *ab, void *a)\n{\n\tstruct common_audit_data *ad = a;\n\taudit_log_format(ab, \"avc:  %s \",\n\t\t\t ad->selinux_audit_data->denied ? \"denied\" : \"granted\");\n\tavc_dump_av(ab, ad->selinux_audit_data->tclass,\n\t\t\tad->selinux_audit_data->audited);\n\taudit_log_format(ab, \" for \");\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" for \""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_dump_av",
          "args": [
            "ab",
            "ad->selinux_audit_data->tclass",
            "ad->selinux_audit_data->audited"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "avc_dump_av",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "109-138",
          "snippet": "static void avc_dump_av(struct audit_buffer *ab, u16 tclass, u32 av)\n{\n\tconst char **perms;\n\tint i, perm;\n\n\tif (av == 0) {\n\t\taudit_log_format(ab, \" null\");\n\t\treturn;\n\t}\n\n\tBUG_ON(!tclass || tclass >= ARRAY_SIZE(secclass_map));\n\tperms = secclass_map[tclass-1].perms;\n\n\taudit_log_format(ab, \" {\");\n\ti = 0;\n\tperm = 1;\n\twhile (i < (sizeof(av) * 8)) {\n\t\tif ((perm & av) && perms[i]) {\n\t\t\taudit_log_format(ab, \" %s\", perms[i]);\n\t\t\tav &= ~perm;\n\t\t}\n\t\ti++;\n\t\tperm <<= 1;\n\t}\n\n\tif (av)\n\t\taudit_log_format(ab, \" 0x%x\", av);\n\n\taudit_log_format(ab, \" }\");\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_dump_av(struct audit_buffer *ab, u16 tclass, u32 av)\n{\n\tconst char **perms;\n\tint i, perm;\n\n\tif (av == 0) {\n\t\taudit_log_format(ab, \" null\");\n\t\treturn;\n\t}\n\n\tBUG_ON(!tclass || tclass >= ARRAY_SIZE(secclass_map));\n\tperms = secclass_map[tclass-1].perms;\n\n\taudit_log_format(ab, \" {\");\n\ti = 0;\n\tperm = 1;\n\twhile (i < (sizeof(av) * 8)) {\n\t\tif ((perm & av) && perms[i]) {\n\t\t\taudit_log_format(ab, \" %s\", perms[i]);\n\t\t\tav &= ~perm;\n\t\t}\n\t\ti++;\n\t\tperm <<= 1;\n\t}\n\n\tif (av)\n\t\taudit_log_format(ab, \" 0x%x\", av);\n\n\taudit_log_format(ab, \" }\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"avc:  %s \"",
            "ad->selinux_audit_data->denied ? \"denied\" : \"granted\""
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_audit_pre_callback(struct audit_buffer *ab, void *a)\n{\n\tstruct common_audit_data *ad = a;\n\taudit_log_format(ab, \"avc:  %s \",\n\t\t\t ad->selinux_audit_data->denied ? \"denied\" : \"granted\");\n\tavc_dump_av(ab, ad->selinux_audit_data->tclass,\n\t\t\tad->selinux_audit_data->audited);\n\taudit_log_format(ab, \" for \");\n}"
  },
  {
    "function_name": "avc_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "657-699",
    "snippet": "static struct avc_node *avc_insert(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\tstruct av_decision *avd,\n\t\t\t\tstruct avc_xperms_node *xp_node)\n{\n\tstruct avc_node *pos, *node = NULL;\n\tint hvalue;\n\tunsigned long flag;\n\n\tif (avc_latest_notif_update(avd->seqno, 1))\n\t\tgoto out;\n\n\tnode = avc_alloc_node();\n\tif (node) {\n\t\tstruct hlist_head *head;\n\t\tspinlock_t *lock;\n\t\tint rc = 0;\n\n\t\thvalue = avc_hash(ssid, tsid, tclass);\n\t\tavc_node_populate(node, ssid, tsid, tclass, avd);\n\t\trc = avc_xperms_populate(node, xp_node);\n\t\tif (rc) {\n\t\t\tkmem_cache_free(avc_node_cachep, node);\n\t\t\treturn NULL;\n\t\t}\n\t\thead = &avc_cache.slots[hvalue];\n\t\tlock = &avc_cache.slots_lock[hvalue];\n\n\t\tspin_lock_irqsave(lock, flag);\n\t\thlist_for_each_entry(pos, head, list) {\n\t\t\tif (pos->ae.ssid == ssid &&\n\t\t\t    pos->ae.tsid == tsid &&\n\t\t\t    pos->ae.tclass == tclass) {\n\t\t\t\tavc_node_replace(node, pos);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\thlist_add_head_rcu(&node->list, head);\nfound:\n\t\tspin_unlock_irqrestore(lock, flag);\n\t}\nout:\n\treturn node;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct avc_cache avc_cache;",
      "static struct kmem_cache *avc_node_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "lock",
            "flag"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&node->list",
            "head"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_node_replace",
          "args": [
            "node",
            "pos"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "avc_node_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "504-509",
          "snippet": "static void avc_node_replace(struct avc_node *new, struct avc_node *old)\n{\n\thlist_replace_rcu(&old->list, &new->list);\n\tcall_rcu(&old->rhead, avc_node_free);\n\tatomic_dec(&avc_cache.active_nodes);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_cache avc_cache;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nstatic void avc_node_replace(struct avc_node *new, struct avc_node *old)\n{\n\thlist_replace_rcu(&old->list, &new->list);\n\tcall_rcu(&old->rhead, avc_node_free);\n\tatomic_dec(&avc_cache.active_nodes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "pos",
            "head",
            "list"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "lock",
            "flag"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "avc_node_cachep",
            "node"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_xperms_populate",
          "args": [
            "node",
            "xp_node"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "403-433",
          "snippet": "static int avc_xperms_populate(struct avc_node *node,\n\t\t\t\tstruct avc_xperms_node *src)\n{\n\tstruct avc_xperms_node *dest;\n\tstruct avc_xperms_decision_node *dest_xpd;\n\tstruct avc_xperms_decision_node *src_xpd;\n\n\tif (src->xp.len == 0)\n\t\treturn 0;\n\tdest = avc_xperms_alloc();\n\tif (!dest)\n\t\treturn -ENOMEM;\n\n\tmemcpy(dest->xp.drivers.p, src->xp.drivers.p, sizeof(dest->xp.drivers.p));\n\tdest->xp.len = src->xp.len;\n\n\t/* for each source xpd allocate a destination xpd and copy */\n\tlist_for_each_entry(src_xpd, &src->xpd_head, xpd_list) {\n\t\tdest_xpd = avc_xperms_decision_alloc(src_xpd->xpd.used);\n\t\tif (!dest_xpd)\n\t\t\tgoto error;\n\t\tavc_copy_xperms_decision(&dest_xpd->xpd, &src_xpd->xpd);\n\t\tlist_add(&dest_xpd->xpd_list, &dest->xpd_head);\n\t}\n\tnode->ae.xp_node = dest;\n\treturn 0;\nerror:\n\tavc_xperms_free(dest);\n\treturn -ENOMEM;\n\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic int avc_xperms_populate(struct avc_node *node,\n\t\t\t\tstruct avc_xperms_node *src)\n{\n\tstruct avc_xperms_node *dest;\n\tstruct avc_xperms_decision_node *dest_xpd;\n\tstruct avc_xperms_decision_node *src_xpd;\n\n\tif (src->xp.len == 0)\n\t\treturn 0;\n\tdest = avc_xperms_alloc();\n\tif (!dest)\n\t\treturn -ENOMEM;\n\n\tmemcpy(dest->xp.drivers.p, src->xp.drivers.p, sizeof(dest->xp.drivers.p));\n\tdest->xp.len = src->xp.len;\n\n\t/* for each source xpd allocate a destination xpd and copy */\n\tlist_for_each_entry(src_xpd, &src->xpd_head, xpd_list) {\n\t\tdest_xpd = avc_xperms_decision_alloc(src_xpd->xpd.used);\n\t\tif (!dest_xpd)\n\t\t\tgoto error;\n\t\tavc_copy_xperms_decision(&dest_xpd->xpd, &src_xpd->xpd);\n\t\tlist_add(&dest_xpd->xpd_list, &dest->xpd_head);\n\t}\n\tnode->ae.xp_node = dest;\n\treturn 0;\nerror:\n\tavc_xperms_free(dest);\n\treturn -ENOMEM;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_node_populate",
          "args": [
            "node",
            "ssid",
            "tsid",
            "tclass",
            "avd"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "avc_node_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "563-569",
          "snippet": "static void avc_node_populate(struct avc_node *node, u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd)\n{\n\tnode->ae.ssid = ssid;\n\tnode->ae.tsid = tsid;\n\tnode->ae.tclass = tclass;\n\tmemcpy(&node->ae.avd, avd, sizeof(node->ae.avd));\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_node_populate(struct avc_node *node, u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd)\n{\n\tnode->ae.ssid = ssid;\n\tnode->ae.tsid = tsid;\n\tnode->ae.tclass = tclass;\n\tmemcpy(&node->ae.avd, avd, sizeof(node->ae.avd));\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_hash",
          "args": [
            "ssid",
            "tsid",
            "tclass"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "avc_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "99-102",
          "snippet": "static inline int avc_hash(u32 ssid, u32 tsid, u16 tclass)\n{\n\treturn (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define AVC_CACHE_SLOTS\t\t\t512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#define AVC_CACHE_SLOTS\t\t\t512\n\nstatic inline int avc_hash(u32 ssid, u32 tsid, u16 tclass)\n{\n\treturn (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_alloc_node",
          "args": [],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "avc_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "545-561",
          "snippet": "static struct avc_node *avc_alloc_node(void)\n{\n\tstruct avc_node *node;\n\n\tnode = kmem_cache_zalloc(avc_node_cachep, GFP_NOWAIT);\n\tif (!node)\n\t\tgoto out;\n\n\tINIT_HLIST_NODE(&node->list);\n\tavc_cache_stats_incr(allocations);\n\n\tif (atomic_inc_return(&avc_cache.active_nodes) > avc_cache_threshold)\n\t\tavc_reclaim_node();\n\nout:\n\treturn node;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int avc_cache_threshold = AVC_DEF_CACHE_THRESHOLD;",
            "static struct avc_cache avc_cache;",
            "static struct kmem_cache *avc_node_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nunsigned int avc_cache_threshold = AVC_DEF_CACHE_THRESHOLD;\nstatic struct avc_cache avc_cache;\nstatic struct kmem_cache *avc_node_cachep;\nstatic noinline struct;\n\nstatic struct avc_node *avc_alloc_node(void)\n{\n\tstruct avc_node *node;\n\n\tnode = kmem_cache_zalloc(avc_node_cachep, GFP_NOWAIT);\n\tif (!node)\n\t\tgoto out;\n\n\tINIT_HLIST_NODE(&node->list);\n\tavc_cache_stats_incr(allocations);\n\n\tif (atomic_inc_return(&avc_cache.active_nodes) > avc_cache_threshold)\n\t\tavc_reclaim_node();\n\nout:\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_latest_notif_update",
          "args": [
            "avd->seqno",
            "1"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "avc_latest_notif_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "617-637",
          "snippet": "static int avc_latest_notif_update(int seqno, int is_insert)\n{\n\tint ret = 0;\n\tstatic DEFINE_SPINLOCK(notif_lock);\n\tunsigned long flag;\n\n\tspin_lock_irqsave(&notif_lock, flag);\n\tif (is_insert) {\n\t\tif (seqno < avc_cache.latest_notif) {\n\t\t\tprintk(KERN_WARNING \"SELinux: avc:  seqno %d < latest_notif %d\\n\",\n\t\t\t       seqno, avc_cache.latest_notif);\n\t\t\tret = -EAGAIN;\n\t\t}\n\t} else {\n\t\tif (seqno > avc_cache.latest_notif)\n\t\t\tavc_cache.latest_notif = seqno;\n\t}\n\tspin_unlock_irqrestore(&notif_lock, flag);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_cache avc_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\n\nstatic int avc_latest_notif_update(int seqno, int is_insert)\n{\n\tint ret = 0;\n\tstatic DEFINE_SPINLOCK(notif_lock);\n\tunsigned long flag;\n\n\tspin_lock_irqsave(&notif_lock, flag);\n\tif (is_insert) {\n\t\tif (seqno < avc_cache.latest_notif) {\n\t\t\tprintk(KERN_WARNING \"SELinux: avc:  seqno %d < latest_notif %d\\n\",\n\t\t\t       seqno, avc_cache.latest_notif);\n\t\t\tret = -EAGAIN;\n\t\t}\n\t} else {\n\t\tif (seqno > avc_cache.latest_notif)\n\t\t\tavc_cache.latest_notif = seqno;\n\t}\n\tspin_unlock_irqrestore(&notif_lock, flag);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic struct kmem_cache *avc_node_cachep;\nstatic noinline struct;\n\nstatic struct avc_node *avc_insert(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\tstruct av_decision *avd,\n\t\t\t\tstruct avc_xperms_node *xp_node)\n{\n\tstruct avc_node *pos, *node = NULL;\n\tint hvalue;\n\tunsigned long flag;\n\n\tif (avc_latest_notif_update(avd->seqno, 1))\n\t\tgoto out;\n\n\tnode = avc_alloc_node();\n\tif (node) {\n\t\tstruct hlist_head *head;\n\t\tspinlock_t *lock;\n\t\tint rc = 0;\n\n\t\thvalue = avc_hash(ssid, tsid, tclass);\n\t\tavc_node_populate(node, ssid, tsid, tclass, avd);\n\t\trc = avc_xperms_populate(node, xp_node);\n\t\tif (rc) {\n\t\t\tkmem_cache_free(avc_node_cachep, node);\n\t\t\treturn NULL;\n\t\t}\n\t\thead = &avc_cache.slots[hvalue];\n\t\tlock = &avc_cache.slots_lock[hvalue];\n\n\t\tspin_lock_irqsave(lock, flag);\n\t\thlist_for_each_entry(pos, head, list) {\n\t\t\tif (pos->ae.ssid == ssid &&\n\t\t\t    pos->ae.tsid == tsid &&\n\t\t\t    pos->ae.tclass == tclass) {\n\t\t\t\tavc_node_replace(node, pos);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\thlist_add_head_rcu(&node->list, head);\nfound:\n\t\tspin_unlock_irqrestore(lock, flag);\n\t}\nout:\n\treturn node;\n}"
  },
  {
    "function_name": "avc_latest_notif_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "617-637",
    "snippet": "static int avc_latest_notif_update(int seqno, int is_insert)\n{\n\tint ret = 0;\n\tstatic DEFINE_SPINLOCK(notif_lock);\n\tunsigned long flag;\n\n\tspin_lock_irqsave(&notif_lock, flag);\n\tif (is_insert) {\n\t\tif (seqno < avc_cache.latest_notif) {\n\t\t\tprintk(KERN_WARNING \"SELinux: avc:  seqno %d < latest_notif %d\\n\",\n\t\t\t       seqno, avc_cache.latest_notif);\n\t\t\tret = -EAGAIN;\n\t\t}\n\t} else {\n\t\tif (seqno > avc_cache.latest_notif)\n\t\t\tavc_cache.latest_notif = seqno;\n\t}\n\tspin_unlock_irqrestore(&notif_lock, flag);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct avc_cache avc_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&notif_lock",
            "flag"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"SELinux: avc:  seqno %d < latest_notif %d\\n\"",
            "seqno",
            "avc_cache.latest_notif"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&notif_lock",
            "flag"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\n\nstatic int avc_latest_notif_update(int seqno, int is_insert)\n{\n\tint ret = 0;\n\tstatic DEFINE_SPINLOCK(notif_lock);\n\tunsigned long flag;\n\n\tspin_lock_irqsave(&notif_lock, flag);\n\tif (is_insert) {\n\t\tif (seqno < avc_cache.latest_notif) {\n\t\t\tprintk(KERN_WARNING \"SELinux: avc:  seqno %d < latest_notif %d\\n\",\n\t\t\t       seqno, avc_cache.latest_notif);\n\t\t\tret = -EAGAIN;\n\t\t}\n\t} else {\n\t\tif (seqno > avc_cache.latest_notif)\n\t\t\tavc_cache.latest_notif = seqno;\n\t}\n\tspin_unlock_irqrestore(&notif_lock, flag);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "avc_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "603-615",
    "snippet": "static struct avc_node *avc_lookup(u32 ssid, u32 tsid, u16 tclass)\n{\n\tstruct avc_node *node;\n\n\tavc_cache_stats_incr(lookups);\n\tnode = avc_search_node(ssid, tsid, tclass);\n\n\tif (node)\n\t\treturn node;\n\n\tavc_cache_stats_incr(misses);\n\treturn NULL;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_cache_stats_incr",
          "args": [
            "misses"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_search_node",
          "args": [
            "ssid",
            "tsid",
            "tclass"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "avc_search_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "571-589",
          "snippet": "static inline struct avc_node *avc_search_node(u32 ssid, u32 tsid, u16 tclass)\n{\n\tstruct avc_node *node, *ret = NULL;\n\tint hvalue;\n\tstruct hlist_head *head;\n\n\thvalue = avc_hash(ssid, tsid, tclass);\n\thead = &avc_cache.slots[hvalue];\n\thlist_for_each_entry_rcu(node, head, list) {\n\t\tif (ssid == node->ae.ssid &&\n\t\t    tclass == node->ae.tclass &&\n\t\t    tsid == node->ae.tsid) {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_cache avc_cache;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nstatic inline struct avc_node *avc_search_node(u32 ssid, u32 tsid, u16 tclass)\n{\n\tstruct avc_node *node, *ret = NULL;\n\tint hvalue;\n\tstruct hlist_head *head;\n\n\thvalue = avc_hash(ssid, tsid, tclass);\n\thead = &avc_cache.slots[hvalue];\n\thlist_for_each_entry_rcu(node, head, list) {\n\t\tif (ssid == node->ae.ssid &&\n\t\t    tclass == node->ae.tclass &&\n\t\t    tsid == node->ae.tsid) {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_cache_stats_incr",
          "args": [
            "lookups"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic struct avc_node *avc_lookup(u32 ssid, u32 tsid, u16 tclass)\n{\n\tstruct avc_node *node;\n\n\tavc_cache_stats_incr(lookups);\n\tnode = avc_search_node(ssid, tsid, tclass);\n\n\tif (node)\n\t\treturn node;\n\n\tavc_cache_stats_incr(misses);\n\treturn NULL;\n}"
  },
  {
    "function_name": "avc_search_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "571-589",
    "snippet": "static inline struct avc_node *avc_search_node(u32 ssid, u32 tsid, u16 tclass)\n{\n\tstruct avc_node *node, *ret = NULL;\n\tint hvalue;\n\tstruct hlist_head *head;\n\n\thvalue = avc_hash(ssid, tsid, tclass);\n\thead = &avc_cache.slots[hvalue];\n\thlist_for_each_entry_rcu(node, head, list) {\n\t\tif (ssid == node->ae.ssid &&\n\t\t    tclass == node->ae.tclass &&\n\t\t    tsid == node->ae.tsid) {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct avc_cache avc_cache;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "node",
            "head",
            "list"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_hash",
          "args": [
            "ssid",
            "tsid",
            "tclass"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "avc_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "99-102",
          "snippet": "static inline int avc_hash(u32 ssid, u32 tsid, u16 tclass)\n{\n\treturn (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define AVC_CACHE_SLOTS\t\t\t512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#define AVC_CACHE_SLOTS\t\t\t512\n\nstatic inline int avc_hash(u32 ssid, u32 tsid, u16 tclass)\n{\n\treturn (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nstatic inline struct avc_node *avc_search_node(u32 ssid, u32 tsid, u16 tclass)\n{\n\tstruct avc_node *node, *ret = NULL;\n\tint hvalue;\n\tstruct hlist_head *head;\n\n\thvalue = avc_hash(ssid, tsid, tclass);\n\thead = &avc_cache.slots[hvalue];\n\thlist_for_each_entry_rcu(node, head, list) {\n\t\tif (ssid == node->ae.ssid &&\n\t\t    tclass == node->ae.tclass &&\n\t\t    tsid == node->ae.tsid) {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "avc_node_populate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "563-569",
    "snippet": "static void avc_node_populate(struct avc_node *node, u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd)\n{\n\tnode->ae.ssid = ssid;\n\tnode->ae.tsid = tsid;\n\tnode->ae.tclass = tclass;\n\tmemcpy(&node->ae.avd, avd, sizeof(node->ae.avd));\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&node->ae.avd",
            "avd",
            "sizeof(node->ae.avd)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_node_populate(struct avc_node *node, u32 ssid, u32 tsid, u16 tclass, struct av_decision *avd)\n{\n\tnode->ae.ssid = ssid;\n\tnode->ae.tsid = tsid;\n\tnode->ae.tclass = tclass;\n\tmemcpy(&node->ae.avd, avd, sizeof(node->ae.avd));\n}"
  },
  {
    "function_name": "avc_alloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "545-561",
    "snippet": "static struct avc_node *avc_alloc_node(void)\n{\n\tstruct avc_node *node;\n\n\tnode = kmem_cache_zalloc(avc_node_cachep, GFP_NOWAIT);\n\tif (!node)\n\t\tgoto out;\n\n\tINIT_HLIST_NODE(&node->list);\n\tavc_cache_stats_incr(allocations);\n\n\tif (atomic_inc_return(&avc_cache.active_nodes) > avc_cache_threshold)\n\t\tavc_reclaim_node();\n\nout:\n\treturn node;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int avc_cache_threshold = AVC_DEF_CACHE_THRESHOLD;",
      "static struct avc_cache avc_cache;",
      "static struct kmem_cache *avc_node_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_reclaim_node",
          "args": [],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "avc_reclaim_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "511-543",
          "snippet": "static inline int avc_reclaim_node(void)\n{\n\tstruct avc_node *node;\n\tint hvalue, try, ecx;\n\tunsigned long flags;\n\tstruct hlist_head *head;\n\tspinlock_t *lock;\n\n\tfor (try = 0, ecx = 0; try < AVC_CACHE_SLOTS; try++) {\n\t\thvalue = atomic_inc_return(&avc_cache.lru_hint) & (AVC_CACHE_SLOTS - 1);\n\t\thead = &avc_cache.slots[hvalue];\n\t\tlock = &avc_cache.slots_lock[hvalue];\n\n\t\tif (!spin_trylock_irqsave(lock, flags))\n\t\t\tcontinue;\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry(node, head, list) {\n\t\t\tavc_node_delete(node);\n\t\t\tavc_cache_stats_incr(reclaims);\n\t\t\tecx++;\n\t\t\tif (ecx >= AVC_CACHE_RECLAIM) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tspin_unlock_irqrestore(lock, flags);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tspin_unlock_irqrestore(lock, flags);\n\t}\nout:\n\treturn ecx;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define AVC_CACHE_RECLAIM\t\t16",
            "#define AVC_CACHE_SLOTS\t\t\t512"
          ],
          "globals_used": [
            "static struct avc_cache avc_cache;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#define AVC_CACHE_RECLAIM\t\t16\n#define AVC_CACHE_SLOTS\t\t\t512\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nstatic inline int avc_reclaim_node(void)\n{\n\tstruct avc_node *node;\n\tint hvalue, try, ecx;\n\tunsigned long flags;\n\tstruct hlist_head *head;\n\tspinlock_t *lock;\n\n\tfor (try = 0, ecx = 0; try < AVC_CACHE_SLOTS; try++) {\n\t\thvalue = atomic_inc_return(&avc_cache.lru_hint) & (AVC_CACHE_SLOTS - 1);\n\t\thead = &avc_cache.slots[hvalue];\n\t\tlock = &avc_cache.slots_lock[hvalue];\n\n\t\tif (!spin_trylock_irqsave(lock, flags))\n\t\t\tcontinue;\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry(node, head, list) {\n\t\t\tavc_node_delete(node);\n\t\t\tavc_cache_stats_incr(reclaims);\n\t\t\tecx++;\n\t\t\tif (ecx >= AVC_CACHE_RECLAIM) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tspin_unlock_irqrestore(lock, flags);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tspin_unlock_irqrestore(lock, flags);\n\t}\nout:\n\treturn ecx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&avc_cache.active_nodes"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_cache_stats_incr",
          "args": [
            "allocations"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&node->list"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "avc_node_cachep",
            "GFP_NOWAIT"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nunsigned int avc_cache_threshold = AVC_DEF_CACHE_THRESHOLD;\nstatic struct avc_cache avc_cache;\nstatic struct kmem_cache *avc_node_cachep;\nstatic noinline struct;\n\nstatic struct avc_node *avc_alloc_node(void)\n{\n\tstruct avc_node *node;\n\n\tnode = kmem_cache_zalloc(avc_node_cachep, GFP_NOWAIT);\n\tif (!node)\n\t\tgoto out;\n\n\tINIT_HLIST_NODE(&node->list);\n\tavc_cache_stats_incr(allocations);\n\n\tif (atomic_inc_return(&avc_cache.active_nodes) > avc_cache_threshold)\n\t\tavc_reclaim_node();\n\nout:\n\treturn node;\n}"
  },
  {
    "function_name": "avc_reclaim_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "511-543",
    "snippet": "static inline int avc_reclaim_node(void)\n{\n\tstruct avc_node *node;\n\tint hvalue, try, ecx;\n\tunsigned long flags;\n\tstruct hlist_head *head;\n\tspinlock_t *lock;\n\n\tfor (try = 0, ecx = 0; try < AVC_CACHE_SLOTS; try++) {\n\t\thvalue = atomic_inc_return(&avc_cache.lru_hint) & (AVC_CACHE_SLOTS - 1);\n\t\thead = &avc_cache.slots[hvalue];\n\t\tlock = &avc_cache.slots_lock[hvalue];\n\n\t\tif (!spin_trylock_irqsave(lock, flags))\n\t\t\tcontinue;\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry(node, head, list) {\n\t\t\tavc_node_delete(node);\n\t\t\tavc_cache_stats_incr(reclaims);\n\t\t\tecx++;\n\t\t\tif (ecx >= AVC_CACHE_RECLAIM) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tspin_unlock_irqrestore(lock, flags);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tspin_unlock_irqrestore(lock, flags);\n\t}\nout:\n\treturn ecx;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define AVC_CACHE_RECLAIM\t\t16",
      "#define AVC_CACHE_SLOTS\t\t\t512"
    ],
    "globals_used": [
      "static struct avc_cache avc_cache;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "lock",
            "flags"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "lock",
            "flags"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_cache_stats_incr",
          "args": [
            "reclaims"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_node_delete",
          "args": [
            "node"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "avc_node_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "489-494",
          "snippet": "static void avc_node_delete(struct avc_node *node)\n{\n\thlist_del_rcu(&node->list);\n\tcall_rcu(&node->rhead, avc_node_free);\n\tatomic_dec(&avc_cache.active_nodes);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_cache avc_cache;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nstatic void avc_node_delete(struct avc_node *node)\n{\n\thlist_del_rcu(&node->list);\n\tcall_rcu(&node->rhead, avc_node_free);\n\tatomic_dec(&avc_cache.active_nodes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "node",
            "head",
            "list"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock_irqsave",
          "args": [
            "lock",
            "flags"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&avc_cache.lru_hint"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#define AVC_CACHE_RECLAIM\t\t16\n#define AVC_CACHE_SLOTS\t\t\t512\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nstatic inline int avc_reclaim_node(void)\n{\n\tstruct avc_node *node;\n\tint hvalue, try, ecx;\n\tunsigned long flags;\n\tstruct hlist_head *head;\n\tspinlock_t *lock;\n\n\tfor (try = 0, ecx = 0; try < AVC_CACHE_SLOTS; try++) {\n\t\thvalue = atomic_inc_return(&avc_cache.lru_hint) & (AVC_CACHE_SLOTS - 1);\n\t\thead = &avc_cache.slots[hvalue];\n\t\tlock = &avc_cache.slots_lock[hvalue];\n\n\t\tif (!spin_trylock_irqsave(lock, flags))\n\t\t\tcontinue;\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry(node, head, list) {\n\t\t\tavc_node_delete(node);\n\t\t\tavc_cache_stats_incr(reclaims);\n\t\t\tecx++;\n\t\t\tif (ecx >= AVC_CACHE_RECLAIM) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tspin_unlock_irqrestore(lock, flags);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tspin_unlock_irqrestore(lock, flags);\n\t}\nout:\n\treturn ecx;\n}"
  },
  {
    "function_name": "avc_node_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "504-509",
    "snippet": "static void avc_node_replace(struct avc_node *new, struct avc_node *old)\n{\n\thlist_replace_rcu(&old->list, &new->list);\n\tcall_rcu(&old->rhead, avc_node_free);\n\tatomic_dec(&avc_cache.active_nodes);\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct avc_cache avc_cache;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&avc_cache.active_nodes"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&old->rhead",
            "avc_node_free"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_replace_rcu",
          "args": [
            "&old->list",
            "&new->list"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nstatic void avc_node_replace(struct avc_node *new, struct avc_node *old)\n{\n\thlist_replace_rcu(&old->list, &new->list);\n\tcall_rcu(&old->rhead, avc_node_free);\n\tatomic_dec(&avc_cache.active_nodes);\n}"
  },
  {
    "function_name": "avc_node_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "496-502",
    "snippet": "static void avc_node_kill(struct avc_node *node)\n{\n\tavc_xperms_free(node->ae.xp_node);\n\tkmem_cache_free(avc_node_cachep, node);\n\tavc_cache_stats_incr(frees);\n\tatomic_dec(&avc_cache.active_nodes);\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct avc_cache avc_cache;",
      "static struct kmem_cache *avc_node_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&avc_cache.active_nodes"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_cache_stats_incr",
          "args": [
            "frees"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "avc_node_cachep",
            "node"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_xperms_free",
          "args": [
            "node->ae.xp_node"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "290-302",
          "snippet": "static void avc_xperms_free(struct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node, *tmp;\n\n\tif (!xp_node)\n\t\treturn;\n\n\tlist_for_each_entry_safe(xpd_node, tmp, &xp_node->xpd_head, xpd_list) {\n\t\tlist_del(&xpd_node->xpd_list);\n\t\tavc_xperms_decision_free(xpd_node);\n\t}\n\tkmem_cache_free(avc_xperms_cachep, xp_node);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avc_xperms_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_xperms_cachep;\nstatic noinline struct;\n\nstatic void avc_xperms_free(struct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node, *tmp;\n\n\tif (!xp_node)\n\t\treturn;\n\n\tlist_for_each_entry_safe(xpd_node, tmp, &xp_node->xpd_head, xpd_list) {\n\t\tlist_del(&xpd_node->xpd_list);\n\t\tavc_xperms_decision_free(xpd_node);\n\t}\n\tkmem_cache_free(avc_xperms_cachep, xp_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic struct kmem_cache *avc_node_cachep;\nstatic noinline struct;\n\nstatic void avc_node_kill(struct avc_node *node)\n{\n\tavc_xperms_free(node->ae.xp_node);\n\tkmem_cache_free(avc_node_cachep, node);\n\tavc_cache_stats_incr(frees);\n\tatomic_dec(&avc_cache.active_nodes);\n}"
  },
  {
    "function_name": "avc_node_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "489-494",
    "snippet": "static void avc_node_delete(struct avc_node *node)\n{\n\thlist_del_rcu(&node->list);\n\tcall_rcu(&node->rhead, avc_node_free);\n\tatomic_dec(&avc_cache.active_nodes);\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct avc_cache avc_cache;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&avc_cache.active_nodes"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&node->rhead",
            "avc_node_free"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&node->list"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nstatic void avc_node_delete(struct avc_node *node)\n{\n\thlist_del_rcu(&node->list);\n\tcall_rcu(&node->rhead, avc_node_free);\n\tatomic_dec(&avc_cache.active_nodes);\n}"
  },
  {
    "function_name": "avc_node_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "481-487",
    "snippet": "static void avc_node_free(struct rcu_head *rhead)\n{\n\tstruct avc_node *node = container_of(rhead, struct avc_node, rhead);\n\tavc_xperms_free(node->ae.xp_node);\n\tkmem_cache_free(avc_node_cachep, node);\n\tavc_cache_stats_incr(frees);\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *avc_node_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_cache_stats_incr",
          "args": [
            "frees"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "avc_node_cachep",
            "node"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_xperms_free",
          "args": [
            "node->ae.xp_node"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "290-302",
          "snippet": "static void avc_xperms_free(struct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node, *tmp;\n\n\tif (!xp_node)\n\t\treturn;\n\n\tlist_for_each_entry_safe(xpd_node, tmp, &xp_node->xpd_head, xpd_list) {\n\t\tlist_del(&xpd_node->xpd_list);\n\t\tavc_xperms_decision_free(xpd_node);\n\t}\n\tkmem_cache_free(avc_xperms_cachep, xp_node);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avc_xperms_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_xperms_cachep;\nstatic noinline struct;\n\nstatic void avc_xperms_free(struct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node, *tmp;\n\n\tif (!xp_node)\n\t\treturn;\n\n\tlist_for_each_entry_safe(xpd_node, tmp, &xp_node->xpd_head, xpd_list) {\n\t\tlist_del(&xpd_node->xpd_list);\n\t\tavc_xperms_decision_free(xpd_node);\n\t}\n\tkmem_cache_free(avc_xperms_cachep, xp_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rhead",
            "structavc_node",
            "rhead"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_node_cachep;\nstatic noinline struct;\n\nstatic void avc_node_free(struct rcu_head *rhead)\n{\n\tstruct avc_node *node = container_of(rhead, struct avc_node, rhead);\n\tavc_xperms_free(node->ae.xp_node);\n\tkmem_cache_free(avc_node_cachep, node);\n\tavc_cache_stats_incr(frees);\n}"
  },
  {
    "function_name": "avc_xperms_audit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "465-479",
    "snippet": "static inline int avc_xperms_audit(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\tu32 requested, struct av_decision *avd,\n\t\t\t\tstruct extended_perms_decision *xpd,\n\t\t\t\tu8 perm, int result,\n\t\t\t\tstruct common_audit_data *ad)\n{\n\tu32 audited, denied;\n\n\taudited = avc_xperms_audit_required(\n\t\t\trequested, avd, xpd, perm, result, &denied);\n\tif (likely(!audited))\n\t\treturn 0;\n\treturn slow_avc_audit(ssid, tsid, tclass, requested,\n\t\t\taudited, denied, result, ad, 0);\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slow_avc_audit",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "requested",
            "audited",
            "denied",
            "result",
            "ad",
            "0"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "slow_avc_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "737-773",
          "snippet": "noinline int slow_avc_audit(u32 ssid, u32 tsid, u16 tclass,\n\t\tu32 requested, u32 audited, u32 denied, int result,\n\t\tstruct common_audit_data *a,\n\t\tunsigned flags)\n{\n\tstruct common_audit_data stack_data;\n\tstruct selinux_audit_data sad;\n\n\tif (!a) {\n\t\ta = &stack_data;\n\t\ta->type = LSM_AUDIT_DATA_NONE;\n\t}\n\n\t/*\n\t * When in a RCU walk do the audit on the RCU retry.  This is because\n\t * the collection of the dname in an inode audit message is not RCU\n\t * safe.  Note this may drop some audits when the situation changes\n\t * during retry. However this is logically just as if the operation\n\t * happened a little later.\n\t */\n\tif ((a->type == LSM_AUDIT_DATA_INODE) &&\n\t    (flags & MAY_NOT_BLOCK))\n\t\treturn -ECHILD;\n\n\tsad.tclass = tclass;\n\tsad.requested = requested;\n\tsad.ssid = ssid;\n\tsad.tsid = tsid;\n\tsad.audited = audited;\n\tsad.denied = denied;\n\tsad.result = result;\n\n\ta->selinux_audit_data = &sad;\n\n\tcommon_lsm_audit(a, avc_audit_pre_callback, avc_audit_post_callback);\n\treturn 0;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nnoinline int slow_avc_audit(u32 ssid, u32 tsid, u16 tclass,\n\t\tu32 requested, u32 audited, u32 denied, int result,\n\t\tstruct common_audit_data *a,\n\t\tunsigned flags)\n{\n\tstruct common_audit_data stack_data;\n\tstruct selinux_audit_data sad;\n\n\tif (!a) {\n\t\ta = &stack_data;\n\t\ta->type = LSM_AUDIT_DATA_NONE;\n\t}\n\n\t/*\n\t * When in a RCU walk do the audit on the RCU retry.  This is because\n\t * the collection of the dname in an inode audit message is not RCU\n\t * safe.  Note this may drop some audits when the situation changes\n\t * during retry. However this is logically just as if the operation\n\t * happened a little later.\n\t */\n\tif ((a->type == LSM_AUDIT_DATA_INODE) &&\n\t    (flags & MAY_NOT_BLOCK))\n\t\treturn -ECHILD;\n\n\tsad.tclass = tclass;\n\tsad.requested = requested;\n\tsad.ssid = ssid;\n\tsad.tsid = tsid;\n\tsad.audited = audited;\n\tsad.denied = denied;\n\tsad.result = result;\n\n\ta->selinux_audit_data = &sad;\n\n\tcommon_lsm_audit(a, avc_audit_pre_callback, avc_audit_post_callback);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!audited"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_xperms_audit_required",
          "args": [
            "requested",
            "avd",
            "xpd",
            "perm",
            "result",
            "&denied"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_audit_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "435-463",
          "snippet": "static inline u32 avc_xperms_audit_required(u32 requested,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms_decision *xpd,\n\t\t\t\t\tu8 perm,\n\t\t\t\t\tint result,\n\t\t\t\t\tu32 *deniedp)\n{\n\tu32 denied, audited;\n\n\tdenied = requested & ~avd->allowed;\n\tif (unlikely(denied)) {\n\t\taudited = denied & avd->auditdeny;\n\t\tif (audited && xpd) {\n\t\t\tif (avc_xperms_has_perm(xpd, perm, XPERMS_DONTAUDIT))\n\t\t\t\taudited &= ~requested;\n\t\t}\n\t} else if (result) {\n\t\taudited = denied = requested;\n\t} else {\n\t\taudited = requested & avd->auditallow;\n\t\tif (audited && xpd) {\n\t\t\tif (!avc_xperms_has_perm(xpd, perm, XPERMS_AUDITALLOW))\n\t\t\t\taudited &= ~requested;\n\t\t}\n\t}\n\n\t*deniedp = denied;\n\treturn audited;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic inline u32 avc_xperms_audit_required(u32 requested,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms_decision *xpd,\n\t\t\t\t\tu8 perm,\n\t\t\t\t\tint result,\n\t\t\t\t\tu32 *deniedp)\n{\n\tu32 denied, audited;\n\n\tdenied = requested & ~avd->allowed;\n\tif (unlikely(denied)) {\n\t\taudited = denied & avd->auditdeny;\n\t\tif (audited && xpd) {\n\t\t\tif (avc_xperms_has_perm(xpd, perm, XPERMS_DONTAUDIT))\n\t\t\t\taudited &= ~requested;\n\t\t}\n\t} else if (result) {\n\t\taudited = denied = requested;\n\t} else {\n\t\taudited = requested & avd->auditallow;\n\t\tif (audited && xpd) {\n\t\t\tif (!avc_xperms_has_perm(xpd, perm, XPERMS_AUDITALLOW))\n\t\t\t\taudited &= ~requested;\n\t\t}\n\t}\n\n\t*deniedp = denied;\n\treturn audited;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic inline int avc_xperms_audit(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\tu32 requested, struct av_decision *avd,\n\t\t\t\tstruct extended_perms_decision *xpd,\n\t\t\t\tu8 perm, int result,\n\t\t\t\tstruct common_audit_data *ad)\n{\n\tu32 audited, denied;\n\n\taudited = avc_xperms_audit_required(\n\t\t\trequested, avd, xpd, perm, result, &denied);\n\tif (likely(!audited))\n\t\treturn 0;\n\treturn slow_avc_audit(ssid, tsid, tclass, requested,\n\t\t\taudited, denied, result, ad, 0);\n}"
  },
  {
    "function_name": "avc_xperms_audit_required",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "435-463",
    "snippet": "static inline u32 avc_xperms_audit_required(u32 requested,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms_decision *xpd,\n\t\t\t\t\tu8 perm,\n\t\t\t\t\tint result,\n\t\t\t\t\tu32 *deniedp)\n{\n\tu32 denied, audited;\n\n\tdenied = requested & ~avd->allowed;\n\tif (unlikely(denied)) {\n\t\taudited = denied & avd->auditdeny;\n\t\tif (audited && xpd) {\n\t\t\tif (avc_xperms_has_perm(xpd, perm, XPERMS_DONTAUDIT))\n\t\t\t\taudited &= ~requested;\n\t\t}\n\t} else if (result) {\n\t\taudited = denied = requested;\n\t} else {\n\t\taudited = requested & avd->auditallow;\n\t\tif (audited && xpd) {\n\t\t\tif (!avc_xperms_has_perm(xpd, perm, XPERMS_AUDITALLOW))\n\t\t\t\taudited &= ~requested;\n\t\t}\n\t}\n\n\t*deniedp = denied;\n\treturn audited;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_xperms_has_perm",
          "args": [
            "xpd",
            "perm",
            "XPERMS_AUDITALLOW"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "248-264",
          "snippet": "static inline unsigned int\navc_xperms_has_perm(struct extended_perms_decision *xpd,\n\t\t\t\t\tu8 perm, u8 which)\n{\n\tunsigned int rc = 0;\n\n\tif ((which == XPERMS_ALLOWED) &&\n\t\t\t(xpd->used & XPERMS_ALLOWED))\n\t\trc = security_xperm_test(xpd->allowed->p, perm);\n\telse if ((which == XPERMS_AUDITALLOW) &&\n\t\t\t(xpd->used & XPERMS_AUDITALLOW))\n\t\trc = security_xperm_test(xpd->auditallow->p, perm);\n\telse if ((which == XPERMS_DONTAUDIT) &&\n\t\t\t(xpd->used & XPERMS_DONTAUDIT))\n\t\trc = security_xperm_test(xpd->dontaudit->p, perm);\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int\navc_xperms_has_perm(struct extended_perms_decision *xpd,\n\t\t\t\t\tu8 perm, u8 which)\n{\n\tunsigned int rc = 0;\n\n\tif ((which == XPERMS_ALLOWED) &&\n\t\t\t(xpd->used & XPERMS_ALLOWED))\n\t\trc = security_xperm_test(xpd->allowed->p, perm);\n\telse if ((which == XPERMS_AUDITALLOW) &&\n\t\t\t(xpd->used & XPERMS_AUDITALLOW))\n\t\trc = security_xperm_test(xpd->auditallow->p, perm);\n\telse if ((which == XPERMS_DONTAUDIT) &&\n\t\t\t(xpd->used & XPERMS_DONTAUDIT))\n\t\trc = security_xperm_test(xpd->dontaudit->p, perm);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "denied"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic inline u32 avc_xperms_audit_required(u32 requested,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms_decision *xpd,\n\t\t\t\t\tu8 perm,\n\t\t\t\t\tint result,\n\t\t\t\t\tu32 *deniedp)\n{\n\tu32 denied, audited;\n\n\tdenied = requested & ~avd->allowed;\n\tif (unlikely(denied)) {\n\t\taudited = denied & avd->auditdeny;\n\t\tif (audited && xpd) {\n\t\t\tif (avc_xperms_has_perm(xpd, perm, XPERMS_DONTAUDIT))\n\t\t\t\taudited &= ~requested;\n\t\t}\n\t} else if (result) {\n\t\taudited = denied = requested;\n\t} else {\n\t\taudited = requested & avd->auditallow;\n\t\tif (audited && xpd) {\n\t\t\tif (!avc_xperms_has_perm(xpd, perm, XPERMS_AUDITALLOW))\n\t\t\t\taudited &= ~requested;\n\t\t}\n\t}\n\n\t*deniedp = denied;\n\treturn audited;\n}"
  },
  {
    "function_name": "avc_xperms_populate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "403-433",
    "snippet": "static int avc_xperms_populate(struct avc_node *node,\n\t\t\t\tstruct avc_xperms_node *src)\n{\n\tstruct avc_xperms_node *dest;\n\tstruct avc_xperms_decision_node *dest_xpd;\n\tstruct avc_xperms_decision_node *src_xpd;\n\n\tif (src->xp.len == 0)\n\t\treturn 0;\n\tdest = avc_xperms_alloc();\n\tif (!dest)\n\t\treturn -ENOMEM;\n\n\tmemcpy(dest->xp.drivers.p, src->xp.drivers.p, sizeof(dest->xp.drivers.p));\n\tdest->xp.len = src->xp.len;\n\n\t/* for each source xpd allocate a destination xpd and copy */\n\tlist_for_each_entry(src_xpd, &src->xpd_head, xpd_list) {\n\t\tdest_xpd = avc_xperms_decision_alloc(src_xpd->xpd.used);\n\t\tif (!dest_xpd)\n\t\t\tgoto error;\n\t\tavc_copy_xperms_decision(&dest_xpd->xpd, &src_xpd->xpd);\n\t\tlist_add(&dest_xpd->xpd_list, &dest->xpd_head);\n\t}\n\tnode->ae.xp_node = dest;\n\treturn 0;\nerror:\n\tavc_xperms_free(dest);\n\treturn -ENOMEM;\n\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_xperms_free",
          "args": [
            "dest"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "290-302",
          "snippet": "static void avc_xperms_free(struct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node, *tmp;\n\n\tif (!xp_node)\n\t\treturn;\n\n\tlist_for_each_entry_safe(xpd_node, tmp, &xp_node->xpd_head, xpd_list) {\n\t\tlist_del(&xpd_node->xpd_list);\n\t\tavc_xperms_decision_free(xpd_node);\n\t}\n\tkmem_cache_free(avc_xperms_cachep, xp_node);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avc_xperms_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_xperms_cachep;\nstatic noinline struct;\n\nstatic void avc_xperms_free(struct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node, *tmp;\n\n\tif (!xp_node)\n\t\treturn;\n\n\tlist_for_each_entry_safe(xpd_node, tmp, &xp_node->xpd_head, xpd_list) {\n\t\tlist_del(&xpd_node->xpd_list);\n\t\tavc_xperms_decision_free(xpd_node);\n\t}\n\tkmem_cache_free(avc_xperms_cachep, xp_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dest_xpd->xpd_list",
            "&dest->xpd_head"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_copy_xperms_decision",
          "args": [
            "&dest_xpd->xpd",
            "&src_xpd->xpd"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "avc_copy_xperms_decision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "304-318",
          "snippet": "static void avc_copy_xperms_decision(struct extended_perms_decision *dest,\n\t\t\t\t\tstruct extended_perms_decision *src)\n{\n\tdest->driver = src->driver;\n\tdest->used = src->used;\n\tif (dest->used & XPERMS_ALLOWED)\n\t\tmemcpy(dest->allowed->p, src->allowed->p,\n\t\t\t\tsizeof(src->allowed->p));\n\tif (dest->used & XPERMS_AUDITALLOW)\n\t\tmemcpy(dest->auditallow->p, src->auditallow->p,\n\t\t\t\tsizeof(src->auditallow->p));\n\tif (dest->used & XPERMS_DONTAUDIT)\n\t\tmemcpy(dest->dontaudit->p, src->dontaudit->p,\n\t\t\t\tsizeof(src->dontaudit->p));\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_copy_xperms_decision(struct extended_perms_decision *dest,\n\t\t\t\t\tstruct extended_perms_decision *src)\n{\n\tdest->driver = src->driver;\n\tdest->used = src->used;\n\tif (dest->used & XPERMS_ALLOWED)\n\t\tmemcpy(dest->allowed->p, src->allowed->p,\n\t\t\t\tsizeof(src->allowed->p));\n\tif (dest->used & XPERMS_AUDITALLOW)\n\t\tmemcpy(dest->auditallow->p, src->auditallow->p,\n\t\t\t\tsizeof(src->auditallow->p));\n\tif (dest->used & XPERMS_DONTAUDIT)\n\t\tmemcpy(dest->dontaudit->p, src->dontaudit->p,\n\t\t\t\tsizeof(src->dontaudit->p));\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_xperms_decision_alloc",
          "args": [
            "src_xpd->xpd.used"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_decision_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "343-376",
          "snippet": "static struct avc_xperms_decision_node\n\t\t*avc_xperms_decision_alloc(u8 which)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\tstruct extended_perms_decision *xpd;\n\n\txpd_node = kmem_cache_zalloc(avc_xperms_decision_cachep, GFP_NOWAIT);\n\tif (!xpd_node)\n\t\treturn NULL;\n\n\txpd = &xpd_node->xpd;\n\tif (which & XPERMS_ALLOWED) {\n\t\txpd->allowed = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->allowed)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_AUDITALLOW) {\n\t\txpd->auditallow = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->auditallow)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_DONTAUDIT) {\n\t\txpd->dontaudit = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->dontaudit)\n\t\t\tgoto error;\n\t}\n\treturn xpd_node;\nerror:\n\tavc_xperms_decision_free(xpd_node);\n\treturn NULL;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avc_xperms_data_cachep;",
            "static struct kmem_cache *avc_xperms_decision_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_xperms_data_cachep;\nstatic struct kmem_cache *avc_xperms_decision_cachep;\nstatic noinline struct;\n\nstatic struct avc_xperms_decision_node\n\t\t*avc_xperms_decision_alloc(u8 which)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\tstruct extended_perms_decision *xpd;\n\n\txpd_node = kmem_cache_zalloc(avc_xperms_decision_cachep, GFP_NOWAIT);\n\tif (!xpd_node)\n\t\treturn NULL;\n\n\txpd = &xpd_node->xpd;\n\tif (which & XPERMS_ALLOWED) {\n\t\txpd->allowed = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->allowed)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_AUDITALLOW) {\n\t\txpd->auditallow = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->auditallow)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_DONTAUDIT) {\n\t\txpd->dontaudit = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->dontaudit)\n\t\t\tgoto error;\n\t}\n\treturn xpd_node;\nerror:\n\tavc_xperms_decision_free(xpd_node);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "src_xpd",
            "&src->xpd_head",
            "xpd_list"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest->xp.drivers.p",
            "src->xp.drivers.p",
            "sizeof(dest->xp.drivers.p)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_xperms_alloc",
          "args": [],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "392-401",
          "snippet": "static struct avc_xperms_node *avc_xperms_alloc(void)\n{\n\tstruct avc_xperms_node *xp_node;\n\n\txp_node = kmem_cache_zalloc(avc_xperms_cachep, GFP_NOWAIT);\n\tif (!xp_node)\n\t\treturn xp_node;\n\tINIT_LIST_HEAD(&xp_node->xpd_head);\n\treturn xp_node;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avc_xperms_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_xperms_cachep;\nstatic noinline struct;\n\nstatic struct avc_xperms_node *avc_xperms_alloc(void)\n{\n\tstruct avc_xperms_node *xp_node;\n\n\txp_node = kmem_cache_zalloc(avc_xperms_cachep, GFP_NOWAIT);\n\tif (!xp_node)\n\t\treturn xp_node;\n\tINIT_LIST_HEAD(&xp_node->xpd_head);\n\treturn xp_node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic int avc_xperms_populate(struct avc_node *node,\n\t\t\t\tstruct avc_xperms_node *src)\n{\n\tstruct avc_xperms_node *dest;\n\tstruct avc_xperms_decision_node *dest_xpd;\n\tstruct avc_xperms_decision_node *src_xpd;\n\n\tif (src->xp.len == 0)\n\t\treturn 0;\n\tdest = avc_xperms_alloc();\n\tif (!dest)\n\t\treturn -ENOMEM;\n\n\tmemcpy(dest->xp.drivers.p, src->xp.drivers.p, sizeof(dest->xp.drivers.p));\n\tdest->xp.len = src->xp.len;\n\n\t/* for each source xpd allocate a destination xpd and copy */\n\tlist_for_each_entry(src_xpd, &src->xpd_head, xpd_list) {\n\t\tdest_xpd = avc_xperms_decision_alloc(src_xpd->xpd.used);\n\t\tif (!dest_xpd)\n\t\t\tgoto error;\n\t\tavc_copy_xperms_decision(&dest_xpd->xpd, &src_xpd->xpd);\n\t\tlist_add(&dest_xpd->xpd_list, &dest->xpd_head);\n\t}\n\tnode->ae.xp_node = dest;\n\treturn 0;\nerror:\n\tavc_xperms_free(dest);\n\treturn -ENOMEM;\n\n}"
  },
  {
    "function_name": "avc_xperms_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "392-401",
    "snippet": "static struct avc_xperms_node *avc_xperms_alloc(void)\n{\n\tstruct avc_xperms_node *xp_node;\n\n\txp_node = kmem_cache_zalloc(avc_xperms_cachep, GFP_NOWAIT);\n\tif (!xp_node)\n\t\treturn xp_node;\n\tINIT_LIST_HEAD(&xp_node->xpd_head);\n\treturn xp_node;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *avc_xperms_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&xp_node->xpd_head"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "avc_xperms_cachep",
            "GFP_NOWAIT"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_xperms_cachep;\nstatic noinline struct;\n\nstatic struct avc_xperms_node *avc_xperms_alloc(void)\n{\n\tstruct avc_xperms_node *xp_node;\n\n\txp_node = kmem_cache_zalloc(avc_xperms_cachep, GFP_NOWAIT);\n\tif (!xp_node)\n\t\treturn xp_node;\n\tINIT_LIST_HEAD(&xp_node->xpd_head);\n\treturn xp_node;\n}"
  },
  {
    "function_name": "avc_add_xperms_decision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "378-390",
    "snippet": "static int avc_add_xperms_decision(struct avc_node *node,\n\t\t\tstruct extended_perms_decision *src)\n{\n\tstruct avc_xperms_decision_node *dest_xpd;\n\n\tnode->ae.xp_node->xp.len++;\n\tdest_xpd = avc_xperms_decision_alloc(src->used);\n\tif (!dest_xpd)\n\t\treturn -ENOMEM;\n\tavc_copy_xperms_decision(&dest_xpd->xpd, src);\n\tlist_add(&dest_xpd->xpd_list, &node->ae.xp_node->xpd_head);\n\treturn 0;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dest_xpd->xpd_list",
            "&node->ae.xp_node->xpd_head"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_copy_xperms_decision",
          "args": [
            "&dest_xpd->xpd",
            "src"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "avc_copy_xperms_decision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "304-318",
          "snippet": "static void avc_copy_xperms_decision(struct extended_perms_decision *dest,\n\t\t\t\t\tstruct extended_perms_decision *src)\n{\n\tdest->driver = src->driver;\n\tdest->used = src->used;\n\tif (dest->used & XPERMS_ALLOWED)\n\t\tmemcpy(dest->allowed->p, src->allowed->p,\n\t\t\t\tsizeof(src->allowed->p));\n\tif (dest->used & XPERMS_AUDITALLOW)\n\t\tmemcpy(dest->auditallow->p, src->auditallow->p,\n\t\t\t\tsizeof(src->auditallow->p));\n\tif (dest->used & XPERMS_DONTAUDIT)\n\t\tmemcpy(dest->dontaudit->p, src->dontaudit->p,\n\t\t\t\tsizeof(src->dontaudit->p));\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_copy_xperms_decision(struct extended_perms_decision *dest,\n\t\t\t\t\tstruct extended_perms_decision *src)\n{\n\tdest->driver = src->driver;\n\tdest->used = src->used;\n\tif (dest->used & XPERMS_ALLOWED)\n\t\tmemcpy(dest->allowed->p, src->allowed->p,\n\t\t\t\tsizeof(src->allowed->p));\n\tif (dest->used & XPERMS_AUDITALLOW)\n\t\tmemcpy(dest->auditallow->p, src->auditallow->p,\n\t\t\t\tsizeof(src->auditallow->p));\n\tif (dest->used & XPERMS_DONTAUDIT)\n\t\tmemcpy(dest->dontaudit->p, src->dontaudit->p,\n\t\t\t\tsizeof(src->dontaudit->p));\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_xperms_decision_alloc",
          "args": [
            "src->used"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_decision_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "343-376",
          "snippet": "static struct avc_xperms_decision_node\n\t\t*avc_xperms_decision_alloc(u8 which)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\tstruct extended_perms_decision *xpd;\n\n\txpd_node = kmem_cache_zalloc(avc_xperms_decision_cachep, GFP_NOWAIT);\n\tif (!xpd_node)\n\t\treturn NULL;\n\n\txpd = &xpd_node->xpd;\n\tif (which & XPERMS_ALLOWED) {\n\t\txpd->allowed = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->allowed)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_AUDITALLOW) {\n\t\txpd->auditallow = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->auditallow)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_DONTAUDIT) {\n\t\txpd->dontaudit = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->dontaudit)\n\t\t\tgoto error;\n\t}\n\treturn xpd_node;\nerror:\n\tavc_xperms_decision_free(xpd_node);\n\treturn NULL;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avc_xperms_data_cachep;",
            "static struct kmem_cache *avc_xperms_decision_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_xperms_data_cachep;\nstatic struct kmem_cache *avc_xperms_decision_cachep;\nstatic noinline struct;\n\nstatic struct avc_xperms_decision_node\n\t\t*avc_xperms_decision_alloc(u8 which)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\tstruct extended_perms_decision *xpd;\n\n\txpd_node = kmem_cache_zalloc(avc_xperms_decision_cachep, GFP_NOWAIT);\n\tif (!xpd_node)\n\t\treturn NULL;\n\n\txpd = &xpd_node->xpd;\n\tif (which & XPERMS_ALLOWED) {\n\t\txpd->allowed = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->allowed)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_AUDITALLOW) {\n\t\txpd->auditallow = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->auditallow)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_DONTAUDIT) {\n\t\txpd->dontaudit = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->dontaudit)\n\t\t\tgoto error;\n\t}\n\treturn xpd_node;\nerror:\n\tavc_xperms_decision_free(xpd_node);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic int avc_add_xperms_decision(struct avc_node *node,\n\t\t\tstruct extended_perms_decision *src)\n{\n\tstruct avc_xperms_decision_node *dest_xpd;\n\n\tnode->ae.xp_node->xp.len++;\n\tdest_xpd = avc_xperms_decision_alloc(src->used);\n\tif (!dest_xpd)\n\t\treturn -ENOMEM;\n\tavc_copy_xperms_decision(&dest_xpd->xpd, src);\n\tlist_add(&dest_xpd->xpd_list, &node->ae.xp_node->xpd_head);\n\treturn 0;\n}"
  },
  {
    "function_name": "avc_xperms_decision_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "343-376",
    "snippet": "static struct avc_xperms_decision_node\n\t\t*avc_xperms_decision_alloc(u8 which)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\tstruct extended_perms_decision *xpd;\n\n\txpd_node = kmem_cache_zalloc(avc_xperms_decision_cachep, GFP_NOWAIT);\n\tif (!xpd_node)\n\t\treturn NULL;\n\n\txpd = &xpd_node->xpd;\n\tif (which & XPERMS_ALLOWED) {\n\t\txpd->allowed = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->allowed)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_AUDITALLOW) {\n\t\txpd->auditallow = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->auditallow)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_DONTAUDIT) {\n\t\txpd->dontaudit = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->dontaudit)\n\t\t\tgoto error;\n\t}\n\treturn xpd_node;\nerror:\n\tavc_xperms_decision_free(xpd_node);\n\treturn NULL;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *avc_xperms_data_cachep;",
      "static struct kmem_cache *avc_xperms_decision_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_xperms_decision_free",
          "args": [
            "xpd_node"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_decision_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "276-288",
          "snippet": "static void avc_xperms_decision_free(struct avc_xperms_decision_node *xpd_node)\n{\n\tstruct extended_perms_decision *xpd;\n\n\txpd = &xpd_node->xpd;\n\tif (xpd->allowed)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->allowed);\n\tif (xpd->auditallow)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->auditallow);\n\tif (xpd->dontaudit)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->dontaudit);\n\tkmem_cache_free(avc_xperms_decision_cachep, xpd_node);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avc_xperms_data_cachep;",
            "static struct kmem_cache *avc_xperms_decision_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_xperms_data_cachep;\nstatic struct kmem_cache *avc_xperms_decision_cachep;\nstatic noinline struct;\n\nstatic void avc_xperms_decision_free(struct avc_xperms_decision_node *xpd_node)\n{\n\tstruct extended_perms_decision *xpd;\n\n\txpd = &xpd_node->xpd;\n\tif (xpd->allowed)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->allowed);\n\tif (xpd->auditallow)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->auditallow);\n\tif (xpd->dontaudit)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->dontaudit);\n\tkmem_cache_free(avc_xperms_decision_cachep, xpd_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "avc_xperms_data_cachep",
            "GFP_NOWAIT"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "avc_xperms_data_cachep",
            "GFP_NOWAIT"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "avc_xperms_data_cachep",
            "GFP_NOWAIT"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "avc_xperms_decision_cachep",
            "GFP_NOWAIT"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_xperms_data_cachep;\nstatic struct kmem_cache *avc_xperms_decision_cachep;\nstatic noinline struct;\n\nstatic struct avc_xperms_decision_node\n\t\t*avc_xperms_decision_alloc(u8 which)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\tstruct extended_perms_decision *xpd;\n\n\txpd_node = kmem_cache_zalloc(avc_xperms_decision_cachep, GFP_NOWAIT);\n\tif (!xpd_node)\n\t\treturn NULL;\n\n\txpd = &xpd_node->xpd;\n\tif (which & XPERMS_ALLOWED) {\n\t\txpd->allowed = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->allowed)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_AUDITALLOW) {\n\t\txpd->auditallow = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->auditallow)\n\t\t\tgoto error;\n\t}\n\tif (which & XPERMS_DONTAUDIT) {\n\t\txpd->dontaudit = kmem_cache_zalloc(avc_xperms_data_cachep,\n\t\t\t\t\t\tGFP_NOWAIT);\n\t\tif (!xpd->dontaudit)\n\t\t\tgoto error;\n\t}\n\treturn xpd_node;\nerror:\n\tavc_xperms_decision_free(xpd_node);\n\treturn NULL;\n}"
  },
  {
    "function_name": "avc_quick_copy_xperms_decision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "324-341",
    "snippet": "static inline void avc_quick_copy_xperms_decision(u8 perm,\n\t\t\tstruct extended_perms_decision *dest,\n\t\t\tstruct extended_perms_decision *src)\n{\n\t/*\n\t * compute index of the u32 of the 256 bits (8 u32s) that contain this\n\t * command permission\n\t */\n\tu8 i = perm >> 5;\n\n\tdest->used = src->used;\n\tif (dest->used & XPERMS_ALLOWED)\n\t\tdest->allowed->p[i] = src->allowed->p[i];\n\tif (dest->used & XPERMS_AUDITALLOW)\n\t\tdest->auditallow->p[i] = src->auditallow->p[i];\n\tif (dest->used & XPERMS_DONTAUDIT)\n\t\tdest->dontaudit->p[i] = src->dontaudit->p[i];\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic inline void avc_quick_copy_xperms_decision(u8 perm,\n\t\t\tstruct extended_perms_decision *dest,\n\t\t\tstruct extended_perms_decision *src)\n{\n\t/*\n\t * compute index of the u32 of the 256 bits (8 u32s) that contain this\n\t * command permission\n\t */\n\tu8 i = perm >> 5;\n\n\tdest->used = src->used;\n\tif (dest->used & XPERMS_ALLOWED)\n\t\tdest->allowed->p[i] = src->allowed->p[i];\n\tif (dest->used & XPERMS_AUDITALLOW)\n\t\tdest->auditallow->p[i] = src->auditallow->p[i];\n\tif (dest->used & XPERMS_DONTAUDIT)\n\t\tdest->dontaudit->p[i] = src->dontaudit->p[i];\n}"
  },
  {
    "function_name": "avc_copy_xperms_decision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "304-318",
    "snippet": "static void avc_copy_xperms_decision(struct extended_perms_decision *dest,\n\t\t\t\t\tstruct extended_perms_decision *src)\n{\n\tdest->driver = src->driver;\n\tdest->used = src->used;\n\tif (dest->used & XPERMS_ALLOWED)\n\t\tmemcpy(dest->allowed->p, src->allowed->p,\n\t\t\t\tsizeof(src->allowed->p));\n\tif (dest->used & XPERMS_AUDITALLOW)\n\t\tmemcpy(dest->auditallow->p, src->auditallow->p,\n\t\t\t\tsizeof(src->auditallow->p));\n\tif (dest->used & XPERMS_DONTAUDIT)\n\t\tmemcpy(dest->dontaudit->p, src->dontaudit->p,\n\t\t\t\tsizeof(src->dontaudit->p));\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest->dontaudit->p",
            "src->dontaudit->p",
            "sizeof(src->dontaudit->p)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest->auditallow->p",
            "src->auditallow->p",
            "sizeof(src->auditallow->p)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest->allowed->p",
            "src->allowed->p",
            "sizeof(src->allowed->p)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_copy_xperms_decision(struct extended_perms_decision *dest,\n\t\t\t\t\tstruct extended_perms_decision *src)\n{\n\tdest->driver = src->driver;\n\tdest->used = src->used;\n\tif (dest->used & XPERMS_ALLOWED)\n\t\tmemcpy(dest->allowed->p, src->allowed->p,\n\t\t\t\tsizeof(src->allowed->p));\n\tif (dest->used & XPERMS_AUDITALLOW)\n\t\tmemcpy(dest->auditallow->p, src->auditallow->p,\n\t\t\t\tsizeof(src->auditallow->p));\n\tif (dest->used & XPERMS_DONTAUDIT)\n\t\tmemcpy(dest->dontaudit->p, src->dontaudit->p,\n\t\t\t\tsizeof(src->dontaudit->p));\n}"
  },
  {
    "function_name": "avc_xperms_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "290-302",
    "snippet": "static void avc_xperms_free(struct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node, *tmp;\n\n\tif (!xp_node)\n\t\treturn;\n\n\tlist_for_each_entry_safe(xpd_node, tmp, &xp_node->xpd_head, xpd_list) {\n\t\tlist_del(&xpd_node->xpd_list);\n\t\tavc_xperms_decision_free(xpd_node);\n\t}\n\tkmem_cache_free(avc_xperms_cachep, xp_node);\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *avc_xperms_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "avc_xperms_cachep",
            "xp_node"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_xperms_decision_free",
          "args": [
            "xpd_node"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_decision_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "276-288",
          "snippet": "static void avc_xperms_decision_free(struct avc_xperms_decision_node *xpd_node)\n{\n\tstruct extended_perms_decision *xpd;\n\n\txpd = &xpd_node->xpd;\n\tif (xpd->allowed)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->allowed);\n\tif (xpd->auditallow)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->auditallow);\n\tif (xpd->dontaudit)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->dontaudit);\n\tkmem_cache_free(avc_xperms_decision_cachep, xpd_node);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avc_xperms_data_cachep;",
            "static struct kmem_cache *avc_xperms_decision_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_xperms_data_cachep;\nstatic struct kmem_cache *avc_xperms_decision_cachep;\nstatic noinline struct;\n\nstatic void avc_xperms_decision_free(struct avc_xperms_decision_node *xpd_node)\n{\n\tstruct extended_perms_decision *xpd;\n\n\txpd = &xpd_node->xpd;\n\tif (xpd->allowed)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->allowed);\n\tif (xpd->auditallow)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->auditallow);\n\tif (xpd->dontaudit)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->dontaudit);\n\tkmem_cache_free(avc_xperms_decision_cachep, xpd_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&xpd_node->xpd_list"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "xpd_node",
            "tmp",
            "&xp_node->xpd_head",
            "xpd_list"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_xperms_cachep;\nstatic noinline struct;\n\nstatic void avc_xperms_free(struct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node, *tmp;\n\n\tif (!xp_node)\n\t\treturn;\n\n\tlist_for_each_entry_safe(xpd_node, tmp, &xp_node->xpd_head, xpd_list) {\n\t\tlist_del(&xpd_node->xpd_list);\n\t\tavc_xperms_decision_free(xpd_node);\n\t}\n\tkmem_cache_free(avc_xperms_cachep, xp_node);\n}"
  },
  {
    "function_name": "avc_xperms_decision_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "276-288",
    "snippet": "static void avc_xperms_decision_free(struct avc_xperms_decision_node *xpd_node)\n{\n\tstruct extended_perms_decision *xpd;\n\n\txpd = &xpd_node->xpd;\n\tif (xpd->allowed)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->allowed);\n\tif (xpd->auditallow)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->auditallow);\n\tif (xpd->dontaudit)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->dontaudit);\n\tkmem_cache_free(avc_xperms_decision_cachep, xpd_node);\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *avc_xperms_data_cachep;",
      "static struct kmem_cache *avc_xperms_decision_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "avc_xperms_decision_cachep",
            "xpd_node"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "avc_xperms_data_cachep",
            "xpd->dontaudit"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "avc_xperms_data_cachep",
            "xpd->auditallow"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "avc_xperms_data_cachep",
            "xpd->allowed"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *avc_xperms_data_cachep;\nstatic struct kmem_cache *avc_xperms_decision_cachep;\nstatic noinline struct;\n\nstatic void avc_xperms_decision_free(struct avc_xperms_decision_node *xpd_node)\n{\n\tstruct extended_perms_decision *xpd;\n\n\txpd = &xpd_node->xpd;\n\tif (xpd->allowed)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->allowed);\n\tif (xpd->auditallow)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->auditallow);\n\tif (xpd->dontaudit)\n\t\tkmem_cache_free(avc_xperms_data_cachep, xpd->dontaudit);\n\tkmem_cache_free(avc_xperms_decision_cachep, xpd_node);\n}"
  },
  {
    "function_name": "avc_xperms_allow_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "266-274",
    "snippet": "static void avc_xperms_allow_perm(struct avc_xperms_node *xp_node,\n\t\t\t\tu8 driver, u8 perm)\n{\n\tstruct extended_perms_decision *xpd;\n\tsecurity_xperm_set(xp_node->xp.drivers.p, driver);\n\txpd = avc_xperms_decision_lookup(driver, xp_node);\n\tif (xpd && xpd->allowed)\n\t\tsecurity_xperm_set(xpd->allowed->p, perm);\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_xperm_set",
          "args": [
            "xpd->allowed->p",
            "perm"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_xperms_decision_lookup",
          "args": [
            "driver",
            "xp_node"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "avc_xperms_decision_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "236-246",
          "snippet": "static struct extended_perms_decision *avc_xperms_decision_lookup(u8 driver,\n\t\t\t\t\tstruct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\n\tlist_for_each_entry(xpd_node, &xp_node->xpd_head, xpd_list) {\n\t\tif (xpd_node->xpd.driver == driver)\n\t\t\treturn &xpd_node->xpd;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic struct extended_perms_decision *avc_xperms_decision_lookup(u8 driver,\n\t\t\t\t\tstruct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\n\tlist_for_each_entry(xpd_node, &xp_node->xpd_head, xpd_list) {\n\t\tif (xpd_node->xpd.driver == driver)\n\t\t\treturn &xpd_node->xpd;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_xperm_set",
          "args": [
            "xp_node->xp.drivers.p",
            "driver"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_xperms_allow_perm(struct avc_xperms_node *xp_node,\n\t\t\t\tu8 driver, u8 perm)\n{\n\tstruct extended_perms_decision *xpd;\n\tsecurity_xperm_set(xp_node->xp.drivers.p, driver);\n\txpd = avc_xperms_decision_lookup(driver, xp_node);\n\tif (xpd && xpd->allowed)\n\t\tsecurity_xperm_set(xpd->allowed->p, perm);\n}"
  },
  {
    "function_name": "avc_xperms_has_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "248-264",
    "snippet": "static inline unsigned int\navc_xperms_has_perm(struct extended_perms_decision *xpd,\n\t\t\t\t\tu8 perm, u8 which)\n{\n\tunsigned int rc = 0;\n\n\tif ((which == XPERMS_ALLOWED) &&\n\t\t\t(xpd->used & XPERMS_ALLOWED))\n\t\trc = security_xperm_test(xpd->allowed->p, perm);\n\telse if ((which == XPERMS_AUDITALLOW) &&\n\t\t\t(xpd->used & XPERMS_AUDITALLOW))\n\t\trc = security_xperm_test(xpd->auditallow->p, perm);\n\telse if ((which == XPERMS_DONTAUDIT) &&\n\t\t\t(xpd->used & XPERMS_DONTAUDIT))\n\t\trc = security_xperm_test(xpd->dontaudit->p, perm);\n\treturn rc;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_xperm_test",
          "args": [
            "xpd->dontaudit->p",
            "perm"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_xperm_test",
          "args": [
            "xpd->auditallow->p",
            "perm"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_xperm_test",
          "args": [
            "xpd->allowed->p",
            "perm"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int\navc_xperms_has_perm(struct extended_perms_decision *xpd,\n\t\t\t\t\tu8 perm, u8 which)\n{\n\tunsigned int rc = 0;\n\n\tif ((which == XPERMS_ALLOWED) &&\n\t\t\t(xpd->used & XPERMS_ALLOWED))\n\t\trc = security_xperm_test(xpd->allowed->p, perm);\n\telse if ((which == XPERMS_AUDITALLOW) &&\n\t\t\t(xpd->used & XPERMS_AUDITALLOW))\n\t\trc = security_xperm_test(xpd->auditallow->p, perm);\n\telse if ((which == XPERMS_DONTAUDIT) &&\n\t\t\t(xpd->used & XPERMS_DONTAUDIT))\n\t\trc = security_xperm_test(xpd->dontaudit->p, perm);\n\treturn rc;\n}"
  },
  {
    "function_name": "avc_xperms_decision_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "236-246",
    "snippet": "static struct extended_perms_decision *avc_xperms_decision_lookup(u8 driver,\n\t\t\t\t\tstruct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\n\tlist_for_each_entry(xpd_node, &xp_node->xpd_head, xpd_list) {\n\t\tif (xpd_node->xpd.driver == driver)\n\t\t\treturn &xpd_node->xpd;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "xpd_node",
            "&xp_node->xpd_head",
            "xpd_list"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic struct extended_perms_decision *avc_xperms_decision_lookup(u8 driver,\n\t\t\t\t\tstruct avc_xperms_node *xp_node)\n{\n\tstruct avc_xperms_decision_node *xpd_node;\n\n\tlist_for_each_entry(xpd_node, &xp_node->xpd_head, xpd_list) {\n\t\tif (xpd_node->xpd.driver == driver)\n\t\t\treturn &xpd_node->xpd;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "avc_get_hash_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "202-230",
    "snippet": "int avc_get_hash_stats(char *page)\n{\n\tint i, chain_len, max_chain_len, slots_used;\n\tstruct avc_node *node;\n\tstruct hlist_head *head;\n\n\trcu_read_lock();\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\thead = &avc_cache.slots[i];\n\t\tif (!hlist_empty(head)) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\thlist_for_each_entry_rcu(node, head, list)\n\t\t\t\tchain_len++;\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn scnprintf(page, PAGE_SIZE, \"entries: %d\\nbuckets used: %d/%d\\n\"\n\t\t\t \"longest chain: %d\\n\",\n\t\t\t atomic_read(&avc_cache.active_nodes),\n\t\t\t slots_used, AVC_CACHE_SLOTS, max_chain_len);\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define AVC_CACHE_SLOTS\t\t\t512"
    ],
    "globals_used": [
      "static struct avc_cache avc_cache;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "page",
            "PAGE_SIZE",
            "\"entries: %d\\nbuckets used: %d/%d\\n\"\n\t\t\t \"longest chain: %d\\n\"",
            "atomic_read(&avc_cache.active_nodes)",
            "slots_used",
            "AVC_CACHE_SLOTS",
            "max_chain_len"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&avc_cache.active_nodes"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "node",
            "head",
            "list"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#define AVC_CACHE_SLOTS\t\t\t512\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nint avc_get_hash_stats(char *page)\n{\n\tint i, chain_len, max_chain_len, slots_used;\n\tstruct avc_node *node;\n\tstruct hlist_head *head;\n\n\trcu_read_lock();\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\thead = &avc_cache.slots[i];\n\t\tif (!hlist_empty(head)) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\thlist_for_each_entry_rcu(node, head, list)\n\t\t\t\tchain_len++;\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn scnprintf(page, PAGE_SIZE, \"entries: %d\\nbuckets used: %d/%d\\n\"\n\t\t\t \"longest chain: %d\\n\",\n\t\t\t atomic_read(&avc_cache.active_nodes),\n\t\t\t slots_used, AVC_CACHE_SLOTS, max_chain_len);\n}"
  },
  {
    "function_name": "avc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "177-200",
    "snippet": "void __init avc_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\tINIT_HLIST_HEAD(&avc_cache.slots[i]);\n\t\tspin_lock_init(&avc_cache.slots_lock[i]);\n\t}\n\tatomic_set(&avc_cache.active_nodes, 0);\n\tatomic_set(&avc_cache.lru_hint, 0);\n\n\tavc_node_cachep = kmem_cache_create(\"avc_node\", sizeof(struct avc_node),\n\t\t\t\t\t0, SLAB_PANIC, NULL);\n\tavc_xperms_cachep = kmem_cache_create(\"avc_xperms_node\",\n\t\t\t\t\tsizeof(struct avc_xperms_node),\n\t\t\t\t\t0, SLAB_PANIC, NULL);\n\tavc_xperms_decision_cachep = kmem_cache_create(\n\t\t\t\t\t\"avc_xperms_decision_node\",\n\t\t\t\t\tsizeof(struct avc_xperms_decision_node),\n\t\t\t\t\t0, SLAB_PANIC, NULL);\n\tavc_xperms_data_cachep = kmem_cache_create(\"avc_xperms_data\",\n\t\t\t\t\tsizeof(struct extended_perms_data),\n\t\t\t\t\t0, SLAB_PANIC, NULL);\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define AVC_CACHE_SLOTS\t\t\t512"
    ],
    "globals_used": [
      "static struct avc_cache avc_cache;",
      "static struct kmem_cache *avc_node_cachep;",
      "static struct kmem_cache *avc_xperms_data_cachep;",
      "static struct kmem_cache *avc_xperms_decision_cachep;",
      "static struct kmem_cache *avc_xperms_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"avc_xperms_data\"",
            "sizeof(struct extended_perms_data)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"avc_xperms_decision_node\"",
            "sizeof(struct avc_xperms_decision_node)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"avc_xperms_node\"",
            "sizeof(struct avc_xperms_node)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"avc_node\"",
            "sizeof(struct avc_node)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&avc_cache.lru_hint",
            "0"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&avc_cache.active_nodes",
            "0"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&avc_cache.slots_lock[i]"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&avc_cache.slots[i]"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#define AVC_CACHE_SLOTS\t\t\t512\n\nstatic struct avc_cache avc_cache;\nstatic struct kmem_cache *avc_node_cachep;\nstatic struct kmem_cache *avc_xperms_data_cachep;\nstatic struct kmem_cache *avc_xperms_decision_cachep;\nstatic struct kmem_cache *avc_xperms_cachep;\nstatic noinline struct;\n\nvoid __init avc_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\tINIT_HLIST_HEAD(&avc_cache.slots[i]);\n\t\tspin_lock_init(&avc_cache.slots_lock[i]);\n\t}\n\tatomic_set(&avc_cache.active_nodes, 0);\n\tatomic_set(&avc_cache.lru_hint, 0);\n\n\tavc_node_cachep = kmem_cache_create(\"avc_node\", sizeof(struct avc_node),\n\t\t\t\t\t0, SLAB_PANIC, NULL);\n\tavc_xperms_cachep = kmem_cache_create(\"avc_xperms_node\",\n\t\t\t\t\tsizeof(struct avc_xperms_node),\n\t\t\t\t\t0, SLAB_PANIC, NULL);\n\tavc_xperms_decision_cachep = kmem_cache_create(\n\t\t\t\t\t\"avc_xperms_decision_node\",\n\t\t\t\t\tsizeof(struct avc_xperms_decision_node),\n\t\t\t\t\t0, SLAB_PANIC, NULL);\n\tavc_xperms_data_cachep = kmem_cache_create(\"avc_xperms_data\",\n\t\t\t\t\tsizeof(struct extended_perms_data),\n\t\t\t\t\t0, SLAB_PANIC, NULL);\n}"
  },
  {
    "function_name": "avc_dump_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "146-170",
    "snippet": "static void avc_dump_query(struct audit_buffer *ab, u32 ssid, u32 tsid, u16 tclass)\n{\n\tint rc;\n\tchar *scontext;\n\tu32 scontext_len;\n\n\trc = security_sid_to_context(ssid, &scontext, &scontext_len);\n\tif (rc)\n\t\taudit_log_format(ab, \"ssid=%d\", ssid);\n\telse {\n\t\taudit_log_format(ab, \"scontext=%s\", scontext);\n\t\tkfree(scontext);\n\t}\n\n\trc = security_sid_to_context(tsid, &scontext, &scontext_len);\n\tif (rc)\n\t\taudit_log_format(ab, \" tsid=%d\", tsid);\n\telse {\n\t\taudit_log_format(ab, \" tcontext=%s\", scontext);\n\t\tkfree(scontext);\n\t}\n\n\tBUG_ON(!tclass || tclass >= ARRAY_SIZE(secclass_map));\n\taudit_log_format(ab, \" tclass=%s\", secclass_map[tclass-1].name);\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" tclass=%s\"",
            "secclass_map[tclass-1].name"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tclass || tclass >= ARRAY_SIZE(secclass_map)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "secclass_map"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "scontext"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" tcontext=%s\"",
            "scontext"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" tsid=%d\"",
            "tsid"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sid_to_context",
          "args": [
            "tsid",
            "&scontext",
            "&scontext_len"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "security_sid_to_context_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1314-1317",
          "snippet": "int security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "scontext"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"scontext=%s\"",
            "scontext"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"ssid=%d\"",
            "ssid"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_dump_query(struct audit_buffer *ab, u32 ssid, u32 tsid, u16 tclass)\n{\n\tint rc;\n\tchar *scontext;\n\tu32 scontext_len;\n\n\trc = security_sid_to_context(ssid, &scontext, &scontext_len);\n\tif (rc)\n\t\taudit_log_format(ab, \"ssid=%d\", ssid);\n\telse {\n\t\taudit_log_format(ab, \"scontext=%s\", scontext);\n\t\tkfree(scontext);\n\t}\n\n\trc = security_sid_to_context(tsid, &scontext, &scontext_len);\n\tif (rc)\n\t\taudit_log_format(ab, \" tsid=%d\", tsid);\n\telse {\n\t\taudit_log_format(ab, \" tcontext=%s\", scontext);\n\t\tkfree(scontext);\n\t}\n\n\tBUG_ON(!tclass || tclass >= ARRAY_SIZE(secclass_map));\n\taudit_log_format(ab, \" tclass=%s\", secclass_map[tclass-1].name);\n}"
  },
  {
    "function_name": "avc_dump_av",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "109-138",
    "snippet": "static void avc_dump_av(struct audit_buffer *ab, u16 tclass, u32 av)\n{\n\tconst char **perms;\n\tint i, perm;\n\n\tif (av == 0) {\n\t\taudit_log_format(ab, \" null\");\n\t\treturn;\n\t}\n\n\tBUG_ON(!tclass || tclass >= ARRAY_SIZE(secclass_map));\n\tperms = secclass_map[tclass-1].perms;\n\n\taudit_log_format(ab, \" {\");\n\ti = 0;\n\tperm = 1;\n\twhile (i < (sizeof(av) * 8)) {\n\t\tif ((perm & av) && perms[i]) {\n\t\t\taudit_log_format(ab, \" %s\", perms[i]);\n\t\t\tav &= ~perm;\n\t\t}\n\t\ti++;\n\t\tperm <<= 1;\n\t}\n\n\tif (av)\n\t\taudit_log_format(ab, \" 0x%x\", av);\n\n\taudit_log_format(ab, \" }\");\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" }\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" 0x%x\"",
            "av"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" %s\"",
            "perms[i]"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" {\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tclass || tclass >= ARRAY_SIZE(secclass_map)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "secclass_map"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" null\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nstatic void avc_dump_av(struct audit_buffer *ab, u16 tclass, u32 av)\n{\n\tconst char **perms;\n\tint i, perm;\n\n\tif (av == 0) {\n\t\taudit_log_format(ab, \" null\");\n\t\treturn;\n\t}\n\n\tBUG_ON(!tclass || tclass >= ARRAY_SIZE(secclass_map));\n\tperms = secclass_map[tclass-1].perms;\n\n\taudit_log_format(ab, \" {\");\n\ti = 0;\n\tperm = 1;\n\twhile (i < (sizeof(av) * 8)) {\n\t\tif ((perm & av) && perms[i]) {\n\t\t\taudit_log_format(ab, \" %s\", perms[i]);\n\t\t\tav &= ~perm;\n\t\t}\n\t\ti++;\n\t\tperm <<= 1;\n\t}\n\n\tif (av)\n\t\taudit_log_format(ab, \" 0x%x\", av);\n\n\taudit_log_format(ab, \" }\");\n}"
  },
  {
    "function_name": "avc_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
    "lines": "99-102",
    "snippet": "static inline int avc_hash(u32 ssid, u32 tsid, u16 tclass)\n{\n\treturn (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);\n}",
    "includes": [
      "#include \"classmap.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include <net/ipv6.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/audit.h>",
      "#include <linux/ip.h>",
      "#include <net/af_unix.h>",
      "#include <linux/un.h>",
      "#include <net/sock.h>",
      "#include <linux/list.h>",
      "#include <linux/percpu.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/init.h>",
      "#include <linux/dcache.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define AVC_CACHE_SLOTS\t\t\t512"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#define AVC_CACHE_SLOTS\t\t\t512\n\nstatic inline int avc_hash(u32 ssid, u32 tsid, u16 tclass)\n{\n\treturn (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);\n}"
  }
]