[
  {
    "function_name": "exit_sel_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1936-1941",
    "snippet": "void exit_sel_fs(void)\n{\n\tsysfs_remove_mount_point(fs_kobj, \"selinux\");\n\tkern_unmount(selinuxfs_mount);\n\tunregister_filesystem(&sel_fs_type);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type sel_fs_type = {\n\t.name\t\t= \"selinuxfs\",\n\t.mount\t\t= sel_mount,\n\t.kill_sb\t= kill_litter_super,\n};",
      "struct vfsmount *selinuxfs_mount;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&sel_fs_type"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_unmount",
          "args": [
            "selinuxfs_mount"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_remove_mount_point",
          "args": [
            "fs_kobj",
            "\"selinux\""
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct file_system_type sel_fs_type = {\n\t.name\t\t= \"selinuxfs\",\n\t.mount\t\t= sel_mount,\n\t.kill_sb\t= kill_litter_super,\n};\nstruct vfsmount *selinuxfs_mount;\n\nvoid exit_sel_fs(void)\n{\n\tsysfs_remove_mount_point(fs_kobj, \"selinux\");\n\tkern_unmount(selinuxfs_mount);\n\tunregister_filesystem(&sel_fs_type);\n}"
  },
  {
    "function_name": "init_sel_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1906-1931",
    "snippet": "static int __init init_sel_fs(void)\n{\n\tint err;\n\n\tif (!selinux_enabled)\n\t\treturn 0;\n\n\terr = sysfs_create_mount_point(fs_kobj, \"selinux\");\n\tif (err)\n\t\treturn err;\n\n\terr = register_filesystem(&sel_fs_type);\n\tif (err) {\n\t\tsysfs_remove_mount_point(fs_kobj, \"selinux\");\n\t\treturn err;\n\t}\n\n\tselinux_null.mnt = selinuxfs_mount = kern_mount(&sel_fs_type);\n\tif (IS_ERR(selinuxfs_mount)) {\n\t\tprintk(KERN_ERR \"selinuxfs:  could not mount!\\n\");\n\t\terr = PTR_ERR(selinuxfs_mount);\n\t\tselinuxfs_mount = NULL;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct path selinux_null;",
      "static struct file_system_type sel_fs_type = {\n\t.name\t\t= \"selinuxfs\",\n\t.mount\t\t= sel_mount,\n\t.kill_sb\t= kill_litter_super,\n};",
      "struct vfsmount *selinuxfs_mount;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "selinuxfs_mount"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"selinuxfs:  could not mount!\\n\""
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "selinuxfs_mount"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "&sel_fs_type"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_remove_mount_point",
          "args": [
            "fs_kobj",
            "\"selinux\""
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&sel_fs_type"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_mount_point",
          "args": [
            "fs_kobj",
            "\"selinux\""
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstruct path selinux_null;\nstatic struct file_system_type sel_fs_type = {\n\t.name\t\t= \"selinuxfs\",\n\t.mount\t\t= sel_mount,\n\t.kill_sb\t= kill_litter_super,\n};\nstruct vfsmount *selinuxfs_mount;\n\nstatic int __init init_sel_fs(void)\n{\n\tint err;\n\n\tif (!selinux_enabled)\n\t\treturn 0;\n\n\terr = sysfs_create_mount_point(fs_kobj, \"selinux\");\n\tif (err)\n\t\treturn err;\n\n\terr = register_filesystem(&sel_fs_type);\n\tif (err) {\n\t\tsysfs_remove_mount_point(fs_kobj, \"selinux\");\n\t\treturn err;\n\t}\n\n\tselinux_null.mnt = selinuxfs_mount = kern_mount(&sel_fs_type);\n\tif (IS_ERR(selinuxfs_mount)) {\n\t\tprintk(KERN_ERR \"selinuxfs:  could not mount!\\n\");\n\t\terr = PTR_ERR(selinuxfs_mount);\n\t\tselinuxfs_mount = NULL;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "sel_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1892-1896",
    "snippet": "static struct dentry *sel_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, sel_fill_super);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_single",
          "args": [
            "fs_type",
            "flags",
            "data",
            "sel_fill_super"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *sel_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, sel_fill_super);\n}"
  },
  {
    "function_name": "sel_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1792-1890",
    "snippet": "static int sel_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tint ret;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct inode_security_struct *isec;\n\n\tstatic const struct tree_descr selinux_files[] = {\n\t\t[SEL_LOAD] = {\"load\", &sel_load_ops, S_IRUSR|S_IWUSR},\n\t\t[SEL_ENFORCE] = {\"enforce\", &sel_enforce_ops, S_IRUGO|S_IWUSR},\n\t\t[SEL_CONTEXT] = {\"context\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_ACCESS] = {\"access\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_CREATE] = {\"create\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_RELABEL] = {\"relabel\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_USER] = {\"user\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_POLICYVERS] = {\"policyvers\", &sel_policyvers_ops, S_IRUGO},\n\t\t[SEL_COMMIT_BOOLS] = {\"commit_pending_bools\", &sel_commit_bools_ops, S_IWUSR},\n\t\t[SEL_MLS] = {\"mls\", &sel_mls_ops, S_IRUGO},\n\t\t[SEL_DISABLE] = {\"disable\", &sel_disable_ops, S_IWUSR},\n\t\t[SEL_MEMBER] = {\"member\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_CHECKREQPROT] = {\"checkreqprot\", &sel_checkreqprot_ops, S_IRUGO|S_IWUSR},\n\t\t[SEL_REJECT_UNKNOWN] = {\"reject_unknown\", &sel_handle_unknown_ops, S_IRUGO},\n\t\t[SEL_DENY_UNKNOWN] = {\"deny_unknown\", &sel_handle_unknown_ops, S_IRUGO},\n\t\t[SEL_STATUS] = {\"status\", &sel_handle_status_ops, S_IRUGO},\n\t\t[SEL_POLICY] = {\"policy\", &sel_policy_ops, S_IRUGO},\n\t\t[SEL_VALIDATE_TRANS] = {\"validatetrans\", &sel_transition_ops,\n\t\t\t\t\tS_IWUGO},\n\t\t/* last one */ {\"\"}\n\t};\n\tret = simple_fill_super(sb, SELINUX_MAGIC, selinux_files);\n\tif (ret)\n\t\tgoto err;\n\n\tbool_dir = sel_make_dir(sb->s_root, BOOL_DIR_NAME, &sel_last_ino);\n\tif (IS_ERR(bool_dir)) {\n\t\tret = PTR_ERR(bool_dir);\n\t\tbool_dir = NULL;\n\t\tgoto err;\n\t}\n\n\tret = -ENOMEM;\n\tdentry = d_alloc_name(sb->s_root, NULL_FILE_NAME);\n\tif (!dentry)\n\t\tgoto err;\n\n\tret = -ENOMEM;\n\tinode = sel_make_inode(sb, S_IFCHR | S_IRUGO | S_IWUGO);\n\tif (!inode)\n\t\tgoto err;\n\n\tinode->i_ino = ++sel_last_ino;\n\tisec = (struct inode_security_struct *)inode->i_security;\n\tisec->sid = SECINITSID_DEVNULL;\n\tisec->sclass = SECCLASS_CHR_FILE;\n\tisec->initialized = LABEL_INITIALIZED;\n\n\tinit_special_inode(inode, S_IFCHR | S_IRUGO | S_IWUGO, MKDEV(MEM_MAJOR, 3));\n\td_add(dentry, inode);\n\tselinux_null.dentry = dentry;\n\n\tdentry = sel_make_dir(sb->s_root, \"avc\", &sel_last_ino);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto err;\n\t}\n\n\tret = sel_make_avc_files(dentry);\n\tif (ret)\n\t\tgoto err;\n\n\tdentry = sel_make_dir(sb->s_root, \"initial_contexts\", &sel_last_ino);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto err;\n\t}\n\n\tret = sel_make_initcon_files(dentry);\n\tif (ret)\n\t\tgoto err;\n\n\tclass_dir = sel_make_dir(sb->s_root, \"class\", &sel_last_ino);\n\tif (IS_ERR(class_dir)) {\n\t\tret = PTR_ERR(class_dir);\n\t\tclass_dir = NULL;\n\t\tgoto err;\n\t}\n\n\tpolicycap_dir = sel_make_dir(sb->s_root, \"policy_capabilities\", &sel_last_ino);\n\tif (IS_ERR(policycap_dir)) {\n\t\tret = PTR_ERR(policycap_dir);\n\t\tpolicycap_dir = NULL;\n\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tprintk(KERN_ERR \"SELinux: %s:  failed while creating inodes\\n\",\n\t\t__func__);\n\treturn ret;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define NULL_FILE_NAME \"null\"",
      "#define BOOL_DIR_NAME \"booleans\""
    ],
    "globals_used": [
      "static struct dentry *bool_dir;",
      "static struct dentry *class_dir;",
      "static struct dentry *policycap_dir;",
      "static unsigned long sel_last_ino = SEL_INO_NEXT - 1;",
      "static const struct file_operations sel_enforce_ops = {\n\t.read\t\t= sel_read_enforce,\n\t.write\t\t= sel_write_enforce,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations sel_handle_unknown_ops = {\n\t.read\t\t= sel_read_handle_unknown,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations sel_handle_status_ops = {\n\t.open\t\t= sel_open_handle_status,\n\t.read\t\t= sel_read_handle_status,\n\t.mmap\t\t= sel_mmap_handle_status,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations sel_disable_ops = {\n\t.write\t\t= sel_write_disable,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations sel_policyvers_ops = {\n\t.read\t\t= sel_read_policyvers,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations sel_mls_ops = {\n\t.read\t\t= sel_read_mls,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations sel_policy_ops = {\n\t.open\t\t= sel_open_policy,\n\t.read\t\t= sel_read_policy,\n\t.mmap\t\t= sel_mmap_policy,\n\t.release\t= sel_release_policy,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations sel_load_ops = {\n\t.write\t\t= sel_write_load,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations sel_checkreqprot_ops = {\n\t.read\t\t= sel_read_checkreqprot,\n\t.write\t\t= sel_write_checkreqprot,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations sel_transition_ops = {\n\t.write\t\t= sel_write_validatetrans,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations transaction_ops = {\n\t.write\t\t= selinux_transaction_write,\n\t.read\t\t= simple_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations sel_commit_bools_ops = {\n\t.write\t\t= sel_commit_bools_write,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "struct path selinux_null;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  failed while creating inodes\\n\"",
            "__func__"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "policycap_dir"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "policycap_dir"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_dir",
          "args": [
            "sb->s_root",
            "\"policy_capabilities\"",
            "&sel_last_ino"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1765-1790",
          "snippet": "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino)\n{\n\tstruct dentry *dentry = d_alloc_name(dir, name);\n\tstruct inode *inode;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = sel_make_inode(dir->d_sb, S_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_ino = ++(*ino);\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_add(dentry, inode);\n\t/* bump link count on parent directory, too */\n\tinc_nlink(d_inode(dir));\n\n\treturn dentry;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino)\n{\n\tstruct dentry *dentry = d_alloc_name(dir, name);\n\tstruct inode *inode;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = sel_make_inode(dir->d_sb, S_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_ino = ++(*ino);\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_add(dentry, inode);\n\t/* bump link count on parent directory, too */\n\tinc_nlink(d_inode(dir));\n\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "class_dir"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "class_dir"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_initcon_files",
          "args": [
            "dentry"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_initcon_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1541-1562",
          "snippet": "static int sel_make_initcon_files(struct dentry *dir)\n{\n\tint i;\n\n\tfor (i = 1; i <= SECINITSID_NUM; i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\t\tdentry = d_alloc_name(dir, security_get_initial_sid_context(i));\n\t\tif (!dentry)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\t\tif (!inode)\n\t\t\treturn -ENOMEM;\n\n\t\tinode->i_fop = &sel_initcon_ops;\n\t\tinode->i_ino = i|SEL_INITCON_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SEL_INITCON_INO_OFFSET\t\t0x01000000"
          ],
          "globals_used": [
            "static const struct file_operations sel_initcon_ops = {\n\t.read\t\t= sel_read_initcon,\n\t.llseek\t\t= generic_file_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_INITCON_INO_OFFSET\t\t0x01000000\n\nstatic const struct file_operations sel_initcon_ops = {\n\t.read\t\t= sel_read_initcon,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_initcon_files(struct dentry *dir)\n{\n\tint i;\n\n\tfor (i = 1; i <= SECINITSID_NUM; i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\t\tdentry = d_alloc_name(dir, security_get_initial_sid_context(i));\n\t\tif (!dentry)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\t\tif (!inode)\n\t\t\treturn -ENOMEM;\n\n\t\tinode->i_fop = &sel_initcon_ops;\n\t\tinode->i_ino = i|SEL_INITCON_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_avc_files",
          "args": [
            "dentry"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_avc_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1487-1517",
          "snippet": "static int sel_make_avc_files(struct dentry *dir)\n{\n\tint i;\n\tstatic const struct tree_descr files[] = {\n\t\t{ \"cache_threshold\",\n\t\t  &sel_avc_cache_threshold_ops, S_IRUGO|S_IWUSR },\n\t\t{ \"hash_stats\", &sel_avc_hash_stats_ops, S_IRUGO },\n#ifdef CONFIG_SECURITY_SELINUX_AVC_STATS\n\t\t{ \"cache_stats\", &sel_avc_cache_stats_ops, S_IRUGO },\n#endif\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(files); i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\n\t\tdentry = d_alloc_name(dir, files[i].name);\n\t\tif (!dentry)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|files[i].mode);\n\t\tif (!inode)\n\t\t\treturn -ENOMEM;\n\n\t\tinode->i_fop = files[i].ops;\n\t\tinode->i_ino = ++sel_last_ino;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long sel_last_ino = SEL_INO_NEXT - 1;",
            "static const struct file_operations sel_avc_cache_threshold_ops = {\n\t.read\t\t= sel_read_avc_cache_threshold,\n\t.write\t\t= sel_write_avc_cache_threshold,\n\t.llseek\t\t= generic_file_llseek,\n};",
            "static const struct file_operations sel_avc_hash_stats_ops = {\n\t.read\t\t= sel_read_avc_hash_stats,\n\t.llseek\t\t= generic_file_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic unsigned long sel_last_ino = SEL_INO_NEXT - 1;\nstatic const struct file_operations sel_avc_cache_threshold_ops = {\n\t.read\t\t= sel_read_avc_cache_threshold,\n\t.write\t\t= sel_write_avc_cache_threshold,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations sel_avc_hash_stats_ops = {\n\t.read\t\t= sel_read_avc_hash_stats,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_avc_files(struct dentry *dir)\n{\n\tint i;\n\tstatic const struct tree_descr files[] = {\n\t\t{ \"cache_threshold\",\n\t\t  &sel_avc_cache_threshold_ops, S_IRUGO|S_IWUSR },\n\t\t{ \"hash_stats\", &sel_avc_hash_stats_ops, S_IRUGO },\n#ifdef CONFIG_SECURITY_SELINUX_AVC_STATS\n\t\t{ \"cache_stats\", &sel_avc_cache_stats_ops, S_IRUGO },\n#endif\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(files); i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\n\t\tdentry = d_alloc_name(dir, files[i].name);\n\t\tif (!dentry)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|files[i].mode);\n\t\tif (!inode)\n\t\t\treturn -ENOMEM;\n\n\t\tinode->i_fop = files[i].ops;\n\t\tinode->i_ino = ++sel_last_ino;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "S_IFCHR | S_IRUGO | S_IWUGO",
            "MKDEV(MEM_MAJOR, 3)"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "MEM_MAJOR",
            "3"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_inode",
          "args": [
            "sb",
            "S_IFCHR | S_IRUGO | S_IWUGO"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1086-1095",
          "snippet": "static struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "sb->s_root",
            "NULL_FILE_NAME"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bool_dir"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bool_dir"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_fill_super",
          "args": [
            "sb",
            "SELINUX_MAGIC",
            "selinux_files"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define NULL_FILE_NAME \"null\"\n#define BOOL_DIR_NAME \"booleans\"\n\nstatic struct dentry *bool_dir;\nstatic struct dentry *class_dir;\nstatic struct dentry *policycap_dir;\nstatic unsigned long sel_last_ino = SEL_INO_NEXT - 1;\nstatic const struct file_operations sel_enforce_ops = {\n\t.read\t\t= sel_read_enforce,\n\t.write\t\t= sel_write_enforce,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations sel_handle_unknown_ops = {\n\t.read\t\t= sel_read_handle_unknown,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations sel_handle_status_ops = {\n\t.open\t\t= sel_open_handle_status,\n\t.read\t\t= sel_read_handle_status,\n\t.mmap\t\t= sel_mmap_handle_status,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations sel_disable_ops = {\n\t.write\t\t= sel_write_disable,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations sel_policyvers_ops = {\n\t.read\t\t= sel_read_policyvers,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations sel_mls_ops = {\n\t.read\t\t= sel_read_mls,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations sel_policy_ops = {\n\t.open\t\t= sel_open_policy,\n\t.read\t\t= sel_read_policy,\n\t.mmap\t\t= sel_mmap_policy,\n\t.release\t= sel_release_policy,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations sel_load_ops = {\n\t.write\t\t= sel_write_load,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations sel_checkreqprot_ops = {\n\t.read\t\t= sel_read_checkreqprot,\n\t.write\t\t= sel_write_checkreqprot,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations sel_transition_ops = {\n\t.write\t\t= sel_write_validatetrans,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations transaction_ops = {\n\t.write\t\t= selinux_transaction_write,\n\t.read\t\t= simple_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations sel_commit_bools_ops = {\n\t.write\t\t= sel_commit_bools_write,\n\t.llseek\t\t= generic_file_llseek,\n};\nstruct path selinux_null;\n\nstatic int sel_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tint ret;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct inode_security_struct *isec;\n\n\tstatic const struct tree_descr selinux_files[] = {\n\t\t[SEL_LOAD] = {\"load\", &sel_load_ops, S_IRUSR|S_IWUSR},\n\t\t[SEL_ENFORCE] = {\"enforce\", &sel_enforce_ops, S_IRUGO|S_IWUSR},\n\t\t[SEL_CONTEXT] = {\"context\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_ACCESS] = {\"access\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_CREATE] = {\"create\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_RELABEL] = {\"relabel\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_USER] = {\"user\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_POLICYVERS] = {\"policyvers\", &sel_policyvers_ops, S_IRUGO},\n\t\t[SEL_COMMIT_BOOLS] = {\"commit_pending_bools\", &sel_commit_bools_ops, S_IWUSR},\n\t\t[SEL_MLS] = {\"mls\", &sel_mls_ops, S_IRUGO},\n\t\t[SEL_DISABLE] = {\"disable\", &sel_disable_ops, S_IWUSR},\n\t\t[SEL_MEMBER] = {\"member\", &transaction_ops, S_IRUGO|S_IWUGO},\n\t\t[SEL_CHECKREQPROT] = {\"checkreqprot\", &sel_checkreqprot_ops, S_IRUGO|S_IWUSR},\n\t\t[SEL_REJECT_UNKNOWN] = {\"reject_unknown\", &sel_handle_unknown_ops, S_IRUGO},\n\t\t[SEL_DENY_UNKNOWN] = {\"deny_unknown\", &sel_handle_unknown_ops, S_IRUGO},\n\t\t[SEL_STATUS] = {\"status\", &sel_handle_status_ops, S_IRUGO},\n\t\t[SEL_POLICY] = {\"policy\", &sel_policy_ops, S_IRUGO},\n\t\t[SEL_VALIDATE_TRANS] = {\"validatetrans\", &sel_transition_ops,\n\t\t\t\t\tS_IWUGO},\n\t\t/* last one */ {\"\"}\n\t};\n\tret = simple_fill_super(sb, SELINUX_MAGIC, selinux_files);\n\tif (ret)\n\t\tgoto err;\n\n\tbool_dir = sel_make_dir(sb->s_root, BOOL_DIR_NAME, &sel_last_ino);\n\tif (IS_ERR(bool_dir)) {\n\t\tret = PTR_ERR(bool_dir);\n\t\tbool_dir = NULL;\n\t\tgoto err;\n\t}\n\n\tret = -ENOMEM;\n\tdentry = d_alloc_name(sb->s_root, NULL_FILE_NAME);\n\tif (!dentry)\n\t\tgoto err;\n\n\tret = -ENOMEM;\n\tinode = sel_make_inode(sb, S_IFCHR | S_IRUGO | S_IWUGO);\n\tif (!inode)\n\t\tgoto err;\n\n\tinode->i_ino = ++sel_last_ino;\n\tisec = (struct inode_security_struct *)inode->i_security;\n\tisec->sid = SECINITSID_DEVNULL;\n\tisec->sclass = SECCLASS_CHR_FILE;\n\tisec->initialized = LABEL_INITIALIZED;\n\n\tinit_special_inode(inode, S_IFCHR | S_IRUGO | S_IWUGO, MKDEV(MEM_MAJOR, 3));\n\td_add(dentry, inode);\n\tselinux_null.dentry = dentry;\n\n\tdentry = sel_make_dir(sb->s_root, \"avc\", &sel_last_ino);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto err;\n\t}\n\n\tret = sel_make_avc_files(dentry);\n\tif (ret)\n\t\tgoto err;\n\n\tdentry = sel_make_dir(sb->s_root, \"initial_contexts\", &sel_last_ino);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto err;\n\t}\n\n\tret = sel_make_initcon_files(dentry);\n\tif (ret)\n\t\tgoto err;\n\n\tclass_dir = sel_make_dir(sb->s_root, \"class\", &sel_last_ino);\n\tif (IS_ERR(class_dir)) {\n\t\tret = PTR_ERR(class_dir);\n\t\tclass_dir = NULL;\n\t\tgoto err;\n\t}\n\n\tpolicycap_dir = sel_make_dir(sb->s_root, \"policy_capabilities\", &sel_last_ino);\n\tif (IS_ERR(policycap_dir)) {\n\t\tret = PTR_ERR(policycap_dir);\n\t\tpolicycap_dir = NULL;\n\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tprintk(KERN_ERR \"SELinux: %s:  failed while creating inodes\\n\",\n\t\t__func__);\n\treturn ret;\n}"
  },
  {
    "function_name": "sel_make_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1765-1790",
    "snippet": "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino)\n{\n\tstruct dentry *dentry = d_alloc_name(dir, name);\n\tstruct inode *inode;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = sel_make_inode(dir->d_sb, S_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_ino = ++(*ino);\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_add(dentry, inode);\n\t/* bump link count on parent directory, too */\n\tinc_nlink(d_inode(dir));\n\n\treturn dentry;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "d_inode(dir)"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dir"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_inode",
          "args": [
            "dir->d_sb",
            "S_IFDIR | S_IRUGO | S_IXUGO"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1086-1095",
          "snippet": "static struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "dir",
            "name"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino)\n{\n\tstruct dentry *dentry = d_alloc_name(dir, name);\n\tstruct inode *inode;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = sel_make_inode(dir->d_sb, S_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_ino = ++(*ino);\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_add(dentry, inode);\n\t/* bump link count on parent directory, too */\n\tinc_nlink(d_inode(dir));\n\n\treturn dentry;\n}"
  },
  {
    "function_name": "sel_make_policycap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1735-1763",
    "snippet": "static int sel_make_policycap(void)\n{\n\tunsigned int iter;\n\tstruct dentry *dentry = NULL;\n\tstruct inode *inode = NULL;\n\n\tsel_remove_entries(policycap_dir);\n\n\tfor (iter = 0; iter <= POLICYDB_CAPABILITY_MAX; iter++) {\n\t\tif (iter < ARRAY_SIZE(selinux_policycap_names))\n\t\t\tdentry = d_alloc_name(policycap_dir,\n\t\t\t\t\t      selinux_policycap_names[iter]);\n\t\telse\n\t\t\tdentry = d_alloc_name(policycap_dir, \"unknown\");\n\n\t\tif (dentry == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(policycap_dir->d_sb, S_IFREG | S_IRUGO);\n\t\tif (inode == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tinode->i_fop = &sel_policycap_ops;\n\t\tinode->i_ino = iter | SEL_POLICYCAP_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SEL_POLICYCAP_INO_OFFSET\t0x08000000"
    ],
    "globals_used": [
      "static struct dentry *policycap_dir;",
      "static int sel_make_policycap(void);",
      "static const struct file_operations sel_policycap_ops = {\n\t.read\t\t= sel_read_policycap,\n\t.llseek\t\t= generic_file_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_inode",
          "args": [
            "policycap_dir->d_sb",
            "S_IFREG | S_IRUGO"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1086-1095",
          "snippet": "static struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "policycap_dir",
            "\"unknown\""
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "policycap_dir",
            "selinux_policycap_names[iter]"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "selinux_policycap_names"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_remove_entries",
          "args": [
            "policycap_dir"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "sel_remove_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1245-1249",
          "snippet": "static void sel_remove_entries(struct dentry *de)\n{\n\td_genocide(de);\n\tshrink_dcache_parent(de);\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic void sel_remove_entries(struct dentry *de)\n{\n\td_genocide(de);\n\tshrink_dcache_parent(de);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_POLICYCAP_INO_OFFSET\t0x08000000\n\nstatic struct dentry *policycap_dir;\nstatic int sel_make_policycap(void);\nstatic const struct file_operations sel_policycap_ops = {\n\t.read\t\t= sel_read_policycap,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_policycap(void)\n{\n\tunsigned int iter;\n\tstruct dentry *dentry = NULL;\n\tstruct inode *inode = NULL;\n\n\tsel_remove_entries(policycap_dir);\n\n\tfor (iter = 0; iter <= POLICYDB_CAPABILITY_MAX; iter++) {\n\t\tif (iter < ARRAY_SIZE(selinux_policycap_names))\n\t\t\tdentry = d_alloc_name(policycap_dir,\n\t\t\t\t\t      selinux_policycap_names[iter]);\n\t\telse\n\t\t\tdentry = d_alloc_name(policycap_dir, \"unknown\");\n\n\t\tif (dentry == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(policycap_dir->d_sb, S_IFREG | S_IRUGO);\n\t\tif (inode == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tinode->i_fop = &sel_policycap_ops;\n\t\tinode->i_ino = iter | SEL_POLICYCAP_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sel_make_classes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1696-1733",
    "snippet": "static int sel_make_classes(void)\n{\n\tint rc, nclasses, i;\n\tchar **classes;\n\n\t/* delete any existing entries */\n\tsel_remove_entries(class_dir);\n\n\trc = security_get_classes(&classes, &nclasses);\n\tif (rc)\n\t\treturn rc;\n\n\t/* +2 since classes are 1-indexed */\n\tlast_class_ino = sel_class_to_ino(nclasses + 2);\n\n\tfor (i = 0; i < nclasses; i++) {\n\t\tstruct dentry *class_name_dir;\n\n\t\tclass_name_dir = sel_make_dir(class_dir, classes[i],\n\t\t\t\t&last_class_ino);\n\t\tif (IS_ERR(class_name_dir)) {\n\t\t\trc = PTR_ERR(class_name_dir);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* i+1 since class values are 1-indexed */\n\t\trc = sel_make_class_dir_entries(classes[i], i + 1,\n\t\t\t\tclass_name_dir);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tfor (i = 0; i < nclasses; i++)\n\t\tkfree(classes[i]);\n\tkfree(classes);\n\treturn rc;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *class_dir;",
      "static unsigned long last_class_ino;",
      "static int sel_make_classes(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "classes"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "classes[i]"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_class_dir_entries",
          "args": [
            "classes[i]",
            "i + 1",
            "class_name_dir"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_class_dir_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1668-1694",
          "snippet": "static int sel_make_class_dir_entries(char *classname, int index,\n\t\t\t\t\tstruct dentry *dir)\n{\n\tstruct dentry *dentry = NULL;\n\tstruct inode *inode = NULL;\n\tint rc;\n\n\tdentry = d_alloc_name(dir, \"index\");\n\tif (!dentry)\n\t\treturn -ENOMEM;\n\n\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_fop = &sel_class_ops;\n\tinode->i_ino = sel_class_to_ino(index);\n\td_add(dentry, inode);\n\n\tdentry = sel_make_dir(dir, \"perms\", &last_class_ino);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\trc = sel_make_perm_files(classname, index, dentry);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long last_class_ino;",
            "static const struct file_operations sel_class_ops = {\n\t.read\t\t= sel_read_class,\n\t.llseek\t\t= generic_file_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic unsigned long last_class_ino;\nstatic const struct file_operations sel_class_ops = {\n\t.read\t\t= sel_read_class,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_class_dir_entries(char *classname, int index,\n\t\t\t\t\tstruct dentry *dir)\n{\n\tstruct dentry *dentry = NULL;\n\tstruct inode *inode = NULL;\n\tint rc;\n\n\tdentry = d_alloc_name(dir, \"index\");\n\tif (!dentry)\n\t\treturn -ENOMEM;\n\n\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_fop = &sel_class_ops;\n\tinode->i_ino = sel_class_to_ino(index);\n\td_add(dentry, inode);\n\n\tdentry = sel_make_dir(dir, \"perms\", &last_class_ino);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\trc = sel_make_perm_files(classname, index, dentry);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "class_name_dir"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "class_name_dir"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_dir",
          "args": [
            "class_dir",
            "classes[i]",
            "&last_class_ino"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1765-1790",
          "snippet": "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino)\n{\n\tstruct dentry *dentry = d_alloc_name(dir, name);\n\tstruct inode *inode;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = sel_make_inode(dir->d_sb, S_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_ino = ++(*ino);\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_add(dentry, inode);\n\t/* bump link count on parent directory, too */\n\tinc_nlink(d_inode(dir));\n\n\treturn dentry;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino)\n{\n\tstruct dentry *dentry = d_alloc_name(dir, name);\n\tstruct inode *inode;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = sel_make_inode(dir->d_sb, S_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_ino = ++(*ino);\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_add(dentry, inode);\n\t/* bump link count on parent directory, too */\n\tinc_nlink(d_inode(dir));\n\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sel_class_to_ino",
          "args": [
            "nclasses + 2"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "sel_class_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1564-1567",
          "snippet": "static inline unsigned long sel_class_to_ino(u16 class)\n{\n\treturn (class * (SEL_VEC_MAX + 1)) | SEL_CLASS_INO_OFFSET;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SEL_CLASS_INO_OFFSET\t\t0x04000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_CLASS_INO_OFFSET\t\t0x04000000\n\nstatic inline unsigned long sel_class_to_ino(u16 class)\n{\n\treturn (class * (SEL_VEC_MAX + 1)) | SEL_CLASS_INO_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_get_classes",
          "args": [
            "&classes",
            "&nclasses"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "security_get_classes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3010-3034",
          "snippet": "int security_get_classes(char ***classes, int *nclasses)\n{\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOMEM;\n\t*nclasses = policydb.p_classes.nprim;\n\t*classes = kcalloc(*nclasses, sizeof(**classes), GFP_ATOMIC);\n\tif (!*classes)\n\t\tgoto out;\n\n\trc = hashtab_map(policydb.p_classes.table, get_classes_callback,\n\t\t\t*classes);\n\tif (rc) {\n\t\tint i;\n\t\tfor (i = 0; i < *nclasses; i++)\n\t\t\tkfree((*classes)[i]);\n\t\tkfree(*classes);\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nint security_get_classes(char ***classes, int *nclasses)\n{\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOMEM;\n\t*nclasses = policydb.p_classes.nprim;\n\t*classes = kcalloc(*nclasses, sizeof(**classes), GFP_ATOMIC);\n\tif (!*classes)\n\t\tgoto out;\n\n\trc = hashtab_map(policydb.p_classes.table, get_classes_callback,\n\t\t\t*classes);\n\tif (rc) {\n\t\tint i;\n\t\tfor (i = 0; i < *nclasses; i++)\n\t\t\tkfree((*classes)[i]);\n\t\tkfree(*classes);\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sel_remove_entries",
          "args": [
            "class_dir"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "sel_remove_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1245-1249",
          "snippet": "static void sel_remove_entries(struct dentry *de)\n{\n\td_genocide(de);\n\tshrink_dcache_parent(de);\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic void sel_remove_entries(struct dentry *de)\n{\n\td_genocide(de);\n\tshrink_dcache_parent(de);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *class_dir;\nstatic unsigned long last_class_ino;\nstatic int sel_make_classes(void);\n\nstatic int sel_make_classes(void)\n{\n\tint rc, nclasses, i;\n\tchar **classes;\n\n\t/* delete any existing entries */\n\tsel_remove_entries(class_dir);\n\n\trc = security_get_classes(&classes, &nclasses);\n\tif (rc)\n\t\treturn rc;\n\n\t/* +2 since classes are 1-indexed */\n\tlast_class_ino = sel_class_to_ino(nclasses + 2);\n\n\tfor (i = 0; i < nclasses; i++) {\n\t\tstruct dentry *class_name_dir;\n\n\t\tclass_name_dir = sel_make_dir(class_dir, classes[i],\n\t\t\t\t&last_class_ino);\n\t\tif (IS_ERR(class_name_dir)) {\n\t\t\trc = PTR_ERR(class_name_dir);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* i+1 since class values are 1-indexed */\n\t\trc = sel_make_class_dir_entries(classes[i], i + 1,\n\t\t\t\tclass_name_dir);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tfor (i = 0; i < nclasses; i++)\n\t\tkfree(classes[i]);\n\tkfree(classes);\n\treturn rc;\n}"
  },
  {
    "function_name": "sel_make_class_dir_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1668-1694",
    "snippet": "static int sel_make_class_dir_entries(char *classname, int index,\n\t\t\t\t\tstruct dentry *dir)\n{\n\tstruct dentry *dentry = NULL;\n\tstruct inode *inode = NULL;\n\tint rc;\n\n\tdentry = d_alloc_name(dir, \"index\");\n\tif (!dentry)\n\t\treturn -ENOMEM;\n\n\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_fop = &sel_class_ops;\n\tinode->i_ino = sel_class_to_ino(index);\n\td_add(dentry, inode);\n\n\tdentry = sel_make_dir(dir, \"perms\", &last_class_ino);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\trc = sel_make_perm_files(classname, index, dentry);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long last_class_ino;",
      "static const struct file_operations sel_class_ops = {\n\t.read\t\t= sel_read_class,\n\t.llseek\t\t= generic_file_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sel_make_perm_files",
          "args": [
            "classname",
            "index",
            "dentry"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_perm_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1631-1666",
          "snippet": "static int sel_make_perm_files(char *objclass, int classvalue,\n\t\t\t\tstruct dentry *dir)\n{\n\tint i, rc, nperms;\n\tchar **perms;\n\n\trc = security_get_permissions(objclass, &perms, &nperms);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < nperms; i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\n\t\trc = -ENOMEM;\n\t\tdentry = d_alloc_name(dir, perms[i]);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\t\tif (!inode)\n\t\t\tgoto out;\n\n\t\tinode->i_fop = &sel_perm_ops;\n\t\t/* i+1 since perm values are 1-indexed */\n\t\tinode->i_ino = sel_perm_to_ino(classvalue, i + 1);\n\t\td_add(dentry, inode);\n\t}\n\trc = 0;\nout:\n\tfor (i = 0; i < nperms; i++)\n\t\tkfree(perms[i]);\n\tkfree(perms);\n\treturn rc;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations sel_perm_ops = {\n\t.read\t\t= sel_read_perm,\n\t.llseek\t\t= generic_file_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic const struct file_operations sel_perm_ops = {\n\t.read\t\t= sel_read_perm,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_perm_files(char *objclass, int classvalue,\n\t\t\t\tstruct dentry *dir)\n{\n\tint i, rc, nperms;\n\tchar **perms;\n\n\trc = security_get_permissions(objclass, &perms, &nperms);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < nperms; i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\n\t\trc = -ENOMEM;\n\t\tdentry = d_alloc_name(dir, perms[i]);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\t\tif (!inode)\n\t\t\tgoto out;\n\n\t\tinode->i_fop = &sel_perm_ops;\n\t\t/* i+1 since perm values are 1-indexed */\n\t\tinode->i_ino = sel_perm_to_ino(classvalue, i + 1);\n\t\td_add(dentry, inode);\n\t}\n\trc = 0;\nout:\n\tfor (i = 0; i < nperms; i++)\n\t\tkfree(perms[i]);\n\tkfree(perms);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_dir",
          "args": [
            "dir",
            "\"perms\"",
            "&last_class_ino"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1765-1790",
          "snippet": "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino)\n{\n\tstruct dentry *dentry = d_alloc_name(dir, name);\n\tstruct inode *inode;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = sel_make_inode(dir->d_sb, S_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_ino = ++(*ino);\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_add(dentry, inode);\n\t/* bump link count on parent directory, too */\n\tinc_nlink(d_inode(dir));\n\n\treturn dentry;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino)\n{\n\tstruct dentry *dentry = d_alloc_name(dir, name);\n\tstruct inode *inode;\n\n\tif (!dentry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode = sel_make_inode(dir->d_sb, S_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_ino = ++(*ino);\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_add(dentry, inode);\n\t/* bump link count on parent directory, too */\n\tinc_nlink(d_inode(dir));\n\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_class_to_ino",
          "args": [
            "index"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "sel_class_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1564-1567",
          "snippet": "static inline unsigned long sel_class_to_ino(u16 class)\n{\n\treturn (class * (SEL_VEC_MAX + 1)) | SEL_CLASS_INO_OFFSET;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SEL_CLASS_INO_OFFSET\t\t0x04000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_CLASS_INO_OFFSET\t\t0x04000000\n\nstatic inline unsigned long sel_class_to_ino(u16 class)\n{\n\treturn (class * (SEL_VEC_MAX + 1)) | SEL_CLASS_INO_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sel_make_inode",
          "args": [
            "dir->d_sb",
            "S_IFREG|S_IRUGO"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1086-1095",
          "snippet": "static struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "dir",
            "\"index\""
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic unsigned long last_class_ino;\nstatic const struct file_operations sel_class_ops = {\n\t.read\t\t= sel_read_class,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_class_dir_entries(char *classname, int index,\n\t\t\t\t\tstruct dentry *dir)\n{\n\tstruct dentry *dentry = NULL;\n\tstruct inode *inode = NULL;\n\tint rc;\n\n\tdentry = d_alloc_name(dir, \"index\");\n\tif (!dentry)\n\t\treturn -ENOMEM;\n\n\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_fop = &sel_class_ops;\n\tinode->i_ino = sel_class_to_ino(index);\n\td_add(dentry, inode);\n\n\tdentry = sel_make_dir(dir, \"perms\", &last_class_ino);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\trc = sel_make_perm_files(classname, index, dentry);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "sel_make_perm_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1631-1666",
    "snippet": "static int sel_make_perm_files(char *objclass, int classvalue,\n\t\t\t\tstruct dentry *dir)\n{\n\tint i, rc, nperms;\n\tchar **perms;\n\n\trc = security_get_permissions(objclass, &perms, &nperms);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < nperms; i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\n\t\trc = -ENOMEM;\n\t\tdentry = d_alloc_name(dir, perms[i]);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\t\tif (!inode)\n\t\t\tgoto out;\n\n\t\tinode->i_fop = &sel_perm_ops;\n\t\t/* i+1 since perm values are 1-indexed */\n\t\tinode->i_ino = sel_perm_to_ino(classvalue, i + 1);\n\t\td_add(dentry, inode);\n\t}\n\trc = 0;\nout:\n\tfor (i = 0; i < nperms; i++)\n\t\tkfree(perms[i]);\n\tkfree(perms);\n\treturn rc;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations sel_perm_ops = {\n\t.read\t\t= sel_read_perm,\n\t.llseek\t\t= generic_file_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "perms"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "perms[i]"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_perm_to_ino",
          "args": [
            "classvalue",
            "i + 1"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "sel_perm_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1574-1577",
          "snippet": "static inline unsigned long sel_perm_to_ino(u16 class, u32 perm)\n{\n\treturn (class * (SEL_VEC_MAX + 1) + perm) | SEL_CLASS_INO_OFFSET;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SEL_CLASS_INO_OFFSET\t\t0x04000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_CLASS_INO_OFFSET\t\t0x04000000\n\nstatic inline unsigned long sel_perm_to_ino(u16 class, u32 perm)\n{\n\treturn (class * (SEL_VEC_MAX + 1) + perm) | SEL_CLASS_INO_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sel_make_inode",
          "args": [
            "dir->d_sb",
            "S_IFREG|S_IRUGO"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1086-1095",
          "snippet": "static struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "dir",
            "perms[i]"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_get_permissions",
          "args": [
            "objclass",
            "&perms",
            "&nperms"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "security_get_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3049-3092",
          "snippet": "int security_get_permissions(char *class, char ***perms, int *nperms)\n{\n\tint rc, i;\n\tstruct class_datum *match;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tmatch = hashtab_search(policydb.p_classes.table, class);\n\tif (!match) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized class %s\\n\",\n\t\t\t__func__, class);\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\t*nperms = match->permissions.nprim;\n\t*perms = kcalloc(*nperms, sizeof(**perms), GFP_ATOMIC);\n\tif (!*perms)\n\t\tgoto out;\n\n\tif (match->comdatum) {\n\t\trc = hashtab_map(match->comdatum->permissions.table,\n\t\t\t\tget_permissions_callback, *perms);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\trc = hashtab_map(match->permissions.table, get_permissions_callback,\n\t\t\t*perms);\n\tif (rc)\n\t\tgoto err;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n\nerr:\n\tread_unlock(&policy_rwlock);\n\tfor (i = 0; i < *nperms; i++)\n\t\tkfree((*perms)[i]);\n\tkfree(*perms);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nint security_get_permissions(char *class, char ***perms, int *nperms)\n{\n\tint rc, i;\n\tstruct class_datum *match;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tmatch = hashtab_search(policydb.p_classes.table, class);\n\tif (!match) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized class %s\\n\",\n\t\t\t__func__, class);\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\t*nperms = match->permissions.nprim;\n\t*perms = kcalloc(*nperms, sizeof(**perms), GFP_ATOMIC);\n\tif (!*perms)\n\t\tgoto out;\n\n\tif (match->comdatum) {\n\t\trc = hashtab_map(match->comdatum->permissions.table,\n\t\t\t\tget_permissions_callback, *perms);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\trc = hashtab_map(match->permissions.table, get_permissions_callback,\n\t\t\t*perms);\n\tif (rc)\n\t\tgoto err;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n\nerr:\n\tread_unlock(&policy_rwlock);\n\tfor (i = 0; i < *nperms; i++)\n\t\tkfree((*perms)[i]);\n\tkfree(*perms);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic const struct file_operations sel_perm_ops = {\n\t.read\t\t= sel_read_perm,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_perm_files(char *objclass, int classvalue,\n\t\t\t\tstruct dentry *dir)\n{\n\tint i, rc, nperms;\n\tchar **perms;\n\n\trc = security_get_permissions(objclass, &perms, &nperms);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < nperms; i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\n\t\trc = -ENOMEM;\n\t\tdentry = d_alloc_name(dir, perms[i]);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\t\tif (!inode)\n\t\t\tgoto out;\n\n\t\tinode->i_fop = &sel_perm_ops;\n\t\t/* i+1 since perm values are 1-indexed */\n\t\tinode->i_ino = sel_perm_to_ino(classvalue, i + 1);\n\t\td_add(dentry, inode);\n\t}\n\trc = 0;\nout:\n\tfor (i = 0; i < nperms; i++)\n\t\tkfree(perms[i]);\n\tkfree(perms);\n\treturn rc;\n}"
  },
  {
    "function_name": "sel_read_policycap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1612-1624",
    "snippet": "static ssize_t sel_read_policycap(struct file *file, char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tint value;\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\tunsigned long i_ino = file_inode(file)->i_ino;\n\n\tvalue = security_policycap_supported(i_ino & SEL_INO_MASK);\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%d\", value);\n\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TMPBUFLEN\t12",
      "#define SEL_INO_MASK\t\t\t0x00ffffff"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "tmpbuf",
            "length"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "tmpbuf",
            "TMPBUFLEN",
            "\"%d\"",
            "value"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_policycap_supported",
          "args": [
            "i_ino & SEL_INO_MASK"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "security_policycap_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3114-3123",
          "snippet": "int security_policycap_supported(unsigned int req_cap)\n{\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\trc = ebitmap_get_bit(&policydb.policycaps, req_cap);\n\tread_unlock(&policy_rwlock);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nint security_policycap_supported(unsigned int req_cap)\n{\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\trc = ebitmap_get_bit(&policydb.policycaps, req_cap);\n\tread_unlock(&policy_rwlock);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define TMPBUFLEN\t12\n#define SEL_INO_MASK\t\t\t0x00ffffff\n\nstatic ssize_t sel_read_policycap(struct file *file, char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tint value;\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\tunsigned long i_ino = file_inode(file)->i_ino;\n\n\tvalue = security_policycap_supported(i_ino & SEL_INO_MASK);\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%d\", value);\n\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}"
  },
  {
    "function_name": "sel_read_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1598-1605",
    "snippet": "static ssize_t sel_read_perm(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tunsigned long ino = file_inode(file)->i_ino;\n\tchar res[TMPBUFLEN];\n\tssize_t len = snprintf(res, sizeof(res), \"%d\", sel_ino_to_perm(ino));\n\treturn simple_read_from_buffer(buf, count, ppos, res, len);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TMPBUFLEN\t12"
    ],
    "globals_used": [
      "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "res",
            "len"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "res",
            "sizeof(res)",
            "\"%d\"",
            "sel_ino_to_perm(ino)"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_ino_to_perm",
          "args": [
            "ino"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "sel_ino_to_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1579-1582",
          "snippet": "static inline u32 sel_ino_to_perm(unsigned long ino)\n{\n\treturn (ino & SEL_INO_MASK) % (SEL_VEC_MAX + 1);\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SEL_INO_MASK\t\t\t0x00ffffff"
          ],
          "globals_used": [
            "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_INO_MASK\t\t\t0x00ffffff\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);\n\nstatic inline u32 sel_ino_to_perm(unsigned long ino)\n{\n\treturn (ino & SEL_INO_MASK) % (SEL_VEC_MAX + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define TMPBUFLEN\t12\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);\n\nstatic ssize_t sel_read_perm(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tunsigned long ino = file_inode(file)->i_ino;\n\tchar res[TMPBUFLEN];\n\tssize_t len = snprintf(res, sizeof(res), \"%d\", sel_ino_to_perm(ino));\n\treturn simple_read_from_buffer(buf, count, ppos, res, len);\n}"
  },
  {
    "function_name": "sel_read_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1584-1591",
    "snippet": "static ssize_t sel_read_class(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tunsigned long ino = file_inode(file)->i_ino;\n\tchar res[TMPBUFLEN];\n\tssize_t len = snprintf(res, sizeof(res), \"%d\", sel_ino_to_class(ino));\n\treturn simple_read_from_buffer(buf, count, ppos, res, len);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TMPBUFLEN\t12"
    ],
    "globals_used": [
      "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "res",
            "len"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "res",
            "sizeof(res)",
            "\"%d\"",
            "sel_ino_to_class(ino)"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_ino_to_class",
          "args": [
            "ino"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "sel_ino_to_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1569-1572",
          "snippet": "static inline u16 sel_ino_to_class(unsigned long ino)\n{\n\treturn (ino & SEL_INO_MASK) / (SEL_VEC_MAX + 1);\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SEL_INO_MASK\t\t\t0x00ffffff"
          ],
          "globals_used": [
            "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_INO_MASK\t\t\t0x00ffffff\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);\n\nstatic inline u16 sel_ino_to_class(unsigned long ino)\n{\n\treturn (ino & SEL_INO_MASK) / (SEL_VEC_MAX + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define TMPBUFLEN\t12\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);\n\nstatic ssize_t sel_read_class(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tunsigned long ino = file_inode(file)->i_ino;\n\tchar res[TMPBUFLEN];\n\tssize_t len = snprintf(res, sizeof(res), \"%d\", sel_ino_to_class(ino));\n\treturn simple_read_from_buffer(buf, count, ppos, res, len);\n}"
  },
  {
    "function_name": "sel_ino_to_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1579-1582",
    "snippet": "static inline u32 sel_ino_to_perm(unsigned long ino)\n{\n\treturn (ino & SEL_INO_MASK) % (SEL_VEC_MAX + 1);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SEL_INO_MASK\t\t\t0x00ffffff"
    ],
    "globals_used": [
      "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_INO_MASK\t\t\t0x00ffffff\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);\n\nstatic inline u32 sel_ino_to_perm(unsigned long ino)\n{\n\treturn (ino & SEL_INO_MASK) % (SEL_VEC_MAX + 1);\n}"
  },
  {
    "function_name": "sel_perm_to_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1574-1577",
    "snippet": "static inline unsigned long sel_perm_to_ino(u16 class, u32 perm)\n{\n\treturn (class * (SEL_VEC_MAX + 1) + perm) | SEL_CLASS_INO_OFFSET;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SEL_CLASS_INO_OFFSET\t\t0x04000000"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_CLASS_INO_OFFSET\t\t0x04000000\n\nstatic inline unsigned long sel_perm_to_ino(u16 class, u32 perm)\n{\n\treturn (class * (SEL_VEC_MAX + 1) + perm) | SEL_CLASS_INO_OFFSET;\n}"
  },
  {
    "function_name": "sel_ino_to_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1569-1572",
    "snippet": "static inline u16 sel_ino_to_class(unsigned long ino)\n{\n\treturn (ino & SEL_INO_MASK) / (SEL_VEC_MAX + 1);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SEL_INO_MASK\t\t\t0x00ffffff"
    ],
    "globals_used": [
      "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_INO_MASK\t\t\t0x00ffffff\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);\n\nstatic inline u16 sel_ino_to_class(unsigned long ino)\n{\n\treturn (ino & SEL_INO_MASK) / (SEL_VEC_MAX + 1);\n}"
  },
  {
    "function_name": "sel_class_to_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1564-1567",
    "snippet": "static inline unsigned long sel_class_to_ino(u16 class)\n{\n\treturn (class * (SEL_VEC_MAX + 1)) | SEL_CLASS_INO_OFFSET;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SEL_CLASS_INO_OFFSET\t\t0x04000000"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_CLASS_INO_OFFSET\t\t0x04000000\n\nstatic inline unsigned long sel_class_to_ino(u16 class)\n{\n\treturn (class * (SEL_VEC_MAX + 1)) | SEL_CLASS_INO_OFFSET;\n}"
  },
  {
    "function_name": "sel_make_initcon_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1541-1562",
    "snippet": "static int sel_make_initcon_files(struct dentry *dir)\n{\n\tint i;\n\n\tfor (i = 1; i <= SECINITSID_NUM; i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\t\tdentry = d_alloc_name(dir, security_get_initial_sid_context(i));\n\t\tif (!dentry)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\t\tif (!inode)\n\t\t\treturn -ENOMEM;\n\n\t\tinode->i_fop = &sel_initcon_ops;\n\t\tinode->i_ino = i|SEL_INITCON_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SEL_INITCON_INO_OFFSET\t\t0x01000000"
    ],
    "globals_used": [
      "static const struct file_operations sel_initcon_ops = {\n\t.read\t\t= sel_read_initcon,\n\t.llseek\t\t= generic_file_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_inode",
          "args": [
            "dir->d_sb",
            "S_IFREG|S_IRUGO"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1086-1095",
          "snippet": "static struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "dir",
            "security_get_initial_sid_context(i)"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_get_initial_sid_context",
          "args": [
            "i"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "security_get_initial_sid_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1242-1247",
          "snippet": "const char *security_get_initial_sid_context(u32 sid)\n{\n\tif (unlikely(sid > SECINITSID_NUM))\n\t\treturn NULL;\n\treturn initial_sid_to_string[sid];\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nconst char *security_get_initial_sid_context(u32 sid)\n{\n\tif (unlikely(sid > SECINITSID_NUM))\n\t\treturn NULL;\n\treturn initial_sid_to_string[sid];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_INITCON_INO_OFFSET\t\t0x01000000\n\nstatic const struct file_operations sel_initcon_ops = {\n\t.read\t\t= sel_read_initcon,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_initcon_files(struct dentry *dir)\n{\n\tint i;\n\n\tfor (i = 1; i <= SECINITSID_NUM; i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\t\tdentry = d_alloc_name(dir, security_get_initial_sid_context(i));\n\t\tif (!dentry)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|S_IRUGO);\n\t\tif (!inode)\n\t\t\treturn -ENOMEM;\n\n\t\tinode->i_fop = &sel_initcon_ops;\n\t\tinode->i_ino = i|SEL_INITCON_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sel_read_initcon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1519-1534",
    "snippet": "static ssize_t sel_read_initcon(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *con;\n\tu32 sid, len;\n\tssize_t ret;\n\n\tsid = file_inode(file)->i_ino&SEL_INO_MASK;\n\tret = security_sid_to_context(sid, &con, &len);\n\tif (ret)\n\t\treturn ret;\n\n\tret = simple_read_from_buffer(buf, count, ppos, con, len);\n\tkfree(con);\n\treturn ret;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SEL_INO_MASK\t\t\t0x00ffffff"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "con"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "con",
            "len"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sid_to_context",
          "args": [
            "sid",
            "&con",
            "&len"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "security_sid_to_context_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1314-1317",
          "snippet": "int security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_INO_MASK\t\t\t0x00ffffff\n\nstatic ssize_t sel_read_initcon(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *con;\n\tu32 sid, len;\n\tssize_t ret;\n\n\tsid = file_inode(file)->i_ino&SEL_INO_MASK;\n\tret = security_sid_to_context(sid, &con, &len);\n\tif (ret)\n\t\treturn ret;\n\n\tret = simple_read_from_buffer(buf, count, ppos, con, len);\n\tkfree(con);\n\treturn ret;\n}"
  },
  {
    "function_name": "sel_make_avc_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1487-1517",
    "snippet": "static int sel_make_avc_files(struct dentry *dir)\n{\n\tint i;\n\tstatic const struct tree_descr files[] = {\n\t\t{ \"cache_threshold\",\n\t\t  &sel_avc_cache_threshold_ops, S_IRUGO|S_IWUSR },\n\t\t{ \"hash_stats\", &sel_avc_hash_stats_ops, S_IRUGO },\n#ifdef CONFIG_SECURITY_SELINUX_AVC_STATS\n\t\t{ \"cache_stats\", &sel_avc_cache_stats_ops, S_IRUGO },\n#endif\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(files); i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\n\t\tdentry = d_alloc_name(dir, files[i].name);\n\t\tif (!dentry)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|files[i].mode);\n\t\tif (!inode)\n\t\t\treturn -ENOMEM;\n\n\t\tinode->i_fop = files[i].ops;\n\t\tinode->i_ino = ++sel_last_ino;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long sel_last_ino = SEL_INO_NEXT - 1;",
      "static const struct file_operations sel_avc_cache_threshold_ops = {\n\t.read\t\t= sel_read_avc_cache_threshold,\n\t.write\t\t= sel_write_avc_cache_threshold,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations sel_avc_hash_stats_ops = {\n\t.read\t\t= sel_read_avc_hash_stats,\n\t.llseek\t\t= generic_file_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_inode",
          "args": [
            "dir->d_sb",
            "S_IFREG|files[i].mode"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1086-1095",
          "snippet": "static struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "dir",
            "files[i].name"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "files"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic unsigned long sel_last_ino = SEL_INO_NEXT - 1;\nstatic const struct file_operations sel_avc_cache_threshold_ops = {\n\t.read\t\t= sel_read_avc_cache_threshold,\n\t.write\t\t= sel_write_avc_cache_threshold,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations sel_avc_hash_stats_ops = {\n\t.read\t\t= sel_read_avc_hash_stats,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_avc_files(struct dentry *dir)\n{\n\tint i;\n\tstatic const struct tree_descr files[] = {\n\t\t{ \"cache_threshold\",\n\t\t  &sel_avc_cache_threshold_ops, S_IRUGO|S_IWUSR },\n\t\t{ \"hash_stats\", &sel_avc_hash_stats_ops, S_IRUGO },\n#ifdef CONFIG_SECURITY_SELINUX_AVC_STATS\n\t\t{ \"cache_stats\", &sel_avc_cache_stats_ops, S_IRUGO },\n#endif\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(files); i++) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\n\t\tdentry = d_alloc_name(dir, files[i].name);\n\t\tif (!dentry)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG|files[i].mode);\n\t\tif (!inode)\n\t\t\treturn -ENOMEM;\n\n\t\tinode->i_fop = files[i].ops;\n\t\tinode->i_ino = ++sel_last_ino;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sel_open_avc_cache_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1474-1477",
    "snippet": "static int sel_open_avc_cache_stats(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &sel_avc_cache_stats_seq_ops);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&sel_avc_cache_stats_seq_ops"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic int sel_open_avc_cache_stats(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &sel_avc_cache_stats_seq_ops);\n}"
  },
  {
    "function_name": "sel_avc_stats_seq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1464-1465",
    "snippet": "static void sel_avc_stats_seq_stop(struct seq_file *seq, void *v)\n{ }",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic void sel_avc_stats_seq_stop(struct seq_file *seq, void *v)\n{ }"
  },
  {
    "function_name": "sel_avc_stats_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1446-1462",
    "snippet": "static int sel_avc_stats_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct avc_cache_stats *st = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"lookups hits misses allocations reclaims frees\\n\");\n\t} else {\n\t\tunsigned int lookups = st->lookups;\n\t\tunsigned int misses = st->misses;\n\t\tunsigned int hits = lookups - misses;\n\t\tseq_printf(seq, \"%u %u %u %u %u %u\\n\", lookups,\n\t\t\t   hits, misses, st->allocations,\n\t\t\t   st->reclaims, st->frees);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"%u %u %u %u %u %u\\n\"",
            "lookups",
            "hits",
            "misses",
            "st->allocations",
            "st->reclaims",
            "st->frees"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"lookups hits misses allocations reclaims frees\\n\""
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic int sel_avc_stats_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct avc_cache_stats *st = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"lookups hits misses allocations reclaims frees\\n\");\n\t} else {\n\t\tunsigned int lookups = st->lookups;\n\t\tunsigned int misses = st->misses;\n\t\tunsigned int hits = lookups - misses;\n\t\tseq_printf(seq, \"%u %u %u %u %u %u\\n\", lookups,\n\t\t\t   hits, misses, st->allocations,\n\t\t\t   st->reclaims, st->frees);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sel_avc_stats_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1441-1444",
    "snippet": "static void *sel_avc_stats_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn sel_avc_get_stat_idx(pos);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sel_avc_get_stat_idx",
          "args": [
            "pos"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "sel_avc_get_stat_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1418-1429",
          "snippet": "static struct avc_cache_stats *sel_avc_get_stat_idx(loff_t *idx)\n{\n\tint cpu;\n\n\tfor (cpu = *idx; cpu < nr_cpu_ids; ++cpu) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*idx = cpu + 1;\n\t\treturn &per_cpu(avc_cache_stats, cpu);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct avc_cache_stats *sel_avc_get_stat_idx(loff_t *idx)\n{\n\tint cpu;\n\n\tfor (cpu = *idx; cpu < nr_cpu_ids; ++cpu) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*idx = cpu + 1;\n\t\treturn &per_cpu(avc_cache_stats, cpu);\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic void *sel_avc_stats_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn sel_avc_get_stat_idx(pos);\n}"
  },
  {
    "function_name": "sel_avc_stats_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1431-1439",
    "snippet": "static void *sel_avc_stats_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tloff_t n = *pos - 1;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn sel_avc_get_stat_idx(&n);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sel_avc_get_stat_idx",
          "args": [
            "&n"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "sel_avc_get_stat_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1418-1429",
          "snippet": "static struct avc_cache_stats *sel_avc_get_stat_idx(loff_t *idx)\n{\n\tint cpu;\n\n\tfor (cpu = *idx; cpu < nr_cpu_ids; ++cpu) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*idx = cpu + 1;\n\t\treturn &per_cpu(avc_cache_stats, cpu);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct avc_cache_stats *sel_avc_get_stat_idx(loff_t *idx)\n{\n\tint cpu;\n\n\tfor (cpu = *idx; cpu < nr_cpu_ids; ++cpu) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*idx = cpu + 1;\n\t\treturn &per_cpu(avc_cache_stats, cpu);\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic void *sel_avc_stats_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tloff_t n = *pos - 1;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn sel_avc_get_stat_idx(&n);\n}"
  },
  {
    "function_name": "sel_avc_get_stat_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1418-1429",
    "snippet": "static struct avc_cache_stats *sel_avc_get_stat_idx(loff_t *idx)\n{\n\tint cpu;\n\n\tfor (cpu = *idx; cpu < nr_cpu_ids; ++cpu) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*idx = cpu + 1;\n\t\treturn &per_cpu(avc_cache_stats, cpu);\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "avc_cache_stats",
            "cpu"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_possible",
          "args": [
            "cpu"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct avc_cache_stats *sel_avc_get_stat_idx(loff_t *idx)\n{\n\tint cpu;\n\n\tfor (cpu = *idx; cpu < nr_cpu_ids; ++cpu) {\n\t\tif (!cpu_possible(cpu))\n\t\t\tcontinue;\n\t\t*idx = cpu + 1;\n\t\treturn &per_cpu(avc_cache_stats, cpu);\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "sel_read_avc_hash_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1388-1404",
    "snippet": "static ssize_t sel_read_avc_hash_stats(struct file *filp, char __user *buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar *page;\n\tssize_t length;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlength = avc_get_hash_stats(page);\n\tif (length >= 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, page, length);\n\tfree_page((unsigned long)page);\n\n\treturn length;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)page"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "page",
            "length"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_get_hash_stats",
          "args": [
            "page"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "avc_get_hash_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "202-230",
          "snippet": "int avc_get_hash_stats(char *page)\n{\n\tint i, chain_len, max_chain_len, slots_used;\n\tstruct avc_node *node;\n\tstruct hlist_head *head;\n\n\trcu_read_lock();\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\thead = &avc_cache.slots[i];\n\t\tif (!hlist_empty(head)) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\thlist_for_each_entry_rcu(node, head, list)\n\t\t\t\tchain_len++;\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn scnprintf(page, PAGE_SIZE, \"entries: %d\\nbuckets used: %d/%d\\n\"\n\t\t\t \"longest chain: %d\\n\",\n\t\t\t atomic_read(&avc_cache.active_nodes),\n\t\t\t slots_used, AVC_CACHE_SLOTS, max_chain_len);\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define AVC_CACHE_SLOTS\t\t\t512"
          ],
          "globals_used": [
            "static struct avc_cache avc_cache;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\n#define AVC_CACHE_SLOTS\t\t\t512\n\nstatic struct avc_cache avc_cache;\nstatic noinline struct;\n\nint avc_get_hash_stats(char *page)\n{\n\tint i, chain_len, max_chain_len, slots_used;\n\tstruct avc_node *node;\n\tstruct hlist_head *head;\n\n\trcu_read_lock();\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < AVC_CACHE_SLOTS; i++) {\n\t\thead = &avc_cache.slots[i];\n\t\tif (!hlist_empty(head)) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\thlist_for_each_entry_rcu(node, head, list)\n\t\t\t\tchain_len++;\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn scnprintf(page, PAGE_SIZE, \"entries: %d\\nbuckets used: %d/%d\\n\"\n\t\t\t \"longest chain: %d\\n\",\n\t\t\t atomic_read(&avc_cache.active_nodes),\n\t\t\t slots_used, AVC_CACHE_SLOTS, max_chain_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sel_read_avc_hash_stats(struct file *filp, char __user *buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar *page;\n\tssize_t length;\n\n\tpage = (char *)__get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tlength = avc_get_hash_stats(page);\n\tif (length >= 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, page, length);\n\tfree_page((unsigned long)page);\n\n\treturn length;\n}"
  },
  {
    "function_name": "sel_write_avc_cache_threshold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1350-1386",
    "snippet": "static ssize_t sel_write_avc_cache_threshold(struct file *file,\n\t\t\t\t\t     const char __user *buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n\n{\n\tchar *page;\n\tssize_t ret;\n\tunsigned int new_value;\n\n\tret = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t   SECCLASS_SECURITY, SECURITY__SETSECPARAM,\n\t\t\t   NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t/* No partial writes. */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tret = -EINVAL;\n\tif (sscanf(page, \"%u\", &new_value) != 1)\n\t\tgoto out;\n\n\tavc_cache_threshold = new_value;\n\n\tret = count;\nout:\n\tkfree(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "page"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "page",
            "\"%u\"",
            "&new_value"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__SETSECPARAM",
            "NULL"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sel_write_avc_cache_threshold(struct file *file,\n\t\t\t\t\t     const char __user *buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n\n{\n\tchar *page;\n\tssize_t ret;\n\tunsigned int new_value;\n\n\tret = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t   SECCLASS_SECURITY, SECURITY__SETSECPARAM,\n\t\t\t   NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t/* No partial writes. */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tret = -EINVAL;\n\tif (sscanf(page, \"%u\", &new_value) != 1)\n\t\tgoto out;\n\n\tavc_cache_threshold = new_value;\n\n\tret = count;\nout:\n\tkfree(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "sel_read_avc_cache_threshold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1340-1348",
    "snippet": "static ssize_t sel_read_avc_cache_threshold(struct file *filp, char __user *buf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\", avc_cache_threshold);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TMPBUFLEN\t12"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "tmpbuf",
            "length"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "tmpbuf",
            "TMPBUFLEN",
            "\"%u\"",
            "avc_cache_threshold"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define TMPBUFLEN\t12\n\nstatic ssize_t sel_read_avc_cache_threshold(struct file *filp, char __user *buf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\", avc_cache_threshold);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}"
  },
  {
    "function_name": "sel_make_bools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1253-1334",
    "snippet": "static int sel_make_bools(void)\n{\n\tint i, ret;\n\tssize_t len;\n\tstruct dentry *dentry = NULL;\n\tstruct dentry *dir = bool_dir;\n\tstruct inode *inode = NULL;\n\tstruct inode_security_struct *isec;\n\tchar **names = NULL, *page;\n\tint num;\n\tint *values = NULL;\n\tu32 sid;\n\n\t/* remove any existing files */\n\tfor (i = 0; i < bool_num; i++)\n\t\tkfree(bool_pending_names[i]);\n\tkfree(bool_pending_names);\n\tkfree(bool_pending_values);\n\tbool_num = 0;\n\tbool_pending_names = NULL;\n\tbool_pending_values = NULL;\n\n\tsel_remove_entries(dir);\n\n\tret = -ENOMEM;\n\tpage = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto out;\n\n\tret = security_get_bools(&num, &names, &values);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = -ENOMEM;\n\t\tdentry = d_alloc_name(dir, names[i]);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\n\t\tret = -ENOMEM;\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG | S_IRUGO | S_IWUSR);\n\t\tif (!inode)\n\t\t\tgoto out;\n\n\t\tret = -ENAMETOOLONG;\n\t\tlen = snprintf(page, PAGE_SIZE, \"/%s/%s\", BOOL_DIR_NAME, names[i]);\n\t\tif (len >= PAGE_SIZE)\n\t\t\tgoto out;\n\n\t\tisec = (struct inode_security_struct *)inode->i_security;\n\t\tret = security_genfs_sid(\"selinuxfs\", page, SECCLASS_FILE, &sid);\n\t\tif (ret) {\n\t\t\tpr_warn_ratelimited(\"SELinux: no sid found, defaulting to security isid for %s\\n\",\n\t\t\t\t\t   page);\n\t\t\tsid = SECINITSID_SECURITY;\n\t\t}\n\n\t\tisec->sid = sid;\n\t\tisec->initialized = LABEL_INITIALIZED;\n\t\tinode->i_fop = &sel_bool_ops;\n\t\tinode->i_ino = i|SEL_BOOL_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\tbool_num = num;\n\tbool_pending_names = names;\n\tbool_pending_values = values;\n\n\tfree_page((unsigned long)page);\n\treturn 0;\nout:\n\tfree_page((unsigned long)page);\n\n\tif (names) {\n\t\tfor (i = 0; i < num; i++)\n\t\t\tkfree(names[i]);\n\t\tkfree(names);\n\t}\n\tkfree(values);\n\tsel_remove_entries(dir);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BOOL_DIR_NAME \"booleans\"",
      "#define SEL_BOOL_INO_OFFSET\t\t0x02000000"
    ],
    "globals_used": [
      "static struct dentry *bool_dir;",
      "static int bool_num;",
      "static char **bool_pending_names;",
      "static int *bool_pending_values;",
      "static int sel_make_bools(void);",
      "static const struct file_operations sel_bool_ops = {\n\t.read\t\t= sel_read_bool,\n\t.write\t\t= sel_write_bool,\n\t.llseek\t\t= generic_file_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sel_remove_entries",
          "args": [
            "dir"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "sel_remove_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1245-1249",
          "snippet": "static void sel_remove_entries(struct dentry *de)\n{\n\td_genocide(de);\n\tshrink_dcache_parent(de);\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic void sel_remove_entries(struct dentry *de)\n{\n\td_genocide(de);\n\tshrink_dcache_parent(de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "values"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "names"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "names[i]"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)page"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)page"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"SELinux: no sid found, defaulting to security isid for %s\\n\"",
            "page"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_genfs_sid",
          "args": [
            "\"selinuxfs\"",
            "page",
            "SECCLASS_FILE",
            "&sid"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "security_genfs_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2645-2656",
          "snippet": "int security_genfs_sid(const char *fstype,\n\t\t       char *path,\n\t\t       u16 orig_sclass,\n\t\t       u32 *sid)\n{\n\tint retval;\n\n\tread_lock(&policy_rwlock);\n\tretval = __security_genfs_sid(fstype, path, orig_sclass, sid);\n\tread_unlock(&policy_rwlock);\n\treturn retval;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\n\nint security_genfs_sid(const char *fstype,\n\t\t       char *path,\n\t\t       u16 orig_sclass,\n\t\t       u32 *sid)\n{\n\tint retval;\n\n\tread_lock(&policy_rwlock);\n\tretval = __security_genfs_sid(fstype, path, orig_sclass, sid);\n\tread_unlock(&policy_rwlock);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "page",
            "PAGE_SIZE",
            "\"/%s/%s\"",
            "BOOL_DIR_NAME",
            "names[i]"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_inode",
          "args": [
            "dir->d_sb",
            "S_IFREG | S_IRUGO | S_IWUSR"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1086-1095",
          "snippet": "static struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "dir",
            "names[i]"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_get_bools",
          "args": [
            "&num",
            "&names",
            "&values"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "security_get_bools",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2703-2745",
          "snippet": "int security_get_bools(int *len, char ***names, int **values)\n{\n\tint i, rc;\n\n\tread_lock(&policy_rwlock);\n\t*names = NULL;\n\t*values = NULL;\n\n\trc = 0;\n\t*len = policydb.p_bools.nprim;\n\tif (!*len)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\t*names = kcalloc(*len, sizeof(char *), GFP_ATOMIC);\n\tif (!*names)\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\t*values = kcalloc(*len, sizeof(int), GFP_ATOMIC);\n\tif (!*values)\n\t\tgoto err;\n\n\tfor (i = 0; i < *len; i++) {\n\t\t(*values)[i] = policydb.bool_val_to_struct[i]->state;\n\n\t\trc = -ENOMEM;\n\t\t(*names)[i] = kstrdup(sym_name(&policydb, SYM_BOOLS, i), GFP_ATOMIC);\n\t\tif (!(*names)[i])\n\t\t\tgoto err;\n\t}\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\nerr:\n\tif (*names) {\n\t\tfor (i = 0; i < *len; i++)\n\t\t\tkfree((*names)[i]);\n\t}\n\tkfree(*values);\n\tgoto out;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nint security_get_bools(int *len, char ***names, int **values)\n{\n\tint i, rc;\n\n\tread_lock(&policy_rwlock);\n\t*names = NULL;\n\t*values = NULL;\n\n\trc = 0;\n\t*len = policydb.p_bools.nprim;\n\tif (!*len)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\t*names = kcalloc(*len, sizeof(char *), GFP_ATOMIC);\n\tif (!*names)\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\t*values = kcalloc(*len, sizeof(int), GFP_ATOMIC);\n\tif (!*values)\n\t\tgoto err;\n\n\tfor (i = 0; i < *len; i++) {\n\t\t(*values)[i] = policydb.bool_val_to_struct[i]->state;\n\n\t\trc = -ENOMEM;\n\t\t(*names)[i] = kstrdup(sym_name(&policydb, SYM_BOOLS, i), GFP_ATOMIC);\n\t\tif (!(*names)[i])\n\t\t\tgoto err;\n\t}\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\nerr:\n\tif (*names) {\n\t\tfor (i = 0; i < *len; i++)\n\t\t\tkfree((*names)[i]);\n\t}\n\tkfree(*values);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bool_pending_values"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bool_pending_names"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bool_pending_names[i]"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define BOOL_DIR_NAME \"booleans\"\n#define SEL_BOOL_INO_OFFSET\t\t0x02000000\n\nstatic struct dentry *bool_dir;\nstatic int bool_num;\nstatic char **bool_pending_names;\nstatic int *bool_pending_values;\nstatic int sel_make_bools(void);\nstatic const struct file_operations sel_bool_ops = {\n\t.read\t\t= sel_read_bool,\n\t.write\t\t= sel_write_bool,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_bools(void)\n{\n\tint i, ret;\n\tssize_t len;\n\tstruct dentry *dentry = NULL;\n\tstruct dentry *dir = bool_dir;\n\tstruct inode *inode = NULL;\n\tstruct inode_security_struct *isec;\n\tchar **names = NULL, *page;\n\tint num;\n\tint *values = NULL;\n\tu32 sid;\n\n\t/* remove any existing files */\n\tfor (i = 0; i < bool_num; i++)\n\t\tkfree(bool_pending_names[i]);\n\tkfree(bool_pending_names);\n\tkfree(bool_pending_values);\n\tbool_num = 0;\n\tbool_pending_names = NULL;\n\tbool_pending_values = NULL;\n\n\tsel_remove_entries(dir);\n\n\tret = -ENOMEM;\n\tpage = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto out;\n\n\tret = security_get_bools(&num, &names, &values);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = -ENOMEM;\n\t\tdentry = d_alloc_name(dir, names[i]);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\n\t\tret = -ENOMEM;\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG | S_IRUGO | S_IWUSR);\n\t\tif (!inode)\n\t\t\tgoto out;\n\n\t\tret = -ENAMETOOLONG;\n\t\tlen = snprintf(page, PAGE_SIZE, \"/%s/%s\", BOOL_DIR_NAME, names[i]);\n\t\tif (len >= PAGE_SIZE)\n\t\t\tgoto out;\n\n\t\tisec = (struct inode_security_struct *)inode->i_security;\n\t\tret = security_genfs_sid(\"selinuxfs\", page, SECCLASS_FILE, &sid);\n\t\tif (ret) {\n\t\t\tpr_warn_ratelimited(\"SELinux: no sid found, defaulting to security isid for %s\\n\",\n\t\t\t\t\t   page);\n\t\t\tsid = SECINITSID_SECURITY;\n\t\t}\n\n\t\tisec->sid = sid;\n\t\tisec->initialized = LABEL_INITIALIZED;\n\t\tinode->i_fop = &sel_bool_ops;\n\t\tinode->i_ino = i|SEL_BOOL_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\tbool_num = num;\n\tbool_pending_names = names;\n\tbool_pending_values = values;\n\n\tfree_page((unsigned long)page);\n\treturn 0;\nout:\n\tfree_page((unsigned long)page);\n\n\tif (names) {\n\t\tfor (i = 0; i < num; i++)\n\t\t\tkfree(names[i]);\n\t\tkfree(names);\n\t}\n\tkfree(values);\n\tsel_remove_entries(dir);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sel_remove_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1245-1249",
    "snippet": "static void sel_remove_entries(struct dentry *de)\n{\n\td_genocide(de);\n\tshrink_dcache_parent(de);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shrink_dcache_parent",
          "args": [
            "de"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_genocide",
          "args": [
            "de"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic void sel_remove_entries(struct dentry *de)\n{\n\td_genocide(de);\n\tshrink_dcache_parent(de);\n}"
  },
  {
    "function_name": "sel_commit_bools_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1191-1238",
    "snippet": "static ssize_t sel_commit_bools_write(struct file *filep,\n\t\t\t\t      const char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *page = NULL;\n\tssize_t length;\n\tint new_value;\n\n\tmutex_lock(&sel_mutex);\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__SETBOOL,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tif (count >= PAGE_SIZE)\n\t\tgoto out;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page)) {\n\t\tlength = PTR_ERR(page);\n\t\tpage = NULL;\n\t\tgoto out;\n\t}\n\n\tlength = -EINVAL;\n\tif (sscanf(page, \"%d\", &new_value) != 1)\n\t\tgoto out;\n\n\tlength = 0;\n\tif (new_value && bool_pending_values)\n\t\tlength = security_set_bools(bool_num, bool_pending_values);\n\n\tif (!length)\n\t\tlength = count;\n\nout:\n\tmutex_unlock(&sel_mutex);\n\tkfree(page);\n\treturn length;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(sel_mutex);",
      "static int bool_num;",
      "static int *bool_pending_values;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "page"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sel_mutex"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_set_bools",
          "args": [
            "bool_num",
            "bool_pending_values"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "security_set_bools",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2748-2795",
          "snippet": "int security_set_bools(int len, int *values)\n{\n\tint i, rc;\n\tint lenp, seqno = 0;\n\tstruct cond_node *cur;\n\n\twrite_lock_irq(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlenp = policydb.p_bools.nprim;\n\tif (len != lenp)\n\t\tgoto out;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!!values[i] != policydb.bool_val_to_struct[i]->state) {\n\t\t\taudit_log(current->audit_context, GFP_ATOMIC,\n\t\t\t\tAUDIT_MAC_CONFIG_CHANGE,\n\t\t\t\t\"bool=%s val=%d old_val=%d auid=%u ses=%u\",\n\t\t\t\tsym_name(&policydb, SYM_BOOLS, i),\n\t\t\t\t!!values[i],\n\t\t\t\tpolicydb.bool_val_to_struct[i]->state,\n\t\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t\taudit_get_sessionid(current));\n\t\t}\n\t\tif (values[i])\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 1;\n\t\telse\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 0;\n\t}\n\n\tfor (cur = policydb.cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(&policydb, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tseqno = ++latest_granting;\n\trc = 0;\nout:\n\twrite_unlock_irq(&policy_rwlock);\n\tif (!rc) {\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_xfrm_notify_policyload();\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "struct policydb policydb;",
            "static u32 latest_granting;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\nstatic u32 latest_granting;\n\nint security_set_bools(int len, int *values)\n{\n\tint i, rc;\n\tint lenp, seqno = 0;\n\tstruct cond_node *cur;\n\n\twrite_lock_irq(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlenp = policydb.p_bools.nprim;\n\tif (len != lenp)\n\t\tgoto out;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!!values[i] != policydb.bool_val_to_struct[i]->state) {\n\t\t\taudit_log(current->audit_context, GFP_ATOMIC,\n\t\t\t\tAUDIT_MAC_CONFIG_CHANGE,\n\t\t\t\t\"bool=%s val=%d old_val=%d auid=%u ses=%u\",\n\t\t\t\tsym_name(&policydb, SYM_BOOLS, i),\n\t\t\t\t!!values[i],\n\t\t\t\tpolicydb.bool_val_to_struct[i]->state,\n\t\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t\taudit_get_sessionid(current));\n\t\t}\n\t\tif (values[i])\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 1;\n\t\telse\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 0;\n\t}\n\n\tfor (cur = policydb.cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(&policydb, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tseqno = ++latest_granting;\n\trc = 0;\nout:\n\twrite_unlock_irq(&policy_rwlock);\n\tif (!rc) {\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_xfrm_notify_policyload();\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "page",
            "\"%d\"",
            "&new_value"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__SETBOOL",
            "NULL"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sel_mutex"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(sel_mutex);\nstatic int bool_num;\nstatic int *bool_pending_values;\n\nstatic ssize_t sel_commit_bools_write(struct file *filep,\n\t\t\t\t      const char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *page = NULL;\n\tssize_t length;\n\tint new_value;\n\n\tmutex_lock(&sel_mutex);\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__SETBOOL,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tif (count >= PAGE_SIZE)\n\t\tgoto out;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page)) {\n\t\tlength = PTR_ERR(page);\n\t\tpage = NULL;\n\t\tgoto out;\n\t}\n\n\tlength = -EINVAL;\n\tif (sscanf(page, \"%d\", &new_value) != 1)\n\t\tgoto out;\n\n\tlength = 0;\n\tif (new_value && bool_pending_values)\n\t\tlength = security_set_bools(bool_num, bool_pending_values);\n\n\tif (!length)\n\t\tlength = count;\n\nout:\n\tmutex_unlock(&sel_mutex);\n\tkfree(page);\n\treturn length;\n}"
  },
  {
    "function_name": "sel_write_bool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1132-1183",
    "snippet": "static ssize_t sel_write_bool(struct file *filep, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *page = NULL;\n\tssize_t length;\n\tint new_value;\n\tunsigned index = file_inode(filep)->i_ino & SEL_INO_MASK;\n\tconst char *name = filep->f_path.dentry->d_name.name;\n\n\tmutex_lock(&sel_mutex);\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__SETBOOL,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (index >= bool_num || strcmp(name, bool_pending_names[index]))\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tif (count >= PAGE_SIZE)\n\t\tgoto out;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page)) {\n\t\tlength = PTR_ERR(page);\n\t\tpage = NULL;\n\t\tgoto out;\n\t}\n\n\tlength = -EINVAL;\n\tif (sscanf(page, \"%d\", &new_value) != 1)\n\t\tgoto out;\n\n\tif (new_value)\n\t\tnew_value = 1;\n\n\tbool_pending_values[index] = new_value;\n\tlength = count;\n\nout:\n\tmutex_unlock(&sel_mutex);\n\tkfree(page);\n\treturn length;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SEL_INO_MASK\t\t\t0x00ffffff"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(sel_mutex);",
      "static int bool_num;",
      "static char **bool_pending_names;",
      "static int *bool_pending_values;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "page"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sel_mutex"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "page",
            "\"%d\"",
            "&new_value"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "bool_pending_names[index]"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__SETBOOL",
            "NULL"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sel_mutex"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filep"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_INO_MASK\t\t\t0x00ffffff\n\nstatic DEFINE_MUTEX(sel_mutex);\nstatic int bool_num;\nstatic char **bool_pending_names;\nstatic int *bool_pending_values;\n\nstatic ssize_t sel_write_bool(struct file *filep, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *page = NULL;\n\tssize_t length;\n\tint new_value;\n\tunsigned index = file_inode(filep)->i_ino & SEL_INO_MASK;\n\tconst char *name = filep->f_path.dentry->d_name.name;\n\n\tmutex_lock(&sel_mutex);\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__SETBOOL,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (index >= bool_num || strcmp(name, bool_pending_names[index]))\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tif (count >= PAGE_SIZE)\n\t\tgoto out;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page)) {\n\t\tlength = PTR_ERR(page);\n\t\tpage = NULL;\n\t\tgoto out;\n\t}\n\n\tlength = -EINVAL;\n\tif (sscanf(page, \"%d\", &new_value) != 1)\n\t\tgoto out;\n\n\tif (new_value)\n\t\tnew_value = 1;\n\n\tbool_pending_values[index] = new_value;\n\tlength = count;\n\nout:\n\tmutex_unlock(&sel_mutex);\n\tkfree(page);\n\treturn length;\n}"
  },
  {
    "function_name": "sel_read_bool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1097-1130",
    "snippet": "static ssize_t sel_read_bool(struct file *filep, char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar *page = NULL;\n\tssize_t length;\n\tssize_t ret;\n\tint cur_enforcing;\n\tunsigned index = file_inode(filep)->i_ino & SEL_INO_MASK;\n\tconst char *name = filep->f_path.dentry->d_name.name;\n\n\tmutex_lock(&sel_mutex);\n\n\tret = -EINVAL;\n\tif (index >= bool_num || strcmp(name, bool_pending_names[index]))\n\t\tgoto out;\n\n\tret = -ENOMEM;\n\tpage = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto out;\n\n\tcur_enforcing = security_get_bool_value(index);\n\tif (cur_enforcing < 0) {\n\t\tret = cur_enforcing;\n\t\tgoto out;\n\t}\n\tlength = scnprintf(page, PAGE_SIZE, \"%d %d\", cur_enforcing,\n\t\t\t  bool_pending_values[index]);\n\tret = simple_read_from_buffer(buf, count, ppos, page, length);\nout:\n\tmutex_unlock(&sel_mutex);\n\tfree_page((unsigned long)page);\n\treturn ret;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SEL_INO_MASK\t\t\t0x00ffffff"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(sel_mutex);",
      "static int bool_num;",
      "static char **bool_pending_names;",
      "static int *bool_pending_values;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)page"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sel_mutex"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "page",
            "length"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "page",
            "PAGE_SIZE",
            "\"%d %d\"",
            "cur_enforcing",
            "bool_pending_values[index]"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_get_bool_value",
          "args": [
            "index"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "security_get_bool_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2797-2813",
          "snippet": "int security_get_bool_value(int index)\n{\n\tint rc;\n\tint len;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlen = policydb.p_bools.nprim;\n\tif (index >= len)\n\t\tgoto out;\n\n\trc = policydb.bool_val_to_struct[index]->state;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nint security_get_bool_value(int index)\n{\n\tint rc;\n\tint len;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlen = policydb.p_bools.nprim;\n\tif (index >= len)\n\t\tgoto out;\n\n\trc = policydb.bool_val_to_struct[index]->state;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "bool_pending_names[index]"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sel_mutex"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filep"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_INO_MASK\t\t\t0x00ffffff\n\nstatic DEFINE_MUTEX(sel_mutex);\nstatic int bool_num;\nstatic char **bool_pending_names;\nstatic int *bool_pending_values;\n\nstatic ssize_t sel_read_bool(struct file *filep, char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar *page = NULL;\n\tssize_t length;\n\tssize_t ret;\n\tint cur_enforcing;\n\tunsigned index = file_inode(filep)->i_ino & SEL_INO_MASK;\n\tconst char *name = filep->f_path.dentry->d_name.name;\n\n\tmutex_lock(&sel_mutex);\n\n\tret = -EINVAL;\n\tif (index >= bool_num || strcmp(name, bool_pending_names[index]))\n\t\tgoto out;\n\n\tret = -ENOMEM;\n\tpage = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto out;\n\n\tcur_enforcing = security_get_bool_value(index);\n\tif (cur_enforcing < 0) {\n\t\tret = cur_enforcing;\n\t\tgoto out;\n\t}\n\tlength = scnprintf(page, PAGE_SIZE, \"%d %d\", cur_enforcing,\n\t\t\t  bool_pending_values[index]);\n\tret = simple_read_from_buffer(buf, count, ppos, page, length);\nout:\n\tmutex_unlock(&sel_mutex);\n\tfree_page((unsigned long)page);\n\treturn ret;\n}"
  },
  {
    "function_name": "sel_make_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1086-1095",
    "snippet": "static struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "ret"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_smack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "295-308",
          "snippet": "static struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *smack_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct kmem_cache *smack_inode_cache;\n\nstatic struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct inode *sel_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret = new_inode(sb);\n\n\tif (ret) {\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = ret->i_ctime = current_time(ret);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sel_write_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "1025-1084",
    "snippet": "static ssize_t sel_write_member(struct file *file, char *buf, size_t size)\n{\n\tchar *scon = NULL, *tcon = NULL;\n\tu32 ssid, tsid, newsid;\n\tu16 tclass;\n\tssize_t length;\n\tchar *newcon = NULL;\n\tu32 len;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_MEMBER,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tscon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!scon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\ttcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!tcon)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(buf, \"%s %s %hu\", scon, tcon, &tclass) != 3)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(scon, &ssid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(tcon, &tsid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_member_sid(ssid, tsid, tclass, &newsid);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_sid_to_context(newsid, &newcon, &len);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ERANGE;\n\tif (len > SIMPLE_TRANSACTION_LIMIT) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  context size (%u) exceeds \"\n\t\t\t\"payload max\\n\", __func__, len);\n\t\tgoto out;\n\t}\n\n\tmemcpy(buf, newcon, len);\n\tlength = len;\nout:\n\tkfree(newcon);\n\tkfree(tcon);\n\tkfree(scon);\n\treturn length;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t sel_write_access(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_create(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_user(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_member(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "scon"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tcon"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newcon"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "newcon",
            "len"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  context size (%u) exceeds \"\n\t\t\t\"payload max\\n\"",
            "__func__",
            "len"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sid_to_context",
          "args": [
            "newsid",
            "&newcon",
            "&len"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "security_sid_to_context_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1314-1317",
          "snippet": "int security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_member_sid",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "&newsid"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "security_member_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1787-1794",
          "snippet": "int security_member_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_MEMBER, NULL,\n\t\t\t\t    out_sid, false);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_member_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_MEMBER, NULL,\n\t\t\t\t    out_sid, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_context_str_to_sid",
          "args": [
            "tcon",
            "&tsid",
            "GFP_KERNEL"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "security_context_str_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1483-1486",
          "snippet": "int security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%s %s %hu\"",
            "scon",
            "tcon",
            "&tclass"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + 1",
            "GFP_KERNEL"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + 1",
            "GFP_KERNEL"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__COMPUTE_MEMBER",
            "NULL"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sel_write_access(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_create(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_user(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_member(struct file *file, char *buf, size_t size);\n\nstatic ssize_t sel_write_member(struct file *file, char *buf, size_t size)\n{\n\tchar *scon = NULL, *tcon = NULL;\n\tu32 ssid, tsid, newsid;\n\tu16 tclass;\n\tssize_t length;\n\tchar *newcon = NULL;\n\tu32 len;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_MEMBER,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tscon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!scon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\ttcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!tcon)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(buf, \"%s %s %hu\", scon, tcon, &tclass) != 3)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(scon, &ssid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(tcon, &tsid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_member_sid(ssid, tsid, tclass, &newsid);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_sid_to_context(newsid, &newcon, &len);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ERANGE;\n\tif (len > SIMPLE_TRANSACTION_LIMIT) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  context size (%u) exceeds \"\n\t\t\t\"payload max\\n\", __func__, len);\n\t\tgoto out;\n\t}\n\n\tmemcpy(buf, newcon, len);\n\tlength = len;\nout:\n\tkfree(newcon);\n\tkfree(tcon);\n\tkfree(scon);\n\treturn length;\n}"
  },
  {
    "function_name": "sel_write_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "963-1023",
    "snippet": "static ssize_t sel_write_user(struct file *file, char *buf, size_t size)\n{\n\tchar *con = NULL, *user = NULL, *ptr;\n\tu32 sid, *sids = NULL;\n\tssize_t length;\n\tchar *newcon;\n\tint i, rc;\n\tu32 len, nsids;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_USER,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!con)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tuser = kzalloc(size + 1, GFP_KERNEL);\n\tif (!user)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(buf, \"%s %s\", con, user) != 2)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(con, &sid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_get_user_sids(sid, user, &sids, &nsids);\n\tif (length)\n\t\tgoto out;\n\n\tlength = sprintf(buf, \"%u\", nsids) + 1;\n\tptr = buf + length;\n\tfor (i = 0; i < nsids; i++) {\n\t\trc = security_sid_to_context(sids[i], &newcon, &len);\n\t\tif (rc) {\n\t\t\tlength = rc;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((length + len) >= SIMPLE_TRANSACTION_LIMIT) {\n\t\t\tkfree(newcon);\n\t\t\tlength = -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(ptr, newcon, len);\n\t\tkfree(newcon);\n\t\tptr += len;\n\t\tlength += len;\n\t}\nout:\n\tkfree(sids);\n\tkfree(user);\n\tkfree(con);\n\treturn length;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t sel_write_access(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_create(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_user(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_member(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "con"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "user"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sids"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newcon"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "newcon",
            "len"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newcon"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sid_to_context",
          "args": [
            "sids[i]",
            "&newcon",
            "&len"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "security_sid_to_context_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1314-1317",
          "snippet": "int security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\"",
            "nsids"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_get_user_sids",
          "args": [
            "sid",
            "user",
            "&sids",
            "&nsids"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "security_get_user_sids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2473-2570",
          "snippet": "int security_get_user_sids(u32 fromsid,\n\t\t\t   char *username,\n\t\t\t   u32 **sids,\n\t\t\t   u32 *nel)\n{\n\tstruct context *fromcon, usercon;\n\tu32 *mysids = NULL, *mysids2, sid;\n\tu32 mynel = 0, maxnel = SIDS_NEL;\n\tstruct user_datum *user;\n\tstruct role_datum *role;\n\tstruct ebitmap_node *rnode, *tnode;\n\tint rc = 0, i, j;\n\n\t*sids = NULL;\n\t*nel = 0;\n\n\tif (!ss_initialized)\n\t\tgoto out;\n\n\tread_lock(&policy_rwlock);\n\n\tcontext_init(&usercon);\n\n\trc = -EINVAL;\n\tfromcon = sidtab_search(&sidtab, fromsid);\n\tif (!fromcon)\n\t\tgoto out_unlock;\n\n\trc = -EINVAL;\n\tuser = hashtab_search(policydb.p_users.table, username);\n\tif (!user)\n\t\tgoto out_unlock;\n\n\tusercon.user = user->value;\n\n\trc = -ENOMEM;\n\tmysids = kcalloc(maxnel, sizeof(*mysids), GFP_ATOMIC);\n\tif (!mysids)\n\t\tgoto out_unlock;\n\n\tebitmap_for_each_positive_bit(&user->roles, rnode, i) {\n\t\trole = policydb.role_val_to_struct[i];\n\t\tusercon.role = i + 1;\n\t\tebitmap_for_each_positive_bit(&role->types, tnode, j) {\n\t\t\tusercon.type = j + 1;\n\n\t\t\tif (mls_setup_user_range(fromcon, user, &usercon))\n\t\t\t\tcontinue;\n\n\t\t\trc = sidtab_context_to_sid(&sidtab, &usercon, &sid);\n\t\t\tif (rc)\n\t\t\t\tgoto out_unlock;\n\t\t\tif (mynel < maxnel) {\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t} else {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tmaxnel += SIDS_NEL;\n\t\t\t\tmysids2 = kcalloc(maxnel, sizeof(*mysids2), GFP_ATOMIC);\n\t\t\t\tif (!mysids2)\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\tmemcpy(mysids2, mysids, mynel * sizeof(*mysids2));\n\t\t\t\tkfree(mysids);\n\t\t\t\tmysids = mysids2;\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tif (rc || !mynel) {\n\t\tkfree(mysids);\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\tmysids2 = kcalloc(mynel, sizeof(*mysids2), GFP_KERNEL);\n\tif (!mysids2) {\n\t\tkfree(mysids);\n\t\tgoto out;\n\t}\n\tfor (i = 0, j = 0; i < mynel; i++) {\n\t\tstruct av_decision dummy_avd;\n\t\trc = avc_has_perm_noaudit(fromsid, mysids[i],\n\t\t\t\t\t  SECCLASS_PROCESS, /* kernel value */\n\t\t\t\t\t  PROCESS__TRANSITION, AVC_STRICT,\n\t\t\t\t\t  &dummy_avd);\n\t\tif (!rc)\n\t\t\tmysids2[j++] = mysids[i];\n\t\tcond_resched();\n\t}\n\trc = 0;\n\tkfree(mysids);\n\t*sids = mysids2;\n\t*nel = j;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SIDS_NEL 25"
          ],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define SIDS_NEL 25\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nint security_get_user_sids(u32 fromsid,\n\t\t\t   char *username,\n\t\t\t   u32 **sids,\n\t\t\t   u32 *nel)\n{\n\tstruct context *fromcon, usercon;\n\tu32 *mysids = NULL, *mysids2, sid;\n\tu32 mynel = 0, maxnel = SIDS_NEL;\n\tstruct user_datum *user;\n\tstruct role_datum *role;\n\tstruct ebitmap_node *rnode, *tnode;\n\tint rc = 0, i, j;\n\n\t*sids = NULL;\n\t*nel = 0;\n\n\tif (!ss_initialized)\n\t\tgoto out;\n\n\tread_lock(&policy_rwlock);\n\n\tcontext_init(&usercon);\n\n\trc = -EINVAL;\n\tfromcon = sidtab_search(&sidtab, fromsid);\n\tif (!fromcon)\n\t\tgoto out_unlock;\n\n\trc = -EINVAL;\n\tuser = hashtab_search(policydb.p_users.table, username);\n\tif (!user)\n\t\tgoto out_unlock;\n\n\tusercon.user = user->value;\n\n\trc = -ENOMEM;\n\tmysids = kcalloc(maxnel, sizeof(*mysids), GFP_ATOMIC);\n\tif (!mysids)\n\t\tgoto out_unlock;\n\n\tebitmap_for_each_positive_bit(&user->roles, rnode, i) {\n\t\trole = policydb.role_val_to_struct[i];\n\t\tusercon.role = i + 1;\n\t\tebitmap_for_each_positive_bit(&role->types, tnode, j) {\n\t\t\tusercon.type = j + 1;\n\n\t\t\tif (mls_setup_user_range(fromcon, user, &usercon))\n\t\t\t\tcontinue;\n\n\t\t\trc = sidtab_context_to_sid(&sidtab, &usercon, &sid);\n\t\t\tif (rc)\n\t\t\t\tgoto out_unlock;\n\t\t\tif (mynel < maxnel) {\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t} else {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tmaxnel += SIDS_NEL;\n\t\t\t\tmysids2 = kcalloc(maxnel, sizeof(*mysids2), GFP_ATOMIC);\n\t\t\t\tif (!mysids2)\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\tmemcpy(mysids2, mysids, mynel * sizeof(*mysids2));\n\t\t\t\tkfree(mysids);\n\t\t\t\tmysids = mysids2;\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tif (rc || !mynel) {\n\t\tkfree(mysids);\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\tmysids2 = kcalloc(mynel, sizeof(*mysids2), GFP_KERNEL);\n\tif (!mysids2) {\n\t\tkfree(mysids);\n\t\tgoto out;\n\t}\n\tfor (i = 0, j = 0; i < mynel; i++) {\n\t\tstruct av_decision dummy_avd;\n\t\trc = avc_has_perm_noaudit(fromsid, mysids[i],\n\t\t\t\t\t  SECCLASS_PROCESS, /* kernel value */\n\t\t\t\t\t  PROCESS__TRANSITION, AVC_STRICT,\n\t\t\t\t\t  &dummy_avd);\n\t\tif (!rc)\n\t\t\tmysids2[j++] = mysids[i];\n\t\tcond_resched();\n\t}\n\trc = 0;\n\tkfree(mysids);\n\t*sids = mysids2;\n\t*nel = j;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_context_str_to_sid",
          "args": [
            "con",
            "&sid",
            "GFP_KERNEL"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "security_context_str_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1483-1486",
          "snippet": "int security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%s %s\"",
            "con",
            "user"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + 1",
            "GFP_KERNEL"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + 1",
            "GFP_KERNEL"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__COMPUTE_USER",
            "NULL"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sel_write_access(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_create(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_user(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_member(struct file *file, char *buf, size_t size);\n\nstatic ssize_t sel_write_user(struct file *file, char *buf, size_t size)\n{\n\tchar *con = NULL, *user = NULL, *ptr;\n\tu32 sid, *sids = NULL;\n\tssize_t length;\n\tchar *newcon;\n\tint i, rc;\n\tu32 len, nsids;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_USER,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!con)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tuser = kzalloc(size + 1, GFP_KERNEL);\n\tif (!user)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(buf, \"%s %s\", con, user) != 2)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(con, &sid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_get_user_sids(sid, user, &sids, &nsids);\n\tif (length)\n\t\tgoto out;\n\n\tlength = sprintf(buf, \"%u\", nsids) + 1;\n\tptr = buf + length;\n\tfor (i = 0; i < nsids; i++) {\n\t\trc = security_sid_to_context(sids[i], &newcon, &len);\n\t\tif (rc) {\n\t\t\tlength = rc;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((length + len) >= SIMPLE_TRANSACTION_LIMIT) {\n\t\t\tkfree(newcon);\n\t\t\tlength = -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(ptr, newcon, len);\n\t\tkfree(newcon);\n\t\tptr += len;\n\t\tlength += len;\n\t}\nout:\n\tkfree(sids);\n\tkfree(user);\n\tkfree(con);\n\treturn length;\n}"
  },
  {
    "function_name": "sel_write_relabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "905-961",
    "snippet": "static ssize_t sel_write_relabel(struct file *file, char *buf, size_t size)\n{\n\tchar *scon = NULL, *tcon = NULL;\n\tu32 ssid, tsid, newsid;\n\tu16 tclass;\n\tssize_t length;\n\tchar *newcon = NULL;\n\tu32 len;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_RELABEL,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tscon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!scon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\ttcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!tcon)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(buf, \"%s %s %hu\", scon, tcon, &tclass) != 3)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(scon, &ssid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(tcon, &tsid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_change_sid(ssid, tsid, tclass, &newsid);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_sid_to_context(newsid, &newcon, &len);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ERANGE;\n\tif (len > SIMPLE_TRANSACTION_LIMIT)\n\t\tgoto out;\n\n\tmemcpy(buf, newcon, len);\n\tlength = len;\nout:\n\tkfree(newcon);\n\tkfree(tcon);\n\tkfree(scon);\n\treturn length;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t sel_write_access(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_create(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_user(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_member(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "scon"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tcon"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newcon"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "newcon",
            "len"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sid_to_context",
          "args": [
            "newsid",
            "&newcon",
            "&len"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "security_sid_to_context_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1314-1317",
          "snippet": "int security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_change_sid",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "&newsid"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "security_change_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1809-1816",
          "snippet": "int security_change_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_CHANGE, NULL,\n\t\t\t\t    out_sid, false);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_change_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_CHANGE, NULL,\n\t\t\t\t    out_sid, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_context_str_to_sid",
          "args": [
            "tcon",
            "&tsid",
            "GFP_KERNEL"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "security_context_str_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1483-1486",
          "snippet": "int security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%s %s %hu\"",
            "scon",
            "tcon",
            "&tclass"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + 1",
            "GFP_KERNEL"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + 1",
            "GFP_KERNEL"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__COMPUTE_RELABEL",
            "NULL"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sel_write_access(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_create(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_user(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_member(struct file *file, char *buf, size_t size);\n\nstatic ssize_t sel_write_relabel(struct file *file, char *buf, size_t size)\n{\n\tchar *scon = NULL, *tcon = NULL;\n\tu32 ssid, tsid, newsid;\n\tu16 tclass;\n\tssize_t length;\n\tchar *newcon = NULL;\n\tu32 len;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_RELABEL,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tscon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!scon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\ttcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!tcon)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(buf, \"%s %s %hu\", scon, tcon, &tclass) != 3)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(scon, &ssid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(tcon, &tsid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_change_sid(ssid, tsid, tclass, &newsid);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_sid_to_context(newsid, &newcon, &len);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ERANGE;\n\tif (len > SIMPLE_TRANSACTION_LIMIT)\n\t\tgoto out;\n\n\tmemcpy(buf, newcon, len);\n\tlength = len;\nout:\n\tkfree(newcon);\n\tkfree(tcon);\n\tkfree(scon);\n\treturn length;\n}"
  },
  {
    "function_name": "sel_write_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "804-903",
    "snippet": "static ssize_t sel_write_create(struct file *file, char *buf, size_t size)\n{\n\tchar *scon = NULL, *tcon = NULL;\n\tchar *namebuf = NULL, *objname = NULL;\n\tu32 ssid, tsid, newsid;\n\tu16 tclass;\n\tssize_t length;\n\tchar *newcon = NULL;\n\tu32 len;\n\tint nargs;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_CREATE,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tscon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!scon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\ttcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!tcon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tnamebuf = kzalloc(size + 1, GFP_KERNEL);\n\tif (!namebuf)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tnargs = sscanf(buf, \"%s %s %hu %s\", scon, tcon, &tclass, namebuf);\n\tif (nargs < 3 || nargs > 4)\n\t\tgoto out;\n\tif (nargs == 4) {\n\t\t/*\n\t\t * If and when the name of new object to be queried contains\n\t\t * either whitespace or multibyte characters, they shall be\n\t\t * encoded based on the percentage-encoding rule.\n\t\t * If not encoded, the sscanf logic picks up only left-half\n\t\t * of the supplied name; splitted by a whitespace unexpectedly.\n\t\t */\n\t\tchar   *r, *w;\n\t\tint     c1, c2;\n\n\t\tr = w = namebuf;\n\t\tdo {\n\t\t\tc1 = *r++;\n\t\t\tif (c1 == '+')\n\t\t\t\tc1 = ' ';\n\t\t\telse if (c1 == '%') {\n\t\t\t\tc1 = hex_to_bin(*r++);\n\t\t\t\tif (c1 < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tc2 = hex_to_bin(*r++);\n\t\t\t\tif (c2 < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tc1 = (c1 << 4) | c2;\n\t\t\t}\n\t\t\t*w++ = c1;\n\t\t} while (c1 != '\\0');\n\n\t\tobjname = namebuf;\n\t}\n\n\tlength = security_context_str_to_sid(scon, &ssid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(tcon, &tsid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_transition_sid_user(ssid, tsid, tclass,\n\t\t\t\t\t      objname, &newsid);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_sid_to_context(newsid, &newcon, &len);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ERANGE;\n\tif (len > SIMPLE_TRANSACTION_LIMIT) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  context size (%u) exceeds \"\n\t\t\t\"payload max\\n\", __func__, len);\n\t\tgoto out;\n\t}\n\n\tmemcpy(buf, newcon, len);\n\tlength = len;\nout:\n\tkfree(newcon);\n\tkfree(namebuf);\n\tkfree(tcon);\n\tkfree(scon);\n\treturn length;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t sel_write_access(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_create(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_user(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_member(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "scon"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tcon"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "namebuf"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newcon"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "newcon",
            "len"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  context size (%u) exceeds \"\n\t\t\t\"payload max\\n\"",
            "__func__",
            "len"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sid_to_context",
          "args": [
            "newsid",
            "&newcon",
            "&len"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "security_sid_to_context_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1314-1317",
          "snippet": "int security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_transition_sid_user",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "objname",
            "&newsid"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "security_transition_sid_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1767-1772",
          "snippet": "int security_transition_sid_user(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\t const char *objname, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\n\t\t\t\t    objname, out_sid, false);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_transition_sid_user(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\t const char *objname, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\n\t\t\t\t    objname, out_sid, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_context_str_to_sid",
          "args": [
            "tcon",
            "&tsid",
            "GFP_KERNEL"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "security_context_str_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1483-1486",
          "snippet": "int security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "*r++"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "*r++"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%s %s %hu %s\"",
            "scon",
            "tcon",
            "&tclass",
            "namebuf"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + 1",
            "GFP_KERNEL"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + 1",
            "GFP_KERNEL"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + 1",
            "GFP_KERNEL"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__COMPUTE_CREATE",
            "NULL"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sel_write_access(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_create(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_user(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_member(struct file *file, char *buf, size_t size);\n\nstatic ssize_t sel_write_create(struct file *file, char *buf, size_t size)\n{\n\tchar *scon = NULL, *tcon = NULL;\n\tchar *namebuf = NULL, *objname = NULL;\n\tu32 ssid, tsid, newsid;\n\tu16 tclass;\n\tssize_t length;\n\tchar *newcon = NULL;\n\tu32 len;\n\tint nargs;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_CREATE,\n\t\t\t      NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tscon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!scon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\ttcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!tcon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tnamebuf = kzalloc(size + 1, GFP_KERNEL);\n\tif (!namebuf)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tnargs = sscanf(buf, \"%s %s %hu %s\", scon, tcon, &tclass, namebuf);\n\tif (nargs < 3 || nargs > 4)\n\t\tgoto out;\n\tif (nargs == 4) {\n\t\t/*\n\t\t * If and when the name of new object to be queried contains\n\t\t * either whitespace or multibyte characters, they shall be\n\t\t * encoded based on the percentage-encoding rule.\n\t\t * If not encoded, the sscanf logic picks up only left-half\n\t\t * of the supplied name; splitted by a whitespace unexpectedly.\n\t\t */\n\t\tchar   *r, *w;\n\t\tint     c1, c2;\n\n\t\tr = w = namebuf;\n\t\tdo {\n\t\t\tc1 = *r++;\n\t\t\tif (c1 == '+')\n\t\t\t\tc1 = ' ';\n\t\t\telse if (c1 == '%') {\n\t\t\t\tc1 = hex_to_bin(*r++);\n\t\t\t\tif (c1 < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tc2 = hex_to_bin(*r++);\n\t\t\t\tif (c2 < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tc1 = (c1 << 4) | c2;\n\t\t\t}\n\t\t\t*w++ = c1;\n\t\t} while (c1 != '\\0');\n\n\t\tobjname = namebuf;\n\t}\n\n\tlength = security_context_str_to_sid(scon, &ssid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(tcon, &tsid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_transition_sid_user(ssid, tsid, tclass,\n\t\t\t\t\t      objname, &newsid);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_sid_to_context(newsid, &newcon, &len);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ERANGE;\n\tif (len > SIMPLE_TRANSACTION_LIMIT) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  context size (%u) exceeds \"\n\t\t\t\"payload max\\n\", __func__, len);\n\t\tgoto out;\n\t}\n\n\tmemcpy(buf, newcon, len);\n\tlength = len;\nout:\n\tkfree(newcon);\n\tkfree(namebuf);\n\tkfree(tcon);\n\tkfree(scon);\n\treturn length;\n}"
  },
  {
    "function_name": "sel_write_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "756-802",
    "snippet": "static ssize_t sel_write_access(struct file *file, char *buf, size_t size)\n{\n\tchar *scon = NULL, *tcon = NULL;\n\tu32 ssid, tsid;\n\tu16 tclass;\n\tstruct av_decision avd;\n\tssize_t length;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_AV, NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tscon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!scon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\ttcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!tcon)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(buf, \"%s %s %hu\", scon, tcon, &tclass) != 3)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(scon, &ssid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(tcon, &tsid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tsecurity_compute_av_user(ssid, tsid, tclass, &avd);\n\n\tlength = scnprintf(buf, SIMPLE_TRANSACTION_LIMIT,\n\t\t\t  \"%x %x %x %x %u %x\",\n\t\t\t  avd.allowed, 0xffffffff,\n\t\t\t  avd.auditallow, avd.auditdeny,\n\t\t\t  avd.seqno, avd.flags);\nout:\n\tkfree(tcon);\n\tkfree(scon);\n\treturn length;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t sel_write_access(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_create(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_user(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_member(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "scon"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tcon"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "SIMPLE_TRANSACTION_LIMIT",
            "\"%x %x %x %x %u %x\"",
            "avd.allowed",
            "0xffffffff",
            "avd.auditallow",
            "avd.auditdeny",
            "avd.seqno",
            "avd.flags"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_compute_av_user",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "&avd"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "security_compute_av_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1140-1183",
          "snippet": "void security_compute_av_user(u32 ssid,\n\t\t\t      u32 tsid,\n\t\t\t      u16 tclass,\n\t\t\t      struct av_decision *avd)\n{\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\tread_lock(&policy_rwlock);\n\tavd_init(avd);\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t/* permissive domain? */\n\tif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(!tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\n\tcontext_struct_compute_av(scontext, tcontext, tclass, avd, NULL);\n out:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nvoid security_compute_av_user(u32 ssid,\n\t\t\t      u32 tsid,\n\t\t\t      u16 tclass,\n\t\t\t      struct av_decision *avd)\n{\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\tread_lock(&policy_rwlock);\n\tavd_init(avd);\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t/* permissive domain? */\n\tif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(!tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\n\tcontext_struct_compute_av(scontext, tcontext, tclass, avd, NULL);\n out:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_context_str_to_sid",
          "args": [
            "tcon",
            "&tsid",
            "GFP_KERNEL"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "security_context_str_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1483-1486",
          "snippet": "int security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%s %s %hu\"",
            "scon",
            "tcon",
            "&tclass"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + 1",
            "GFP_KERNEL"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size + 1",
            "GFP_KERNEL"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__COMPUTE_AV",
            "NULL"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sel_write_access(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_create(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_user(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_member(struct file *file, char *buf, size_t size);\n\nstatic ssize_t sel_write_access(struct file *file, char *buf, size_t size)\n{\n\tchar *scon = NULL, *tcon = NULL;\n\tu32 ssid, tsid;\n\tu16 tclass;\n\tstruct av_decision avd;\n\tssize_t length;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__COMPUTE_AV, NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tscon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!scon)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\ttcon = kzalloc(size + 1, GFP_KERNEL);\n\tif (!tcon)\n\t\tgoto out;\n\n\tlength = -EINVAL;\n\tif (sscanf(buf, \"%s %s %hu\", scon, tcon, &tclass) != 3)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(scon, &ssid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_str_to_sid(tcon, &tsid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tsecurity_compute_av_user(ssid, tsid, tclass, &avd);\n\n\tlength = scnprintf(buf, SIMPLE_TRANSACTION_LIMIT,\n\t\t\t  \"%x %x %x %x %u %x\",\n\t\t\t  avd.allowed, 0xffffffff,\n\t\t\t  avd.auditallow, avd.auditdeny,\n\t\t\t  avd.seqno, avd.flags);\nout:\n\tkfree(tcon);\n\tkfree(scon);\n\treturn length;\n}"
  },
  {
    "function_name": "selinux_transaction_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "722-741",
    "snippet": "static ssize_t selinux_transaction_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)\n{\n\tino_t ino = file_inode(file)->i_ino;\n\tchar *data;\n\tssize_t rv;\n\n\tif (ino >= ARRAY_SIZE(write_op) || !write_op[ino])\n\t\treturn -EINVAL;\n\n\tdata = simple_transaction_get(file, buf, size);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trv = write_op[ino](file, data, size);\n\tif (rv > 0) {\n\t\tsimple_transaction_set(file, rv);\n\t\trv = size;\n\t}\n\treturn rv;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);",
      "static ssize_t sel_write_access(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_create(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_user(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_member(struct file *file, char *buf, size_t size);",
      "static ssize_t (*write_op[])(struct file *, char *, size_t) = {\n\t[SEL_ACCESS] = sel_write_access,\n\t[SEL_CREATE] = sel_write_create,\n\t[SEL_RELABEL] = sel_write_relabel,\n\t[SEL_USER] = sel_write_user,\n\t[SEL_MEMBER] = sel_write_member,\n\t[SEL_CONTEXT] = sel_write_context,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_transaction_set",
          "args": [
            "file",
            "rv"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_op[ino]",
          "args": [
            "file",
            "data",
            "size"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_transaction_get",
          "args": [
            "file",
            "buf",
            "size"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "write_op"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);\nstatic ssize_t sel_write_access(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_create(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_user(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_member(struct file *file, char *buf, size_t size);\nstatic ssize_t (*write_op[])(struct file *, char *, size_t) = {\n\t[SEL_ACCESS] = sel_write_access,\n\t[SEL_CREATE] = sel_write_create,\n\t[SEL_RELABEL] = sel_write_relabel,\n\t[SEL_USER] = sel_write_user,\n\t[SEL_MEMBER] = sel_write_member,\n\t[SEL_CONTEXT] = sel_write_context,\n};\n\nstatic ssize_t selinux_transaction_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)\n{\n\tino_t ino = file_inode(file)->i_ino;\n\tchar *data;\n\tssize_t rv;\n\n\tif (ino >= ARRAY_SIZE(write_op) || !write_op[ino])\n\t\treturn -EINVAL;\n\n\tdata = simple_transaction_get(file, buf, size);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trv = write_op[ino](file, data, size);\n\tif (rv > 0) {\n\t\tsimple_transaction_set(file, rv);\n\t\trv = size;\n\t}\n\treturn rv;\n}"
  },
  {
    "function_name": "sel_write_validatetrans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "628-697",
    "snippet": "static ssize_t sel_write_validatetrans(struct file *file,\n\t\t\t\t\tconst char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *oldcon = NULL, *newcon = NULL, *taskcon = NULL;\n\tchar *req = NULL;\n\tu32 osid, nsid, tsid;\n\tu16 tclass;\n\tint rc;\n\n\trc = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t  SECCLASS_SECURITY, SECURITY__VALIDATE_TRANS, NULL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tif (count >= PAGE_SIZE)\n\t\tgoto out;\n\n\t/* No partial writes. */\n\trc = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\treq = memdup_user_nul(buf, count);\n\tif (IS_ERR(req)) {\n\t\trc = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\toldcon = kzalloc(count + 1, GFP_KERNEL);\n\tif (!oldcon)\n\t\tgoto out;\n\n\tnewcon = kzalloc(count + 1, GFP_KERNEL);\n\tif (!newcon)\n\t\tgoto out;\n\n\ttaskcon = kzalloc(count + 1, GFP_KERNEL);\n\tif (!taskcon)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif (sscanf(req, \"%s %s %hu %s\", oldcon, newcon, &tclass, taskcon) != 4)\n\t\tgoto out;\n\n\trc = security_context_str_to_sid(oldcon, &osid, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = security_context_str_to_sid(newcon, &nsid, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = security_context_str_to_sid(taskcon, &tsid, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = security_validate_transition_user(osid, nsid, tsid, tclass);\n\tif (!rc)\n\t\trc = count;\nout:\n\tkfree(req);\n\tkfree(oldcon);\n\tkfree(newcon);\n\tkfree(taskcon);\n\treturn rc;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "taskcon"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newcon"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oldcon"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "req"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_validate_transition_user",
          "args": [
            "osid",
            "nsid",
            "tsid",
            "tclass"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "security_validate_transition_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "840-845",
          "snippet": "int security_validate_transition_user(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t\tu16 tclass)\n{\n\treturn security_compute_validatetrans(oldsid, newsid, tasksid,\n\t\t\t\t\t\ttclass, true);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_validate_transition_user(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t\tu16 tclass)\n{\n\treturn security_compute_validatetrans(oldsid, newsid, tasksid,\n\t\t\t\t\t\ttclass, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_context_str_to_sid",
          "args": [
            "taskcon",
            "&tsid",
            "GFP_KERNEL"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "security_context_str_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1483-1486",
          "snippet": "int security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "req",
            "\"%s %s %hu %s\"",
            "oldcon",
            "newcon",
            "&tclass",
            "taskcon"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "count + 1",
            "GFP_KERNEL"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "count + 1",
            "GFP_KERNEL"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "count + 1",
            "GFP_KERNEL"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__VALIDATE_TRANS",
            "NULL"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sel_write_validatetrans(struct file *file,\n\t\t\t\t\tconst char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *oldcon = NULL, *newcon = NULL, *taskcon = NULL;\n\tchar *req = NULL;\n\tu32 osid, nsid, tsid;\n\tu16 tclass;\n\tint rc;\n\n\trc = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t  SECCLASS_SECURITY, SECURITY__VALIDATE_TRANS, NULL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tif (count >= PAGE_SIZE)\n\t\tgoto out;\n\n\t/* No partial writes. */\n\trc = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\treq = memdup_user_nul(buf, count);\n\tif (IS_ERR(req)) {\n\t\trc = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\toldcon = kzalloc(count + 1, GFP_KERNEL);\n\tif (!oldcon)\n\t\tgoto out;\n\n\tnewcon = kzalloc(count + 1, GFP_KERNEL);\n\tif (!newcon)\n\t\tgoto out;\n\n\ttaskcon = kzalloc(count + 1, GFP_KERNEL);\n\tif (!taskcon)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif (sscanf(req, \"%s %s %hu %s\", oldcon, newcon, &tclass, taskcon) != 4)\n\t\tgoto out;\n\n\trc = security_context_str_to_sid(oldcon, &osid, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = security_context_str_to_sid(newcon, &nsid, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = security_context_str_to_sid(taskcon, &tsid, GFP_KERNEL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = security_validate_transition_user(osid, nsid, tsid, tclass);\n\tif (!rc)\n\t\trc = count;\nout:\n\tkfree(req);\n\tkfree(oldcon);\n\tkfree(newcon);\n\tkfree(taskcon);\n\treturn rc;\n}"
  },
  {
    "function_name": "sel_write_checkreqprot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "588-621",
    "snippet": "static ssize_t sel_write_checkreqprot(struct file *file, const char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *page;\n\tssize_t length;\n\tunsigned int new_value;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__SETCHECKREQPROT,\n\t\t\t      NULL);\n\tif (length)\n\t\treturn length;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t/* No partial writes. */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tlength = -EINVAL;\n\tif (sscanf(page, \"%u\", &new_value) != 1)\n\t\tgoto out;\n\n\tselinux_checkreqprot = new_value ? 1 : 0;\n\tlength = count;\nout:\n\tkfree(page);\n\treturn length;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int selinux_checkreqprot = CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "page"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "page",
            "\"%u\"",
            "&new_value"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__SETCHECKREQPROT",
            "NULL"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nunsigned int selinux_checkreqprot = CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE;\n\nstatic ssize_t sel_write_checkreqprot(struct file *file, const char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *page;\n\tssize_t length;\n\tunsigned int new_value;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__SETCHECKREQPROT,\n\t\t\t      NULL);\n\tif (length)\n\t\treturn length;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t/* No partial writes. */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tlength = -EINVAL;\n\tif (sscanf(page, \"%u\", &new_value) != 1)\n\t\tgoto out;\n\n\tselinux_checkreqprot = new_value ? 1 : 0;\n\tlength = count;\nout:\n\tkfree(page);\n\treturn length;\n}"
  },
  {
    "function_name": "sel_read_checkreqprot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "578-586",
    "snippet": "static ssize_t sel_read_checkreqprot(struct file *filp, char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\", selinux_checkreqprot);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TMPBUFLEN\t12"
    ],
    "globals_used": [
      "unsigned int selinux_checkreqprot = CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "tmpbuf",
            "length"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "tmpbuf",
            "TMPBUFLEN",
            "\"%u\"",
            "selinux_checkreqprot"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define TMPBUFLEN\t12\n\nunsigned int selinux_checkreqprot = CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE;\n\nstatic ssize_t sel_read_checkreqprot(struct file *filp, char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\", selinux_checkreqprot);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}"
  },
  {
    "function_name": "sel_write_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "545-576",
    "snippet": "static ssize_t sel_write_context(struct file *file, char *buf, size_t size)\n{\n\tchar *canon = NULL;\n\tu32 sid, len;\n\tssize_t length;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__CHECK_CONTEXT, NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_to_sid(buf, size, &sid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_sid_to_context(sid, &canon, &len);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ERANGE;\n\tif (len > SIMPLE_TRANSACTION_LIMIT) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  context size (%u) exceeds \"\n\t\t\t\"payload max\\n\", __func__, len);\n\t\tgoto out;\n\t}\n\n\tmemcpy(buf, canon, len);\n\tlength = len;\nout:\n\tkfree(canon);\n\treturn length;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t sel_write_access(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_create(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_user(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_member(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "canon"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "canon",
            "len"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  context size (%u) exceeds \"\n\t\t\t\"payload max\\n\"",
            "__func__",
            "len"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sid_to_context",
          "args": [
            "sid",
            "&canon",
            "&len"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "security_sid_to_context_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1314-1317",
          "snippet": "int security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_context_to_sid",
          "args": [
            "buf",
            "size",
            "&sid",
            "GFP_KERNEL"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "security_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1476-1481",
          "snippet": "int security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid,\n\t\t\t    gfp_t gfp)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, gfp, 0);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid,\n\t\t\t    gfp_t gfp)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, gfp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__CHECK_CONTEXT",
            "NULL"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sel_write_access(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_create(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_user(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_member(struct file *file, char *buf, size_t size);\n\nstatic ssize_t sel_write_context(struct file *file, char *buf, size_t size)\n{\n\tchar *canon = NULL;\n\tu32 sid, len;\n\tssize_t length;\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__CHECK_CONTEXT, NULL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_context_to_sid(buf, size, &sid, GFP_KERNEL);\n\tif (length)\n\t\tgoto out;\n\n\tlength = security_sid_to_context(sid, &canon, &len);\n\tif (length)\n\t\tgoto out;\n\n\tlength = -ERANGE;\n\tif (len > SIMPLE_TRANSACTION_LIMIT) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  context size (%u) exceeds \"\n\t\t\t\"payload max\\n\", __func__, len);\n\t\tgoto out;\n\t}\n\n\tmemcpy(buf, canon, len);\n\tlength = len;\nout:\n\tkfree(canon);\n\treturn length;\n}"
  },
  {
    "function_name": "sel_write_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "471-538",
    "snippet": "static ssize_t sel_write_load(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n\n{\n\tssize_t length;\n\tvoid *data = NULL;\n\n\tmutex_lock(&sel_mutex);\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__LOAD_POLICY, NULL);\n\tif (length)\n\t\tgoto out;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tlength = -EFBIG;\n\tif (count > 64 * 1024 * 1024)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tdata = vmalloc(count);\n\tif (!data)\n\t\tgoto out;\n\n\tlength = -EFAULT;\n\tif (copy_from_user(data, buf, count) != 0)\n\t\tgoto out;\n\n\tlength = security_load_policy(data, count);\n\tif (length) {\n\t\tpr_warn_ratelimited(\"SELinux: failed to load policy\\n\");\n\t\tgoto out;\n\t}\n\n\tlength = sel_make_bools();\n\tif (length) {\n\t\tpr_err(\"SELinux: failed to load policy booleans\\n\");\n\t\tgoto out1;\n\t}\n\n\tlength = sel_make_classes();\n\tif (length) {\n\t\tpr_err(\"SELinux: failed to load policy classes\\n\");\n\t\tgoto out1;\n\t}\n\n\tlength = sel_make_policycap();\n\tif (length) {\n\t\tpr_err(\"SELinux: failed to load policy capabilities\\n\");\n\t\tgoto out1;\n\t}\n\n\tlength = count;\n\nout1:\n\taudit_log(current->audit_context, GFP_KERNEL, AUDIT_MAC_POLICY_LOAD,\n\t\t\"policy loaded auid=%u ses=%u\",\n\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\taudit_get_sessionid(current));\nout:\n\tmutex_unlock(&sel_mutex);\n\tvfree(data);\n\treturn length;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(sel_mutex);",
      "static int sel_make_bools(void);",
      "static int sel_make_classes(void);",
      "static int sel_make_policycap(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "data"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sel_mutex"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "current->audit_context",
            "GFP_KERNEL",
            "AUDIT_MAC_POLICY_LOAD",
            "\"policy loaded auid=%u ses=%u\"",
            "from_kuid(&init_user_ns, audit_get_loginuid(current))",
            "audit_get_sessionid(current)"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "audit_get_loginuid(current)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SELinux: failed to load policy capabilities\\n\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_policycap",
          "args": [],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_policycap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1735-1763",
          "snippet": "static int sel_make_policycap(void)\n{\n\tunsigned int iter;\n\tstruct dentry *dentry = NULL;\n\tstruct inode *inode = NULL;\n\n\tsel_remove_entries(policycap_dir);\n\n\tfor (iter = 0; iter <= POLICYDB_CAPABILITY_MAX; iter++) {\n\t\tif (iter < ARRAY_SIZE(selinux_policycap_names))\n\t\t\tdentry = d_alloc_name(policycap_dir,\n\t\t\t\t\t      selinux_policycap_names[iter]);\n\t\telse\n\t\t\tdentry = d_alloc_name(policycap_dir, \"unknown\");\n\n\t\tif (dentry == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(policycap_dir->d_sb, S_IFREG | S_IRUGO);\n\t\tif (inode == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tinode->i_fop = &sel_policycap_ops;\n\t\tinode->i_ino = iter | SEL_POLICYCAP_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SEL_POLICYCAP_INO_OFFSET\t0x08000000"
          ],
          "globals_used": [
            "static struct dentry *policycap_dir;",
            "static int sel_make_policycap(void);",
            "static const struct file_operations sel_policycap_ops = {\n\t.read\t\t= sel_read_policycap,\n\t.llseek\t\t= generic_file_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define SEL_POLICYCAP_INO_OFFSET\t0x08000000\n\nstatic struct dentry *policycap_dir;\nstatic int sel_make_policycap(void);\nstatic const struct file_operations sel_policycap_ops = {\n\t.read\t\t= sel_read_policycap,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_policycap(void)\n{\n\tunsigned int iter;\n\tstruct dentry *dentry = NULL;\n\tstruct inode *inode = NULL;\n\n\tsel_remove_entries(policycap_dir);\n\n\tfor (iter = 0; iter <= POLICYDB_CAPABILITY_MAX; iter++) {\n\t\tif (iter < ARRAY_SIZE(selinux_policycap_names))\n\t\t\tdentry = d_alloc_name(policycap_dir,\n\t\t\t\t\t      selinux_policycap_names[iter]);\n\t\telse\n\t\t\tdentry = d_alloc_name(policycap_dir, \"unknown\");\n\n\t\tif (dentry == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tinode = sel_make_inode(policycap_dir->d_sb, S_IFREG | S_IRUGO);\n\t\tif (inode == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tinode->i_fop = &sel_policycap_ops;\n\t\tinode->i_ino = iter | SEL_POLICYCAP_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SELinux: failed to load policy classes\\n\""
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_classes",
          "args": [],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_classes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1696-1733",
          "snippet": "static int sel_make_classes(void)\n{\n\tint rc, nclasses, i;\n\tchar **classes;\n\n\t/* delete any existing entries */\n\tsel_remove_entries(class_dir);\n\n\trc = security_get_classes(&classes, &nclasses);\n\tif (rc)\n\t\treturn rc;\n\n\t/* +2 since classes are 1-indexed */\n\tlast_class_ino = sel_class_to_ino(nclasses + 2);\n\n\tfor (i = 0; i < nclasses; i++) {\n\t\tstruct dentry *class_name_dir;\n\n\t\tclass_name_dir = sel_make_dir(class_dir, classes[i],\n\t\t\t\t&last_class_ino);\n\t\tif (IS_ERR(class_name_dir)) {\n\t\t\trc = PTR_ERR(class_name_dir);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* i+1 since class values are 1-indexed */\n\t\trc = sel_make_class_dir_entries(classes[i], i + 1,\n\t\t\t\tclass_name_dir);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tfor (i = 0; i < nclasses; i++)\n\t\tkfree(classes[i]);\n\tkfree(classes);\n\treturn rc;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *class_dir;",
            "static unsigned long last_class_ino;",
            "static int sel_make_classes(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *class_dir;\nstatic unsigned long last_class_ino;\nstatic int sel_make_classes(void);\n\nstatic int sel_make_classes(void)\n{\n\tint rc, nclasses, i;\n\tchar **classes;\n\n\t/* delete any existing entries */\n\tsel_remove_entries(class_dir);\n\n\trc = security_get_classes(&classes, &nclasses);\n\tif (rc)\n\t\treturn rc;\n\n\t/* +2 since classes are 1-indexed */\n\tlast_class_ino = sel_class_to_ino(nclasses + 2);\n\n\tfor (i = 0; i < nclasses; i++) {\n\t\tstruct dentry *class_name_dir;\n\n\t\tclass_name_dir = sel_make_dir(class_dir, classes[i],\n\t\t\t\t&last_class_ino);\n\t\tif (IS_ERR(class_name_dir)) {\n\t\t\trc = PTR_ERR(class_name_dir);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* i+1 since class values are 1-indexed */\n\t\trc = sel_make_class_dir_entries(classes[i], i + 1,\n\t\t\t\tclass_name_dir);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tfor (i = 0; i < nclasses; i++)\n\t\tkfree(classes[i]);\n\tkfree(classes);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SELinux: failed to load policy booleans\\n\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_make_bools",
          "args": [],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "sel_make_bools",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
          "lines": "1253-1334",
          "snippet": "static int sel_make_bools(void)\n{\n\tint i, ret;\n\tssize_t len;\n\tstruct dentry *dentry = NULL;\n\tstruct dentry *dir = bool_dir;\n\tstruct inode *inode = NULL;\n\tstruct inode_security_struct *isec;\n\tchar **names = NULL, *page;\n\tint num;\n\tint *values = NULL;\n\tu32 sid;\n\n\t/* remove any existing files */\n\tfor (i = 0; i < bool_num; i++)\n\t\tkfree(bool_pending_names[i]);\n\tkfree(bool_pending_names);\n\tkfree(bool_pending_values);\n\tbool_num = 0;\n\tbool_pending_names = NULL;\n\tbool_pending_values = NULL;\n\n\tsel_remove_entries(dir);\n\n\tret = -ENOMEM;\n\tpage = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto out;\n\n\tret = security_get_bools(&num, &names, &values);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = -ENOMEM;\n\t\tdentry = d_alloc_name(dir, names[i]);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\n\t\tret = -ENOMEM;\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG | S_IRUGO | S_IWUSR);\n\t\tif (!inode)\n\t\t\tgoto out;\n\n\t\tret = -ENAMETOOLONG;\n\t\tlen = snprintf(page, PAGE_SIZE, \"/%s/%s\", BOOL_DIR_NAME, names[i]);\n\t\tif (len >= PAGE_SIZE)\n\t\t\tgoto out;\n\n\t\tisec = (struct inode_security_struct *)inode->i_security;\n\t\tret = security_genfs_sid(\"selinuxfs\", page, SECCLASS_FILE, &sid);\n\t\tif (ret) {\n\t\t\tpr_warn_ratelimited(\"SELinux: no sid found, defaulting to security isid for %s\\n\",\n\t\t\t\t\t   page);\n\t\t\tsid = SECINITSID_SECURITY;\n\t\t}\n\n\t\tisec->sid = sid;\n\t\tisec->initialized = LABEL_INITIALIZED;\n\t\tinode->i_fop = &sel_bool_ops;\n\t\tinode->i_ino = i|SEL_BOOL_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\tbool_num = num;\n\tbool_pending_names = names;\n\tbool_pending_values = values;\n\n\tfree_page((unsigned long)page);\n\treturn 0;\nout:\n\tfree_page((unsigned long)page);\n\n\tif (names) {\n\t\tfor (i = 0; i < num; i++)\n\t\t\tkfree(names[i]);\n\t\tkfree(names);\n\t}\n\tkfree(values);\n\tsel_remove_entries(dir);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"conditional.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/kobject.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/audit.h>",
            "#include <linux/percpu.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/major.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BOOL_DIR_NAME \"booleans\"",
            "#define SEL_BOOL_INO_OFFSET\t\t0x02000000"
          ],
          "globals_used": [
            "static struct dentry *bool_dir;",
            "static int bool_num;",
            "static char **bool_pending_names;",
            "static int *bool_pending_values;",
            "static int sel_make_bools(void);",
            "static const struct file_operations sel_bool_ops = {\n\t.read\t\t= sel_read_bool,\n\t.write\t\t= sel_write_bool,\n\t.llseek\t\t= generic_file_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define BOOL_DIR_NAME \"booleans\"\n#define SEL_BOOL_INO_OFFSET\t\t0x02000000\n\nstatic struct dentry *bool_dir;\nstatic int bool_num;\nstatic char **bool_pending_names;\nstatic int *bool_pending_values;\nstatic int sel_make_bools(void);\nstatic const struct file_operations sel_bool_ops = {\n\t.read\t\t= sel_read_bool,\n\t.write\t\t= sel_write_bool,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int sel_make_bools(void)\n{\n\tint i, ret;\n\tssize_t len;\n\tstruct dentry *dentry = NULL;\n\tstruct dentry *dir = bool_dir;\n\tstruct inode *inode = NULL;\n\tstruct inode_security_struct *isec;\n\tchar **names = NULL, *page;\n\tint num;\n\tint *values = NULL;\n\tu32 sid;\n\n\t/* remove any existing files */\n\tfor (i = 0; i < bool_num; i++)\n\t\tkfree(bool_pending_names[i]);\n\tkfree(bool_pending_names);\n\tkfree(bool_pending_values);\n\tbool_num = 0;\n\tbool_pending_names = NULL;\n\tbool_pending_values = NULL;\n\n\tsel_remove_entries(dir);\n\n\tret = -ENOMEM;\n\tpage = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!page)\n\t\tgoto out;\n\n\tret = security_get_bools(&num, &names, &values);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = -ENOMEM;\n\t\tdentry = d_alloc_name(dir, names[i]);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\n\t\tret = -ENOMEM;\n\t\tinode = sel_make_inode(dir->d_sb, S_IFREG | S_IRUGO | S_IWUSR);\n\t\tif (!inode)\n\t\t\tgoto out;\n\n\t\tret = -ENAMETOOLONG;\n\t\tlen = snprintf(page, PAGE_SIZE, \"/%s/%s\", BOOL_DIR_NAME, names[i]);\n\t\tif (len >= PAGE_SIZE)\n\t\t\tgoto out;\n\n\t\tisec = (struct inode_security_struct *)inode->i_security;\n\t\tret = security_genfs_sid(\"selinuxfs\", page, SECCLASS_FILE, &sid);\n\t\tif (ret) {\n\t\t\tpr_warn_ratelimited(\"SELinux: no sid found, defaulting to security isid for %s\\n\",\n\t\t\t\t\t   page);\n\t\t\tsid = SECINITSID_SECURITY;\n\t\t}\n\n\t\tisec->sid = sid;\n\t\tisec->initialized = LABEL_INITIALIZED;\n\t\tinode->i_fop = &sel_bool_ops;\n\t\tinode->i_ino = i|SEL_BOOL_INO_OFFSET;\n\t\td_add(dentry, inode);\n\t}\n\tbool_num = num;\n\tbool_pending_names = names;\n\tbool_pending_values = values;\n\n\tfree_page((unsigned long)page);\n\treturn 0;\nout:\n\tfree_page((unsigned long)page);\n\n\tif (names) {\n\t\tfor (i = 0; i < num; i++)\n\t\t\tkfree(names[i]);\n\t\tkfree(names);\n\t}\n\tkfree(values);\n\tsel_remove_entries(dir);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"SELinux: failed to load policy\\n\""
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_load_policy",
          "args": [
            "data",
            "count"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "security_load_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2042-2195",
          "snippet": "int security_load_policy(void *data, size_t len)\n{\n\tstruct policydb *oldpolicydb, *newpolicydb;\n\tstruct sidtab oldsidtab, newsidtab;\n\tstruct selinux_mapping *oldmap, *map = NULL;\n\tstruct convert_context_args args;\n\tu32 seqno;\n\tu16 map_size;\n\tint rc = 0;\n\tstruct policy_file file = { data, len }, *fp = &file;\n\n\toldpolicydb = kzalloc(2 * sizeof(*oldpolicydb), GFP_KERNEL);\n\tif (!oldpolicydb) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnewpolicydb = oldpolicydb + 1;\n\n\tif (!ss_initialized) {\n\t\tavtab_cache_init();\n\t\tebitmap_cache_init();\n\t\thashtab_cache_init();\n\t\trc = policydb_read(&policydb, fp);\n\t\tif (rc) {\n\t\t\tavtab_cache_destroy();\n\t\t\tebitmap_cache_destroy();\n\t\t\thashtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\tpolicydb.len = len;\n\t\trc = selinux_set_mapping(&policydb, secclass_map,\n\t\t\t\t\t &current_mapping,\n\t\t\t\t\t &current_mapping_size);\n\t\tif (rc) {\n\t\t\tpolicydb_destroy(&policydb);\n\t\t\tavtab_cache_destroy();\n\t\t\tebitmap_cache_destroy();\n\t\t\thashtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = policydb_load_isids(&policydb, &sidtab);\n\t\tif (rc) {\n\t\t\tpolicydb_destroy(&policydb);\n\t\t\tavtab_cache_destroy();\n\t\t\tebitmap_cache_destroy();\n\t\t\thashtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\tsecurity_load_policycaps();\n\t\tss_initialized = 1;\n\t\tseqno = ++latest_granting;\n\t\tselinux_complete_init();\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_netlbl_cache_invalidate();\n\t\tselinux_xfrm_notify_policyload();\n\t\tgoto out;\n\t}\n\n#if 0\n\tsidtab_hash_eval(&sidtab, \"sids\");\n#endif\n\n\trc = policydb_read(newpolicydb, fp);\n\tif (rc)\n\t\tgoto out;\n\n\tnewpolicydb->len = len;\n\t/* If switching between different policy types, log MLS status */\n\tif (policydb.mls_enabled && !newpolicydb->mls_enabled)\n\t\tprintk(KERN_INFO \"SELinux: Disabling MLS support...\\n\");\n\telse if (!policydb.mls_enabled && newpolicydb->mls_enabled)\n\t\tprintk(KERN_INFO \"SELinux: Enabling MLS support...\\n\");\n\n\trc = policydb_load_isids(newpolicydb, &newsidtab);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to load the initial SIDs\\n\");\n\t\tpolicydb_destroy(newpolicydb);\n\t\tgoto out;\n\t}\n\n\trc = selinux_set_mapping(newpolicydb, secclass_map, &map, &map_size);\n\tif (rc)\n\t\tgoto err;\n\n\trc = security_preserve_bools(newpolicydb);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to preserve booleans\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Clone the SID table. */\n\tsidtab_shutdown(&sidtab);\n\n\trc = sidtab_map(&sidtab, clone_sid, &newsidtab);\n\tif (rc)\n\t\tgoto err;\n\n\t/*\n\t * Convert the internal representations of contexts\n\t * in the new SID table.\n\t */\n\targs.oldp = &policydb;\n\targs.newp = newpolicydb;\n\trc = sidtab_map(&newsidtab, convert_context, &args);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to convert the internal\"\n\t\t\t\" representation of contexts in the new SID\"\n\t\t\t\" table\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Save the old policydb and SID table to free later. */\n\tmemcpy(oldpolicydb, &policydb, sizeof(policydb));\n\tsidtab_set(&oldsidtab, &sidtab);\n\n\t/* Install the new policydb and SID table. */\n\twrite_lock_irq(&policy_rwlock);\n\tmemcpy(&policydb, newpolicydb, sizeof(policydb));\n\tsidtab_set(&sidtab, &newsidtab);\n\tsecurity_load_policycaps();\n\toldmap = current_mapping;\n\tcurrent_mapping = map;\n\tcurrent_mapping_size = map_size;\n\tseqno = ++latest_granting;\n\twrite_unlock_irq(&policy_rwlock);\n\n\t/* Free the old policydb and SID table. */\n\tpolicydb_destroy(oldpolicydb);\n\tsidtab_destroy(&oldsidtab);\n\tkfree(oldmap);\n\n\tavc_ss_reset(seqno);\n\tselnl_notify_policyload(seqno);\n\tselinux_status_update_policyload(seqno);\n\tselinux_netlbl_cache_invalidate();\n\tselinux_xfrm_notify_policyload();\n\n\trc = 0;\n\tgoto out;\n\nerr:\n\tkfree(map);\n\tsidtab_destroy(&newsidtab);\n\tpolicydb_destroy(newpolicydb);\n\nout:\n\tkfree(oldpolicydb);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;",
            "static u32 latest_granting;",
            "static struct selinux_mapping *current_mapping;",
            "static u16 current_mapping_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\nstatic u32 latest_granting;\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nint security_load_policy(void *data, size_t len)\n{\n\tstruct policydb *oldpolicydb, *newpolicydb;\n\tstruct sidtab oldsidtab, newsidtab;\n\tstruct selinux_mapping *oldmap, *map = NULL;\n\tstruct convert_context_args args;\n\tu32 seqno;\n\tu16 map_size;\n\tint rc = 0;\n\tstruct policy_file file = { data, len }, *fp = &file;\n\n\toldpolicydb = kzalloc(2 * sizeof(*oldpolicydb), GFP_KERNEL);\n\tif (!oldpolicydb) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnewpolicydb = oldpolicydb + 1;\n\n\tif (!ss_initialized) {\n\t\tavtab_cache_init();\n\t\tebitmap_cache_init();\n\t\thashtab_cache_init();\n\t\trc = policydb_read(&policydb, fp);\n\t\tif (rc) {\n\t\t\tavtab_cache_destroy();\n\t\t\tebitmap_cache_destroy();\n\t\t\thashtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\tpolicydb.len = len;\n\t\trc = selinux_set_mapping(&policydb, secclass_map,\n\t\t\t\t\t &current_mapping,\n\t\t\t\t\t &current_mapping_size);\n\t\tif (rc) {\n\t\t\tpolicydb_destroy(&policydb);\n\t\t\tavtab_cache_destroy();\n\t\t\tebitmap_cache_destroy();\n\t\t\thashtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = policydb_load_isids(&policydb, &sidtab);\n\t\tif (rc) {\n\t\t\tpolicydb_destroy(&policydb);\n\t\t\tavtab_cache_destroy();\n\t\t\tebitmap_cache_destroy();\n\t\t\thashtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\tsecurity_load_policycaps();\n\t\tss_initialized = 1;\n\t\tseqno = ++latest_granting;\n\t\tselinux_complete_init();\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_netlbl_cache_invalidate();\n\t\tselinux_xfrm_notify_policyload();\n\t\tgoto out;\n\t}\n\n#if 0\n\tsidtab_hash_eval(&sidtab, \"sids\");\n#endif\n\n\trc = policydb_read(newpolicydb, fp);\n\tif (rc)\n\t\tgoto out;\n\n\tnewpolicydb->len = len;\n\t/* If switching between different policy types, log MLS status */\n\tif (policydb.mls_enabled && !newpolicydb->mls_enabled)\n\t\tprintk(KERN_INFO \"SELinux: Disabling MLS support...\\n\");\n\telse if (!policydb.mls_enabled && newpolicydb->mls_enabled)\n\t\tprintk(KERN_INFO \"SELinux: Enabling MLS support...\\n\");\n\n\trc = policydb_load_isids(newpolicydb, &newsidtab);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to load the initial SIDs\\n\");\n\t\tpolicydb_destroy(newpolicydb);\n\t\tgoto out;\n\t}\n\n\trc = selinux_set_mapping(newpolicydb, secclass_map, &map, &map_size);\n\tif (rc)\n\t\tgoto err;\n\n\trc = security_preserve_bools(newpolicydb);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to preserve booleans\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Clone the SID table. */\n\tsidtab_shutdown(&sidtab);\n\n\trc = sidtab_map(&sidtab, clone_sid, &newsidtab);\n\tif (rc)\n\t\tgoto err;\n\n\t/*\n\t * Convert the internal representations of contexts\n\t * in the new SID table.\n\t */\n\targs.oldp = &policydb;\n\targs.newp = newpolicydb;\n\trc = sidtab_map(&newsidtab, convert_context, &args);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to convert the internal\"\n\t\t\t\" representation of contexts in the new SID\"\n\t\t\t\" table\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Save the old policydb and SID table to free later. */\n\tmemcpy(oldpolicydb, &policydb, sizeof(policydb));\n\tsidtab_set(&oldsidtab, &sidtab);\n\n\t/* Install the new policydb and SID table. */\n\twrite_lock_irq(&policy_rwlock);\n\tmemcpy(&policydb, newpolicydb, sizeof(policydb));\n\tsidtab_set(&sidtab, &newsidtab);\n\tsecurity_load_policycaps();\n\toldmap = current_mapping;\n\tcurrent_mapping = map;\n\tcurrent_mapping_size = map_size;\n\tseqno = ++latest_granting;\n\twrite_unlock_irq(&policy_rwlock);\n\n\t/* Free the old policydb and SID table. */\n\tpolicydb_destroy(oldpolicydb);\n\tsidtab_destroy(&oldsidtab);\n\tkfree(oldmap);\n\n\tavc_ss_reset(seqno);\n\tselnl_notify_policyload(seqno);\n\tselinux_status_update_policyload(seqno);\n\tselinux_netlbl_cache_invalidate();\n\tselinux_xfrm_notify_policyload();\n\n\trc = 0;\n\tgoto out;\n\nerr:\n\tkfree(map);\n\tsidtab_destroy(&newsidtab);\n\tpolicydb_destroy(newpolicydb);\n\nout:\n\tkfree(oldpolicydb);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "data",
            "buf",
            "count"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "count"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__LOAD_POLICY",
            "NULL"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sel_mutex"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(sel_mutex);\nstatic int sel_make_bools(void);\nstatic int sel_make_classes(void);\nstatic int sel_make_policycap(void);\n\nstatic ssize_t sel_write_load(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n\n{\n\tssize_t length;\n\tvoid *data = NULL;\n\n\tmutex_lock(&sel_mutex);\n\n\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t      SECCLASS_SECURITY, SECURITY__LOAD_POLICY, NULL);\n\tif (length)\n\t\tgoto out;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tlength = -EFBIG;\n\tif (count > 64 * 1024 * 1024)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tdata = vmalloc(count);\n\tif (!data)\n\t\tgoto out;\n\n\tlength = -EFAULT;\n\tif (copy_from_user(data, buf, count) != 0)\n\t\tgoto out;\n\n\tlength = security_load_policy(data, count);\n\tif (length) {\n\t\tpr_warn_ratelimited(\"SELinux: failed to load policy\\n\");\n\t\tgoto out;\n\t}\n\n\tlength = sel_make_bools();\n\tif (length) {\n\t\tpr_err(\"SELinux: failed to load policy booleans\\n\");\n\t\tgoto out1;\n\t}\n\n\tlength = sel_make_classes();\n\tif (length) {\n\t\tpr_err(\"SELinux: failed to load policy classes\\n\");\n\t\tgoto out1;\n\t}\n\n\tlength = sel_make_policycap();\n\tif (length) {\n\t\tpr_err(\"SELinux: failed to load policy capabilities\\n\");\n\t\tgoto out1;\n\t}\n\n\tlength = count;\n\nout1:\n\taudit_log(current->audit_context, GFP_KERNEL, AUDIT_MAC_POLICY_LOAD,\n\t\t\"policy loaded auid=%u ses=%u\",\n\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\taudit_get_sessionid(current));\nout:\n\tmutex_unlock(&sel_mutex);\n\tvfree(data);\n\treturn length;\n}"
  },
  {
    "function_name": "sel_mmap_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "447-461",
    "snippet": "static int sel_mmap_policy(struct file *filp, struct vm_area_struct *vma)\n{\n\tif (vma->vm_flags & VM_SHARED) {\n\t\t/* do not allow mprotect to make mapping writable */\n\t\tvma->vm_flags &= ~VM_MAYWRITE;\n\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\treturn -EACCES;\n\t}\n\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\tvma->vm_ops = &sel_mmap_policy_ops;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct sel_mmap_policy_ops = {\n\t.fault = sel_mmap_policy_fault,\n\t.page_mkwrite = sel_mmap_policy_fault,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic const struct vm_operations_struct sel_mmap_policy_ops = {\n\t.fault = sel_mmap_policy_fault,\n\t.page_mkwrite = sel_mmap_policy_fault,\n};\n\nstatic int sel_mmap_policy(struct file *filp, struct vm_area_struct *vma)\n{\n\tif (vma->vm_flags & VM_SHARED) {\n\t\t/* do not allow mprotect to make mapping writable */\n\t\tvma->vm_flags &= ~VM_MAYWRITE;\n\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\treturn -EACCES;\n\t}\n\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\tvma->vm_ops = &sel_mmap_policy_ops;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sel_mmap_policy_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "421-440",
    "snippet": "static int sel_mmap_policy_fault(struct vm_fault *vmf)\n{\n\tstruct policy_load_memory *plm = vmf->vma->vm_file->private_data;\n\tunsigned long offset;\n\tstruct page *page;\n\n\tif (vmf->flags & (FAULT_FLAG_MKWRITE | FAULT_FLAG_WRITE))\n\t\treturn VM_FAULT_SIGBUS;\n\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tif (offset >= roundup(plm->len, PAGE_SIZE))\n\t\treturn VM_FAULT_SIGBUS;\n\n\tpage = vmalloc_to_page(plm->data + offset);\n\tget_page(page);\n\n\tvmf->page = page;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "page"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "plm->data + offset"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "plm->len",
            "PAGE_SIZE"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic int sel_mmap_policy_fault(struct vm_fault *vmf)\n{\n\tstruct policy_load_memory *plm = vmf->vma->vm_file->private_data;\n\tunsigned long offset;\n\tstruct page *page;\n\n\tif (vmf->flags & (FAULT_FLAG_MKWRITE | FAULT_FLAG_WRITE))\n\t\treturn VM_FAULT_SIGBUS;\n\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tif (offset >= roundup(plm->len, PAGE_SIZE))\n\t\treturn VM_FAULT_SIGBUS;\n\n\tpage = vmalloc_to_page(plm->data + offset);\n\tget_page(page);\n\n\tvmf->page = page;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sel_read_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "402-419",
    "snippet": "static ssize_t sel_read_policy(struct file *filp, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct policy_load_memory *plm = filp->private_data;\n\tint ret;\n\n\tmutex_lock(&sel_mutex);\n\n\tret = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t  SECCLASS_SECURITY, SECURITY__READ_POLICY, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = simple_read_from_buffer(buf, count, ppos, plm->data, plm->len);\nout:\n\tmutex_unlock(&sel_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(sel_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sel_mutex"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "plm->data",
            "plm->len"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__READ_POLICY",
            "NULL"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sel_mutex"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(sel_mutex);\n\nstatic ssize_t sel_read_policy(struct file *filp, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct policy_load_memory *plm = filp->private_data;\n\tint ret;\n\n\tmutex_lock(&sel_mutex);\n\n\tret = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t  SECCLASS_SECURITY, SECURITY__READ_POLICY, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = simple_read_from_buffer(buf, count, ppos, plm->data, plm->len);\nout:\n\tmutex_unlock(&sel_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "sel_release_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "388-400",
    "snippet": "static int sel_release_policy(struct inode *inode, struct file *filp)\n{\n\tstruct policy_load_memory *plm = filp->private_data;\n\n\tBUG_ON(!plm);\n\n\tpolicy_opened = 0;\n\n\tvfree(plm->data);\n\tkfree(plm);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char policy_opened;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "plm"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "plm->data"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!plm"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic char policy_opened;\n\nstatic int sel_release_policy(struct inode *inode, struct file *filp)\n{\n\tstruct policy_load_memory *plm = filp->private_data;\n\n\tBUG_ON(!plm);\n\n\tpolicy_opened = 0;\n\n\tvfree(plm->data);\n\tkfree(plm);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sel_open_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "339-386",
    "snippet": "static int sel_open_policy(struct inode *inode, struct file *filp)\n{\n\tstruct policy_load_memory *plm = NULL;\n\tint rc;\n\n\tBUG_ON(filp->private_data);\n\n\tmutex_lock(&sel_mutex);\n\n\trc = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t  SECCLASS_SECURITY, SECURITY__READ_POLICY, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\trc = -EBUSY;\n\tif (policy_opened)\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\tplm = kzalloc(sizeof(*plm), GFP_KERNEL);\n\tif (!plm)\n\t\tgoto err;\n\n\tif (i_size_read(inode) != security_policydb_len()) {\n\t\tinode_lock(inode);\n\t\ti_size_write(inode, security_policydb_len());\n\t\tinode_unlock(inode);\n\t}\n\n\trc = security_read_policy(&plm->data, &plm->len);\n\tif (rc)\n\t\tgoto err;\n\n\tpolicy_opened = 1;\n\n\tfilp->private_data = plm;\n\n\tmutex_unlock(&sel_mutex);\n\n\treturn 0;\nerr:\n\tmutex_unlock(&sel_mutex);\n\n\tif (plm)\n\t\tvfree(plm->data);\n\tkfree(plm);\n\treturn rc;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(sel_mutex);",
      "static char policy_opened;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "plm"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "plm->data"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sel_mutex"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sel_mutex"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_read_policy",
          "args": [
            "&plm->data",
            "&plm->len"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "security_read_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3543-3570",
          "snippet": "int security_read_policy(void **data, size_t *len)\n{\n\tint rc;\n\tstruct policy_file fp;\n\n\tif (!ss_initialized)\n\t\treturn -EINVAL;\n\n\t*len = security_policydb_len();\n\n\t*data = vmalloc_user(*len);\n\tif (!*data)\n\t\treturn -ENOMEM;\n\n\tfp.data = *data;\n\tfp.len = *len;\n\n\tread_lock(&policy_rwlock);\n\trc = policydb_write(&policydb, &fp);\n\tread_unlock(&policy_rwlock);\n\n\tif (rc)\n\t\treturn rc;\n\n\t*len = (unsigned long)fp.data - (unsigned long)*data;\n\treturn 0;\n\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "struct policydb policydb;",
            "int ss_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\nint ss_initialized;\n\nint security_read_policy(void **data, size_t *len)\n{\n\tint rc;\n\tstruct policy_file fp;\n\n\tif (!ss_initialized)\n\t\treturn -EINVAL;\n\n\t*len = security_policydb_len();\n\n\t*data = vmalloc_user(*len);\n\tif (!*data)\n\t\treturn -ENOMEM;\n\n\tfp.data = *data;\n\tfp.len = *len;\n\n\tread_lock(&policy_rwlock);\n\trc = policydb_write(&policydb, &fp);\n\tread_unlock(&policy_rwlock);\n\n\tif (rc)\n\t\treturn rc;\n\n\t*len = (unsigned long)fp.data - (unsigned long)*data;\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "security_policydb_len()"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_policydb_len",
          "args": [],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "security_policydb_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2197-2206",
          "snippet": "size_t security_policydb_len(void)\n{\n\tsize_t len;\n\n\tread_lock(&policy_rwlock);\n\tlen = policydb.len;\n\tread_unlock(&policy_rwlock);\n\n\treturn len;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nsize_t security_policydb_len(void)\n{\n\tsize_t len;\n\n\tread_lock(&policy_rwlock);\n\tlen = policydb.len;\n\tread_unlock(&policy_rwlock);\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*plm)",
            "GFP_KERNEL"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__READ_POLICY",
            "NULL"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sel_mutex"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "filp->private_data"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(sel_mutex);\nstatic char policy_opened;\n\nstatic int sel_open_policy(struct inode *inode, struct file *filp)\n{\n\tstruct policy_load_memory *plm = NULL;\n\tint rc;\n\n\tBUG_ON(filp->private_data);\n\n\tmutex_lock(&sel_mutex);\n\n\trc = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t  SECCLASS_SECURITY, SECURITY__READ_POLICY, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\trc = -EBUSY;\n\tif (policy_opened)\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\tplm = kzalloc(sizeof(*plm), GFP_KERNEL);\n\tif (!plm)\n\t\tgoto err;\n\n\tif (i_size_read(inode) != security_policydb_len()) {\n\t\tinode_lock(inode);\n\t\ti_size_write(inode, security_policydb_len());\n\t\tinode_unlock(inode);\n\t}\n\n\trc = security_read_policy(&plm->data, &plm->len);\n\tif (rc)\n\t\tgoto err;\n\n\tpolicy_opened = 1;\n\n\tfilp->private_data = plm;\n\n\tmutex_unlock(&sel_mutex);\n\n\treturn 0;\nerr:\n\tmutex_unlock(&sel_mutex);\n\n\tif (plm)\n\t\tvfree(plm->data);\n\tkfree(plm);\n\treturn rc;\n}"
  },
  {
    "function_name": "sel_read_mls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "318-327",
    "snippet": "static ssize_t sel_read_mls(struct file *filp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%d\",\n\t\t\t   security_mls_enabled());\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TMPBUFLEN\t12"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "tmpbuf",
            "length"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "tmpbuf",
            "TMPBUFLEN",
            "\"%d\"",
            "security_mls_enabled()"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_mls_enabled",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "security_mls_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "269-272",
          "snippet": "int security_mls_enabled(void)\n{\n\treturn policydb.mls_enabled;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nint security_mls_enabled(void)\n{\n\treturn policydb.mls_enabled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define TMPBUFLEN\t12\n\nstatic ssize_t sel_read_mls(struct file *filp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%d\",\n\t\t\t   security_mls_enabled());\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}"
  },
  {
    "function_name": "sel_read_policyvers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "294-302",
    "snippet": "static ssize_t sel_read_policyvers(struct file *filp, char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\", POLICYDB_VERSION_MAX);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TMPBUFLEN\t12"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "tmpbuf",
            "length"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "tmpbuf",
            "TMPBUFLEN",
            "\"%u\"",
            "POLICYDB_VERSION_MAX"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define TMPBUFLEN\t12\n\nstatic ssize_t sel_read_policyvers(struct file *filp, char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\", POLICYDB_VERSION_MAX);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}"
  },
  {
    "function_name": "sel_write_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "247-284",
    "snippet": "static ssize_t sel_write_disable(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n\n{\n\tchar *page;\n\tssize_t length;\n\tint new_value;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t/* No partial writes. */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tlength = -EINVAL;\n\tif (sscanf(page, \"%d\", &new_value) != 1)\n\t\tgoto out;\n\n\tif (new_value) {\n\t\tlength = selinux_disable();\n\t\tif (length)\n\t\t\tgoto out;\n\t\taudit_log(current->audit_context, GFP_KERNEL, AUDIT_MAC_STATUS,\n\t\t\t\"selinux=0 auid=%u ses=%u\",\n\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\taudit_get_sessionid(current));\n\t}\n\n\tlength = count;\nout:\n\tkfree(page);\n\treturn length;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define sel_write_disable NULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "page"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "current->audit_context",
            "GFP_KERNEL",
            "AUDIT_MAC_STATUS",
            "\"selinux=0 auid=%u ses=%u\"",
            "from_kuid(&init_user_ns, audit_get_loginuid(current))",
            "audit_get_sessionid(current)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "audit_get_loginuid(current)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_disable",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/hooks.c",
          "lines": "6785-6814",
          "snippet": "int selinux_disable(void)\n{\n\tif (ss_initialized) {\n\t\t/* Not permitted after initial policy load. */\n\t\treturn -EINVAL;\n\t}\n\n\tif (selinux_disabled) {\n\t\t/* Only do this once. */\n\t\treturn -EINVAL;\n\t}\n\n\tprintk(KERN_INFO \"SELinux:  Disabled at runtime.\\n\");\n\n\tselinux_disabled = 1;\n\tselinux_enabled = 0;\n\n\tsecurity_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));\n\n\t/* Try to destroy the avc node cache */\n\tavc_disable();\n\n\t/* Unregister netfilter hooks. */\n\tselinux_nf_ip_exit();\n\n\t/* Unregister selinuxfs. */\n\texit_sel_fs();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"avc_ss.h\"",
            "#include \"audit.h\"",
            "#include \"netlabel.h\"",
            "#include \"xfrm.h\"",
            "#include \"ibpkey.h\"",
            "#include \"netport.h\"",
            "#include \"netnode.h\"",
            "#include \"netif.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/bpf.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/export.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syslog.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/mutex.h>",
            "#include <linux/selinux.h>",
            "#include <linux/string.h>",
            "#include <linux/audit.h>",
            "#include <linux/personality.h>",
            "#include <linux/hugetlb.h>",
            "#include <net/ipv6.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/parser.h>",
            "#include <net/af_unix.h>\t/* for Unix socket types */",
            "#include <linux/un.h>\t\t/* for Unix socket types */",
            "#include <linux/quota.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <net/netlink.h>",
            "#include <linux/netdevice.h>\t/* for network interface checks */",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <net/netlabel.h>",
            "#include <net/net_namespace.h>",
            "#include <net/inet_connection_sock.h>",
            "#include <net/tcp.h>\t\t/* struct or_callable used in sock_rcv_skb */",
            "#include <net/ip.h>\t\t/* for local_port_range[] */",
            "#include <net/icmp.h>",
            "#include <linux/tty.h>",
            "#include <linux/netfilter_ipv6.h>",
            "#include <linux/netfilter_ipv4.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swap.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/unistd.h>",
            "#include <linux/capability.h>",
            "#include <linux/xattr.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kd.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct security_hook_list selinux_hooks[] __lsm_ro_after_init = {\n\tLSM_HOOK_INIT(binder_set_context_mgr, selinux_binder_set_context_mgr),\n\tLSM_HOOK_INIT(binder_transaction, selinux_binder_transaction),\n\tLSM_HOOK_INIT(binder_transfer_binder, selinux_binder_transfer_binder),\n\tLSM_HOOK_INIT(binder_transfer_file, selinux_binder_transfer_file),\n\n\tLSM_HOOK_INIT(ptrace_access_check, selinux_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, selinux_ptrace_traceme),\n\tLSM_HOOK_INIT(capget, selinux_capget),\n\tLSM_HOOK_INIT(capset, selinux_capset),\n\tLSM_HOOK_INIT(capable, selinux_capable),\n\tLSM_HOOK_INIT(quotactl, selinux_quotactl),\n\tLSM_HOOK_INIT(quota_on, selinux_quota_on),\n\tLSM_HOOK_INIT(syslog, selinux_syslog),\n\tLSM_HOOK_INIT(vm_enough_memory, selinux_vm_enough_memory),\n\n\tLSM_HOOK_INIT(netlink_send, selinux_netlink_send),\n\n\tLSM_HOOK_INIT(bprm_set_creds, selinux_bprm_set_creds),\n\tLSM_HOOK_INIT(bprm_committing_creds, selinux_bprm_committing_creds),\n\tLSM_HOOK_INIT(bprm_committed_creds, selinux_bprm_committed_creds),\n\n\tLSM_HOOK_INIT(sb_alloc_security, selinux_sb_alloc_security),\n\tLSM_HOOK_INIT(sb_free_security, selinux_sb_free_security),\n\tLSM_HOOK_INIT(sb_copy_data, selinux_sb_copy_data),\n\tLSM_HOOK_INIT(sb_remount, selinux_sb_remount),\n\tLSM_HOOK_INIT(sb_kern_mount, selinux_sb_kern_mount),\n\tLSM_HOOK_INIT(sb_show_options, selinux_sb_show_options),\n\tLSM_HOOK_INIT(sb_statfs, selinux_sb_statfs),\n\tLSM_HOOK_INIT(sb_mount, selinux_mount),\n\tLSM_HOOK_INIT(sb_umount, selinux_umount),\n\tLSM_HOOK_INIT(sb_set_mnt_opts, selinux_set_mnt_opts),\n\tLSM_HOOK_INIT(sb_clone_mnt_opts, selinux_sb_clone_mnt_opts),\n\tLSM_HOOK_INIT(sb_parse_opts_str, selinux_parse_opts_str),\n\n\tLSM_HOOK_INIT(dentry_init_security, selinux_dentry_init_security),\n\tLSM_HOOK_INIT(dentry_create_files_as, selinux_dentry_create_files_as),\n\n\tLSM_HOOK_INIT(inode_alloc_security, selinux_inode_alloc_security),\n\tLSM_HOOK_INIT(inode_free_security, selinux_inode_free_security),\n\tLSM_HOOK_INIT(inode_init_security, selinux_inode_init_security),\n\tLSM_HOOK_INIT(inode_create, selinux_inode_create),\n\tLSM_HOOK_INIT(inode_link, selinux_inode_link),\n\tLSM_HOOK_INIT(inode_unlink, selinux_inode_unlink),\n\tLSM_HOOK_INIT(inode_symlink, selinux_inode_symlink),\n\tLSM_HOOK_INIT(inode_mkdir, selinux_inode_mkdir),\n\tLSM_HOOK_INIT(inode_rmdir, selinux_inode_rmdir),\n\tLSM_HOOK_INIT(inode_mknod, selinux_inode_mknod),\n\tLSM_HOOK_INIT(inode_rename, selinux_inode_rename),\n\tLSM_HOOK_INIT(inode_readlink, selinux_inode_readlink),\n\tLSM_HOOK_INIT(inode_follow_link, selinux_inode_follow_link),\n\tLSM_HOOK_INIT(inode_permission, selinux_inode_permission),\n\tLSM_HOOK_INIT(inode_setattr, selinux_inode_setattr),\n\tLSM_HOOK_INIT(inode_getattr, selinux_inode_getattr),\n\tLSM_HOOK_INIT(inode_setxattr, selinux_inode_setxattr),\n\tLSM_HOOK_INIT(inode_post_setxattr, selinux_inode_post_setxattr),\n\tLSM_HOOK_INIT(inode_getxattr, selinux_inode_getxattr),\n\tLSM_HOOK_INIT(inode_listxattr, selinux_inode_listxattr),\n\tLSM_HOOK_INIT(inode_removexattr, selinux_inode_removexattr),\n\tLSM_HOOK_INIT(inode_getsecurity, selinux_inode_getsecurity),\n\tLSM_HOOK_INIT(inode_setsecurity, selinux_inode_setsecurity),\n\tLSM_HOOK_INIT(inode_listsecurity, selinux_inode_listsecurity),\n\tLSM_HOOK_INIT(inode_getsecid, selinux_inode_getsecid),\n\tLSM_HOOK_INIT(inode_copy_up, selinux_inode_copy_up),\n\tLSM_HOOK_INIT(inode_copy_up_xattr, selinux_inode_copy_up_xattr),\n\n\tLSM_HOOK_INIT(file_permission, selinux_file_permission),\n\tLSM_HOOK_INIT(file_alloc_security, selinux_file_alloc_security),\n\tLSM_HOOK_INIT(file_free_security, selinux_file_free_security),\n\tLSM_HOOK_INIT(file_ioctl, selinux_file_ioctl),\n\tLSM_HOOK_INIT(mmap_file, selinux_mmap_file),\n\tLSM_HOOK_INIT(mmap_addr, selinux_mmap_addr),\n\tLSM_HOOK_INIT(file_mprotect, selinux_file_mprotect),\n\tLSM_HOOK_INIT(file_lock, selinux_file_lock),\n\tLSM_HOOK_INIT(file_fcntl, selinux_file_fcntl),\n\tLSM_HOOK_INIT(file_set_fowner, selinux_file_set_fowner),\n\tLSM_HOOK_INIT(file_send_sigiotask, selinux_file_send_sigiotask),\n\tLSM_HOOK_INIT(file_receive, selinux_file_receive),\n\n\tLSM_HOOK_INIT(file_open, selinux_file_open),\n\n\tLSM_HOOK_INIT(task_alloc, selinux_task_alloc),\n\tLSM_HOOK_INIT(cred_alloc_blank, selinux_cred_alloc_blank),\n\tLSM_HOOK_INIT(cred_free, selinux_cred_free),\n\tLSM_HOOK_INIT(cred_prepare, selinux_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, selinux_cred_transfer),\n\tLSM_HOOK_INIT(kernel_act_as, selinux_kernel_act_as),\n\tLSM_HOOK_INIT(kernel_create_files_as, selinux_kernel_create_files_as),\n\tLSM_HOOK_INIT(kernel_module_request, selinux_kernel_module_request),\n\tLSM_HOOK_INIT(kernel_read_file, selinux_kernel_read_file),\n\tLSM_HOOK_INIT(task_setpgid, selinux_task_setpgid),\n\tLSM_HOOK_INIT(task_getpgid, selinux_task_getpgid),\n\tLSM_HOOK_INIT(task_getsid, selinux_task_getsid),\n\tLSM_HOOK_INIT(task_getsecid, selinux_task_getsecid),\n\tLSM_HOOK_INIT(task_setnice, selinux_task_setnice),\n\tLSM_HOOK_INIT(task_setioprio, selinux_task_setioprio),\n\tLSM_HOOK_INIT(task_getioprio, selinux_task_getioprio),\n\tLSM_HOOK_INIT(task_prlimit, selinux_task_prlimit),\n\tLSM_HOOK_INIT(task_setrlimit, selinux_task_setrlimit),\n\tLSM_HOOK_INIT(task_setscheduler, selinux_task_setscheduler),\n\tLSM_HOOK_INIT(task_getscheduler, selinux_task_getscheduler),\n\tLSM_HOOK_INIT(task_movememory, selinux_task_movememory),\n\tLSM_HOOK_INIT(task_kill, selinux_task_kill),\n\tLSM_HOOK_INIT(task_to_inode, selinux_task_to_inode),\n\n\tLSM_HOOK_INIT(ipc_permission, selinux_ipc_permission),\n\tLSM_HOOK_INIT(ipc_getsecid, selinux_ipc_getsecid),\n\n\tLSM_HOOK_INIT(msg_msg_alloc_security, selinux_msg_msg_alloc_security),\n\tLSM_HOOK_INIT(msg_msg_free_security, selinux_msg_msg_free_security),\n\n\tLSM_HOOK_INIT(msg_queue_alloc_security,\n\t\t\tselinux_msg_queue_alloc_security),\n\tLSM_HOOK_INIT(msg_queue_free_security, selinux_msg_queue_free_security),\n\tLSM_HOOK_INIT(msg_queue_associate, selinux_msg_queue_associate),\n\tLSM_HOOK_INIT(msg_queue_msgctl, selinux_msg_queue_msgctl),\n\tLSM_HOOK_INIT(msg_queue_msgsnd, selinux_msg_queue_msgsnd),\n\tLSM_HOOK_INIT(msg_queue_msgrcv, selinux_msg_queue_msgrcv),\n\n\tLSM_HOOK_INIT(shm_alloc_security, selinux_shm_alloc_security),\n\tLSM_HOOK_INIT(shm_free_security, selinux_shm_free_security),\n\tLSM_HOOK_INIT(shm_associate, selinux_shm_associate),\n\tLSM_HOOK_INIT(shm_shmctl, selinux_shm_shmctl),\n\tLSM_HOOK_INIT(shm_shmat, selinux_shm_shmat),\n\n\tLSM_HOOK_INIT(sem_alloc_security, selinux_sem_alloc_security),\n\tLSM_HOOK_INIT(sem_free_security, selinux_sem_free_security),\n\tLSM_HOOK_INIT(sem_associate, selinux_sem_associate),\n\tLSM_HOOK_INIT(sem_semctl, selinux_sem_semctl),\n\tLSM_HOOK_INIT(sem_semop, selinux_sem_semop),\n\n\tLSM_HOOK_INIT(d_instantiate, selinux_d_instantiate),\n\n\tLSM_HOOK_INIT(getprocattr, selinux_getprocattr),\n\tLSM_HOOK_INIT(setprocattr, selinux_setprocattr),\n\n\tLSM_HOOK_INIT(ismaclabel, selinux_ismaclabel),\n\tLSM_HOOK_INIT(secid_to_secctx, selinux_secid_to_secctx),\n\tLSM_HOOK_INIT(secctx_to_secid, selinux_secctx_to_secid),\n\tLSM_HOOK_INIT(release_secctx, selinux_release_secctx),\n\tLSM_HOOK_INIT(inode_invalidate_secctx, selinux_inode_invalidate_secctx),\n\tLSM_HOOK_INIT(inode_notifysecctx, selinux_inode_notifysecctx),\n\tLSM_HOOK_INIT(inode_setsecctx, selinux_inode_setsecctx),\n\tLSM_HOOK_INIT(inode_getsecctx, selinux_inode_getsecctx),\n\n\tLSM_HOOK_INIT(unix_stream_connect, selinux_socket_unix_stream_connect),\n\tLSM_HOOK_INIT(unix_may_send, selinux_socket_unix_may_send),\n\n\tLSM_HOOK_INIT(socket_create, selinux_socket_create),\n\tLSM_HOOK_INIT(socket_post_create, selinux_socket_post_create),\n\tLSM_HOOK_INIT(socket_bind, selinux_socket_bind),\n\tLSM_HOOK_INIT(socket_connect, selinux_socket_connect),\n\tLSM_HOOK_INIT(socket_listen, selinux_socket_listen),\n\tLSM_HOOK_INIT(socket_accept, selinux_socket_accept),\n\tLSM_HOOK_INIT(socket_sendmsg, selinux_socket_sendmsg),\n\tLSM_HOOK_INIT(socket_recvmsg, selinux_socket_recvmsg),\n\tLSM_HOOK_INIT(socket_getsockname, selinux_socket_getsockname),\n\tLSM_HOOK_INIT(socket_getpeername, selinux_socket_getpeername),\n\tLSM_HOOK_INIT(socket_getsockopt, selinux_socket_getsockopt),\n\tLSM_HOOK_INIT(socket_setsockopt, selinux_socket_setsockopt),\n\tLSM_HOOK_INIT(socket_shutdown, selinux_socket_shutdown),\n\tLSM_HOOK_INIT(socket_sock_rcv_skb, selinux_socket_sock_rcv_skb),\n\tLSM_HOOK_INIT(socket_getpeersec_stream,\n\t\t\tselinux_socket_getpeersec_stream),\n\tLSM_HOOK_INIT(socket_getpeersec_dgram, selinux_socket_getpeersec_dgram),\n\tLSM_HOOK_INIT(sk_alloc_security, selinux_sk_alloc_security),\n\tLSM_HOOK_INIT(sk_free_security, selinux_sk_free_security),\n\tLSM_HOOK_INIT(sk_clone_security, selinux_sk_clone_security),\n\tLSM_HOOK_INIT(sk_getsecid, selinux_sk_getsecid),\n\tLSM_HOOK_INIT(sock_graft, selinux_sock_graft),\n\tLSM_HOOK_INIT(inet_conn_request, selinux_inet_conn_request),\n\tLSM_HOOK_INIT(inet_csk_clone, selinux_inet_csk_clone),\n\tLSM_HOOK_INIT(inet_conn_established, selinux_inet_conn_established),\n\tLSM_HOOK_INIT(secmark_relabel_packet, selinux_secmark_relabel_packet),\n\tLSM_HOOK_INIT(secmark_refcount_inc, selinux_secmark_refcount_inc),\n\tLSM_HOOK_INIT(secmark_refcount_dec, selinux_secmark_refcount_dec),\n\tLSM_HOOK_INIT(req_classify_flow, selinux_req_classify_flow),\n\tLSM_HOOK_INIT(tun_dev_alloc_security, selinux_tun_dev_alloc_security),\n\tLSM_HOOK_INIT(tun_dev_free_security, selinux_tun_dev_free_security),\n\tLSM_HOOK_INIT(tun_dev_create, selinux_tun_dev_create),\n\tLSM_HOOK_INIT(tun_dev_attach_queue, selinux_tun_dev_attach_queue),\n\tLSM_HOOK_INIT(tun_dev_attach, selinux_tun_dev_attach),\n\tLSM_HOOK_INIT(tun_dev_open, selinux_tun_dev_open),\n#ifdef CONFIG_SECURITY_INFINIBAND\n\tLSM_HOOK_INIT(ib_pkey_access, selinux_ib_pkey_access),\n\tLSM_HOOK_INIT(ib_endport_manage_subnet,\n\t\t      selinux_ib_endport_manage_subnet),\n\tLSM_HOOK_INIT(ib_alloc_security, selinux_ib_alloc_security),\n\tLSM_HOOK_INIT(ib_free_security, selinux_ib_free_security),\n#endif\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\n\tLSM_HOOK_INIT(xfrm_policy_alloc_security, selinux_xfrm_policy_alloc),\n\tLSM_HOOK_INIT(xfrm_policy_clone_security, selinux_xfrm_policy_clone),\n\tLSM_HOOK_INIT(xfrm_policy_free_security, selinux_xfrm_policy_free),\n\tLSM_HOOK_INIT(xfrm_policy_delete_security, selinux_xfrm_policy_delete),\n\tLSM_HOOK_INIT(xfrm_state_alloc, selinux_xfrm_state_alloc),\n\tLSM_HOOK_INIT(xfrm_state_alloc_acquire,\n\t\t\tselinux_xfrm_state_alloc_acquire),\n\tLSM_HOOK_INIT(xfrm_state_free_security, selinux_xfrm_state_free),\n\tLSM_HOOK_INIT(xfrm_state_delete_security, selinux_xfrm_state_delete),\n\tLSM_HOOK_INIT(xfrm_policy_lookup, selinux_xfrm_policy_lookup),\n\tLSM_HOOK_INIT(xfrm_state_pol_flow_match,\n\t\t\tselinux_xfrm_state_pol_flow_match),\n\tLSM_HOOK_INIT(xfrm_decode_session, selinux_xfrm_decode_session),\n#endif\n\n#ifdef CONFIG_KEYS\n\tLSM_HOOK_INIT(key_alloc, selinux_key_alloc),\n\tLSM_HOOK_INIT(key_free, selinux_key_free),\n\tLSM_HOOK_INIT(key_permission, selinux_key_permission),\n\tLSM_HOOK_INIT(key_getsecurity, selinux_key_getsecurity),\n#endif\n\n#ifdef CONFIG_AUDIT\n\tLSM_HOOK_INIT(audit_rule_init, selinux_audit_rule_init),\n\tLSM_HOOK_INIT(audit_rule_known, selinux_audit_rule_known),\n\tLSM_HOOK_INIT(audit_rule_match, selinux_audit_rule_match),\n\tLSM_HOOK_INIT(audit_rule_free, selinux_audit_rule_free),\n#endif\n\n#ifdef CONFIG_BPF_SYSCALL\n\tLSM_HOOK_INIT(bpf, selinux_bpf),\n\tLSM_HOOK_INIT(bpf_map, selinux_bpf_map),\n\tLSM_HOOK_INIT(bpf_prog, selinux_bpf_prog),\n\tLSM_HOOK_INIT(bpf_map_alloc_security, selinux_bpf_map_alloc),\n\tLSM_HOOK_INIT(bpf_prog_alloc_security, selinux_bpf_prog_alloc),\n\tLSM_HOOK_INIT(bpf_map_free_security, selinux_bpf_map_free),\n\tLSM_HOOK_INIT(bpf_prog_free_security, selinux_bpf_prog_free),\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avc_ss.h\"\n#include \"audit.h\"\n#include \"netlabel.h\"\n#include \"xfrm.h\"\n#include \"ibpkey.h\"\n#include \"netport.h\"\n#include \"netnode.h\"\n#include \"netif.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/bpf.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/export.h>\n#include <linux/user_namespace.h>\n#include <linux/syslog.h>\n#include <linux/posix-timers.h>\n#include <linux/mutex.h>\n#include <linux/selinux.h>\n#include <linux/string.h>\n#include <linux/audit.h>\n#include <linux/personality.h>\n#include <linux/hugetlb.h>\n#include <net/ipv6.h>\n#include <linux/nfs_mount.h>\n#include <linux/parser.h>\n#include <net/af_unix.h>\t/* for Unix socket types */\n#include <linux/un.h>\t\t/* for Unix socket types */\n#include <linux/quota.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <net/netlink.h>\n#include <linux/netdevice.h>\t/* for network interface checks */\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <net/netlabel.h>\n#include <net/net_namespace.h>\n#include <net/inet_connection_sock.h>\n#include <net/tcp.h>\t\t/* struct or_callable used in sock_rcv_skb */\n#include <net/ip.h>\t\t/* for local_port_range[] */\n#include <net/icmp.h>\n#include <linux/tty.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/swap.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/unistd.h>\n#include <linux/capability.h>\n#include <linux/xattr.h>\n#include <linux/lsm_hooks.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/errno.h>\n#include <linux/tracehook.h>\n#include <linux/kernel.h>\n#include <linux/kd.h>\n#include <linux/init.h>\n\nstatic struct security_hook_list selinux_hooks[] __lsm_ro_after_init = {\n\tLSM_HOOK_INIT(binder_set_context_mgr, selinux_binder_set_context_mgr),\n\tLSM_HOOK_INIT(binder_transaction, selinux_binder_transaction),\n\tLSM_HOOK_INIT(binder_transfer_binder, selinux_binder_transfer_binder),\n\tLSM_HOOK_INIT(binder_transfer_file, selinux_binder_transfer_file),\n\n\tLSM_HOOK_INIT(ptrace_access_check, selinux_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, selinux_ptrace_traceme),\n\tLSM_HOOK_INIT(capget, selinux_capget),\n\tLSM_HOOK_INIT(capset, selinux_capset),\n\tLSM_HOOK_INIT(capable, selinux_capable),\n\tLSM_HOOK_INIT(quotactl, selinux_quotactl),\n\tLSM_HOOK_INIT(quota_on, selinux_quota_on),\n\tLSM_HOOK_INIT(syslog, selinux_syslog),\n\tLSM_HOOK_INIT(vm_enough_memory, selinux_vm_enough_memory),\n\n\tLSM_HOOK_INIT(netlink_send, selinux_netlink_send),\n\n\tLSM_HOOK_INIT(bprm_set_creds, selinux_bprm_set_creds),\n\tLSM_HOOK_INIT(bprm_committing_creds, selinux_bprm_committing_creds),\n\tLSM_HOOK_INIT(bprm_committed_creds, selinux_bprm_committed_creds),\n\n\tLSM_HOOK_INIT(sb_alloc_security, selinux_sb_alloc_security),\n\tLSM_HOOK_INIT(sb_free_security, selinux_sb_free_security),\n\tLSM_HOOK_INIT(sb_copy_data, selinux_sb_copy_data),\n\tLSM_HOOK_INIT(sb_remount, selinux_sb_remount),\n\tLSM_HOOK_INIT(sb_kern_mount, selinux_sb_kern_mount),\n\tLSM_HOOK_INIT(sb_show_options, selinux_sb_show_options),\n\tLSM_HOOK_INIT(sb_statfs, selinux_sb_statfs),\n\tLSM_HOOK_INIT(sb_mount, selinux_mount),\n\tLSM_HOOK_INIT(sb_umount, selinux_umount),\n\tLSM_HOOK_INIT(sb_set_mnt_opts, selinux_set_mnt_opts),\n\tLSM_HOOK_INIT(sb_clone_mnt_opts, selinux_sb_clone_mnt_opts),\n\tLSM_HOOK_INIT(sb_parse_opts_str, selinux_parse_opts_str),\n\n\tLSM_HOOK_INIT(dentry_init_security, selinux_dentry_init_security),\n\tLSM_HOOK_INIT(dentry_create_files_as, selinux_dentry_create_files_as),\n\n\tLSM_HOOK_INIT(inode_alloc_security, selinux_inode_alloc_security),\n\tLSM_HOOK_INIT(inode_free_security, selinux_inode_free_security),\n\tLSM_HOOK_INIT(inode_init_security, selinux_inode_init_security),\n\tLSM_HOOK_INIT(inode_create, selinux_inode_create),\n\tLSM_HOOK_INIT(inode_link, selinux_inode_link),\n\tLSM_HOOK_INIT(inode_unlink, selinux_inode_unlink),\n\tLSM_HOOK_INIT(inode_symlink, selinux_inode_symlink),\n\tLSM_HOOK_INIT(inode_mkdir, selinux_inode_mkdir),\n\tLSM_HOOK_INIT(inode_rmdir, selinux_inode_rmdir),\n\tLSM_HOOK_INIT(inode_mknod, selinux_inode_mknod),\n\tLSM_HOOK_INIT(inode_rename, selinux_inode_rename),\n\tLSM_HOOK_INIT(inode_readlink, selinux_inode_readlink),\n\tLSM_HOOK_INIT(inode_follow_link, selinux_inode_follow_link),\n\tLSM_HOOK_INIT(inode_permission, selinux_inode_permission),\n\tLSM_HOOK_INIT(inode_setattr, selinux_inode_setattr),\n\tLSM_HOOK_INIT(inode_getattr, selinux_inode_getattr),\n\tLSM_HOOK_INIT(inode_setxattr, selinux_inode_setxattr),\n\tLSM_HOOK_INIT(inode_post_setxattr, selinux_inode_post_setxattr),\n\tLSM_HOOK_INIT(inode_getxattr, selinux_inode_getxattr),\n\tLSM_HOOK_INIT(inode_listxattr, selinux_inode_listxattr),\n\tLSM_HOOK_INIT(inode_removexattr, selinux_inode_removexattr),\n\tLSM_HOOK_INIT(inode_getsecurity, selinux_inode_getsecurity),\n\tLSM_HOOK_INIT(inode_setsecurity, selinux_inode_setsecurity),\n\tLSM_HOOK_INIT(inode_listsecurity, selinux_inode_listsecurity),\n\tLSM_HOOK_INIT(inode_getsecid, selinux_inode_getsecid),\n\tLSM_HOOK_INIT(inode_copy_up, selinux_inode_copy_up),\n\tLSM_HOOK_INIT(inode_copy_up_xattr, selinux_inode_copy_up_xattr),\n\n\tLSM_HOOK_INIT(file_permission, selinux_file_permission),\n\tLSM_HOOK_INIT(file_alloc_security, selinux_file_alloc_security),\n\tLSM_HOOK_INIT(file_free_security, selinux_file_free_security),\n\tLSM_HOOK_INIT(file_ioctl, selinux_file_ioctl),\n\tLSM_HOOK_INIT(mmap_file, selinux_mmap_file),\n\tLSM_HOOK_INIT(mmap_addr, selinux_mmap_addr),\n\tLSM_HOOK_INIT(file_mprotect, selinux_file_mprotect),\n\tLSM_HOOK_INIT(file_lock, selinux_file_lock),\n\tLSM_HOOK_INIT(file_fcntl, selinux_file_fcntl),\n\tLSM_HOOK_INIT(file_set_fowner, selinux_file_set_fowner),\n\tLSM_HOOK_INIT(file_send_sigiotask, selinux_file_send_sigiotask),\n\tLSM_HOOK_INIT(file_receive, selinux_file_receive),\n\n\tLSM_HOOK_INIT(file_open, selinux_file_open),\n\n\tLSM_HOOK_INIT(task_alloc, selinux_task_alloc),\n\tLSM_HOOK_INIT(cred_alloc_blank, selinux_cred_alloc_blank),\n\tLSM_HOOK_INIT(cred_free, selinux_cred_free),\n\tLSM_HOOK_INIT(cred_prepare, selinux_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, selinux_cred_transfer),\n\tLSM_HOOK_INIT(kernel_act_as, selinux_kernel_act_as),\n\tLSM_HOOK_INIT(kernel_create_files_as, selinux_kernel_create_files_as),\n\tLSM_HOOK_INIT(kernel_module_request, selinux_kernel_module_request),\n\tLSM_HOOK_INIT(kernel_read_file, selinux_kernel_read_file),\n\tLSM_HOOK_INIT(task_setpgid, selinux_task_setpgid),\n\tLSM_HOOK_INIT(task_getpgid, selinux_task_getpgid),\n\tLSM_HOOK_INIT(task_getsid, selinux_task_getsid),\n\tLSM_HOOK_INIT(task_getsecid, selinux_task_getsecid),\n\tLSM_HOOK_INIT(task_setnice, selinux_task_setnice),\n\tLSM_HOOK_INIT(task_setioprio, selinux_task_setioprio),\n\tLSM_HOOK_INIT(task_getioprio, selinux_task_getioprio),\n\tLSM_HOOK_INIT(task_prlimit, selinux_task_prlimit),\n\tLSM_HOOK_INIT(task_setrlimit, selinux_task_setrlimit),\n\tLSM_HOOK_INIT(task_setscheduler, selinux_task_setscheduler),\n\tLSM_HOOK_INIT(task_getscheduler, selinux_task_getscheduler),\n\tLSM_HOOK_INIT(task_movememory, selinux_task_movememory),\n\tLSM_HOOK_INIT(task_kill, selinux_task_kill),\n\tLSM_HOOK_INIT(task_to_inode, selinux_task_to_inode),\n\n\tLSM_HOOK_INIT(ipc_permission, selinux_ipc_permission),\n\tLSM_HOOK_INIT(ipc_getsecid, selinux_ipc_getsecid),\n\n\tLSM_HOOK_INIT(msg_msg_alloc_security, selinux_msg_msg_alloc_security),\n\tLSM_HOOK_INIT(msg_msg_free_security, selinux_msg_msg_free_security),\n\n\tLSM_HOOK_INIT(msg_queue_alloc_security,\n\t\t\tselinux_msg_queue_alloc_security),\n\tLSM_HOOK_INIT(msg_queue_free_security, selinux_msg_queue_free_security),\n\tLSM_HOOK_INIT(msg_queue_associate, selinux_msg_queue_associate),\n\tLSM_HOOK_INIT(msg_queue_msgctl, selinux_msg_queue_msgctl),\n\tLSM_HOOK_INIT(msg_queue_msgsnd, selinux_msg_queue_msgsnd),\n\tLSM_HOOK_INIT(msg_queue_msgrcv, selinux_msg_queue_msgrcv),\n\n\tLSM_HOOK_INIT(shm_alloc_security, selinux_shm_alloc_security),\n\tLSM_HOOK_INIT(shm_free_security, selinux_shm_free_security),\n\tLSM_HOOK_INIT(shm_associate, selinux_shm_associate),\n\tLSM_HOOK_INIT(shm_shmctl, selinux_shm_shmctl),\n\tLSM_HOOK_INIT(shm_shmat, selinux_shm_shmat),\n\n\tLSM_HOOK_INIT(sem_alloc_security, selinux_sem_alloc_security),\n\tLSM_HOOK_INIT(sem_free_security, selinux_sem_free_security),\n\tLSM_HOOK_INIT(sem_associate, selinux_sem_associate),\n\tLSM_HOOK_INIT(sem_semctl, selinux_sem_semctl),\n\tLSM_HOOK_INIT(sem_semop, selinux_sem_semop),\n\n\tLSM_HOOK_INIT(d_instantiate, selinux_d_instantiate),\n\n\tLSM_HOOK_INIT(getprocattr, selinux_getprocattr),\n\tLSM_HOOK_INIT(setprocattr, selinux_setprocattr),\n\n\tLSM_HOOK_INIT(ismaclabel, selinux_ismaclabel),\n\tLSM_HOOK_INIT(secid_to_secctx, selinux_secid_to_secctx),\n\tLSM_HOOK_INIT(secctx_to_secid, selinux_secctx_to_secid),\n\tLSM_HOOK_INIT(release_secctx, selinux_release_secctx),\n\tLSM_HOOK_INIT(inode_invalidate_secctx, selinux_inode_invalidate_secctx),\n\tLSM_HOOK_INIT(inode_notifysecctx, selinux_inode_notifysecctx),\n\tLSM_HOOK_INIT(inode_setsecctx, selinux_inode_setsecctx),\n\tLSM_HOOK_INIT(inode_getsecctx, selinux_inode_getsecctx),\n\n\tLSM_HOOK_INIT(unix_stream_connect, selinux_socket_unix_stream_connect),\n\tLSM_HOOK_INIT(unix_may_send, selinux_socket_unix_may_send),\n\n\tLSM_HOOK_INIT(socket_create, selinux_socket_create),\n\tLSM_HOOK_INIT(socket_post_create, selinux_socket_post_create),\n\tLSM_HOOK_INIT(socket_bind, selinux_socket_bind),\n\tLSM_HOOK_INIT(socket_connect, selinux_socket_connect),\n\tLSM_HOOK_INIT(socket_listen, selinux_socket_listen),\n\tLSM_HOOK_INIT(socket_accept, selinux_socket_accept),\n\tLSM_HOOK_INIT(socket_sendmsg, selinux_socket_sendmsg),\n\tLSM_HOOK_INIT(socket_recvmsg, selinux_socket_recvmsg),\n\tLSM_HOOK_INIT(socket_getsockname, selinux_socket_getsockname),\n\tLSM_HOOK_INIT(socket_getpeername, selinux_socket_getpeername),\n\tLSM_HOOK_INIT(socket_getsockopt, selinux_socket_getsockopt),\n\tLSM_HOOK_INIT(socket_setsockopt, selinux_socket_setsockopt),\n\tLSM_HOOK_INIT(socket_shutdown, selinux_socket_shutdown),\n\tLSM_HOOK_INIT(socket_sock_rcv_skb, selinux_socket_sock_rcv_skb),\n\tLSM_HOOK_INIT(socket_getpeersec_stream,\n\t\t\tselinux_socket_getpeersec_stream),\n\tLSM_HOOK_INIT(socket_getpeersec_dgram, selinux_socket_getpeersec_dgram),\n\tLSM_HOOK_INIT(sk_alloc_security, selinux_sk_alloc_security),\n\tLSM_HOOK_INIT(sk_free_security, selinux_sk_free_security),\n\tLSM_HOOK_INIT(sk_clone_security, selinux_sk_clone_security),\n\tLSM_HOOK_INIT(sk_getsecid, selinux_sk_getsecid),\n\tLSM_HOOK_INIT(sock_graft, selinux_sock_graft),\n\tLSM_HOOK_INIT(inet_conn_request, selinux_inet_conn_request),\n\tLSM_HOOK_INIT(inet_csk_clone, selinux_inet_csk_clone),\n\tLSM_HOOK_INIT(inet_conn_established, selinux_inet_conn_established),\n\tLSM_HOOK_INIT(secmark_relabel_packet, selinux_secmark_relabel_packet),\n\tLSM_HOOK_INIT(secmark_refcount_inc, selinux_secmark_refcount_inc),\n\tLSM_HOOK_INIT(secmark_refcount_dec, selinux_secmark_refcount_dec),\n\tLSM_HOOK_INIT(req_classify_flow, selinux_req_classify_flow),\n\tLSM_HOOK_INIT(tun_dev_alloc_security, selinux_tun_dev_alloc_security),\n\tLSM_HOOK_INIT(tun_dev_free_security, selinux_tun_dev_free_security),\n\tLSM_HOOK_INIT(tun_dev_create, selinux_tun_dev_create),\n\tLSM_HOOK_INIT(tun_dev_attach_queue, selinux_tun_dev_attach_queue),\n\tLSM_HOOK_INIT(tun_dev_attach, selinux_tun_dev_attach),\n\tLSM_HOOK_INIT(tun_dev_open, selinux_tun_dev_open),\n#ifdef CONFIG_SECURITY_INFINIBAND\n\tLSM_HOOK_INIT(ib_pkey_access, selinux_ib_pkey_access),\n\tLSM_HOOK_INIT(ib_endport_manage_subnet,\n\t\t      selinux_ib_endport_manage_subnet),\n\tLSM_HOOK_INIT(ib_alloc_security, selinux_ib_alloc_security),\n\tLSM_HOOK_INIT(ib_free_security, selinux_ib_free_security),\n#endif\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\n\tLSM_HOOK_INIT(xfrm_policy_alloc_security, selinux_xfrm_policy_alloc),\n\tLSM_HOOK_INIT(xfrm_policy_clone_security, selinux_xfrm_policy_clone),\n\tLSM_HOOK_INIT(xfrm_policy_free_security, selinux_xfrm_policy_free),\n\tLSM_HOOK_INIT(xfrm_policy_delete_security, selinux_xfrm_policy_delete),\n\tLSM_HOOK_INIT(xfrm_state_alloc, selinux_xfrm_state_alloc),\n\tLSM_HOOK_INIT(xfrm_state_alloc_acquire,\n\t\t\tselinux_xfrm_state_alloc_acquire),\n\tLSM_HOOK_INIT(xfrm_state_free_security, selinux_xfrm_state_free),\n\tLSM_HOOK_INIT(xfrm_state_delete_security, selinux_xfrm_state_delete),\n\tLSM_HOOK_INIT(xfrm_policy_lookup, selinux_xfrm_policy_lookup),\n\tLSM_HOOK_INIT(xfrm_state_pol_flow_match,\n\t\t\tselinux_xfrm_state_pol_flow_match),\n\tLSM_HOOK_INIT(xfrm_decode_session, selinux_xfrm_decode_session),\n#endif\n\n#ifdef CONFIG_KEYS\n\tLSM_HOOK_INIT(key_alloc, selinux_key_alloc),\n\tLSM_HOOK_INIT(key_free, selinux_key_free),\n\tLSM_HOOK_INIT(key_permission, selinux_key_permission),\n\tLSM_HOOK_INIT(key_getsecurity, selinux_key_getsecurity),\n#endif\n\n#ifdef CONFIG_AUDIT\n\tLSM_HOOK_INIT(audit_rule_init, selinux_audit_rule_init),\n\tLSM_HOOK_INIT(audit_rule_known, selinux_audit_rule_known),\n\tLSM_HOOK_INIT(audit_rule_match, selinux_audit_rule_match),\n\tLSM_HOOK_INIT(audit_rule_free, selinux_audit_rule_free),\n#endif\n\n#ifdef CONFIG_BPF_SYSCALL\n\tLSM_HOOK_INIT(bpf, selinux_bpf),\n\tLSM_HOOK_INIT(bpf_map, selinux_bpf_map),\n\tLSM_HOOK_INIT(bpf_prog, selinux_bpf_prog),\n\tLSM_HOOK_INIT(bpf_map_alloc_security, selinux_bpf_map_alloc),\n\tLSM_HOOK_INIT(bpf_prog_alloc_security, selinux_bpf_prog_alloc),\n\tLSM_HOOK_INIT(bpf_map_free_security, selinux_bpf_map_free),\n\tLSM_HOOK_INIT(bpf_prog_free_security, selinux_bpf_prog_free),\n#endif\n};\n\nint selinux_disable(void)\n{\n\tif (ss_initialized) {\n\t\t/* Not permitted after initial policy load. */\n\t\treturn -EINVAL;\n\t}\n\n\tif (selinux_disabled) {\n\t\t/* Only do this once. */\n\t\treturn -EINVAL;\n\t}\n\n\tprintk(KERN_INFO \"SELinux:  Disabled at runtime.\\n\");\n\n\tselinux_disabled = 1;\n\tselinux_enabled = 0;\n\n\tsecurity_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));\n\n\t/* Try to destroy the avc node cache */\n\tavc_disable();\n\n\t/* Unregister netfilter hooks. */\n\tselinux_nf_ip_exit();\n\n\t/* Unregister selinuxfs. */\n\texit_sel_fs();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "page",
            "\"%d\"",
            "&new_value"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define sel_write_disable NULL\n\nstatic ssize_t sel_write_disable(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n\n{\n\tchar *page;\n\tssize_t length;\n\tint new_value;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t/* No partial writes. */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tlength = -EINVAL;\n\tif (sscanf(page, \"%d\", &new_value) != 1)\n\t\tgoto out;\n\n\tif (new_value) {\n\t\tlength = selinux_disable();\n\t\tif (length)\n\t\t\tgoto out;\n\t\taudit_log(current->audit_context, GFP_KERNEL, AUDIT_MAC_STATUS,\n\t\t\t\"selinux=0 auid=%u ses=%u\",\n\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\taudit_get_sessionid(current));\n\t}\n\n\tlength = count;\nout:\n\tkfree(page);\n\treturn length;\n}"
  },
  {
    "function_name": "sel_mmap_handle_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "217-237",
    "snippet": "static int sel_mmap_handle_status(struct file *filp,\n\t\t\t\t  struct vm_area_struct *vma)\n{\n\tstruct page    *status = filp->private_data;\n\tunsigned long\tsize = vma->vm_end - vma->vm_start;\n\n\tBUG_ON(!status);\n\n\t/* only allows one page from the head */\n\tif (vma->vm_pgoff > 0 || size != PAGE_SIZE)\n\t\treturn -EIO;\n\t/* disallow writable mapping */\n\tif (vma->vm_flags & VM_WRITE)\n\t\treturn -EPERM;\n\t/* disallow mprotect() turns it into writable */\n\tvma->vm_flags &= ~VM_MAYWRITE;\n\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\t       page_to_pfn(status),\n\t\t\t       size, vma->vm_page_prot);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t sel_write_access(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_create(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_user(struct file *file, char *buf, size_t size);",
      "static ssize_t sel_write_member(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_pfn_range",
          "args": [
            "vma",
            "vma->vm_start",
            "page_to_pfn(status)",
            "size",
            "vma->vm_page_prot"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "status"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!status"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sel_write_access(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_create(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_relabel(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_user(struct file *file, char *buf, size_t size);\nstatic ssize_t sel_write_member(struct file *file, char *buf, size_t size);\n\nstatic int sel_mmap_handle_status(struct file *filp,\n\t\t\t\t  struct vm_area_struct *vma)\n{\n\tstruct page    *status = filp->private_data;\n\tunsigned long\tsize = vma->vm_end - vma->vm_start;\n\n\tBUG_ON(!status);\n\n\t/* only allows one page from the head */\n\tif (vma->vm_pgoff > 0 || size != PAGE_SIZE)\n\t\treturn -EIO;\n\t/* disallow writable mapping */\n\tif (vma->vm_flags & VM_WRITE)\n\t\treturn -EPERM;\n\t/* disallow mprotect() turns it into writable */\n\tvma->vm_flags &= ~VM_MAYWRITE;\n\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\t       page_to_pfn(status),\n\t\t\t       size, vma->vm_page_prot);\n}"
  },
  {
    "function_name": "sel_read_handle_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "205-215",
    "snippet": "static ssize_t sel_read_handle_status(struct file *filp, char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct page    *status = filp->private_data;\n\n\tBUG_ON(!status);\n\n\treturn simple_read_from_buffer(buf, count, ppos,\n\t\t\t\t       page_address(status),\n\t\t\t\t       sizeof(struct selinux_kernel_status));\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "page_address(status)",
            "sizeof(struct selinux_kernel_status)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "status"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!status"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic ssize_t sel_read_handle_status(struct file *filp, char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct page    *status = filp->private_data;\n\n\tBUG_ON(!status);\n\n\treturn simple_read_from_buffer(buf, count, ppos,\n\t\t\t\t       page_address(status),\n\t\t\t\t       sizeof(struct selinux_kernel_status));\n}"
  },
  {
    "function_name": "sel_open_handle_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "193-203",
    "snippet": "static int sel_open_handle_status(struct inode *inode, struct file *filp)\n{\n\tstruct page    *status = selinux_kernel_status_page();\n\n\tif (!status)\n\t\treturn -ENOMEM;\n\n\tfilp->private_data = status;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_kernel_status_page",
          "args": [],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_kernel_status_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/status.c",
          "lines": "47-76",
          "snippet": "struct page *selinux_kernel_status_page(void)\n{\n\tstruct selinux_kernel_status   *status;\n\tstruct page\t\t       *result = NULL;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (!selinux_status_page) {\n\t\tselinux_status_page = alloc_page(GFP_KERNEL|__GFP_ZERO);\n\n\t\tif (selinux_status_page) {\n\t\t\tstatus = page_address(selinux_status_page);\n\n\t\t\tstatus->version = SELINUX_KERNEL_STATUS_VERSION;\n\t\t\tstatus->sequence = 0;\n\t\t\tstatus->enforcing = selinux_enforcing;\n\t\t\t/*\n\t\t\t * NOTE: the next policyload event shall set\n\t\t\t * a positive value on the status->policyload,\n\t\t\t * although it may not be 1, but never zero.\n\t\t\t * So, application can know it was updated.\n\t\t\t */\n\t\t\tstatus->policyload = 0;\n\t\t\tstatus->deny_unknown = !security_get_allow_unknown();\n\t\t}\n\t}\n\tresult = selinux_status_page;\n\tmutex_unlock(&selinux_status_lock);\n\n\treturn result;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"avc.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct page *selinux_status_page;",
            "static DEFINE_MUTEX(selinux_status_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"avc.h\"\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n\nstatic struct page *selinux_status_page;\nstatic DEFINE_MUTEX(selinux_status_lock);\n\nstruct page *selinux_kernel_status_page(void)\n{\n\tstruct selinux_kernel_status   *status;\n\tstruct page\t\t       *result = NULL;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (!selinux_status_page) {\n\t\tselinux_status_page = alloc_page(GFP_KERNEL|__GFP_ZERO);\n\n\t\tif (selinux_status_page) {\n\t\t\tstatus = page_address(selinux_status_page);\n\n\t\t\tstatus->version = SELINUX_KERNEL_STATUS_VERSION;\n\t\t\tstatus->sequence = 0;\n\t\t\tstatus->enforcing = selinux_enforcing;\n\t\t\t/*\n\t\t\t * NOTE: the next policyload event shall set\n\t\t\t * a positive value on the status->policyload,\n\t\t\t * although it may not be 1, but never zero.\n\t\t\t * So, application can know it was updated.\n\t\t\t */\n\t\t\tstatus->policyload = 0;\n\t\t\tstatus->deny_unknown = !security_get_allow_unknown();\n\t\t}\n\t}\n\tresult = selinux_status_page;\n\tmutex_unlock(&selinux_status_lock);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nstatic int sel_open_handle_status(struct inode *inode, struct file *filp)\n{\n\tstruct page    *status = selinux_kernel_status_page();\n\n\tif (!status)\n\t\treturn -ENOMEM;\n\n\tfilp->private_data = status;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sel_read_handle_unknown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "175-186",
    "snippet": "static ssize_t sel_read_handle_unknown(struct file *filp, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\tino_t ino = file_inode(filp)->i_ino;\n\tint handle_unknown = (ino == SEL_REJECT_UNKNOWN) ?\n\t\tsecurity_get_reject_unknown() : !security_get_allow_unknown();\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%d\", handle_unknown);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TMPBUFLEN\t12"
    ],
    "globals_used": [
      "static struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "tmpbuf",
            "length"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "tmpbuf",
            "TMPBUFLEN",
            "\"%d\"",
            "handle_unknown"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_get_allow_unknown",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "security_get_allow_unknown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3099-3102",
          "snippet": "int security_get_allow_unknown(void)\n{\n\treturn policydb.allow_unknown;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nint security_get_allow_unknown(void)\n{\n\treturn policydb.allow_unknown;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_get_reject_unknown",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "security_get_reject_unknown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3094-3097",
          "snippet": "int security_get_reject_unknown(void)\n{\n\treturn policydb.reject_unknown;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nint security_get_reject_unknown(void)\n{\n\treturn policydb.reject_unknown;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define TMPBUFLEN\t12\n\nstatic struct dentry *sel_make_dir(struct dentry *dir, const char *name,\n\t\t\tunsigned long *ino);\n\nstatic ssize_t sel_read_handle_unknown(struct file *filp, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\tino_t ino = file_inode(filp)->i_ino;\n\tint handle_unknown = (ino == SEL_REJECT_UNKNOWN) ?\n\t\tsecurity_get_reject_unknown() : !security_get_allow_unknown();\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%d\", handle_unknown);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}"
  },
  {
    "function_name": "sel_write_enforce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "116-164",
    "snippet": "static ssize_t sel_write_enforce(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n\n{\n\tchar *page = NULL;\n\tssize_t length;\n\tint new_value;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t/* No partial writes. */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tlength = -EINVAL;\n\tif (sscanf(page, \"%d\", &new_value) != 1)\n\t\tgoto out;\n\n\tnew_value = !!new_value;\n\n\tif (new_value != selinux_enforcing) {\n\t\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t\t      SECCLASS_SECURITY, SECURITY__SETENFORCE,\n\t\t\t\t      NULL);\n\t\tif (length)\n\t\t\tgoto out;\n\t\taudit_log(current->audit_context, GFP_KERNEL, AUDIT_MAC_STATUS,\n\t\t\t\"enforcing=%d old_enforcing=%d auid=%u ses=%u\",\n\t\t\tnew_value, selinux_enforcing,\n\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\taudit_get_sessionid(current));\n\t\tselinux_enforcing = new_value;\n\t\tif (selinux_enforcing)\n\t\t\tavc_ss_reset(0);\n\t\tselnl_notify_setenforce(selinux_enforcing);\n\t\tselinux_status_update_setenforce(selinux_enforcing);\n\t\tif (!selinux_enforcing)\n\t\t\tcall_lsm_notifier(LSM_POLICY_CHANGE, NULL);\n\t}\n\tlength = count;\nout:\n\tkfree(page);\n\treturn length;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define sel_write_enforce NULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "page"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_lsm_notifier",
          "args": [
            "LSM_POLICY_CHANGE",
            "NULL"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "call_lsm_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "172-175",
          "snippet": "int call_lsm_notifier(enum lsm_event event, void *data)\n{\n\treturn atomic_notifier_call_chain(&lsm_notifier_chain, event, data);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ATOMIC_NOTIFIER_HEAD(lsm_notifier_chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(lsm_notifier_chain);\n\nint call_lsm_notifier(enum lsm_event event, void *data)\n{\n\treturn atomic_notifier_call_chain(&lsm_notifier_chain, event, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_status_update_setenforce",
          "args": [
            "selinux_enforcing"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_status_update_setenforce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/status.c",
          "lines": "83-100",
          "snippet": "void selinux_status_update_setenforce(int enforcing)\n{\n\tstruct selinux_kernel_status   *status;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (selinux_status_page) {\n\t\tstatus = page_address(selinux_status_page);\n\n\t\tstatus->sequence++;\n\t\tsmp_wmb();\n\n\t\tstatus->enforcing = enforcing;\n\n\t\tsmp_wmb();\n\t\tstatus->sequence++;\n\t}\n\tmutex_unlock(&selinux_status_lock);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"avc.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct page *selinux_status_page;",
            "static DEFINE_MUTEX(selinux_status_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"avc.h\"\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n\nstatic struct page *selinux_status_page;\nstatic DEFINE_MUTEX(selinux_status_lock);\n\nvoid selinux_status_update_setenforce(int enforcing)\n{\n\tstruct selinux_kernel_status   *status;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (selinux_status_page) {\n\t\tstatus = page_address(selinux_status_page);\n\n\t\tstatus->sequence++;\n\t\tsmp_wmb();\n\n\t\tstatus->enforcing = enforcing;\n\n\t\tsmp_wmb();\n\t\tstatus->sequence++;\n\t}\n\tmutex_unlock(&selinux_status_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "selnl_notify_setenforce",
          "args": [
            "selinux_enforcing"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "selnl_notify_setenforce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlink.c",
          "lines": "101-104",
          "snippet": "void selnl_notify_setenforce(int val)\n{\n\tselnl_notify(SELNL_MSG_SETENFORCE, &val);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include <net/netlink.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/selinux_netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include <net/netlink.h>\n#include <net/net_namespace.h>\n#include <linux/selinux_netlink.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid selnl_notify_setenforce(int val)\n{\n\tselnl_notify(SELNL_MSG_SETENFORCE, &val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_ss_reset",
          "args": [
            "0"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "avc_ss_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "936-955",
          "snippet": "int avc_ss_reset(u32 seqno)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0, tmprc;\n\n\tavc_flush();\n\n\tfor (c = avc_callbacks; c; c = c->next) {\n\t\tif (c->events & AVC_CALLBACK_RESET) {\n\t\t\ttmprc = c->callback(AVC_CALLBACK_RESET);\n\t\t\t/* save the first error encountered for the return\n\t\t\t   value and continue processing the callbacks */\n\t\t\tif (!rc)\n\t\t\t\trc = tmprc;\n\t\t}\n\t}\n\n\tavc_latest_notif_update(seqno, 0);\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_callback_node *avc_callbacks;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_callback_node *avc_callbacks;\nstatic noinline struct;\n\nint avc_ss_reset(u32 seqno)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0, tmprc;\n\n\tavc_flush();\n\n\tfor (c = avc_callbacks; c; c = c->next) {\n\t\tif (c->events & AVC_CALLBACK_RESET) {\n\t\t\ttmprc = c->callback(AVC_CALLBACK_RESET);\n\t\t\t/* save the first error encountered for the return\n\t\t\t   value and continue processing the callbacks */\n\t\t\tif (!rc)\n\t\t\t\trc = tmprc;\n\t\t}\n\t}\n\n\tavc_latest_notif_update(seqno, 0);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "current->audit_context",
            "GFP_KERNEL",
            "AUDIT_MAC_STATUS",
            "\"enforcing=%d old_enforcing=%d auid=%u ses=%u\"",
            "new_value",
            "selinux_enforcing",
            "from_kuid(&init_user_ns, audit_get_loginuid(current))",
            "audit_get_sessionid(current)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "audit_get_loginuid(current)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "current_sid()",
            "SECINITSID_SECURITY",
            "SECCLASS_SECURITY",
            "SECURITY__SETENFORCE",
            "NULL"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_sid",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "current_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/objsec.h",
          "lines": "44-49",
          "snippet": "static inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}",
          "includes": [
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/in.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc.h\"\n#include \"flask.h\"\n#include <net/net_namespace.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/binfmts.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n\nstatic inline u32 current_sid(void)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\treturn tsec->sid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "page",
            "\"%d\"",
            "&new_value"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define sel_write_enforce NULL\n\nstatic ssize_t sel_write_enforce(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n\n{\n\tchar *page = NULL;\n\tssize_t length;\n\tint new_value;\n\n\tif (count >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\t/* No partial writes. */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tpage = memdup_user_nul(buf, count);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tlength = -EINVAL;\n\tif (sscanf(page, \"%d\", &new_value) != 1)\n\t\tgoto out;\n\n\tnew_value = !!new_value;\n\n\tif (new_value != selinux_enforcing) {\n\t\tlength = avc_has_perm(current_sid(), SECINITSID_SECURITY,\n\t\t\t\t      SECCLASS_SECURITY, SECURITY__SETENFORCE,\n\t\t\t\t      NULL);\n\t\tif (length)\n\t\t\tgoto out;\n\t\taudit_log(current->audit_context, GFP_KERNEL, AUDIT_MAC_STATUS,\n\t\t\t\"enforcing=%d old_enforcing=%d auid=%u ses=%u\",\n\t\t\tnew_value, selinux_enforcing,\n\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\taudit_get_sessionid(current));\n\t\tselinux_enforcing = new_value;\n\t\tif (selinux_enforcing)\n\t\t\tavc_ss_reset(0);\n\t\tselnl_notify_setenforce(selinux_enforcing);\n\t\tselinux_status_update_setenforce(selinux_enforcing);\n\t\tif (!selinux_enforcing)\n\t\t\tcall_lsm_notifier(LSM_POLICY_CHANGE, NULL);\n\t}\n\tlength = count;\nout:\n\tkfree(page);\n\treturn length;\n}"
  },
  {
    "function_name": "sel_read_enforce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "105-113",
    "snippet": "static ssize_t sel_read_enforce(struct file *filp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%d\", selinux_enforcing);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TMPBUFLEN\t12"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "tmpbuf",
            "length"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "tmpbuf",
            "TMPBUFLEN",
            "\"%d\"",
            "selinux_enforcing"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\n#define TMPBUFLEN\t12\n\nstatic ssize_t sel_read_enforce(struct file *filp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%d\", selinux_enforcing);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}"
  },
  {
    "function_name": "checkreqprot_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/selinuxfs.c",
    "lines": "46-52",
    "snippet": "static int __init checkreqprot_setup(char *str)\n{\n\tunsigned long checkreqprot;\n\tif (!kstrtoul(str, 0, &checkreqprot))\n\t\tselinux_checkreqprot = checkreqprot ? 1 : 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"conditional.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/kobject.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/audit.h>",
      "#include <linux/percpu.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/major.h>",
      "#include <linux/security.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/mutex.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int selinux_checkreqprot = CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "str",
            "0",
            "&checkreqprot"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"conditional.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <linux/ctype.h>\n#include <linux/kobject.h>\n#include <linux/uaccess.h>\n#include <linux/audit.h>\n#include <linux/percpu.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n\nunsigned int selinux_checkreqprot = CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE;\n\nstatic int __init checkreqprot_setup(char *str)\n{\n\tunsigned long checkreqprot;\n\tif (!kstrtoul(str, 0, &checkreqprot))\n\t\tselinux_checkreqprot = checkreqprot ? 1 : 0;\n\treturn 1;\n}"
  }
]