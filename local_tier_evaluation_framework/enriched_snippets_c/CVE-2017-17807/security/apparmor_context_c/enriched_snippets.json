[
  {
    "function_name": "aa_restore_previous_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
    "lines": "202-228",
    "snippet": "int aa_restore_previous_label(u64 token)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct cred *new = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\tif (ctx->token != token) {\n\t\tabort_creds(new);\n\t\treturn -EACCES;\n\t}\n\t/* ignore restores when there is no saved label */\n\tif (!ctx->previous) {\n\t\tabort_creds(new);\n\t\treturn 0;\n\t}\n\n\taa_put_label(ctx->label);\n\tctx->label = aa_get_newest_label(ctx->previous);\n\tAA_BUG(!ctx->label);\n\t/* clear exec && prev information when restoring to previous context */\n\taa_clear_task_ctx_trans(ctx);\n\n\tcommit_creds(new);\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/context.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_clear_task_ctx_trans",
          "args": [
            "ctx"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "aa_clear_task_ctx_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "220-227",
          "snippet": "static inline void aa_clear_task_ctx_trans(struct aa_task_ctx *ctx)\n{\n\taa_put_label(ctx->previous);\n\taa_put_label(ctx->onexec);\n\tctx->previous = NULL;\n\tctx->onexec = NULL;\n\tctx->token = 0;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void aa_clear_task_ctx_trans(struct aa_task_ctx *ctx)\n{\n\taa_put_label(ctx->previous);\n\taa_put_label(ctx->onexec);\n\tctx->previous = NULL;\n\tctx->onexec = NULL;\n\tctx->token = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ctx->label"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_newest_label",
          "args": [
            "ctx->previous"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "393-414",
          "snippet": "static inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "ctx->label"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "new"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "new"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "new"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nint aa_restore_previous_label(u64 token)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct cred *new = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\tif (ctx->token != token) {\n\t\tabort_creds(new);\n\t\treturn -EACCES;\n\t}\n\t/* ignore restores when there is no saved label */\n\tif (!ctx->previous) {\n\t\tabort_creds(new);\n\t\treturn 0;\n\t}\n\n\taa_put_label(ctx->label);\n\tctx->label = aa_get_newest_label(ctx->previous);\n\tAA_BUG(!ctx->label);\n\t/* clear exec && prev information when restoring to previous context */\n\taa_clear_task_ctx_trans(ctx);\n\n\tcommit_creds(new);\n\treturn 0;\n}"
  },
  {
    "function_name": "aa_set_current_hat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
    "lines": "164-191",
    "snippet": "int aa_set_current_hat(struct aa_label *label, u64 token)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct cred *new = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tAA_BUG(!label);\n\n\tctx = cred_ctx(new);\n\tif (!ctx->previous) {\n\t\t/* transfer refcount */\n\t\tctx->previous = ctx->label;\n\t\tctx->token = token;\n\t} else if (ctx->token == token) {\n\t\taa_put_label(ctx->label);\n\t} else {\n\t\t/* previous_profile && ctx->token != token */\n\t\tabort_creds(new);\n\t\treturn -EACCES;\n\t}\n\tctx->label = aa_get_newest_label(label);\n\t/* clear exec on switching context */\n\taa_put_label(ctx->onexec);\n\tctx->onexec = NULL;\n\n\tcommit_creds(new);\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/context.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "ctx->onexec"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_newest_label",
          "args": [
            "label"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "393-414",
          "snippet": "static inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "new"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "new"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nint aa_set_current_hat(struct aa_label *label, u64 token)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct cred *new = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tAA_BUG(!label);\n\n\tctx = cred_ctx(new);\n\tif (!ctx->previous) {\n\t\t/* transfer refcount */\n\t\tctx->previous = ctx->label;\n\t\tctx->token = token;\n\t} else if (ctx->token == token) {\n\t\taa_put_label(ctx->label);\n\t} else {\n\t\t/* previous_profile && ctx->token != token */\n\t\tabort_creds(new);\n\t\treturn -EACCES;\n\t}\n\tctx->label = aa_get_newest_label(label);\n\t/* clear exec on switching context */\n\taa_put_label(ctx->onexec);\n\tctx->onexec = NULL;\n\n\tcommit_creds(new);\n\treturn 0;\n}"
  },
  {
    "function_name": "aa_set_current_onexec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
    "lines": "137-152",
    "snippet": "int aa_set_current_onexec(struct aa_label *label, bool stack)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct cred *new = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\taa_get_label(label);\n\taa_clear_task_ctx_trans(ctx);\n\tctx->onexec = label;\n\tctx->token = stack;\n\n\tcommit_creds(new);\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/context.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_clear_task_ctx_trans",
          "args": [
            "ctx"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "aa_clear_task_ctx_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "220-227",
          "snippet": "static inline void aa_clear_task_ctx_trans(struct aa_task_ctx *ctx)\n{\n\taa_put_label(ctx->previous);\n\taa_put_label(ctx->onexec);\n\tctx->previous = NULL;\n\tctx->onexec = NULL;\n\tctx->token = 0;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void aa_clear_task_ctx_trans(struct aa_task_ctx *ctx)\n{\n\taa_put_label(ctx->previous);\n\taa_put_label(ctx->onexec);\n\tctx->previous = NULL;\n\tctx->onexec = NULL;\n\tctx->token = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "label"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "new"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nint aa_set_current_onexec(struct aa_label *label, bool stack)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct cred *new = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\taa_get_label(label);\n\taa_clear_task_ctx_trans(ctx);\n\tctx->onexec = label;\n\tctx->token = stack;\n\n\tcommit_creds(new);\n\treturn 0;\n}"
  },
  {
    "function_name": "aa_replace_current_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
    "lines": "94-129",
    "snippet": "int aa_replace_current_label(struct aa_label *label)\n{\n\tstruct aa_task_ctx *ctx = current_ctx();\n\tstruct cred *new;\n\tAA_BUG(!label);\n\n\tif (ctx->label == label)\n\t\treturn 0;\n\n\tif (current_cred() != current_real_cred())\n\t\treturn -EBUSY;\n\n\tnew  = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\tif (unconfined(label) || (labels_ns(ctx->label) != labels_ns(label)))\n\t\t/* if switching to unconfined or a different label namespace\n\t\t * clear out context state\n\t\t */\n\t\taa_clear_task_ctx_trans(ctx);\n\n\t/*\n\t * be careful switching ctx->profile, when racing replacement it\n\t * is possible that ctx->profile->proxy->profile is the reference\n\t * keeping @profile valid, so make sure to get its reference before\n\t * dropping the reference on ctx->profile\n\t */\n\taa_get_label(label);\n\taa_put_label(ctx->label);\n\tctx->label = label;\n\n\tcommit_creds(new);\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/context.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "ctx->label"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "label"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_clear_task_ctx_trans",
          "args": [
            "ctx"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "aa_clear_task_ctx_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "220-227",
          "snippet": "static inline void aa_clear_task_ctx_trans(struct aa_task_ctx *ctx)\n{\n\taa_put_label(ctx->previous);\n\taa_put_label(ctx->onexec);\n\tctx->previous = NULL;\n\tctx->onexec = NULL;\n\tctx->token = 0;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void aa_clear_task_ctx_trans(struct aa_task_ctx *ctx)\n{\n\taa_put_label(ctx->previous);\n\taa_put_label(ctx->onexec);\n\tctx->previous = NULL;\n\tctx->onexec = NULL;\n\tctx->token = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "ctx->label"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "label"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "new"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_real_cred",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_ctx",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nint aa_replace_current_label(struct aa_label *label)\n{\n\tstruct aa_task_ctx *ctx = current_ctx();\n\tstruct cred *new;\n\tAA_BUG(!label);\n\n\tif (ctx->label == label)\n\t\treturn 0;\n\n\tif (current_cred() != current_real_cred())\n\t\treturn -EBUSY;\n\n\tnew  = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\tif (unconfined(label) || (labels_ns(ctx->label) != labels_ns(label)))\n\t\t/* if switching to unconfined or a different label namespace\n\t\t * clear out context state\n\t\t */\n\t\taa_clear_task_ctx_trans(ctx);\n\n\t/*\n\t * be careful switching ctx->profile, when racing replacement it\n\t * is possible that ctx->profile->proxy->profile is the reference\n\t * keeping @profile valid, so make sure to get its reference before\n\t * dropping the reference on ctx->profile\n\t */\n\taa_get_label(label);\n\taa_put_label(ctx->label);\n\tctx->label = label;\n\n\tcommit_creds(new);\n\treturn 0;\n}"
  },
  {
    "function_name": "aa_get_task_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
    "lines": "77-86",
    "snippet": "struct aa_label *aa_get_task_label(struct task_struct *task)\n{\n\tstruct aa_label *p;\n\n\trcu_read_lock();\n\tp = aa_get_newest_label(__aa_task_raw_label(task));\n\trcu_read_unlock();\n\n\treturn p;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/context.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_newest_label",
          "args": [
            "__aa_task_raw_label(task)"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "393-414",
          "snippet": "static inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__aa_task_raw_label",
          "args": [
            "task"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_task_raw_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "93-96",
          "snippet": "static inline struct aa_label *__aa_task_raw_label(struct task_struct *task)\n{\n\treturn aa_cred_raw_label(__task_cred(task));\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *__aa_task_raw_label(struct task_struct *task)\n{\n\treturn aa_cred_raw_label(__task_cred(task));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nstruct aa_label *aa_get_task_label(struct task_struct *task)\n{\n\tstruct aa_label *p;\n\n\trcu_read_lock();\n\tp = aa_get_newest_label(__aa_task_raw_label(task));\n\trcu_read_unlock();\n\n\treturn p;\n}"
  },
  {
    "function_name": "aa_dup_task_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
    "lines": "63-69",
    "snippet": "void aa_dup_task_context(struct aa_task_ctx *new, const struct aa_task_ctx *old)\n{\n\t*new = *old;\n\taa_get_label(new->label);\n\taa_get_label(new->previous);\n\taa_get_label(new->onexec);\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/context.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "new->onexec"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nvoid aa_dup_task_context(struct aa_task_ctx *new, const struct aa_task_ctx *old)\n{\n\t*new = *old;\n\taa_get_label(new->label);\n\taa_get_label(new->previous);\n\taa_get_label(new->onexec);\n}"
  },
  {
    "function_name": "aa_free_task_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
    "lines": "47-56",
    "snippet": "void aa_free_task_context(struct aa_task_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(ctx->label);\n\t\taa_put_label(ctx->previous);\n\t\taa_put_label(ctx->onexec);\n\n\t\tkzfree(ctx);\n\t}\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/context.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "ctx"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "ctx->onexec"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nvoid aa_free_task_context(struct aa_task_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(ctx->label);\n\t\taa_put_label(ctx->previous);\n\t\taa_put_label(ctx->onexec);\n\n\t\tkzfree(ctx);\n\t}\n}"
  },
  {
    "function_name": "aa_alloc_task_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
    "lines": "38-41",
    "snippet": "struct aa_task_ctx *aa_alloc_task_context(gfp_t flags)\n{\n\treturn kzalloc(sizeof(struct aa_task_ctx), flags);\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/context.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct aa_task_ctx)",
            "flags"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nstruct aa_task_ctx *aa_alloc_task_context(gfp_t flags)\n{\n\treturn kzalloc(sizeof(struct aa_task_ctx), flags);\n}"
  }
]