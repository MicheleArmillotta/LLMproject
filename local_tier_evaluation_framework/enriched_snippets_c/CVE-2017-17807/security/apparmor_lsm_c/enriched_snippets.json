[
  {
    "function_name": "apparmor_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "1116-1180",
    "snippet": "static int __init apparmor_init(void)\n{\n\tint error;\n\n\tif (!apparmor_enabled || !security_module_enable(\"apparmor\")) {\n\t\taa_info_message(\"AppArmor disabled by boot time parameter\");\n\t\tapparmor_enabled = false;\n\t\treturn 0;\n\t}\n\n\terror = aa_setup_dfa_engine();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to setup dfa engine\\n\");\n\t\tgoto alloc_out;\n\t}\n\n\terror = aa_alloc_root_ns();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to allocate default profile namespace\\n\");\n\t\tgoto alloc_out;\n\t}\n\n\terror = apparmor_init_sysctl();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to register sysctls\\n\");\n\t\tgoto alloc_out;\n\n\t}\n\n\terror = alloc_buffers();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to allocate work buffers\\n\");\n\t\tgoto buffers_out;\n\t}\n\n\terror = set_init_ctx();\n\tif (error) {\n\t\tAA_ERROR(\"Failed to set context on init task\\n\");\n\t\taa_free_root_ns();\n\t\tgoto buffers_out;\n\t}\n\tsecurity_add_hooks(apparmor_hooks, ARRAY_SIZE(apparmor_hooks),\n\t\t\t\t\"apparmor\");\n\n\t/* Report that AppArmor successfully initialized */\n\tapparmor_initialized = 1;\n\tif (aa_g_profile_mode == APPARMOR_COMPLAIN)\n\t\taa_info_message(\"AppArmor initialized: complain mode enabled\");\n\telse if (aa_g_profile_mode == APPARMOR_KILL)\n\t\taa_info_message(\"AppArmor initialized: kill mode enabled\");\n\telse\n\t\taa_info_message(\"AppArmor initialized\");\n\n\treturn error;\n\nbuffers_out:\n\tdestroy_buffers();\n\nalloc_out:\n\taa_destroy_aafs();\n\taa_teardown_dfa_engine();\n\n\tapparmor_enabled = false;\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int apparmor_initialized;",
      "static struct security_hook_list apparmor_hooks[] __lsm_ro_after_init = {\n\tLSM_HOOK_INIT(ptrace_access_check, apparmor_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, apparmor_ptrace_traceme),\n\tLSM_HOOK_INIT(capget, apparmor_capget),\n\tLSM_HOOK_INIT(capable, apparmor_capable),\n\n\tLSM_HOOK_INIT(sb_mount, apparmor_sb_mount),\n\tLSM_HOOK_INIT(sb_umount, apparmor_sb_umount),\n\tLSM_HOOK_INIT(sb_pivotroot, apparmor_sb_pivotroot),\n\n\tLSM_HOOK_INIT(path_link, apparmor_path_link),\n\tLSM_HOOK_INIT(path_unlink, apparmor_path_unlink),\n\tLSM_HOOK_INIT(path_symlink, apparmor_path_symlink),\n\tLSM_HOOK_INIT(path_mkdir, apparmor_path_mkdir),\n\tLSM_HOOK_INIT(path_rmdir, apparmor_path_rmdir),\n\tLSM_HOOK_INIT(path_mknod, apparmor_path_mknod),\n\tLSM_HOOK_INIT(path_rename, apparmor_path_rename),\n\tLSM_HOOK_INIT(path_chmod, apparmor_path_chmod),\n\tLSM_HOOK_INIT(path_chown, apparmor_path_chown),\n\tLSM_HOOK_INIT(path_truncate, apparmor_path_truncate),\n\tLSM_HOOK_INIT(inode_getattr, apparmor_inode_getattr),\n\n\tLSM_HOOK_INIT(file_open, apparmor_file_open),\n\tLSM_HOOK_INIT(file_receive, apparmor_file_receive),\n\tLSM_HOOK_INIT(file_permission, apparmor_file_permission),\n\tLSM_HOOK_INIT(file_alloc_security, apparmor_file_alloc_security),\n\tLSM_HOOK_INIT(file_free_security, apparmor_file_free_security),\n\tLSM_HOOK_INIT(mmap_file, apparmor_mmap_file),\n\tLSM_HOOK_INIT(file_mprotect, apparmor_file_mprotect),\n\tLSM_HOOK_INIT(file_lock, apparmor_file_lock),\n\n\tLSM_HOOK_INIT(getprocattr, apparmor_getprocattr),\n\tLSM_HOOK_INIT(setprocattr, apparmor_setprocattr),\n\n\tLSM_HOOK_INIT(cred_alloc_blank, apparmor_cred_alloc_blank),\n\tLSM_HOOK_INIT(cred_free, apparmor_cred_free),\n\tLSM_HOOK_INIT(cred_prepare, apparmor_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, apparmor_cred_transfer),\n\n\tLSM_HOOK_INIT(bprm_set_creds, apparmor_bprm_set_creds),\n\tLSM_HOOK_INIT(bprm_committing_creds, apparmor_bprm_committing_creds),\n\tLSM_HOOK_INIT(bprm_committed_creds, apparmor_bprm_committed_creds),\n\n\tLSM_HOOK_INIT(task_setrlimit, apparmor_task_setrlimit),\n\tLSM_HOOK_INIT(task_kill, apparmor_task_kill),\n};",
      "enum profile_mode aa_g_profile_mode = APPARMOR_ENFORCE;",
      "static bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_teardown_dfa_engine",
          "args": [],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "aa_teardown_dfa_engine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "49-53",
          "snippet": "void aa_teardown_dfa_engine(void)\n{\n\taa_put_dfa(nulldfa);\n\tnulldfa = NULL;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct aa_dfa *nulldfa;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstruct aa_dfa *nulldfa;\n\nvoid aa_teardown_dfa_engine(void)\n{\n\taa_put_dfa(nulldfa);\n\tnulldfa = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_destroy_aafs",
          "args": [],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "aa_destroy_aafs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "2326-2329",
          "snippet": "void __init aa_destroy_aafs(void)\n{\n\tentry_remove_dir(&aa_sfs_entry);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic struct aa_sfs_entry aa_sfs_entry =\n\tAA_SFS_DIR(\"apparmor\", aa_sfs_entry_apparmor);\n\nvoid __init aa_destroy_aafs(void)\n{\n\tentry_remove_dir(&aa_sfs_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_buffers",
          "args": [],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "1039-1049",
          "snippet": "static void destroy_buffers(void)\n{\n\tu32 i, j;\n\n\tfor_each_possible_cpu(i) {\n\t\tfor_each_cpu_buffer(j) {\n\t\t\tkfree(per_cpu(aa_buffers, i).buf[j]);\n\t\t\tper_cpu(aa_buffers, i).buf[j] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic void destroy_buffers(void)\n{\n\tu32 i, j;\n\n\tfor_each_possible_cpu(i) {\n\t\tfor_each_cpu_buffer(j) {\n\t\t\tkfree(per_cpu(aa_buffers, i).buf[j]);\n\t\t\tper_cpu(aa_buffers, i).buf[j] = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_info_message",
          "args": [
            "\"AppArmor initialized\""
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "aa_info_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "126-135",
          "snippet": "void aa_info_message(const char *str)\n{\n\tif (audit_enabled) {\n\t\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, NULL);\n\n\t\taad(&sa)->info = str;\n\t\taa_audit_msg(AUDIT_APPARMOR_STATUS, &sa, NULL);\n\t}\n\tprintk(KERN_INFO \"AppArmor: %s\\n\", str);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_info_message(const char *str)\n{\n\tif (audit_enabled) {\n\t\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, NULL);\n\n\t\taad(&sa)->info = str;\n\t\taa_audit_msg(AUDIT_APPARMOR_STATUS, &sa, NULL);\n\t}\n\tprintk(KERN_INFO \"AppArmor: %s\\n\", str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_add_hooks",
          "args": [
            "apparmor_hooks",
            "ARRAY_SIZE(apparmor_hooks)",
            "\"apparmor\""
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "security_add_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "159-170",
          "snippet": "void __init security_add_hooks(struct security_hook_list *hooks, int count,\n\t\t\t\tchar *lsm)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\thooks[i].lsm = lsm;\n\t\tlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n\t}\n\tif (lsm_append(lsm, &lsm_names) < 0)\n\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *lsm_names;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nchar *lsm_names;\n\nvoid __init security_add_hooks(struct security_hook_list *hooks, int count,\n\t\t\t\tchar *lsm)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\thooks[i].lsm = lsm;\n\t\tlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n\t}\n\tif (lsm_append(lsm, &lsm_names) < 0)\n\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "apparmor_hooks"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_free_root_ns",
          "args": [],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "aa_free_root_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "406-414",
          "snippet": "void __init aa_free_root_ns(void)\n{\n\t struct aa_ns *ns = root_ns;\n\n\t root_ns = NULL;\n\n\t destroy_ns(ns);\n\t aa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct aa_ns *root_ns;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nstruct aa_ns *root_ns;\n\nvoid __init aa_free_root_ns(void)\n{\n\t struct aa_ns *ns = root_ns;\n\n\t root_ns = NULL;\n\n\t destroy_ns(ns);\n\t aa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_ERROR",
          "args": [
            "\"Failed to set context on init task\\n\""
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_init_ctx",
          "args": [],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "set_init_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "1024-1037",
          "snippet": "static int __init set_init_ctx(void)\n{\n\tstruct cred *cred = (struct cred *)current->real_cred;\n\tstruct aa_task_ctx *ctx;\n\n\tctx = aa_alloc_task_context(GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->label = aa_get_label(ns_unconfined(root_ns));\n\tcred_ctx(cred) = ctx;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int __init set_init_ctx(void)\n{\n\tstruct cred *cred = (struct cred *)current->real_cred;\n\tstruct aa_task_ctx *ctx;\n\n\tctx = aa_alloc_task_context(GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->label = aa_get_label(ns_unconfined(root_ns));\n\tcred_ctx(cred) = ctx;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_ERROR",
          "args": [
            "\"Unable to allocate work buffers\\n\""
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_buffers",
          "args": [],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "1051-1074",
          "snippet": "static int __init alloc_buffers(void)\n{\n\tu32 i, j;\n\n\tfor_each_possible_cpu(i) {\n\t\tfor_each_cpu_buffer(j) {\n\t\t\tchar *buffer;\n\n\t\t\tif (cpu_to_node(i) > num_online_nodes())\n\t\t\t\t/* fallback to kmalloc for offline nodes */\n\t\t\t\tbuffer = kmalloc(aa_g_path_max, GFP_KERNEL);\n\t\t\telse\n\t\t\t\tbuffer = kmalloc_node(aa_g_path_max, GFP_KERNEL,\n\t\t\t\t\t\t      cpu_to_node(i));\n\t\t\tif (!buffer) {\n\t\t\t\tdestroy_buffers();\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tper_cpu(aa_buffers, i).buf[j] = buffer;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int aa_g_path_max = 2 * PATH_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nunsigned int aa_g_path_max = 2 * PATH_MAX;\n\nstatic int __init alloc_buffers(void)\n{\n\tu32 i, j;\n\n\tfor_each_possible_cpu(i) {\n\t\tfor_each_cpu_buffer(j) {\n\t\t\tchar *buffer;\n\n\t\t\tif (cpu_to_node(i) > num_online_nodes())\n\t\t\t\t/* fallback to kmalloc for offline nodes */\n\t\t\t\tbuffer = kmalloc(aa_g_path_max, GFP_KERNEL);\n\t\t\telse\n\t\t\t\tbuffer = kmalloc_node(aa_g_path_max, GFP_KERNEL,\n\t\t\t\t\t\t      cpu_to_node(i));\n\t\t\tif (!buffer) {\n\t\t\t\tdestroy_buffers();\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tper_cpu(aa_buffers, i).buf[j] = buffer;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_ERROR",
          "args": [
            "\"Unable to register sysctls\\n\""
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apparmor_init_sysctl",
          "args": [],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "apparmor_init_sysctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "1110-1113",
          "snippet": "static inline int apparmor_init_sysctl(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic inline int apparmor_init_sysctl(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_ERROR",
          "args": [
            "\"Unable to allocate default profile namespace\\n\""
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_alloc_root_ns",
          "args": [],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "aa_alloc_root_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "393-401",
          "snippet": "int __init aa_alloc_root_ns(void)\n{\n\t/* released by aa_free_root_ns - used as list ref*/\n\troot_ns = alloc_ns(NULL, \"root\");\n\tif (!root_ns)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct aa_ns *root_ns;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nstruct aa_ns *root_ns;\n\nint __init aa_alloc_root_ns(void)\n{\n\t/* released by aa_free_root_ns - used as list ref*/\n\troot_ns = alloc_ns(NULL, \"root\");\n\tif (!root_ns)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_ERROR",
          "args": [
            "\"Unable to setup dfa engine\\n\""
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_setup_dfa_engine",
          "args": [],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "aa_setup_dfa_engine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "33-47",
          "snippet": "int aa_setup_dfa_engine(void)\n{\n\tint error;\n\n\tnulldfa = aa_dfa_unpack(nulldfa_src, sizeof(nulldfa_src),\n\t\t\t\tTO_ACCEPT1_FLAG(YYTD_DATA32) |\n\t\t\t\tTO_ACCEPT2_FLAG(YYTD_DATA32));\n\tif (!IS_ERR(nulldfa))\n\t\treturn 0;\n\n\terror = PTR_ERR(nulldfa);\n\tnulldfa = NULL;\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char nulldfa_src[] = {\n\t#include \"nulldfa.in\"\n};",
            "struct aa_dfa *nulldfa;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic char nulldfa_src[] = {\n\t#include \"nulldfa.in\"\n};\nstruct aa_dfa *nulldfa;\n\nint aa_setup_dfa_engine(void)\n{\n\tint error;\n\n\tnulldfa = aa_dfa_unpack(nulldfa_src, sizeof(nulldfa_src),\n\t\t\t\tTO_ACCEPT1_FLAG(YYTD_DATA32) |\n\t\t\t\tTO_ACCEPT2_FLAG(YYTD_DATA32));\n\tif (!IS_ERR(nulldfa))\n\t\treturn 0;\n\n\terror = PTR_ERR(nulldfa);\n\tnulldfa = NULL;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_module_enable",
          "args": [
            "\"apparmor\""
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "security_module_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "146-149",
          "snippet": "int __init security_module_enable(const char *module)\n{\n\treturn !strcmp(module, chosen_lsm);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =\n\tCONFIG_DEFAULT_SECURITY;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nstatic __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =\n\tCONFIG_DEFAULT_SECURITY;\n\nint __init security_module_enable(const char *module)\n{\n\treturn !strcmp(module, chosen_lsm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nint apparmor_initialized;\nstatic struct security_hook_list apparmor_hooks[] __lsm_ro_after_init = {\n\tLSM_HOOK_INIT(ptrace_access_check, apparmor_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, apparmor_ptrace_traceme),\n\tLSM_HOOK_INIT(capget, apparmor_capget),\n\tLSM_HOOK_INIT(capable, apparmor_capable),\n\n\tLSM_HOOK_INIT(sb_mount, apparmor_sb_mount),\n\tLSM_HOOK_INIT(sb_umount, apparmor_sb_umount),\n\tLSM_HOOK_INIT(sb_pivotroot, apparmor_sb_pivotroot),\n\n\tLSM_HOOK_INIT(path_link, apparmor_path_link),\n\tLSM_HOOK_INIT(path_unlink, apparmor_path_unlink),\n\tLSM_HOOK_INIT(path_symlink, apparmor_path_symlink),\n\tLSM_HOOK_INIT(path_mkdir, apparmor_path_mkdir),\n\tLSM_HOOK_INIT(path_rmdir, apparmor_path_rmdir),\n\tLSM_HOOK_INIT(path_mknod, apparmor_path_mknod),\n\tLSM_HOOK_INIT(path_rename, apparmor_path_rename),\n\tLSM_HOOK_INIT(path_chmod, apparmor_path_chmod),\n\tLSM_HOOK_INIT(path_chown, apparmor_path_chown),\n\tLSM_HOOK_INIT(path_truncate, apparmor_path_truncate),\n\tLSM_HOOK_INIT(inode_getattr, apparmor_inode_getattr),\n\n\tLSM_HOOK_INIT(file_open, apparmor_file_open),\n\tLSM_HOOK_INIT(file_receive, apparmor_file_receive),\n\tLSM_HOOK_INIT(file_permission, apparmor_file_permission),\n\tLSM_HOOK_INIT(file_alloc_security, apparmor_file_alloc_security),\n\tLSM_HOOK_INIT(file_free_security, apparmor_file_free_security),\n\tLSM_HOOK_INIT(mmap_file, apparmor_mmap_file),\n\tLSM_HOOK_INIT(file_mprotect, apparmor_file_mprotect),\n\tLSM_HOOK_INIT(file_lock, apparmor_file_lock),\n\n\tLSM_HOOK_INIT(getprocattr, apparmor_getprocattr),\n\tLSM_HOOK_INIT(setprocattr, apparmor_setprocattr),\n\n\tLSM_HOOK_INIT(cred_alloc_blank, apparmor_cred_alloc_blank),\n\tLSM_HOOK_INIT(cred_free, apparmor_cred_free),\n\tLSM_HOOK_INIT(cred_prepare, apparmor_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, apparmor_cred_transfer),\n\n\tLSM_HOOK_INIT(bprm_set_creds, apparmor_bprm_set_creds),\n\tLSM_HOOK_INIT(bprm_committing_creds, apparmor_bprm_committing_creds),\n\tLSM_HOOK_INIT(bprm_committed_creds, apparmor_bprm_committed_creds),\n\n\tLSM_HOOK_INIT(task_setrlimit, apparmor_task_setrlimit),\n\tLSM_HOOK_INIT(task_kill, apparmor_task_kill),\n};\nenum profile_mode aa_g_profile_mode = APPARMOR_ENFORCE;\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\n\nstatic int __init apparmor_init(void)\n{\n\tint error;\n\n\tif (!apparmor_enabled || !security_module_enable(\"apparmor\")) {\n\t\taa_info_message(\"AppArmor disabled by boot time parameter\");\n\t\tapparmor_enabled = false;\n\t\treturn 0;\n\t}\n\n\terror = aa_setup_dfa_engine();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to setup dfa engine\\n\");\n\t\tgoto alloc_out;\n\t}\n\n\terror = aa_alloc_root_ns();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to allocate default profile namespace\\n\");\n\t\tgoto alloc_out;\n\t}\n\n\terror = apparmor_init_sysctl();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to register sysctls\\n\");\n\t\tgoto alloc_out;\n\n\t}\n\n\terror = alloc_buffers();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to allocate work buffers\\n\");\n\t\tgoto buffers_out;\n\t}\n\n\terror = set_init_ctx();\n\tif (error) {\n\t\tAA_ERROR(\"Failed to set context on init task\\n\");\n\t\taa_free_root_ns();\n\t\tgoto buffers_out;\n\t}\n\tsecurity_add_hooks(apparmor_hooks, ARRAY_SIZE(apparmor_hooks),\n\t\t\t\t\"apparmor\");\n\n\t/* Report that AppArmor successfully initialized */\n\tapparmor_initialized = 1;\n\tif (aa_g_profile_mode == APPARMOR_COMPLAIN)\n\t\taa_info_message(\"AppArmor initialized: complain mode enabled\");\n\telse if (aa_g_profile_mode == APPARMOR_KILL)\n\t\taa_info_message(\"AppArmor initialized: kill mode enabled\");\n\telse\n\t\taa_info_message(\"AppArmor initialized\");\n\n\treturn error;\n\nbuffers_out:\n\tdestroy_buffers();\n\nalloc_out:\n\taa_destroy_aafs();\n\taa_teardown_dfa_engine();\n\n\tapparmor_enabled = false;\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_init_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "1110-1113",
    "snippet": "static inline int apparmor_init_sysctl(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic inline int apparmor_init_sysctl(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "apparmor_init_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "1104-1108",
    "snippet": "static int __init apparmor_init_sysctl(void)\n{\n\treturn register_sysctl_paths(apparmor_sysctl_path,\n\t\t\t\t     apparmor_sysctl_table) ? 0 : -ENOMEM;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_sysctl_paths",
          "args": [
            "apparmor_sysctl_path",
            "apparmor_sysctl_table"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int __init apparmor_init_sysctl(void)\n{\n\treturn register_sysctl_paths(apparmor_sysctl_path,\n\t\t\t\t     apparmor_sysctl_table) ? 0 : -ENOMEM;\n}"
  },
  {
    "function_name": "apparmor_dointvec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "1077-1086",
    "snippet": "static int apparmor_dointvec(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (!policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\treturn proc_dointvec(table, write, buffer, lenp, ppos);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_dointvec",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy_admin_capable",
          "args": [
            "NULL"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\n\nstatic int apparmor_dointvec(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (!policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\treturn proc_dointvec(table, write, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "alloc_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "1051-1074",
    "snippet": "static int __init alloc_buffers(void)\n{\n\tu32 i, j;\n\n\tfor_each_possible_cpu(i) {\n\t\tfor_each_cpu_buffer(j) {\n\t\t\tchar *buffer;\n\n\t\t\tif (cpu_to_node(i) > num_online_nodes())\n\t\t\t\t/* fallback to kmalloc for offline nodes */\n\t\t\t\tbuffer = kmalloc(aa_g_path_max, GFP_KERNEL);\n\t\t\telse\n\t\t\t\tbuffer = kmalloc_node(aa_g_path_max, GFP_KERNEL,\n\t\t\t\t\t\t      cpu_to_node(i));\n\t\t\tif (!buffer) {\n\t\t\t\tdestroy_buffers();\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tper_cpu(aa_buffers, i).buf[j] = buffer;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int aa_g_path_max = 2 * PATH_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "aa_buffers",
            "i"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_buffers",
          "args": [],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "1039-1049",
          "snippet": "static void destroy_buffers(void)\n{\n\tu32 i, j;\n\n\tfor_each_possible_cpu(i) {\n\t\tfor_each_cpu_buffer(j) {\n\t\t\tkfree(per_cpu(aa_buffers, i).buf[j]);\n\t\t\tper_cpu(aa_buffers, i).buf[j] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic void destroy_buffers(void)\n{\n\tu32 i, j;\n\n\tfor_each_possible_cpu(i) {\n\t\tfor_each_cpu_buffer(j) {\n\t\t\tkfree(per_cpu(aa_buffers, i).buf[j]);\n\t\t\tper_cpu(aa_buffers, i).buf[j] = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "aa_g_path_max",
            "GFP_KERNEL",
            "cpu_to_node(i)"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "i"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "aa_g_path_max",
            "GFP_KERNEL"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_nodes",
          "args": [],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "i"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nunsigned int aa_g_path_max = 2 * PATH_MAX;\n\nstatic int __init alloc_buffers(void)\n{\n\tu32 i, j;\n\n\tfor_each_possible_cpu(i) {\n\t\tfor_each_cpu_buffer(j) {\n\t\t\tchar *buffer;\n\n\t\t\tif (cpu_to_node(i) > num_online_nodes())\n\t\t\t\t/* fallback to kmalloc for offline nodes */\n\t\t\t\tbuffer = kmalloc(aa_g_path_max, GFP_KERNEL);\n\t\t\telse\n\t\t\t\tbuffer = kmalloc_node(aa_g_path_max, GFP_KERNEL,\n\t\t\t\t\t\t      cpu_to_node(i));\n\t\t\tif (!buffer) {\n\t\t\t\tdestroy_buffers();\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tper_cpu(aa_buffers, i).buf[j] = buffer;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "destroy_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "1039-1049",
    "snippet": "static void destroy_buffers(void)\n{\n\tu32 i, j;\n\n\tfor_each_possible_cpu(i) {\n\t\tfor_each_cpu_buffer(j) {\n\t\t\tkfree(per_cpu(aa_buffers, i).buf[j]);\n\t\t\tper_cpu(aa_buffers, i).buf[j] = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "aa_buffers",
            "i"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "per_cpu(aa_buffers, i).buf[j]"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "aa_buffers",
            "i"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic void destroy_buffers(void)\n{\n\tu32 i, j;\n\n\tfor_each_possible_cpu(i) {\n\t\tfor_each_cpu_buffer(j) {\n\t\t\tkfree(per_cpu(aa_buffers, i).buf[j]);\n\t\t\tper_cpu(aa_buffers, i).buf[j] = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "set_init_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "1024-1037",
    "snippet": "static int __init set_init_ctx(void)\n{\n\tstruct cred *cred = (struct cred *)current->real_cred;\n\tstruct aa_task_ctx *ctx;\n\n\tctx = aa_alloc_task_context(GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->label = aa_get_label(ns_unconfined(root_ns));\n\tcred_ctx(cred) = ctx;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "cred"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "ns_unconfined(root_ns)"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_unconfined",
          "args": [
            "root_ns"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_alloc_task_context",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "aa_alloc_task_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "38-41",
          "snippet": "struct aa_task_ctx *aa_alloc_task_context(gfp_t flags)\n{\n\treturn kzalloc(sizeof(struct aa_task_ctx), flags);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nstruct aa_task_ctx *aa_alloc_task_context(gfp_t flags)\n{\n\treturn kzalloc(sizeof(struct aa_task_ctx), flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int __init set_init_ctx(void)\n{\n\tstruct cred *cred = (struct cred *)current->real_cred;\n\tstruct aa_task_ctx *ctx;\n\n\tctx = aa_alloc_task_context(GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->label = aa_get_label(ns_unconfined(root_ns));\n\tcred_ctx(cred) = ctx;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "param_set_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "994-1013",
    "snippet": "static int param_set_mode(const char *val, const struct kernel_param *kp)\n{\n\tint i;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (!val)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\n\tfor (i = 0; i < APPARMOR_MODE_NAMES_MAX_INDEX; i++) {\n\t\tif (strcmp(val, aa_profile_mode_names[i]) == 0) {\n\t\t\taa_g_profile_mode = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int apparmor_initialized;",
      "static int param_set_aabool(const char *val, const struct kernel_param *kp);",
      "static int param_get_aabool(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aauint(const char *val, const struct kernel_param *kp);",
      "static int param_get_aauint(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);",
      "static int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);",
      "static int param_set_audit(const char *val, const struct kernel_param *kp);",
      "static int param_get_audit(char *buffer, const struct kernel_param *kp);",
      "static int param_set_mode(const char *val, const struct kernel_param *kp);",
      "static int param_get_mode(char *buffer, const struct kernel_param *kp);",
      "enum profile_mode aa_g_profile_mode = APPARMOR_ENFORCE;",
      "static bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "val",
            "aa_profile_mode_names[i]"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy_admin_capable",
          "args": [
            "NULL"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nint apparmor_initialized;\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\nstatic int param_set_audit(const char *val, const struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, const struct kernel_param *kp);\nstatic int param_set_mode(const char *val, const struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, const struct kernel_param *kp);\nenum profile_mode aa_g_profile_mode = APPARMOR_ENFORCE;\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\n\nstatic int param_set_mode(const char *val, const struct kernel_param *kp)\n{\n\tint i;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (!val)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\n\tfor (i = 0; i < APPARMOR_MODE_NAMES_MAX_INDEX; i++) {\n\t\tif (strcmp(val, aa_profile_mode_names[i]) == 0) {\n\t\t\taa_g_profile_mode = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "param_get_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "984-992",
    "snippet": "static int param_get_mode(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_view_capable(NULL))\n\t\treturn -EPERM;\n\n\treturn sprintf(buffer, \"%s\", aa_profile_mode_names[aa_g_profile_mode]);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int apparmor_initialized;",
      "static int param_set_aabool(const char *val, const struct kernel_param *kp);",
      "static int param_get_aabool(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aauint(const char *val, const struct kernel_param *kp);",
      "static int param_get_aauint(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);",
      "static int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);",
      "static int param_set_audit(const char *val, const struct kernel_param *kp);",
      "static int param_get_audit(char *buffer, const struct kernel_param *kp);",
      "static int param_set_mode(const char *val, const struct kernel_param *kp);",
      "static int param_get_mode(char *buffer, const struct kernel_param *kp);",
      "enum profile_mode aa_g_profile_mode = APPARMOR_ENFORCE;",
      "static bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer",
            "\"%s\"",
            "aa_profile_mode_names[aa_g_profile_mode]"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy_view_capable",
          "args": [
            "NULL"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "policy_view_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "640-658",
          "snippet": "bool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int unprivileged_userns_apparmor_policy = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint unprivileged_userns_apparmor_policy = 1;\n\nbool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nint apparmor_initialized;\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\nstatic int param_set_audit(const char *val, const struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, const struct kernel_param *kp);\nstatic int param_set_mode(const char *val, const struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, const struct kernel_param *kp);\nenum profile_mode aa_g_profile_mode = APPARMOR_ENFORCE;\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\n\nstatic int param_get_mode(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_view_capable(NULL))\n\t\treturn -EPERM;\n\n\treturn sprintf(buffer, \"%s\", aa_profile_mode_names[aa_g_profile_mode]);\n}"
  },
  {
    "function_name": "param_set_audit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "963-982",
    "snippet": "static int param_set_audit(const char *val, const struct kernel_param *kp)\n{\n\tint i;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (!val)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\n\tfor (i = 0; i < AUDIT_MAX_INDEX; i++) {\n\t\tif (strcmp(val, audit_mode_names[i]) == 0) {\n\t\t\taa_g_audit = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int apparmor_initialized;",
      "static int param_set_aabool(const char *val, const struct kernel_param *kp);",
      "static int param_get_aabool(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aauint(const char *val, const struct kernel_param *kp);",
      "static int param_get_aauint(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);",
      "static int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);",
      "static int param_set_audit(const char *val, const struct kernel_param *kp);",
      "static int param_get_audit(char *buffer, const struct kernel_param *kp);",
      "static int param_set_mode(const char *val, const struct kernel_param *kp);",
      "static int param_get_mode(char *buffer, const struct kernel_param *kp);",
      "enum audit_mode aa_g_audit;",
      "static bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "val",
            "audit_mode_names[i]"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy_admin_capable",
          "args": [
            "NULL"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nint apparmor_initialized;\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\nstatic int param_set_audit(const char *val, const struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, const struct kernel_param *kp);\nstatic int param_set_mode(const char *val, const struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, const struct kernel_param *kp);\nenum audit_mode aa_g_audit;\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\n\nstatic int param_set_audit(const char *val, const struct kernel_param *kp)\n{\n\tint i;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (!val)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\n\tfor (i = 0; i < AUDIT_MAX_INDEX; i++) {\n\t\tif (strcmp(val, audit_mode_names[i]) == 0) {\n\t\t\taa_g_audit = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "param_get_audit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "954-961",
    "snippet": "static int param_get_audit(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_view_capable(NULL))\n\t\treturn -EPERM;\n\treturn sprintf(buffer, \"%s\", audit_mode_names[aa_g_audit]);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int apparmor_initialized;",
      "static int param_set_aabool(const char *val, const struct kernel_param *kp);",
      "static int param_get_aabool(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aauint(const char *val, const struct kernel_param *kp);",
      "static int param_get_aauint(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);",
      "static int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);",
      "static int param_set_audit(const char *val, const struct kernel_param *kp);",
      "static int param_get_audit(char *buffer, const struct kernel_param *kp);",
      "static int param_set_mode(const char *val, const struct kernel_param *kp);",
      "static int param_get_mode(char *buffer, const struct kernel_param *kp);",
      "enum audit_mode aa_g_audit;",
      "static bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer",
            "\"%s\"",
            "audit_mode_names[aa_g_audit]"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy_view_capable",
          "args": [
            "NULL"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "policy_view_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "640-658",
          "snippet": "bool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int unprivileged_userns_apparmor_policy = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint unprivileged_userns_apparmor_policy = 1;\n\nbool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nint apparmor_initialized;\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\nstatic int param_set_audit(const char *val, const struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, const struct kernel_param *kp);\nstatic int param_set_mode(const char *val, const struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, const struct kernel_param *kp);\nenum audit_mode aa_g_audit;\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\n\nstatic int param_get_audit(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_view_capable(NULL))\n\t\treturn -EPERM;\n\treturn sprintf(buffer, \"%s\", audit_mode_names[aa_g_audit]);\n}"
  },
  {
    "function_name": "param_get_aauint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "945-952",
    "snippet": "static int param_get_aauint(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_view_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_get_uint(buffer, kp);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int apparmor_initialized;",
      "static int param_set_aabool(const char *val, const struct kernel_param *kp);",
      "static int param_get_aabool(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aauint(const char *val, const struct kernel_param *kp);",
      "static int param_get_aauint(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);",
      "static int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);",
      "static int param_set_audit(const char *val, const struct kernel_param *kp);",
      "static int param_get_audit(char *buffer, const struct kernel_param *kp);",
      "static int param_set_mode(const char *val, const struct kernel_param *kp);",
      "static int param_get_mode(char *buffer, const struct kernel_param *kp);",
      "static bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "param_get_uint",
          "args": [
            "buffer",
            "kp"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy_view_capable",
          "args": [
            "NULL"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "policy_view_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "640-658",
          "snippet": "bool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int unprivileged_userns_apparmor_policy = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint unprivileged_userns_apparmor_policy = 1;\n\nbool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nint apparmor_initialized;\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\nstatic int param_set_audit(const char *val, const struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, const struct kernel_param *kp);\nstatic int param_set_mode(const char *val, const struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, const struct kernel_param *kp);\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\n\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_view_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_get_uint(buffer, kp);\n}"
  },
  {
    "function_name": "param_set_aauint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "929-943",
    "snippet": "static int param_set_aauint(const char *val, const struct kernel_param *kp)\n{\n\tint error;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\t/* file is ro but enforce 2nd line check */\n\tif (apparmor_initialized)\n\t\treturn -EPERM;\n\n\terror = param_set_uint(val, kp);\n\tpr_info(\"AppArmor: buffer size set to %d bytes\\n\", aa_g_path_max);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int apparmor_initialized;",
      "static int param_set_aabool(const char *val, const struct kernel_param *kp);",
      "static int param_get_aabool(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aauint(const char *val, const struct kernel_param *kp);",
      "static int param_get_aauint(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);",
      "static int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);",
      "static int param_set_audit(const char *val, const struct kernel_param *kp);",
      "static int param_get_audit(char *buffer, const struct kernel_param *kp);",
      "static int param_set_mode(const char *val, const struct kernel_param *kp);",
      "static int param_get_mode(char *buffer, const struct kernel_param *kp);",
      "unsigned int aa_g_path_max = 2 * PATH_MAX;",
      "static bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"AppArmor: buffer size set to %d bytes\\n\"",
            "aa_g_path_max"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param_set_uint",
          "args": [
            "val",
            "kp"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nint apparmor_initialized;\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\nstatic int param_set_audit(const char *val, const struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, const struct kernel_param *kp);\nstatic int param_set_mode(const char *val, const struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, const struct kernel_param *kp);\nunsigned int aa_g_path_max = 2 * PATH_MAX;\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\n\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp)\n{\n\tint error;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\t/* file is ro but enforce 2nd line check */\n\tif (apparmor_initialized)\n\t\treturn -EPERM;\n\n\terror = param_set_uint(val, kp);\n\tpr_info(\"AppArmor: buffer size set to %d bytes\\n\", aa_g_path_max);\n\n\treturn error;\n}"
  },
  {
    "function_name": "param_get_aabool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "920-927",
    "snippet": "static int param_get_aabool(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_view_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int apparmor_initialized;",
      "static int param_set_aabool(const char *val, const struct kernel_param *kp);",
      "static int param_get_aabool(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aauint(const char *val, const struct kernel_param *kp);",
      "static int param_get_aauint(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);",
      "static int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);",
      "static int param_set_audit(const char *val, const struct kernel_param *kp);",
      "static int param_get_audit(char *buffer, const struct kernel_param *kp);",
      "static int param_set_mode(const char *val, const struct kernel_param *kp);",
      "static int param_get_mode(char *buffer, const struct kernel_param *kp);",
      "static bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "param_get_bool",
          "args": [
            "buffer",
            "kp"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy_view_capable",
          "args": [
            "NULL"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "policy_view_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "640-658",
          "snippet": "bool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int unprivileged_userns_apparmor_policy = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint unprivileged_userns_apparmor_policy = 1;\n\nbool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nint apparmor_initialized;\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\nstatic int param_set_audit(const char *val, const struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, const struct kernel_param *kp);\nstatic int param_set_mode(const char *val, const struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, const struct kernel_param *kp);\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\n\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_view_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}"
  },
  {
    "function_name": "param_set_aabool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "911-918",
    "snippet": "static int param_set_aabool(const char *val, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_set_bool(val, kp);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int apparmor_initialized;",
      "static int param_set_aabool(const char *val, const struct kernel_param *kp);",
      "static int param_get_aabool(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aauint(const char *val, const struct kernel_param *kp);",
      "static int param_get_aauint(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);",
      "static int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);",
      "static int param_set_audit(const char *val, const struct kernel_param *kp);",
      "static int param_get_audit(char *buffer, const struct kernel_param *kp);",
      "static int param_set_mode(const char *val, const struct kernel_param *kp);",
      "static int param_get_mode(char *buffer, const struct kernel_param *kp);",
      "static bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "param_set_bool",
          "args": [
            "val",
            "kp"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy_admin_capable",
          "args": [
            "NULL"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nint apparmor_initialized;\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\nstatic int param_set_audit(const char *val, const struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, const struct kernel_param *kp);\nstatic int param_set_mode(const char *val, const struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, const struct kernel_param *kp);\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\n\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_set_bool(val, kp);\n}"
  },
  {
    "function_name": "param_get_aalockpolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "902-909",
    "snippet": "static int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_view_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int apparmor_initialized;",
      "static int param_set_aabool(const char *val, const struct kernel_param *kp);",
      "static int param_get_aabool(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aauint(const char *val, const struct kernel_param *kp);",
      "static int param_get_aauint(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);",
      "static int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);",
      "static int param_set_audit(const char *val, const struct kernel_param *kp);",
      "static int param_get_audit(char *buffer, const struct kernel_param *kp);",
      "static int param_set_mode(const char *val, const struct kernel_param *kp);",
      "static int param_get_mode(char *buffer, const struct kernel_param *kp);",
      "static bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "param_get_bool",
          "args": [
            "buffer",
            "kp"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy_view_capable",
          "args": [
            "NULL"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "policy_view_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "640-658",
          "snippet": "bool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int unprivileged_userns_apparmor_policy = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint unprivileged_userns_apparmor_policy = 1;\n\nbool policy_view_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tstruct aa_ns *view_ns = aa_get_current_ns();\n\tbool root_in_user_ns = uid_eq(current_euid(), make_kuid(user_ns, 0)) ||\n\t\t\t       in_egroup_p(make_kgid(user_ns, 0));\n\tbool response = false;\n\tif (!ns)\n\t\tns = view_ns;\n\n\tif (root_in_user_ns && aa_ns_visible(view_ns, ns, true) &&\n\t    (user_ns == &init_user_ns ||\n\t     (unprivileged_userns_apparmor_policy != 0 &&\n\t      user_ns->level == view_ns->level)))\n\t\tresponse = true;\n\taa_put_ns(view_ns);\n\n\treturn response;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nint apparmor_initialized;\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\nstatic int param_set_audit(const char *val, const struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, const struct kernel_param *kp);\nstatic int param_set_mode(const char *val, const struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, const struct kernel_param *kp);\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\n\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_view_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}"
  },
  {
    "function_name": "param_set_aalockpolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "893-900",
    "snippet": "static int param_set_aalockpolicy(const char *val, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_set_bool(val, kp);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int apparmor_initialized;",
      "static int param_set_aabool(const char *val, const struct kernel_param *kp);",
      "static int param_get_aabool(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aauint(const char *val, const struct kernel_param *kp);",
      "static int param_get_aauint(char *buffer, const struct kernel_param *kp);",
      "static int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);",
      "static int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);",
      "static int param_set_audit(const char *val, const struct kernel_param *kp);",
      "static int param_get_audit(char *buffer, const struct kernel_param *kp);",
      "static int param_set_mode(const char *val, const struct kernel_param *kp);",
      "static int param_get_mode(char *buffer, const struct kernel_param *kp);",
      "static bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "param_set_bool",
          "args": [
            "val",
            "kp"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy_admin_capable",
          "args": [
            "NULL"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nint apparmor_initialized;\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\nstatic int param_set_audit(const char *val, const struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, const struct kernel_param *kp);\nstatic int param_set_mode(const char *val, const struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, const struct kernel_param *kp);\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\n\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp)\n{\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\tif (apparmor_initialized && !policy_admin_capable(NULL))\n\t\treturn -EPERM;\n\treturn param_set_bool(val, kp);\n}"
  },
  {
    "function_name": "apparmor_enabled_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "881-888",
    "snippet": "static int __init apparmor_enabled_setup(char *str)\n{\n\tunsigned long enabled;\n\tint error = kstrtoul(str, 0, &enabled);\n\tif (!error)\n\t\tapparmor_enabled = enabled ? 1 : 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "str",
            "0",
            "&enabled"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\n\nstatic int __init apparmor_enabled_setup(char *str)\n{\n\tunsigned long enabled;\n\tint error = kstrtoul(str, 0, &enabled);\n\tif (!error)\n\t\tapparmor_enabled = enabled ? 1 : 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "apparmor_task_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "719-737",
    "snippet": "static int apparmor_task_kill(struct task_struct *target, struct siginfo *info,\n\t\t\t      int sig, u32 secid)\n{\n\tstruct aa_label *cl, *tl;\n\tint error;\n\n\tif (secid)\n\t\t/* TODO: after secid to label mapping is done.\n\t\t *  Dealing with USB IO specific behavior\n\t\t */\n\t\treturn 0;\n\tcl = __begin_current_label_crit_section();\n\ttl = aa_get_task_label(target);\n\terror = aa_may_signal(cl, tl, sig);\n\taa_put_label(tl);\n\t__end_current_label_crit_section(cl);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__end_current_label_crit_section",
          "args": [
            "cl"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "tl"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_may_signal",
          "args": [
            "cl",
            "tl",
            "sig"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "aa_may_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
          "lines": "215-222",
          "snippet": "int aa_may_signal(struct aa_label *sender, struct aa_label *target, int sig)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SIGNAL);\n\n\taad(&sa)->signal = map_signal_num(sig);\n\treturn xcheck_labels_profiles(sender, target, aa_signal_cross_perm,\n\t\t\t\t      &sa);\n}",
          "includes": [
            "#include \"include/sig_names.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nint aa_may_signal(struct aa_label *sender, struct aa_label *target, int sig)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SIGNAL);\n\n\taad(&sa)->signal = map_signal_num(sig);\n\treturn xcheck_labels_profiles(sender, target, aa_signal_cross_perm,\n\t\t\t\t      &sa);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_task_label",
          "args": [
            "target"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_task_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "77-86",
          "snippet": "struct aa_label *aa_get_task_label(struct task_struct *task)\n{\n\tstruct aa_label *p;\n\n\trcu_read_lock();\n\tp = aa_get_newest_label(__aa_task_raw_label(task));\n\trcu_read_unlock();\n\n\treturn p;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nstruct aa_label *aa_get_task_label(struct task_struct *task)\n{\n\tstruct aa_label *p;\n\n\trcu_read_lock();\n\tp = aa_get_newest_label(__aa_task_raw_label(task));\n\trcu_read_unlock();\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__begin_current_label_crit_section",
          "args": [],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "__begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "168-176",
          "snippet": "static inline struct aa_label *__begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label))\n\t\tlabel = aa_get_newest_label(label);\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *__begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label))\n\t\tlabel = aa_get_newest_label(label);\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_task_kill(struct task_struct *target, struct siginfo *info,\n\t\t\t      int sig, u32 secid)\n{\n\tstruct aa_label *cl, *tl;\n\tint error;\n\n\tif (secid)\n\t\t/* TODO: after secid to label mapping is done.\n\t\t *  Dealing with USB IO specific behavior\n\t\t */\n\t\treturn 0;\n\tcl = __begin_current_label_crit_section();\n\ttl = aa_get_task_label(target);\n\terror = aa_may_signal(cl, tl, sig);\n\taa_put_label(tl);\n\t__end_current_label_crit_section(cl);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_task_setrlimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "706-717",
    "snippet": "static int apparmor_task_setrlimit(struct task_struct *task,\n\t\tunsigned int resource, struct rlimit *new_rlim)\n{\n\tstruct aa_label *label = __begin_current_label_crit_section();\n\tint error = 0;\n\n\tif (!unconfined(label))\n\t\terror = aa_task_setrlimit(label, task, resource, new_rlim);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_task_setrlimit",
          "args": [
            "label",
            "task",
            "resource",
            "new_rlim"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "aa_task_setrlimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/resource.c",
          "lines": "108-138",
          "snippet": "int aa_task_setrlimit(struct aa_label *label, struct task_struct *task,\n\t\t      unsigned int resource, struct rlimit *new_rlim)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *peer;\n\tint error = 0;\n\n\trcu_read_lock();\n\tpeer = aa_get_newest_cred_label(__task_cred(task));\n\trcu_read_unlock();\n\n\t/* TODO: extend resource control to handle other (non current)\n\t * profiles.  AppArmor rules currently have the implicit assumption\n\t * that the task is setting the resource of a task confined with\n\t * the same profile or that the task setting the resource of another\n\t * task has CAP_SYS_RESOURCE.\n\t */\n\n\tif (label != peer &&\n\t    !aa_capable(label, CAP_SYS_RESOURCE, SECURITY_CAP_NOAUDIT))\n\t\terror = fn_for_each(label, profile,\n\t\t\t\taudit_resource(profile, resource,\n\t\t\t\t\t       new_rlim->rlim_max, peer,\n\t\t\t\t\t       \"cap_sys_resource\", -EACCES));\n\telse\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\t\tprofile_setrlimit(profile, resource, new_rlim));\n\taa_put_label(peer);\n\n\treturn error;\n}",
          "includes": [
            "#include \"rlim_names.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rlim_names.h\"\n#include \"include/policy.h\"\n#include \"include/resource.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include <linux/security.h>\n#include <linux/audit.h>\n\nint aa_task_setrlimit(struct aa_label *label, struct task_struct *task,\n\t\t      unsigned int resource, struct rlimit *new_rlim)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *peer;\n\tint error = 0;\n\n\trcu_read_lock();\n\tpeer = aa_get_newest_cred_label(__task_cred(task));\n\trcu_read_unlock();\n\n\t/* TODO: extend resource control to handle other (non current)\n\t * profiles.  AppArmor rules currently have the implicit assumption\n\t * that the task is setting the resource of a task confined with\n\t * the same profile or that the task setting the resource of another\n\t * task has CAP_SYS_RESOURCE.\n\t */\n\n\tif (label != peer &&\n\t    !aa_capable(label, CAP_SYS_RESOURCE, SECURITY_CAP_NOAUDIT))\n\t\terror = fn_for_each(label, profile,\n\t\t\t\taudit_resource(profile, resource,\n\t\t\t\t\t       new_rlim->rlim_max, peer,\n\t\t\t\t\t       \"cap_sys_resource\", -EACCES));\n\telse\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\t\tprofile_setrlimit(profile, resource, new_rlim));\n\taa_put_label(peer);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "label"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__begin_current_label_crit_section",
          "args": [],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "__begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "168-176",
          "snippet": "static inline struct aa_label *__begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label))\n\t\tlabel = aa_get_newest_label(label);\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *__begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label))\n\t\tlabel = aa_get_newest_label(label);\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_task_setrlimit(struct task_struct *task,\n\t\tunsigned int resource, struct rlimit *new_rlim)\n{\n\tstruct aa_label *label = __begin_current_label_crit_section();\n\tint error = 0;\n\n\tif (!unconfined(label))\n\t\terror = aa_task_setrlimit(label, task, resource, new_rlim);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_bprm_committed_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "700-704",
    "snippet": "static void apparmor_bprm_committed_creds(struct linux_binprm *bprm)\n{\n\t/* TODO: cleanup signals - ipc mediation */\n\treturn;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic void apparmor_bprm_committed_creds(struct linux_binprm *bprm)\n{\n\t/* TODO: cleanup signals - ipc mediation */\n\treturn;\n}"
  },
  {
    "function_name": "apparmor_bprm_committing_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "678-694",
    "snippet": "static void apparmor_bprm_committing_creds(struct linux_binprm *bprm)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\tstruct aa_task_ctx *new_ctx = cred_ctx(bprm->cred);\n\n\t/* bail out if unconfined or not changing profile */\n\tif ((new_ctx->label->proxy == label->proxy) ||\n\t    (unconfined(new_ctx->label)))\n\t\treturn;\n\n\taa_inherit_files(bprm->cred, current->files);\n\n\tcurrent->pdeath_signal = 0;\n\n\t/* reset soft limits and set hard limits for the new label */\n\t__aa_transition_rlimits(label, new_ctx->label);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__aa_transition_rlimits",
          "args": [
            "label",
            "new_ctx->label"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_transition_rlimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/resource.c",
          "lines": "145-191",
          "snippet": "void __aa_transition_rlimits(struct aa_label *old_l, struct aa_label *new_l)\n{\n\tunsigned int mask = 0;\n\tstruct rlimit *rlim, *initrlim;\n\tstruct aa_profile *old, *new;\n\tstruct label_it i;\n\n\told = labels_profile(old_l);\n\tnew = labels_profile(new_l);\n\n\t/* for any rlimits the profile controlled, reset the soft limit\n\t * to the lesser of the tasks hard limit and the init tasks soft limit\n\t */\n\tlabel_for_each_confined(i, old_l, old) {\n\t\tif (old->rlimits.mask) {\n\t\t\tint j;\n\n\t\t\tfor (j = 0, mask = 1; j < RLIM_NLIMITS; j++,\n\t\t\t\t     mask <<= 1) {\n\t\t\t\tif (old->rlimits.mask & mask) {\n\t\t\t\t\trlim = current->signal->rlim + j;\n\t\t\t\t\tinitrlim = init_task.signal->rlim + j;\n\t\t\t\t\trlim->rlim_cur = min(rlim->rlim_max,\n\t\t\t\t\t\t\t    initrlim->rlim_cur);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set any new hard limits as dictated by the new profile */\n\tlabel_for_each_confined(i, new_l, new) {\n\t\tint j;\n\n\t\tif (!new->rlimits.mask)\n\t\t\tcontinue;\n\t\tfor (j = 0, mask = 1; j < RLIM_NLIMITS; j++, mask <<= 1) {\n\t\t\tif (!(new->rlimits.mask & mask))\n\t\t\t\tcontinue;\n\n\t\t\trlim = current->signal->rlim + j;\n\t\t\trlim->rlim_max = min(rlim->rlim_max,\n\t\t\t\t\t     new->rlimits.limits[j].rlim_max);\n\t\t\t/* soft limit should not exceed hard limit */\n\t\t\trlim->rlim_cur = min(rlim->rlim_cur, rlim->rlim_max);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rlim_names.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rlim_names.h\"\n#include \"include/policy.h\"\n#include \"include/resource.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include <linux/security.h>\n#include <linux/audit.h>\n\nvoid __aa_transition_rlimits(struct aa_label *old_l, struct aa_label *new_l)\n{\n\tunsigned int mask = 0;\n\tstruct rlimit *rlim, *initrlim;\n\tstruct aa_profile *old, *new;\n\tstruct label_it i;\n\n\told = labels_profile(old_l);\n\tnew = labels_profile(new_l);\n\n\t/* for any rlimits the profile controlled, reset the soft limit\n\t * to the lesser of the tasks hard limit and the init tasks soft limit\n\t */\n\tlabel_for_each_confined(i, old_l, old) {\n\t\tif (old->rlimits.mask) {\n\t\t\tint j;\n\n\t\t\tfor (j = 0, mask = 1; j < RLIM_NLIMITS; j++,\n\t\t\t\t     mask <<= 1) {\n\t\t\t\tif (old->rlimits.mask & mask) {\n\t\t\t\t\trlim = current->signal->rlim + j;\n\t\t\t\t\tinitrlim = init_task.signal->rlim + j;\n\t\t\t\t\trlim->rlim_cur = min(rlim->rlim_max,\n\t\t\t\t\t\t\t    initrlim->rlim_cur);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set any new hard limits as dictated by the new profile */\n\tlabel_for_each_confined(i, new_l, new) {\n\t\tint j;\n\n\t\tif (!new->rlimits.mask)\n\t\t\tcontinue;\n\t\tfor (j = 0, mask = 1; j < RLIM_NLIMITS; j++, mask <<= 1) {\n\t\t\tif (!(new->rlimits.mask & mask))\n\t\t\t\tcontinue;\n\n\t\t\trlim = current->signal->rlim + j;\n\t\t\trlim->rlim_max = min(rlim->rlim_max,\n\t\t\t\t\t     new->rlimits.limits[j].rlim_max);\n\t\t\t/* soft limit should not exceed hard limit */\n\t\t\trlim->rlim_cur = min(rlim->rlim_cur, rlim->rlim_max);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_inherit_files",
          "args": [
            "bprm->cred",
            "current->files"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "aa_inherit_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "652-676",
          "snippet": "void aa_inherit_files(const struct cred *cred, struct files_struct *files)\n{\n\tstruct aa_label *label = aa_get_newest_cred_label(cred);\n\tstruct file *devnull = NULL;\n\tunsigned int n;\n\n\trevalidate_tty(label);\n\n\t/* Revalidate access to inherited open files. */\n\tn = iterate_fd(files, 0, match_file, label);\n\tif (!n) /* none found? */\n\t\tgoto out;\n\n\tdevnull = dentry_open(&aa_null, O_RDWR, cred);\n\tif (IS_ERR(devnull))\n\t\tdevnull = NULL;\n\t/* replace all the matching ones with this */\n\tdo {\n\t\treplace_fd(n - 1, devnull, 0);\n\t} while ((n = iterate_fd(files, n, match_file, label)) != 0);\n\tif (devnull)\n\t\tfput(devnull);\nout:\n\taa_put_label(label);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nvoid aa_inherit_files(const struct cred *cred, struct files_struct *files)\n{\n\tstruct aa_label *label = aa_get_newest_cred_label(cred);\n\tstruct file *devnull = NULL;\n\tunsigned int n;\n\n\trevalidate_tty(label);\n\n\t/* Revalidate access to inherited open files. */\n\tn = iterate_fd(files, 0, match_file, label);\n\tif (!n) /* none found? */\n\t\tgoto out;\n\n\tdevnull = dentry_open(&aa_null, O_RDWR, cred);\n\tif (IS_ERR(devnull))\n\t\tdevnull = NULL;\n\t/* replace all the matching ones with this */\n\tdo {\n\t\treplace_fd(n - 1, devnull, 0);\n\t} while ((n = iterate_fd(files, n, match_file, label)) != 0);\n\tif (devnull)\n\t\tfput(devnull);\nout:\n\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "new_ctx->label"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "bprm->cred"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_current_raw_label",
          "args": [],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "aa_current_raw_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "117-120",
          "snippet": "static inline struct aa_label *aa_current_raw_label(void)\n{\n\treturn aa_cred_raw_label(current_cred());\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *aa_current_raw_label(void)\n{\n\treturn aa_cred_raw_label(current_cred());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic void apparmor_bprm_committing_creds(struct linux_binprm *bprm)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\tstruct aa_task_ctx *new_ctx = cred_ctx(bprm->cred);\n\n\t/* bail out if unconfined or not changing profile */\n\tif ((new_ctx->label->proxy == label->proxy) ||\n\t    (unconfined(new_ctx->label)))\n\t\treturn;\n\n\taa_inherit_files(bprm->cred, current->files);\n\n\tcurrent->pdeath_signal = 0;\n\n\t/* reset soft limits and set hard limits for the new label */\n\t__aa_transition_rlimits(label, new_ctx->label);\n}"
  },
  {
    "function_name": "apparmor_setprocattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "601-672",
    "snippet": "static int apparmor_setprocattr(const char *name, void *value,\n\t\t\t\tsize_t size)\n{\n\tchar *command, *largs = NULL, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SETPROCATTR);\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\t/* AppArmor requires that the buffer must be null terminated atm */\n\tif (args[size - 1] != '\\0') {\n\t\t/* null terminate */\n\t\tlargs = args = kmalloc(size + 1, GFP_KERNEL);\n\t\tif (!args)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(args, value, size);\n\t\targs[size] = '\\0';\n\t}\n\n\terror = -EINVAL;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\tgoto out;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\tgoto out;\n\n\targ_size = size - (args - (largs ? largs : (char *) value));\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_CHANGE_NOFLAGS);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_CHANGE_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_change_profile(args, AA_CHANGE_NOFLAGS);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_change_profile(args, AA_CHANGE_TEST);\n\t\t} else if (strcmp(command, \"stack\") == 0) {\n\t\t\terror = aa_change_profile(args, AA_CHANGE_STACK);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_change_profile(args, AA_CHANGE_ONEXEC);\n\t\telse if (strcmp(command, \"stack\") == 0)\n\t\t\terror = aa_change_profile(args, (AA_CHANGE_ONEXEC |\n\t\t\t\t\t\t\t AA_CHANGE_STACK));\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\tgoto fail;\n\n\tif (!error)\n\t\terror = size;\nout:\n\tkfree(largs);\n\treturn error;\n\nfail:\n\taad(&sa)->label = begin_current_label_crit_section();\n\taad(&sa)->info = name;\n\taad(&sa)->error = error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\tend_current_label_crit_section(aad(&sa)->label);\n\tgoto out;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "aad(&sa)->label"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_audit_msg",
          "args": [
            "AUDIT_APPARMOR_DENIED",
            "&sa",
            "NULL"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/audit.c",
          "lines": "111-116",
          "snippet": "void aa_audit_msg(int type, struct common_audit_data *sa,\n\t\t  void (*cb) (struct audit_buffer *, void *))\n{\n\taad(sa)->type = type;\n\tcommon_lsm_audit(sa, audit_pre, cb);\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/socket.h>\n#include <linux/audit.h>\n\nvoid aa_audit_msg(int type, struct common_audit_data *sa,\n\t\t  void (*cb) (struct audit_buffer *, void *))\n{\n\taad(sa)->type = type;\n\tcommon_lsm_audit(sa, audit_pre, cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "largs"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_change_profile",
          "args": [
            "args",
            "(AA_CHANGE_ONEXEC |\n\t\t\t\t\t\t\t AA_CHANGE_STACK)"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "aa_change_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "1186-1317",
          "snippet": "int aa_change_profile(const char *fqname, int flags)\n{\n\tstruct aa_label *label, *new = NULL, *target = NULL;\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tconst char *info = NULL;\n\tconst char *auditname = fqname;\t\t/* retain leading & if stack */\n\tbool stack = flags & AA_CHANGE_STACK;\n\tint error = 0;\n\tchar *op;\n\tu32 request;\n\n\tif (!fqname || !*fqname) {\n\t\tAA_DEBUG(\"no profile name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & AA_CHANGE_ONEXEC) {\n\t\trequest = AA_MAY_ONEXEC;\n\t\tif (stack)\n\t\t\top = OP_STACK_ONEXEC;\n\t\telse\n\t\t\top = OP_CHANGE_ONEXEC;\n\t} else {\n\t\trequest = AA_MAY_CHANGE_PROFILE;\n\t\tif (stack)\n\t\t\top = OP_STACK;\n\t\telse\n\t\t\top = OP_CHANGE_PROFILE;\n\t}\n\n\tlabel = aa_get_current_label();\n\n\tif (*fqname == '&') {\n\t\tstack = true;\n\t\t/* don't have label_parse() do stacking */\n\t\tfqname++;\n\t}\n\ttarget = aa_label_parse(label, fqname, GFP_KERNEL, true, false);\n\tif (IS_ERR(target)) {\n\t\tstruct aa_profile *tprofile;\n\n\t\tinfo = \"label not found\";\n\t\terror = PTR_ERR(target);\n\t\ttarget = NULL;\n\t\t/*\n\t\t * TODO: fixme using labels_profile is not right - do profile\n\t\t * per complain profile\n\t\t */\n\t\tif ((flags & AA_CHANGE_TEST) ||\n\t\t    !COMPLAIN_MODE(labels_profile(label)))\n\t\t\tgoto audit;\n\t\t/* released below */\n\t\ttprofile = aa_new_null_profile(labels_profile(label), false,\n\t\t\t\t\t       fqname, GFP_KERNEL);\n\t\tif (!tprofile) {\n\t\t\tinfo = \"failed null profile create\";\n\t\t\terror = -ENOMEM;\n\t\t\tgoto audit;\n\t\t}\n\t\ttarget = &tprofile->label;\n\t\tgoto check;\n\t}\n\n\t/*\n\t * self directed transitions only apply to current policy ns\n\t * TODO: currently requiring perms for stacking and straight change\n\t *       stacking doesn't strictly need this. Determine how much\n\t *       we want to loosen this restriction for stacking\n\t *\n\t * if (!stack) {\n\t */\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\tchange_profile_perms_wrapper(op, auditname,\n\t\t\t\t\t\t     profile, target, stack,\n\t\t\t\t\t\t     request, &perms));\n\tif (error)\n\t\t/* auditing done in change_profile_perms_wrapper */\n\t\tgoto out;\n\n\t/* } */\n\ncheck:\n\t/* check if tracing task is allowed to trace target domain */\n\terror = may_change_ptraced_domain(target, &info);\n\tif (error && !fn_for_each_in_ns(label, profile,\n\t\t\t\t\tCOMPLAIN_MODE(profile)))\n\t\tgoto audit;\n\n\t/* TODO: add permission check to allow this\n\t * if ((flags & AA_CHANGE_ONEXEC) && !current_is_single_threaded()) {\n\t *      info = \"not a single threaded task\";\n\t *      error = -EACCES;\n\t *      goto audit;\n\t * }\n\t */\n\tif (flags & AA_CHANGE_TEST)\n\t\tgoto out;\n\n\tif (!(flags & AA_CHANGE_ONEXEC)) {\n\t\t/* only transition profiles in the current ns */\n\t\tif (stack)\n\t\t\tnew = aa_label_merge(label, target, GFP_KERNEL);\n\t\telse\n\t\t\tnew = fn_label_build_in_ns(label, profile, GFP_KERNEL,\n\t\t\t\t\taa_get_label(target),\n\t\t\t\t\taa_get_label(&profile->label));\n\t\tif (IS_ERR_OR_NULL(new)) {\n\t\t\tinfo = \"failed to build target label\";\n\t\t\terror = PTR_ERR(new);\n\t\t\tnew = NULL;\n\t\t\tperms.allow = 0;\n\t\t\tgoto audit;\n\t\t}\n\t\terror = aa_replace_current_label(new);\n\t} else\n\t\t/* full transition will be built in exec path */\n\t\terror = aa_set_current_onexec(target, stack);\n\naudit:\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\taa_audit_file(profile, &perms, op, request, auditname,\n\t\t\t\t      NULL, new ? new : target,\n\t\t\t\t      GLOBAL_ROOT_UID, info, error));\n\nout:\n\taa_put_label(new);\n\taa_put_label(target);\n\taa_put_label(label);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nint aa_change_profile(const char *fqname, int flags)\n{\n\tstruct aa_label *label, *new = NULL, *target = NULL;\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tconst char *info = NULL;\n\tconst char *auditname = fqname;\t\t/* retain leading & if stack */\n\tbool stack = flags & AA_CHANGE_STACK;\n\tint error = 0;\n\tchar *op;\n\tu32 request;\n\n\tif (!fqname || !*fqname) {\n\t\tAA_DEBUG(\"no profile name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & AA_CHANGE_ONEXEC) {\n\t\trequest = AA_MAY_ONEXEC;\n\t\tif (stack)\n\t\t\top = OP_STACK_ONEXEC;\n\t\telse\n\t\t\top = OP_CHANGE_ONEXEC;\n\t} else {\n\t\trequest = AA_MAY_CHANGE_PROFILE;\n\t\tif (stack)\n\t\t\top = OP_STACK;\n\t\telse\n\t\t\top = OP_CHANGE_PROFILE;\n\t}\n\n\tlabel = aa_get_current_label();\n\n\tif (*fqname == '&') {\n\t\tstack = true;\n\t\t/* don't have label_parse() do stacking */\n\t\tfqname++;\n\t}\n\ttarget = aa_label_parse(label, fqname, GFP_KERNEL, true, false);\n\tif (IS_ERR(target)) {\n\t\tstruct aa_profile *tprofile;\n\n\t\tinfo = \"label not found\";\n\t\terror = PTR_ERR(target);\n\t\ttarget = NULL;\n\t\t/*\n\t\t * TODO: fixme using labels_profile is not right - do profile\n\t\t * per complain profile\n\t\t */\n\t\tif ((flags & AA_CHANGE_TEST) ||\n\t\t    !COMPLAIN_MODE(labels_profile(label)))\n\t\t\tgoto audit;\n\t\t/* released below */\n\t\ttprofile = aa_new_null_profile(labels_profile(label), false,\n\t\t\t\t\t       fqname, GFP_KERNEL);\n\t\tif (!tprofile) {\n\t\t\tinfo = \"failed null profile create\";\n\t\t\terror = -ENOMEM;\n\t\t\tgoto audit;\n\t\t}\n\t\ttarget = &tprofile->label;\n\t\tgoto check;\n\t}\n\n\t/*\n\t * self directed transitions only apply to current policy ns\n\t * TODO: currently requiring perms for stacking and straight change\n\t *       stacking doesn't strictly need this. Determine how much\n\t *       we want to loosen this restriction for stacking\n\t *\n\t * if (!stack) {\n\t */\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\tchange_profile_perms_wrapper(op, auditname,\n\t\t\t\t\t\t     profile, target, stack,\n\t\t\t\t\t\t     request, &perms));\n\tif (error)\n\t\t/* auditing done in change_profile_perms_wrapper */\n\t\tgoto out;\n\n\t/* } */\n\ncheck:\n\t/* check if tracing task is allowed to trace target domain */\n\terror = may_change_ptraced_domain(target, &info);\n\tif (error && !fn_for_each_in_ns(label, profile,\n\t\t\t\t\tCOMPLAIN_MODE(profile)))\n\t\tgoto audit;\n\n\t/* TODO: add permission check to allow this\n\t * if ((flags & AA_CHANGE_ONEXEC) && !current_is_single_threaded()) {\n\t *      info = \"not a single threaded task\";\n\t *      error = -EACCES;\n\t *      goto audit;\n\t * }\n\t */\n\tif (flags & AA_CHANGE_TEST)\n\t\tgoto out;\n\n\tif (!(flags & AA_CHANGE_ONEXEC)) {\n\t\t/* only transition profiles in the current ns */\n\t\tif (stack)\n\t\t\tnew = aa_label_merge(label, target, GFP_KERNEL);\n\t\telse\n\t\t\tnew = fn_label_build_in_ns(label, profile, GFP_KERNEL,\n\t\t\t\t\taa_get_label(target),\n\t\t\t\t\taa_get_label(&profile->label));\n\t\tif (IS_ERR_OR_NULL(new)) {\n\t\t\tinfo = \"failed to build target label\";\n\t\t\terror = PTR_ERR(new);\n\t\t\tnew = NULL;\n\t\t\tperms.allow = 0;\n\t\t\tgoto audit;\n\t\t}\n\t\terror = aa_replace_current_label(new);\n\t} else\n\t\t/* full transition will be built in exec path */\n\t\terror = aa_set_current_onexec(target, stack);\n\naudit:\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\taa_audit_file(profile, &perms, op, request, auditname,\n\t\t\t\t      NULL, new ? new : target,\n\t\t\t\t      GLOBAL_ROOT_UID, info, error));\n\nout:\n\taa_put_label(new);\n\taa_put_label(target);\n\taa_put_label(label);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "command",
            "\"stack\""
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "command",
            "\"exec\""
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"exec\""
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "command",
            "\"stack\""
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "command",
            "\"permprofile\""
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "command",
            "\"changeprofile\""
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_setprocattr_changehat",
          "args": [
            "args",
            "arg_size",
            "AA_CHANGE_TEST"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "aa_setprocattr_changehat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/procattr.c",
          "lines": "106-142",
          "snippet": "int aa_setprocattr_changehat(char *args, size_t size, int flags)\n{\n\tchar *hat;\n\tu64 token;\n\tconst char *hats[16];\t\t/* current hard limit on # of names */\n\tint count = 0;\n\n\that = split_token_from_name(OP_CHANGE_HAT, args, &token);\n\tif (IS_ERR(hat))\n\t\treturn PTR_ERR(hat);\n\n\tif (!hat && !token) {\n\t\tAA_ERROR(\"change_hat: Invalid input, NULL hat and NULL magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hat) {\n\t\t/* set up hat name vector, args guaranteed null terminated\n\t\t * at args[size] by setprocattr.\n\t\t *\n\t\t * If there are multiple hat names in the buffer each is\n\t\t * separated by a \\0.  Ie. userspace writes them pre tokenized\n\t\t */\n\t\tchar *end = args + size;\n\t\tfor (count = 0; (hat < end) && count < 16; ++count) {\n\t\t\tchar *next = hat + strlen(hat) + 1;\n\t\t\thats[count] = hat;\n\t\t\tAA_DEBUG(\"%s: (pid %d) Magic 0x%llx count %d hat '%s'\\n\"\n\t\t\t\t , __func__, current->pid, token, count, hat);\n\t\t\that = next;\n\t\t}\n\t} else\n\t\tAA_DEBUG(\"%s: (pid %d) Magic 0x%llx count %d Hat '%s'\\n\",\n\t\t\t __func__, current->pid, token, count, \"<NULL>\");\n\n\treturn aa_change_hat(hats, count, token, flags);\n}",
          "includes": [
            "#include \"include/procattr.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/procattr.h\"\n#include \"include/domain.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n\nint aa_setprocattr_changehat(char *args, size_t size, int flags)\n{\n\tchar *hat;\n\tu64 token;\n\tconst char *hats[16];\t\t/* current hard limit on # of names */\n\tint count = 0;\n\n\that = split_token_from_name(OP_CHANGE_HAT, args, &token);\n\tif (IS_ERR(hat))\n\t\treturn PTR_ERR(hat);\n\n\tif (!hat && !token) {\n\t\tAA_ERROR(\"change_hat: Invalid input, NULL hat and NULL magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hat) {\n\t\t/* set up hat name vector, args guaranteed null terminated\n\t\t * at args[size] by setprocattr.\n\t\t *\n\t\t * If there are multiple hat names in the buffer each is\n\t\t * separated by a \\0.  Ie. userspace writes them pre tokenized\n\t\t */\n\t\tchar *end = args + size;\n\t\tfor (count = 0; (hat < end) && count < 16; ++count) {\n\t\t\tchar *next = hat + strlen(hat) + 1;\n\t\t\thats[count] = hat;\n\t\t\tAA_DEBUG(\"%s: (pid %d) Magic 0x%llx count %d hat '%s'\\n\"\n\t\t\t\t , __func__, current->pid, token, count, hat);\n\t\t\that = next;\n\t\t}\n\t} else\n\t\tAA_DEBUG(\"%s: (pid %d) Magic 0x%llx count %d Hat '%s'\\n\",\n\t\t\t __func__, current->pid, token, count, \"<NULL>\");\n\n\treturn aa_change_hat(hats, count, token, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "command",
            "\"permhat\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "command",
            "\"changehat\""
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"current\""
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "args"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&args",
            "\" \""
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strim",
          "args": [
            "args"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "args",
            "value",
            "size"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size + 1",
            "GFP_KERNEL"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_AUDIT_DATA",
          "args": [
            "sa",
            "LSM_AUDIT_DATA_NONE",
            "OP_SETPROCATTR"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_setprocattr(const char *name, void *value,\n\t\t\t\tsize_t size)\n{\n\tchar *command, *largs = NULL, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SETPROCATTR);\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\t/* AppArmor requires that the buffer must be null terminated atm */\n\tif (args[size - 1] != '\\0') {\n\t\t/* null terminate */\n\t\tlargs = args = kmalloc(size + 1, GFP_KERNEL);\n\t\tif (!args)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(args, value, size);\n\t\targs[size] = '\\0';\n\t}\n\n\terror = -EINVAL;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\tgoto out;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\tgoto out;\n\n\targ_size = size - (args - (largs ? largs : (char *) value));\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_CHANGE_NOFLAGS);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_CHANGE_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_change_profile(args, AA_CHANGE_NOFLAGS);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_change_profile(args, AA_CHANGE_TEST);\n\t\t} else if (strcmp(command, \"stack\") == 0) {\n\t\t\terror = aa_change_profile(args, AA_CHANGE_STACK);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_change_profile(args, AA_CHANGE_ONEXEC);\n\t\telse if (strcmp(command, \"stack\") == 0)\n\t\t\terror = aa_change_profile(args, (AA_CHANGE_ONEXEC |\n\t\t\t\t\t\t\t AA_CHANGE_STACK));\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\tgoto fail;\n\n\tif (!error)\n\t\terror = size;\nout:\n\tkfree(largs);\n\treturn error;\n\nfail:\n\taad(&sa)->label = begin_current_label_crit_section();\n\taad(&sa)->info = name;\n\taad(&sa)->error = error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\tend_current_label_crit_section(aad(&sa)->label);\n\tgoto out;\n}"
  },
  {
    "function_name": "apparmor_getprocattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "574-599",
    "snippet": "static int apparmor_getprocattr(struct task_struct *task, char *name,\n\t\t\t\tchar **value)\n{\n\tint error = -ENOENT;\n\t/* released below */\n\tconst struct cred *cred = get_task_cred(task);\n\tstruct aa_task_ctx *ctx = cred_ctx(cred);\n\tstruct aa_label *label = NULL;\n\n\tif (strcmp(name, \"current\") == 0)\n\t\tlabel = aa_get_newest_label(ctx->label);\n\telse if (strcmp(name, \"prev\") == 0  && ctx->previous)\n\t\tlabel = aa_get_newest_label(ctx->previous);\n\telse if (strcmp(name, \"exec\") == 0 && ctx->onexec)\n\t\tlabel = aa_get_newest_label(ctx->onexec);\n\telse\n\t\terror = -EINVAL;\n\n\tif (label)\n\t\terror = aa_getprocattr(label, value);\n\n\taa_put_label(label);\n\tput_cred(cred);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "cred"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_getprocattr",
          "args": [
            "label",
            "value"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "aa_getprocattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/procattr.c",
          "lines": "37-72",
          "snippet": "int aa_getprocattr(struct aa_label *label, char **string)\n{\n\tstruct aa_ns *ns = labels_ns(label);\n\tstruct aa_ns *current_ns = aa_get_current_ns();\n\tint len;\n\n\tif (!aa_ns_visible(current_ns, ns, true)) {\n\t\taa_put_ns(current_ns);\n\t\treturn -EACCES;\n\t}\n\n\tlen = aa_label_snxprint(NULL, 0, current_ns, label,\n\t\t\t\tFLAG_SHOW_MODE | FLAG_VIEW_SUBNS |\n\t\t\t\tFLAG_HIDDEN_UNCONFINED);\n\tAA_BUG(len < 0);\n\n\t*string = kmalloc(len + 2, GFP_KERNEL);\n\tif (!*string) {\n\t\taa_put_ns(current_ns);\n\t\treturn -ENOMEM;\n\t}\n\n\tlen = aa_label_snxprint(*string, len + 2, current_ns, label,\n\t\t\t\tFLAG_SHOW_MODE | FLAG_VIEW_SUBNS |\n\t\t\t\tFLAG_HIDDEN_UNCONFINED);\n\tif (len < 0) {\n\t\taa_put_ns(current_ns);\n\t\treturn len;\n\t}\n\n\t(*string)[len] = '\\n';\n\t(*string)[len + 1] = 0;\n\n\taa_put_ns(current_ns);\n\treturn len + 1;\n}",
          "includes": [
            "#include \"include/procattr.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/procattr.h\"\n#include \"include/domain.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n\nint aa_getprocattr(struct aa_label *label, char **string)\n{\n\tstruct aa_ns *ns = labels_ns(label);\n\tstruct aa_ns *current_ns = aa_get_current_ns();\n\tint len;\n\n\tif (!aa_ns_visible(current_ns, ns, true)) {\n\t\taa_put_ns(current_ns);\n\t\treturn -EACCES;\n\t}\n\n\tlen = aa_label_snxprint(NULL, 0, current_ns, label,\n\t\t\t\tFLAG_SHOW_MODE | FLAG_VIEW_SUBNS |\n\t\t\t\tFLAG_HIDDEN_UNCONFINED);\n\tAA_BUG(len < 0);\n\n\t*string = kmalloc(len + 2, GFP_KERNEL);\n\tif (!*string) {\n\t\taa_put_ns(current_ns);\n\t\treturn -ENOMEM;\n\t}\n\n\tlen = aa_label_snxprint(*string, len + 2, current_ns, label,\n\t\t\t\tFLAG_SHOW_MODE | FLAG_VIEW_SUBNS |\n\t\t\t\tFLAG_HIDDEN_UNCONFINED);\n\tif (len < 0) {\n\t\taa_put_ns(current_ns);\n\t\treturn len;\n\t}\n\n\t(*string)[len] = '\\n';\n\t(*string)[len + 1] = 0;\n\n\taa_put_ns(current_ns);\n\treturn len + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_newest_label",
          "args": [
            "ctx->onexec"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "393-414",
          "snippet": "static inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"exec\""
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"prev\""
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"current\""
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "cred"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_cred",
          "args": [
            "task"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_getprocattr(struct task_struct *task, char *name,\n\t\t\t\tchar **value)\n{\n\tint error = -ENOENT;\n\t/* released below */\n\tconst struct cred *cred = get_task_cred(task);\n\tstruct aa_task_ctx *ctx = cred_ctx(cred);\n\tstruct aa_label *label = NULL;\n\n\tif (strcmp(name, \"current\") == 0)\n\t\tlabel = aa_get_newest_label(ctx->label);\n\telse if (strcmp(name, \"prev\") == 0  && ctx->previous)\n\t\tlabel = aa_get_newest_label(ctx->previous);\n\telse if (strcmp(name, \"exec\") == 0 && ctx->onexec)\n\t\tlabel = aa_get_newest_label(ctx->onexec);\n\telse\n\t\terror = -EINVAL;\n\n\tif (label)\n\t\terror = aa_getprocattr(label, value);\n\n\taa_put_label(label);\n\tput_cred(cred);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_sb_pivotroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "560-572",
    "snippet": "static int apparmor_sb_pivotroot(const struct path *old_path,\n\t\t\t\t const struct path *new_path)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tlabel = aa_get_current_label();\n\tif (!unconfined(label))\n\t\terror = aa_pivotroot(label, old_path, new_path);\n\taa_put_label(label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_pivotroot",
          "args": [
            "label",
            "old_path",
            "new_path"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "aa_pivotroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "651-695",
          "snippet": "int aa_pivotroot(struct aa_label *label, const struct path *old_path,\n\t\t const struct path *new_path)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *target = NULL;\n\tchar *old_buffer = NULL, *new_buffer = NULL, *info = NULL;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!old_path);\n\tAA_BUG(!new_path);\n\n\tget_buffers(old_buffer, new_buffer);\n\ttarget = fn_label_build(label, profile, GFP_ATOMIC,\n\t\t\tbuild_pivotroot(profile, new_path, new_buffer,\n\t\t\t\t\told_path, old_buffer));\n\tif (!target) {\n\t\tinfo = \"label build failed\";\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t} else if (!IS_ERR(target)) {\n\t\terror = aa_replace_current_label(target);\n\t\tif (error) {\n\t\t\t/* TODO: audit target */\n\t\t\taa_put_label(target);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\t/* already audited error */\n\t\terror = PTR_ERR(target);\nout:\n\tput_buffers(old_buffer, new_buffer);\n\n\treturn error;\n\nfail:\n\t/* TODO: add back in auditing of new_name and old_name */\n\terror = fn_for_each(label, profile,\n\t\t\taudit_mount(profile, OP_PIVOTROOT, NULL /*new_name */,\n\t\t\t\t    NULL /* old_name */,\n\t\t\t\t    NULL, NULL,\n\t\t\t\t    0, NULL, AA_MAY_PIVOTROOT, &nullperms, info,\n\t\t\t\t    error));\n\tgoto out;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_pivotroot(struct aa_label *label, const struct path *old_path,\n\t\t const struct path *new_path)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *target = NULL;\n\tchar *old_buffer = NULL, *new_buffer = NULL, *info = NULL;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!old_path);\n\tAA_BUG(!new_path);\n\n\tget_buffers(old_buffer, new_buffer);\n\ttarget = fn_label_build(label, profile, GFP_ATOMIC,\n\t\t\tbuild_pivotroot(profile, new_path, new_buffer,\n\t\t\t\t\told_path, old_buffer));\n\tif (!target) {\n\t\tinfo = \"label build failed\";\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t} else if (!IS_ERR(target)) {\n\t\terror = aa_replace_current_label(target);\n\t\tif (error) {\n\t\t\t/* TODO: audit target */\n\t\t\taa_put_label(target);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\t/* already audited error */\n\t\terror = PTR_ERR(target);\nout:\n\tput_buffers(old_buffer, new_buffer);\n\n\treturn error;\n\nfail:\n\t/* TODO: add back in auditing of new_name and old_name */\n\terror = fn_for_each(label, profile,\n\t\t\taudit_mount(profile, OP_PIVOTROOT, NULL /*new_name */,\n\t\t\t\t    NULL /* old_name */,\n\t\t\t\t    NULL, NULL,\n\t\t\t\t    0, NULL, AA_MAY_PIVOTROOT, &nullperms, info,\n\t\t\t\t    error));\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "label"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_current_label",
          "args": [],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_current_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "131-138",
          "snippet": "static inline struct aa_label *aa_get_current_label(void)\n{\n\tstruct aa_label *l = aa_current_raw_label();\n\n\tif (label_is_stale(l))\n\t\treturn aa_get_newest_label(l);\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *aa_get_current_label(void)\n{\n\tstruct aa_label *l = aa_current_raw_label();\n\n\tif (label_is_stale(l))\n\t\treturn aa_get_newest_label(l);\n\treturn aa_get_label(l);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_sb_pivotroot(const struct path *old_path,\n\t\t\t\t const struct path *new_path)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tlabel = aa_get_current_label();\n\tif (!unconfined(label))\n\t\terror = aa_pivotroot(label, old_path, new_path);\n\taa_put_label(label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_sb_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "547-558",
    "snippet": "static int apparmor_sb_umount(struct vfsmount *mnt, int flags)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tlabel = __begin_current_label_crit_section();\n\tif (!unconfined(label))\n\t\terror = aa_umount(label, mnt, flags);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_umount",
          "args": [
            "label",
            "mnt",
            "flags"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "aa_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "578-594",
          "snippet": "int aa_umount(struct aa_label *label, struct vfsmount *mnt, int flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\tstruct path path = { .mnt = mnt, .dentry = mnt->mnt_root };\n\n\tAA_BUG(!label);\n\tAA_BUG(!mnt);\n\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_umount(profile, &path, buffer));\n\tput_buffers(buffer);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_umount(struct aa_label *label, struct vfsmount *mnt, int flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\tstruct path path = { .mnt = mnt, .dentry = mnt->mnt_root };\n\n\tAA_BUG(!label);\n\tAA_BUG(!mnt);\n\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_umount(profile, &path, buffer));\n\tput_buffers(buffer);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "label"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__begin_current_label_crit_section",
          "args": [],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "__begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "168-176",
          "snippet": "static inline struct aa_label *__begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label))\n\t\tlabel = aa_get_newest_label(label);\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *__begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label))\n\t\tlabel = aa_get_newest_label(label);\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_sb_umount(struct vfsmount *mnt, int flags)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tlabel = __begin_current_label_crit_section();\n\tif (!unconfined(label))\n\t\terror = aa_umount(label, mnt, flags);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_sb_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "515-545",
    "snippet": "static int apparmor_sb_mount(const char *dev_name, const struct path *path,\n\t\t\t     const char *type, unsigned long flags, void *data)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t/* Discard magic */\n\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)\n\t\tflags &= ~MS_MGC_MSK;\n\n\tflags &= ~AA_MS_IGNORE_MASK;\n\n\tlabel = __begin_current_label_crit_section();\n\tif (!unconfined(label)) {\n\t\tif (flags & MS_REMOUNT)\n\t\t\terror = aa_remount(label, path, flags, data);\n\t\telse if (flags & MS_BIND)\n\t\t\terror = aa_bind_mount(label, path, dev_name, flags);\n\t\telse if (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE |\n\t\t\t\t  MS_UNBINDABLE))\n\t\t\terror = aa_mount_change_type(label, path, flags);\n\t\telse if (flags & MS_MOVE)\n\t\t\terror = aa_move_mount(label, path, dev_name);\n\t\telse\n\t\t\terror = aa_new_mount(label, dev_name, path, type,\n\t\t\t\t\t     flags, data);\n\t}\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_new_mount",
          "args": [
            "label",
            "dev_name",
            "path",
            "type",
            "flags",
            "data"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "aa_new_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "498-548",
          "snippet": "int aa_new_mount(struct aa_label *label, const char *dev_name,\n\t\t const struct path *path, const char *type, unsigned long flags,\n\t\t void *data)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *dev_buffer = NULL;\n\tbool binary = true;\n\tint error;\n\tint requires_dev = 0;\n\tstruct path tmp_path, *dev_path = NULL;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (type) {\n\t\tstruct file_system_type *fstype;\n\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype)\n\t\t\treturn -ENODEV;\n\t\tbinary = fstype->fs_flags & FS_BINARY_MOUNTDATA;\n\t\trequires_dev = fstype->fs_flags & FS_REQUIRES_DEV;\n\t\tput_filesystem(fstype);\n\n\t\tif (requires_dev) {\n\t\t\tif (!dev_name || !*dev_name)\n\t\t\t\treturn -ENOENT;\n\n\t\t\terror = kern_path(dev_name, LOOKUP_FOLLOW, &tmp_path);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tdev_path = &tmp_path;\n\t\t}\n\t}\n\n\tget_buffers(buffer, dev_buffer);\n\tif (dev_path) {\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, dev_path, dev_buffer,\n\t\t\t\t  type, flags, data, binary));\n\t} else {\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt_path_str(profile, path, buffer, dev_name,\n\t\t\t\t\t   type, flags, data, binary, NULL));\n\t}\n\tput_buffers(buffer, dev_buffer);\n\tif (dev_path)\n\t\tpath_put(dev_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_new_mount(struct aa_label *label, const char *dev_name,\n\t\t const struct path *path, const char *type, unsigned long flags,\n\t\t void *data)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *dev_buffer = NULL;\n\tbool binary = true;\n\tint error;\n\tint requires_dev = 0;\n\tstruct path tmp_path, *dev_path = NULL;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (type) {\n\t\tstruct file_system_type *fstype;\n\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype)\n\t\t\treturn -ENODEV;\n\t\tbinary = fstype->fs_flags & FS_BINARY_MOUNTDATA;\n\t\trequires_dev = fstype->fs_flags & FS_REQUIRES_DEV;\n\t\tput_filesystem(fstype);\n\n\t\tif (requires_dev) {\n\t\t\tif (!dev_name || !*dev_name)\n\t\t\t\treturn -ENOENT;\n\n\t\t\terror = kern_path(dev_name, LOOKUP_FOLLOW, &tmp_path);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tdev_path = &tmp_path;\n\t\t}\n\t}\n\n\tget_buffers(buffer, dev_buffer);\n\tif (dev_path) {\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, dev_path, dev_buffer,\n\t\t\t\t  type, flags, data, binary));\n\t} else {\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt_path_str(profile, path, buffer, dev_name,\n\t\t\t\t\t   type, flags, data, binary, NULL));\n\t}\n\tput_buffers(buffer, dev_buffer);\n\tif (dev_path)\n\t\tpath_put(dev_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_move_mount",
          "args": [
            "label",
            "path",
            "dev_name"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "aa_move_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "470-496",
          "snippet": "int aa_move_mount(struct aa_label *label, const struct path *path,\n\t\t  const char *orig_name)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *old_buffer = NULL;\n\tstruct path old_path;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (!orig_name || !*orig_name)\n\t\treturn -EINVAL;\n\n\terror = kern_path(orig_name, LOOKUP_FOLLOW, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tget_buffers(buffer, old_buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, &old_path, old_buffer,\n\t\t\t\t  NULL, MS_MOVE, NULL, false));\n\tput_buffers(buffer, old_buffer);\n\tpath_put(&old_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_move_mount(struct aa_label *label, const struct path *path,\n\t\t  const char *orig_name)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *old_buffer = NULL;\n\tstruct path old_path;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (!orig_name || !*orig_name)\n\t\treturn -EINVAL;\n\n\terror = kern_path(orig_name, LOOKUP_FOLLOW, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tget_buffers(buffer, old_buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, &old_path, old_buffer,\n\t\t\t\t  NULL, MS_MOVE, NULL, false));\n\tput_buffers(buffer, old_buffer);\n\tpath_put(&old_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_mount_change_type",
          "args": [
            "label",
            "path",
            "flags"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "aa_mount_change_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "447-468",
          "snippet": "int aa_mount_change_type(struct aa_label *label, const struct path *path,\n\t\t\t unsigned long flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\t/* These are the flags allowed by do_change_type() */\n\tflags &= (MS_REC | MS_SILENT | MS_SHARED | MS_PRIVATE | MS_SLAVE |\n\t\t  MS_UNBINDABLE);\n\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, NULL, NULL, NULL,\n\t\t\t\t  flags, NULL, false));\n\tput_buffers(buffer);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_mount_change_type(struct aa_label *label, const struct path *path,\n\t\t\t unsigned long flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\t/* These are the flags allowed by do_change_type() */\n\tflags &= (MS_REC | MS_SILENT | MS_SHARED | MS_PRIVATE | MS_SLAVE |\n\t\t  MS_UNBINDABLE);\n\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, NULL, NULL, NULL,\n\t\t\t\t  flags, NULL, false));\n\tput_buffers(buffer);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_bind_mount",
          "args": [
            "label",
            "path",
            "dev_name",
            "flags"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "aa_bind_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "417-445",
          "snippet": "int aa_bind_mount(struct aa_label *label, const struct path *path,\n\t\t  const char *dev_name, unsigned long flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *old_buffer = NULL;\n\tstruct path old_path;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (!dev_name || !*dev_name)\n\t\treturn -EINVAL;\n\n\tflags &= MS_REC | MS_BIND;\n\n\terror = kern_path(dev_name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tget_buffers(buffer, old_buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, &old_path, old_buffer,\n\t\t\t\t  NULL, flags, NULL, false));\n\tput_buffers(buffer, old_buffer);\n\tpath_put(&old_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_bind_mount(struct aa_label *label, const struct path *path,\n\t\t  const char *dev_name, unsigned long flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *old_buffer = NULL;\n\tstruct path old_path;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (!dev_name || !*dev_name)\n\t\treturn -EINVAL;\n\n\tflags &= MS_REC | MS_BIND;\n\n\terror = kern_path(dev_name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tget_buffers(buffer, old_buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, &old_path, old_buffer,\n\t\t\t\t  NULL, flags, NULL, false));\n\tput_buffers(buffer, old_buffer);\n\tpath_put(&old_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_remount",
          "args": [
            "label",
            "path",
            "flags",
            "data"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "aa_remount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "395-415",
          "snippet": "int aa_remount(struct aa_label *label, const struct path *path,\n\t       unsigned long flags, void *data)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tbool binary;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tbinary = path->dentry->d_sb->s_type->fs_flags & FS_BINARY_MOUNTDATA;\n\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, NULL, NULL, NULL,\n\t\t\t\t  flags, data, binary));\n\tput_buffers(buffer);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_remount(struct aa_label *label, const struct path *path,\n\t       unsigned long flags, void *data)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tbool binary;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tbinary = path->dentry->d_sb->s_type->fs_flags & FS_BINARY_MOUNTDATA;\n\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, NULL, NULL, NULL,\n\t\t\t\t  flags, data, binary));\n\tput_buffers(buffer);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "label"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__begin_current_label_crit_section",
          "args": [],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "__begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "168-176",
          "snippet": "static inline struct aa_label *__begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label))\n\t\tlabel = aa_get_newest_label(label);\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *__begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label))\n\t\tlabel = aa_get_newest_label(label);\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_sb_mount(const char *dev_name, const struct path *path,\n\t\t\t     const char *type, unsigned long flags, void *data)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t/* Discard magic */\n\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)\n\t\tflags &= ~MS_MGC_MSK;\n\n\tflags &= ~AA_MS_IGNORE_MASK;\n\n\tlabel = __begin_current_label_crit_section();\n\tif (!unconfined(label)) {\n\t\tif (flags & MS_REMOUNT)\n\t\t\terror = aa_remount(label, path, flags, data);\n\t\telse if (flags & MS_BIND)\n\t\t\terror = aa_bind_mount(label, path, dev_name, flags);\n\t\telse if (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE |\n\t\t\t\t  MS_UNBINDABLE))\n\t\t\terror = aa_mount_change_type(label, path, flags);\n\t\telse if (flags & MS_MOVE)\n\t\t\terror = aa_move_mount(label, path, dev_name);\n\t\telse\n\t\t\terror = aa_new_mount(label, dev_name, path, type,\n\t\t\t\t\t     flags, data);\n\t}\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_file_mprotect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "508-513",
    "snippet": "static int apparmor_file_mprotect(struct vm_area_struct *vma,\n\t\t\t\t  unsigned long reqprot, unsigned long prot)\n{\n\treturn common_mmap(OP_FMPROT, vma->vm_file, prot,\n\t\t\t   !(vma->vm_flags & VM_SHARED) ? MAP_PRIVATE : 0);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_mmap",
          "args": [
            "OP_FMPROT",
            "vma->vm_file",
            "prot",
            "!(vma->vm_flags & VM_SHARED) ? MAP_PRIVATE : 0"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "common_mmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "480-500",
          "snippet": "static int common_mmap(const char *op, struct file *file, unsigned long prot,\n\t\t       unsigned long flags)\n{\n\tint mask = 0;\n\n\tif (!file || !file_ctx(file))\n\t\treturn 0;\n\n\tif (prot & PROT_READ)\n\t\tmask |= MAY_READ;\n\t/*\n\t * Private mappings don't require write perms since they don't\n\t * write back to the files\n\t */\n\tif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\n\t\tmask |= MAY_WRITE;\n\tif (prot & PROT_EXEC)\n\t\tmask |= AA_EXEC_MMAP;\n\n\treturn common_file_perm(op, file, mask);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_mmap(const char *op, struct file *file, unsigned long prot,\n\t\t       unsigned long flags)\n{\n\tint mask = 0;\n\n\tif (!file || !file_ctx(file))\n\t\treturn 0;\n\n\tif (prot & PROT_READ)\n\t\tmask |= MAY_READ;\n\t/*\n\t * Private mappings don't require write perms since they don't\n\t * write back to the files\n\t */\n\tif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\n\t\tmask |= MAY_WRITE;\n\tif (prot & PROT_EXEC)\n\t\tmask |= AA_EXEC_MMAP;\n\n\treturn common_file_perm(op, file, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_file_mprotect(struct vm_area_struct *vma,\n\t\t\t\t  unsigned long reqprot, unsigned long prot)\n{\n\treturn common_mmap(OP_FMPROT, vma->vm_file, prot,\n\t\t\t   !(vma->vm_flags & VM_SHARED) ? MAP_PRIVATE : 0);\n}"
  },
  {
    "function_name": "apparmor_mmap_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "502-506",
    "snippet": "static int apparmor_mmap_file(struct file *file, unsigned long reqprot,\n\t\t\t      unsigned long prot, unsigned long flags)\n{\n\treturn common_mmap(OP_FMMAP, file, prot, flags);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_mmap",
          "args": [
            "OP_FMMAP",
            "file",
            "prot",
            "flags"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "common_mmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "480-500",
          "snippet": "static int common_mmap(const char *op, struct file *file, unsigned long prot,\n\t\t       unsigned long flags)\n{\n\tint mask = 0;\n\n\tif (!file || !file_ctx(file))\n\t\treturn 0;\n\n\tif (prot & PROT_READ)\n\t\tmask |= MAY_READ;\n\t/*\n\t * Private mappings don't require write perms since they don't\n\t * write back to the files\n\t */\n\tif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\n\t\tmask |= MAY_WRITE;\n\tif (prot & PROT_EXEC)\n\t\tmask |= AA_EXEC_MMAP;\n\n\treturn common_file_perm(op, file, mask);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_mmap(const char *op, struct file *file, unsigned long prot,\n\t\t       unsigned long flags)\n{\n\tint mask = 0;\n\n\tif (!file || !file_ctx(file))\n\t\treturn 0;\n\n\tif (prot & PROT_READ)\n\t\tmask |= MAY_READ;\n\t/*\n\t * Private mappings don't require write perms since they don't\n\t * write back to the files\n\t */\n\tif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\n\t\tmask |= MAY_WRITE;\n\tif (prot & PROT_EXEC)\n\t\tmask |= AA_EXEC_MMAP;\n\n\treturn common_file_perm(op, file, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_mmap_file(struct file *file, unsigned long reqprot,\n\t\t\t      unsigned long prot, unsigned long flags)\n{\n\treturn common_mmap(OP_FMMAP, file, prot, flags);\n}"
  },
  {
    "function_name": "common_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "480-500",
    "snippet": "static int common_mmap(const char *op, struct file *file, unsigned long prot,\n\t\t       unsigned long flags)\n{\n\tint mask = 0;\n\n\tif (!file || !file_ctx(file))\n\t\treturn 0;\n\n\tif (prot & PROT_READ)\n\t\tmask |= MAY_READ;\n\t/*\n\t * Private mappings don't require write perms since they don't\n\t * write back to the files\n\t */\n\tif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\n\t\tmask |= MAY_WRITE;\n\tif (prot & PROT_EXEC)\n\t\tmask |= AA_EXEC_MMAP;\n\n\treturn common_file_perm(op, file, mask);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_file_perm",
          "args": [
            "op",
            "file",
            "mask"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "common_file_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "444-458",
          "snippet": "static int common_file_perm(const char *op, struct file *file, u32 mask)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t/* don't reaudit files closed during inheritance */\n\tif (file->f_path.dentry == aa_null.dentry)\n\t\treturn -EACCES;\n\n\tlabel = __begin_current_label_crit_section();\n\terror = aa_file_perm(op, label, file, mask);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_file_perm(const char *op, struct file *file, u32 mask)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t/* don't reaudit files closed during inheritance */\n\tif (file->f_path.dentry == aa_null.dentry)\n\t\treturn -EACCES;\n\n\tlabel = __begin_current_label_crit_section();\n\terror = aa_file_perm(op, label, file, mask);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_ctx",
          "args": [
            "file"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "aa_free_file_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/file.h",
          "lines": "72-78",
          "snippet": "static inline void aa_free_file_ctx(struct aa_file_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n\t\tkzfree(ctx);\n\t}\n}",
          "includes": [
            "#include \"perms.h\"",
            "#include \"match.h\"",
            "#include \"domain.h\"",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"perms.h\"\n#include \"match.h\"\n#include \"domain.h\"\n#include <linux/spinlock.h>\n\nstatic inline void aa_free_file_ctx(struct aa_file_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n\t\tkzfree(ctx);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_mmap(const char *op, struct file *file, unsigned long prot,\n\t\t       unsigned long flags)\n{\n\tint mask = 0;\n\n\tif (!file || !file_ctx(file))\n\t\treturn 0;\n\n\tif (prot & PROT_READ)\n\t\tmask |= MAY_READ;\n\t/*\n\t * Private mappings don't require write perms since they don't\n\t * write back to the files\n\t */\n\tif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\n\t\tmask |= MAY_WRITE;\n\tif (prot & PROT_EXEC)\n\t\tmask |= AA_EXEC_MMAP;\n\n\treturn common_file_perm(op, file, mask);\n}"
  },
  {
    "function_name": "apparmor_file_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "470-478",
    "snippet": "static int apparmor_file_lock(struct file *file, unsigned int cmd)\n{\n\tu32 mask = AA_MAY_LOCK;\n\n\tif (cmd == F_WRLCK)\n\t\tmask |= MAY_WRITE;\n\n\treturn common_file_perm(OP_FLOCK, file, mask);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_file_perm",
          "args": [
            "OP_FLOCK",
            "file",
            "mask"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "common_file_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "444-458",
          "snippet": "static int common_file_perm(const char *op, struct file *file, u32 mask)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t/* don't reaudit files closed during inheritance */\n\tif (file->f_path.dentry == aa_null.dentry)\n\t\treturn -EACCES;\n\n\tlabel = __begin_current_label_crit_section();\n\terror = aa_file_perm(op, label, file, mask);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_file_perm(const char *op, struct file *file, u32 mask)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t/* don't reaudit files closed during inheritance */\n\tif (file->f_path.dentry == aa_null.dentry)\n\t\treturn -EACCES;\n\n\tlabel = __begin_current_label_crit_section();\n\terror = aa_file_perm(op, label, file, mask);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_file_lock(struct file *file, unsigned int cmd)\n{\n\tu32 mask = AA_MAY_LOCK;\n\n\tif (cmd == F_WRLCK)\n\t\tmask |= MAY_WRITE;\n\n\treturn common_file_perm(OP_FLOCK, file, mask);\n}"
  },
  {
    "function_name": "apparmor_file_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "465-468",
    "snippet": "static int apparmor_file_permission(struct file *file, int mask)\n{\n\treturn common_file_perm(OP_FPERM, file, mask);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_file_perm",
          "args": [
            "OP_FPERM",
            "file",
            "mask"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "common_file_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "444-458",
          "snippet": "static int common_file_perm(const char *op, struct file *file, u32 mask)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t/* don't reaudit files closed during inheritance */\n\tif (file->f_path.dentry == aa_null.dentry)\n\t\treturn -EACCES;\n\n\tlabel = __begin_current_label_crit_section();\n\terror = aa_file_perm(op, label, file, mask);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_file_perm(const char *op, struct file *file, u32 mask)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t/* don't reaudit files closed during inheritance */\n\tif (file->f_path.dentry == aa_null.dentry)\n\t\treturn -EACCES;\n\n\tlabel = __begin_current_label_crit_section();\n\terror = aa_file_perm(op, label, file, mask);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_file_permission(struct file *file, int mask)\n{\n\treturn common_file_perm(OP_FPERM, file, mask);\n}"
  },
  {
    "function_name": "apparmor_file_receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "460-463",
    "snippet": "static int apparmor_file_receive(struct file *file)\n{\n\treturn common_file_perm(OP_FRECEIVE, file, aa_map_file_to_perms(file));\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_file_perm",
          "args": [
            "OP_FRECEIVE",
            "file",
            "aa_map_file_to_perms(file)"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "common_file_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "444-458",
          "snippet": "static int common_file_perm(const char *op, struct file *file, u32 mask)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t/* don't reaudit files closed during inheritance */\n\tif (file->f_path.dentry == aa_null.dentry)\n\t\treturn -EACCES;\n\n\tlabel = __begin_current_label_crit_section();\n\terror = aa_file_perm(op, label, file, mask);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_file_perm(const char *op, struct file *file, u32 mask)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t/* don't reaudit files closed during inheritance */\n\tif (file->f_path.dentry == aa_null.dentry)\n\t\treturn -EACCES;\n\n\tlabel = __begin_current_label_crit_section();\n\terror = aa_file_perm(op, label, file, mask);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_map_file_to_perms",
          "args": [
            "file"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "aa_map_file_to_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/file.h",
          "lines": "217-236",
          "snippet": "static inline u32 aa_map_file_to_perms(struct file *file)\n{\n\tint flags = file->f_flags;\n\tu32 perms = 0;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\tperms |= MAY_WRITE;\n\tif (file->f_mode & FMODE_READ)\n\t\tperms |= MAY_READ;\n\n\tif ((flags & O_APPEND) && (perms & MAY_WRITE))\n\t\tperms = (perms & ~MAY_WRITE) | MAY_APPEND;\n\t/* trunc implies write permission */\n\tif (flags & O_TRUNC)\n\t\tperms |= MAY_WRITE;\n\tif (flags & O_CREAT)\n\t\tperms |= AA_MAY_CREATE;\n\n\treturn perms;\n}",
          "includes": [
            "#include \"perms.h\"",
            "#include \"match.h\"",
            "#include \"domain.h\"",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"perms.h\"\n#include \"match.h\"\n#include \"domain.h\"\n#include <linux/spinlock.h>\n\nstatic inline u32 aa_map_file_to_perms(struct file *file)\n{\n\tint flags = file->f_flags;\n\tu32 perms = 0;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\tperms |= MAY_WRITE;\n\tif (file->f_mode & FMODE_READ)\n\t\tperms |= MAY_READ;\n\n\tif ((flags & O_APPEND) && (perms & MAY_WRITE))\n\t\tperms = (perms & ~MAY_WRITE) | MAY_APPEND;\n\t/* trunc implies write permission */\n\tif (flags & O_TRUNC)\n\t\tperms |= MAY_WRITE;\n\tif (flags & O_CREAT)\n\t\tperms |= AA_MAY_CREATE;\n\n\treturn perms;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_file_receive(struct file *file)\n{\n\treturn common_file_perm(OP_FRECEIVE, file, aa_map_file_to_perms(file));\n}"
  },
  {
    "function_name": "common_file_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "444-458",
    "snippet": "static int common_file_perm(const char *op, struct file *file, u32 mask)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t/* don't reaudit files closed during inheritance */\n\tif (file->f_path.dentry == aa_null.dentry)\n\t\treturn -EACCES;\n\n\tlabel = __begin_current_label_crit_section();\n\terror = aa_file_perm(op, label, file, mask);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_file_perm",
          "args": [
            "op",
            "label",
            "file",
            "mask"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "aa_file_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "572-611",
          "snippet": "int aa_file_perm(const char *op, struct aa_label *label, struct file *file,\n\t\t u32 request)\n{\n\tstruct aa_file_ctx *fctx;\n\tstruct aa_label *flabel;\n\tu32 denied;\n\tint error = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!file);\n\n\tfctx = file_ctx(file);\n\n\trcu_read_lock();\n\tflabel  = rcu_dereference(fctx->label);\n\tAA_BUG(!flabel);\n\n\t/* revalidate access, if task is unconfined, or the cached cred\n\t * doesn't match or if the request is for more permissions than\n\t * was granted.\n\t *\n\t * Note: the test for !unconfined(flabel) is to handle file\n\t *       delegation from unconfined tasks\n\t */\n\tdenied = request & ~fctx->allow;\n\tif (unconfined(label) || unconfined(flabel) ||\n\t    (!denied && aa_label_is_subset(flabel, label)))\n\t\tgoto done;\n\n\t/* TODO: label cross check */\n\n\tif (file->f_path.mnt && path_mediated_fs(file->f_path.dentry))\n\t\terror = __file_path_perm(op, label, flabel, file, request,\n\t\t\t\t\t denied);\n\ndone:\n\trcu_read_unlock();\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_file_perm(const char *op, struct aa_label *label, struct file *file,\n\t\t u32 request)\n{\n\tstruct aa_file_ctx *fctx;\n\tstruct aa_label *flabel;\n\tu32 denied;\n\tint error = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!file);\n\n\tfctx = file_ctx(file);\n\n\trcu_read_lock();\n\tflabel  = rcu_dereference(fctx->label);\n\tAA_BUG(!flabel);\n\n\t/* revalidate access, if task is unconfined, or the cached cred\n\t * doesn't match or if the request is for more permissions than\n\t * was granted.\n\t *\n\t * Note: the test for !unconfined(flabel) is to handle file\n\t *       delegation from unconfined tasks\n\t */\n\tdenied = request & ~fctx->allow;\n\tif (unconfined(label) || unconfined(flabel) ||\n\t    (!denied && aa_label_is_subset(flabel, label)))\n\t\tgoto done;\n\n\t/* TODO: label cross check */\n\n\tif (file->f_path.mnt && path_mediated_fs(file->f_path.dentry))\n\t\terror = __file_path_perm(op, label, flabel, file, request,\n\t\t\t\t\t denied);\n\ndone:\n\trcu_read_unlock();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__begin_current_label_crit_section",
          "args": [],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "__begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "168-176",
          "snippet": "static inline struct aa_label *__begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label))\n\t\tlabel = aa_get_newest_label(label);\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *__begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label))\n\t\tlabel = aa_get_newest_label(label);\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_file_perm(const char *op, struct file *file, u32 mask)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\t/* don't reaudit files closed during inheritance */\n\tif (file->f_path.dentry == aa_null.dentry)\n\t\treturn -EACCES;\n\n\tlabel = __begin_current_label_crit_section();\n\terror = aa_file_perm(op, label, file, mask);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_file_free_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "439-442",
    "snippet": "static void apparmor_file_free_security(struct file *file)\n{\n\taa_free_file_ctx(file_ctx(file));\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_free_file_ctx",
          "args": [
            "file_ctx(file)"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "aa_free_file_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/file.h",
          "lines": "72-78",
          "snippet": "static inline void aa_free_file_ctx(struct aa_file_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n\t\tkzfree(ctx);\n\t}\n}",
          "includes": [
            "#include \"perms.h\"",
            "#include \"match.h\"",
            "#include \"domain.h\"",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"perms.h\"\n#include \"match.h\"\n#include \"domain.h\"\n#include <linux/spinlock.h>\n\nstatic inline void aa_free_file_ctx(struct aa_file_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n\t\tkzfree(ctx);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic void apparmor_file_free_security(struct file *file)\n{\n\taa_free_file_ctx(file_ctx(file));\n}"
  },
  {
    "function_name": "apparmor_file_alloc_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "425-437",
    "snippet": "static int apparmor_file_alloc_security(struct file *file)\n{\n\tint error = 0;\n\n\t/* freed by apparmor_file_free_security */\n\tstruct aa_label *label = begin_current_label_crit_section();\n\tfile->f_security = aa_alloc_file_ctx(label, GFP_KERNEL);\n\tif (!file_ctx(file))\n\t\terror = -ENOMEM;\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_ctx",
          "args": [
            "file"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "aa_free_file_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/file.h",
          "lines": "72-78",
          "snippet": "static inline void aa_free_file_ctx(struct aa_file_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n\t\tkzfree(ctx);\n\t}\n}",
          "includes": [
            "#include \"perms.h\"",
            "#include \"match.h\"",
            "#include \"domain.h\"",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"perms.h\"\n#include \"match.h\"\n#include \"domain.h\"\n#include <linux/spinlock.h>\n\nstatic inline void aa_free_file_ctx(struct aa_file_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n\t\tkzfree(ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_alloc_file_ctx",
          "args": [
            "label",
            "GFP_KERNEL"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "aa_alloc_file_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/file.h",
          "lines": "55-66",
          "snippet": "static inline struct aa_file_ctx *aa_alloc_file_ctx(struct aa_label *label,\n\t\t\t\t\t\t    gfp_t gfp)\n{\n\tstruct aa_file_ctx *ctx;\n\n\tctx = kzalloc(sizeof(struct aa_file_ctx), gfp);\n\tif (ctx) {\n\t\tspin_lock_init(&ctx->lock);\n\t\trcu_assign_pointer(ctx->label, aa_get_label(label));\n\t}\n\treturn ctx;\n}",
          "includes": [
            "#include \"perms.h\"",
            "#include \"match.h\"",
            "#include \"domain.h\"",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"perms.h\"\n#include \"match.h\"\n#include \"domain.h\"\n#include <linux/spinlock.h>\n\nstatic inline struct aa_file_ctx *aa_alloc_file_ctx(struct aa_label *label,\n\t\t\t\t\t\t    gfp_t gfp)\n{\n\tstruct aa_file_ctx *ctx;\n\n\tctx = kzalloc(sizeof(struct aa_file_ctx), gfp);\n\tif (ctx) {\n\t\tspin_lock_init(&ctx->lock);\n\t\trcu_assign_pointer(ctx->label, aa_get_label(label));\n\t}\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_file_alloc_security(struct file *file)\n{\n\tint error = 0;\n\n\t/* freed by apparmor_file_free_security */\n\tstruct aa_label *label = begin_current_label_crit_section();\n\tfile->f_security = aa_alloc_file_ctx(label, GFP_KERNEL);\n\tif (!file_ctx(file))\n\t\terror = -ENOMEM;\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "391-423",
    "snippet": "static int apparmor_file_open(struct file *file, const struct cred *cred)\n{\n\tstruct aa_file_ctx *fctx = file_ctx(file);\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tif (!path_mediated_fs(file->f_path.dentry))\n\t\treturn 0;\n\n\t/* If in exec, permission is handled by bprm hooks.\n\t * Cache permissions granted by the previous exec check, with\n\t * implicit read and executable mmap which are required to\n\t * actually execute the image.\n\t */\n\tif (current->in_execve) {\n\t\tfctx->allow = MAY_EXEC | MAY_READ | AA_EXEC_MMAP;\n\t\treturn 0;\n\t}\n\n\tlabel = aa_get_newest_cred_label(cred);\n\tif (!unconfined(label)) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tstruct path_cond cond = { inode->i_uid, inode->i_mode };\n\n\t\terror = aa_path_perm(OP_OPEN, label, &file->f_path, 0,\n\t\t\t\t     aa_map_file_to_perms(file), &cond);\n\t\t/* todo cache full allowed permissions set and state */\n\t\tfctx->allow = aa_map_file_to_perms(file);\n\t}\n\taa_put_label(label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_map_file_to_perms",
          "args": [
            "file"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "aa_map_file_to_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/file.h",
          "lines": "217-236",
          "snippet": "static inline u32 aa_map_file_to_perms(struct file *file)\n{\n\tint flags = file->f_flags;\n\tu32 perms = 0;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\tperms |= MAY_WRITE;\n\tif (file->f_mode & FMODE_READ)\n\t\tperms |= MAY_READ;\n\n\tif ((flags & O_APPEND) && (perms & MAY_WRITE))\n\t\tperms = (perms & ~MAY_WRITE) | MAY_APPEND;\n\t/* trunc implies write permission */\n\tif (flags & O_TRUNC)\n\t\tperms |= MAY_WRITE;\n\tif (flags & O_CREAT)\n\t\tperms |= AA_MAY_CREATE;\n\n\treturn perms;\n}",
          "includes": [
            "#include \"perms.h\"",
            "#include \"match.h\"",
            "#include \"domain.h\"",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"perms.h\"\n#include \"match.h\"\n#include \"domain.h\"\n#include <linux/spinlock.h>\n\nstatic inline u32 aa_map_file_to_perms(struct file *file)\n{\n\tint flags = file->f_flags;\n\tu32 perms = 0;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\tperms |= MAY_WRITE;\n\tif (file->f_mode & FMODE_READ)\n\t\tperms |= MAY_READ;\n\n\tif ((flags & O_APPEND) && (perms & MAY_WRITE))\n\t\tperms = (perms & ~MAY_WRITE) | MAY_APPEND;\n\t/* trunc implies write permission */\n\tif (flags & O_TRUNC)\n\t\tperms |= MAY_WRITE;\n\tif (flags & O_CREAT)\n\t\tperms |= AA_MAY_CREATE;\n\n\treturn perms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_path_perm",
          "args": [
            "OP_OPEN",
            "label",
            "&file->f_path",
            "0",
            "aa_map_file_to_perms(file)",
            "&cond"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "aa_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "326-345",
          "snippet": "int aa_path_perm(const char *op, struct aa_label *label,\n\t\t const struct path *path, int flags, u32 request,\n\t\t struct path_cond *cond)\n{\n\tstruct aa_perms perms = {};\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tflags |= PATH_DELEGATE_DELETED | (S_ISDIR(cond->mode) ? PATH_IS_DIR :\n\t\t\t\t\t\t\t\t0);\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_perm(op, profile, path, buffer, request,\n\t\t\t\t\t  cond, flags, &perms));\n\n\tput_buffers(buffer);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_path_perm(const char *op, struct aa_label *label,\n\t\t const struct path *path, int flags, u32 request,\n\t\t struct path_cond *cond)\n{\n\tstruct aa_perms perms = {};\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tflags |= PATH_DELEGATE_DELETED | (S_ISDIR(cond->mode) ? PATH_IS_DIR :\n\t\t\t\t\t\t\t\t0);\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_perm(op, profile, path, buffer, request,\n\t\t\t\t\t  cond, flags, &perms));\n\n\tput_buffers(buffer);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "label"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_newest_cred_label",
          "args": [
            "cred"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_cred_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "80-83",
          "snippet": "static inline struct aa_label *aa_get_newest_cred_label(const struct cred *cred)\n{\n\treturn aa_get_newest_label(aa_cred_raw_label(cred));\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *aa_get_newest_cred_label(const struct cred *cred)\n{\n\treturn aa_get_newest_label(aa_cred_raw_label(cred));\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_mediated_fs",
          "args": [
            "file->f_path.dentry"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "path_mediated_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/lib.h",
          "lines": "87-90",
          "snippet": "static inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n\nstatic inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_ctx",
          "args": [
            "file"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "aa_free_file_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/file.h",
          "lines": "72-78",
          "snippet": "static inline void aa_free_file_ctx(struct aa_file_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n\t\tkzfree(ctx);\n\t}\n}",
          "includes": [
            "#include \"perms.h\"",
            "#include \"match.h\"",
            "#include \"domain.h\"",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"perms.h\"\n#include \"match.h\"\n#include \"domain.h\"\n#include <linux/spinlock.h>\n\nstatic inline void aa_free_file_ctx(struct aa_file_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n\t\tkzfree(ctx);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_file_open(struct file *file, const struct cred *cred)\n{\n\tstruct aa_file_ctx *fctx = file_ctx(file);\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tif (!path_mediated_fs(file->f_path.dentry))\n\t\treturn 0;\n\n\t/* If in exec, permission is handled by bprm hooks.\n\t * Cache permissions granted by the previous exec check, with\n\t * implicit read and executable mmap which are required to\n\t * actually execute the image.\n\t */\n\tif (current->in_execve) {\n\t\tfctx->allow = MAY_EXEC | MAY_READ | AA_EXEC_MMAP;\n\t\treturn 0;\n\t}\n\n\tlabel = aa_get_newest_cred_label(cred);\n\tif (!unconfined(label)) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tstruct path_cond cond = { inode->i_uid, inode->i_mode };\n\n\t\terror = aa_path_perm(OP_OPEN, label, &file->f_path, 0,\n\t\t\t\t     aa_map_file_to_perms(file), &cond);\n\t\t/* todo cache full allowed permissions set and state */\n\t\tfctx->allow = aa_map_file_to_perms(file);\n\t}\n\taa_put_label(label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_inode_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "386-389",
    "snippet": "static int apparmor_inode_getattr(const struct path *path)\n{\n\treturn common_perm_cond(OP_GETATTR, path, AA_MAY_GETATTR);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_perm_cond",
          "args": [
            "OP_GETATTR",
            "path",
            "AA_MAY_GETATTR"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "common_perm_cond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "214-224",
          "snippet": "static int common_perm_cond(const char *op, const struct path *path, u32 mask)\n{\n\tstruct path_cond cond = { d_backing_inode(path->dentry)->i_uid,\n\t\t\t\t  d_backing_inode(path->dentry)->i_mode\n\t};\n\n\tif (!path_mediated_fs(path->dentry))\n\t\treturn 0;\n\n\treturn common_perm(op, path, mask, &cond);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_cond(const char *op, const struct path *path, u32 mask)\n{\n\tstruct path_cond cond = { d_backing_inode(path->dentry)->i_uid,\n\t\t\t\t  d_backing_inode(path->dentry)->i_mode\n\t};\n\n\tif (!path_mediated_fs(path->dentry))\n\t\treturn 0;\n\n\treturn common_perm(op, path, mask, &cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_inode_getattr(const struct path *path)\n{\n\treturn common_perm_cond(OP_GETATTR, path, AA_MAY_GETATTR);\n}"
  },
  {
    "function_name": "apparmor_path_chown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "381-384",
    "snippet": "static int apparmor_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n{\n\treturn common_perm_cond(OP_CHOWN, path, AA_MAY_CHOWN);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_perm_cond",
          "args": [
            "OP_CHOWN",
            "path",
            "AA_MAY_CHOWN"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "common_perm_cond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "214-224",
          "snippet": "static int common_perm_cond(const char *op, const struct path *path, u32 mask)\n{\n\tstruct path_cond cond = { d_backing_inode(path->dentry)->i_uid,\n\t\t\t\t  d_backing_inode(path->dentry)->i_mode\n\t};\n\n\tif (!path_mediated_fs(path->dentry))\n\t\treturn 0;\n\n\treturn common_perm(op, path, mask, &cond);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_cond(const char *op, const struct path *path, u32 mask)\n{\n\tstruct path_cond cond = { d_backing_inode(path->dentry)->i_uid,\n\t\t\t\t  d_backing_inode(path->dentry)->i_mode\n\t};\n\n\tif (!path_mediated_fs(path->dentry))\n\t\treturn 0;\n\n\treturn common_perm(op, path, mask, &cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n{\n\treturn common_perm_cond(OP_CHOWN, path, AA_MAY_CHOWN);\n}"
  },
  {
    "function_name": "apparmor_path_chmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "376-379",
    "snippet": "static int apparmor_path_chmod(const struct path *path, umode_t mode)\n{\n\treturn common_perm_cond(OP_CHMOD, path, AA_MAY_CHMOD);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_perm_cond",
          "args": [
            "OP_CHMOD",
            "path",
            "AA_MAY_CHMOD"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "common_perm_cond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "214-224",
          "snippet": "static int common_perm_cond(const char *op, const struct path *path, u32 mask)\n{\n\tstruct path_cond cond = { d_backing_inode(path->dentry)->i_uid,\n\t\t\t\t  d_backing_inode(path->dentry)->i_mode\n\t};\n\n\tif (!path_mediated_fs(path->dentry))\n\t\treturn 0;\n\n\treturn common_perm(op, path, mask, &cond);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_cond(const char *op, const struct path *path, u32 mask)\n{\n\tstruct path_cond cond = { d_backing_inode(path->dentry)->i_uid,\n\t\t\t\t  d_backing_inode(path->dentry)->i_mode\n\t};\n\n\tif (!path_mediated_fs(path->dentry))\n\t\treturn 0;\n\n\treturn common_perm(op, path, mask, &cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_path_chmod(const struct path *path, umode_t mode)\n{\n\treturn common_perm_cond(OP_CHMOD, path, AA_MAY_CHMOD);\n}"
  },
  {
    "function_name": "apparmor_path_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "342-374",
    "snippet": "static int apparmor_path_rename(const struct path *old_dir, struct dentry *old_dentry,\n\t\t\t\tconst struct path *new_dir, struct dentry *new_dentry)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tif (!path_mediated_fs(old_dentry))\n\t\treturn 0;\n\n\tlabel = begin_current_label_crit_section();\n\tif (!unconfined(label)) {\n\t\tstruct path old_path = { .mnt = old_dir->mnt,\n\t\t\t\t\t .dentry = old_dentry };\n\t\tstruct path new_path = { .mnt = new_dir->mnt,\n\t\t\t\t\t .dentry = new_dentry };\n\t\tstruct path_cond cond = { d_backing_inode(old_dentry)->i_uid,\n\t\t\t\t\t  d_backing_inode(old_dentry)->i_mode\n\t\t};\n\n\t\terror = aa_path_perm(OP_RENAME_SRC, label, &old_path, 0,\n\t\t\t\t     MAY_READ | AA_MAY_GETATTR | MAY_WRITE |\n\t\t\t\t     AA_MAY_SETATTR | AA_MAY_DELETE,\n\t\t\t\t     &cond);\n\t\tif (!error)\n\t\t\terror = aa_path_perm(OP_RENAME_DEST, label, &new_path,\n\t\t\t\t\t     0, MAY_WRITE | AA_MAY_SETATTR |\n\t\t\t\t\t     AA_MAY_CREATE, &cond);\n\n\t}\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_path_perm",
          "args": [
            "OP_RENAME_DEST",
            "label",
            "&new_path",
            "0",
            "MAY_WRITE | AA_MAY_SETATTR |\n\t\t\t\t\t     AA_MAY_CREATE",
            "&cond"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "aa_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "326-345",
          "snippet": "int aa_path_perm(const char *op, struct aa_label *label,\n\t\t const struct path *path, int flags, u32 request,\n\t\t struct path_cond *cond)\n{\n\tstruct aa_perms perms = {};\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tflags |= PATH_DELEGATE_DELETED | (S_ISDIR(cond->mode) ? PATH_IS_DIR :\n\t\t\t\t\t\t\t\t0);\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_perm(op, profile, path, buffer, request,\n\t\t\t\t\t  cond, flags, &perms));\n\n\tput_buffers(buffer);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_path_perm(const char *op, struct aa_label *label,\n\t\t const struct path *path, int flags, u32 request,\n\t\t struct path_cond *cond)\n{\n\tstruct aa_perms perms = {};\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tflags |= PATH_DELEGATE_DELETED | (S_ISDIR(cond->mode) ? PATH_IS_DIR :\n\t\t\t\t\t\t\t\t0);\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_perm(op, profile, path, buffer, request,\n\t\t\t\t\t  cond, flags, &perms));\n\n\tput_buffers(buffer);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "old_dentry"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "old_dentry"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "label"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_mediated_fs",
          "args": [
            "old_dentry"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "path_mediated_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/lib.h",
          "lines": "87-90",
          "snippet": "static inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n\nstatic inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_path_rename(const struct path *old_dir, struct dentry *old_dentry,\n\t\t\t\tconst struct path *new_dir, struct dentry *new_dentry)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tif (!path_mediated_fs(old_dentry))\n\t\treturn 0;\n\n\tlabel = begin_current_label_crit_section();\n\tif (!unconfined(label)) {\n\t\tstruct path old_path = { .mnt = old_dir->mnt,\n\t\t\t\t\t .dentry = old_dentry };\n\t\tstruct path new_path = { .mnt = new_dir->mnt,\n\t\t\t\t\t .dentry = new_dentry };\n\t\tstruct path_cond cond = { d_backing_inode(old_dentry)->i_uid,\n\t\t\t\t\t  d_backing_inode(old_dentry)->i_mode\n\t\t};\n\n\t\terror = aa_path_perm(OP_RENAME_SRC, label, &old_path, 0,\n\t\t\t\t     MAY_READ | AA_MAY_GETATTR | MAY_WRITE |\n\t\t\t\t     AA_MAY_SETATTR | AA_MAY_DELETE,\n\t\t\t\t     &cond);\n\t\tif (!error)\n\t\t\terror = aa_path_perm(OP_RENAME_DEST, label, &new_path,\n\t\t\t\t\t     0, MAY_WRITE | AA_MAY_SETATTR |\n\t\t\t\t\t     AA_MAY_CREATE, &cond);\n\n\t}\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_path_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "325-340",
    "snippet": "static int apparmor_path_link(struct dentry *old_dentry, const struct path *new_dir,\n\t\t\t      struct dentry *new_dentry)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tif (!path_mediated_fs(old_dentry))\n\t\treturn 0;\n\n\tlabel = begin_current_label_crit_section();\n\tif (!unconfined(label))\n\t\terror = aa_path_link(label, old_dentry, new_dir, new_dentry);\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_path_link",
          "args": [
            "label",
            "old_dentry",
            "new_dir",
            "new_dentry"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "aa_path_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "466-487",
          "snippet": "int aa_path_link(struct aa_label *label, struct dentry *old_dentry,\n\t\t const struct path *new_dir, struct dentry *new_dentry)\n{\n\tstruct path link = { .mnt = new_dir->mnt, .dentry = new_dentry };\n\tstruct path target = { .mnt = new_dir->mnt, .dentry = old_dentry };\n\tstruct path_cond cond = {\n\t\td_backing_inode(old_dentry)->i_uid,\n\t\td_backing_inode(old_dentry)->i_mode\n\t};\n\tchar *buffer = NULL, *buffer2 = NULL;\n\tstruct aa_profile *profile;\n\tint error;\n\n\t/* buffer freed below, lname is pointer in buffer */\n\tget_buffers(buffer, buffer2);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_link(profile, &link, buffer, &target,\n\t\t\t\t\t  buffer2, &cond));\n\tput_buffers(buffer, buffer2);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_path_link(struct aa_label *label, struct dentry *old_dentry,\n\t\t const struct path *new_dir, struct dentry *new_dentry)\n{\n\tstruct path link = { .mnt = new_dir->mnt, .dentry = new_dentry };\n\tstruct path target = { .mnt = new_dir->mnt, .dentry = old_dentry };\n\tstruct path_cond cond = {\n\t\td_backing_inode(old_dentry)->i_uid,\n\t\td_backing_inode(old_dentry)->i_mode\n\t};\n\tchar *buffer = NULL, *buffer2 = NULL;\n\tstruct aa_profile *profile;\n\tint error;\n\n\t/* buffer freed below, lname is pointer in buffer */\n\tget_buffers(buffer, buffer2);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_link(profile, &link, buffer, &target,\n\t\t\t\t\t  buffer2, &cond));\n\tput_buffers(buffer, buffer2);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "label"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_mediated_fs",
          "args": [
            "old_dentry"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "path_mediated_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/lib.h",
          "lines": "87-90",
          "snippet": "static inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n\nstatic inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_path_link(struct dentry *old_dentry, const struct path *new_dir,\n\t\t\t      struct dentry *new_dentry)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tif (!path_mediated_fs(old_dentry))\n\t\treturn 0;\n\n\tlabel = begin_current_label_crit_section();\n\tif (!unconfined(label))\n\t\terror = aa_path_link(label, old_dentry, new_dir, new_dentry);\n\tend_current_label_crit_section(label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_path_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "318-323",
    "snippet": "static int apparmor_path_symlink(const struct path *dir, struct dentry *dentry,\n\t\t\t\t const char *old_name)\n{\n\treturn common_perm_create(OP_SYMLINK, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFLNK);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_perm_create",
          "args": [
            "OP_SYMLINK",
            "dir",
            "dentry",
            "AA_MAY_CREATE",
            "S_IFLNK"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "common_perm_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "279-288",
          "snippet": "static int common_perm_create(const char *op, const struct path *dir,\n\t\t\t      struct dentry *dentry, u32 mask, umode_t mode)\n{\n\tstruct path_cond cond = { current_fsuid(), mode };\n\n\tif (!path_mediated_fs(dir->dentry))\n\t\treturn 0;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_create(const char *op, const struct path *dir,\n\t\t\t      struct dentry *dentry, u32 mask, umode_t mode)\n{\n\tstruct path_cond cond = { current_fsuid(), mode };\n\n\tif (!path_mediated_fs(dir->dentry))\n\t\treturn 0;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_path_symlink(const struct path *dir, struct dentry *dentry,\n\t\t\t\t const char *old_name)\n{\n\treturn common_perm_create(OP_SYMLINK, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFLNK);\n}"
  },
  {
    "function_name": "apparmor_path_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "313-316",
    "snippet": "static int apparmor_path_truncate(const struct path *path)\n{\n\treturn common_perm_cond(OP_TRUNC, path, MAY_WRITE | AA_MAY_SETATTR);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_perm_cond",
          "args": [
            "OP_TRUNC",
            "path",
            "MAY_WRITE | AA_MAY_SETATTR"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "common_perm_cond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "214-224",
          "snippet": "static int common_perm_cond(const char *op, const struct path *path, u32 mask)\n{\n\tstruct path_cond cond = { d_backing_inode(path->dentry)->i_uid,\n\t\t\t\t  d_backing_inode(path->dentry)->i_mode\n\t};\n\n\tif (!path_mediated_fs(path->dentry))\n\t\treturn 0;\n\n\treturn common_perm(op, path, mask, &cond);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_cond(const char *op, const struct path *path, u32 mask)\n{\n\tstruct path_cond cond = { d_backing_inode(path->dentry)->i_uid,\n\t\t\t\t  d_backing_inode(path->dentry)->i_mode\n\t};\n\n\tif (!path_mediated_fs(path->dentry))\n\t\treturn 0;\n\n\treturn common_perm(op, path, mask, &cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_path_truncate(const struct path *path)\n{\n\treturn common_perm_cond(OP_TRUNC, path, MAY_WRITE | AA_MAY_SETATTR);\n}"
  },
  {
    "function_name": "apparmor_path_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "307-311",
    "snippet": "static int apparmor_path_mknod(const struct path *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, unsigned int dev)\n{\n\treturn common_perm_create(OP_MKNOD, dir, dentry, AA_MAY_CREATE, mode);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_perm_create",
          "args": [
            "OP_MKNOD",
            "dir",
            "dentry",
            "AA_MAY_CREATE",
            "mode"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "common_perm_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "279-288",
          "snippet": "static int common_perm_create(const char *op, const struct path *dir,\n\t\t\t      struct dentry *dentry, u32 mask, umode_t mode)\n{\n\tstruct path_cond cond = { current_fsuid(), mode };\n\n\tif (!path_mediated_fs(dir->dentry))\n\t\treturn 0;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_create(const char *op, const struct path *dir,\n\t\t\t      struct dentry *dentry, u32 mask, umode_t mode)\n{\n\tstruct path_cond cond = { current_fsuid(), mode };\n\n\tif (!path_mediated_fs(dir->dentry))\n\t\treturn 0;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_path_mknod(const struct path *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, unsigned int dev)\n{\n\treturn common_perm_create(OP_MKNOD, dir, dentry, AA_MAY_CREATE, mode);\n}"
  },
  {
    "function_name": "apparmor_path_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "302-305",
    "snippet": "static int apparmor_path_rmdir(const struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_RMDIR, dir, dentry, AA_MAY_DELETE);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_perm_rm",
          "args": [
            "OP_RMDIR",
            "dir",
            "dentry",
            "AA_MAY_DELETE"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "common_perm_rm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "254-267",
          "snippet": "static int common_perm_rm(const char *op, const struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct path_cond cond = { };\n\n\tif (!inode || !path_mediated_fs(dentry))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_rm(const char *op, const struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct path_cond cond = { };\n\n\tif (!inode || !path_mediated_fs(dentry))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_path_rmdir(const struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_RMDIR, dir, dentry, AA_MAY_DELETE);\n}"
  },
  {
    "function_name": "apparmor_path_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "295-300",
    "snippet": "static int apparmor_path_mkdir(const struct path *dir, struct dentry *dentry,\n\t\t\t       umode_t mode)\n{\n\treturn common_perm_create(OP_MKDIR, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFDIR);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_perm_create",
          "args": [
            "OP_MKDIR",
            "dir",
            "dentry",
            "AA_MAY_CREATE",
            "S_IFDIR"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "common_perm_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "279-288",
          "snippet": "static int common_perm_create(const char *op, const struct path *dir,\n\t\t\t      struct dentry *dentry, u32 mask, umode_t mode)\n{\n\tstruct path_cond cond = { current_fsuid(), mode };\n\n\tif (!path_mediated_fs(dir->dentry))\n\t\treturn 0;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_create(const char *op, const struct path *dir,\n\t\t\t      struct dentry *dentry, u32 mask, umode_t mode)\n{\n\tstruct path_cond cond = { current_fsuid(), mode };\n\n\tif (!path_mediated_fs(dir->dentry))\n\t\treturn 0;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_path_mkdir(const struct path *dir, struct dentry *dentry,\n\t\t\t       umode_t mode)\n{\n\treturn common_perm_create(OP_MKDIR, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFDIR);\n}"
  },
  {
    "function_name": "apparmor_path_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "290-293",
    "snippet": "static int apparmor_path_unlink(const struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_UNLINK, dir, dentry, AA_MAY_DELETE);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_perm_rm",
          "args": [
            "OP_UNLINK",
            "dir",
            "dentry",
            "AA_MAY_DELETE"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "common_perm_rm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "254-267",
          "snippet": "static int common_perm_rm(const char *op, const struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct path_cond cond = { };\n\n\tif (!inode || !path_mediated_fs(dentry))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_rm(const char *op, const struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct path_cond cond = { };\n\n\tif (!inode || !path_mediated_fs(dentry))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_path_unlink(const struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_UNLINK, dir, dentry, AA_MAY_DELETE);\n}"
  },
  {
    "function_name": "common_perm_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "279-288",
    "snippet": "static int common_perm_create(const char *op, const struct path *dir,\n\t\t\t      struct dentry *dentry, u32 mask, umode_t mode)\n{\n\tstruct path_cond cond = { current_fsuid(), mode };\n\n\tif (!path_mediated_fs(dir->dentry))\n\t\treturn 0;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_perm_dir_dentry",
          "args": [
            "op",
            "dir",
            "dentry",
            "mask",
            "&cond"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "common_perm_dir_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "236-243",
          "snippet": "static int common_perm_dir_dentry(const char *op, const struct path *dir,\n\t\t\t\t  struct dentry *dentry, u32 mask,\n\t\t\t\t  struct path_cond *cond)\n{\n\tstruct path path = { .mnt = dir->mnt, .dentry = dentry };\n\n\treturn common_perm(op, &path, mask, cond);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_dir_dentry(const char *op, const struct path *dir,\n\t\t\t\t  struct dentry *dentry, u32 mask,\n\t\t\t\t  struct path_cond *cond)\n{\n\tstruct path path = { .mnt = dir->mnt, .dentry = dentry };\n\n\treturn common_perm(op, &path, mask, cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_mediated_fs",
          "args": [
            "dir->dentry"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "path_mediated_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/lib.h",
          "lines": "87-90",
          "snippet": "static inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n\nstatic inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_create(const char *op, const struct path *dir,\n\t\t\t      struct dentry *dentry, u32 mask, umode_t mode)\n{\n\tstruct path_cond cond = { current_fsuid(), mode };\n\n\tif (!path_mediated_fs(dir->dentry))\n\t\treturn 0;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}"
  },
  {
    "function_name": "common_perm_rm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "254-267",
    "snippet": "static int common_perm_rm(const char *op, const struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct path_cond cond = { };\n\n\tif (!inode || !path_mediated_fs(dentry))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_perm_dir_dentry",
          "args": [
            "op",
            "dir",
            "dentry",
            "mask",
            "&cond"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "common_perm_dir_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "236-243",
          "snippet": "static int common_perm_dir_dentry(const char *op, const struct path *dir,\n\t\t\t\t  struct dentry *dentry, u32 mask,\n\t\t\t\t  struct path_cond *cond)\n{\n\tstruct path path = { .mnt = dir->mnt, .dentry = dentry };\n\n\treturn common_perm(op, &path, mask, cond);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_dir_dentry(const char *op, const struct path *dir,\n\t\t\t\t  struct dentry *dentry, u32 mask,\n\t\t\t\t  struct path_cond *cond)\n{\n\tstruct path path = { .mnt = dir->mnt, .dentry = dentry };\n\n\treturn common_perm(op, &path, mask, cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_mediated_fs",
          "args": [
            "dentry"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "path_mediated_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/lib.h",
          "lines": "87-90",
          "snippet": "static inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n\nstatic inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_rm(const char *op, const struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct path_cond cond = { };\n\n\tif (!inode || !path_mediated_fs(dentry))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}"
  },
  {
    "function_name": "common_perm_dir_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "236-243",
    "snippet": "static int common_perm_dir_dentry(const char *op, const struct path *dir,\n\t\t\t\t  struct dentry *dentry, u32 mask,\n\t\t\t\t  struct path_cond *cond)\n{\n\tstruct path path = { .mnt = dir->mnt, .dentry = dentry };\n\n\treturn common_perm(op, &path, mask, cond);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_perm",
          "args": [
            "op",
            "&path",
            "mask",
            "cond"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "common_perm_rm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "254-267",
          "snippet": "static int common_perm_rm(const char *op, const struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct path_cond cond = { };\n\n\tif (!inode || !path_mediated_fs(dentry))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_rm(const char *op, const struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct path_cond cond = { };\n\n\tif (!inode || !path_mediated_fs(dentry))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_dir_dentry(const char *op, const struct path *dir,\n\t\t\t\t  struct dentry *dentry, u32 mask,\n\t\t\t\t  struct path_cond *cond)\n{\n\tstruct path path = { .mnt = dir->mnt, .dentry = dentry };\n\n\treturn common_perm(op, &path, mask, cond);\n}"
  },
  {
    "function_name": "common_perm_cond",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "214-224",
    "snippet": "static int common_perm_cond(const char *op, const struct path *path, u32 mask)\n{\n\tstruct path_cond cond = { d_backing_inode(path->dentry)->i_uid,\n\t\t\t\t  d_backing_inode(path->dentry)->i_mode\n\t};\n\n\tif (!path_mediated_fs(path->dentry))\n\t\treturn 0;\n\n\treturn common_perm(op, path, mask, &cond);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_perm",
          "args": [
            "op",
            "path",
            "mask",
            "&cond"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "common_perm_rm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
          "lines": "254-267",
          "snippet": "static int common_perm_rm(const char *op, const struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct path_cond cond = { };\n\n\tif (!inode || !path_mediated_fs(dentry))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}",
          "includes": [
            "#include \"include/mount.h\"",
            "#include \"include/procattr.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/path.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <net/sock.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/audit.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ctype.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_rm(const char *op, const struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct path_cond cond = { };\n\n\tif (!inode || !path_mediated_fs(dentry))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_mediated_fs",
          "args": [
            "path->dentry"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "path_mediated_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/lib.h",
          "lines": "87-90",
          "snippet": "static inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n\nstatic inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "path->dentry"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "path->dentry"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm_cond(const char *op, const struct path *path, u32 mask)\n{\n\tstruct path_cond cond = { d_backing_inode(path->dentry)->i_uid,\n\t\t\t\t  d_backing_inode(path->dentry)->i_mode\n\t};\n\n\tif (!path_mediated_fs(path->dentry))\n\t\treturn 0;\n\n\treturn common_perm(op, path, mask, &cond);\n}"
  },
  {
    "function_name": "common_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "192-204",
    "snippet": "static int common_perm(const char *op, const struct path *path, u32 mask,\n\t\t       struct path_cond *cond)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tlabel = __begin_current_label_crit_section();\n\tif (!unconfined(label))\n\t\terror = aa_path_perm(op, label, path, 0, mask, cond);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__end_current_label_crit_section",
          "args": [
            "label"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_path_perm",
          "args": [
            "op",
            "label",
            "path",
            "0",
            "mask",
            "cond"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "aa_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "326-345",
          "snippet": "int aa_path_perm(const char *op, struct aa_label *label,\n\t\t const struct path *path, int flags, u32 request,\n\t\t struct path_cond *cond)\n{\n\tstruct aa_perms perms = {};\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tflags |= PATH_DELEGATE_DELETED | (S_ISDIR(cond->mode) ? PATH_IS_DIR :\n\t\t\t\t\t\t\t\t0);\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_perm(op, profile, path, buffer, request,\n\t\t\t\t\t  cond, flags, &perms));\n\n\tput_buffers(buffer);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_path_perm(const char *op, struct aa_label *label,\n\t\t const struct path *path, int flags, u32 request,\n\t\t struct path_cond *cond)\n{\n\tstruct aa_perms perms = {};\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tflags |= PATH_DELEGATE_DELETED | (S_ISDIR(cond->mode) ? PATH_IS_DIR :\n\t\t\t\t\t\t\t\t0);\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_perm(op, profile, path, buffer, request,\n\t\t\t\t\t  cond, flags, &perms));\n\n\tput_buffers(buffer);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "label"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__begin_current_label_crit_section",
          "args": [],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "__begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "168-176",
          "snippet": "static inline struct aa_label *__begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label))\n\t\tlabel = aa_get_newest_label(label);\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *__begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label))\n\t\tlabel = aa_get_newest_label(label);\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int common_perm(const char *op, const struct path *path, u32 mask,\n\t\t       struct path_cond *cond)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tlabel = __begin_current_label_crit_section();\n\tif (!unconfined(label))\n\t\terror = aa_path_perm(op, label, path, 0, mask, cond);\n\t__end_current_label_crit_section(label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_capable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "169-181",
    "snippet": "static int apparmor_capable(const struct cred *cred, struct user_namespace *ns,\n\t\t\t    int cap, int audit)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tlabel = aa_get_newest_cred_label(cred);\n\tif (!unconfined(label))\n\t\terror = aa_capable(label, cap, audit);\n\taa_put_label(label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_capable",
          "args": [
            "label",
            "cap",
            "audit"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "aa_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/capability.c",
          "lines": "151-162",
          "snippet": "int aa_capable(struct aa_label *label, int cap, int audit)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_CAP, OP_CAPABLE);\n\n\tsa.u.cap = cap;\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_capable(profile, cap, audit, &sa));\n\n\treturn error;\n}",
          "includes": [
            "#include \"capability_names.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/security.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability_names.h\"\n#include \"include/audit.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/security.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nint aa_capable(struct aa_label *label, int cap, int audit)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_CAP, OP_CAPABLE);\n\n\tsa.u.cap = cap;\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_capable(profile, cap, audit, &sa));\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "label"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_newest_cred_label",
          "args": [
            "cred"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_cred_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "80-83",
          "snippet": "static inline struct aa_label *aa_get_newest_cred_label(const struct cred *cred)\n{\n\treturn aa_get_newest_label(aa_cred_raw_label(cred));\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *aa_get_newest_cred_label(const struct cred *cred)\n{\n\treturn aa_get_newest_label(aa_cred_raw_label(cred));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_capable(const struct cred *cred, struct user_namespace *ns,\n\t\t\t    int cap, int audit)\n{\n\tstruct aa_label *label;\n\tint error = 0;\n\n\tlabel = aa_get_newest_cred_label(cred);\n\tif (!unconfined(label))\n\t\terror = aa_capable(label, cap, audit);\n\taa_put_label(label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_capget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "136-167",
    "snippet": "static int apparmor_capget(struct task_struct *target, kernel_cap_t *effective,\n\t\t\t   kernel_cap_t *inheritable, kernel_cap_t *permitted)\n{\n\tstruct aa_label *label;\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\tcred = __task_cred(target);\n\tlabel = aa_get_newest_cred_label(cred);\n\n\t/*\n\t * cap_capget is stacked ahead of this and will\n\t * initialize effective and permitted.\n\t */\n\tif (!unconfined(label)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each_confined(i, label, profile) {\n\t\t\tif (COMPLAIN_MODE(profile))\n\t\t\t\tcontinue;\n\t\t\t*effective = cap_intersect(*effective,\n\t\t\t\t\t\t   profile->caps.allow);\n\t\t\t*permitted = cap_intersect(*permitted,\n\t\t\t\t\t\t   profile->caps.allow);\n\t\t}\n\t}\n\trcu_read_unlock();\n\taa_put_label(label);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_intersect",
          "args": [
            "*permitted",
            "profile->caps.allow"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_intersect",
          "args": [
            "*effective",
            "profile->caps.allow"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPLAIN_MODE",
          "args": [
            "profile"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_for_each_confined",
          "args": [
            "i",
            "label",
            "profile"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "label"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_newest_cred_label",
          "args": [
            "cred"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_cred_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "80-83",
          "snippet": "static inline struct aa_label *aa_get_newest_cred_label(const struct cred *cred)\n{\n\treturn aa_get_newest_label(aa_cred_raw_label(cred));\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *aa_get_newest_cred_label(const struct cred *cred)\n{\n\treturn aa_get_newest_label(aa_cred_raw_label(cred));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "target"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_capget(struct task_struct *target, kernel_cap_t *effective,\n\t\t\t   kernel_cap_t *inheritable, kernel_cap_t *permitted)\n{\n\tstruct aa_label *label;\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\tcred = __task_cred(target);\n\tlabel = aa_get_newest_cred_label(cred);\n\n\t/*\n\t * cap_capget is stacked ahead of this and will\n\t * initialize effective and permitted.\n\t */\n\tif (!unconfined(label)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each_confined(i, label, profile) {\n\t\t\tif (COMPLAIN_MODE(profile))\n\t\t\t\tcontinue;\n\t\t\t*effective = cap_intersect(*effective,\n\t\t\t\t\t\t   profile->caps.allow);\n\t\t\t*permitted = cap_intersect(*permitted,\n\t\t\t\t\t\t   profile->caps.allow);\n\t\t}\n\t}\n\trcu_read_unlock();\n\taa_put_label(label);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "apparmor_ptrace_traceme",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "121-133",
    "snippet": "static int apparmor_ptrace_traceme(struct task_struct *parent)\n{\n\tstruct aa_label *tracer, *tracee;\n\tint error;\n\n\ttracee = begin_current_label_crit_section();\n\ttracer = aa_get_task_label(parent);\n\terror = aa_may_ptrace(tracer, tracee, AA_PTRACE_TRACE);\n\taa_put_label(tracer);\n\tend_current_label_crit_section(tracee);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "tracee"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "tracer"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_may_ptrace",
          "args": [
            "tracer",
            "tracee",
            "AA_PTRACE_TRACE"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "aa_may_ptrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
          "lines": "115-122",
          "snippet": "int aa_may_ptrace(struct aa_label *tracer, struct aa_label *tracee,\n\t\t  u32 request)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_PTRACE);\n\n\treturn xcheck_labels_profiles(tracer, tracee, cross_ptrace_perm,\n\t\t\t\t      request, &sa);\n}",
          "includes": [
            "#include \"include/sig_names.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nint aa_may_ptrace(struct aa_label *tracer, struct aa_label *tracee,\n\t\t  u32 request)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_PTRACE);\n\n\treturn xcheck_labels_profiles(tracer, tracee, cross_ptrace_perm,\n\t\t\t\t      request, &sa);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_task_label",
          "args": [
            "parent"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_task_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "77-86",
          "snippet": "struct aa_label *aa_get_task_label(struct task_struct *task)\n{\n\tstruct aa_label *p;\n\n\trcu_read_lock();\n\tp = aa_get_newest_label(__aa_task_raw_label(task));\n\trcu_read_unlock();\n\n\treturn p;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nstruct aa_label *aa_get_task_label(struct task_struct *task)\n{\n\tstruct aa_label *p;\n\n\trcu_read_lock();\n\tp = aa_get_newest_label(__aa_task_raw_label(task));\n\trcu_read_unlock();\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_ptrace_traceme(struct task_struct *parent)\n{\n\tstruct aa_label *tracer, *tracee;\n\tint error;\n\n\ttracee = begin_current_label_crit_section();\n\ttracer = aa_get_task_label(parent);\n\terror = aa_may_ptrace(tracer, tracee, AA_PTRACE_TRACE);\n\taa_put_label(tracer);\n\tend_current_label_crit_section(tracee);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_ptrace_access_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "105-119",
    "snippet": "static int apparmor_ptrace_access_check(struct task_struct *child,\n\t\t\t\t\tunsigned int mode)\n{\n\tstruct aa_label *tracer, *tracee;\n\tint error;\n\n\ttracer = begin_current_label_crit_section();\n\ttracee = aa_get_task_label(child);\n\terror = aa_may_ptrace(tracer, tracee,\n\t\t  mode == PTRACE_MODE_READ ? AA_PTRACE_READ : AA_PTRACE_TRACE);\n\taa_put_label(tracee);\n\tend_current_label_crit_section(tracer);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_current_label_crit_section",
          "args": [
            "tracer"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "end_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "150-154",
          "snippet": "static inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void end_current_label_crit_section(struct aa_label *label)\n{\n\tif (label != aa_current_raw_label())\n\t\taa_put_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "tracee"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_may_ptrace",
          "args": [
            "tracer",
            "tracee",
            "mode == PTRACE_MODE_READ ? AA_PTRACE_READ : AA_PTRACE_TRACE"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "aa_may_ptrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
          "lines": "115-122",
          "snippet": "int aa_may_ptrace(struct aa_label *tracer, struct aa_label *tracee,\n\t\t  u32 request)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_PTRACE);\n\n\treturn xcheck_labels_profiles(tracer, tracee, cross_ptrace_perm,\n\t\t\t\t      request, &sa);\n}",
          "includes": [
            "#include \"include/sig_names.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nint aa_may_ptrace(struct aa_label *tracer, struct aa_label *tracee,\n\t\t  u32 request)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_PTRACE);\n\n\treturn xcheck_labels_profiles(tracer, tracee, cross_ptrace_perm,\n\t\t\t\t      request, &sa);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_task_label",
          "args": [
            "child"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_task_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "77-86",
          "snippet": "struct aa_label *aa_get_task_label(struct task_struct *task)\n{\n\tstruct aa_label *p;\n\n\trcu_read_lock();\n\tp = aa_get_newest_label(__aa_task_raw_label(task));\n\trcu_read_unlock();\n\n\treturn p;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nstruct aa_label *aa_get_task_label(struct task_struct *task)\n{\n\tstruct aa_label *p;\n\n\trcu_read_lock();\n\tp = aa_get_newest_label(__aa_task_raw_label(task));\n\trcu_read_unlock();\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "begin_current_label_crit_section",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "begin_current_label_crit_section",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "190-202",
          "snippet": "static inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *begin_current_label_crit_section(void)\n{\n\tstruct aa_label *label = aa_current_raw_label();\n\n\tif (label_is_stale(label)) {\n\t\tlabel = aa_get_newest_label(label);\n\t\tif (aa_replace_current_label(label) == 0)\n\t\t\t/* task cred will keep the reference */\n\t\t\taa_put_label(label);\n\t}\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_ptrace_access_check(struct task_struct *child,\n\t\t\t\t\tunsigned int mode)\n{\n\tstruct aa_label *tracer, *tracee;\n\tint error;\n\n\ttracer = begin_current_label_crit_section();\n\ttracee = aa_get_task_label(child);\n\terror = aa_may_ptrace(tracer, tracee,\n\t\t  mode == PTRACE_MODE_READ ? AA_PTRACE_READ : AA_PTRACE_TRACE);\n\taa_put_label(tracee);\n\tend_current_label_crit_section(tracer);\n\n\treturn error;\n}"
  },
  {
    "function_name": "apparmor_cred_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "97-103",
    "snippet": "static void apparmor_cred_transfer(struct cred *new, const struct cred *old)\n{\n\tconst struct aa_task_ctx *old_ctx = cred_ctx(old);\n\tstruct aa_task_ctx *new_ctx = cred_ctx(new);\n\n\taa_dup_task_context(new_ctx, old_ctx);\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_dup_task_context",
          "args": [
            "new_ctx",
            "old_ctx"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dup_task_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "63-69",
          "snippet": "void aa_dup_task_context(struct aa_task_ctx *new, const struct aa_task_ctx *old)\n{\n\t*new = *old;\n\taa_get_label(new->label);\n\taa_get_label(new->previous);\n\taa_get_label(new->onexec);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nvoid aa_dup_task_context(struct aa_task_ctx *new, const struct aa_task_ctx *old)\n{\n\t*new = *old;\n\taa_get_label(new->label);\n\taa_get_label(new->previous);\n\taa_get_label(new->onexec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "new"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "old"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic void apparmor_cred_transfer(struct cred *new, const struct cred *old)\n{\n\tconst struct aa_task_ctx *old_ctx = cred_ctx(old);\n\tstruct aa_task_ctx *new_ctx = cred_ctx(new);\n\n\taa_dup_task_context(new_ctx, old_ctx);\n}"
  },
  {
    "function_name": "apparmor_cred_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "80-92",
    "snippet": "static int apparmor_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t\t gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_ctx *ctx = aa_alloc_task_context(gfp);\n\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\taa_dup_task_context(ctx, cred_ctx(old));\n\tcred_ctx(new) = ctx;\n\treturn 0;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "new"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_dup_task_context",
          "args": [
            "ctx",
            "cred_ctx(old)"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dup_task_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "63-69",
          "snippet": "void aa_dup_task_context(struct aa_task_ctx *new, const struct aa_task_ctx *old)\n{\n\t*new = *old;\n\taa_get_label(new->label);\n\taa_get_label(new->previous);\n\taa_get_label(new->onexec);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nvoid aa_dup_task_context(struct aa_task_ctx *new, const struct aa_task_ctx *old)\n{\n\t*new = *old;\n\taa_get_label(new->label);\n\taa_get_label(new->previous);\n\taa_get_label(new->onexec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "old"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_alloc_task_context",
          "args": [
            "gfp"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "aa_alloc_task_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "38-41",
          "snippet": "struct aa_task_ctx *aa_alloc_task_context(gfp_t flags)\n{\n\treturn kzalloc(sizeof(struct aa_task_ctx), flags);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nstruct aa_task_ctx *aa_alloc_task_context(gfp_t flags)\n{\n\treturn kzalloc(sizeof(struct aa_task_ctx), flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t\t gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_ctx *ctx = aa_alloc_task_context(gfp);\n\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\taa_dup_task_context(ctx, cred_ctx(old));\n\tcred_ctx(new) = ctx;\n\treturn 0;\n}"
  },
  {
    "function_name": "apparmor_cred_alloc_blank",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "65-75",
    "snippet": "static int apparmor_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_ctx *ctx = aa_alloc_task_context(gfp);\n\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tcred_ctx(cred) = ctx;\n\treturn 0;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "cred"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_alloc_task_context",
          "args": [
            "gfp"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "aa_alloc_task_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "38-41",
          "snippet": "struct aa_task_ctx *aa_alloc_task_context(gfp_t flags)\n{\n\treturn kzalloc(sizeof(struct aa_task_ctx), flags);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nstruct aa_task_ctx *aa_alloc_task_context(gfp_t flags)\n{\n\treturn kzalloc(sizeof(struct aa_task_ctx), flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic int apparmor_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_ctx *ctx = aa_alloc_task_context(gfp);\n\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tcred_ctx(cred) = ctx;\n\treturn 0;\n}"
  },
  {
    "function_name": "apparmor_cred_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lsm.c",
    "lines": "56-60",
    "snippet": "static void apparmor_cred_free(struct cred *cred)\n{\n\taa_free_task_context(cred_ctx(cred));\n\tcred_ctx(cred) = NULL;\n}",
    "includes": [
      "#include \"include/mount.h\"",
      "#include \"include/procattr.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/path.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/apparmor.h\"",
      "#include <net/sock.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/audit.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ctype.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "cred"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_free_task_context",
          "args": [
            "cred_ctx(cred)"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "aa_free_task_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "47-56",
          "snippet": "void aa_free_task_context(struct aa_task_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(ctx->label);\n\t\taa_put_label(ctx->previous);\n\t\taa_put_label(ctx->onexec);\n\n\t\tkzfree(ctx);\n\t}\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nvoid aa_free_task_context(struct aa_task_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(ctx->label);\n\t\taa_put_label(ctx->previous);\n\t\taa_put_label(ctx->onexec);\n\n\t\tkzfree(ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "cred"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/mount.h\"\n#include \"include/procattr.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/path.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <net/sock.h>\n#include <linux/kmemleak.h>\n#include <linux/user_namespace.h>\n#include <linux/audit.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/ptrace.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/lsm_hooks.h>\n\nstatic void apparmor_cred_free(struct cred *cred)\n{\n\taa_free_task_context(cred_ctx(cred));\n\tcred_ctx(cred) = NULL;\n}"
  }
]