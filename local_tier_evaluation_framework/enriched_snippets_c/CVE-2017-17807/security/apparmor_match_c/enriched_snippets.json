[
  {
    "function_name": "aa_dfa_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
    "lines": "429-459",
    "snippet": "unsigned int aa_dfa_next(struct aa_dfa *dfa, unsigned int state,\n\t\t\t  const char c)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int pos;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\n\t\tpos = base_idx(base[state]) + equiv[(u8) c];\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t} else {\n\t\t/* default is direct to next state */\n\t\tpos = base_idx(base[state]) + (u8) c;\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t}\n\n\treturn state;\n}",
    "includes": [
      "#include \"include/match.h\"",
      "#include \"include/lib.h\"",
      "#include <linux/kref.h>",
      "#include <linux/err.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "base_idx",
          "args": [
            "base[state]"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base_idx",
          "args": [
            "base[state]"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EQUIV_TABLE",
          "args": [
            "dfa"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_TABLE",
          "args": [
            "dfa"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_TABLE",
          "args": [
            "dfa"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BASE_TABLE",
          "args": [
            "dfa"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_TABLE",
          "args": [
            "dfa"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_next(struct aa_dfa *dfa, unsigned int state,\n\t\t\t  const char c)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int pos;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\n\t\tpos = base_idx(base[state]) + equiv[(u8) c];\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t} else {\n\t\t/* default is direct to next state */\n\t\tpos = base_idx(base[state]) + (u8) c;\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t}\n\n\treturn state;\n}"
  },
  {
    "function_name": "aa_dfa_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
    "lines": "381-417",
    "snippet": "unsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
    "includes": [
      "#include \"include/match.h\"",
      "#include \"include/lib.h\"",
      "#include <linux/kref.h>",
      "#include <linux/err.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "base_idx",
          "args": [
            "base[state]"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base_idx",
          "args": [
            "base[state]"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EQUIV_TABLE",
          "args": [
            "dfa"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_TABLE",
          "args": [
            "dfa"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_TABLE",
          "args": [
            "dfa"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BASE_TABLE",
          "args": [
            "dfa"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_TABLE",
          "args": [
            "dfa"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
  },
  {
    "function_name": "aa_dfa_match_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
    "lines": "331-367",
    "snippet": "unsigned int aa_dfa_match_len(struct aa_dfa *dfa, unsigned int start,\n\t\t\t      const char *str, int len)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
    "includes": [
      "#include \"include/match.h\"",
      "#include \"include/lib.h\"",
      "#include <linux/kref.h>",
      "#include <linux/err.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "base_idx",
          "args": [
            "base[state]"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base_idx",
          "args": [
            "base[state]"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EQUIV_TABLE",
          "args": [
            "dfa"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_TABLE",
          "args": [
            "dfa"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_TABLE",
          "args": [
            "dfa"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BASE_TABLE",
          "args": [
            "dfa"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_TABLE",
          "args": [
            "dfa"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match_len(struct aa_dfa *dfa, unsigned int start,\n\t\t\t      const char *str, int len)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
  },
  {
    "function_name": "aa_dfa_unpack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
    "lines": "234-313",
    "snippet": "struct aa_dfa *aa_dfa_unpack(void *blob, size_t size, int flags)\n{\n\tint hsize;\n\tint error = -ENOMEM;\n\tchar *data = blob;\n\tstruct table_header *table = NULL;\n\tstruct aa_dfa *dfa = kzalloc(sizeof(struct aa_dfa), GFP_KERNEL);\n\tif (!dfa)\n\t\tgoto fail;\n\n\tkref_init(&dfa->count);\n\n\terror = -EPROTO;\n\n\t/* get dfa table set header */\n\tif (size < sizeof(struct table_set_header))\n\t\tgoto fail;\n\n\tif (ntohl(*(__be32 *) data) != YYTH_MAGIC)\n\t\tgoto fail;\n\n\thsize = ntohl(*(__be32 *) (data + 4));\n\tif (size < hsize)\n\t\tgoto fail;\n\n\tdfa->flags = ntohs(*(__be16 *) (data + 12));\n\tdata += hsize;\n\tsize -= hsize;\n\n\twhile (size > 0) {\n\t\ttable = unpack_table(data, size);\n\t\tif (!table)\n\t\t\tgoto fail;\n\n\t\tswitch (table->td_id) {\n\t\tcase YYTD_ID_ACCEPT:\n\t\t\tif (!(table->td_flags & ACCEPT1_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_ACCEPT2:\n\t\t\tif (!(table->td_flags & ACCEPT2_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_BASE:\n\t\t\tif (table->td_flags != YYTD_DATA32)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_DEF:\n\t\tcase YYTD_ID_NXT:\n\t\tcase YYTD_ID_CHK:\n\t\t\tif (table->td_flags != YYTD_DATA16)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_EC:\n\t\t\tif (table->td_flags != YYTD_DATA8)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t\t/* check for duplicate table entry */\n\t\tif (dfa->tables[table->td_id])\n\t\t\tgoto fail;\n\t\tdfa->tables[table->td_id] = table;\n\t\tdata += table_size(table->td_lolen, table->td_flags);\n\t\tsize -= table_size(table->td_lolen, table->td_flags);\n\t\ttable = NULL;\n\t}\n\n\terror = verify_dfa(dfa, flags);\n\tif (error)\n\t\tgoto fail;\n\n\treturn dfa;\n\nfail:\n\tkvfree(table);\n\tdfa_free(dfa);\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"include/match.h\"",
      "#include \"include/lib.h\"",
      "#include <linux/kref.h>",
      "#include <linux/err.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfa_free",
          "args": [
            "dfa"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_free_kref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "216-220",
          "snippet": "void aa_dfa_free_kref(struct kref *kref)\n{\n\tstruct aa_dfa *dfa = container_of(kref, struct aa_dfa, count);\n\tdfa_free(dfa);\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nvoid aa_dfa_free_kref(struct kref *kref)\n{\n\tstruct aa_dfa *dfa = container_of(kref, struct aa_dfa, count);\n\tdfa_free(dfa);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "table"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_dfa",
          "args": [
            "dfa",
            "flags"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "verify_dfa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "131-191",
          "snippet": "static int verify_dfa(struct aa_dfa *dfa, int flags)\n{\n\tsize_t i, state_count, trans_count;\n\tint error = -EPROTO;\n\n\t/* check that required tables exist */\n\tif (!(dfa->tables[YYTD_ID_DEF] &&\n\t      dfa->tables[YYTD_ID_BASE] &&\n\t      dfa->tables[YYTD_ID_NXT] && dfa->tables[YYTD_ID_CHK]))\n\t\tgoto out;\n\n\t/* accept.size == default.size == base.size */\n\tstate_count = dfa->tables[YYTD_ID_BASE]->td_lolen;\n\tif (ACCEPT1_FLAGS(flags)) {\n\t\tif (!dfa->tables[YYTD_ID_ACCEPT])\n\t\t\tgoto out;\n\t\tif (state_count != dfa->tables[YYTD_ID_ACCEPT]->td_lolen)\n\t\t\tgoto out;\n\t}\n\tif (ACCEPT2_FLAGS(flags)) {\n\t\tif (!dfa->tables[YYTD_ID_ACCEPT2])\n\t\t\tgoto out;\n\t\tif (state_count != dfa->tables[YYTD_ID_ACCEPT2]->td_lolen)\n\t\t\tgoto out;\n\t}\n\tif (state_count != dfa->tables[YYTD_ID_DEF]->td_lolen)\n\t\tgoto out;\n\n\t/* next.size == chk.size */\n\ttrans_count = dfa->tables[YYTD_ID_NXT]->td_lolen;\n\tif (trans_count != dfa->tables[YYTD_ID_CHK]->td_lolen)\n\t\tgoto out;\n\n\t/* if equivalence classes then its table size must be 256 */\n\tif (dfa->tables[YYTD_ID_EC] &&\n\t    dfa->tables[YYTD_ID_EC]->td_lolen != 256)\n\t\tgoto out;\n\n\tif (flags & DFA_FLAG_VERIFY_STATES) {\n\t\tfor (i = 0; i < state_count; i++) {\n\t\t\tif (DEFAULT_TABLE(dfa)[i] >= state_count)\n\t\t\t\tgoto out;\n\t\t\tif (base_idx(BASE_TABLE(dfa)[i]) + 255 >= trans_count) {\n\t\t\t\tprintk(KERN_ERR \"AppArmor DFA next/check upper \"\n\t\t\t\t       \"bounds error\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < trans_count; i++) {\n\t\t\tif (NEXT_TABLE(dfa)[i] >= state_count)\n\t\t\t\tgoto out;\n\t\t\tif (CHECK_TABLE(dfa)[i] >= state_count)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\terror = 0;\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic int verify_dfa(struct aa_dfa *dfa, int flags)\n{\n\tsize_t i, state_count, trans_count;\n\tint error = -EPROTO;\n\n\t/* check that required tables exist */\n\tif (!(dfa->tables[YYTD_ID_DEF] &&\n\t      dfa->tables[YYTD_ID_BASE] &&\n\t      dfa->tables[YYTD_ID_NXT] && dfa->tables[YYTD_ID_CHK]))\n\t\tgoto out;\n\n\t/* accept.size == default.size == base.size */\n\tstate_count = dfa->tables[YYTD_ID_BASE]->td_lolen;\n\tif (ACCEPT1_FLAGS(flags)) {\n\t\tif (!dfa->tables[YYTD_ID_ACCEPT])\n\t\t\tgoto out;\n\t\tif (state_count != dfa->tables[YYTD_ID_ACCEPT]->td_lolen)\n\t\t\tgoto out;\n\t}\n\tif (ACCEPT2_FLAGS(flags)) {\n\t\tif (!dfa->tables[YYTD_ID_ACCEPT2])\n\t\t\tgoto out;\n\t\tif (state_count != dfa->tables[YYTD_ID_ACCEPT2]->td_lolen)\n\t\t\tgoto out;\n\t}\n\tif (state_count != dfa->tables[YYTD_ID_DEF]->td_lolen)\n\t\tgoto out;\n\n\t/* next.size == chk.size */\n\ttrans_count = dfa->tables[YYTD_ID_NXT]->td_lolen;\n\tif (trans_count != dfa->tables[YYTD_ID_CHK]->td_lolen)\n\t\tgoto out;\n\n\t/* if equivalence classes then its table size must be 256 */\n\tif (dfa->tables[YYTD_ID_EC] &&\n\t    dfa->tables[YYTD_ID_EC]->td_lolen != 256)\n\t\tgoto out;\n\n\tif (flags & DFA_FLAG_VERIFY_STATES) {\n\t\tfor (i = 0; i < state_count; i++) {\n\t\t\tif (DEFAULT_TABLE(dfa)[i] >= state_count)\n\t\t\t\tgoto out;\n\t\t\tif (base_idx(BASE_TABLE(dfa)[i]) + 255 >= trans_count) {\n\t\t\t\tprintk(KERN_ERR \"AppArmor DFA next/check upper \"\n\t\t\t\t       \"bounds error\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < trans_count; i++) {\n\t\t\tif (NEXT_TABLE(dfa)[i] >= state_count)\n\t\t\t\tgoto out;\n\t\t\tif (CHECK_TABLE(dfa)[i] >= state_count)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\terror = 0;\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "table_size",
          "args": [
            "table->td_lolen",
            "table->td_flags"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "table_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/match.h",
          "lines": "117-120",
          "snippet": "static inline size_t table_size(size_t len, size_t el_size)\n{\n\treturn ALIGN(sizeof(struct table_header) + len * el_size, 8);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline size_t table_size(size_t len, size_t el_size)\n{\n\treturn ALIGN(sizeof(struct table_header) + len * el_size, 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACCEPT2_FLAGS",
          "args": [
            "flags"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCEPT1_FLAGS",
          "args": [
            "flags"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_table",
          "args": [
            "data",
            "size"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "64-119",
          "snippet": "static struct table_header *unpack_table(char *blob, size_t bsize)\n{\n\tstruct table_header *table = NULL;\n\tstruct table_header th;\n\tsize_t tsize;\n\n\tif (bsize < sizeof(struct table_header))\n\t\tgoto out;\n\n\t/* loaded td_id's start at 1, subtract 1 now to avoid doing\n\t * it every time we use td_id as an index\n\t */\n\tth.td_id = be16_to_cpu(*(__be16 *) (blob)) - 1;\n\tif (th.td_id > YYTD_ID_MAX)\n\t\tgoto out;\n\tth.td_flags = be16_to_cpu(*(__be16 *) (blob + 2));\n\tth.td_lolen = be32_to_cpu(*(__be32 *) (blob + 8));\n\tblob += sizeof(struct table_header);\n\n\tif (!(th.td_flags == YYTD_DATA16 || th.td_flags == YYTD_DATA32 ||\n\t      th.td_flags == YYTD_DATA8))\n\t\tgoto out;\n\n\ttsize = table_size(th.td_lolen, th.td_flags);\n\tif (bsize < tsize)\n\t\tgoto out;\n\n\ttable = kvzalloc(tsize, GFP_KERNEL);\n\tif (table) {\n\t\ttable->td_id = th.td_id;\n\t\ttable->td_flags = th.td_flags;\n\t\ttable->td_lolen = th.td_lolen;\n\t\tif (th.td_flags == YYTD_DATA8)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u8, u8, byte_to_byte);\n\t\telse if (th.td_flags == YYTD_DATA16)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u16, __be16, be16_to_cpu);\n\t\telse if (th.td_flags == YYTD_DATA32)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u32, __be32, be32_to_cpu);\n\t\telse\n\t\t\tgoto fail;\n\t\t/* if table was vmalloced make sure the page tables are synced\n\t\t * before it is used, as it goes live to all cpus.\n\t\t */\n\t\tif (is_vmalloc_addr(table))\n\t\t\tvm_unmap_aliases();\n\t}\n\nout:\n\treturn table;\nfail:\n\tkvfree(table);\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic struct table_header *unpack_table(char *blob, size_t bsize)\n{\n\tstruct table_header *table = NULL;\n\tstruct table_header th;\n\tsize_t tsize;\n\n\tif (bsize < sizeof(struct table_header))\n\t\tgoto out;\n\n\t/* loaded td_id's start at 1, subtract 1 now to avoid doing\n\t * it every time we use td_id as an index\n\t */\n\tth.td_id = be16_to_cpu(*(__be16 *) (blob)) - 1;\n\tif (th.td_id > YYTD_ID_MAX)\n\t\tgoto out;\n\tth.td_flags = be16_to_cpu(*(__be16 *) (blob + 2));\n\tth.td_lolen = be32_to_cpu(*(__be32 *) (blob + 8));\n\tblob += sizeof(struct table_header);\n\n\tif (!(th.td_flags == YYTD_DATA16 || th.td_flags == YYTD_DATA32 ||\n\t      th.td_flags == YYTD_DATA8))\n\t\tgoto out;\n\n\ttsize = table_size(th.td_lolen, th.td_flags);\n\tif (bsize < tsize)\n\t\tgoto out;\n\n\ttable = kvzalloc(tsize, GFP_KERNEL);\n\tif (table) {\n\t\ttable->td_id = th.td_id;\n\t\ttable->td_flags = th.td_flags;\n\t\ttable->td_lolen = th.td_lolen;\n\t\tif (th.td_flags == YYTD_DATA8)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u8, u8, byte_to_byte);\n\t\telse if (th.td_flags == YYTD_DATA16)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u16, __be16, be16_to_cpu);\n\t\telse if (th.td_flags == YYTD_DATA32)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u32, __be32, be32_to_cpu);\n\t\telse\n\t\t\tgoto fail;\n\t\t/* if table was vmalloced make sure the page tables are synced\n\t\t * before it is used, as it goes live to all cpus.\n\t\t */\n\t\tif (is_vmalloc_addr(table))\n\t\t\tvm_unmap_aliases();\n\t}\n\nout:\n\treturn table;\nfail:\n\tkvfree(table);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "*(__be16 *) (data + 12)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*(__be32 *) (data + 4)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*(__be32 *) data"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&dfa->count"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct aa_dfa)",
            "GFP_KERNEL"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstruct aa_dfa *aa_dfa_unpack(void *blob, size_t size, int flags)\n{\n\tint hsize;\n\tint error = -ENOMEM;\n\tchar *data = blob;\n\tstruct table_header *table = NULL;\n\tstruct aa_dfa *dfa = kzalloc(sizeof(struct aa_dfa), GFP_KERNEL);\n\tif (!dfa)\n\t\tgoto fail;\n\n\tkref_init(&dfa->count);\n\n\terror = -EPROTO;\n\n\t/* get dfa table set header */\n\tif (size < sizeof(struct table_set_header))\n\t\tgoto fail;\n\n\tif (ntohl(*(__be32 *) data) != YYTH_MAGIC)\n\t\tgoto fail;\n\n\thsize = ntohl(*(__be32 *) (data + 4));\n\tif (size < hsize)\n\t\tgoto fail;\n\n\tdfa->flags = ntohs(*(__be16 *) (data + 12));\n\tdata += hsize;\n\tsize -= hsize;\n\n\twhile (size > 0) {\n\t\ttable = unpack_table(data, size);\n\t\tif (!table)\n\t\t\tgoto fail;\n\n\t\tswitch (table->td_id) {\n\t\tcase YYTD_ID_ACCEPT:\n\t\t\tif (!(table->td_flags & ACCEPT1_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_ACCEPT2:\n\t\t\tif (!(table->td_flags & ACCEPT2_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_BASE:\n\t\t\tif (table->td_flags != YYTD_DATA32)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_DEF:\n\t\tcase YYTD_ID_NXT:\n\t\tcase YYTD_ID_CHK:\n\t\t\tif (table->td_flags != YYTD_DATA16)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_EC:\n\t\t\tif (table->td_flags != YYTD_DATA8)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t\t/* check for duplicate table entry */\n\t\tif (dfa->tables[table->td_id])\n\t\t\tgoto fail;\n\t\tdfa->tables[table->td_id] = table;\n\t\tdata += table_size(table->td_lolen, table->td_flags);\n\t\tsize -= table_size(table->td_lolen, table->td_flags);\n\t\ttable = NULL;\n\t}\n\n\terror = verify_dfa(dfa, flags);\n\tif (error)\n\t\tgoto fail;\n\n\treturn dfa;\n\nfail:\n\tkvfree(table);\n\tdfa_free(dfa);\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "aa_dfa_free_kref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
    "lines": "216-220",
    "snippet": "void aa_dfa_free_kref(struct kref *kref)\n{\n\tstruct aa_dfa *dfa = container_of(kref, struct aa_dfa, count);\n\tdfa_free(dfa);\n}",
    "includes": [
      "#include \"include/match.h\"",
      "#include \"include/lib.h\"",
      "#include <linux/kref.h>",
      "#include <linux/err.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dfa_free",
          "args": [
            "dfa"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_free_kref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "216-220",
          "snippet": "void aa_dfa_free_kref(struct kref *kref)\n{\n\tstruct aa_dfa *dfa = container_of(kref, struct aa_dfa, count);\n\tdfa_free(dfa);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structaa_dfa",
            "count"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nvoid aa_dfa_free_kref(struct kref *kref)\n{\n\tstruct aa_dfa *dfa = container_of(kref, struct aa_dfa, count);\n\tdfa_free(dfa);\n}"
  },
  {
    "function_name": "dfa_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
    "lines": "199-210",
    "snippet": "static void dfa_free(struct aa_dfa *dfa)\n{\n\tif (dfa) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(dfa->tables); i++) {\n\t\t\tkvfree(dfa->tables[i]);\n\t\t\tdfa->tables[i] = NULL;\n\t\t}\n\t\tkfree(dfa);\n\t}\n}",
    "includes": [
      "#include \"include/match.h\"",
      "#include \"include/lib.h\"",
      "#include <linux/kref.h>",
      "#include <linux/err.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dfa"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "dfa->tables[i]"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "dfa->tables"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic void dfa_free(struct aa_dfa *dfa)\n{\n\tif (dfa) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(dfa->tables); i++) {\n\t\t\tkvfree(dfa->tables[i]);\n\t\t\tdfa->tables[i] = NULL;\n\t\t}\n\t\tkfree(dfa);\n\t}\n}"
  },
  {
    "function_name": "verify_dfa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
    "lines": "131-191",
    "snippet": "static int verify_dfa(struct aa_dfa *dfa, int flags)\n{\n\tsize_t i, state_count, trans_count;\n\tint error = -EPROTO;\n\n\t/* check that required tables exist */\n\tif (!(dfa->tables[YYTD_ID_DEF] &&\n\t      dfa->tables[YYTD_ID_BASE] &&\n\t      dfa->tables[YYTD_ID_NXT] && dfa->tables[YYTD_ID_CHK]))\n\t\tgoto out;\n\n\t/* accept.size == default.size == base.size */\n\tstate_count = dfa->tables[YYTD_ID_BASE]->td_lolen;\n\tif (ACCEPT1_FLAGS(flags)) {\n\t\tif (!dfa->tables[YYTD_ID_ACCEPT])\n\t\t\tgoto out;\n\t\tif (state_count != dfa->tables[YYTD_ID_ACCEPT]->td_lolen)\n\t\t\tgoto out;\n\t}\n\tif (ACCEPT2_FLAGS(flags)) {\n\t\tif (!dfa->tables[YYTD_ID_ACCEPT2])\n\t\t\tgoto out;\n\t\tif (state_count != dfa->tables[YYTD_ID_ACCEPT2]->td_lolen)\n\t\t\tgoto out;\n\t}\n\tif (state_count != dfa->tables[YYTD_ID_DEF]->td_lolen)\n\t\tgoto out;\n\n\t/* next.size == chk.size */\n\ttrans_count = dfa->tables[YYTD_ID_NXT]->td_lolen;\n\tif (trans_count != dfa->tables[YYTD_ID_CHK]->td_lolen)\n\t\tgoto out;\n\n\t/* if equivalence classes then its table size must be 256 */\n\tif (dfa->tables[YYTD_ID_EC] &&\n\t    dfa->tables[YYTD_ID_EC]->td_lolen != 256)\n\t\tgoto out;\n\n\tif (flags & DFA_FLAG_VERIFY_STATES) {\n\t\tfor (i = 0; i < state_count; i++) {\n\t\t\tif (DEFAULT_TABLE(dfa)[i] >= state_count)\n\t\t\t\tgoto out;\n\t\t\tif (base_idx(BASE_TABLE(dfa)[i]) + 255 >= trans_count) {\n\t\t\t\tprintk(KERN_ERR \"AppArmor DFA next/check upper \"\n\t\t\t\t       \"bounds error\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < trans_count; i++) {\n\t\t\tif (NEXT_TABLE(dfa)[i] >= state_count)\n\t\t\t\tgoto out;\n\t\t\tif (CHECK_TABLE(dfa)[i] >= state_count)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\terror = 0;\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"include/match.h\"",
      "#include \"include/lib.h\"",
      "#include <linux/kref.h>",
      "#include <linux/err.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_TABLE",
          "args": [
            "dfa"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_TABLE",
          "args": [
            "dfa"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"AppArmor DFA next/check upper \"\n\t\t\t\t       \"bounds error\\n\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base_idx",
          "args": [
            "BASE_TABLE(dfa)[i]"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BASE_TABLE",
          "args": [
            "dfa"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFAULT_TABLE",
          "args": [
            "dfa"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCEPT2_FLAGS",
          "args": [
            "flags"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCEPT1_FLAGS",
          "args": [
            "flags"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic int verify_dfa(struct aa_dfa *dfa, int flags)\n{\n\tsize_t i, state_count, trans_count;\n\tint error = -EPROTO;\n\n\t/* check that required tables exist */\n\tif (!(dfa->tables[YYTD_ID_DEF] &&\n\t      dfa->tables[YYTD_ID_BASE] &&\n\t      dfa->tables[YYTD_ID_NXT] && dfa->tables[YYTD_ID_CHK]))\n\t\tgoto out;\n\n\t/* accept.size == default.size == base.size */\n\tstate_count = dfa->tables[YYTD_ID_BASE]->td_lolen;\n\tif (ACCEPT1_FLAGS(flags)) {\n\t\tif (!dfa->tables[YYTD_ID_ACCEPT])\n\t\t\tgoto out;\n\t\tif (state_count != dfa->tables[YYTD_ID_ACCEPT]->td_lolen)\n\t\t\tgoto out;\n\t}\n\tif (ACCEPT2_FLAGS(flags)) {\n\t\tif (!dfa->tables[YYTD_ID_ACCEPT2])\n\t\t\tgoto out;\n\t\tif (state_count != dfa->tables[YYTD_ID_ACCEPT2]->td_lolen)\n\t\t\tgoto out;\n\t}\n\tif (state_count != dfa->tables[YYTD_ID_DEF]->td_lolen)\n\t\tgoto out;\n\n\t/* next.size == chk.size */\n\ttrans_count = dfa->tables[YYTD_ID_NXT]->td_lolen;\n\tif (trans_count != dfa->tables[YYTD_ID_CHK]->td_lolen)\n\t\tgoto out;\n\n\t/* if equivalence classes then its table size must be 256 */\n\tif (dfa->tables[YYTD_ID_EC] &&\n\t    dfa->tables[YYTD_ID_EC]->td_lolen != 256)\n\t\tgoto out;\n\n\tif (flags & DFA_FLAG_VERIFY_STATES) {\n\t\tfor (i = 0; i < state_count; i++) {\n\t\t\tif (DEFAULT_TABLE(dfa)[i] >= state_count)\n\t\t\t\tgoto out;\n\t\t\tif (base_idx(BASE_TABLE(dfa)[i]) + 255 >= trans_count) {\n\t\t\t\tprintk(KERN_ERR \"AppArmor DFA next/check upper \"\n\t\t\t\t       \"bounds error\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < trans_count; i++) {\n\t\t\tif (NEXT_TABLE(dfa)[i] >= state_count)\n\t\t\t\tgoto out;\n\t\t\tif (CHECK_TABLE(dfa)[i] >= state_count)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\terror = 0;\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "unpack_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
    "lines": "64-119",
    "snippet": "static struct table_header *unpack_table(char *blob, size_t bsize)\n{\n\tstruct table_header *table = NULL;\n\tstruct table_header th;\n\tsize_t tsize;\n\n\tif (bsize < sizeof(struct table_header))\n\t\tgoto out;\n\n\t/* loaded td_id's start at 1, subtract 1 now to avoid doing\n\t * it every time we use td_id as an index\n\t */\n\tth.td_id = be16_to_cpu(*(__be16 *) (blob)) - 1;\n\tif (th.td_id > YYTD_ID_MAX)\n\t\tgoto out;\n\tth.td_flags = be16_to_cpu(*(__be16 *) (blob + 2));\n\tth.td_lolen = be32_to_cpu(*(__be32 *) (blob + 8));\n\tblob += sizeof(struct table_header);\n\n\tif (!(th.td_flags == YYTD_DATA16 || th.td_flags == YYTD_DATA32 ||\n\t      th.td_flags == YYTD_DATA8))\n\t\tgoto out;\n\n\ttsize = table_size(th.td_lolen, th.td_flags);\n\tif (bsize < tsize)\n\t\tgoto out;\n\n\ttable = kvzalloc(tsize, GFP_KERNEL);\n\tif (table) {\n\t\ttable->td_id = th.td_id;\n\t\ttable->td_flags = th.td_flags;\n\t\ttable->td_lolen = th.td_lolen;\n\t\tif (th.td_flags == YYTD_DATA8)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u8, u8, byte_to_byte);\n\t\telse if (th.td_flags == YYTD_DATA16)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u16, __be16, be16_to_cpu);\n\t\telse if (th.td_flags == YYTD_DATA32)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u32, __be32, be32_to_cpu);\n\t\telse\n\t\t\tgoto fail;\n\t\t/* if table was vmalloced make sure the page tables are synced\n\t\t * before it is used, as it goes live to all cpus.\n\t\t */\n\t\tif (is_vmalloc_addr(table))\n\t\t\tvm_unmap_aliases();\n\t}\n\nout:\n\treturn table;\nfail:\n\tkvfree(table);\n\treturn NULL;\n}",
    "includes": [
      "#include \"include/match.h\"",
      "#include \"include/lib.h\"",
      "#include <linux/kref.h>",
      "#include <linux/err.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "table"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_unmap_aliases",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "table"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNPACK_ARRAY",
          "args": [
            "table->td_data",
            "blob",
            "th.td_lolen",
            "u32",
            "__be32",
            "be32_to_cpu"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNPACK_ARRAY",
          "args": [
            "table->td_data",
            "blob",
            "th.td_lolen",
            "u16",
            "__be16",
            "be16_to_cpu"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNPACK_ARRAY",
          "args": [
            "table->td_data",
            "blob",
            "th.td_lolen",
            "u8",
            "u8",
            "byte_to_byte"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvzalloc",
          "args": [
            "tsize",
            "GFP_KERNEL"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table_size",
          "args": [
            "th.td_lolen",
            "th.td_flags"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "table_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/match.h",
          "lines": "117-120",
          "snippet": "static inline size_t table_size(size_t len, size_t el_size)\n{\n\treturn ALIGN(sizeof(struct table_header) + len * el_size, 8);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline size_t table_size(size_t len, size_t el_size)\n{\n\treturn ALIGN(sizeof(struct table_header) + len * el_size, 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*(__be32 *) (blob + 8)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*(__be16 *) (blob + 2)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*(__be16 *) (blob)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic struct table_header *unpack_table(char *blob, size_t bsize)\n{\n\tstruct table_header *table = NULL;\n\tstruct table_header th;\n\tsize_t tsize;\n\n\tif (bsize < sizeof(struct table_header))\n\t\tgoto out;\n\n\t/* loaded td_id's start at 1, subtract 1 now to avoid doing\n\t * it every time we use td_id as an index\n\t */\n\tth.td_id = be16_to_cpu(*(__be16 *) (blob)) - 1;\n\tif (th.td_id > YYTD_ID_MAX)\n\t\tgoto out;\n\tth.td_flags = be16_to_cpu(*(__be16 *) (blob + 2));\n\tth.td_lolen = be32_to_cpu(*(__be32 *) (blob + 8));\n\tblob += sizeof(struct table_header);\n\n\tif (!(th.td_flags == YYTD_DATA16 || th.td_flags == YYTD_DATA32 ||\n\t      th.td_flags == YYTD_DATA8))\n\t\tgoto out;\n\n\ttsize = table_size(th.td_lolen, th.td_flags);\n\tif (bsize < tsize)\n\t\tgoto out;\n\n\ttable = kvzalloc(tsize, GFP_KERNEL);\n\tif (table) {\n\t\ttable->td_id = th.td_id;\n\t\ttable->td_flags = th.td_flags;\n\t\ttable->td_lolen = th.td_lolen;\n\t\tif (th.td_flags == YYTD_DATA8)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u8, u8, byte_to_byte);\n\t\telse if (th.td_flags == YYTD_DATA16)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u16, __be16, be16_to_cpu);\n\t\telse if (th.td_flags == YYTD_DATA32)\n\t\t\tUNPACK_ARRAY(table->td_data, blob, th.td_lolen,\n\t\t\t\t     u32, __be32, be32_to_cpu);\n\t\telse\n\t\t\tgoto fail;\n\t\t/* if table was vmalloced make sure the page tables are synced\n\t\t * before it is used, as it goes live to all cpus.\n\t\t */\n\t\tif (is_vmalloc_addr(table))\n\t\t\tvm_unmap_aliases();\n\t}\n\nout:\n\treturn table;\nfail:\n\tkvfree(table);\n\treturn NULL;\n}"
  },
  {
    "function_name": "aa_teardown_dfa_engine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
    "lines": "49-53",
    "snippet": "void aa_teardown_dfa_engine(void)\n{\n\taa_put_dfa(nulldfa);\n\tnulldfa = NULL;\n}",
    "includes": [
      "#include \"include/match.h\"",
      "#include \"include/lib.h\"",
      "#include <linux/kref.h>",
      "#include <linux/err.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct aa_dfa *nulldfa;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_dfa",
          "args": [
            "nulldfa"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_dfa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/match.h",
          "lines": "156-160",
          "snippet": "static inline void aa_put_dfa(struct aa_dfa *dfa)\n{\n\tif (dfa)\n\t\tkref_put(&dfa->count, aa_dfa_free_kref);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void aa_put_dfa(struct aa_dfa *dfa)\n{\n\tif (dfa)\n\t\tkref_put(&dfa->count, aa_dfa_free_kref);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstruct aa_dfa *nulldfa;\n\nvoid aa_teardown_dfa_engine(void)\n{\n\taa_put_dfa(nulldfa);\n\tnulldfa = NULL;\n}"
  },
  {
    "function_name": "aa_setup_dfa_engine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
    "lines": "33-47",
    "snippet": "int aa_setup_dfa_engine(void)\n{\n\tint error;\n\n\tnulldfa = aa_dfa_unpack(nulldfa_src, sizeof(nulldfa_src),\n\t\t\t\tTO_ACCEPT1_FLAG(YYTD_DATA32) |\n\t\t\t\tTO_ACCEPT2_FLAG(YYTD_DATA32));\n\tif (!IS_ERR(nulldfa))\n\t\treturn 0;\n\n\terror = PTR_ERR(nulldfa);\n\tnulldfa = NULL;\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/match.h\"",
      "#include \"include/lib.h\"",
      "#include <linux/kref.h>",
      "#include <linux/err.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char nulldfa_src[] = {\n\t#include \"nulldfa.in\"\n};",
      "struct aa_dfa *nulldfa;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "nulldfa"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nulldfa"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_dfa_unpack",
          "args": [
            "nulldfa_src",
            "sizeof(nulldfa_src)",
            "TO_ACCEPT1_FLAG(YYTD_DATA32) |\n\t\t\t\tTO_ACCEPT2_FLAG(YYTD_DATA32)"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_unpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "234-313",
          "snippet": "struct aa_dfa *aa_dfa_unpack(void *blob, size_t size, int flags)\n{\n\tint hsize;\n\tint error = -ENOMEM;\n\tchar *data = blob;\n\tstruct table_header *table = NULL;\n\tstruct aa_dfa *dfa = kzalloc(sizeof(struct aa_dfa), GFP_KERNEL);\n\tif (!dfa)\n\t\tgoto fail;\n\n\tkref_init(&dfa->count);\n\n\terror = -EPROTO;\n\n\t/* get dfa table set header */\n\tif (size < sizeof(struct table_set_header))\n\t\tgoto fail;\n\n\tif (ntohl(*(__be32 *) data) != YYTH_MAGIC)\n\t\tgoto fail;\n\n\thsize = ntohl(*(__be32 *) (data + 4));\n\tif (size < hsize)\n\t\tgoto fail;\n\n\tdfa->flags = ntohs(*(__be16 *) (data + 12));\n\tdata += hsize;\n\tsize -= hsize;\n\n\twhile (size > 0) {\n\t\ttable = unpack_table(data, size);\n\t\tif (!table)\n\t\t\tgoto fail;\n\n\t\tswitch (table->td_id) {\n\t\tcase YYTD_ID_ACCEPT:\n\t\t\tif (!(table->td_flags & ACCEPT1_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_ACCEPT2:\n\t\t\tif (!(table->td_flags & ACCEPT2_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_BASE:\n\t\t\tif (table->td_flags != YYTD_DATA32)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_DEF:\n\t\tcase YYTD_ID_NXT:\n\t\tcase YYTD_ID_CHK:\n\t\t\tif (table->td_flags != YYTD_DATA16)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_EC:\n\t\t\tif (table->td_flags != YYTD_DATA8)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t\t/* check for duplicate table entry */\n\t\tif (dfa->tables[table->td_id])\n\t\t\tgoto fail;\n\t\tdfa->tables[table->td_id] = table;\n\t\tdata += table_size(table->td_lolen, table->td_flags);\n\t\tsize -= table_size(table->td_lolen, table->td_flags);\n\t\ttable = NULL;\n\t}\n\n\terror = verify_dfa(dfa, flags);\n\tif (error)\n\t\tgoto fail;\n\n\treturn dfa;\n\nfail:\n\tkvfree(table);\n\tdfa_free(dfa);\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstruct aa_dfa *aa_dfa_unpack(void *blob, size_t size, int flags)\n{\n\tint hsize;\n\tint error = -ENOMEM;\n\tchar *data = blob;\n\tstruct table_header *table = NULL;\n\tstruct aa_dfa *dfa = kzalloc(sizeof(struct aa_dfa), GFP_KERNEL);\n\tif (!dfa)\n\t\tgoto fail;\n\n\tkref_init(&dfa->count);\n\n\terror = -EPROTO;\n\n\t/* get dfa table set header */\n\tif (size < sizeof(struct table_set_header))\n\t\tgoto fail;\n\n\tif (ntohl(*(__be32 *) data) != YYTH_MAGIC)\n\t\tgoto fail;\n\n\thsize = ntohl(*(__be32 *) (data + 4));\n\tif (size < hsize)\n\t\tgoto fail;\n\n\tdfa->flags = ntohs(*(__be16 *) (data + 12));\n\tdata += hsize;\n\tsize -= hsize;\n\n\twhile (size > 0) {\n\t\ttable = unpack_table(data, size);\n\t\tif (!table)\n\t\t\tgoto fail;\n\n\t\tswitch (table->td_id) {\n\t\tcase YYTD_ID_ACCEPT:\n\t\t\tif (!(table->td_flags & ACCEPT1_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_ACCEPT2:\n\t\t\tif (!(table->td_flags & ACCEPT2_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_BASE:\n\t\t\tif (table->td_flags != YYTD_DATA32)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_DEF:\n\t\tcase YYTD_ID_NXT:\n\t\tcase YYTD_ID_CHK:\n\t\t\tif (table->td_flags != YYTD_DATA16)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_EC:\n\t\t\tif (table->td_flags != YYTD_DATA8)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t\t/* check for duplicate table entry */\n\t\tif (dfa->tables[table->td_id])\n\t\t\tgoto fail;\n\t\tdfa->tables[table->td_id] = table;\n\t\tdata += table_size(table->td_lolen, table->td_flags);\n\t\tsize -= table_size(table->td_lolen, table->td_flags);\n\t\ttable = NULL;\n\t}\n\n\terror = verify_dfa(dfa, flags);\n\tif (error)\n\t\tgoto fail;\n\n\treturn dfa;\n\nfail:\n\tkvfree(table);\n\tdfa_free(dfa);\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TO_ACCEPT2_FLAG",
          "args": [
            "YYTD_DATA32"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TO_ACCEPT1_FLAG",
          "args": [
            "YYTD_DATA32"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic char nulldfa_src[] = {\n\t#include \"nulldfa.in\"\n};\nstruct aa_dfa *nulldfa;\n\nint aa_setup_dfa_engine(void)\n{\n\tint error;\n\n\tnulldfa = aa_dfa_unpack(nulldfa_src, sizeof(nulldfa_src),\n\t\t\t\tTO_ACCEPT1_FLAG(YYTD_DATA32) |\n\t\t\t\tTO_ACCEPT2_FLAG(YYTD_DATA32));\n\tif (!IS_ERR(nulldfa))\n\t\treturn 0;\n\n\terror = PTR_ERR(nulldfa);\n\tnulldfa = NULL;\n\n\treturn error;\n}"
  }
]