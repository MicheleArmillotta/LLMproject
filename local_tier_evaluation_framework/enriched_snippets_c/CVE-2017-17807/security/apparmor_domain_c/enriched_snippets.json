[
  {
    "function_name": "aa_change_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "1186-1317",
    "snippet": "int aa_change_profile(const char *fqname, int flags)\n{\n\tstruct aa_label *label, *new = NULL, *target = NULL;\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tconst char *info = NULL;\n\tconst char *auditname = fqname;\t\t/* retain leading & if stack */\n\tbool stack = flags & AA_CHANGE_STACK;\n\tint error = 0;\n\tchar *op;\n\tu32 request;\n\n\tif (!fqname || !*fqname) {\n\t\tAA_DEBUG(\"no profile name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & AA_CHANGE_ONEXEC) {\n\t\trequest = AA_MAY_ONEXEC;\n\t\tif (stack)\n\t\t\top = OP_STACK_ONEXEC;\n\t\telse\n\t\t\top = OP_CHANGE_ONEXEC;\n\t} else {\n\t\trequest = AA_MAY_CHANGE_PROFILE;\n\t\tif (stack)\n\t\t\top = OP_STACK;\n\t\telse\n\t\t\top = OP_CHANGE_PROFILE;\n\t}\n\n\tlabel = aa_get_current_label();\n\n\tif (*fqname == '&') {\n\t\tstack = true;\n\t\t/* don't have label_parse() do stacking */\n\t\tfqname++;\n\t}\n\ttarget = aa_label_parse(label, fqname, GFP_KERNEL, true, false);\n\tif (IS_ERR(target)) {\n\t\tstruct aa_profile *tprofile;\n\n\t\tinfo = \"label not found\";\n\t\terror = PTR_ERR(target);\n\t\ttarget = NULL;\n\t\t/*\n\t\t * TODO: fixme using labels_profile is not right - do profile\n\t\t * per complain profile\n\t\t */\n\t\tif ((flags & AA_CHANGE_TEST) ||\n\t\t    !COMPLAIN_MODE(labels_profile(label)))\n\t\t\tgoto audit;\n\t\t/* released below */\n\t\ttprofile = aa_new_null_profile(labels_profile(label), false,\n\t\t\t\t\t       fqname, GFP_KERNEL);\n\t\tif (!tprofile) {\n\t\t\tinfo = \"failed null profile create\";\n\t\t\terror = -ENOMEM;\n\t\t\tgoto audit;\n\t\t}\n\t\ttarget = &tprofile->label;\n\t\tgoto check;\n\t}\n\n\t/*\n\t * self directed transitions only apply to current policy ns\n\t * TODO: currently requiring perms for stacking and straight change\n\t *       stacking doesn't strictly need this. Determine how much\n\t *       we want to loosen this restriction for stacking\n\t *\n\t * if (!stack) {\n\t */\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\tchange_profile_perms_wrapper(op, auditname,\n\t\t\t\t\t\t     profile, target, stack,\n\t\t\t\t\t\t     request, &perms));\n\tif (error)\n\t\t/* auditing done in change_profile_perms_wrapper */\n\t\tgoto out;\n\n\t/* } */\n\ncheck:\n\t/* check if tracing task is allowed to trace target domain */\n\terror = may_change_ptraced_domain(target, &info);\n\tif (error && !fn_for_each_in_ns(label, profile,\n\t\t\t\t\tCOMPLAIN_MODE(profile)))\n\t\tgoto audit;\n\n\t/* TODO: add permission check to allow this\n\t * if ((flags & AA_CHANGE_ONEXEC) && !current_is_single_threaded()) {\n\t *      info = \"not a single threaded task\";\n\t *      error = -EACCES;\n\t *      goto audit;\n\t * }\n\t */\n\tif (flags & AA_CHANGE_TEST)\n\t\tgoto out;\n\n\tif (!(flags & AA_CHANGE_ONEXEC)) {\n\t\t/* only transition profiles in the current ns */\n\t\tif (stack)\n\t\t\tnew = aa_label_merge(label, target, GFP_KERNEL);\n\t\telse\n\t\t\tnew = fn_label_build_in_ns(label, profile, GFP_KERNEL,\n\t\t\t\t\taa_get_label(target),\n\t\t\t\t\taa_get_label(&profile->label));\n\t\tif (IS_ERR_OR_NULL(new)) {\n\t\t\tinfo = \"failed to build target label\";\n\t\t\terror = PTR_ERR(new);\n\t\t\tnew = NULL;\n\t\t\tperms.allow = 0;\n\t\t\tgoto audit;\n\t\t}\n\t\terror = aa_replace_current_label(new);\n\t} else\n\t\t/* full transition will be built in exec path */\n\t\terror = aa_set_current_onexec(target, stack);\n\naudit:\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\taa_audit_file(profile, &perms, op, request, auditname,\n\t\t\t\t      NULL, new ? new : target,\n\t\t\t\t      GLOBAL_ROOT_UID, info, error));\n\nout:\n\taa_put_label(new);\n\taa_put_label(target);\n\taa_put_label(label);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn_for_each_in_ns",
          "args": [
            "label",
            "profile",
            "aa_audit_file(profile, &perms, op, request, auditname,\n\t\t\t\t      NULL, new ? new : target,\n\t\t\t\t      GLOBAL_ROOT_UID, info, error)"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_audit_file",
          "args": [
            "profile",
            "&perms",
            "op",
            "request",
            "auditname",
            "NULL",
            "new ? new : target",
            "GLOBAL_ROOT_UID",
            "info",
            "error"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "103-153",
          "snippet": "int aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_set_current_onexec",
          "args": [
            "target",
            "stack"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "aa_set_current_onexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "137-152",
          "snippet": "int aa_set_current_onexec(struct aa_label *label, bool stack)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct cred *new = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\taa_get_label(label);\n\taa_clear_task_ctx_trans(ctx);\n\tctx->onexec = label;\n\tctx->token = stack;\n\n\tcommit_creds(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nint aa_set_current_onexec(struct aa_label *label, bool stack)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct cred *new = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\taa_get_label(label);\n\taa_clear_task_ctx_trans(ctx);\n\tctx->onexec = label;\n\tctx->token = stack;\n\n\tcommit_creds(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_replace_current_label",
          "args": [
            "new"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "aa_replace_current_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "94-129",
          "snippet": "int aa_replace_current_label(struct aa_label *label)\n{\n\tstruct aa_task_ctx *ctx = current_ctx();\n\tstruct cred *new;\n\tAA_BUG(!label);\n\n\tif (ctx->label == label)\n\t\treturn 0;\n\n\tif (current_cred() != current_real_cred())\n\t\treturn -EBUSY;\n\n\tnew  = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\tif (unconfined(label) || (labels_ns(ctx->label) != labels_ns(label)))\n\t\t/* if switching to unconfined or a different label namespace\n\t\t * clear out context state\n\t\t */\n\t\taa_clear_task_ctx_trans(ctx);\n\n\t/*\n\t * be careful switching ctx->profile, when racing replacement it\n\t * is possible that ctx->profile->proxy->profile is the reference\n\t * keeping @profile valid, so make sure to get its reference before\n\t * dropping the reference on ctx->profile\n\t */\n\taa_get_label(label);\n\taa_put_label(ctx->label);\n\tctx->label = label;\n\n\tcommit_creds(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nint aa_replace_current_label(struct aa_label *label)\n{\n\tstruct aa_task_ctx *ctx = current_ctx();\n\tstruct cred *new;\n\tAA_BUG(!label);\n\n\tif (ctx->label == label)\n\t\treturn 0;\n\n\tif (current_cred() != current_real_cred())\n\t\treturn -EBUSY;\n\n\tnew  = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\tif (unconfined(label) || (labels_ns(ctx->label) != labels_ns(label)))\n\t\t/* if switching to unconfined or a different label namespace\n\t\t * clear out context state\n\t\t */\n\t\taa_clear_task_ctx_trans(ctx);\n\n\t/*\n\t * be careful switching ctx->profile, when racing replacement it\n\t * is possible that ctx->profile->proxy->profile is the reference\n\t * keeping @profile valid, so make sure to get its reference before\n\t * dropping the reference on ctx->profile\n\t */\n\taa_get_label(label);\n\taa_put_label(ctx->label);\n\tctx->label = label;\n\n\tcommit_creds(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "new"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_label_build_in_ns",
          "args": [
            "label",
            "profile",
            "GFP_KERNEL",
            "aa_get_label(target)",
            "aa_get_label(&profile->label)"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "&profile->label"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_merge",
          "args": [
            "label",
            "target",
            "GFP_KERNEL"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1195-1233",
          "snippet": "struct aa_label *aa_label_merge(struct aa_label *a, struct aa_label *b,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn aa_get_newest_label(a);\n\n\t/* TODO: enable when read side is lockless\n\t * check if label exists before taking locks\n\tif (!label_is_stale(a) && !label_is_stale(b))\n\t\tlabel = aa_label_find_merge(a, b);\n\t*/\n\n\tif (!label) {\n\t\tstruct aa_label *new;\n\n\t\ta = aa_get_newest_label(a);\n\t\tb = aa_get_newest_label(b);\n\n\t\t/* could use label_merge_len(a, b), but requires double\n\t\t * comparison for small savings\n\t\t */\n\t\tnew = aa_label_alloc(a->size + b->size, NULL, gfp);\n\t\tif (!new)\n\t\t\tgoto out;\n\n\t\tlabel = label_merge_insert(new, a, b);\n\t\tlabel_free_or_put_new(label, new);\nout:\n\t\taa_put_label(a);\n\t\taa_put_label(b);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_merge(struct aa_label *a, struct aa_label *b,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn aa_get_newest_label(a);\n\n\t/* TODO: enable when read side is lockless\n\t * check if label exists before taking locks\n\tif (!label_is_stale(a) && !label_is_stale(b))\n\t\tlabel = aa_label_find_merge(a, b);\n\t*/\n\n\tif (!label) {\n\t\tstruct aa_label *new;\n\n\t\ta = aa_get_newest_label(a);\n\t\tb = aa_get_newest_label(b);\n\n\t\t/* could use label_merge_len(a, b), but requires double\n\t\t * comparison for small savings\n\t\t */\n\t\tnew = aa_label_alloc(a->size + b->size, NULL, gfp);\n\t\tif (!new)\n\t\t\tgoto out;\n\n\t\tlabel = label_merge_insert(new, a, b);\n\t\tlabel_free_or_put_new(label, new);\nout:\n\t\taa_put_label(a);\n\t\taa_put_label(b);\n\t}\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn_for_each_in_ns",
          "args": [
            "label",
            "profile",
            "COMPLAIN_MODE(profile)"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPLAIN_MODE",
          "args": [
            "profile"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "may_change_ptraced_domain",
          "args": [
            "target",
            "&info"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "may_change_ptraced_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "62-88",
          "snippet": "static int may_change_ptraced_domain(struct aa_label *to_label,\n\t\t\t\t     const char **info)\n{\n\tstruct task_struct *tracer;\n\tstruct aa_label *tracerl = NULL;\n\tint error = 0;\n\n\trcu_read_lock();\n\ttracer = ptrace_parent(current);\n\tif (tracer)\n\t\t/* released below */\n\t\ttracerl = aa_get_task_label(tracer);\n\n\t/* not ptraced */\n\tif (!tracer || unconfined(tracerl))\n\t\tgoto out;\n\n\terror = aa_may_ptrace(tracerl, to_label, PTRACE_MODE_ATTACH);\n\nout:\n\trcu_read_unlock();\n\taa_put_label(tracerl);\n\n\tif (error)\n\t\t*info = \"ptrace prevents transition\";\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int may_change_ptraced_domain(struct aa_label *to_label,\n\t\t\t\t     const char **info)\n{\n\tstruct task_struct *tracer;\n\tstruct aa_label *tracerl = NULL;\n\tint error = 0;\n\n\trcu_read_lock();\n\ttracer = ptrace_parent(current);\n\tif (tracer)\n\t\t/* released below */\n\t\ttracerl = aa_get_task_label(tracer);\n\n\t/* not ptraced */\n\tif (!tracer || unconfined(tracerl))\n\t\tgoto out;\n\n\terror = aa_may_ptrace(tracerl, to_label, PTRACE_MODE_ATTACH);\n\nout:\n\trcu_read_unlock();\n\taa_put_label(tracerl);\n\n\tif (error)\n\t\t*info = \"ptrace prevents transition\";\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn_for_each_in_ns",
          "args": [
            "label",
            "profile",
            "change_profile_perms_wrapper(op, auditname,\n\t\t\t\t\t\t     profile, target, stack,\n\t\t\t\t\t\t     request, &perms)"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "change_profile_perms_wrapper",
          "args": [
            "op",
            "auditname",
            "profile",
            "target",
            "stack",
            "request",
            "&perms"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "change_profile_perms_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "1138-1170",
          "snippet": "static int change_profile_perms_wrapper(const char *op, const char *name,\n\t\t\t\t\tstruct aa_profile *profile,\n\t\t\t\t\tstruct aa_label *target, bool stack,\n\t\t\t\t\tu32 request, struct aa_perms *perms)\n{\n\tconst char *info = NULL;\n\tint error = 0;\n\n\t/*\n\t * Fail explicitly requested domain transitions when no_new_privs\n\t * and not unconfined OR the transition results in a stack on\n\t * the current label.\n\t * Stacking domain transitions and transitions from unconfined are\n\t * allowed even when no_new_privs is set because this aways results\n\t * in a reduction of permissions.\n\t */\n\tif (task_no_new_privs(current) && !stack &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(target, &profile->label)) {\n\t\tinfo = \"no new privs\";\n\t\terror = -EPERM;\n\t}\n\n\tif (!error)\n\t\terror = change_profile_perms(profile, target, stack, request,\n\t\t\t\t\t     profile->file.start, perms);\n\tif (error)\n\t\terror = aa_audit_file(profile, perms, op, request, name,\n\t\t\t\t      NULL, target, GLOBAL_ROOT_UID, info,\n\t\t\t\t      error);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int change_profile_perms_wrapper(const char *op, const char *name,\n\t\t\t\t\tstruct aa_profile *profile,\n\t\t\t\t\tstruct aa_label *target, bool stack,\n\t\t\t\t\tu32 request, struct aa_perms *perms)\n{\n\tconst char *info = NULL;\n\tint error = 0;\n\n\t/*\n\t * Fail explicitly requested domain transitions when no_new_privs\n\t * and not unconfined OR the transition results in a stack on\n\t * the current label.\n\t * Stacking domain transitions and transitions from unconfined are\n\t * allowed even when no_new_privs is set because this aways results\n\t * in a reduction of permissions.\n\t */\n\tif (task_no_new_privs(current) && !stack &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(target, &profile->label)) {\n\t\tinfo = \"no new privs\";\n\t\terror = -EPERM;\n\t}\n\n\tif (!error)\n\t\terror = change_profile_perms(profile, target, stack, request,\n\t\t\t\t\t     profile->file.start, perms);\n\tif (error)\n\t\terror = aa_audit_file(profile, perms, op, request, name,\n\t\t\t\t      NULL, target, GLOBAL_ROOT_UID, info,\n\t\t\t\t      error);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_new_null_profile",
          "args": [
            "labels_profile(label)",
            "false",
            "fqname",
            "GFP_KERNEL"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "aa_new_null_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "500-568",
          "snippet": "struct aa_profile *aa_new_null_profile(struct aa_profile *parent, bool hat,\n\t\t\t\t       const char *base, gfp_t gfp)\n{\n\tstruct aa_profile *p, *profile;\n\tconst char *bname;\n\tchar *name = NULL;\n\n\tAA_BUG(!parent);\n\n\tif (base) {\n\t\tname = kmalloc(strlen(parent->base.hname) + 8 + strlen(base),\n\t\t\t       gfp);\n\t\tif (name) {\n\t\t\tsprintf(name, \"%s//null-%s\", parent->base.hname, base);\n\t\t\tgoto name;\n\t\t}\n\t\t/* fall through to try shorter uniq */\n\t}\n\n\tname = kmalloc(strlen(parent->base.hname) + 2 + 7 + 8, gfp);\n\tif (!name)\n\t\treturn NULL;\n\tsprintf(name, \"%s//null-%x\", parent->base.hname,\n\t\tatomic_inc_return(&parent->ns->uniq_null));\n\nname:\n\t/* lookup to see if this is a dup creation */\n\tbname = basename(name);\n\tprofile = aa_find_child(parent, bname);\n\tif (profile)\n\t\tgoto out;\n\n\tprofile = aa_alloc_profile(name, NULL, gfp);\n\tif (!profile)\n\t\tgoto fail;\n\n\tprofile->mode = APPARMOR_COMPLAIN;\n\tprofile->label.flags |= FLAG_NULL;\n\tif (hat)\n\t\tprofile->label.flags |= FLAG_HAT;\n\tprofile->path_flags = parent->path_flags;\n\n\t/* released on free_profile */\n\trcu_assign_pointer(profile->parent, aa_get_profile(parent));\n\tprofile->ns = aa_get_ns(parent->ns);\n\tprofile->file.dfa = aa_get_dfa(nulldfa);\n\tprofile->policy.dfa = aa_get_dfa(nulldfa);\n\n\tmutex_lock_nested(&profile->ns->lock, profile->ns->level);\n\tp = __find_child(&parent->base.profiles, bname);\n\tif (p) {\n\t\taa_free_profile(profile);\n\t\tprofile = aa_get_profile(p);\n\t} else {\n\t\t__add_profile(&parent->base.profiles, profile);\n\t}\n\tmutex_unlock(&profile->ns->lock);\n\n\t/* refcount released by caller */\nout:\n\tkfree(name);\n\n\treturn profile;\n\nfail:\n\tkfree(name);\n\taa_free_profile(profile);\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct aa_profile *aa_new_null_profile(struct aa_profile *parent, bool hat,\n\t\t\t\t       const char *base, gfp_t gfp)\n{\n\tstruct aa_profile *p, *profile;\n\tconst char *bname;\n\tchar *name = NULL;\n\n\tAA_BUG(!parent);\n\n\tif (base) {\n\t\tname = kmalloc(strlen(parent->base.hname) + 8 + strlen(base),\n\t\t\t       gfp);\n\t\tif (name) {\n\t\t\tsprintf(name, \"%s//null-%s\", parent->base.hname, base);\n\t\t\tgoto name;\n\t\t}\n\t\t/* fall through to try shorter uniq */\n\t}\n\n\tname = kmalloc(strlen(parent->base.hname) + 2 + 7 + 8, gfp);\n\tif (!name)\n\t\treturn NULL;\n\tsprintf(name, \"%s//null-%x\", parent->base.hname,\n\t\tatomic_inc_return(&parent->ns->uniq_null));\n\nname:\n\t/* lookup to see if this is a dup creation */\n\tbname = basename(name);\n\tprofile = aa_find_child(parent, bname);\n\tif (profile)\n\t\tgoto out;\n\n\tprofile = aa_alloc_profile(name, NULL, gfp);\n\tif (!profile)\n\t\tgoto fail;\n\n\tprofile->mode = APPARMOR_COMPLAIN;\n\tprofile->label.flags |= FLAG_NULL;\n\tif (hat)\n\t\tprofile->label.flags |= FLAG_HAT;\n\tprofile->path_flags = parent->path_flags;\n\n\t/* released on free_profile */\n\trcu_assign_pointer(profile->parent, aa_get_profile(parent));\n\tprofile->ns = aa_get_ns(parent->ns);\n\tprofile->file.dfa = aa_get_dfa(nulldfa);\n\tprofile->policy.dfa = aa_get_dfa(nulldfa);\n\n\tmutex_lock_nested(&profile->ns->lock, profile->ns->level);\n\tp = __find_child(&parent->base.profiles, bname);\n\tif (p) {\n\t\taa_free_profile(profile);\n\t\tprofile = aa_get_profile(p);\n\t} else {\n\t\t__add_profile(&parent->base.profiles, profile);\n\t}\n\tmutex_unlock(&profile->ns->lock);\n\n\t/* refcount released by caller */\nout:\n\tkfree(name);\n\n\treturn profile;\n\nfail:\n\tkfree(name);\n\taa_free_profile(profile);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_profile",
          "args": [
            "label"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPLAIN_MODE",
          "args": [
            "labels_profile(label)"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_profile",
          "args": [
            "label"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "target"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "target"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_parse",
          "args": [
            "label",
            "fqname",
            "GFP_KERNEL",
            "true",
            "false"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1856-1931",
          "snippet": "struct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack)\n{\n\tDEFINE_VEC(profile, vec);\n\tstruct aa_label *label, *currbase = base;\n\tint i, len, stack = 0, error;\n\tchar *split;\n\n\tAA_BUG(!base);\n\tAA_BUG(!str);\n\n\tstr = skip_spaces(str);\n\tlen = label_count_str_entries(str);\n\tif (*str == '&' || force_stack) {\n\t\t/* stack on top of base */\n\t\tstack = base->size;\n\t\tlen += stack;\n\t\tif (*str == '&')\n\t\t\tstr++;\n\t}\n\tif (*str == '=')\n\t\tbase = &root_ns->unconfined->label;\n\n\terror = vec_setup(profile, vec, len, gfp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tfor (i = 0; i < stack; i++)\n\t\tvec[i] = aa_get_profile(base->vec[i]);\n\n\tfor (split = strstr(str, \"//&\"), i = stack; split && i < len; i++) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, split - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t\t/*\n\t\t * if component specified a new ns it becomes the new base\n\t\t * so that subsequent lookups are relative to it\n\t\t */\n\t\tif (vec[i]->ns != labels_ns(currbase))\n\t\t\tcurrbase = &vec[i]->label;\n\t\tstr = split + 3;\n\t\tsplit = strstr(str, \"//&\");\n\t}\n\t/* last element doesn't have a split */\n\tif (i < len) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, strlen(str));\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t}\n\tif (len == 1)\n\t\t/* no need to free vec as len < LOCAL_VEC_ENTRIES */\n\t\treturn &vec[0]->label;\n\n\tlen -= aa_vec_unique(vec, len, VEC_FLAG_TERMINATE);\n\t/* TODO: deal with reference labels */\n\tif (len == 1) {\n\t\tlabel = aa_get_label(&vec[0]->label);\n\t\tgoto out;\n\t}\n\n\tif (create)\n\t\tlabel = aa_vec_find_or_create_label(vec, len, gfp);\n\telse\n\t\tlabel = vec_find(vec, len);\n\tif (!label)\n\t\tgoto fail;\n\nout:\n\t/* use adjusted len from after vec_unique, not original */\n\tvec_cleanup(profile, vec, len);\n\treturn label;\n\nfail:\n\tlabel = ERR_PTR(-ENOENT);\n\tgoto out;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack)\n{\n\tDEFINE_VEC(profile, vec);\n\tstruct aa_label *label, *currbase = base;\n\tint i, len, stack = 0, error;\n\tchar *split;\n\n\tAA_BUG(!base);\n\tAA_BUG(!str);\n\n\tstr = skip_spaces(str);\n\tlen = label_count_str_entries(str);\n\tif (*str == '&' || force_stack) {\n\t\t/* stack on top of base */\n\t\tstack = base->size;\n\t\tlen += stack;\n\t\tif (*str == '&')\n\t\t\tstr++;\n\t}\n\tif (*str == '=')\n\t\tbase = &root_ns->unconfined->label;\n\n\terror = vec_setup(profile, vec, len, gfp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tfor (i = 0; i < stack; i++)\n\t\tvec[i] = aa_get_profile(base->vec[i]);\n\n\tfor (split = strstr(str, \"//&\"), i = stack; split && i < len; i++) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, split - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t\t/*\n\t\t * if component specified a new ns it becomes the new base\n\t\t * so that subsequent lookups are relative to it\n\t\t */\n\t\tif (vec[i]->ns != labels_ns(currbase))\n\t\t\tcurrbase = &vec[i]->label;\n\t\tstr = split + 3;\n\t\tsplit = strstr(str, \"//&\");\n\t}\n\t/* last element doesn't have a split */\n\tif (i < len) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, strlen(str));\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t}\n\tif (len == 1)\n\t\t/* no need to free vec as len < LOCAL_VEC_ENTRIES */\n\t\treturn &vec[0]->label;\n\n\tlen -= aa_vec_unique(vec, len, VEC_FLAG_TERMINATE);\n\t/* TODO: deal with reference labels */\n\tif (len == 1) {\n\t\tlabel = aa_get_label(&vec[0]->label);\n\t\tgoto out;\n\t}\n\n\tif (create)\n\t\tlabel = aa_vec_find_or_create_label(vec, len, gfp);\n\telse\n\t\tlabel = vec_find(vec, len);\n\tif (!label)\n\t\tgoto fail;\n\nout:\n\t/* use adjusted len from after vec_unique, not original */\n\tvec_cleanup(profile, vec, len);\n\treturn label;\n\nfail:\n\tlabel = ERR_PTR(-ENOENT);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_current_label",
          "args": [],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_current_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "131-138",
          "snippet": "static inline struct aa_label *aa_get_current_label(void)\n{\n\tstruct aa_label *l = aa_current_raw_label();\n\n\tif (label_is_stale(l))\n\t\treturn aa_get_newest_label(l);\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *aa_get_current_label(void)\n{\n\tstruct aa_label *l = aa_current_raw_label();\n\n\tif (label_is_stale(l))\n\t\treturn aa_get_newest_label(l);\n\treturn aa_get_label(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_DEBUG",
          "args": [
            "\"no profile name\""
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nint aa_change_profile(const char *fqname, int flags)\n{\n\tstruct aa_label *label, *new = NULL, *target = NULL;\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tconst char *info = NULL;\n\tconst char *auditname = fqname;\t\t/* retain leading & if stack */\n\tbool stack = flags & AA_CHANGE_STACK;\n\tint error = 0;\n\tchar *op;\n\tu32 request;\n\n\tif (!fqname || !*fqname) {\n\t\tAA_DEBUG(\"no profile name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & AA_CHANGE_ONEXEC) {\n\t\trequest = AA_MAY_ONEXEC;\n\t\tif (stack)\n\t\t\top = OP_STACK_ONEXEC;\n\t\telse\n\t\t\top = OP_CHANGE_ONEXEC;\n\t} else {\n\t\trequest = AA_MAY_CHANGE_PROFILE;\n\t\tif (stack)\n\t\t\top = OP_STACK;\n\t\telse\n\t\t\top = OP_CHANGE_PROFILE;\n\t}\n\n\tlabel = aa_get_current_label();\n\n\tif (*fqname == '&') {\n\t\tstack = true;\n\t\t/* don't have label_parse() do stacking */\n\t\tfqname++;\n\t}\n\ttarget = aa_label_parse(label, fqname, GFP_KERNEL, true, false);\n\tif (IS_ERR(target)) {\n\t\tstruct aa_profile *tprofile;\n\n\t\tinfo = \"label not found\";\n\t\terror = PTR_ERR(target);\n\t\ttarget = NULL;\n\t\t/*\n\t\t * TODO: fixme using labels_profile is not right - do profile\n\t\t * per complain profile\n\t\t */\n\t\tif ((flags & AA_CHANGE_TEST) ||\n\t\t    !COMPLAIN_MODE(labels_profile(label)))\n\t\t\tgoto audit;\n\t\t/* released below */\n\t\ttprofile = aa_new_null_profile(labels_profile(label), false,\n\t\t\t\t\t       fqname, GFP_KERNEL);\n\t\tif (!tprofile) {\n\t\t\tinfo = \"failed null profile create\";\n\t\t\terror = -ENOMEM;\n\t\t\tgoto audit;\n\t\t}\n\t\ttarget = &tprofile->label;\n\t\tgoto check;\n\t}\n\n\t/*\n\t * self directed transitions only apply to current policy ns\n\t * TODO: currently requiring perms for stacking and straight change\n\t *       stacking doesn't strictly need this. Determine how much\n\t *       we want to loosen this restriction for stacking\n\t *\n\t * if (!stack) {\n\t */\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\tchange_profile_perms_wrapper(op, auditname,\n\t\t\t\t\t\t     profile, target, stack,\n\t\t\t\t\t\t     request, &perms));\n\tif (error)\n\t\t/* auditing done in change_profile_perms_wrapper */\n\t\tgoto out;\n\n\t/* } */\n\ncheck:\n\t/* check if tracing task is allowed to trace target domain */\n\terror = may_change_ptraced_domain(target, &info);\n\tif (error && !fn_for_each_in_ns(label, profile,\n\t\t\t\t\tCOMPLAIN_MODE(profile)))\n\t\tgoto audit;\n\n\t/* TODO: add permission check to allow this\n\t * if ((flags & AA_CHANGE_ONEXEC) && !current_is_single_threaded()) {\n\t *      info = \"not a single threaded task\";\n\t *      error = -EACCES;\n\t *      goto audit;\n\t * }\n\t */\n\tif (flags & AA_CHANGE_TEST)\n\t\tgoto out;\n\n\tif (!(flags & AA_CHANGE_ONEXEC)) {\n\t\t/* only transition profiles in the current ns */\n\t\tif (stack)\n\t\t\tnew = aa_label_merge(label, target, GFP_KERNEL);\n\t\telse\n\t\t\tnew = fn_label_build_in_ns(label, profile, GFP_KERNEL,\n\t\t\t\t\taa_get_label(target),\n\t\t\t\t\taa_get_label(&profile->label));\n\t\tif (IS_ERR_OR_NULL(new)) {\n\t\t\tinfo = \"failed to build target label\";\n\t\t\terror = PTR_ERR(new);\n\t\t\tnew = NULL;\n\t\t\tperms.allow = 0;\n\t\t\tgoto audit;\n\t\t}\n\t\terror = aa_replace_current_label(new);\n\t} else\n\t\t/* full transition will be built in exec path */\n\t\terror = aa_set_current_onexec(target, stack);\n\naudit:\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\taa_audit_file(profile, &perms, op, request, auditname,\n\t\t\t\t      NULL, new ? new : target,\n\t\t\t\t      GLOBAL_ROOT_UID, info, error));\n\nout:\n\taa_put_label(new);\n\taa_put_label(target);\n\taa_put_label(label);\n\n\treturn error;\n}"
  },
  {
    "function_name": "change_profile_perms_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "1138-1170",
    "snippet": "static int change_profile_perms_wrapper(const char *op, const char *name,\n\t\t\t\t\tstruct aa_profile *profile,\n\t\t\t\t\tstruct aa_label *target, bool stack,\n\t\t\t\t\tu32 request, struct aa_perms *perms)\n{\n\tconst char *info = NULL;\n\tint error = 0;\n\n\t/*\n\t * Fail explicitly requested domain transitions when no_new_privs\n\t * and not unconfined OR the transition results in a stack on\n\t * the current label.\n\t * Stacking domain transitions and transitions from unconfined are\n\t * allowed even when no_new_privs is set because this aways results\n\t * in a reduction of permissions.\n\t */\n\tif (task_no_new_privs(current) && !stack &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(target, &profile->label)) {\n\t\tinfo = \"no new privs\";\n\t\terror = -EPERM;\n\t}\n\n\tif (!error)\n\t\terror = change_profile_perms(profile, target, stack, request,\n\t\t\t\t\t     profile->file.start, perms);\n\tif (error)\n\t\terror = aa_audit_file(profile, perms, op, request, name,\n\t\t\t\t      NULL, target, GLOBAL_ROOT_UID, info,\n\t\t\t\t      error);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_audit_file",
          "args": [
            "profile",
            "perms",
            "op",
            "request",
            "name",
            "NULL",
            "target",
            "GLOBAL_ROOT_UID",
            "info",
            "error"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "103-153",
          "snippet": "int aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "change_profile_perms",
          "args": [
            "profile",
            "target",
            "stack",
            "request",
            "profile->file.start",
            "perms"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "change_profile_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "289-302",
          "snippet": "static int change_profile_perms(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *target, bool stack,\n\t\t\t\tu32 request, unsigned int start,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tif (profile_unconfined(profile)) {\n\t\tperms->allow = AA_MAY_CHANGE_PROFILE | AA_MAY_ONEXEC;\n\t\tperms->audit = perms->quiet = perms->kill = 0;\n\t\treturn 0;\n\t}\n\n\t/* TODO: add profile in ns screening */\n\treturn label_match(profile, target, stack, start, true, request, perms);\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int change_profile_perms(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *target, bool stack,\n\t\t\t\tu32 request, unsigned int start,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tif (profile_unconfined(profile)) {\n\t\tperms->allow = AA_MAY_CHANGE_PROFILE | AA_MAY_ONEXEC;\n\t\tperms->audit = perms->quiet = perms->kill = 0;\n\t\treturn 0;\n\t}\n\n\t/* TODO: add profile in ns screening */\n\treturn label_match(profile, target, stack, start, true, request, perms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_is_subset",
          "args": [
            "target",
            "&profile->label"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_is_subset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "545-556",
          "snippet": "bool aa_label_is_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\treturn __aa_label_next_not_in_set(&i, set, sub) == NULL;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nbool aa_label_is_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\treturn __aa_label_next_not_in_set(&i, set, sub) == NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_no_new_privs",
          "args": [
            "current"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int change_profile_perms_wrapper(const char *op, const char *name,\n\t\t\t\t\tstruct aa_profile *profile,\n\t\t\t\t\tstruct aa_label *target, bool stack,\n\t\t\t\t\tu32 request, struct aa_perms *perms)\n{\n\tconst char *info = NULL;\n\tint error = 0;\n\n\t/*\n\t * Fail explicitly requested domain transitions when no_new_privs\n\t * and not unconfined OR the transition results in a stack on\n\t * the current label.\n\t * Stacking domain transitions and transitions from unconfined are\n\t * allowed even when no_new_privs is set because this aways results\n\t * in a reduction of permissions.\n\t */\n\tif (task_no_new_privs(current) && !stack &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(target, &profile->label)) {\n\t\tinfo = \"no new privs\";\n\t\terror = -EPERM;\n\t}\n\n\tif (!error)\n\t\terror = change_profile_perms(profile, target, stack, request,\n\t\t\t\t\t     profile->file.start, perms);\n\tif (error)\n\t\terror = aa_audit_file(profile, perms, op, request, name,\n\t\t\t\t      NULL, target, GLOBAL_ROOT_UID, info,\n\t\t\t\t      error);\n\n\treturn error;\n}"
  },
  {
    "function_name": "aa_change_hat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "1048-1135",
    "snippet": "int aa_change_hat(const char *hats[], int count, u64 token, int flags)\n{\n\tconst struct cred *cred;\n\tstruct aa_task_ctx *ctx;\n\tstruct aa_label *label, *previous, *new = NULL, *target = NULL;\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tconst char *info = NULL;\n\tint error = 0;\n\n\t/*\n\t * Fail explicitly requested domain transitions if no_new_privs.\n\t * There is no exception for unconfined as change_hat is not\n\t * available.\n\t */\n\tif (task_no_new_privs(current)) {\n\t\t/* not an apparmor denial per se, so don't log it */\n\t\tAA_DEBUG(\"no_new_privs - change_hat denied\");\n\t\treturn -EPERM;\n\t}\n\n\t/* released below */\n\tcred = get_current_cred();\n\tctx = cred_ctx(cred);\n\tlabel = aa_get_newest_cred_label(cred);\n\tprevious = aa_get_newest_label(ctx->previous);\n\n\tif (unconfined(label)) {\n\t\tinfo = \"unconfined can not change_hat\";\n\t\terror = -EPERM;\n\t\tgoto fail;\n\t}\n\n\tif (count) {\n\t\tnew = change_hat(label, hats, count, flags);\n\t\tAA_BUG(!new);\n\t\tif (IS_ERR(new)) {\n\t\t\terror = PTR_ERR(new);\n\t\t\tnew = NULL;\n\t\t\t/* already audited */\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = may_change_ptraced_domain(new, &info);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tif (flags & AA_CHANGE_TEST)\n\t\t\tgoto out;\n\n\t\ttarget = new;\n\t\terror = aa_set_current_hat(new, token);\n\t\tif (error == -EACCES)\n\t\t\t/* kill task in case of brute force attacks */\n\t\t\tgoto kill;\n\t} else if (previous && !(flags & AA_CHANGE_TEST)) {\n\t\t/* Return to saved label.  Kill task if restore fails\n\t\t * to avoid brute force attacks\n\t\t */\n\t\ttarget = previous;\n\t\terror = aa_restore_previous_label(token);\n\t\tif (error) {\n\t\t\tif (error == -EACCES)\n\t\t\t\tgoto kill;\n\t\t\tgoto fail;\n\t\t}\n\t} /* else ignore @flags && restores when there is no saved profile */\n\nout:\n\taa_put_label(new);\n\taa_put_label(previous);\n\taa_put_label(label);\n\tput_cred(cred);\n\n\treturn error;\n\nkill:\n\tinfo = \"failed token match\";\n\tperms.kill = AA_MAY_CHANGEHAT;\n\nfail:\n\tfn_for_each_in_ns(label, profile,\n\t\taa_audit_file(profile, &perms, OP_CHANGE_HAT,\n\t\t\t      AA_MAY_CHANGEHAT, NULL, NULL, target,\n\t\t\t      GLOBAL_ROOT_UID, info, error));\n\n\tgoto out;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn_for_each_in_ns",
          "args": [
            "label",
            "profile",
            "aa_audit_file(profile, &perms, OP_CHANGE_HAT,\n\t\t\t      AA_MAY_CHANGEHAT, NULL, NULL, target,\n\t\t\t      GLOBAL_ROOT_UID, info, error)"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_audit_file",
          "args": [
            "profile",
            "&perms",
            "OP_CHANGE_HAT",
            "AA_MAY_CHANGEHAT",
            "NULL",
            "NULL",
            "target",
            "GLOBAL_ROOT_UID",
            "info",
            "error"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "103-153",
          "snippet": "int aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "cred"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_restore_previous_label",
          "args": [
            "token"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "aa_restore_previous_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "202-228",
          "snippet": "int aa_restore_previous_label(u64 token)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct cred *new = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\tif (ctx->token != token) {\n\t\tabort_creds(new);\n\t\treturn -EACCES;\n\t}\n\t/* ignore restores when there is no saved label */\n\tif (!ctx->previous) {\n\t\tabort_creds(new);\n\t\treturn 0;\n\t}\n\n\taa_put_label(ctx->label);\n\tctx->label = aa_get_newest_label(ctx->previous);\n\tAA_BUG(!ctx->label);\n\t/* clear exec && prev information when restoring to previous context */\n\taa_clear_task_ctx_trans(ctx);\n\n\tcommit_creds(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nint aa_restore_previous_label(u64 token)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct cred *new = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\tif (ctx->token != token) {\n\t\tabort_creds(new);\n\t\treturn -EACCES;\n\t}\n\t/* ignore restores when there is no saved label */\n\tif (!ctx->previous) {\n\t\tabort_creds(new);\n\t\treturn 0;\n\t}\n\n\taa_put_label(ctx->label);\n\tctx->label = aa_get_newest_label(ctx->previous);\n\tAA_BUG(!ctx->label);\n\t/* clear exec && prev information when restoring to previous context */\n\taa_clear_task_ctx_trans(ctx);\n\n\tcommit_creds(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_set_current_hat",
          "args": [
            "new",
            "token"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "aa_set_current_hat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "164-191",
          "snippet": "int aa_set_current_hat(struct aa_label *label, u64 token)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct cred *new = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tAA_BUG(!label);\n\n\tctx = cred_ctx(new);\n\tif (!ctx->previous) {\n\t\t/* transfer refcount */\n\t\tctx->previous = ctx->label;\n\t\tctx->token = token;\n\t} else if (ctx->token == token) {\n\t\taa_put_label(ctx->label);\n\t} else {\n\t\t/* previous_profile && ctx->token != token */\n\t\tabort_creds(new);\n\t\treturn -EACCES;\n\t}\n\tctx->label = aa_get_newest_label(label);\n\t/* clear exec on switching context */\n\taa_put_label(ctx->onexec);\n\tctx->onexec = NULL;\n\n\tcommit_creds(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nint aa_set_current_hat(struct aa_label *label, u64 token)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct cred *new = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tAA_BUG(!label);\n\n\tctx = cred_ctx(new);\n\tif (!ctx->previous) {\n\t\t/* transfer refcount */\n\t\tctx->previous = ctx->label;\n\t\tctx->token = token;\n\t} else if (ctx->token == token) {\n\t\taa_put_label(ctx->label);\n\t} else {\n\t\t/* previous_profile && ctx->token != token */\n\t\tabort_creds(new);\n\t\treturn -EACCES;\n\t}\n\tctx->label = aa_get_newest_label(label);\n\t/* clear exec on switching context */\n\taa_put_label(ctx->onexec);\n\tctx->onexec = NULL;\n\n\tcommit_creds(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "may_change_ptraced_domain",
          "args": [
            "new",
            "&info"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "may_change_ptraced_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "62-88",
          "snippet": "static int may_change_ptraced_domain(struct aa_label *to_label,\n\t\t\t\t     const char **info)\n{\n\tstruct task_struct *tracer;\n\tstruct aa_label *tracerl = NULL;\n\tint error = 0;\n\n\trcu_read_lock();\n\ttracer = ptrace_parent(current);\n\tif (tracer)\n\t\t/* released below */\n\t\ttracerl = aa_get_task_label(tracer);\n\n\t/* not ptraced */\n\tif (!tracer || unconfined(tracerl))\n\t\tgoto out;\n\n\terror = aa_may_ptrace(tracerl, to_label, PTRACE_MODE_ATTACH);\n\nout:\n\trcu_read_unlock();\n\taa_put_label(tracerl);\n\n\tif (error)\n\t\t*info = \"ptrace prevents transition\";\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int may_change_ptraced_domain(struct aa_label *to_label,\n\t\t\t\t     const char **info)\n{\n\tstruct task_struct *tracer;\n\tstruct aa_label *tracerl = NULL;\n\tint error = 0;\n\n\trcu_read_lock();\n\ttracer = ptrace_parent(current);\n\tif (tracer)\n\t\t/* released below */\n\t\ttracerl = aa_get_task_label(tracer);\n\n\t/* not ptraced */\n\tif (!tracer || unconfined(tracerl))\n\t\tgoto out;\n\n\terror = aa_may_ptrace(tracerl, to_label, PTRACE_MODE_ATTACH);\n\nout:\n\trcu_read_unlock();\n\taa_put_label(tracerl);\n\n\tif (error)\n\t\t*info = \"ptrace prevents transition\";\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!new"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "change_hat",
          "args": [
            "label",
            "hats",
            "count",
            "flags"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "aa_change_hat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "1048-1135",
          "snippet": "int aa_change_hat(const char *hats[], int count, u64 token, int flags)\n{\n\tconst struct cred *cred;\n\tstruct aa_task_ctx *ctx;\n\tstruct aa_label *label, *previous, *new = NULL, *target = NULL;\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tconst char *info = NULL;\n\tint error = 0;\n\n\t/*\n\t * Fail explicitly requested domain transitions if no_new_privs.\n\t * There is no exception for unconfined as change_hat is not\n\t * available.\n\t */\n\tif (task_no_new_privs(current)) {\n\t\t/* not an apparmor denial per se, so don't log it */\n\t\tAA_DEBUG(\"no_new_privs - change_hat denied\");\n\t\treturn -EPERM;\n\t}\n\n\t/* released below */\n\tcred = get_current_cred();\n\tctx = cred_ctx(cred);\n\tlabel = aa_get_newest_cred_label(cred);\n\tprevious = aa_get_newest_label(ctx->previous);\n\n\tif (unconfined(label)) {\n\t\tinfo = \"unconfined can not change_hat\";\n\t\terror = -EPERM;\n\t\tgoto fail;\n\t}\n\n\tif (count) {\n\t\tnew = change_hat(label, hats, count, flags);\n\t\tAA_BUG(!new);\n\t\tif (IS_ERR(new)) {\n\t\t\terror = PTR_ERR(new);\n\t\t\tnew = NULL;\n\t\t\t/* already audited */\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = may_change_ptraced_domain(new, &info);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tif (flags & AA_CHANGE_TEST)\n\t\t\tgoto out;\n\n\t\ttarget = new;\n\t\terror = aa_set_current_hat(new, token);\n\t\tif (error == -EACCES)\n\t\t\t/* kill task in case of brute force attacks */\n\t\t\tgoto kill;\n\t} else if (previous && !(flags & AA_CHANGE_TEST)) {\n\t\t/* Return to saved label.  Kill task if restore fails\n\t\t * to avoid brute force attacks\n\t\t */\n\t\ttarget = previous;\n\t\terror = aa_restore_previous_label(token);\n\t\tif (error) {\n\t\t\tif (error == -EACCES)\n\t\t\t\tgoto kill;\n\t\t\tgoto fail;\n\t\t}\n\t} /* else ignore @flags && restores when there is no saved profile */\n\nout:\n\taa_put_label(new);\n\taa_put_label(previous);\n\taa_put_label(label);\n\tput_cred(cred);\n\n\treturn error;\n\nkill:\n\tinfo = \"failed token match\";\n\tperms.kill = AA_MAY_CHANGEHAT;\n\nfail:\n\tfn_for_each_in_ns(label, profile,\n\t\taa_audit_file(profile, &perms, OP_CHANGE_HAT,\n\t\t\t      AA_MAY_CHANGEHAT, NULL, NULL, target,\n\t\t\t      GLOBAL_ROOT_UID, info, error));\n\n\tgoto out;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "label"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_newest_label",
          "args": [
            "ctx->previous"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "393-414",
          "snippet": "static inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_newest_cred_label",
          "args": [
            "cred"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_cred_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "80-83",
          "snippet": "static inline struct aa_label *aa_get_newest_cred_label(const struct cred *cred)\n{\n\treturn aa_get_newest_label(aa_cred_raw_label(cred));\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *aa_get_newest_cred_label(const struct cred *cred)\n{\n\treturn aa_get_newest_label(aa_cred_raw_label(cred));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "cred"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_cred",
          "args": [],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_DEBUG",
          "args": [
            "\"no_new_privs - change_hat denied\""
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_no_new_privs",
          "args": [
            "current"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nint aa_change_hat(const char *hats[], int count, u64 token, int flags)\n{\n\tconst struct cred *cred;\n\tstruct aa_task_ctx *ctx;\n\tstruct aa_label *label, *previous, *new = NULL, *target = NULL;\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tconst char *info = NULL;\n\tint error = 0;\n\n\t/*\n\t * Fail explicitly requested domain transitions if no_new_privs.\n\t * There is no exception for unconfined as change_hat is not\n\t * available.\n\t */\n\tif (task_no_new_privs(current)) {\n\t\t/* not an apparmor denial per se, so don't log it */\n\t\tAA_DEBUG(\"no_new_privs - change_hat denied\");\n\t\treturn -EPERM;\n\t}\n\n\t/* released below */\n\tcred = get_current_cred();\n\tctx = cred_ctx(cred);\n\tlabel = aa_get_newest_cred_label(cred);\n\tprevious = aa_get_newest_label(ctx->previous);\n\n\tif (unconfined(label)) {\n\t\tinfo = \"unconfined can not change_hat\";\n\t\terror = -EPERM;\n\t\tgoto fail;\n\t}\n\n\tif (count) {\n\t\tnew = change_hat(label, hats, count, flags);\n\t\tAA_BUG(!new);\n\t\tif (IS_ERR(new)) {\n\t\t\terror = PTR_ERR(new);\n\t\t\tnew = NULL;\n\t\t\t/* already audited */\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = may_change_ptraced_domain(new, &info);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tif (flags & AA_CHANGE_TEST)\n\t\t\tgoto out;\n\n\t\ttarget = new;\n\t\terror = aa_set_current_hat(new, token);\n\t\tif (error == -EACCES)\n\t\t\t/* kill task in case of brute force attacks */\n\t\t\tgoto kill;\n\t} else if (previous && !(flags & AA_CHANGE_TEST)) {\n\t\t/* Return to saved label.  Kill task if restore fails\n\t\t * to avoid brute force attacks\n\t\t */\n\t\ttarget = previous;\n\t\terror = aa_restore_previous_label(token);\n\t\tif (error) {\n\t\t\tif (error == -EACCES)\n\t\t\t\tgoto kill;\n\t\t\tgoto fail;\n\t\t}\n\t} /* else ignore @flags && restores when there is no saved profile */\n\nout:\n\taa_put_label(new);\n\taa_put_label(previous);\n\taa_put_label(label);\n\tput_cred(cred);\n\n\treturn error;\n\nkill:\n\tinfo = \"failed token match\";\n\tperms.kill = AA_MAY_CHANGEHAT;\n\nfail:\n\tfn_for_each_in_ns(label, profile,\n\t\taa_audit_file(profile, &perms, OP_CHANGE_HAT,\n\t\t\t      AA_MAY_CHANGEHAT, NULL, NULL, target,\n\t\t\t      GLOBAL_ROOT_UID, info, error));\n\n\tgoto out;\n}"
  },
  {
    "function_name": "change_hat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "935-1029",
    "snippet": "static struct aa_label *change_hat(struct aa_label *label, const char *hats[],\n\t\t\t\t   int count, int flags)\n{\n\tstruct aa_profile *profile, *root, *hat = NULL;\n\tstruct aa_label *new;\n\tstruct label_it it;\n\tbool sibling = false;\n\tconst char *name, *info = NULL;\n\tint i, error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!hats);\n\tAA_BUG(count < 1);\n\n\tif (PROFILE_IS_HAT(labels_profile(label)))\n\t\tsibling = true;\n\n\t/*find first matching hat */\n\tfor (i = 0; i < count && !hat; i++) {\n\t\tname = hats[i];\n\t\tlabel_for_each_in_ns(it, labels_ns(label), label, profile) {\n\t\t\tif (sibling && PROFILE_IS_HAT(profile)) {\n\t\t\t\troot = aa_get_profile_rcu(&profile->parent);\n\t\t\t} else if (!sibling && !PROFILE_IS_HAT(profile)) {\n\t\t\t\troot = aa_get_profile(profile);\n\t\t\t} else {\t/* conflicting change type */\n\t\t\t\tinfo = \"conflicting targets types\";\n\t\t\t\terror = -EPERM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\that = aa_find_child(root, name);\n\t\t\taa_put_profile(root);\n\t\t\tif (!hat) {\n\t\t\t\tif (!COMPLAIN_MODE(profile))\n\t\t\t\t\tgoto outer_continue;\n\t\t\t\t/* complain mode succeed as if hat */\n\t\t\t} else if (!PROFILE_IS_HAT(hat)) {\n\t\t\t\tinfo = \"target not hat\";\n\t\t\t\terror = -EPERM;\n\t\t\t\taa_put_profile(hat);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\taa_put_profile(hat);\n\t\t}\n\t\t/* found a hat for all profiles in ns */\n\t\tgoto build;\nouter_continue:\n\t;\n\t}\n\t/* no hats that match, find appropriate error\n\t *\n\t * In complain mode audit of the failure is based off of the first\n\t * hat supplied.  This is done due how userspace interacts with\n\t * change_hat.\n\t */\n\tname = NULL;\n\tlabel_for_each_in_ns(it, labels_ns(label), label, profile) {\n\t\tif (!list_empty(&profile->base.profiles)) {\n\t\t\tinfo = \"hat not found\";\n\t\t\terror = -ENOENT;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tinfo = \"no hats defined\";\n\terror = -ECHILD;\n\nfail:\n\tlabel_for_each_in_ns(it, labels_ns(label), label, profile) {\n\t\t/*\n\t\t * no target as it has failed to be found or built\n\t\t *\n\t\t * change_hat uses probing and should not log failures\n\t\t * related to missing hats\n\t\t */\n\t\t/* TODO: get rid of GLOBAL_ROOT_UID */\n\t\tif (count > 1 || COMPLAIN_MODE(profile)) {\n\t\t\taa_audit_file(profile, &nullperms, OP_CHANGE_HAT,\n\t\t\t\t      AA_MAY_CHANGEHAT, name, NULL, NULL,\n\t\t\t\t      GLOBAL_ROOT_UID, info, error);\n\t\t}\n\t}\n\treturn ERR_PTR(error);\n\nbuild:\n\tnew = fn_label_build_in_ns(label, profile, GFP_KERNEL,\n\t\t\t\t   build_change_hat(profile, name, sibling),\n\t\t\t\t   aa_get_label(&profile->label));\n\tif (!new) {\n\t\tinfo = \"label build failed\";\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t} /* else if (IS_ERR) build_change_hat has logged error so return new */\n\n\treturn new;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn_label_build_in_ns",
          "args": [
            "label",
            "profile",
            "GFP_KERNEL",
            "build_change_hat(profile, name, sibling)",
            "aa_get_label(&profile->label)"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "&profile->label"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_change_hat",
          "args": [
            "profile",
            "name",
            "sibling"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "build_change_hat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "887-929",
          "snippet": "static struct aa_label *build_change_hat(struct aa_profile *profile,\n\t\t\t\t\t const char *name, bool sibling)\n{\n\tstruct aa_profile *root, *hat = NULL;\n\tconst char *info = NULL;\n\tint error = 0;\n\n\tif (sibling && PROFILE_IS_HAT(profile)) {\n\t\troot = aa_get_profile_rcu(&profile->parent);\n\t} else if (!sibling && !PROFILE_IS_HAT(profile)) {\n\t\troot = aa_get_profile(profile);\n\t} else {\n\t\tinfo = \"conflicting target types\";\n\t\terror = -EPERM;\n\t\tgoto audit;\n\t}\n\n\that = aa_find_child(root, name);\n\tif (!hat) {\n\t\terror = -ENOENT;\n\t\tif (COMPLAIN_MODE(profile)) {\n\t\t\that = aa_new_null_profile(profile, true, name,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!hat) {\n\t\t\t\tinfo = \"failed null profile create\";\n\t\t\t\terror = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\taa_put_profile(root);\n\naudit:\n\taa_audit_file(profile, &nullperms, OP_CHANGE_HAT, AA_MAY_CHANGEHAT,\n\t\t      name, hat ? hat->base.hname : NULL,\n\t\t      hat ? &hat->label : NULL, GLOBAL_ROOT_UID, NULL,\n\t\t      error);\n\tif (!hat || (error && error != -ENOENT))\n\t\treturn ERR_PTR(error);\n\t/* if hat && error - complain mode, already audited and we adjust for\n\t * complain mode allow by returning hat->label\n\t */\n\treturn &hat->label;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_label *build_change_hat(struct aa_profile *profile,\n\t\t\t\t\t const char *name, bool sibling)\n{\n\tstruct aa_profile *root, *hat = NULL;\n\tconst char *info = NULL;\n\tint error = 0;\n\n\tif (sibling && PROFILE_IS_HAT(profile)) {\n\t\troot = aa_get_profile_rcu(&profile->parent);\n\t} else if (!sibling && !PROFILE_IS_HAT(profile)) {\n\t\troot = aa_get_profile(profile);\n\t} else {\n\t\tinfo = \"conflicting target types\";\n\t\terror = -EPERM;\n\t\tgoto audit;\n\t}\n\n\that = aa_find_child(root, name);\n\tif (!hat) {\n\t\terror = -ENOENT;\n\t\tif (COMPLAIN_MODE(profile)) {\n\t\t\that = aa_new_null_profile(profile, true, name,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!hat) {\n\t\t\t\tinfo = \"failed null profile create\";\n\t\t\t\terror = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\taa_put_profile(root);\n\naudit:\n\taa_audit_file(profile, &nullperms, OP_CHANGE_HAT, AA_MAY_CHANGEHAT,\n\t\t      name, hat ? hat->base.hname : NULL,\n\t\t      hat ? &hat->label : NULL, GLOBAL_ROOT_UID, NULL,\n\t\t      error);\n\tif (!hat || (error && error != -ENOENT))\n\t\treturn ERR_PTR(error);\n\t/* if hat && error - complain mode, already audited and we adjust for\n\t * complain mode allow by returning hat->label\n\t */\n\treturn &hat->label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_audit_file",
          "args": [
            "profile",
            "&nullperms",
            "OP_CHANGE_HAT",
            "AA_MAY_CHANGEHAT",
            "name",
            "NULL",
            "NULL",
            "GLOBAL_ROOT_UID",
            "info",
            "error"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "103-153",
          "snippet": "int aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "COMPLAIN_MODE",
          "args": [
            "profile"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_for_each_in_ns",
          "args": [
            "it",
            "labels_ns(label)",
            "label",
            "profile"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&profile->base.profiles"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_for_each_in_ns",
          "args": [
            "it",
            "labels_ns(label)",
            "label",
            "profile"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_profile",
          "args": [
            "hat"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "277-281",
          "snippet": "static inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROFILE_IS_HAT",
          "args": [
            "hat"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPLAIN_MODE",
          "args": [
            "profile"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_find_child",
          "args": [
            "root",
            "name"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "aa_find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "331-343",
          "snippet": "struct aa_profile *aa_find_child(struct aa_profile *parent, const char *name)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tdo {\n\t\tprofile = __find_child(&parent->base.profiles, name);\n\t} while (profile && !aa_get_profile_not0(profile));\n\trcu_read_unlock();\n\n\t/* refcount released by caller */\n\treturn profile;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct aa_profile *aa_find_child(struct aa_profile *parent, const char *name)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tdo {\n\t\tprofile = __find_child(&parent->base.profiles, name);\n\t} while (profile && !aa_get_profile_not0(profile));\n\trcu_read_unlock();\n\n\t/* refcount released by caller */\n\treturn profile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_profile",
          "args": [
            "profile"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_profile_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "260-271",
          "snippet": "static inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROFILE_IS_HAT",
          "args": [
            "profile"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROFILE_IS_HAT",
          "args": [
            "profile"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_for_each_in_ns",
          "args": [
            "it",
            "labels_ns(label)",
            "label",
            "profile"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROFILE_IS_HAT",
          "args": [
            "labels_profile(label)"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_profile",
          "args": [
            "label"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "count < 1"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!hats"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_label *change_hat(struct aa_label *label, const char *hats[],\n\t\t\t\t   int count, int flags)\n{\n\tstruct aa_profile *profile, *root, *hat = NULL;\n\tstruct aa_label *new;\n\tstruct label_it it;\n\tbool sibling = false;\n\tconst char *name, *info = NULL;\n\tint i, error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!hats);\n\tAA_BUG(count < 1);\n\n\tif (PROFILE_IS_HAT(labels_profile(label)))\n\t\tsibling = true;\n\n\t/*find first matching hat */\n\tfor (i = 0; i < count && !hat; i++) {\n\t\tname = hats[i];\n\t\tlabel_for_each_in_ns(it, labels_ns(label), label, profile) {\n\t\t\tif (sibling && PROFILE_IS_HAT(profile)) {\n\t\t\t\troot = aa_get_profile_rcu(&profile->parent);\n\t\t\t} else if (!sibling && !PROFILE_IS_HAT(profile)) {\n\t\t\t\troot = aa_get_profile(profile);\n\t\t\t} else {\t/* conflicting change type */\n\t\t\t\tinfo = \"conflicting targets types\";\n\t\t\t\terror = -EPERM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\that = aa_find_child(root, name);\n\t\t\taa_put_profile(root);\n\t\t\tif (!hat) {\n\t\t\t\tif (!COMPLAIN_MODE(profile))\n\t\t\t\t\tgoto outer_continue;\n\t\t\t\t/* complain mode succeed as if hat */\n\t\t\t} else if (!PROFILE_IS_HAT(hat)) {\n\t\t\t\tinfo = \"target not hat\";\n\t\t\t\terror = -EPERM;\n\t\t\t\taa_put_profile(hat);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\taa_put_profile(hat);\n\t\t}\n\t\t/* found a hat for all profiles in ns */\n\t\tgoto build;\nouter_continue:\n\t;\n\t}\n\t/* no hats that match, find appropriate error\n\t *\n\t * In complain mode audit of the failure is based off of the first\n\t * hat supplied.  This is done due how userspace interacts with\n\t * change_hat.\n\t */\n\tname = NULL;\n\tlabel_for_each_in_ns(it, labels_ns(label), label, profile) {\n\t\tif (!list_empty(&profile->base.profiles)) {\n\t\t\tinfo = \"hat not found\";\n\t\t\terror = -ENOENT;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tinfo = \"no hats defined\";\n\terror = -ECHILD;\n\nfail:\n\tlabel_for_each_in_ns(it, labels_ns(label), label, profile) {\n\t\t/*\n\t\t * no target as it has failed to be found or built\n\t\t *\n\t\t * change_hat uses probing and should not log failures\n\t\t * related to missing hats\n\t\t */\n\t\t/* TODO: get rid of GLOBAL_ROOT_UID */\n\t\tif (count > 1 || COMPLAIN_MODE(profile)) {\n\t\t\taa_audit_file(profile, &nullperms, OP_CHANGE_HAT,\n\t\t\t\t      AA_MAY_CHANGEHAT, name, NULL, NULL,\n\t\t\t\t      GLOBAL_ROOT_UID, info, error);\n\t\t}\n\t}\n\treturn ERR_PTR(error);\n\nbuild:\n\tnew = fn_label_build_in_ns(label, profile, GFP_KERNEL,\n\t\t\t\t   build_change_hat(profile, name, sibling),\n\t\t\t\t   aa_get_label(&profile->label));\n\tif (!new) {\n\t\tinfo = \"label build failed\";\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t} /* else if (IS_ERR) build_change_hat has logged error so return new */\n\n\treturn new;\n}"
  },
  {
    "function_name": "build_change_hat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "887-929",
    "snippet": "static struct aa_label *build_change_hat(struct aa_profile *profile,\n\t\t\t\t\t const char *name, bool sibling)\n{\n\tstruct aa_profile *root, *hat = NULL;\n\tconst char *info = NULL;\n\tint error = 0;\n\n\tif (sibling && PROFILE_IS_HAT(profile)) {\n\t\troot = aa_get_profile_rcu(&profile->parent);\n\t} else if (!sibling && !PROFILE_IS_HAT(profile)) {\n\t\troot = aa_get_profile(profile);\n\t} else {\n\t\tinfo = \"conflicting target types\";\n\t\terror = -EPERM;\n\t\tgoto audit;\n\t}\n\n\that = aa_find_child(root, name);\n\tif (!hat) {\n\t\terror = -ENOENT;\n\t\tif (COMPLAIN_MODE(profile)) {\n\t\t\that = aa_new_null_profile(profile, true, name,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!hat) {\n\t\t\t\tinfo = \"failed null profile create\";\n\t\t\t\terror = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\taa_put_profile(root);\n\naudit:\n\taa_audit_file(profile, &nullperms, OP_CHANGE_HAT, AA_MAY_CHANGEHAT,\n\t\t      name, hat ? hat->base.hname : NULL,\n\t\t      hat ? &hat->label : NULL, GLOBAL_ROOT_UID, NULL,\n\t\t      error);\n\tif (!hat || (error && error != -ENOENT))\n\t\treturn ERR_PTR(error);\n\t/* if hat && error - complain mode, already audited and we adjust for\n\t * complain mode allow by returning hat->label\n\t */\n\treturn &hat->label;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_audit_file",
          "args": [
            "profile",
            "&nullperms",
            "OP_CHANGE_HAT",
            "AA_MAY_CHANGEHAT",
            "name",
            "hat ? hat->base.hname : NULL",
            "hat ? &hat->label : NULL",
            "GLOBAL_ROOT_UID",
            "NULL",
            "error"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "103-153",
          "snippet": "int aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_put_profile",
          "args": [
            "root"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "277-281",
          "snippet": "static inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_new_null_profile",
          "args": [
            "profile",
            "true",
            "name",
            "GFP_KERNEL"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "aa_new_null_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "500-568",
          "snippet": "struct aa_profile *aa_new_null_profile(struct aa_profile *parent, bool hat,\n\t\t\t\t       const char *base, gfp_t gfp)\n{\n\tstruct aa_profile *p, *profile;\n\tconst char *bname;\n\tchar *name = NULL;\n\n\tAA_BUG(!parent);\n\n\tif (base) {\n\t\tname = kmalloc(strlen(parent->base.hname) + 8 + strlen(base),\n\t\t\t       gfp);\n\t\tif (name) {\n\t\t\tsprintf(name, \"%s//null-%s\", parent->base.hname, base);\n\t\t\tgoto name;\n\t\t}\n\t\t/* fall through to try shorter uniq */\n\t}\n\n\tname = kmalloc(strlen(parent->base.hname) + 2 + 7 + 8, gfp);\n\tif (!name)\n\t\treturn NULL;\n\tsprintf(name, \"%s//null-%x\", parent->base.hname,\n\t\tatomic_inc_return(&parent->ns->uniq_null));\n\nname:\n\t/* lookup to see if this is a dup creation */\n\tbname = basename(name);\n\tprofile = aa_find_child(parent, bname);\n\tif (profile)\n\t\tgoto out;\n\n\tprofile = aa_alloc_profile(name, NULL, gfp);\n\tif (!profile)\n\t\tgoto fail;\n\n\tprofile->mode = APPARMOR_COMPLAIN;\n\tprofile->label.flags |= FLAG_NULL;\n\tif (hat)\n\t\tprofile->label.flags |= FLAG_HAT;\n\tprofile->path_flags = parent->path_flags;\n\n\t/* released on free_profile */\n\trcu_assign_pointer(profile->parent, aa_get_profile(parent));\n\tprofile->ns = aa_get_ns(parent->ns);\n\tprofile->file.dfa = aa_get_dfa(nulldfa);\n\tprofile->policy.dfa = aa_get_dfa(nulldfa);\n\n\tmutex_lock_nested(&profile->ns->lock, profile->ns->level);\n\tp = __find_child(&parent->base.profiles, bname);\n\tif (p) {\n\t\taa_free_profile(profile);\n\t\tprofile = aa_get_profile(p);\n\t} else {\n\t\t__add_profile(&parent->base.profiles, profile);\n\t}\n\tmutex_unlock(&profile->ns->lock);\n\n\t/* refcount released by caller */\nout:\n\tkfree(name);\n\n\treturn profile;\n\nfail:\n\tkfree(name);\n\taa_free_profile(profile);\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct aa_profile *aa_new_null_profile(struct aa_profile *parent, bool hat,\n\t\t\t\t       const char *base, gfp_t gfp)\n{\n\tstruct aa_profile *p, *profile;\n\tconst char *bname;\n\tchar *name = NULL;\n\n\tAA_BUG(!parent);\n\n\tif (base) {\n\t\tname = kmalloc(strlen(parent->base.hname) + 8 + strlen(base),\n\t\t\t       gfp);\n\t\tif (name) {\n\t\t\tsprintf(name, \"%s//null-%s\", parent->base.hname, base);\n\t\t\tgoto name;\n\t\t}\n\t\t/* fall through to try shorter uniq */\n\t}\n\n\tname = kmalloc(strlen(parent->base.hname) + 2 + 7 + 8, gfp);\n\tif (!name)\n\t\treturn NULL;\n\tsprintf(name, \"%s//null-%x\", parent->base.hname,\n\t\tatomic_inc_return(&parent->ns->uniq_null));\n\nname:\n\t/* lookup to see if this is a dup creation */\n\tbname = basename(name);\n\tprofile = aa_find_child(parent, bname);\n\tif (profile)\n\t\tgoto out;\n\n\tprofile = aa_alloc_profile(name, NULL, gfp);\n\tif (!profile)\n\t\tgoto fail;\n\n\tprofile->mode = APPARMOR_COMPLAIN;\n\tprofile->label.flags |= FLAG_NULL;\n\tif (hat)\n\t\tprofile->label.flags |= FLAG_HAT;\n\tprofile->path_flags = parent->path_flags;\n\n\t/* released on free_profile */\n\trcu_assign_pointer(profile->parent, aa_get_profile(parent));\n\tprofile->ns = aa_get_ns(parent->ns);\n\tprofile->file.dfa = aa_get_dfa(nulldfa);\n\tprofile->policy.dfa = aa_get_dfa(nulldfa);\n\n\tmutex_lock_nested(&profile->ns->lock, profile->ns->level);\n\tp = __find_child(&parent->base.profiles, bname);\n\tif (p) {\n\t\taa_free_profile(profile);\n\t\tprofile = aa_get_profile(p);\n\t} else {\n\t\t__add_profile(&parent->base.profiles, profile);\n\t}\n\tmutex_unlock(&profile->ns->lock);\n\n\t/* refcount released by caller */\nout:\n\tkfree(name);\n\n\treturn profile;\n\nfail:\n\tkfree(name);\n\taa_free_profile(profile);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COMPLAIN_MODE",
          "args": [
            "profile"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_find_child",
          "args": [
            "root",
            "name"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "aa_find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "331-343",
          "snippet": "struct aa_profile *aa_find_child(struct aa_profile *parent, const char *name)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tdo {\n\t\tprofile = __find_child(&parent->base.profiles, name);\n\t} while (profile && !aa_get_profile_not0(profile));\n\trcu_read_unlock();\n\n\t/* refcount released by caller */\n\treturn profile;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct aa_profile *aa_find_child(struct aa_profile *parent, const char *name)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tdo {\n\t\tprofile = __find_child(&parent->base.profiles, name);\n\t} while (profile && !aa_get_profile_not0(profile));\n\trcu_read_unlock();\n\n\t/* refcount released by caller */\n\treturn profile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_profile",
          "args": [
            "profile"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_profile_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "260-271",
          "snippet": "static inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROFILE_IS_HAT",
          "args": [
            "profile"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROFILE_IS_HAT",
          "args": [
            "profile"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_label *build_change_hat(struct aa_profile *profile,\n\t\t\t\t\t const char *name, bool sibling)\n{\n\tstruct aa_profile *root, *hat = NULL;\n\tconst char *info = NULL;\n\tint error = 0;\n\n\tif (sibling && PROFILE_IS_HAT(profile)) {\n\t\troot = aa_get_profile_rcu(&profile->parent);\n\t} else if (!sibling && !PROFILE_IS_HAT(profile)) {\n\t\troot = aa_get_profile(profile);\n\t} else {\n\t\tinfo = \"conflicting target types\";\n\t\terror = -EPERM;\n\t\tgoto audit;\n\t}\n\n\that = aa_find_child(root, name);\n\tif (!hat) {\n\t\terror = -ENOENT;\n\t\tif (COMPLAIN_MODE(profile)) {\n\t\t\that = aa_new_null_profile(profile, true, name,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!hat) {\n\t\t\t\tinfo = \"failed null profile create\";\n\t\t\t\terror = -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\taa_put_profile(root);\n\naudit:\n\taa_audit_file(profile, &nullperms, OP_CHANGE_HAT, AA_MAY_CHANGEHAT,\n\t\t      name, hat ? hat->base.hname : NULL,\n\t\t      hat ? &hat->label : NULL, GLOBAL_ROOT_UID, NULL,\n\t\t      error);\n\tif (!hat || (error && error != -ENOENT))\n\t\treturn ERR_PTR(error);\n\t/* if hat && error - complain mode, already audited and we adjust for\n\t * complain mode allow by returning hat->label\n\t */\n\treturn &hat->label;\n}"
  },
  {
    "function_name": "apparmor_bprm_set_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "779-876",
    "snippet": "int apparmor_bprm_set_creds(struct linux_binprm *bprm)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct aa_label *label, *new = NULL;\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tconst char *info = NULL;\n\tint error = 0;\n\tbool unsafe = false;\n\tstruct path_cond cond = {\n\t\tfile_inode(bprm->file)->i_uid,\n\t\tfile_inode(bprm->file)->i_mode\n\t};\n\n\tif (bprm->called_set_creds)\n\t\treturn 0;\n\n\tctx = cred_ctx(bprm->cred);\n\tAA_BUG(!ctx);\n\n\tlabel = aa_get_newest_label(ctx->label);\n\n\t/* buffer freed below, name is pointer into buffer */\n\tget_buffers(buffer);\n\t/* Test for onexec first as onexec override other x transitions. */\n\tif (ctx->onexec)\n\t\tnew = handle_onexec(label, ctx->onexec, ctx->token,\n\t\t\t\t    bprm, buffer, &cond, &unsafe);\n\telse\n\t\tnew = fn_label_build(label, profile, GFP_ATOMIC,\n\t\t\t\tprofile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   &cond, &unsafe));\n\n\tAA_BUG(!new);\n\tif (IS_ERR(new)) {\n\t\terror = PTR_ERR(new);\n\t\tgoto done;\n\t} else if (!new) {\n\t\terror = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t/* TODO: Add ns level no_new_privs subset test */\n\n\tif (bprm->unsafe & LSM_UNSAFE_SHARE) {\n\t\t/* FIXME: currently don't mediate shared state */\n\t\t;\n\t}\n\n\tif (bprm->unsafe & (LSM_UNSAFE_PTRACE)) {\n\t\t/* TODO: test needs to be profile of label to new */\n\t\terror = may_change_ptraced_domain(new, &info);\n\t\tif (error)\n\t\t\tgoto audit;\n\t}\n\n\tif (unsafe) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"scrubbing environment variables for %s \"\n\t\t\t\t   \"label=\", bprm->filename);\n\t\t\taa_label_printk(new, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\tbprm->secureexec = 1;\n\t}\n\n\tif (label->proxy != new->proxy) {\n\t\t/* when transitioning clear unsafe personality bits */\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: clearing unsafe personality \"\n\t\t\t\t   \"bits. %s label=\", bprm->filename);\n\t\t\taa_label_printk(new, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t}\n\taa_put_label(ctx->label);\n\t/* transfer reference, released when ctx is freed */\n\tctx->label = new;\n\ndone:\n\t/* clear out temporary/transitional state from the context */\n\taa_clear_task_ctx_trans(ctx);\n\n\taa_put_label(label);\n\tput_buffers(buffer);\n\n\treturn error;\n\naudit:\n\terror = fn_for_each(label, profile,\n\t\t\taa_audit_file(profile, &nullperms, OP_EXEC, MAY_EXEC,\n\t\t\t\t      bprm->filename, NULL, new,\n\t\t\t\t      file_inode(bprm->file)->i_uid, info,\n\t\t\t\t      error));\n\taa_put_label(new);\n\tgoto done;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "new"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn_for_each",
          "args": [
            "label",
            "profile",
            "aa_audit_file(profile, &nullperms, OP_EXEC, MAY_EXEC,\n\t\t\t\t      bprm->filename, NULL, new,\n\t\t\t\t      file_inode(bprm->file)->i_uid, info,\n\t\t\t\t      error)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_audit_file",
          "args": [
            "profile",
            "&nullperms",
            "OP_EXEC",
            "MAY_EXEC",
            "bprm->filename",
            "NULL",
            "new",
            "file_inode(bprm->file)->i_uid",
            "info",
            "error"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "103-153",
          "snippet": "int aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "bprm->file"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_buffers",
          "args": [
            "buffer"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_clear_task_ctx_trans",
          "args": [
            "ctx"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "aa_clear_task_ctx_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "220-227",
          "snippet": "static inline void aa_clear_task_ctx_trans(struct aa_task_ctx *ctx)\n{\n\taa_put_label(ctx->previous);\n\taa_put_label(ctx->onexec);\n\tctx->previous = NULL;\n\tctx->onexec = NULL;\n\tctx->token = 0;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline void aa_clear_task_ctx_trans(struct aa_task_ctx *ctx)\n{\n\taa_put_label(ctx->previous);\n\taa_put_label(ctx->onexec);\n\tctx->previous = NULL;\n\tctx->onexec = NULL;\n\tctx->token = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_printk",
          "args": [
            "\"\\n\""
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_printk",
          "args": [
            "new",
            "GFP_ATOMIC"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_printk",
          "args": [
            "\"apparmor: clearing unsafe personality \"\n\t\t\t\t   \"bits. %s label=\"",
            "bprm->filename"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_printk",
          "args": [
            "\"\\n\""
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_printk",
          "args": [
            "\"scrubbing environment variables for %s \"\n\t\t\t\t   \"label=\"",
            "bprm->filename"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "may_change_ptraced_domain",
          "args": [
            "new",
            "&info"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "may_change_ptraced_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "62-88",
          "snippet": "static int may_change_ptraced_domain(struct aa_label *to_label,\n\t\t\t\t     const char **info)\n{\n\tstruct task_struct *tracer;\n\tstruct aa_label *tracerl = NULL;\n\tint error = 0;\n\n\trcu_read_lock();\n\ttracer = ptrace_parent(current);\n\tif (tracer)\n\t\t/* released below */\n\t\ttracerl = aa_get_task_label(tracer);\n\n\t/* not ptraced */\n\tif (!tracer || unconfined(tracerl))\n\t\tgoto out;\n\n\terror = aa_may_ptrace(tracerl, to_label, PTRACE_MODE_ATTACH);\n\nout:\n\trcu_read_unlock();\n\taa_put_label(tracerl);\n\n\tif (error)\n\t\t*info = \"ptrace prevents transition\";\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int may_change_ptraced_domain(struct aa_label *to_label,\n\t\t\t\t     const char **info)\n{\n\tstruct task_struct *tracer;\n\tstruct aa_label *tracerl = NULL;\n\tint error = 0;\n\n\trcu_read_lock();\n\ttracer = ptrace_parent(current);\n\tif (tracer)\n\t\t/* released below */\n\t\ttracerl = aa_get_task_label(tracer);\n\n\t/* not ptraced */\n\tif (!tracer || unconfined(tracerl))\n\t\tgoto out;\n\n\terror = aa_may_ptrace(tracerl, to_label, PTRACE_MODE_ATTACH);\n\nout:\n\trcu_read_unlock();\n\taa_put_label(tracerl);\n\n\tif (error)\n\t\t*info = \"ptrace prevents transition\";\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!new"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_label_build",
          "args": [
            "label",
            "profile",
            "GFP_ATOMIC",
            "profile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   &cond, &unsafe)"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_transition",
          "args": [
            "profile",
            "bprm",
            "buffer",
            "&cond",
            "&unsafe"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "profile_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "508-630",
          "snippet": "static struct aa_label *profile_transition(struct aa_profile *profile,\n\t\t\t\t\t   const struct linux_binprm *bprm,\n\t\t\t\t\t   char *buffer, struct path_cond *cond,\n\t\t\t\t\t   bool *secure_exec)\n{\n\tstruct aa_label *new = NULL;\n\tconst char *info = NULL, *name = NULL, *target = NULL;\n\tunsigned int state = profile->file.start;\n\tstruct aa_perms perms = {};\n\tbool nonewprivs = false;\n\tint error = 0;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(&bprm->file->f_path, profile->path_flags, buffer,\n\t\t\t     &name, &info, profile->disconnected);\n\tif (error) {\n\t\tif (profile_unconfined(profile) ||\n\t\t    (profile->label.flags & FLAG_IX_ON_NAME_ERROR)) {\n\t\t\tAA_DEBUG(\"name lookup ix on error\");\n\t\t\terror = 0;\n\t\t\tnew = aa_get_newest_label(&profile->label);\n\t\t}\n\t\tname = bprm->filename;\n\t\tgoto audit;\n\t}\n\n\tif (profile_unconfined(profile)) {\n\t\tnew = find_attach(profile->ns, &profile->ns->base.profiles,\n\t\t\t\t  name, &info);\n\t\tif (new) {\n\t\t\tAA_DEBUG(\"unconfined attached to new label\");\n\t\t\treturn new;\n\t\t}\n\t\tAA_DEBUG(\"unconfined exec no attachment\");\n\t\treturn aa_get_newest_label(&profile->label);\n\t}\n\n\t/* find exec permissions for name */\n\tstate = aa_str_perms(profile->file.dfa, state, name, cond, &perms);\n\tif (perms.allow & MAY_EXEC) {\n\t\t/* exec permission determine how to transition */\n\t\tnew = x_to_label(profile, name, perms.xindex, &target, &info);\n\t\tif (new && new->proxy == profile->label.proxy && info) {\n\t\t\t/* hack ix fallback - improve how this is detected */\n\t\t\tgoto audit;\n\t\t} else if (!new) {\n\t\t\terror = -EACCES;\n\t\t\tinfo = \"profile transition not found\";\n\t\t\t/* remove MAY_EXEC to audit as failure */\n\t\t\tperms.allow &= ~MAY_EXEC;\n\t\t}\n\t} else if (COMPLAIN_MODE(profile)) {\n\t\t/* no exec permission - learning mode */\n\t\tstruct aa_profile *new_profile = NULL;\n\t\tchar *n = kstrdup(name, GFP_ATOMIC);\n\n\t\tif (n) {\n\t\t\t/* name is ptr into buffer */\n\t\t\tlong pos = name - buffer;\n\t\t\t/* break per cpu buffer hold */\n\t\t\tput_buffers(buffer);\n\t\t\tnew_profile = aa_new_null_profile(profile, false, n,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tget_buffers(buffer);\n\t\t\tname = buffer + pos;\n\t\t\tstrcpy((char *)name, n);\n\t\t\tkfree(n);\n\t\t}\n\t\tif (!new_profile) {\n\t\t\terror = -ENOMEM;\n\t\t\tinfo = \"could not create null profile\";\n\t\t} else {\n\t\t\terror = -EACCES;\n\t\t\tnew = &new_profile->label;\n\t\t}\n\t\tperms.xindex |= AA_X_UNSAFE;\n\t} else\n\t\t/* fail exec */\n\t\terror = -EACCES;\n\n\tif (!new)\n\t\tgoto audit;\n\n\t/* Policy has specified a domain transitions. if no_new_privs and\n\t * confined and not transitioning to the current domain fail.\n\t *\n\t * NOTE: Domain transitions from unconfined and to stritly stacked\n\t * subsets are allowed even when no_new_privs is set because this\n\t * aways results in a further reduction of permissions.\n\t */\n\tif ((bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS) &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(new, &profile->label)) {\n\t\terror = -EPERM;\n\t\tinfo = \"no new privs\";\n\t\tnonewprivs = true;\n\t\tperms.allow &= ~MAY_EXEC;\n\t\tgoto audit;\n\t}\n\n\tif (!(perms.xindex & AA_X_UNSAFE)) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: scrubbing environment variables\"\n\t\t\t\t   \" for %s profile=\", name);\n\t\t\taa_label_printk(new, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\t*secure_exec = true;\n\t}\n\naudit:\n\taa_audit_file(profile, &perms, OP_EXEC, MAY_EXEC, name, target, new,\n\t\t      cond->uid, info, error);\n\tif (!new || nonewprivs) {\n\t\taa_put_label(new);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn new;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_label *profile_transition(struct aa_profile *profile,\n\t\t\t\t\t   const struct linux_binprm *bprm,\n\t\t\t\t\t   char *buffer, struct path_cond *cond,\n\t\t\t\t\t   bool *secure_exec)\n{\n\tstruct aa_label *new = NULL;\n\tconst char *info = NULL, *name = NULL, *target = NULL;\n\tunsigned int state = profile->file.start;\n\tstruct aa_perms perms = {};\n\tbool nonewprivs = false;\n\tint error = 0;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(&bprm->file->f_path, profile->path_flags, buffer,\n\t\t\t     &name, &info, profile->disconnected);\n\tif (error) {\n\t\tif (profile_unconfined(profile) ||\n\t\t    (profile->label.flags & FLAG_IX_ON_NAME_ERROR)) {\n\t\t\tAA_DEBUG(\"name lookup ix on error\");\n\t\t\terror = 0;\n\t\t\tnew = aa_get_newest_label(&profile->label);\n\t\t}\n\t\tname = bprm->filename;\n\t\tgoto audit;\n\t}\n\n\tif (profile_unconfined(profile)) {\n\t\tnew = find_attach(profile->ns, &profile->ns->base.profiles,\n\t\t\t\t  name, &info);\n\t\tif (new) {\n\t\t\tAA_DEBUG(\"unconfined attached to new label\");\n\t\t\treturn new;\n\t\t}\n\t\tAA_DEBUG(\"unconfined exec no attachment\");\n\t\treturn aa_get_newest_label(&profile->label);\n\t}\n\n\t/* find exec permissions for name */\n\tstate = aa_str_perms(profile->file.dfa, state, name, cond, &perms);\n\tif (perms.allow & MAY_EXEC) {\n\t\t/* exec permission determine how to transition */\n\t\tnew = x_to_label(profile, name, perms.xindex, &target, &info);\n\t\tif (new && new->proxy == profile->label.proxy && info) {\n\t\t\t/* hack ix fallback - improve how this is detected */\n\t\t\tgoto audit;\n\t\t} else if (!new) {\n\t\t\terror = -EACCES;\n\t\t\tinfo = \"profile transition not found\";\n\t\t\t/* remove MAY_EXEC to audit as failure */\n\t\t\tperms.allow &= ~MAY_EXEC;\n\t\t}\n\t} else if (COMPLAIN_MODE(profile)) {\n\t\t/* no exec permission - learning mode */\n\t\tstruct aa_profile *new_profile = NULL;\n\t\tchar *n = kstrdup(name, GFP_ATOMIC);\n\n\t\tif (n) {\n\t\t\t/* name is ptr into buffer */\n\t\t\tlong pos = name - buffer;\n\t\t\t/* break per cpu buffer hold */\n\t\t\tput_buffers(buffer);\n\t\t\tnew_profile = aa_new_null_profile(profile, false, n,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tget_buffers(buffer);\n\t\t\tname = buffer + pos;\n\t\t\tstrcpy((char *)name, n);\n\t\t\tkfree(n);\n\t\t}\n\t\tif (!new_profile) {\n\t\t\terror = -ENOMEM;\n\t\t\tinfo = \"could not create null profile\";\n\t\t} else {\n\t\t\terror = -EACCES;\n\t\t\tnew = &new_profile->label;\n\t\t}\n\t\tperms.xindex |= AA_X_UNSAFE;\n\t} else\n\t\t/* fail exec */\n\t\terror = -EACCES;\n\n\tif (!new)\n\t\tgoto audit;\n\n\t/* Policy has specified a domain transitions. if no_new_privs and\n\t * confined and not transitioning to the current domain fail.\n\t *\n\t * NOTE: Domain transitions from unconfined and to stritly stacked\n\t * subsets are allowed even when no_new_privs is set because this\n\t * aways results in a further reduction of permissions.\n\t */\n\tif ((bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS) &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(new, &profile->label)) {\n\t\terror = -EPERM;\n\t\tinfo = \"no new privs\";\n\t\tnonewprivs = true;\n\t\tperms.allow &= ~MAY_EXEC;\n\t\tgoto audit;\n\t}\n\n\tif (!(perms.xindex & AA_X_UNSAFE)) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: scrubbing environment variables\"\n\t\t\t\t   \" for %s profile=\", name);\n\t\t\taa_label_printk(new, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\t*secure_exec = true;\n\t}\n\naudit:\n\taa_audit_file(profile, &perms, OP_EXEC, MAY_EXEC, name, target, new,\n\t\t      cond->uid, info, error);\n\tif (!new || nonewprivs) {\n\t\taa_put_label(new);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_onexec",
          "args": [
            "label",
            "ctx->onexec",
            "ctx->token",
            "bprm",
            "buffer",
            "&cond",
            "&unsafe"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "handle_onexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "719-769",
          "snippet": "static struct aa_label *handle_onexec(struct aa_label *label,\n\t\t\t\t      struct aa_label *onexec, bool stack,\n\t\t\t\t      const struct linux_binprm *bprm,\n\t\t\t\t      char *buffer, struct path_cond *cond,\n\t\t\t\t      bool *unsafe)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *new;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!onexec);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\tif (!stack) {\n\t\terror = fn_for_each_in_ns(label, profile,\n\t\t\t\tprofile_onexec(profile, onexec, stack,\n\t\t\t\t\t       bprm, buffer, cond, unsafe));\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tnew = fn_label_build_in_ns(label, profile, GFP_ATOMIC,\n\t\t\t\taa_get_newest_label(onexec),\n\t\t\t\tprofile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   cond, unsafe));\n\n\t} else {\n\t\t/* TODO: determine how much we want to losen this */\n\t\terror = fn_for_each_in_ns(label, profile,\n\t\t\t\tprofile_onexec(profile, onexec, stack, bprm,\n\t\t\t\t\t       buffer, cond, unsafe));\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tnew = fn_label_build_in_ns(label, profile, GFP_ATOMIC,\n\t\t\t\taa_label_merge(&profile->label, onexec,\n\t\t\t\t\t       GFP_ATOMIC),\n\t\t\t\tprofile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   cond, unsafe));\n\t}\n\n\tif (new)\n\t\treturn new;\n\n\t/* TODO: get rid of GLOBAL_ROOT_UID */\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\taa_audit_file(profile, &nullperms, OP_CHANGE_ONEXEC,\n\t\t\t\t      AA_MAY_ONEXEC, bprm->filename, NULL,\n\t\t\t\t      onexec, GLOBAL_ROOT_UID,\n\t\t\t\t      \"failed to build target label\", -ENOMEM));\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_label *handle_onexec(struct aa_label *label,\n\t\t\t\t      struct aa_label *onexec, bool stack,\n\t\t\t\t      const struct linux_binprm *bprm,\n\t\t\t\t      char *buffer, struct path_cond *cond,\n\t\t\t\t      bool *unsafe)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *new;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!onexec);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\tif (!stack) {\n\t\terror = fn_for_each_in_ns(label, profile,\n\t\t\t\tprofile_onexec(profile, onexec, stack,\n\t\t\t\t\t       bprm, buffer, cond, unsafe));\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tnew = fn_label_build_in_ns(label, profile, GFP_ATOMIC,\n\t\t\t\taa_get_newest_label(onexec),\n\t\t\t\tprofile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   cond, unsafe));\n\n\t} else {\n\t\t/* TODO: determine how much we want to losen this */\n\t\terror = fn_for_each_in_ns(label, profile,\n\t\t\t\tprofile_onexec(profile, onexec, stack, bprm,\n\t\t\t\t\t       buffer, cond, unsafe));\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tnew = fn_label_build_in_ns(label, profile, GFP_ATOMIC,\n\t\t\t\taa_label_merge(&profile->label, onexec,\n\t\t\t\t\t       GFP_ATOMIC),\n\t\t\t\tprofile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   cond, unsafe));\n\t}\n\n\tif (new)\n\t\treturn new;\n\n\t/* TODO: get rid of GLOBAL_ROOT_UID */\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\taa_audit_file(profile, &nullperms, OP_CHANGE_ONEXEC,\n\t\t\t\t      AA_MAY_ONEXEC, bprm->filename, NULL,\n\t\t\t\t      onexec, GLOBAL_ROOT_UID,\n\t\t\t\t      \"failed to build target label\", -ENOMEM));\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_buffers",
          "args": [
            "buffer"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_newest_label",
          "args": [
            "ctx->label"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "393-414",
          "snippet": "static inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ctx"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cred_ctx",
          "args": [
            "bprm->cred"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "bprm->file"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "bprm->file"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nint apparmor_bprm_set_creds(struct linux_binprm *bprm)\n{\n\tstruct aa_task_ctx *ctx;\n\tstruct aa_label *label, *new = NULL;\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tconst char *info = NULL;\n\tint error = 0;\n\tbool unsafe = false;\n\tstruct path_cond cond = {\n\t\tfile_inode(bprm->file)->i_uid,\n\t\tfile_inode(bprm->file)->i_mode\n\t};\n\n\tif (bprm->called_set_creds)\n\t\treturn 0;\n\n\tctx = cred_ctx(bprm->cred);\n\tAA_BUG(!ctx);\n\n\tlabel = aa_get_newest_label(ctx->label);\n\n\t/* buffer freed below, name is pointer into buffer */\n\tget_buffers(buffer);\n\t/* Test for onexec first as onexec override other x transitions. */\n\tif (ctx->onexec)\n\t\tnew = handle_onexec(label, ctx->onexec, ctx->token,\n\t\t\t\t    bprm, buffer, &cond, &unsafe);\n\telse\n\t\tnew = fn_label_build(label, profile, GFP_ATOMIC,\n\t\t\t\tprofile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   &cond, &unsafe));\n\n\tAA_BUG(!new);\n\tif (IS_ERR(new)) {\n\t\terror = PTR_ERR(new);\n\t\tgoto done;\n\t} else if (!new) {\n\t\terror = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t/* TODO: Add ns level no_new_privs subset test */\n\n\tif (bprm->unsafe & LSM_UNSAFE_SHARE) {\n\t\t/* FIXME: currently don't mediate shared state */\n\t\t;\n\t}\n\n\tif (bprm->unsafe & (LSM_UNSAFE_PTRACE)) {\n\t\t/* TODO: test needs to be profile of label to new */\n\t\terror = may_change_ptraced_domain(new, &info);\n\t\tif (error)\n\t\t\tgoto audit;\n\t}\n\n\tif (unsafe) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"scrubbing environment variables for %s \"\n\t\t\t\t   \"label=\", bprm->filename);\n\t\t\taa_label_printk(new, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\tbprm->secureexec = 1;\n\t}\n\n\tif (label->proxy != new->proxy) {\n\t\t/* when transitioning clear unsafe personality bits */\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: clearing unsafe personality \"\n\t\t\t\t   \"bits. %s label=\", bprm->filename);\n\t\t\taa_label_printk(new, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t}\n\taa_put_label(ctx->label);\n\t/* transfer reference, released when ctx is freed */\n\tctx->label = new;\n\ndone:\n\t/* clear out temporary/transitional state from the context */\n\taa_clear_task_ctx_trans(ctx);\n\n\taa_put_label(label);\n\tput_buffers(buffer);\n\n\treturn error;\n\naudit:\n\terror = fn_for_each(label, profile,\n\t\t\taa_audit_file(profile, &nullperms, OP_EXEC, MAY_EXEC,\n\t\t\t\t      bprm->filename, NULL, new,\n\t\t\t\t      file_inode(bprm->file)->i_uid, info,\n\t\t\t\t      error));\n\taa_put_label(new);\n\tgoto done;\n}"
  },
  {
    "function_name": "handle_onexec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "719-769",
    "snippet": "static struct aa_label *handle_onexec(struct aa_label *label,\n\t\t\t\t      struct aa_label *onexec, bool stack,\n\t\t\t\t      const struct linux_binprm *bprm,\n\t\t\t\t      char *buffer, struct path_cond *cond,\n\t\t\t\t      bool *unsafe)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *new;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!onexec);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\tif (!stack) {\n\t\terror = fn_for_each_in_ns(label, profile,\n\t\t\t\tprofile_onexec(profile, onexec, stack,\n\t\t\t\t\t       bprm, buffer, cond, unsafe));\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tnew = fn_label_build_in_ns(label, profile, GFP_ATOMIC,\n\t\t\t\taa_get_newest_label(onexec),\n\t\t\t\tprofile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   cond, unsafe));\n\n\t} else {\n\t\t/* TODO: determine how much we want to losen this */\n\t\terror = fn_for_each_in_ns(label, profile,\n\t\t\t\tprofile_onexec(profile, onexec, stack, bprm,\n\t\t\t\t\t       buffer, cond, unsafe));\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tnew = fn_label_build_in_ns(label, profile, GFP_ATOMIC,\n\t\t\t\taa_label_merge(&profile->label, onexec,\n\t\t\t\t\t       GFP_ATOMIC),\n\t\t\t\tprofile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   cond, unsafe));\n\t}\n\n\tif (new)\n\t\treturn new;\n\n\t/* TODO: get rid of GLOBAL_ROOT_UID */\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\taa_audit_file(profile, &nullperms, OP_CHANGE_ONEXEC,\n\t\t\t\t      AA_MAY_ONEXEC, bprm->filename, NULL,\n\t\t\t\t      onexec, GLOBAL_ROOT_UID,\n\t\t\t\t      \"failed to build target label\", -ENOMEM));\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_for_each_in_ns",
          "args": [
            "label",
            "profile",
            "aa_audit_file(profile, &nullperms, OP_CHANGE_ONEXEC,\n\t\t\t\t      AA_MAY_ONEXEC, bprm->filename, NULL,\n\t\t\t\t      onexec, GLOBAL_ROOT_UID,\n\t\t\t\t      \"failed to build target label\", -ENOMEM)"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_audit_file",
          "args": [
            "profile",
            "&nullperms",
            "OP_CHANGE_ONEXEC",
            "AA_MAY_ONEXEC",
            "bprm->filename",
            "NULL",
            "onexec",
            "GLOBAL_ROOT_UID",
            "\"failed to build target label\"",
            "-ENOMEM"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "103-153",
          "snippet": "int aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn_label_build_in_ns",
          "args": [
            "label",
            "profile",
            "GFP_ATOMIC",
            "aa_label_merge(&profile->label, onexec,\n\t\t\t\t\t       GFP_ATOMIC)",
            "profile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   cond, unsafe)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_transition",
          "args": [
            "profile",
            "bprm",
            "buffer",
            "cond",
            "unsafe"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "profile_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "508-630",
          "snippet": "static struct aa_label *profile_transition(struct aa_profile *profile,\n\t\t\t\t\t   const struct linux_binprm *bprm,\n\t\t\t\t\t   char *buffer, struct path_cond *cond,\n\t\t\t\t\t   bool *secure_exec)\n{\n\tstruct aa_label *new = NULL;\n\tconst char *info = NULL, *name = NULL, *target = NULL;\n\tunsigned int state = profile->file.start;\n\tstruct aa_perms perms = {};\n\tbool nonewprivs = false;\n\tint error = 0;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(&bprm->file->f_path, profile->path_flags, buffer,\n\t\t\t     &name, &info, profile->disconnected);\n\tif (error) {\n\t\tif (profile_unconfined(profile) ||\n\t\t    (profile->label.flags & FLAG_IX_ON_NAME_ERROR)) {\n\t\t\tAA_DEBUG(\"name lookup ix on error\");\n\t\t\terror = 0;\n\t\t\tnew = aa_get_newest_label(&profile->label);\n\t\t}\n\t\tname = bprm->filename;\n\t\tgoto audit;\n\t}\n\n\tif (profile_unconfined(profile)) {\n\t\tnew = find_attach(profile->ns, &profile->ns->base.profiles,\n\t\t\t\t  name, &info);\n\t\tif (new) {\n\t\t\tAA_DEBUG(\"unconfined attached to new label\");\n\t\t\treturn new;\n\t\t}\n\t\tAA_DEBUG(\"unconfined exec no attachment\");\n\t\treturn aa_get_newest_label(&profile->label);\n\t}\n\n\t/* find exec permissions for name */\n\tstate = aa_str_perms(profile->file.dfa, state, name, cond, &perms);\n\tif (perms.allow & MAY_EXEC) {\n\t\t/* exec permission determine how to transition */\n\t\tnew = x_to_label(profile, name, perms.xindex, &target, &info);\n\t\tif (new && new->proxy == profile->label.proxy && info) {\n\t\t\t/* hack ix fallback - improve how this is detected */\n\t\t\tgoto audit;\n\t\t} else if (!new) {\n\t\t\terror = -EACCES;\n\t\t\tinfo = \"profile transition not found\";\n\t\t\t/* remove MAY_EXEC to audit as failure */\n\t\t\tperms.allow &= ~MAY_EXEC;\n\t\t}\n\t} else if (COMPLAIN_MODE(profile)) {\n\t\t/* no exec permission - learning mode */\n\t\tstruct aa_profile *new_profile = NULL;\n\t\tchar *n = kstrdup(name, GFP_ATOMIC);\n\n\t\tif (n) {\n\t\t\t/* name is ptr into buffer */\n\t\t\tlong pos = name - buffer;\n\t\t\t/* break per cpu buffer hold */\n\t\t\tput_buffers(buffer);\n\t\t\tnew_profile = aa_new_null_profile(profile, false, n,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tget_buffers(buffer);\n\t\t\tname = buffer + pos;\n\t\t\tstrcpy((char *)name, n);\n\t\t\tkfree(n);\n\t\t}\n\t\tif (!new_profile) {\n\t\t\terror = -ENOMEM;\n\t\t\tinfo = \"could not create null profile\";\n\t\t} else {\n\t\t\terror = -EACCES;\n\t\t\tnew = &new_profile->label;\n\t\t}\n\t\tperms.xindex |= AA_X_UNSAFE;\n\t} else\n\t\t/* fail exec */\n\t\terror = -EACCES;\n\n\tif (!new)\n\t\tgoto audit;\n\n\t/* Policy has specified a domain transitions. if no_new_privs and\n\t * confined and not transitioning to the current domain fail.\n\t *\n\t * NOTE: Domain transitions from unconfined and to stritly stacked\n\t * subsets are allowed even when no_new_privs is set because this\n\t * aways results in a further reduction of permissions.\n\t */\n\tif ((bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS) &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(new, &profile->label)) {\n\t\terror = -EPERM;\n\t\tinfo = \"no new privs\";\n\t\tnonewprivs = true;\n\t\tperms.allow &= ~MAY_EXEC;\n\t\tgoto audit;\n\t}\n\n\tif (!(perms.xindex & AA_X_UNSAFE)) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: scrubbing environment variables\"\n\t\t\t\t   \" for %s profile=\", name);\n\t\t\taa_label_printk(new, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\t*secure_exec = true;\n\t}\n\naudit:\n\taa_audit_file(profile, &perms, OP_EXEC, MAY_EXEC, name, target, new,\n\t\t      cond->uid, info, error);\n\tif (!new || nonewprivs) {\n\t\taa_put_label(new);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn new;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_label *profile_transition(struct aa_profile *profile,\n\t\t\t\t\t   const struct linux_binprm *bprm,\n\t\t\t\t\t   char *buffer, struct path_cond *cond,\n\t\t\t\t\t   bool *secure_exec)\n{\n\tstruct aa_label *new = NULL;\n\tconst char *info = NULL, *name = NULL, *target = NULL;\n\tunsigned int state = profile->file.start;\n\tstruct aa_perms perms = {};\n\tbool nonewprivs = false;\n\tint error = 0;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(&bprm->file->f_path, profile->path_flags, buffer,\n\t\t\t     &name, &info, profile->disconnected);\n\tif (error) {\n\t\tif (profile_unconfined(profile) ||\n\t\t    (profile->label.flags & FLAG_IX_ON_NAME_ERROR)) {\n\t\t\tAA_DEBUG(\"name lookup ix on error\");\n\t\t\terror = 0;\n\t\t\tnew = aa_get_newest_label(&profile->label);\n\t\t}\n\t\tname = bprm->filename;\n\t\tgoto audit;\n\t}\n\n\tif (profile_unconfined(profile)) {\n\t\tnew = find_attach(profile->ns, &profile->ns->base.profiles,\n\t\t\t\t  name, &info);\n\t\tif (new) {\n\t\t\tAA_DEBUG(\"unconfined attached to new label\");\n\t\t\treturn new;\n\t\t}\n\t\tAA_DEBUG(\"unconfined exec no attachment\");\n\t\treturn aa_get_newest_label(&profile->label);\n\t}\n\n\t/* find exec permissions for name */\n\tstate = aa_str_perms(profile->file.dfa, state, name, cond, &perms);\n\tif (perms.allow & MAY_EXEC) {\n\t\t/* exec permission determine how to transition */\n\t\tnew = x_to_label(profile, name, perms.xindex, &target, &info);\n\t\tif (new && new->proxy == profile->label.proxy && info) {\n\t\t\t/* hack ix fallback - improve how this is detected */\n\t\t\tgoto audit;\n\t\t} else if (!new) {\n\t\t\terror = -EACCES;\n\t\t\tinfo = \"profile transition not found\";\n\t\t\t/* remove MAY_EXEC to audit as failure */\n\t\t\tperms.allow &= ~MAY_EXEC;\n\t\t}\n\t} else if (COMPLAIN_MODE(profile)) {\n\t\t/* no exec permission - learning mode */\n\t\tstruct aa_profile *new_profile = NULL;\n\t\tchar *n = kstrdup(name, GFP_ATOMIC);\n\n\t\tif (n) {\n\t\t\t/* name is ptr into buffer */\n\t\t\tlong pos = name - buffer;\n\t\t\t/* break per cpu buffer hold */\n\t\t\tput_buffers(buffer);\n\t\t\tnew_profile = aa_new_null_profile(profile, false, n,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tget_buffers(buffer);\n\t\t\tname = buffer + pos;\n\t\t\tstrcpy((char *)name, n);\n\t\t\tkfree(n);\n\t\t}\n\t\tif (!new_profile) {\n\t\t\terror = -ENOMEM;\n\t\t\tinfo = \"could not create null profile\";\n\t\t} else {\n\t\t\terror = -EACCES;\n\t\t\tnew = &new_profile->label;\n\t\t}\n\t\tperms.xindex |= AA_X_UNSAFE;\n\t} else\n\t\t/* fail exec */\n\t\terror = -EACCES;\n\n\tif (!new)\n\t\tgoto audit;\n\n\t/* Policy has specified a domain transitions. if no_new_privs and\n\t * confined and not transitioning to the current domain fail.\n\t *\n\t * NOTE: Domain transitions from unconfined and to stritly stacked\n\t * subsets are allowed even when no_new_privs is set because this\n\t * aways results in a further reduction of permissions.\n\t */\n\tif ((bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS) &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(new, &profile->label)) {\n\t\terror = -EPERM;\n\t\tinfo = \"no new privs\";\n\t\tnonewprivs = true;\n\t\tperms.allow &= ~MAY_EXEC;\n\t\tgoto audit;\n\t}\n\n\tif (!(perms.xindex & AA_X_UNSAFE)) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: scrubbing environment variables\"\n\t\t\t\t   \" for %s profile=\", name);\n\t\t\taa_label_printk(new, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\t*secure_exec = true;\n\t}\n\naudit:\n\taa_audit_file(profile, &perms, OP_EXEC, MAY_EXEC, name, target, new,\n\t\t      cond->uid, info, error);\n\tif (!new || nonewprivs) {\n\t\taa_put_label(new);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_merge",
          "args": [
            "&profile->label",
            "onexec",
            "GFP_ATOMIC"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1195-1233",
          "snippet": "struct aa_label *aa_label_merge(struct aa_label *a, struct aa_label *b,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn aa_get_newest_label(a);\n\n\t/* TODO: enable when read side is lockless\n\t * check if label exists before taking locks\n\tif (!label_is_stale(a) && !label_is_stale(b))\n\t\tlabel = aa_label_find_merge(a, b);\n\t*/\n\n\tif (!label) {\n\t\tstruct aa_label *new;\n\n\t\ta = aa_get_newest_label(a);\n\t\tb = aa_get_newest_label(b);\n\n\t\t/* could use label_merge_len(a, b), but requires double\n\t\t * comparison for small savings\n\t\t */\n\t\tnew = aa_label_alloc(a->size + b->size, NULL, gfp);\n\t\tif (!new)\n\t\t\tgoto out;\n\n\t\tlabel = label_merge_insert(new, a, b);\n\t\tlabel_free_or_put_new(label, new);\nout:\n\t\taa_put_label(a);\n\t\taa_put_label(b);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_merge(struct aa_label *a, struct aa_label *b,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn aa_get_newest_label(a);\n\n\t/* TODO: enable when read side is lockless\n\t * check if label exists before taking locks\n\tif (!label_is_stale(a) && !label_is_stale(b))\n\t\tlabel = aa_label_find_merge(a, b);\n\t*/\n\n\tif (!label) {\n\t\tstruct aa_label *new;\n\n\t\ta = aa_get_newest_label(a);\n\t\tb = aa_get_newest_label(b);\n\n\t\t/* could use label_merge_len(a, b), but requires double\n\t\t * comparison for small savings\n\t\t */\n\t\tnew = aa_label_alloc(a->size + b->size, NULL, gfp);\n\t\tif (!new)\n\t\t\tgoto out;\n\n\t\tlabel = label_merge_insert(new, a, b);\n\t\tlabel_free_or_put_new(label, new);\nout:\n\t\taa_put_label(a);\n\t\taa_put_label(b);\n\t}\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_for_each_in_ns",
          "args": [
            "label",
            "profile",
            "profile_onexec(profile, onexec, stack, bprm,\n\t\t\t\t\t       buffer, cond, unsafe)"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_onexec",
          "args": [
            "profile",
            "onexec",
            "stack",
            "bprm",
            "buffer",
            "cond",
            "unsafe"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "profile_onexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "632-715",
          "snippet": "static int profile_onexec(struct aa_profile *profile, struct aa_label *onexec,\n\t\t\t  bool stack, const struct linux_binprm *bprm,\n\t\t\t  char *buffer, struct path_cond *cond,\n\t\t\t  bool *secure_exec)\n{\n\tunsigned int state = profile->file.start;\n\tstruct aa_perms perms = {};\n\tconst char *xname = NULL, *info = \"change_profile onexec\";\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!onexec);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\tif (profile_unconfined(profile)) {\n\t\t/* change_profile on exec already granted */\n\t\t/*\n\t\t * NOTE: Domain transitions from unconfined are allowed\n\t\t * even when no_new_privs is set because this aways results\n\t\t * in a further reduction of permissions.\n\t\t */\n\t\treturn 0;\n\t}\n\n\terror = aa_path_name(&bprm->file->f_path, profile->path_flags, buffer,\n\t\t\t     &xname, &info, profile->disconnected);\n\tif (error) {\n\t\tif (profile_unconfined(profile) ||\n\t\t    (profile->label.flags & FLAG_IX_ON_NAME_ERROR)) {\n\t\t\tAA_DEBUG(\"name lookup ix on error\");\n\t\t\terror = 0;\n\t\t}\n\t\txname = bprm->filename;\n\t\tgoto audit;\n\t}\n\n\t/* find exec permissions for name */\n\tstate = aa_str_perms(profile->file.dfa, state, xname, cond, &perms);\n\tif (!(perms.allow & AA_MAY_ONEXEC)) {\n\t\tinfo = \"no change_onexec valid for executable\";\n\t\tgoto audit;\n\t}\n\t/* test if this exec can be paired with change_profile onexec.\n\t * onexec permission is linked to exec with a standard pairing\n\t * exec\\0change_profile\n\t */\n\tstate = aa_dfa_null_transition(profile->file.dfa, state);\n\terror = change_profile_perms(profile, onexec, stack, AA_MAY_ONEXEC,\n\t\t\t\t     state, &perms);\n\tif (error) {\n\t\tperms.allow &= ~AA_MAY_ONEXEC;\n\t\tgoto audit;\n\t}\n\t/* Policy has specified a domain transitions. if no_new_privs and\n\t * confined and not transitioning to the current domain fail.\n\t *\n\t * NOTE: Domain transitions from unconfined and to stritly stacked\n\t * subsets are allowed even when no_new_privs is set because this\n\t * aways results in a further reduction of permissions.\n\t */\n\tif ((bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS) &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(onexec, &profile->label)) {\n\t\terror = -EPERM;\n\t\tinfo = \"no new privs\";\n\t\tperms.allow &= ~AA_MAY_ONEXEC;\n\t\tgoto audit;\n\t}\n\n\tif (!(perms.xindex & AA_X_UNSAFE)) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: scrubbing environment \"\n\t\t\t\t   \"variables for %s label=\", xname);\n\t\t\taa_label_printk(onexec, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\t*secure_exec = true;\n\t}\n\naudit:\n\treturn aa_audit_file(profile, &perms, OP_EXEC, AA_MAY_ONEXEC, xname,\n\t\t\t     NULL, onexec, cond->uid, info, error);\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int profile_onexec(struct aa_profile *profile, struct aa_label *onexec,\n\t\t\t  bool stack, const struct linux_binprm *bprm,\n\t\t\t  char *buffer, struct path_cond *cond,\n\t\t\t  bool *secure_exec)\n{\n\tunsigned int state = profile->file.start;\n\tstruct aa_perms perms = {};\n\tconst char *xname = NULL, *info = \"change_profile onexec\";\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!onexec);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\tif (profile_unconfined(profile)) {\n\t\t/* change_profile on exec already granted */\n\t\t/*\n\t\t * NOTE: Domain transitions from unconfined are allowed\n\t\t * even when no_new_privs is set because this aways results\n\t\t * in a further reduction of permissions.\n\t\t */\n\t\treturn 0;\n\t}\n\n\terror = aa_path_name(&bprm->file->f_path, profile->path_flags, buffer,\n\t\t\t     &xname, &info, profile->disconnected);\n\tif (error) {\n\t\tif (profile_unconfined(profile) ||\n\t\t    (profile->label.flags & FLAG_IX_ON_NAME_ERROR)) {\n\t\t\tAA_DEBUG(\"name lookup ix on error\");\n\t\t\terror = 0;\n\t\t}\n\t\txname = bprm->filename;\n\t\tgoto audit;\n\t}\n\n\t/* find exec permissions for name */\n\tstate = aa_str_perms(profile->file.dfa, state, xname, cond, &perms);\n\tif (!(perms.allow & AA_MAY_ONEXEC)) {\n\t\tinfo = \"no change_onexec valid for executable\";\n\t\tgoto audit;\n\t}\n\t/* test if this exec can be paired with change_profile onexec.\n\t * onexec permission is linked to exec with a standard pairing\n\t * exec\\0change_profile\n\t */\n\tstate = aa_dfa_null_transition(profile->file.dfa, state);\n\terror = change_profile_perms(profile, onexec, stack, AA_MAY_ONEXEC,\n\t\t\t\t     state, &perms);\n\tif (error) {\n\t\tperms.allow &= ~AA_MAY_ONEXEC;\n\t\tgoto audit;\n\t}\n\t/* Policy has specified a domain transitions. if no_new_privs and\n\t * confined and not transitioning to the current domain fail.\n\t *\n\t * NOTE: Domain transitions from unconfined and to stritly stacked\n\t * subsets are allowed even when no_new_privs is set because this\n\t * aways results in a further reduction of permissions.\n\t */\n\tif ((bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS) &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(onexec, &profile->label)) {\n\t\terror = -EPERM;\n\t\tinfo = \"no new privs\";\n\t\tperms.allow &= ~AA_MAY_ONEXEC;\n\t\tgoto audit;\n\t}\n\n\tif (!(perms.xindex & AA_X_UNSAFE)) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: scrubbing environment \"\n\t\t\t\t   \"variables for %s label=\", xname);\n\t\t\taa_label_printk(onexec, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\t*secure_exec = true;\n\t}\n\naudit:\n\treturn aa_audit_file(profile, &perms, OP_EXEC, AA_MAY_ONEXEC, xname,\n\t\t\t     NULL, onexec, cond->uid, info, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn_label_build_in_ns",
          "args": [
            "label",
            "profile",
            "GFP_ATOMIC",
            "aa_get_newest_label(onexec)",
            "profile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   cond, unsafe)"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_newest_label",
          "args": [
            "onexec"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "393-414",
          "snippet": "static inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_for_each_in_ns",
          "args": [
            "label",
            "profile",
            "profile_onexec(profile, onexec, stack,\n\t\t\t\t\t       bprm, buffer, cond, unsafe)"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!buffer"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!bprm"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!onexec"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_label *handle_onexec(struct aa_label *label,\n\t\t\t\t      struct aa_label *onexec, bool stack,\n\t\t\t\t      const struct linux_binprm *bprm,\n\t\t\t\t      char *buffer, struct path_cond *cond,\n\t\t\t\t      bool *unsafe)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *new;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!onexec);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\tif (!stack) {\n\t\terror = fn_for_each_in_ns(label, profile,\n\t\t\t\tprofile_onexec(profile, onexec, stack,\n\t\t\t\t\t       bprm, buffer, cond, unsafe));\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tnew = fn_label_build_in_ns(label, profile, GFP_ATOMIC,\n\t\t\t\taa_get_newest_label(onexec),\n\t\t\t\tprofile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   cond, unsafe));\n\n\t} else {\n\t\t/* TODO: determine how much we want to losen this */\n\t\terror = fn_for_each_in_ns(label, profile,\n\t\t\t\tprofile_onexec(profile, onexec, stack, bprm,\n\t\t\t\t\t       buffer, cond, unsafe));\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tnew = fn_label_build_in_ns(label, profile, GFP_ATOMIC,\n\t\t\t\taa_label_merge(&profile->label, onexec,\n\t\t\t\t\t       GFP_ATOMIC),\n\t\t\t\tprofile_transition(profile, bprm, buffer,\n\t\t\t\t\t\t   cond, unsafe));\n\t}\n\n\tif (new)\n\t\treturn new;\n\n\t/* TODO: get rid of GLOBAL_ROOT_UID */\n\terror = fn_for_each_in_ns(label, profile,\n\t\t\taa_audit_file(profile, &nullperms, OP_CHANGE_ONEXEC,\n\t\t\t\t      AA_MAY_ONEXEC, bprm->filename, NULL,\n\t\t\t\t      onexec, GLOBAL_ROOT_UID,\n\t\t\t\t      \"failed to build target label\", -ENOMEM));\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "profile_onexec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "632-715",
    "snippet": "static int profile_onexec(struct aa_profile *profile, struct aa_label *onexec,\n\t\t\t  bool stack, const struct linux_binprm *bprm,\n\t\t\t  char *buffer, struct path_cond *cond,\n\t\t\t  bool *secure_exec)\n{\n\tunsigned int state = profile->file.start;\n\tstruct aa_perms perms = {};\n\tconst char *xname = NULL, *info = \"change_profile onexec\";\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!onexec);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\tif (profile_unconfined(profile)) {\n\t\t/* change_profile on exec already granted */\n\t\t/*\n\t\t * NOTE: Domain transitions from unconfined are allowed\n\t\t * even when no_new_privs is set because this aways results\n\t\t * in a further reduction of permissions.\n\t\t */\n\t\treturn 0;\n\t}\n\n\terror = aa_path_name(&bprm->file->f_path, profile->path_flags, buffer,\n\t\t\t     &xname, &info, profile->disconnected);\n\tif (error) {\n\t\tif (profile_unconfined(profile) ||\n\t\t    (profile->label.flags & FLAG_IX_ON_NAME_ERROR)) {\n\t\t\tAA_DEBUG(\"name lookup ix on error\");\n\t\t\terror = 0;\n\t\t}\n\t\txname = bprm->filename;\n\t\tgoto audit;\n\t}\n\n\t/* find exec permissions for name */\n\tstate = aa_str_perms(profile->file.dfa, state, xname, cond, &perms);\n\tif (!(perms.allow & AA_MAY_ONEXEC)) {\n\t\tinfo = \"no change_onexec valid for executable\";\n\t\tgoto audit;\n\t}\n\t/* test if this exec can be paired with change_profile onexec.\n\t * onexec permission is linked to exec with a standard pairing\n\t * exec\\0change_profile\n\t */\n\tstate = aa_dfa_null_transition(profile->file.dfa, state);\n\terror = change_profile_perms(profile, onexec, stack, AA_MAY_ONEXEC,\n\t\t\t\t     state, &perms);\n\tif (error) {\n\t\tperms.allow &= ~AA_MAY_ONEXEC;\n\t\tgoto audit;\n\t}\n\t/* Policy has specified a domain transitions. if no_new_privs and\n\t * confined and not transitioning to the current domain fail.\n\t *\n\t * NOTE: Domain transitions from unconfined and to stritly stacked\n\t * subsets are allowed even when no_new_privs is set because this\n\t * aways results in a further reduction of permissions.\n\t */\n\tif ((bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS) &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(onexec, &profile->label)) {\n\t\terror = -EPERM;\n\t\tinfo = \"no new privs\";\n\t\tperms.allow &= ~AA_MAY_ONEXEC;\n\t\tgoto audit;\n\t}\n\n\tif (!(perms.xindex & AA_X_UNSAFE)) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: scrubbing environment \"\n\t\t\t\t   \"variables for %s label=\", xname);\n\t\t\taa_label_printk(onexec, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\t*secure_exec = true;\n\t}\n\naudit:\n\treturn aa_audit_file(profile, &perms, OP_EXEC, AA_MAY_ONEXEC, xname,\n\t\t\t     NULL, onexec, cond->uid, info, error);\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_audit_file",
          "args": [
            "profile",
            "&perms",
            "OP_EXEC",
            "AA_MAY_ONEXEC",
            "xname",
            "NULL",
            "onexec",
            "cond->uid",
            "info",
            "error"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "103-153",
          "snippet": "int aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_printk",
          "args": [
            "\"\\n\""
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_printk",
          "args": [
            "onexec",
            "GFP_ATOMIC"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_printk",
          "args": [
            "\"apparmor: scrubbing environment \"\n\t\t\t\t   \"variables for %s label=\"",
            "xname"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_is_subset",
          "args": [
            "onexec",
            "&profile->label"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_is_subset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "545-556",
          "snippet": "bool aa_label_is_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\treturn __aa_label_next_not_in_set(&i, set, sub) == NULL;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nbool aa_label_is_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\treturn __aa_label_next_not_in_set(&i, set, sub) == NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "change_profile_perms",
          "args": [
            "profile",
            "onexec",
            "stack",
            "AA_MAY_ONEXEC",
            "state",
            "&perms"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "change_profile_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "289-302",
          "snippet": "static int change_profile_perms(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *target, bool stack,\n\t\t\t\tu32 request, unsigned int start,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tif (profile_unconfined(profile)) {\n\t\tperms->allow = AA_MAY_CHANGE_PROFILE | AA_MAY_ONEXEC;\n\t\tperms->audit = perms->quiet = perms->kill = 0;\n\t\treturn 0;\n\t}\n\n\t/* TODO: add profile in ns screening */\n\treturn label_match(profile, target, stack, start, true, request, perms);\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int change_profile_perms(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *target, bool stack,\n\t\t\t\tu32 request, unsigned int start,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tif (profile_unconfined(profile)) {\n\t\tperms->allow = AA_MAY_CHANGE_PROFILE | AA_MAY_ONEXEC;\n\t\tperms->audit = perms->quiet = perms->kill = 0;\n\t\treturn 0;\n\t}\n\n\t/* TODO: add profile in ns screening */\n\treturn label_match(profile, target, stack, start, true, request, perms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_null_transition",
          "args": [
            "profile->file.dfa",
            "state"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_null_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/lib.h",
          "lines": "80-85",
          "snippet": "static inline unsigned int aa_dfa_null_transition(struct aa_dfa *dfa,\n\t\t\t\t\t\t  unsigned int start)\n{\n\t/* the null transition only needs the string's null terminator byte */\n\treturn aa_dfa_next(dfa, start, 0);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int aa_dfa_null_transition(struct aa_dfa *dfa,\n\t\t\t\t\t\t  unsigned int start)\n{\n\t/* the null transition only needs the string's null terminator byte */\n\treturn aa_dfa_next(dfa, start, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_str_perms",
          "args": [
            "profile->file.dfa",
            "state",
            "xname",
            "cond",
            "&perms"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "aa_str_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "268-277",
          "snippet": "unsigned int aa_str_perms(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *name, struct path_cond *cond,\n\t\t\t  struct aa_perms *perms)\n{\n\tunsigned int state;\n\tstate = aa_dfa_match(dfa, start, name);\n\t*perms = aa_compute_fperms(dfa, state, cond);\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nunsigned int aa_str_perms(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *name, struct path_cond *cond,\n\t\t\t  struct aa_perms *perms)\n{\n\tunsigned int state;\n\tstate = aa_dfa_match(dfa, start, name);\n\t*perms = aa_compute_fperms(dfa, state, cond);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_DEBUG",
          "args": [
            "\"name lookup ix on error\""
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_path_name",
          "args": [
            "&bprm->file->f_path",
            "profile->path_flags",
            "buffer",
            "&xname",
            "&info",
            "profile->disconnected"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "aa_path_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
          "lines": "201-221",
          "snippet": "int aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/path.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\nint aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!buffer"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!bprm"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!onexec"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!profile"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int profile_onexec(struct aa_profile *profile, struct aa_label *onexec,\n\t\t\t  bool stack, const struct linux_binprm *bprm,\n\t\t\t  char *buffer, struct path_cond *cond,\n\t\t\t  bool *secure_exec)\n{\n\tunsigned int state = profile->file.start;\n\tstruct aa_perms perms = {};\n\tconst char *xname = NULL, *info = \"change_profile onexec\";\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!onexec);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\tif (profile_unconfined(profile)) {\n\t\t/* change_profile on exec already granted */\n\t\t/*\n\t\t * NOTE: Domain transitions from unconfined are allowed\n\t\t * even when no_new_privs is set because this aways results\n\t\t * in a further reduction of permissions.\n\t\t */\n\t\treturn 0;\n\t}\n\n\terror = aa_path_name(&bprm->file->f_path, profile->path_flags, buffer,\n\t\t\t     &xname, &info, profile->disconnected);\n\tif (error) {\n\t\tif (profile_unconfined(profile) ||\n\t\t    (profile->label.flags & FLAG_IX_ON_NAME_ERROR)) {\n\t\t\tAA_DEBUG(\"name lookup ix on error\");\n\t\t\terror = 0;\n\t\t}\n\t\txname = bprm->filename;\n\t\tgoto audit;\n\t}\n\n\t/* find exec permissions for name */\n\tstate = aa_str_perms(profile->file.dfa, state, xname, cond, &perms);\n\tif (!(perms.allow & AA_MAY_ONEXEC)) {\n\t\tinfo = \"no change_onexec valid for executable\";\n\t\tgoto audit;\n\t}\n\t/* test if this exec can be paired with change_profile onexec.\n\t * onexec permission is linked to exec with a standard pairing\n\t * exec\\0change_profile\n\t */\n\tstate = aa_dfa_null_transition(profile->file.dfa, state);\n\terror = change_profile_perms(profile, onexec, stack, AA_MAY_ONEXEC,\n\t\t\t\t     state, &perms);\n\tif (error) {\n\t\tperms.allow &= ~AA_MAY_ONEXEC;\n\t\tgoto audit;\n\t}\n\t/* Policy has specified a domain transitions. if no_new_privs and\n\t * confined and not transitioning to the current domain fail.\n\t *\n\t * NOTE: Domain transitions from unconfined and to stritly stacked\n\t * subsets are allowed even when no_new_privs is set because this\n\t * aways results in a further reduction of permissions.\n\t */\n\tif ((bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS) &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(onexec, &profile->label)) {\n\t\terror = -EPERM;\n\t\tinfo = \"no new privs\";\n\t\tperms.allow &= ~AA_MAY_ONEXEC;\n\t\tgoto audit;\n\t}\n\n\tif (!(perms.xindex & AA_X_UNSAFE)) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: scrubbing environment \"\n\t\t\t\t   \"variables for %s label=\", xname);\n\t\t\taa_label_printk(onexec, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\t*secure_exec = true;\n\t}\n\naudit:\n\treturn aa_audit_file(profile, &perms, OP_EXEC, AA_MAY_ONEXEC, xname,\n\t\t\t     NULL, onexec, cond->uid, info, error);\n}"
  },
  {
    "function_name": "profile_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "508-630",
    "snippet": "static struct aa_label *profile_transition(struct aa_profile *profile,\n\t\t\t\t\t   const struct linux_binprm *bprm,\n\t\t\t\t\t   char *buffer, struct path_cond *cond,\n\t\t\t\t\t   bool *secure_exec)\n{\n\tstruct aa_label *new = NULL;\n\tconst char *info = NULL, *name = NULL, *target = NULL;\n\tunsigned int state = profile->file.start;\n\tstruct aa_perms perms = {};\n\tbool nonewprivs = false;\n\tint error = 0;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(&bprm->file->f_path, profile->path_flags, buffer,\n\t\t\t     &name, &info, profile->disconnected);\n\tif (error) {\n\t\tif (profile_unconfined(profile) ||\n\t\t    (profile->label.flags & FLAG_IX_ON_NAME_ERROR)) {\n\t\t\tAA_DEBUG(\"name lookup ix on error\");\n\t\t\terror = 0;\n\t\t\tnew = aa_get_newest_label(&profile->label);\n\t\t}\n\t\tname = bprm->filename;\n\t\tgoto audit;\n\t}\n\n\tif (profile_unconfined(profile)) {\n\t\tnew = find_attach(profile->ns, &profile->ns->base.profiles,\n\t\t\t\t  name, &info);\n\t\tif (new) {\n\t\t\tAA_DEBUG(\"unconfined attached to new label\");\n\t\t\treturn new;\n\t\t}\n\t\tAA_DEBUG(\"unconfined exec no attachment\");\n\t\treturn aa_get_newest_label(&profile->label);\n\t}\n\n\t/* find exec permissions for name */\n\tstate = aa_str_perms(profile->file.dfa, state, name, cond, &perms);\n\tif (perms.allow & MAY_EXEC) {\n\t\t/* exec permission determine how to transition */\n\t\tnew = x_to_label(profile, name, perms.xindex, &target, &info);\n\t\tif (new && new->proxy == profile->label.proxy && info) {\n\t\t\t/* hack ix fallback - improve how this is detected */\n\t\t\tgoto audit;\n\t\t} else if (!new) {\n\t\t\terror = -EACCES;\n\t\t\tinfo = \"profile transition not found\";\n\t\t\t/* remove MAY_EXEC to audit as failure */\n\t\t\tperms.allow &= ~MAY_EXEC;\n\t\t}\n\t} else if (COMPLAIN_MODE(profile)) {\n\t\t/* no exec permission - learning mode */\n\t\tstruct aa_profile *new_profile = NULL;\n\t\tchar *n = kstrdup(name, GFP_ATOMIC);\n\n\t\tif (n) {\n\t\t\t/* name is ptr into buffer */\n\t\t\tlong pos = name - buffer;\n\t\t\t/* break per cpu buffer hold */\n\t\t\tput_buffers(buffer);\n\t\t\tnew_profile = aa_new_null_profile(profile, false, n,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tget_buffers(buffer);\n\t\t\tname = buffer + pos;\n\t\t\tstrcpy((char *)name, n);\n\t\t\tkfree(n);\n\t\t}\n\t\tif (!new_profile) {\n\t\t\terror = -ENOMEM;\n\t\t\tinfo = \"could not create null profile\";\n\t\t} else {\n\t\t\terror = -EACCES;\n\t\t\tnew = &new_profile->label;\n\t\t}\n\t\tperms.xindex |= AA_X_UNSAFE;\n\t} else\n\t\t/* fail exec */\n\t\terror = -EACCES;\n\n\tif (!new)\n\t\tgoto audit;\n\n\t/* Policy has specified a domain transitions. if no_new_privs and\n\t * confined and not transitioning to the current domain fail.\n\t *\n\t * NOTE: Domain transitions from unconfined and to stritly stacked\n\t * subsets are allowed even when no_new_privs is set because this\n\t * aways results in a further reduction of permissions.\n\t */\n\tif ((bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS) &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(new, &profile->label)) {\n\t\terror = -EPERM;\n\t\tinfo = \"no new privs\";\n\t\tnonewprivs = true;\n\t\tperms.allow &= ~MAY_EXEC;\n\t\tgoto audit;\n\t}\n\n\tif (!(perms.xindex & AA_X_UNSAFE)) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: scrubbing environment variables\"\n\t\t\t\t   \" for %s profile=\", name);\n\t\t\taa_label_printk(new, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\t*secure_exec = true;\n\t}\n\naudit:\n\taa_audit_file(profile, &perms, OP_EXEC, MAY_EXEC, name, target, new,\n\t\t      cond->uid, info, error);\n\tif (!new || nonewprivs) {\n\t\taa_put_label(new);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn new;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "new"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_audit_file",
          "args": [
            "profile",
            "&perms",
            "OP_EXEC",
            "MAY_EXEC",
            "name",
            "target",
            "new",
            "cond->uid",
            "info",
            "error"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "103-153",
          "snippet": "int aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_printk",
          "args": [
            "\"\\n\""
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_printk",
          "args": [
            "new",
            "GFP_ATOMIC"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_printk",
          "args": [
            "\"apparmor: scrubbing environment variables\"\n\t\t\t\t   \" for %s profile=\"",
            "name"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_is_subset",
          "args": [
            "new",
            "&profile->label"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_is_subset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "545-556",
          "snippet": "bool aa_label_is_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\treturn __aa_label_next_not_in_set(&i, set, sub) == NULL;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nbool aa_label_is_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\treturn __aa_label_next_not_in_set(&i, set, sub) == NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "n"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "(char *)name",
            "n"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_buffers",
          "args": [
            "buffer"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_new_null_profile",
          "args": [
            "profile",
            "false",
            "n",
            "GFP_KERNEL"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "aa_new_null_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "500-568",
          "snippet": "struct aa_profile *aa_new_null_profile(struct aa_profile *parent, bool hat,\n\t\t\t\t       const char *base, gfp_t gfp)\n{\n\tstruct aa_profile *p, *profile;\n\tconst char *bname;\n\tchar *name = NULL;\n\n\tAA_BUG(!parent);\n\n\tif (base) {\n\t\tname = kmalloc(strlen(parent->base.hname) + 8 + strlen(base),\n\t\t\t       gfp);\n\t\tif (name) {\n\t\t\tsprintf(name, \"%s//null-%s\", parent->base.hname, base);\n\t\t\tgoto name;\n\t\t}\n\t\t/* fall through to try shorter uniq */\n\t}\n\n\tname = kmalloc(strlen(parent->base.hname) + 2 + 7 + 8, gfp);\n\tif (!name)\n\t\treturn NULL;\n\tsprintf(name, \"%s//null-%x\", parent->base.hname,\n\t\tatomic_inc_return(&parent->ns->uniq_null));\n\nname:\n\t/* lookup to see if this is a dup creation */\n\tbname = basename(name);\n\tprofile = aa_find_child(parent, bname);\n\tif (profile)\n\t\tgoto out;\n\n\tprofile = aa_alloc_profile(name, NULL, gfp);\n\tif (!profile)\n\t\tgoto fail;\n\n\tprofile->mode = APPARMOR_COMPLAIN;\n\tprofile->label.flags |= FLAG_NULL;\n\tif (hat)\n\t\tprofile->label.flags |= FLAG_HAT;\n\tprofile->path_flags = parent->path_flags;\n\n\t/* released on free_profile */\n\trcu_assign_pointer(profile->parent, aa_get_profile(parent));\n\tprofile->ns = aa_get_ns(parent->ns);\n\tprofile->file.dfa = aa_get_dfa(nulldfa);\n\tprofile->policy.dfa = aa_get_dfa(nulldfa);\n\n\tmutex_lock_nested(&profile->ns->lock, profile->ns->level);\n\tp = __find_child(&parent->base.profiles, bname);\n\tif (p) {\n\t\taa_free_profile(profile);\n\t\tprofile = aa_get_profile(p);\n\t} else {\n\t\t__add_profile(&parent->base.profiles, profile);\n\t}\n\tmutex_unlock(&profile->ns->lock);\n\n\t/* refcount released by caller */\nout:\n\tkfree(name);\n\n\treturn profile;\n\nfail:\n\tkfree(name);\n\taa_free_profile(profile);\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct aa_profile *aa_new_null_profile(struct aa_profile *parent, bool hat,\n\t\t\t\t       const char *base, gfp_t gfp)\n{\n\tstruct aa_profile *p, *profile;\n\tconst char *bname;\n\tchar *name = NULL;\n\n\tAA_BUG(!parent);\n\n\tif (base) {\n\t\tname = kmalloc(strlen(parent->base.hname) + 8 + strlen(base),\n\t\t\t       gfp);\n\t\tif (name) {\n\t\t\tsprintf(name, \"%s//null-%s\", parent->base.hname, base);\n\t\t\tgoto name;\n\t\t}\n\t\t/* fall through to try shorter uniq */\n\t}\n\n\tname = kmalloc(strlen(parent->base.hname) + 2 + 7 + 8, gfp);\n\tif (!name)\n\t\treturn NULL;\n\tsprintf(name, \"%s//null-%x\", parent->base.hname,\n\t\tatomic_inc_return(&parent->ns->uniq_null));\n\nname:\n\t/* lookup to see if this is a dup creation */\n\tbname = basename(name);\n\tprofile = aa_find_child(parent, bname);\n\tif (profile)\n\t\tgoto out;\n\n\tprofile = aa_alloc_profile(name, NULL, gfp);\n\tif (!profile)\n\t\tgoto fail;\n\n\tprofile->mode = APPARMOR_COMPLAIN;\n\tprofile->label.flags |= FLAG_NULL;\n\tif (hat)\n\t\tprofile->label.flags |= FLAG_HAT;\n\tprofile->path_flags = parent->path_flags;\n\n\t/* released on free_profile */\n\trcu_assign_pointer(profile->parent, aa_get_profile(parent));\n\tprofile->ns = aa_get_ns(parent->ns);\n\tprofile->file.dfa = aa_get_dfa(nulldfa);\n\tprofile->policy.dfa = aa_get_dfa(nulldfa);\n\n\tmutex_lock_nested(&profile->ns->lock, profile->ns->level);\n\tp = __find_child(&parent->base.profiles, bname);\n\tif (p) {\n\t\taa_free_profile(profile);\n\t\tprofile = aa_get_profile(p);\n\t} else {\n\t\t__add_profile(&parent->base.profiles, profile);\n\t}\n\tmutex_unlock(&profile->ns->lock);\n\n\t/* refcount released by caller */\nout:\n\tkfree(name);\n\n\treturn profile;\n\nfail:\n\tkfree(name);\n\taa_free_profile(profile);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_buffers",
          "args": [
            "buffer"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_ATOMIC"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPLAIN_MODE",
          "args": [
            "profile"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_to_label",
          "args": [
            "profile",
            "name",
            "perms.xindex",
            "&target",
            "&info"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "x_to_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "442-506",
          "snippet": "static struct aa_label *x_to_label(struct aa_profile *profile,\n\t\t\t\t   const char *name, u32 xindex,\n\t\t\t\t   const char **lookupname,\n\t\t\t\t   const char **info)\n{\n\tstruct aa_label *new = NULL;\n\tstruct aa_ns *ns = profile->ns;\n\tu32 xtype = xindex & AA_X_TYPE_MASK;\n\tconst char *stack = NULL;\n\n\tswitch (xtype) {\n\tcase AA_X_NONE:\n\t\t/* fail exec unless ix || ux fallback - handled by caller */\n\t\t*lookupname = NULL;\n\t\tbreak;\n\tcase AA_X_TABLE:\n\t\t/* TODO: fix when perm mapping done at unload */\n\t\tstack = profile->file.trans.table[xindex & AA_X_INDEX_MASK];\n\t\tif (*stack != '&') {\n\t\t\t/* released by caller */\n\t\t\tnew = x_table_lookup(profile, xindex, lookupname);\n\t\t\tstack = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through to X_NAME */\n\tcase AA_X_NAME:\n\t\tif (xindex & AA_X_CHILD)\n\t\t\t/* released by caller */\n\t\t\tnew = find_attach(ns, &profile->base.profiles,\n\t\t\t\t\t  name, info);\n\t\telse\n\t\t\t/* released by caller */\n\t\t\tnew = find_attach(ns, &ns->base.profiles,\n\t\t\t\t\t  name, info);\n\t\t*lookupname = name;\n\t\tbreak;\n\t}\n\n\tif (!new) {\n\t\tif (xindex & AA_X_INHERIT) {\n\t\t\t/* (p|c|n)ix - don't change profile but do\n\t\t\t * use the newest version\n\t\t\t */\n\t\t\t*info = \"ix fallback\";\n\t\t\t/* no profile && no error */\n\t\t\tnew = aa_get_newest_label(&profile->label);\n\t\t} else if (xindex & AA_X_UNCONFINED) {\n\t\t\tnew = aa_get_newest_label(ns_unconfined(profile->ns));\n\t\t\t*info = \"ux fallback\";\n\t\t}\n\t}\n\n\tif (new && stack) {\n\t\t/* base the stack on post domain transition */\n\t\tstruct aa_label *base = new;\n\n\t\tnew = aa_label_parse(base, stack, GFP_ATOMIC, true, false);\n\t\tif (IS_ERR(new))\n\t\t\tnew = NULL;\n\t\taa_put_label(base);\n\t}\n\n\t/* released by caller */\n\treturn new;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_label *x_to_label(struct aa_profile *profile,\n\t\t\t\t   const char *name, u32 xindex,\n\t\t\t\t   const char **lookupname,\n\t\t\t\t   const char **info)\n{\n\tstruct aa_label *new = NULL;\n\tstruct aa_ns *ns = profile->ns;\n\tu32 xtype = xindex & AA_X_TYPE_MASK;\n\tconst char *stack = NULL;\n\n\tswitch (xtype) {\n\tcase AA_X_NONE:\n\t\t/* fail exec unless ix || ux fallback - handled by caller */\n\t\t*lookupname = NULL;\n\t\tbreak;\n\tcase AA_X_TABLE:\n\t\t/* TODO: fix when perm mapping done at unload */\n\t\tstack = profile->file.trans.table[xindex & AA_X_INDEX_MASK];\n\t\tif (*stack != '&') {\n\t\t\t/* released by caller */\n\t\t\tnew = x_table_lookup(profile, xindex, lookupname);\n\t\t\tstack = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through to X_NAME */\n\tcase AA_X_NAME:\n\t\tif (xindex & AA_X_CHILD)\n\t\t\t/* released by caller */\n\t\t\tnew = find_attach(ns, &profile->base.profiles,\n\t\t\t\t\t  name, info);\n\t\telse\n\t\t\t/* released by caller */\n\t\t\tnew = find_attach(ns, &ns->base.profiles,\n\t\t\t\t\t  name, info);\n\t\t*lookupname = name;\n\t\tbreak;\n\t}\n\n\tif (!new) {\n\t\tif (xindex & AA_X_INHERIT) {\n\t\t\t/* (p|c|n)ix - don't change profile but do\n\t\t\t * use the newest version\n\t\t\t */\n\t\t\t*info = \"ix fallback\";\n\t\t\t/* no profile && no error */\n\t\t\tnew = aa_get_newest_label(&profile->label);\n\t\t} else if (xindex & AA_X_UNCONFINED) {\n\t\t\tnew = aa_get_newest_label(ns_unconfined(profile->ns));\n\t\t\t*info = \"ux fallback\";\n\t\t}\n\t}\n\n\tif (new && stack) {\n\t\t/* base the stack on post domain transition */\n\t\tstruct aa_label *base = new;\n\n\t\tnew = aa_label_parse(base, stack, GFP_ATOMIC, true, false);\n\t\tif (IS_ERR(new))\n\t\t\tnew = NULL;\n\t\taa_put_label(base);\n\t}\n\n\t/* released by caller */\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_str_perms",
          "args": [
            "profile->file.dfa",
            "state",
            "name",
            "cond",
            "&perms"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "aa_str_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "268-277",
          "snippet": "unsigned int aa_str_perms(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *name, struct path_cond *cond,\n\t\t\t  struct aa_perms *perms)\n{\n\tunsigned int state;\n\tstate = aa_dfa_match(dfa, start, name);\n\t*perms = aa_compute_fperms(dfa, state, cond);\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nunsigned int aa_str_perms(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *name, struct path_cond *cond,\n\t\t\t  struct aa_perms *perms)\n{\n\tunsigned int state;\n\tstate = aa_dfa_match(dfa, start, name);\n\t*perms = aa_compute_fperms(dfa, state, cond);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_newest_label",
          "args": [
            "&profile->label"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "393-414",
          "snippet": "static inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_DEBUG",
          "args": [
            "\"unconfined exec no attachment\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_DEBUG",
          "args": [
            "\"unconfined attached to new label\""
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_attach",
          "args": [
            "profile->ns",
            "&profile->ns->base.profiles",
            "name",
            "&info"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "find_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "372-382",
          "snippet": "static struct aa_label *find_attach(struct aa_ns *ns, struct list_head *list,\n\t\t\t\t    const char *name, const char **info)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tprofile = aa_get_profile(__attach_match(name, list, info));\n\trcu_read_unlock();\n\n\treturn profile ? &profile->label : NULL;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_label *find_attach(struct aa_ns *ns, struct list_head *list,\n\t\t\t\t    const char *name, const char **info)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tprofile = aa_get_profile(__attach_match(name, list, info));\n\trcu_read_unlock();\n\n\treturn profile ? &profile->label : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_DEBUG",
          "args": [
            "\"name lookup ix on error\""
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_path_name",
          "args": [
            "&bprm->file->f_path",
            "profile->path_flags",
            "buffer",
            "&name",
            "&info",
            "profile->disconnected"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "aa_path_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
          "lines": "201-221",
          "snippet": "int aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/path.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\nint aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!buffer"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!bprm"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!profile"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_label *profile_transition(struct aa_profile *profile,\n\t\t\t\t\t   const struct linux_binprm *bprm,\n\t\t\t\t\t   char *buffer, struct path_cond *cond,\n\t\t\t\t\t   bool *secure_exec)\n{\n\tstruct aa_label *new = NULL;\n\tconst char *info = NULL, *name = NULL, *target = NULL;\n\tunsigned int state = profile->file.start;\n\tstruct aa_perms perms = {};\n\tbool nonewprivs = false;\n\tint error = 0;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!bprm);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(&bprm->file->f_path, profile->path_flags, buffer,\n\t\t\t     &name, &info, profile->disconnected);\n\tif (error) {\n\t\tif (profile_unconfined(profile) ||\n\t\t    (profile->label.flags & FLAG_IX_ON_NAME_ERROR)) {\n\t\t\tAA_DEBUG(\"name lookup ix on error\");\n\t\t\terror = 0;\n\t\t\tnew = aa_get_newest_label(&profile->label);\n\t\t}\n\t\tname = bprm->filename;\n\t\tgoto audit;\n\t}\n\n\tif (profile_unconfined(profile)) {\n\t\tnew = find_attach(profile->ns, &profile->ns->base.profiles,\n\t\t\t\t  name, &info);\n\t\tif (new) {\n\t\t\tAA_DEBUG(\"unconfined attached to new label\");\n\t\t\treturn new;\n\t\t}\n\t\tAA_DEBUG(\"unconfined exec no attachment\");\n\t\treturn aa_get_newest_label(&profile->label);\n\t}\n\n\t/* find exec permissions for name */\n\tstate = aa_str_perms(profile->file.dfa, state, name, cond, &perms);\n\tif (perms.allow & MAY_EXEC) {\n\t\t/* exec permission determine how to transition */\n\t\tnew = x_to_label(profile, name, perms.xindex, &target, &info);\n\t\tif (new && new->proxy == profile->label.proxy && info) {\n\t\t\t/* hack ix fallback - improve how this is detected */\n\t\t\tgoto audit;\n\t\t} else if (!new) {\n\t\t\terror = -EACCES;\n\t\t\tinfo = \"profile transition not found\";\n\t\t\t/* remove MAY_EXEC to audit as failure */\n\t\t\tperms.allow &= ~MAY_EXEC;\n\t\t}\n\t} else if (COMPLAIN_MODE(profile)) {\n\t\t/* no exec permission - learning mode */\n\t\tstruct aa_profile *new_profile = NULL;\n\t\tchar *n = kstrdup(name, GFP_ATOMIC);\n\n\t\tif (n) {\n\t\t\t/* name is ptr into buffer */\n\t\t\tlong pos = name - buffer;\n\t\t\t/* break per cpu buffer hold */\n\t\t\tput_buffers(buffer);\n\t\t\tnew_profile = aa_new_null_profile(profile, false, n,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tget_buffers(buffer);\n\t\t\tname = buffer + pos;\n\t\t\tstrcpy((char *)name, n);\n\t\t\tkfree(n);\n\t\t}\n\t\tif (!new_profile) {\n\t\t\terror = -ENOMEM;\n\t\t\tinfo = \"could not create null profile\";\n\t\t} else {\n\t\t\terror = -EACCES;\n\t\t\tnew = &new_profile->label;\n\t\t}\n\t\tperms.xindex |= AA_X_UNSAFE;\n\t} else\n\t\t/* fail exec */\n\t\terror = -EACCES;\n\n\tif (!new)\n\t\tgoto audit;\n\n\t/* Policy has specified a domain transitions. if no_new_privs and\n\t * confined and not transitioning to the current domain fail.\n\t *\n\t * NOTE: Domain transitions from unconfined and to stritly stacked\n\t * subsets are allowed even when no_new_privs is set because this\n\t * aways results in a further reduction of permissions.\n\t */\n\tif ((bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS) &&\n\t    !profile_unconfined(profile) &&\n\t    !aa_label_is_subset(new, &profile->label)) {\n\t\terror = -EPERM;\n\t\tinfo = \"no new privs\";\n\t\tnonewprivs = true;\n\t\tperms.allow &= ~MAY_EXEC;\n\t\tgoto audit;\n\t}\n\n\tif (!(perms.xindex & AA_X_UNSAFE)) {\n\t\tif (DEBUG_ON) {\n\t\t\tdbg_printk(\"apparmor: scrubbing environment variables\"\n\t\t\t\t   \" for %s profile=\", name);\n\t\t\taa_label_printk(new, GFP_ATOMIC);\n\t\t\tdbg_printk(\"\\n\");\n\t\t}\n\t\t*secure_exec = true;\n\t}\n\naudit:\n\taa_audit_file(profile, &perms, OP_EXEC, MAY_EXEC, name, target, new,\n\t\t      cond->uid, info, error);\n\tif (!new || nonewprivs) {\n\t\taa_put_label(new);\n\t\treturn ERR_PTR(error);\n\t}\n\n\treturn new;\n}"
  },
  {
    "function_name": "x_to_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "442-506",
    "snippet": "static struct aa_label *x_to_label(struct aa_profile *profile,\n\t\t\t\t   const char *name, u32 xindex,\n\t\t\t\t   const char **lookupname,\n\t\t\t\t   const char **info)\n{\n\tstruct aa_label *new = NULL;\n\tstruct aa_ns *ns = profile->ns;\n\tu32 xtype = xindex & AA_X_TYPE_MASK;\n\tconst char *stack = NULL;\n\n\tswitch (xtype) {\n\tcase AA_X_NONE:\n\t\t/* fail exec unless ix || ux fallback - handled by caller */\n\t\t*lookupname = NULL;\n\t\tbreak;\n\tcase AA_X_TABLE:\n\t\t/* TODO: fix when perm mapping done at unload */\n\t\tstack = profile->file.trans.table[xindex & AA_X_INDEX_MASK];\n\t\tif (*stack != '&') {\n\t\t\t/* released by caller */\n\t\t\tnew = x_table_lookup(profile, xindex, lookupname);\n\t\t\tstack = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through to X_NAME */\n\tcase AA_X_NAME:\n\t\tif (xindex & AA_X_CHILD)\n\t\t\t/* released by caller */\n\t\t\tnew = find_attach(ns, &profile->base.profiles,\n\t\t\t\t\t  name, info);\n\t\telse\n\t\t\t/* released by caller */\n\t\t\tnew = find_attach(ns, &ns->base.profiles,\n\t\t\t\t\t  name, info);\n\t\t*lookupname = name;\n\t\tbreak;\n\t}\n\n\tif (!new) {\n\t\tif (xindex & AA_X_INHERIT) {\n\t\t\t/* (p|c|n)ix - don't change profile but do\n\t\t\t * use the newest version\n\t\t\t */\n\t\t\t*info = \"ix fallback\";\n\t\t\t/* no profile && no error */\n\t\t\tnew = aa_get_newest_label(&profile->label);\n\t\t} else if (xindex & AA_X_UNCONFINED) {\n\t\t\tnew = aa_get_newest_label(ns_unconfined(profile->ns));\n\t\t\t*info = \"ux fallback\";\n\t\t}\n\t}\n\n\tif (new && stack) {\n\t\t/* base the stack on post domain transition */\n\t\tstruct aa_label *base = new;\n\n\t\tnew = aa_label_parse(base, stack, GFP_ATOMIC, true, false);\n\t\tif (IS_ERR(new))\n\t\t\tnew = NULL;\n\t\taa_put_label(base);\n\t}\n\n\t/* released by caller */\n\treturn new;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "base"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_parse",
          "args": [
            "base",
            "stack",
            "GFP_ATOMIC",
            "true",
            "false"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1856-1931",
          "snippet": "struct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack)\n{\n\tDEFINE_VEC(profile, vec);\n\tstruct aa_label *label, *currbase = base;\n\tint i, len, stack = 0, error;\n\tchar *split;\n\n\tAA_BUG(!base);\n\tAA_BUG(!str);\n\n\tstr = skip_spaces(str);\n\tlen = label_count_str_entries(str);\n\tif (*str == '&' || force_stack) {\n\t\t/* stack on top of base */\n\t\tstack = base->size;\n\t\tlen += stack;\n\t\tif (*str == '&')\n\t\t\tstr++;\n\t}\n\tif (*str == '=')\n\t\tbase = &root_ns->unconfined->label;\n\n\terror = vec_setup(profile, vec, len, gfp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tfor (i = 0; i < stack; i++)\n\t\tvec[i] = aa_get_profile(base->vec[i]);\n\n\tfor (split = strstr(str, \"//&\"), i = stack; split && i < len; i++) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, split - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t\t/*\n\t\t * if component specified a new ns it becomes the new base\n\t\t * so that subsequent lookups are relative to it\n\t\t */\n\t\tif (vec[i]->ns != labels_ns(currbase))\n\t\t\tcurrbase = &vec[i]->label;\n\t\tstr = split + 3;\n\t\tsplit = strstr(str, \"//&\");\n\t}\n\t/* last element doesn't have a split */\n\tif (i < len) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, strlen(str));\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t}\n\tif (len == 1)\n\t\t/* no need to free vec as len < LOCAL_VEC_ENTRIES */\n\t\treturn &vec[0]->label;\n\n\tlen -= aa_vec_unique(vec, len, VEC_FLAG_TERMINATE);\n\t/* TODO: deal with reference labels */\n\tif (len == 1) {\n\t\tlabel = aa_get_label(&vec[0]->label);\n\t\tgoto out;\n\t}\n\n\tif (create)\n\t\tlabel = aa_vec_find_or_create_label(vec, len, gfp);\n\telse\n\t\tlabel = vec_find(vec, len);\n\tif (!label)\n\t\tgoto fail;\n\nout:\n\t/* use adjusted len from after vec_unique, not original */\n\tvec_cleanup(profile, vec, len);\n\treturn label;\n\nfail:\n\tlabel = ERR_PTR(-ENOENT);\n\tgoto out;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack)\n{\n\tDEFINE_VEC(profile, vec);\n\tstruct aa_label *label, *currbase = base;\n\tint i, len, stack = 0, error;\n\tchar *split;\n\n\tAA_BUG(!base);\n\tAA_BUG(!str);\n\n\tstr = skip_spaces(str);\n\tlen = label_count_str_entries(str);\n\tif (*str == '&' || force_stack) {\n\t\t/* stack on top of base */\n\t\tstack = base->size;\n\t\tlen += stack;\n\t\tif (*str == '&')\n\t\t\tstr++;\n\t}\n\tif (*str == '=')\n\t\tbase = &root_ns->unconfined->label;\n\n\terror = vec_setup(profile, vec, len, gfp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tfor (i = 0; i < stack; i++)\n\t\tvec[i] = aa_get_profile(base->vec[i]);\n\n\tfor (split = strstr(str, \"//&\"), i = stack; split && i < len; i++) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, split - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t\t/*\n\t\t * if component specified a new ns it becomes the new base\n\t\t * so that subsequent lookups are relative to it\n\t\t */\n\t\tif (vec[i]->ns != labels_ns(currbase))\n\t\t\tcurrbase = &vec[i]->label;\n\t\tstr = split + 3;\n\t\tsplit = strstr(str, \"//&\");\n\t}\n\t/* last element doesn't have a split */\n\tif (i < len) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, strlen(str));\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t}\n\tif (len == 1)\n\t\t/* no need to free vec as len < LOCAL_VEC_ENTRIES */\n\t\treturn &vec[0]->label;\n\n\tlen -= aa_vec_unique(vec, len, VEC_FLAG_TERMINATE);\n\t/* TODO: deal with reference labels */\n\tif (len == 1) {\n\t\tlabel = aa_get_label(&vec[0]->label);\n\t\tgoto out;\n\t}\n\n\tif (create)\n\t\tlabel = aa_vec_find_or_create_label(vec, len, gfp);\n\telse\n\t\tlabel = vec_find(vec, len);\n\tif (!label)\n\t\tgoto fail;\n\nout:\n\t/* use adjusted len from after vec_unique, not original */\n\tvec_cleanup(profile, vec, len);\n\treturn label;\n\nfail:\n\tlabel = ERR_PTR(-ENOENT);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_newest_label",
          "args": [
            "ns_unconfined(profile->ns)"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "393-414",
          "snippet": "static inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_unconfined",
          "args": [
            "profile->ns"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_attach",
          "args": [
            "ns",
            "&ns->base.profiles",
            "name",
            "info"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "find_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "372-382",
          "snippet": "static struct aa_label *find_attach(struct aa_ns *ns, struct list_head *list,\n\t\t\t\t    const char *name, const char **info)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tprofile = aa_get_profile(__attach_match(name, list, info));\n\trcu_read_unlock();\n\n\treturn profile ? &profile->label : NULL;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_label *find_attach(struct aa_ns *ns, struct list_head *list,\n\t\t\t\t    const char *name, const char **info)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tprofile = aa_get_profile(__attach_match(name, list, info));\n\trcu_read_unlock();\n\n\treturn profile ? &profile->label : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x_table_lookup",
          "args": [
            "profile",
            "xindex",
            "lookupname"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "x_table_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "397-429",
          "snippet": "struct aa_label *x_table_lookup(struct aa_profile *profile, u32 xindex,\n\t\t\t\tconst char **name)\n{\n\tstruct aa_label *label = NULL;\n\tu32 xtype = xindex & AA_X_TYPE_MASK;\n\tint index = xindex & AA_X_INDEX_MASK;\n\n\tAA_BUG(!name);\n\n\t/* index is guaranteed to be in range, validated at load time */\n\t/* TODO: move lookup parsing to unpack time so this is a straight\n\t *       index into the resultant label\n\t */\n\tfor (*name = profile->file.trans.table[index]; !label && *name;\n\t     *name = next_name(xtype, *name)) {\n\t\tif (xindex & AA_X_CHILD) {\n\t\t\tstruct aa_profile *new_profile;\n\t\t\t/* release by caller */\n\t\t\tnew_profile = aa_find_child(profile, *name);\n\t\t\tif (new_profile)\n\t\t\t\tlabel = &new_profile->label;\n\t\t\tcontinue;\n\t\t}\n\t\tlabel = aa_label_parse(&profile->label, *name, GFP_ATOMIC,\n\t\t\t\t       true, false);\n\t\tif (IS_ERR(label))\n\t\t\tlabel = NULL;\n\t}\n\n\t/* released by caller */\n\n\treturn label;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstruct aa_label *x_table_lookup(struct aa_profile *profile, u32 xindex,\n\t\t\t\tconst char **name)\n{\n\tstruct aa_label *label = NULL;\n\tu32 xtype = xindex & AA_X_TYPE_MASK;\n\tint index = xindex & AA_X_INDEX_MASK;\n\n\tAA_BUG(!name);\n\n\t/* index is guaranteed to be in range, validated at load time */\n\t/* TODO: move lookup parsing to unpack time so this is a straight\n\t *       index into the resultant label\n\t */\n\tfor (*name = profile->file.trans.table[index]; !label && *name;\n\t     *name = next_name(xtype, *name)) {\n\t\tif (xindex & AA_X_CHILD) {\n\t\t\tstruct aa_profile *new_profile;\n\t\t\t/* release by caller */\n\t\t\tnew_profile = aa_find_child(profile, *name);\n\t\t\tif (new_profile)\n\t\t\t\tlabel = &new_profile->label;\n\t\t\tcontinue;\n\t\t}\n\t\tlabel = aa_label_parse(&profile->label, *name, GFP_ATOMIC,\n\t\t\t\t       true, false);\n\t\tif (IS_ERR(label))\n\t\t\tlabel = NULL;\n\t}\n\n\t/* released by caller */\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_label *x_to_label(struct aa_profile *profile,\n\t\t\t\t   const char *name, u32 xindex,\n\t\t\t\t   const char **lookupname,\n\t\t\t\t   const char **info)\n{\n\tstruct aa_label *new = NULL;\n\tstruct aa_ns *ns = profile->ns;\n\tu32 xtype = xindex & AA_X_TYPE_MASK;\n\tconst char *stack = NULL;\n\n\tswitch (xtype) {\n\tcase AA_X_NONE:\n\t\t/* fail exec unless ix || ux fallback - handled by caller */\n\t\t*lookupname = NULL;\n\t\tbreak;\n\tcase AA_X_TABLE:\n\t\t/* TODO: fix when perm mapping done at unload */\n\t\tstack = profile->file.trans.table[xindex & AA_X_INDEX_MASK];\n\t\tif (*stack != '&') {\n\t\t\t/* released by caller */\n\t\t\tnew = x_table_lookup(profile, xindex, lookupname);\n\t\t\tstack = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through to X_NAME */\n\tcase AA_X_NAME:\n\t\tif (xindex & AA_X_CHILD)\n\t\t\t/* released by caller */\n\t\t\tnew = find_attach(ns, &profile->base.profiles,\n\t\t\t\t\t  name, info);\n\t\telse\n\t\t\t/* released by caller */\n\t\t\tnew = find_attach(ns, &ns->base.profiles,\n\t\t\t\t\t  name, info);\n\t\t*lookupname = name;\n\t\tbreak;\n\t}\n\n\tif (!new) {\n\t\tif (xindex & AA_X_INHERIT) {\n\t\t\t/* (p|c|n)ix - don't change profile but do\n\t\t\t * use the newest version\n\t\t\t */\n\t\t\t*info = \"ix fallback\";\n\t\t\t/* no profile && no error */\n\t\t\tnew = aa_get_newest_label(&profile->label);\n\t\t} else if (xindex & AA_X_UNCONFINED) {\n\t\t\tnew = aa_get_newest_label(ns_unconfined(profile->ns));\n\t\t\t*info = \"ux fallback\";\n\t\t}\n\t}\n\n\tif (new && stack) {\n\t\t/* base the stack on post domain transition */\n\t\tstruct aa_label *base = new;\n\n\t\tnew = aa_label_parse(base, stack, GFP_ATOMIC, true, false);\n\t\tif (IS_ERR(new))\n\t\t\tnew = NULL;\n\t\taa_put_label(base);\n\t}\n\n\t/* released by caller */\n\treturn new;\n}"
  },
  {
    "function_name": "x_table_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "397-429",
    "snippet": "struct aa_label *x_table_lookup(struct aa_profile *profile, u32 xindex,\n\t\t\t\tconst char **name)\n{\n\tstruct aa_label *label = NULL;\n\tu32 xtype = xindex & AA_X_TYPE_MASK;\n\tint index = xindex & AA_X_INDEX_MASK;\n\n\tAA_BUG(!name);\n\n\t/* index is guaranteed to be in range, validated at load time */\n\t/* TODO: move lookup parsing to unpack time so this is a straight\n\t *       index into the resultant label\n\t */\n\tfor (*name = profile->file.trans.table[index]; !label && *name;\n\t     *name = next_name(xtype, *name)) {\n\t\tif (xindex & AA_X_CHILD) {\n\t\t\tstruct aa_profile *new_profile;\n\t\t\t/* release by caller */\n\t\t\tnew_profile = aa_find_child(profile, *name);\n\t\t\tif (new_profile)\n\t\t\t\tlabel = &new_profile->label;\n\t\t\tcontinue;\n\t\t}\n\t\tlabel = aa_label_parse(&profile->label, *name, GFP_ATOMIC,\n\t\t\t\t       true, false);\n\t\tif (IS_ERR(label))\n\t\t\tlabel = NULL;\n\t}\n\n\t/* released by caller */\n\n\treturn label;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "label"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_parse",
          "args": [
            "&profile->label",
            "*name",
            "GFP_ATOMIC",
            "true",
            "false"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1856-1931",
          "snippet": "struct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack)\n{\n\tDEFINE_VEC(profile, vec);\n\tstruct aa_label *label, *currbase = base;\n\tint i, len, stack = 0, error;\n\tchar *split;\n\n\tAA_BUG(!base);\n\tAA_BUG(!str);\n\n\tstr = skip_spaces(str);\n\tlen = label_count_str_entries(str);\n\tif (*str == '&' || force_stack) {\n\t\t/* stack on top of base */\n\t\tstack = base->size;\n\t\tlen += stack;\n\t\tif (*str == '&')\n\t\t\tstr++;\n\t}\n\tif (*str == '=')\n\t\tbase = &root_ns->unconfined->label;\n\n\terror = vec_setup(profile, vec, len, gfp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tfor (i = 0; i < stack; i++)\n\t\tvec[i] = aa_get_profile(base->vec[i]);\n\n\tfor (split = strstr(str, \"//&\"), i = stack; split && i < len; i++) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, split - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t\t/*\n\t\t * if component specified a new ns it becomes the new base\n\t\t * so that subsequent lookups are relative to it\n\t\t */\n\t\tif (vec[i]->ns != labels_ns(currbase))\n\t\t\tcurrbase = &vec[i]->label;\n\t\tstr = split + 3;\n\t\tsplit = strstr(str, \"//&\");\n\t}\n\t/* last element doesn't have a split */\n\tif (i < len) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, strlen(str));\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t}\n\tif (len == 1)\n\t\t/* no need to free vec as len < LOCAL_VEC_ENTRIES */\n\t\treturn &vec[0]->label;\n\n\tlen -= aa_vec_unique(vec, len, VEC_FLAG_TERMINATE);\n\t/* TODO: deal with reference labels */\n\tif (len == 1) {\n\t\tlabel = aa_get_label(&vec[0]->label);\n\t\tgoto out;\n\t}\n\n\tif (create)\n\t\tlabel = aa_vec_find_or_create_label(vec, len, gfp);\n\telse\n\t\tlabel = vec_find(vec, len);\n\tif (!label)\n\t\tgoto fail;\n\nout:\n\t/* use adjusted len from after vec_unique, not original */\n\tvec_cleanup(profile, vec, len);\n\treturn label;\n\nfail:\n\tlabel = ERR_PTR(-ENOENT);\n\tgoto out;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack)\n{\n\tDEFINE_VEC(profile, vec);\n\tstruct aa_label *label, *currbase = base;\n\tint i, len, stack = 0, error;\n\tchar *split;\n\n\tAA_BUG(!base);\n\tAA_BUG(!str);\n\n\tstr = skip_spaces(str);\n\tlen = label_count_str_entries(str);\n\tif (*str == '&' || force_stack) {\n\t\t/* stack on top of base */\n\t\tstack = base->size;\n\t\tlen += stack;\n\t\tif (*str == '&')\n\t\t\tstr++;\n\t}\n\tif (*str == '=')\n\t\tbase = &root_ns->unconfined->label;\n\n\terror = vec_setup(profile, vec, len, gfp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tfor (i = 0; i < stack; i++)\n\t\tvec[i] = aa_get_profile(base->vec[i]);\n\n\tfor (split = strstr(str, \"//&\"), i = stack; split && i < len; i++) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, split - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t\t/*\n\t\t * if component specified a new ns it becomes the new base\n\t\t * so that subsequent lookups are relative to it\n\t\t */\n\t\tif (vec[i]->ns != labels_ns(currbase))\n\t\t\tcurrbase = &vec[i]->label;\n\t\tstr = split + 3;\n\t\tsplit = strstr(str, \"//&\");\n\t}\n\t/* last element doesn't have a split */\n\tif (i < len) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, strlen(str));\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t}\n\tif (len == 1)\n\t\t/* no need to free vec as len < LOCAL_VEC_ENTRIES */\n\t\treturn &vec[0]->label;\n\n\tlen -= aa_vec_unique(vec, len, VEC_FLAG_TERMINATE);\n\t/* TODO: deal with reference labels */\n\tif (len == 1) {\n\t\tlabel = aa_get_label(&vec[0]->label);\n\t\tgoto out;\n\t}\n\n\tif (create)\n\t\tlabel = aa_vec_find_or_create_label(vec, len, gfp);\n\telse\n\t\tlabel = vec_find(vec, len);\n\tif (!label)\n\t\tgoto fail;\n\nout:\n\t/* use adjusted len from after vec_unique, not original */\n\tvec_cleanup(profile, vec, len);\n\treturn label;\n\nfail:\n\tlabel = ERR_PTR(-ENOENT);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_find_child",
          "args": [
            "profile",
            "*name"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "aa_find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "331-343",
          "snippet": "struct aa_profile *aa_find_child(struct aa_profile *parent, const char *name)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tdo {\n\t\tprofile = __find_child(&parent->base.profiles, name);\n\t} while (profile && !aa_get_profile_not0(profile));\n\trcu_read_unlock();\n\n\t/* refcount released by caller */\n\treturn profile;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct aa_profile *aa_find_child(struct aa_profile *parent, const char *name)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tdo {\n\t\tprofile = __find_child(&parent->base.profiles, name);\n\t} while (profile && !aa_get_profile_not0(profile));\n\trcu_read_unlock();\n\n\t/* refcount released by caller */\n\treturn profile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_name",
          "args": [
            "xtype",
            "*name"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "next_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "384-387",
          "snippet": "static const char *next_name(int xtype, const char *name)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic const char *next_name(int xtype, const char *name)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!name"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstruct aa_label *x_table_lookup(struct aa_profile *profile, u32 xindex,\n\t\t\t\tconst char **name)\n{\n\tstruct aa_label *label = NULL;\n\tu32 xtype = xindex & AA_X_TYPE_MASK;\n\tint index = xindex & AA_X_INDEX_MASK;\n\n\tAA_BUG(!name);\n\n\t/* index is guaranteed to be in range, validated at load time */\n\t/* TODO: move lookup parsing to unpack time so this is a straight\n\t *       index into the resultant label\n\t */\n\tfor (*name = profile->file.trans.table[index]; !label && *name;\n\t     *name = next_name(xtype, *name)) {\n\t\tif (xindex & AA_X_CHILD) {\n\t\t\tstruct aa_profile *new_profile;\n\t\t\t/* release by caller */\n\t\t\tnew_profile = aa_find_child(profile, *name);\n\t\t\tif (new_profile)\n\t\t\t\tlabel = &new_profile->label;\n\t\t\tcontinue;\n\t\t}\n\t\tlabel = aa_label_parse(&profile->label, *name, GFP_ATOMIC,\n\t\t\t\t       true, false);\n\t\tif (IS_ERR(label))\n\t\t\tlabel = NULL;\n\t}\n\n\t/* released by caller */\n\n\treturn label;\n}"
  },
  {
    "function_name": "next_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "384-387",
    "snippet": "static const char *next_name(int xtype, const char *name)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic const char *next_name(int xtype, const char *name)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "372-382",
    "snippet": "static struct aa_label *find_attach(struct aa_ns *ns, struct list_head *list,\n\t\t\t\t    const char *name, const char **info)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tprofile = aa_get_profile(__attach_match(name, list, info));\n\trcu_read_unlock();\n\n\treturn profile ? &profile->label : NULL;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_profile",
          "args": [
            "__attach_match(name, list, info)"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_profile_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "260-271",
          "snippet": "static inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__attach_match",
          "args": [
            "name",
            "list",
            "info"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "__attach_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "319-361",
          "snippet": "static struct aa_profile *__attach_match(const char *name,\n\t\t\t\t\t struct list_head *head,\n\t\t\t\t\t const char **info)\n{\n\tint len = 0;\n\tbool conflict = false;\n\tstruct aa_profile *profile, *candidate = NULL;\n\n\tlist_for_each_entry_rcu(profile, head, base.list) {\n\t\tif (profile->label.flags & FLAG_NULL &&\n\t\t    &profile->label == ns_unconfined(profile->ns))\n\t\t\tcontinue;\n\n\t\tif (profile->xmatch) {\n\t\t\tif (profile->xmatch_len == len) {\n\t\t\t\tconflict = true;\n\t\t\t\tcontinue;\n\t\t\t} else if (profile->xmatch_len > len) {\n\t\t\t\tunsigned int state;\n\t\t\t\tu32 perm;\n\n\t\t\t\tstate = aa_dfa_match(profile->xmatch,\n\t\t\t\t\t\t     DFA_START, name);\n\t\t\t\tperm = dfa_user_allow(profile->xmatch, state);\n\t\t\t\t/* any accepting state means a valid match. */\n\t\t\t\tif (perm & MAY_EXEC) {\n\t\t\t\t\tcandidate = profile;\n\t\t\t\t\tlen = profile->xmatch_len;\n\t\t\t\t\tconflict = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strcmp(profile->base.name, name))\n\t\t\t/* exact non-re match, no more searching required */\n\t\t\treturn profile;\n\t}\n\n\tif (conflict) {\n\t\t*info = \"conflicting profile attachments\";\n\t\treturn NULL;\n\t}\n\n\treturn candidate;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_profile *__attach_match(const char *name,\n\t\t\t\t\t struct list_head *head,\n\t\t\t\t\t const char **info)\n{\n\tint len = 0;\n\tbool conflict = false;\n\tstruct aa_profile *profile, *candidate = NULL;\n\n\tlist_for_each_entry_rcu(profile, head, base.list) {\n\t\tif (profile->label.flags & FLAG_NULL &&\n\t\t    &profile->label == ns_unconfined(profile->ns))\n\t\t\tcontinue;\n\n\t\tif (profile->xmatch) {\n\t\t\tif (profile->xmatch_len == len) {\n\t\t\t\tconflict = true;\n\t\t\t\tcontinue;\n\t\t\t} else if (profile->xmatch_len > len) {\n\t\t\t\tunsigned int state;\n\t\t\t\tu32 perm;\n\n\t\t\t\tstate = aa_dfa_match(profile->xmatch,\n\t\t\t\t\t\t     DFA_START, name);\n\t\t\t\tperm = dfa_user_allow(profile->xmatch, state);\n\t\t\t\t/* any accepting state means a valid match. */\n\t\t\t\tif (perm & MAY_EXEC) {\n\t\t\t\t\tcandidate = profile;\n\t\t\t\t\tlen = profile->xmatch_len;\n\t\t\t\t\tconflict = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strcmp(profile->base.name, name))\n\t\t\t/* exact non-re match, no more searching required */\n\t\t\treturn profile;\n\t}\n\n\tif (conflict) {\n\t\t*info = \"conflicting profile attachments\";\n\t\treturn NULL;\n\t}\n\n\treturn candidate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_label *find_attach(struct aa_ns *ns, struct list_head *list,\n\t\t\t\t    const char *name, const char **info)\n{\n\tstruct aa_profile *profile;\n\n\trcu_read_lock();\n\tprofile = aa_get_profile(__attach_match(name, list, info));\n\trcu_read_unlock();\n\n\treturn profile ? &profile->label : NULL;\n}"
  },
  {
    "function_name": "__attach_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "319-361",
    "snippet": "static struct aa_profile *__attach_match(const char *name,\n\t\t\t\t\t struct list_head *head,\n\t\t\t\t\t const char **info)\n{\n\tint len = 0;\n\tbool conflict = false;\n\tstruct aa_profile *profile, *candidate = NULL;\n\n\tlist_for_each_entry_rcu(profile, head, base.list) {\n\t\tif (profile->label.flags & FLAG_NULL &&\n\t\t    &profile->label == ns_unconfined(profile->ns))\n\t\t\tcontinue;\n\n\t\tif (profile->xmatch) {\n\t\t\tif (profile->xmatch_len == len) {\n\t\t\t\tconflict = true;\n\t\t\t\tcontinue;\n\t\t\t} else if (profile->xmatch_len > len) {\n\t\t\t\tunsigned int state;\n\t\t\t\tu32 perm;\n\n\t\t\t\tstate = aa_dfa_match(profile->xmatch,\n\t\t\t\t\t\t     DFA_START, name);\n\t\t\t\tperm = dfa_user_allow(profile->xmatch, state);\n\t\t\t\t/* any accepting state means a valid match. */\n\t\t\t\tif (perm & MAY_EXEC) {\n\t\t\t\t\tcandidate = profile;\n\t\t\t\t\tlen = profile->xmatch_len;\n\t\t\t\t\tconflict = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strcmp(profile->base.name, name))\n\t\t\t/* exact non-re match, no more searching required */\n\t\t\treturn profile;\n\t}\n\n\tif (conflict) {\n\t\t*info = \"conflicting profile attachments\";\n\t\treturn NULL;\n\t}\n\n\treturn candidate;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "profile->base.name",
            "name"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfa_user_allow",
          "args": [
            "profile->xmatch",
            "state"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_dfa_match",
          "args": [
            "profile->xmatch",
            "DFA_START",
            "name"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "381-417",
          "snippet": "unsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_unconfined",
          "args": [
            "profile->ns"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "profile",
            "head",
            "base.list"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic struct aa_profile *__attach_match(const char *name,\n\t\t\t\t\t struct list_head *head,\n\t\t\t\t\t const char **info)\n{\n\tint len = 0;\n\tbool conflict = false;\n\tstruct aa_profile *profile, *candidate = NULL;\n\n\tlist_for_each_entry_rcu(profile, head, base.list) {\n\t\tif (profile->label.flags & FLAG_NULL &&\n\t\t    &profile->label == ns_unconfined(profile->ns))\n\t\t\tcontinue;\n\n\t\tif (profile->xmatch) {\n\t\t\tif (profile->xmatch_len == len) {\n\t\t\t\tconflict = true;\n\t\t\t\tcontinue;\n\t\t\t} else if (profile->xmatch_len > len) {\n\t\t\t\tunsigned int state;\n\t\t\t\tu32 perm;\n\n\t\t\t\tstate = aa_dfa_match(profile->xmatch,\n\t\t\t\t\t\t     DFA_START, name);\n\t\t\t\tperm = dfa_user_allow(profile->xmatch, state);\n\t\t\t\t/* any accepting state means a valid match. */\n\t\t\t\tif (perm & MAY_EXEC) {\n\t\t\t\t\tcandidate = profile;\n\t\t\t\t\tlen = profile->xmatch_len;\n\t\t\t\t\tconflict = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!strcmp(profile->base.name, name))\n\t\t\t/* exact non-re match, no more searching required */\n\t\t\treturn profile;\n\t}\n\n\tif (conflict) {\n\t\t*info = \"conflicting profile attachments\";\n\t\treturn NULL;\n\t}\n\n\treturn candidate;\n}"
  },
  {
    "function_name": "change_profile_perms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "289-302",
    "snippet": "static int change_profile_perms(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *target, bool stack,\n\t\t\t\tu32 request, unsigned int start,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tif (profile_unconfined(profile)) {\n\t\tperms->allow = AA_MAY_CHANGE_PROFILE | AA_MAY_ONEXEC;\n\t\tperms->audit = perms->quiet = perms->kill = 0;\n\t\treturn 0;\n\t}\n\n\t/* TODO: add profile in ns screening */\n\treturn label_match(profile, target, stack, start, true, request, perms);\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "label_match",
          "args": [
            "profile",
            "target",
            "stack",
            "start",
            "true",
            "request",
            "perms"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "label_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "256-271",
          "snippet": "static int label_match(struct aa_profile *profile, struct aa_label *label,\n\t\t       bool stack, unsigned int state, bool subns, u32 request,\n\t\t       struct aa_perms *perms)\n{\n\tint error;\n\n\t*perms = nullperms;\n\terror = label_compound_match(profile, label, stack, state, subns,\n\t\t\t\t     request, perms);\n\tif (!error)\n\t\treturn error;\n\n\t*perms = allperms;\n\treturn label_components_match(profile, label, stack, state, subns,\n\t\t\t\t      request, perms);\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int label_match(struct aa_profile *profile, struct aa_label *label,\n\t\t       bool stack, unsigned int state, bool subns, u32 request,\n\t\t       struct aa_perms *perms)\n{\n\tint error;\n\n\t*perms = nullperms;\n\terror = label_compound_match(profile, label, stack, state, subns,\n\t\t\t\t     request, perms);\n\tif (!error)\n\t\treturn error;\n\n\t*perms = allperms;\n\treturn label_components_match(profile, label, stack, state, subns,\n\t\t\t\t      request, perms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int change_profile_perms(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *target, bool stack,\n\t\t\t\tu32 request, unsigned int start,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tif (profile_unconfined(profile)) {\n\t\tperms->allow = AA_MAY_CHANGE_PROFILE | AA_MAY_ONEXEC;\n\t\tperms->audit = perms->quiet = perms->kill = 0;\n\t\treturn 0;\n\t}\n\n\t/* TODO: add profile in ns screening */\n\treturn label_match(profile, target, stack, start, true, request, perms);\n}"
  },
  {
    "function_name": "label_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "256-271",
    "snippet": "static int label_match(struct aa_profile *profile, struct aa_label *label,\n\t\t       bool stack, unsigned int state, bool subns, u32 request,\n\t\t       struct aa_perms *perms)\n{\n\tint error;\n\n\t*perms = nullperms;\n\terror = label_compound_match(profile, label, stack, state, subns,\n\t\t\t\t     request, perms);\n\tif (!error)\n\t\treturn error;\n\n\t*perms = allperms;\n\treturn label_components_match(profile, label, stack, state, subns,\n\t\t\t\t      request, perms);\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "label_components_match",
          "args": [
            "profile",
            "label",
            "stack",
            "state",
            "subns",
            "request",
            "perms"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "label_components_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "195-242",
          "snippet": "static int label_components_match(struct aa_profile *profile,\n\t\t\t\t  struct aa_label *label, bool stack,\n\t\t\t\t  unsigned int start, bool subns, u32 request,\n\t\t\t\t  struct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct aa_perms tmp;\n\tstruct path_cond cond = { };\n\tunsigned int state = 0;\n\n\t/* find first subcomponent to test */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no subcomponents visible - no change in perms */\n\treturn 0;\n\nnext:\n\ttmp = aa_compute_fperms(profile->file.dfa, state, &cond);\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum(perms, &tmp);\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\ttmp = aa_compute_fperms(profile->file.dfa, state, &cond);\n\t\taa_apply_modes_to_perms(profile, &tmp);\n\t\taa_perms_accum(perms, &tmp);\n\t}\n\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int label_components_match(struct aa_profile *profile,\n\t\t\t\t  struct aa_label *label, bool stack,\n\t\t\t\t  unsigned int start, bool subns, u32 request,\n\t\t\t\t  struct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct aa_perms tmp;\n\tstruct path_cond cond = { };\n\tunsigned int state = 0;\n\n\t/* find first subcomponent to test */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no subcomponents visible - no change in perms */\n\treturn 0;\n\nnext:\n\ttmp = aa_compute_fperms(profile->file.dfa, state, &cond);\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum(perms, &tmp);\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\ttmp = aa_compute_fperms(profile->file.dfa, state, &cond);\n\t\taa_apply_modes_to_perms(profile, &tmp);\n\t\taa_perms_accum(perms, &tmp);\n\t}\n\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_compound_match",
          "args": [
            "profile",
            "label",
            "stack",
            "state",
            "subns",
            "request",
            "perms"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "label_compound_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "135-177",
          "snippet": "static int label_compound_match(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *label, bool stack,\n\t\t\t\tunsigned int state, bool subns, u32 request,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct path_cond cond = { };\n\n\t/* find first subcomponent that is visible */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no component visible */\n\t*perms = allperms;\n\treturn 0;\n\nnext:\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = aa_dfa_match(profile->file.dfa, state, \"//&\");\n\t\tstate = match_component(profile, tp, false, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t}\n\t*perms = aa_compute_fperms(profile->file.dfa, state, &cond);\n\taa_apply_modes_to_perms(profile, perms);\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int label_compound_match(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *label, bool stack,\n\t\t\t\tunsigned int state, bool subns, u32 request,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct path_cond cond = { };\n\n\t/* find first subcomponent that is visible */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no component visible */\n\t*perms = allperms;\n\treturn 0;\n\nnext:\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = aa_dfa_match(profile->file.dfa, state, \"//&\");\n\t\tstate = match_component(profile, tp, false, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t}\n\t*perms = aa_compute_fperms(profile->file.dfa, state, &cond);\n\taa_apply_modes_to_perms(profile, perms);\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int label_match(struct aa_profile *profile, struct aa_label *label,\n\t\t       bool stack, unsigned int state, bool subns, u32 request,\n\t\t       struct aa_perms *perms)\n{\n\tint error;\n\n\t*perms = nullperms;\n\terror = label_compound_match(profile, label, stack, state, subns,\n\t\t\t\t     request, perms);\n\tif (!error)\n\t\treturn error;\n\n\t*perms = allperms;\n\treturn label_components_match(profile, label, stack, state, subns,\n\t\t\t\t      request, perms);\n}"
  },
  {
    "function_name": "label_components_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "195-242",
    "snippet": "static int label_components_match(struct aa_profile *profile,\n\t\t\t\t  struct aa_label *label, bool stack,\n\t\t\t\t  unsigned int start, bool subns, u32 request,\n\t\t\t\t  struct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct aa_perms tmp;\n\tstruct path_cond cond = { };\n\tunsigned int state = 0;\n\n\t/* find first subcomponent to test */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no subcomponents visible - no change in perms */\n\treturn 0;\n\nnext:\n\ttmp = aa_compute_fperms(profile->file.dfa, state, &cond);\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum(perms, &tmp);\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\ttmp = aa_compute_fperms(profile->file.dfa, state, &cond);\n\t\taa_apply_modes_to_perms(profile, &tmp);\n\t\taa_perms_accum(perms, &tmp);\n\t}\n\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_perms_accum",
          "args": [
            "perms",
            "&tmp"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "aa_perms_accum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "359-371",
          "snippet": "void aa_perms_accum(struct aa_perms *accum, struct aa_perms *addend)\n{\n\taccum->deny |= addend->deny;\n\taccum->allow &= addend->allow & ~accum->deny;\n\taccum->audit |= addend->audit & accum->allow;\n\taccum->quiet &= addend->quiet & ~accum->allow;\n\taccum->kill |= addend->kill & ~accum->allow;\n\taccum->stop |= addend->stop & ~accum->allow;\n\taccum->complain |= addend->complain & ~accum->allow & ~accum->deny;\n\taccum->cond |= addend->cond & ~accum->allow & ~accum->deny;\n\taccum->hide &= addend->hide & ~accum->allow;\n\taccum->prompt |= addend->prompt & ~accum->allow & ~accum->deny;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_perms_accum(struct aa_perms *accum, struct aa_perms *addend)\n{\n\taccum->deny |= addend->deny;\n\taccum->allow &= addend->allow & ~accum->deny;\n\taccum->audit |= addend->audit & accum->allow;\n\taccum->quiet &= addend->quiet & ~accum->allow;\n\taccum->kill |= addend->kill & ~accum->allow;\n\taccum->stop |= addend->stop & ~accum->allow;\n\taccum->complain |= addend->complain & ~accum->allow & ~accum->deny;\n\taccum->cond |= addend->cond & ~accum->allow & ~accum->deny;\n\taccum->hide &= addend->hide & ~accum->allow;\n\taccum->prompt |= addend->prompt & ~accum->allow & ~accum->deny;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_apply_modes_to_perms",
          "args": [
            "profile",
            "&tmp"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "aa_apply_modes_to_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "282-308",
          "snippet": "void aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_compute_fperms",
          "args": [
            "profile->file.dfa",
            "state",
            "&cond"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "aa_compute_fperms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "226-256",
          "snippet": "struct aa_perms aa_compute_fperms(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t  struct path_cond *cond)\n{\n\t/* FIXME: change over to new dfa format\n\t * currently file perms are encoded in the dfa, new format\n\t * splits the permissions from the dfa.  This mapping can be\n\t * done at profile load\n\t */\n\tstruct aa_perms perms = { };\n\n\tif (uid_eq(current_fsuid(), cond->uid)) {\n\t\tperms.allow = map_old_perms(dfa_user_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_user_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_user_quiet(dfa, state));\n\t\tperms.xindex = dfa_user_xindex(dfa, state);\n\t} else {\n\t\tperms.allow = map_old_perms(dfa_other_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_other_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_other_quiet(dfa, state));\n\t\tperms.xindex = dfa_other_xindex(dfa, state);\n\t}\n\tperms.allow |= AA_MAY_GETATTR;\n\n\t/* change_profile wasn't determined by ownership in old mapping */\n\tif (ACCEPT_TABLE(dfa)[state] & 0x80000000)\n\t\tperms.allow |= AA_MAY_CHANGE_PROFILE;\n\tif (ACCEPT_TABLE(dfa)[state] & 0x40000000)\n\t\tperms.allow |= AA_MAY_ONEXEC;\n\n\treturn perms;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstruct aa_perms aa_compute_fperms(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t  struct path_cond *cond)\n{\n\t/* FIXME: change over to new dfa format\n\t * currently file perms are encoded in the dfa, new format\n\t * splits the permissions from the dfa.  This mapping can be\n\t * done at profile load\n\t */\n\tstruct aa_perms perms = { };\n\n\tif (uid_eq(current_fsuid(), cond->uid)) {\n\t\tperms.allow = map_old_perms(dfa_user_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_user_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_user_quiet(dfa, state));\n\t\tperms.xindex = dfa_user_xindex(dfa, state);\n\t} else {\n\t\tperms.allow = map_old_perms(dfa_other_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_other_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_other_quiet(dfa, state));\n\t\tperms.xindex = dfa_other_xindex(dfa, state);\n\t}\n\tperms.allow |= AA_MAY_GETATTR;\n\n\t/* change_profile wasn't determined by ownership in old mapping */\n\tif (ACCEPT_TABLE(dfa)[state] & 0x80000000)\n\t\tperms.allow |= AA_MAY_CHANGE_PROFILE;\n\tif (ACCEPT_TABLE(dfa)[state] & 0x40000000)\n\t\tperms.allow |= AA_MAY_ONEXEC;\n\n\treturn perms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_component",
          "args": [
            "profile",
            "tp",
            "stack",
            "start"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "match_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "100-117",
          "snippet": "static inline unsigned int match_component(struct aa_profile *profile,\n\t\t\t\t\t   struct aa_profile *tp,\n\t\t\t\t\t   bool stack, unsigned int state)\n{\n\tconst char *ns_name;\n\n\tif (stack)\n\t\tstate = aa_dfa_match(profile->file.dfa, state, \"&\");\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(profile->file.dfa, state, tp->base.hname);\n\n\t/* try matching with namespace name and then profile */\n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(profile->file.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(profile->file.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(profile->file.dfa, state, \":\", 1);\n\treturn aa_dfa_match(profile->file.dfa, state, tp->base.hname);\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic inline unsigned int match_component(struct aa_profile *profile,\n\t\t\t\t\t   struct aa_profile *tp,\n\t\t\t\t\t   bool stack, unsigned int state)\n{\n\tconst char *ns_name;\n\n\tif (stack)\n\t\tstate = aa_dfa_match(profile->file.dfa, state, \"&\");\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(profile->file.dfa, state, tp->base.hname);\n\n\t/* try matching with namespace name and then profile */\n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(profile->file.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(profile->file.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(profile->file.dfa, state, \":\", 1);\n\treturn aa_dfa_match(profile->file.dfa, state, tp->base.hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_ns_visible",
          "args": [
            "profile->ns",
            "tp->ns",
            "subns"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "aa_ns_visible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "41-55",
          "snippet": "bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nbool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_for_each_cont",
          "args": [
            "i",
            "label",
            "tp"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_for_each",
          "args": [
            "i",
            "label",
            "tp"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int label_components_match(struct aa_profile *profile,\n\t\t\t\t  struct aa_label *label, bool stack,\n\t\t\t\t  unsigned int start, bool subns, u32 request,\n\t\t\t\t  struct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct aa_perms tmp;\n\tstruct path_cond cond = { };\n\tunsigned int state = 0;\n\n\t/* find first subcomponent to test */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no subcomponents visible - no change in perms */\n\treturn 0;\n\nnext:\n\ttmp = aa_compute_fperms(profile->file.dfa, state, &cond);\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum(perms, &tmp);\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\ttmp = aa_compute_fperms(profile->file.dfa, state, &cond);\n\t\taa_apply_modes_to_perms(profile, &tmp);\n\t\taa_perms_accum(perms, &tmp);\n\t}\n\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}"
  },
  {
    "function_name": "label_compound_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "135-177",
    "snippet": "static int label_compound_match(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *label, bool stack,\n\t\t\t\tunsigned int state, bool subns, u32 request,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct path_cond cond = { };\n\n\t/* find first subcomponent that is visible */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no component visible */\n\t*perms = allperms;\n\treturn 0;\n\nnext:\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = aa_dfa_match(profile->file.dfa, state, \"//&\");\n\t\tstate = match_component(profile, tp, false, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t}\n\t*perms = aa_compute_fperms(profile->file.dfa, state, &cond);\n\taa_apply_modes_to_perms(profile, perms);\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_apply_modes_to_perms",
          "args": [
            "profile",
            "perms"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "aa_apply_modes_to_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "282-308",
          "snippet": "void aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_compute_fperms",
          "args": [
            "profile->file.dfa",
            "state",
            "&cond"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "aa_compute_fperms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "226-256",
          "snippet": "struct aa_perms aa_compute_fperms(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t  struct path_cond *cond)\n{\n\t/* FIXME: change over to new dfa format\n\t * currently file perms are encoded in the dfa, new format\n\t * splits the permissions from the dfa.  This mapping can be\n\t * done at profile load\n\t */\n\tstruct aa_perms perms = { };\n\n\tif (uid_eq(current_fsuid(), cond->uid)) {\n\t\tperms.allow = map_old_perms(dfa_user_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_user_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_user_quiet(dfa, state));\n\t\tperms.xindex = dfa_user_xindex(dfa, state);\n\t} else {\n\t\tperms.allow = map_old_perms(dfa_other_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_other_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_other_quiet(dfa, state));\n\t\tperms.xindex = dfa_other_xindex(dfa, state);\n\t}\n\tperms.allow |= AA_MAY_GETATTR;\n\n\t/* change_profile wasn't determined by ownership in old mapping */\n\tif (ACCEPT_TABLE(dfa)[state] & 0x80000000)\n\t\tperms.allow |= AA_MAY_CHANGE_PROFILE;\n\tif (ACCEPT_TABLE(dfa)[state] & 0x40000000)\n\t\tperms.allow |= AA_MAY_ONEXEC;\n\n\treturn perms;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstruct aa_perms aa_compute_fperms(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t  struct path_cond *cond)\n{\n\t/* FIXME: change over to new dfa format\n\t * currently file perms are encoded in the dfa, new format\n\t * splits the permissions from the dfa.  This mapping can be\n\t * done at profile load\n\t */\n\tstruct aa_perms perms = { };\n\n\tif (uid_eq(current_fsuid(), cond->uid)) {\n\t\tperms.allow = map_old_perms(dfa_user_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_user_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_user_quiet(dfa, state));\n\t\tperms.xindex = dfa_user_xindex(dfa, state);\n\t} else {\n\t\tperms.allow = map_old_perms(dfa_other_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_other_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_other_quiet(dfa, state));\n\t\tperms.xindex = dfa_other_xindex(dfa, state);\n\t}\n\tperms.allow |= AA_MAY_GETATTR;\n\n\t/* change_profile wasn't determined by ownership in old mapping */\n\tif (ACCEPT_TABLE(dfa)[state] & 0x80000000)\n\t\tperms.allow |= AA_MAY_CHANGE_PROFILE;\n\tif (ACCEPT_TABLE(dfa)[state] & 0x40000000)\n\t\tperms.allow |= AA_MAY_ONEXEC;\n\n\treturn perms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_component",
          "args": [
            "profile",
            "tp",
            "false",
            "state"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "match_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "100-117",
          "snippet": "static inline unsigned int match_component(struct aa_profile *profile,\n\t\t\t\t\t   struct aa_profile *tp,\n\t\t\t\t\t   bool stack, unsigned int state)\n{\n\tconst char *ns_name;\n\n\tif (stack)\n\t\tstate = aa_dfa_match(profile->file.dfa, state, \"&\");\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(profile->file.dfa, state, tp->base.hname);\n\n\t/* try matching with namespace name and then profile */\n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(profile->file.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(profile->file.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(profile->file.dfa, state, \":\", 1);\n\treturn aa_dfa_match(profile->file.dfa, state, tp->base.hname);\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic inline unsigned int match_component(struct aa_profile *profile,\n\t\t\t\t\t   struct aa_profile *tp,\n\t\t\t\t\t   bool stack, unsigned int state)\n{\n\tconst char *ns_name;\n\n\tif (stack)\n\t\tstate = aa_dfa_match(profile->file.dfa, state, \"&\");\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(profile->file.dfa, state, tp->base.hname);\n\n\t/* try matching with namespace name and then profile */\n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(profile->file.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(profile->file.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(profile->file.dfa, state, \":\", 1);\n\treturn aa_dfa_match(profile->file.dfa, state, tp->base.hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_match",
          "args": [
            "profile->file.dfa",
            "state",
            "\"//&\""
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "381-417",
          "snippet": "unsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_ns_visible",
          "args": [
            "profile->ns",
            "tp->ns",
            "subns"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "aa_ns_visible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "41-55",
          "snippet": "bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nbool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_for_each_cont",
          "args": [
            "i",
            "label",
            "tp"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_for_each",
          "args": [
            "i",
            "label",
            "tp"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int label_compound_match(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *label, bool stack,\n\t\t\t\tunsigned int state, bool subns, u32 request,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct path_cond cond = { };\n\n\t/* find first subcomponent that is visible */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, stack, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no component visible */\n\t*perms = allperms;\n\treturn 0;\n\nnext:\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = aa_dfa_match(profile->file.dfa, state, \"//&\");\n\t\tstate = match_component(profile, tp, false, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t}\n\t*perms = aa_compute_fperms(profile->file.dfa, state, &cond);\n\taa_apply_modes_to_perms(profile, perms);\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}"
  },
  {
    "function_name": "match_component",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "100-117",
    "snippet": "static inline unsigned int match_component(struct aa_profile *profile,\n\t\t\t\t\t   struct aa_profile *tp,\n\t\t\t\t\t   bool stack, unsigned int state)\n{\n\tconst char *ns_name;\n\n\tif (stack)\n\t\tstate = aa_dfa_match(profile->file.dfa, state, \"&\");\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(profile->file.dfa, state, tp->base.hname);\n\n\t/* try matching with namespace name and then profile */\n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(profile->file.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(profile->file.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(profile->file.dfa, state, \":\", 1);\n\treturn aa_dfa_match(profile->file.dfa, state, tp->base.hname);\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_dfa_match",
          "args": [
            "profile->file.dfa",
            "state",
            "tp->base.hname"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "381-417",
          "snippet": "unsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_match_len",
          "args": [
            "profile->file.dfa",
            "state",
            "\":\"",
            "1"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_match_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "331-367",
          "snippet": "unsigned int aa_dfa_match_len(struct aa_dfa *dfa, unsigned int start,\n\t\t\t      const char *str, int len)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match_len(struct aa_dfa *dfa, unsigned int start,\n\t\t\t      const char *str, int len)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_ns_name",
          "args": [
            "profile->ns",
            "tp->ns",
            "true"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "aa_ns_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "65-82",
          "snippet": "const char *aa_ns_name(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\t/* if view == curr then the namespace name isn't displayed */\n\tif (curr == view)\n\t\treturn \"\";\n\n\tif (aa_ns_visible(curr, view, subns)) {\n\t\t/* at this point if a ns is visible it is in a view ns\n\t\t * thus the curr ns.hname is a prefix of its name.\n\t\t * Only output the virtualized portion of the name\n\t\t * Add + 2 to skip over // separating curr hname prefix\n\t\t * from the visible tail of the views hname\n\t\t */\n\t\treturn view->base.hname + strlen(curr->base.hname) + 2;\n\t}\n\n\treturn aa_hidden_ns_name;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const char *aa_hidden_ns_name = \"---\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nconst char *aa_hidden_ns_name = \"---\";\n\nconst char *aa_ns_name(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\t/* if view == curr then the namespace name isn't displayed */\n\tif (curr == view)\n\t\treturn \"\";\n\n\tif (aa_ns_visible(curr, view, subns)) {\n\t\t/* at this point if a ns is visible it is in a view ns\n\t\t * thus the curr ns.hname is a prefix of its name.\n\t\t * Only output the virtualized portion of the name\n\t\t * Add + 2 to skip over // separating curr hname prefix\n\t\t * from the visible tail of the views hname\n\t\t */\n\t\treturn view->base.hname + strlen(curr->base.hname) + 2;\n\t}\n\n\treturn aa_hidden_ns_name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic inline unsigned int match_component(struct aa_profile *profile,\n\t\t\t\t\t   struct aa_profile *tp,\n\t\t\t\t\t   bool stack, unsigned int state)\n{\n\tconst char *ns_name;\n\n\tif (stack)\n\t\tstate = aa_dfa_match(profile->file.dfa, state, \"&\");\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(profile->file.dfa, state, tp->base.hname);\n\n\t/* try matching with namespace name and then profile */\n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(profile->file.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(profile->file.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(profile->file.dfa, state, \":\", 1);\n\treturn aa_dfa_match(profile->file.dfa, state, tp->base.hname);\n}"
  },
  {
    "function_name": "may_change_ptraced_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "62-88",
    "snippet": "static int may_change_ptraced_domain(struct aa_label *to_label,\n\t\t\t\t     const char **info)\n{\n\tstruct task_struct *tracer;\n\tstruct aa_label *tracerl = NULL;\n\tint error = 0;\n\n\trcu_read_lock();\n\ttracer = ptrace_parent(current);\n\tif (tracer)\n\t\t/* released below */\n\t\ttracerl = aa_get_task_label(tracer);\n\n\t/* not ptraced */\n\tif (!tracer || unconfined(tracerl))\n\t\tgoto out;\n\n\terror = aa_may_ptrace(tracerl, to_label, PTRACE_MODE_ATTACH);\n\nout:\n\trcu_read_unlock();\n\taa_put_label(tracerl);\n\n\tif (error)\n\t\t*info = \"ptrace prevents transition\";\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "tracerl"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_may_ptrace",
          "args": [
            "tracerl",
            "to_label",
            "PTRACE_MODE_ATTACH"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "aa_may_ptrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
          "lines": "115-122",
          "snippet": "int aa_may_ptrace(struct aa_label *tracer, struct aa_label *tracee,\n\t\t  u32 request)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_PTRACE);\n\n\treturn xcheck_labels_profiles(tracer, tracee, cross_ptrace_perm,\n\t\t\t\t      request, &sa);\n}",
          "includes": [
            "#include \"include/sig_names.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nint aa_may_ptrace(struct aa_label *tracer, struct aa_label *tracee,\n\t\t  u32 request)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_PTRACE);\n\n\treturn xcheck_labels_profiles(tracer, tracee, cross_ptrace_perm,\n\t\t\t\t      request, &sa);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "tracerl"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_task_label",
          "args": [
            "tracer"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_task_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "77-86",
          "snippet": "struct aa_label *aa_get_task_label(struct task_struct *task)\n{\n\tstruct aa_label *p;\n\n\trcu_read_lock();\n\tp = aa_get_newest_label(__aa_task_raw_label(task));\n\trcu_read_unlock();\n\n\treturn p;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nstruct aa_label *aa_get_task_label(struct task_struct *task)\n{\n\tstruct aa_label *p;\n\n\trcu_read_lock();\n\tp = aa_get_newest_label(__aa_task_raw_label(task));\n\trcu_read_unlock();\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_parent",
          "args": [
            "current"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nstatic int may_change_ptraced_domain(struct aa_label *to_label,\n\t\t\t\t     const char **info)\n{\n\tstruct task_struct *tracer;\n\tstruct aa_label *tracerl = NULL;\n\tint error = 0;\n\n\trcu_read_lock();\n\ttracer = ptrace_parent(current);\n\tif (tracer)\n\t\t/* released below */\n\t\ttracerl = aa_get_task_label(tracer);\n\n\t/* not ptraced */\n\tif (!tracer || unconfined(tracerl))\n\t\tgoto out;\n\n\terror = aa_may_ptrace(tracerl, to_label, PTRACE_MODE_ATTACH);\n\nout:\n\trcu_read_unlock();\n\taa_put_label(tracerl);\n\n\tif (error)\n\t\t*info = \"ptrace prevents transition\";\n\treturn error;\n}"
  },
  {
    "function_name": "aa_free_domain_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
    "lines": "38-50",
    "snippet": "void aa_free_domain_entries(struct aa_domain *domain)\n{\n\tint i;\n\tif (domain) {\n\t\tif (!domain->table)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < domain->size; i++)\n\t\t\tkzfree(domain->table[i]);\n\t\tkzfree(domain->table);\n\t\tdomain->table = NULL;\n\t}\n}",
    "includes": [
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmorfs.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/personality.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "domain->table"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "domain->table[i]"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nvoid aa_free_domain_entries(struct aa_domain *domain)\n{\n\tint i;\n\tif (domain) {\n\t\tif (!domain->table)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < domain->size; i++)\n\t\t\tkzfree(domain->table[i]);\n\t\tkzfree(domain->table);\n\t\tdomain->table = NULL;\n\t}\n}"
  }
]