[
  {
    "function_name": "aa_unpack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "955-1023",
    "snippet": "int aa_unpack(struct aa_loaddata *udata, struct list_head *lh,\n\t      const char **ns)\n{\n\tstruct aa_load_ent *tmp, *ent;\n\tstruct aa_profile *profile = NULL;\n\tint error;\n\tstruct aa_ext e = {\n\t\t.start = udata->data,\n\t\t.end = udata->data + udata->size,\n\t\t.pos = udata->data,\n\t};\n\n\t*ns = NULL;\n\twhile (e.pos < e.end) {\n\t\tchar *ns_name = NULL;\n\t\tvoid *start;\n\t\terror = verify_header(&e, e.pos == e.start, ns);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tstart = e.pos;\n\t\tprofile = unpack_profile(&e, &ns_name);\n\t\tif (IS_ERR(profile)) {\n\t\t\terror = PTR_ERR(profile);\n\t\t\tgoto fail;\n\t\t}\n\n\t\terror = verify_profile(profile);\n\t\tif (error)\n\t\t\tgoto fail_profile;\n\n\t\tif (aa_g_hash_policy)\n\t\t\terror = aa_calc_profile_hash(profile, e.version, start,\n\t\t\t\t\t\t     e.pos - start);\n\t\tif (error)\n\t\t\tgoto fail_profile;\n\n\t\tent = aa_load_ent_alloc();\n\t\tif (!ent) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail_profile;\n\t\t}\n\n\t\tent->new = profile;\n\t\tent->ns_name = ns_name;\n\t\tlist_add_tail(&ent->list, lh);\n\t}\n\tudata->abi = e.version & K_ABI_MASK;\n\tif (aa_g_hash_policy) {\n\t\tudata->hash = aa_calc_hash(udata->data, udata->size);\n\t\tif (IS_ERR(udata->hash)) {\n\t\t\terror = PTR_ERR(udata->hash);\n\t\t\tudata->hash = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\n\nfail_profile:\n\taa_put_profile(profile);\n\nfail:\n\tlist_for_each_entry_safe(ent, tmp, lh, list) {\n\t\tlist_del_init(&ent->list);\n\t\taa_load_ent_free(ent);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [
      "#define K_ABI_MASK 0x3ff"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_load_ent_free",
          "args": [
            "ent"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "aa_load_ent_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "924-933",
          "snippet": "void aa_load_ent_free(struct aa_load_ent *ent)\n{\n\tif (ent) {\n\t\taa_put_profile(ent->rename);\n\t\taa_put_profile(ent->old);\n\t\taa_put_profile(ent->new);\n\t\tkfree(ent->ns_name);\n\t\tkzfree(ent);\n\t}\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nvoid aa_load_ent_free(struct aa_load_ent *ent)\n{\n\tif (ent) {\n\t\taa_put_profile(ent->rename);\n\t\taa_put_profile(ent->old);\n\t\taa_put_profile(ent->new);\n\t\tkfree(ent->ns_name);\n\t\tkzfree(ent);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ent->list"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ent",
            "tmp",
            "lh",
            "list"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_profile",
          "args": [
            "profile"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "277-281",
          "snippet": "static inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "udata->hash"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "udata->hash"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_calc_hash",
          "args": [
            "udata->data",
            "udata->size"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "aa_calc_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/crypto.c",
          "lines": "32-64",
          "snippet": "char *aa_calc_hash(void *data, size_t len)\n{\n\tSHASH_DESC_ON_STACK(desc, apparmor_tfm);\n\tchar *hash = NULL;\n\tint error = -ENOMEM;\n\n\tif (!apparmor_tfm)\n\t\treturn NULL;\n\n\thash = kzalloc(apparmor_hash_size, GFP_KERNEL);\n\tif (!hash)\n\t\tgoto fail;\n\n\tdesc->tfm = apparmor_tfm;\n\tdesc->flags = 0;\n\n\terror = crypto_shash_init(desc);\n\tif (error)\n\t\tgoto fail;\n\terror = crypto_shash_update(desc, (u8 *) data, len);\n\tif (error)\n\t\tgoto fail;\n\terror = crypto_shash_final(desc, hash);\n\tif (error)\n\t\tgoto fail;\n\n\treturn hash;\n\nfail:\n\tkfree(hash);\n\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"include/crypto.h\"",
            "#include \"include/apparmor.h\"",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int apparmor_hash_size;",
            "static struct crypto_shash *apparmor_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/crypto.h\"\n#include \"include/apparmor.h\"\n#include <crypto/hash.h>\n\nstatic unsigned int apparmor_hash_size;\nstatic struct crypto_shash *apparmor_tfm;\n\nchar *aa_calc_hash(void *data, size_t len)\n{\n\tSHASH_DESC_ON_STACK(desc, apparmor_tfm);\n\tchar *hash = NULL;\n\tint error = -ENOMEM;\n\n\tif (!apparmor_tfm)\n\t\treturn NULL;\n\n\thash = kzalloc(apparmor_hash_size, GFP_KERNEL);\n\tif (!hash)\n\t\tgoto fail;\n\n\tdesc->tfm = apparmor_tfm;\n\tdesc->flags = 0;\n\n\terror = crypto_shash_init(desc);\n\tif (error)\n\t\tgoto fail;\n\terror = crypto_shash_update(desc, (u8 *) data, len);\n\tif (error)\n\t\tgoto fail;\n\terror = crypto_shash_final(desc, hash);\n\tif (error)\n\t\tgoto fail;\n\n\treturn hash;\n\nfail:\n\tkfree(hash);\n\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ent->list",
            "lh"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_load_ent_alloc",
          "args": [],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "aa_load_ent_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "935-941",
          "snippet": "struct aa_load_ent *aa_load_ent_alloc(void)\n{\n\tstruct aa_load_ent *ent = kzalloc(sizeof(*ent), GFP_KERNEL);\n\tif (ent)\n\t\tINIT_LIST_HEAD(&ent->list);\n\treturn ent;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstruct aa_load_ent *aa_load_ent_alloc(void)\n{\n\tstruct aa_load_ent *ent = kzalloc(sizeof(*ent), GFP_KERNEL);\n\tif (ent)\n\t\tINIT_LIST_HEAD(&ent->list);\n\treturn ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_calc_profile_hash",
          "args": [
            "profile",
            "e.version",
            "start",
            "e.pos - start"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "aa_calc_profile_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/crypto.c",
          "lines": "66-106",
          "snippet": "int aa_calc_profile_hash(struct aa_profile *profile, u32 version, void *start,\n\t\t\t size_t len)\n{\n\tSHASH_DESC_ON_STACK(desc, apparmor_tfm);\n\tint error = -ENOMEM;\n\t__le32 le32_version = cpu_to_le32(version);\n\n\tif (!aa_g_hash_policy)\n\t\treturn 0;\n\n\tif (!apparmor_tfm)\n\t\treturn 0;\n\n\tprofile->hash = kzalloc(apparmor_hash_size, GFP_KERNEL);\n\tif (!profile->hash)\n\t\tgoto fail;\n\n\tdesc->tfm = apparmor_tfm;\n\tdesc->flags = 0;\n\n\terror = crypto_shash_init(desc);\n\tif (error)\n\t\tgoto fail;\n\terror = crypto_shash_update(desc, (u8 *) &le32_version, 4);\n\tif (error)\n\t\tgoto fail;\n\terror = crypto_shash_update(desc, (u8 *) start, len);\n\tif (error)\n\t\tgoto fail;\n\terror = crypto_shash_final(desc, profile->hash);\n\tif (error)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tkfree(profile->hash);\n\tprofile->hash = NULL;\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/crypto.h\"",
            "#include \"include/apparmor.h\"",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int apparmor_hash_size;",
            "static struct crypto_shash *apparmor_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/crypto.h\"\n#include \"include/apparmor.h\"\n#include <crypto/hash.h>\n\nstatic unsigned int apparmor_hash_size;\nstatic struct crypto_shash *apparmor_tfm;\n\nint aa_calc_profile_hash(struct aa_profile *profile, u32 version, void *start,\n\t\t\t size_t len)\n{\n\tSHASH_DESC_ON_STACK(desc, apparmor_tfm);\n\tint error = -ENOMEM;\n\t__le32 le32_version = cpu_to_le32(version);\n\n\tif (!aa_g_hash_policy)\n\t\treturn 0;\n\n\tif (!apparmor_tfm)\n\t\treturn 0;\n\n\tprofile->hash = kzalloc(apparmor_hash_size, GFP_KERNEL);\n\tif (!profile->hash)\n\t\tgoto fail;\n\n\tdesc->tfm = apparmor_tfm;\n\tdesc->flags = 0;\n\n\terror = crypto_shash_init(desc);\n\tif (error)\n\t\tgoto fail;\n\terror = crypto_shash_update(desc, (u8 *) &le32_version, 4);\n\tif (error)\n\t\tgoto fail;\n\terror = crypto_shash_update(desc, (u8 *) start, len);\n\tif (error)\n\t\tgoto fail;\n\terror = crypto_shash_final(desc, profile->hash);\n\tif (error)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tkfree(profile->hash);\n\tprofile->hash = NULL;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_profile",
          "args": [
            "profile"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "verify_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "911-922",
          "snippet": "static int verify_profile(struct aa_profile *profile)\n{\n\tif (profile->file.dfa &&\n\t    !verify_dfa_xindex(profile->file.dfa,\n\t\t\t       profile->file.trans.size)) {\n\t\taudit_iface(profile, NULL, NULL, \"Invalid named transition\",\n\t\t\t    NULL, -EPROTO);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic int verify_profile(struct aa_profile *profile)\n{\n\tif (profile->file.dfa &&\n\t    !verify_dfa_xindex(profile->file.dfa,\n\t\t\t       profile->file.trans.size)) {\n\t\taudit_iface(profile, NULL, NULL, \"Invalid named transition\",\n\t\t\t    NULL, -EPROTO);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "profile"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "profile"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_profile",
          "args": [
            "&e",
            "&ns_name"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "582-830",
          "snippet": "static struct aa_profile *unpack_profile(struct aa_ext *e, char **ns_name)\n{\n\tstruct aa_profile *profile = NULL;\n\tconst char *tmpname, *tmpns = NULL, *name = NULL;\n\tconst char *info = \"failed to unpack profile\";\n\tsize_t ns_len;\n\tstruct rhashtable_params params = { 0 };\n\tchar *key = NULL;\n\tstruct aa_data *data;\n\tint i, error = -EPROTO;\n\tkernel_cap_t tmpcap;\n\tu32 tmp;\n\n\t*ns_name = NULL;\n\n\t/* check that we have the right struct being passed */\n\tif (!unpack_nameX(e, AA_STRUCT, \"profile\"))\n\t\tgoto fail;\n\tif (!unpack_str(e, &name, NULL))\n\t\tgoto fail;\n\tif (*name == '\\0')\n\t\tgoto fail;\n\n\ttmpname = aa_splitn_fqname(name, strlen(name), &tmpns, &ns_len);\n\tif (tmpns) {\n\t\t*ns_name = kstrndup(tmpns, ns_len, GFP_KERNEL);\n\t\tif (!*ns_name) {\n\t\t\tinfo = \"out of memory\";\n\t\t\tgoto fail;\n\t\t}\n\t\tname = tmpname;\n\t}\n\n\tprofile = aa_alloc_profile(name, NULL, GFP_KERNEL);\n\tif (!profile)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* profile renaming is optional */\n\t(void) unpack_str(e, &profile->rename, \"rename\");\n\n\t/* attachment string is optional */\n\t(void) unpack_str(e, &profile->attach, \"attach\");\n\n\t/* xmatch is optional and may be NULL */\n\tprofile->xmatch = unpack_dfa(e);\n\tif (IS_ERR(profile->xmatch)) {\n\t\terror = PTR_ERR(profile->xmatch);\n\t\tprofile->xmatch = NULL;\n\t\tinfo = \"bad xmatch\";\n\t\tgoto fail;\n\t}\n\t/* xmatch_len is not optional if xmatch is set */\n\tif (profile->xmatch) {\n\t\tif (!unpack_u32(e, &tmp, NULL)) {\n\t\t\tinfo = \"missing xmatch len\";\n\t\t\tgoto fail;\n\t\t}\n\t\tprofile->xmatch_len = tmp;\n\t}\n\n\t/* disconnected attachment string is optional */\n\t(void) unpack_str(e, &profile->disconnected, \"disconnected\");\n\n\t/* per profile debug flags (complain, audit) */\n\tif (!unpack_nameX(e, AA_STRUCT, \"flags\")) {\n\t\tinfo = \"profile missing flags\";\n\t\tgoto fail;\n\t}\n\tinfo = \"failed to unpack profile flags\";\n\tif (!unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp & PACKED_FLAG_HAT)\n\t\tprofile->label.flags |= FLAG_HAT;\n\tif (!unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp == PACKED_MODE_COMPLAIN || (e->version & FORCE_COMPLAIN_FLAG))\n\t\tprofile->mode = APPARMOR_COMPLAIN;\n\telse if (tmp == PACKED_MODE_KILL)\n\t\tprofile->mode = APPARMOR_KILL;\n\telse if (tmp == PACKED_MODE_UNCONFINED)\n\t\tprofile->mode = APPARMOR_UNCONFINED;\n\tif (!unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp)\n\t\tprofile->audit = AUDIT_ALL;\n\n\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\tgoto fail;\n\n\t/* path_flags is optional */\n\tif (unpack_u32(e, &profile->path_flags, \"path_flags\"))\n\t\tprofile->path_flags |= profile->label.flags &\n\t\t\tPATH_MEDIATE_DELETED;\n\telse\n\t\t/* set a default value if path_flags field is not present */\n\t\tprofile->path_flags = PATH_MEDIATE_DELETED;\n\n\tinfo = \"failed to unpack profile capabilities\";\n\tif (!unpack_u32(e, &(profile->caps.allow.cap[0]), NULL))\n\t\tgoto fail;\n\tif (!unpack_u32(e, &(profile->caps.audit.cap[0]), NULL))\n\t\tgoto fail;\n\tif (!unpack_u32(e, &(profile->caps.quiet.cap[0]), NULL))\n\t\tgoto fail;\n\tif (!unpack_u32(e, &tmpcap.cap[0], NULL))\n\t\tgoto fail;\n\n\tinfo = \"failed to unpack upper profile capabilities\";\n\tif (unpack_nameX(e, AA_STRUCT, \"caps64\")) {\n\t\t/* optional upper half of 64 bit caps */\n\t\tif (!unpack_u32(e, &(profile->caps.allow.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(profile->caps.audit.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(profile->caps.quiet.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(tmpcap.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\n\tinfo = \"failed to unpack extended profile capabilities\";\n\tif (unpack_nameX(e, AA_STRUCT, \"capsx\")) {\n\t\t/* optional extended caps mediation mask */\n\t\tif (!unpack_u32(e, &(profile->caps.extended.cap[0]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(profile->caps.extended.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\n\tif (!unpack_rlimits(e, profile)) {\n\t\tinfo = \"failed to unpack profile rlimits\";\n\t\tgoto fail;\n\t}\n\n\tif (unpack_nameX(e, AA_STRUCT, \"policydb\")) {\n\t\t/* generic policy dfa - optional and may be NULL */\n\t\tinfo = \"failed to unpack policydb\";\n\t\tprofile->policy.dfa = unpack_dfa(e);\n\t\tif (IS_ERR(profile->policy.dfa)) {\n\t\t\terror = PTR_ERR(profile->policy.dfa);\n\t\t\tprofile->policy.dfa = NULL;\n\t\t\tgoto fail;\n\t\t} else if (!profile->policy.dfa) {\n\t\t\terror = -EPROTO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (!unpack_u32(e, &profile->policy.start[0], \"start\"))\n\t\t\t/* default start state */\n\t\t\tprofile->policy.start[0] = DFA_START;\n\t\t/* setup class index */\n\t\tfor (i = AA_CLASS_FILE; i <= AA_CLASS_LAST; i++) {\n\t\t\tprofile->policy.start[i] =\n\t\t\t\taa_dfa_next(profile->policy.dfa,\n\t\t\t\t\t    profile->policy.start[0],\n\t\t\t\t\t    i);\n\t\t}\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t} else\n\t\tprofile->policy.dfa = aa_get_dfa(nulldfa);\n\n\t/* get file rules */\n\tprofile->file.dfa = unpack_dfa(e);\n\tif (IS_ERR(profile->file.dfa)) {\n\t\terror = PTR_ERR(profile->file.dfa);\n\t\tprofile->file.dfa = NULL;\n\t\tinfo = \"failed to unpack profile file rules\";\n\t\tgoto fail;\n\t} else if (profile->file.dfa) {\n\t\tif (!unpack_u32(e, &profile->file.start, \"dfa_start\"))\n\t\t\t/* default start state */\n\t\t\tprofile->file.start = DFA_START;\n\t} else if (profile->policy.dfa &&\n\t\t   profile->policy.start[AA_CLASS_FILE]) {\n\t\tprofile->file.dfa = aa_get_dfa(profile->policy.dfa);\n\t\tprofile->file.start = profile->policy.start[AA_CLASS_FILE];\n\t} else\n\t\tprofile->file.dfa = aa_get_dfa(nulldfa);\n\n\tif (!unpack_trans_table(e, profile)) {\n\t\tinfo = \"failed to unpack profile transition table\";\n\t\tgoto fail;\n\t}\n\n\tif (unpack_nameX(e, AA_STRUCT, \"data\")) {\n\t\tinfo = \"out of memory\";\n\t\tprofile->data = kzalloc(sizeof(*profile->data), GFP_KERNEL);\n\t\tif (!profile->data)\n\t\t\tgoto fail;\n\n\t\tparams.nelem_hint = 3;\n\t\tparams.key_len = sizeof(void *);\n\t\tparams.key_offset = offsetof(struct aa_data, key);\n\t\tparams.head_offset = offsetof(struct aa_data, head);\n\t\tparams.hashfn = strhash;\n\t\tparams.obj_cmpfn = datacmp;\n\n\t\tif (rhashtable_init(profile->data, &params)) {\n\t\t\tinfo = \"failed to init key, value hash table\";\n\t\t\tgoto fail;\n\t\t}\n\n\t\twhile (unpack_strdup(e, &key, NULL)) {\n\t\t\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\t\t\tif (!data) {\n\t\t\t\tkzfree(key);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tdata->key = key;\n\t\t\tdata->size = unpack_blob(e, &data->data, NULL);\n\t\t\tdata->data = kvmemdup(data->data, data->size);\n\t\t\tif (data->size && !data->data) {\n\t\t\t\tkzfree(data->key);\n\t\t\t\tkzfree(data);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trhashtable_insert_fast(profile->data, &data->head,\n\t\t\t\t\t       profile->data->p);\n\t\t}\n\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL)) {\n\t\t\tinfo = \"failed to unpack end of key, value data table\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!unpack_nameX(e, AA_STRUCTEND, NULL)) {\n\t\tinfo = \"failed to unpack end of profile\";\n\t\tgoto fail;\n\t}\n\n\treturn profile;\n\nfail:\n\tif (profile)\n\t\tname = NULL;\n\telse if (!name)\n\t\tname = \"unknown\";\n\taudit_iface(profile, NULL, name, info, e, error);\n\taa_free_profile(profile);\n\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [
            "#define FORCE_COMPLAIN_FLAG 0x800"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\n#define FORCE_COMPLAIN_FLAG 0x800\n\nstatic struct aa_profile *unpack_profile(struct aa_ext *e, char **ns_name)\n{\n\tstruct aa_profile *profile = NULL;\n\tconst char *tmpname, *tmpns = NULL, *name = NULL;\n\tconst char *info = \"failed to unpack profile\";\n\tsize_t ns_len;\n\tstruct rhashtable_params params = { 0 };\n\tchar *key = NULL;\n\tstruct aa_data *data;\n\tint i, error = -EPROTO;\n\tkernel_cap_t tmpcap;\n\tu32 tmp;\n\n\t*ns_name = NULL;\n\n\t/* check that we have the right struct being passed */\n\tif (!unpack_nameX(e, AA_STRUCT, \"profile\"))\n\t\tgoto fail;\n\tif (!unpack_str(e, &name, NULL))\n\t\tgoto fail;\n\tif (*name == '\\0')\n\t\tgoto fail;\n\n\ttmpname = aa_splitn_fqname(name, strlen(name), &tmpns, &ns_len);\n\tif (tmpns) {\n\t\t*ns_name = kstrndup(tmpns, ns_len, GFP_KERNEL);\n\t\tif (!*ns_name) {\n\t\t\tinfo = \"out of memory\";\n\t\t\tgoto fail;\n\t\t}\n\t\tname = tmpname;\n\t}\n\n\tprofile = aa_alloc_profile(name, NULL, GFP_KERNEL);\n\tif (!profile)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* profile renaming is optional */\n\t(void) unpack_str(e, &profile->rename, \"rename\");\n\n\t/* attachment string is optional */\n\t(void) unpack_str(e, &profile->attach, \"attach\");\n\n\t/* xmatch is optional and may be NULL */\n\tprofile->xmatch = unpack_dfa(e);\n\tif (IS_ERR(profile->xmatch)) {\n\t\terror = PTR_ERR(profile->xmatch);\n\t\tprofile->xmatch = NULL;\n\t\tinfo = \"bad xmatch\";\n\t\tgoto fail;\n\t}\n\t/* xmatch_len is not optional if xmatch is set */\n\tif (profile->xmatch) {\n\t\tif (!unpack_u32(e, &tmp, NULL)) {\n\t\t\tinfo = \"missing xmatch len\";\n\t\t\tgoto fail;\n\t\t}\n\t\tprofile->xmatch_len = tmp;\n\t}\n\n\t/* disconnected attachment string is optional */\n\t(void) unpack_str(e, &profile->disconnected, \"disconnected\");\n\n\t/* per profile debug flags (complain, audit) */\n\tif (!unpack_nameX(e, AA_STRUCT, \"flags\")) {\n\t\tinfo = \"profile missing flags\";\n\t\tgoto fail;\n\t}\n\tinfo = \"failed to unpack profile flags\";\n\tif (!unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp & PACKED_FLAG_HAT)\n\t\tprofile->label.flags |= FLAG_HAT;\n\tif (!unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp == PACKED_MODE_COMPLAIN || (e->version & FORCE_COMPLAIN_FLAG))\n\t\tprofile->mode = APPARMOR_COMPLAIN;\n\telse if (tmp == PACKED_MODE_KILL)\n\t\tprofile->mode = APPARMOR_KILL;\n\telse if (tmp == PACKED_MODE_UNCONFINED)\n\t\tprofile->mode = APPARMOR_UNCONFINED;\n\tif (!unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp)\n\t\tprofile->audit = AUDIT_ALL;\n\n\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\tgoto fail;\n\n\t/* path_flags is optional */\n\tif (unpack_u32(e, &profile->path_flags, \"path_flags\"))\n\t\tprofile->path_flags |= profile->label.flags &\n\t\t\tPATH_MEDIATE_DELETED;\n\telse\n\t\t/* set a default value if path_flags field is not present */\n\t\tprofile->path_flags = PATH_MEDIATE_DELETED;\n\n\tinfo = \"failed to unpack profile capabilities\";\n\tif (!unpack_u32(e, &(profile->caps.allow.cap[0]), NULL))\n\t\tgoto fail;\n\tif (!unpack_u32(e, &(profile->caps.audit.cap[0]), NULL))\n\t\tgoto fail;\n\tif (!unpack_u32(e, &(profile->caps.quiet.cap[0]), NULL))\n\t\tgoto fail;\n\tif (!unpack_u32(e, &tmpcap.cap[0], NULL))\n\t\tgoto fail;\n\n\tinfo = \"failed to unpack upper profile capabilities\";\n\tif (unpack_nameX(e, AA_STRUCT, \"caps64\")) {\n\t\t/* optional upper half of 64 bit caps */\n\t\tif (!unpack_u32(e, &(profile->caps.allow.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(profile->caps.audit.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(profile->caps.quiet.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(tmpcap.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\n\tinfo = \"failed to unpack extended profile capabilities\";\n\tif (unpack_nameX(e, AA_STRUCT, \"capsx\")) {\n\t\t/* optional extended caps mediation mask */\n\t\tif (!unpack_u32(e, &(profile->caps.extended.cap[0]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(profile->caps.extended.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\n\tif (!unpack_rlimits(e, profile)) {\n\t\tinfo = \"failed to unpack profile rlimits\";\n\t\tgoto fail;\n\t}\n\n\tif (unpack_nameX(e, AA_STRUCT, \"policydb\")) {\n\t\t/* generic policy dfa - optional and may be NULL */\n\t\tinfo = \"failed to unpack policydb\";\n\t\tprofile->policy.dfa = unpack_dfa(e);\n\t\tif (IS_ERR(profile->policy.dfa)) {\n\t\t\terror = PTR_ERR(profile->policy.dfa);\n\t\t\tprofile->policy.dfa = NULL;\n\t\t\tgoto fail;\n\t\t} else if (!profile->policy.dfa) {\n\t\t\terror = -EPROTO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (!unpack_u32(e, &profile->policy.start[0], \"start\"))\n\t\t\t/* default start state */\n\t\t\tprofile->policy.start[0] = DFA_START;\n\t\t/* setup class index */\n\t\tfor (i = AA_CLASS_FILE; i <= AA_CLASS_LAST; i++) {\n\t\t\tprofile->policy.start[i] =\n\t\t\t\taa_dfa_next(profile->policy.dfa,\n\t\t\t\t\t    profile->policy.start[0],\n\t\t\t\t\t    i);\n\t\t}\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t} else\n\t\tprofile->policy.dfa = aa_get_dfa(nulldfa);\n\n\t/* get file rules */\n\tprofile->file.dfa = unpack_dfa(e);\n\tif (IS_ERR(profile->file.dfa)) {\n\t\terror = PTR_ERR(profile->file.dfa);\n\t\tprofile->file.dfa = NULL;\n\t\tinfo = \"failed to unpack profile file rules\";\n\t\tgoto fail;\n\t} else if (profile->file.dfa) {\n\t\tif (!unpack_u32(e, &profile->file.start, \"dfa_start\"))\n\t\t\t/* default start state */\n\t\t\tprofile->file.start = DFA_START;\n\t} else if (profile->policy.dfa &&\n\t\t   profile->policy.start[AA_CLASS_FILE]) {\n\t\tprofile->file.dfa = aa_get_dfa(profile->policy.dfa);\n\t\tprofile->file.start = profile->policy.start[AA_CLASS_FILE];\n\t} else\n\t\tprofile->file.dfa = aa_get_dfa(nulldfa);\n\n\tif (!unpack_trans_table(e, profile)) {\n\t\tinfo = \"failed to unpack profile transition table\";\n\t\tgoto fail;\n\t}\n\n\tif (unpack_nameX(e, AA_STRUCT, \"data\")) {\n\t\tinfo = \"out of memory\";\n\t\tprofile->data = kzalloc(sizeof(*profile->data), GFP_KERNEL);\n\t\tif (!profile->data)\n\t\t\tgoto fail;\n\n\t\tparams.nelem_hint = 3;\n\t\tparams.key_len = sizeof(void *);\n\t\tparams.key_offset = offsetof(struct aa_data, key);\n\t\tparams.head_offset = offsetof(struct aa_data, head);\n\t\tparams.hashfn = strhash;\n\t\tparams.obj_cmpfn = datacmp;\n\n\t\tif (rhashtable_init(profile->data, &params)) {\n\t\t\tinfo = \"failed to init key, value hash table\";\n\t\t\tgoto fail;\n\t\t}\n\n\t\twhile (unpack_strdup(e, &key, NULL)) {\n\t\t\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\t\t\tif (!data) {\n\t\t\t\tkzfree(key);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tdata->key = key;\n\t\t\tdata->size = unpack_blob(e, &data->data, NULL);\n\t\t\tdata->data = kvmemdup(data->data, data->size);\n\t\t\tif (data->size && !data->data) {\n\t\t\t\tkzfree(data->key);\n\t\t\t\tkzfree(data);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trhashtable_insert_fast(profile->data, &data->head,\n\t\t\t\t\t       profile->data->p);\n\t\t}\n\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL)) {\n\t\t\tinfo = \"failed to unpack end of key, value data table\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!unpack_nameX(e, AA_STRUCTEND, NULL)) {\n\t\tinfo = \"failed to unpack end of profile\";\n\t\tgoto fail;\n\t}\n\n\treturn profile;\n\nfail:\n\tif (profile)\n\t\tname = NULL;\n\telse if (!name)\n\t\tname = \"unknown\";\n\taudit_iface(profile, NULL, name, info, e, error);\n\taa_free_profile(profile);\n\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_header",
          "args": [
            "&e",
            "e.pos == e.start",
            "ns"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "verify_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "840-880",
          "snippet": "static int verify_header(struct aa_ext *e, int required, const char **ns)\n{\n\tint error = -EPROTONOSUPPORT;\n\tconst char *name = NULL;\n\t*ns = NULL;\n\n\t/* get the interface version */\n\tif (!unpack_u32(e, &e->version, \"version\")) {\n\t\tif (required) {\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid profile format\",\n\t\t\t\t    e, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t/* Check that the interface version is currently supported.\n\t * if not specified use previous version\n\t * Mask off everything that is not kernel abi version\n\t */\n\tif (VERSION_LT(e->version, v5) || VERSION_GT(e->version, v7)) {\n\t\taudit_iface(NULL, NULL, NULL, \"unsupported interface version\",\n\t\t\t    e, error);\n\t\treturn error;\n\t}\n\n\t/* read the namespace if present */\n\tif (unpack_str(e, &name, \"namespace\")) {\n\t\tif (*name == '\\0') {\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid namespace name\",\n\t\t\t\t    e, error);\n\t\t\treturn error;\n\t\t}\n\t\tif (*ns && strcmp(*ns, name))\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid ns change\", e,\n\t\t\t\t    error);\n\t\telse if (!*ns)\n\t\t\t*ns = name;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [
            "#define v7\t7\t/* full network masking */",
            "#define v5\t5\t/* base version */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\n#define v7\t7\t/* full network masking */\n#define v5\t5\t/* base version */\n\nstatic int verify_header(struct aa_ext *e, int required, const char **ns)\n{\n\tint error = -EPROTONOSUPPORT;\n\tconst char *name = NULL;\n\t*ns = NULL;\n\n\t/* get the interface version */\n\tif (!unpack_u32(e, &e->version, \"version\")) {\n\t\tif (required) {\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid profile format\",\n\t\t\t\t    e, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t/* Check that the interface version is currently supported.\n\t * if not specified use previous version\n\t * Mask off everything that is not kernel abi version\n\t */\n\tif (VERSION_LT(e->version, v5) || VERSION_GT(e->version, v7)) {\n\t\taudit_iface(NULL, NULL, NULL, \"unsupported interface version\",\n\t\t\t    e, error);\n\t\treturn error;\n\t}\n\n\t/* read the namespace if present */\n\tif (unpack_str(e, &name, \"namespace\")) {\n\t\tif (*name == '\\0') {\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid namespace name\",\n\t\t\t\t    e, error);\n\t\t\treturn error;\n\t\t}\n\t\tif (*ns && strcmp(*ns, name))\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid ns change\", e,\n\t\t\t\t    error);\n\t\telse if (!*ns)\n\t\t\t*ns = name;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\n#define K_ABI_MASK 0x3ff\n\nint aa_unpack(struct aa_loaddata *udata, struct list_head *lh,\n\t      const char **ns)\n{\n\tstruct aa_load_ent *tmp, *ent;\n\tstruct aa_profile *profile = NULL;\n\tint error;\n\tstruct aa_ext e = {\n\t\t.start = udata->data,\n\t\t.end = udata->data + udata->size,\n\t\t.pos = udata->data,\n\t};\n\n\t*ns = NULL;\n\twhile (e.pos < e.end) {\n\t\tchar *ns_name = NULL;\n\t\tvoid *start;\n\t\terror = verify_header(&e, e.pos == e.start, ns);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tstart = e.pos;\n\t\tprofile = unpack_profile(&e, &ns_name);\n\t\tif (IS_ERR(profile)) {\n\t\t\terror = PTR_ERR(profile);\n\t\t\tgoto fail;\n\t\t}\n\n\t\terror = verify_profile(profile);\n\t\tif (error)\n\t\t\tgoto fail_profile;\n\n\t\tif (aa_g_hash_policy)\n\t\t\terror = aa_calc_profile_hash(profile, e.version, start,\n\t\t\t\t\t\t     e.pos - start);\n\t\tif (error)\n\t\t\tgoto fail_profile;\n\n\t\tent = aa_load_ent_alloc();\n\t\tif (!ent) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail_profile;\n\t\t}\n\n\t\tent->new = profile;\n\t\tent->ns_name = ns_name;\n\t\tlist_add_tail(&ent->list, lh);\n\t}\n\tudata->abi = e.version & K_ABI_MASK;\n\tif (aa_g_hash_policy) {\n\t\tudata->hash = aa_calc_hash(udata->data, udata->size);\n\t\tif (IS_ERR(udata->hash)) {\n\t\t\terror = PTR_ERR(udata->hash);\n\t\t\tudata->hash = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\n\nfail_profile:\n\taa_put_profile(profile);\n\nfail:\n\tlist_for_each_entry_safe(ent, tmp, lh, list) {\n\t\tlist_del_init(&ent->list);\n\t\taa_load_ent_free(ent);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "aa_load_ent_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "935-941",
    "snippet": "struct aa_load_ent *aa_load_ent_alloc(void)\n{\n\tstruct aa_load_ent *ent = kzalloc(sizeof(*ent), GFP_KERNEL);\n\tif (ent)\n\t\tINIT_LIST_HEAD(&ent->list);\n\treturn ent;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ent->list"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ent)",
            "GFP_KERNEL"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstruct aa_load_ent *aa_load_ent_alloc(void)\n{\n\tstruct aa_load_ent *ent = kzalloc(sizeof(*ent), GFP_KERNEL);\n\tif (ent)\n\t\tINIT_LIST_HEAD(&ent->list);\n\treturn ent;\n}"
  },
  {
    "function_name": "aa_load_ent_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "924-933",
    "snippet": "void aa_load_ent_free(struct aa_load_ent *ent)\n{\n\tif (ent) {\n\t\taa_put_profile(ent->rename);\n\t\taa_put_profile(ent->old);\n\t\taa_put_profile(ent->new);\n\t\tkfree(ent->ns_name);\n\t\tkzfree(ent);\n\t}\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "ent"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ent->ns_name"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_profile",
          "args": [
            "ent->new"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "277-281",
          "snippet": "static inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nvoid aa_load_ent_free(struct aa_load_ent *ent)\n{\n\tif (ent) {\n\t\taa_put_profile(ent->rename);\n\t\taa_put_profile(ent->old);\n\t\taa_put_profile(ent->new);\n\t\tkfree(ent->ns_name);\n\t\tkzfree(ent);\n\t}\n}"
  },
  {
    "function_name": "verify_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "911-922",
    "snippet": "static int verify_profile(struct aa_profile *profile)\n{\n\tif (profile->file.dfa &&\n\t    !verify_dfa_xindex(profile->file.dfa,\n\t\t\t       profile->file.trans.size)) {\n\t\taudit_iface(profile, NULL, NULL, \"Invalid named transition\",\n\t\t\t    NULL, -EPROTO);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_iface",
          "args": [
            "profile",
            "NULL",
            "NULL",
            "\"Invalid named transition\"",
            "NULL",
            "-EPROTO"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "audit_iface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "107-124",
          "snippet": "static int audit_iface(struct aa_profile *new, const char *ns_name,\n\t\t       const char *name, const char *info, struct aa_ext *e,\n\t\t       int error)\n{\n\tstruct aa_profile *profile = labels_profile(aa_current_raw_label());\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, NULL);\n\tif (e)\n\t\taad(&sa)->iface.pos = e->pos - e->start;\n\taad(&sa)->iface.ns = ns_name;\n\tif (new)\n\t\taad(&sa)->name = new->base.hname;\n\telse\n\t\taad(&sa)->name = name;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_STATUS, profile, &sa, audit_cb);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic int audit_iface(struct aa_profile *new, const char *ns_name,\n\t\t       const char *name, const char *info, struct aa_ext *e,\n\t\t       int error)\n{\n\tstruct aa_profile *profile = labels_profile(aa_current_raw_label());\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, NULL);\n\tif (e)\n\t\taad(&sa)->iface.pos = e->pos - e->start;\n\taad(&sa)->iface.ns = ns_name;\n\tif (new)\n\t\taad(&sa)->name = new->base.hname;\n\telse\n\t\taad(&sa)->name = name;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_STATUS, profile, &sa, audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_dfa_xindex",
          "args": [
            "profile->file.dfa",
            "profile->file.trans.size"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "verify_dfa_xindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "893-903",
          "snippet": "static bool verify_dfa_xindex(struct aa_dfa *dfa, int table_size)\n{\n\tint i;\n\tfor (i = 0; i < dfa->tables[YYTD_ID_ACCEPT]->td_lolen; i++) {\n\t\tif (!verify_xindex(dfa_user_xindex(dfa, i), table_size))\n\t\t\treturn 0;\n\t\tif (!verify_xindex(dfa_other_xindex(dfa, i), table_size))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool verify_dfa_xindex(struct aa_dfa *dfa, int table_size)\n{\n\tint i;\n\tfor (i = 0; i < dfa->tables[YYTD_ID_ACCEPT]->td_lolen; i++) {\n\t\tif (!verify_xindex(dfa_user_xindex(dfa, i), table_size))\n\t\t\treturn 0;\n\t\tif (!verify_xindex(dfa_other_xindex(dfa, i), table_size))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic int verify_profile(struct aa_profile *profile)\n{\n\tif (profile->file.dfa &&\n\t    !verify_dfa_xindex(profile->file.dfa,\n\t\t\t       profile->file.trans.size)) {\n\t\taudit_iface(profile, NULL, NULL, \"Invalid named transition\",\n\t\t\t    NULL, -EPROTO);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "verify_dfa_xindex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "893-903",
    "snippet": "static bool verify_dfa_xindex(struct aa_dfa *dfa, int table_size)\n{\n\tint i;\n\tfor (i = 0; i < dfa->tables[YYTD_ID_ACCEPT]->td_lolen; i++) {\n\t\tif (!verify_xindex(dfa_user_xindex(dfa, i), table_size))\n\t\t\treturn 0;\n\t\tif (!verify_xindex(dfa_other_xindex(dfa, i), table_size))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify_xindex",
          "args": [
            "dfa_other_xindex(dfa, i)",
            "table_size"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "verify_xindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "882-890",
          "snippet": "static bool verify_xindex(int xindex, int table_size)\n{\n\tint index, xtype;\n\txtype = xindex & AA_X_TYPE_MASK;\n\tindex = xindex & AA_X_INDEX_MASK;\n\tif (xtype == AA_X_TABLE && index >= table_size)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool verify_xindex(int xindex, int table_size)\n{\n\tint index, xtype;\n\txtype = xindex & AA_X_TYPE_MASK;\n\tindex = xindex & AA_X_INDEX_MASK;\n\tif (xtype == AA_X_TABLE && index >= table_size)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfa_other_xindex",
          "args": [
            "dfa",
            "i"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfa_user_xindex",
          "args": [
            "dfa",
            "i"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool verify_dfa_xindex(struct aa_dfa *dfa, int table_size)\n{\n\tint i;\n\tfor (i = 0; i < dfa->tables[YYTD_ID_ACCEPT]->td_lolen; i++) {\n\t\tif (!verify_xindex(dfa_user_xindex(dfa, i), table_size))\n\t\t\treturn 0;\n\t\tif (!verify_xindex(dfa_other_xindex(dfa, i), table_size))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "verify_xindex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "882-890",
    "snippet": "static bool verify_xindex(int xindex, int table_size)\n{\n\tint index, xtype;\n\txtype = xindex & AA_X_TYPE_MASK;\n\tindex = xindex & AA_X_INDEX_MASK;\n\tif (xtype == AA_X_TABLE && index >= table_size)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool verify_xindex(int xindex, int table_size)\n{\n\tint index, xtype;\n\txtype = xindex & AA_X_TYPE_MASK;\n\tindex = xindex & AA_X_INDEX_MASK;\n\tif (xtype == AA_X_TABLE && index >= table_size)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "verify_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "840-880",
    "snippet": "static int verify_header(struct aa_ext *e, int required, const char **ns)\n{\n\tint error = -EPROTONOSUPPORT;\n\tconst char *name = NULL;\n\t*ns = NULL;\n\n\t/* get the interface version */\n\tif (!unpack_u32(e, &e->version, \"version\")) {\n\t\tif (required) {\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid profile format\",\n\t\t\t\t    e, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t/* Check that the interface version is currently supported.\n\t * if not specified use previous version\n\t * Mask off everything that is not kernel abi version\n\t */\n\tif (VERSION_LT(e->version, v5) || VERSION_GT(e->version, v7)) {\n\t\taudit_iface(NULL, NULL, NULL, \"unsupported interface version\",\n\t\t\t    e, error);\n\t\treturn error;\n\t}\n\n\t/* read the namespace if present */\n\tif (unpack_str(e, &name, \"namespace\")) {\n\t\tif (*name == '\\0') {\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid namespace name\",\n\t\t\t\t    e, error);\n\t\t\treturn error;\n\t\t}\n\t\tif (*ns && strcmp(*ns, name))\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid ns change\", e,\n\t\t\t\t    error);\n\t\telse if (!*ns)\n\t\t\t*ns = name;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [
      "#define v7\t7\t/* full network masking */",
      "#define v5\t5\t/* base version */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_iface",
          "args": [
            "NULL",
            "NULL",
            "NULL",
            "\"invalid ns change\"",
            "e",
            "error"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "audit_iface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "107-124",
          "snippet": "static int audit_iface(struct aa_profile *new, const char *ns_name,\n\t\t       const char *name, const char *info, struct aa_ext *e,\n\t\t       int error)\n{\n\tstruct aa_profile *profile = labels_profile(aa_current_raw_label());\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, NULL);\n\tif (e)\n\t\taad(&sa)->iface.pos = e->pos - e->start;\n\taad(&sa)->iface.ns = ns_name;\n\tif (new)\n\t\taad(&sa)->name = new->base.hname;\n\telse\n\t\taad(&sa)->name = name;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_STATUS, profile, &sa, audit_cb);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic int audit_iface(struct aa_profile *new, const char *ns_name,\n\t\t       const char *name, const char *info, struct aa_ext *e,\n\t\t       int error)\n{\n\tstruct aa_profile *profile = labels_profile(aa_current_raw_label());\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, NULL);\n\tif (e)\n\t\taad(&sa)->iface.pos = e->pos - e->start;\n\taad(&sa)->iface.ns = ns_name;\n\tif (new)\n\t\taad(&sa)->name = new->base.hname;\n\telse\n\t\taad(&sa)->name = name;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_STATUS, profile, &sa, audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*ns",
            "name"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_str",
          "args": [
            "e",
            "&name",
            "\"namespace\""
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "356-373",
          "snippet": "static int unpack_strdup(struct aa_ext *e, char **string, const char *name)\n{\n\tconst char *tmp;\n\tvoid *pos = e->pos;\n\tint res = unpack_str(e, &tmp, name);\n\t*string = NULL;\n\n\tif (!res)\n\t\treturn 0;\n\n\t*string = kmemdup(tmp, res, GFP_KERNEL);\n\tif (!*string) {\n\t\te->pos = pos;\n\t\treturn 0;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic int unpack_strdup(struct aa_ext *e, char **string, const char *name)\n{\n\tconst char *tmp;\n\tvoid *pos = e->pos;\n\tint res = unpack_str(e, &tmp, name);\n\t*string = NULL;\n\n\tif (!res)\n\t\treturn 0;\n\n\t*string = kmemdup(tmp, res, GFP_KERNEL);\n\tif (!*string) {\n\t\te->pos = pos;\n\t\treturn 0;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERSION_GT",
          "args": [
            "e->version",
            "v7"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERSION_LT",
          "args": [
            "e->version",
            "v5"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_u32",
          "args": [
            "e",
            "&e->version",
            "\"version\""
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "278-289",
          "snippet": "static bool unpack_u32(struct aa_ext *e, u32 *data, const char *name)\n{\n\tif (unpack_nameX(e, AA_U32, name)) {\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tif (data)\n\t\t\t*data = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_u32(struct aa_ext *e, u32 *data, const char *name)\n{\n\tif (unpack_nameX(e, AA_U32, name)) {\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tif (data)\n\t\t\t*data = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\n#define v7\t7\t/* full network masking */\n#define v5\t5\t/* base version */\n\nstatic int verify_header(struct aa_ext *e, int required, const char **ns)\n{\n\tint error = -EPROTONOSUPPORT;\n\tconst char *name = NULL;\n\t*ns = NULL;\n\n\t/* get the interface version */\n\tif (!unpack_u32(e, &e->version, \"version\")) {\n\t\tif (required) {\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid profile format\",\n\t\t\t\t    e, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t/* Check that the interface version is currently supported.\n\t * if not specified use previous version\n\t * Mask off everything that is not kernel abi version\n\t */\n\tif (VERSION_LT(e->version, v5) || VERSION_GT(e->version, v7)) {\n\t\taudit_iface(NULL, NULL, NULL, \"unsupported interface version\",\n\t\t\t    e, error);\n\t\treturn error;\n\t}\n\n\t/* read the namespace if present */\n\tif (unpack_str(e, &name, \"namespace\")) {\n\t\tif (*name == '\\0') {\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid namespace name\",\n\t\t\t\t    e, error);\n\t\t\treturn error;\n\t\t}\n\t\tif (*ns && strcmp(*ns, name))\n\t\t\taudit_iface(NULL, NULL, NULL, \"invalid ns change\", e,\n\t\t\t\t    error);\n\t\telse if (!*ns)\n\t\t\t*ns = name;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "unpack_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "582-830",
    "snippet": "static struct aa_profile *unpack_profile(struct aa_ext *e, char **ns_name)\n{\n\tstruct aa_profile *profile = NULL;\n\tconst char *tmpname, *tmpns = NULL, *name = NULL;\n\tconst char *info = \"failed to unpack profile\";\n\tsize_t ns_len;\n\tstruct rhashtable_params params = { 0 };\n\tchar *key = NULL;\n\tstruct aa_data *data;\n\tint i, error = -EPROTO;\n\tkernel_cap_t tmpcap;\n\tu32 tmp;\n\n\t*ns_name = NULL;\n\n\t/* check that we have the right struct being passed */\n\tif (!unpack_nameX(e, AA_STRUCT, \"profile\"))\n\t\tgoto fail;\n\tif (!unpack_str(e, &name, NULL))\n\t\tgoto fail;\n\tif (*name == '\\0')\n\t\tgoto fail;\n\n\ttmpname = aa_splitn_fqname(name, strlen(name), &tmpns, &ns_len);\n\tif (tmpns) {\n\t\t*ns_name = kstrndup(tmpns, ns_len, GFP_KERNEL);\n\t\tif (!*ns_name) {\n\t\t\tinfo = \"out of memory\";\n\t\t\tgoto fail;\n\t\t}\n\t\tname = tmpname;\n\t}\n\n\tprofile = aa_alloc_profile(name, NULL, GFP_KERNEL);\n\tif (!profile)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* profile renaming is optional */\n\t(void) unpack_str(e, &profile->rename, \"rename\");\n\n\t/* attachment string is optional */\n\t(void) unpack_str(e, &profile->attach, \"attach\");\n\n\t/* xmatch is optional and may be NULL */\n\tprofile->xmatch = unpack_dfa(e);\n\tif (IS_ERR(profile->xmatch)) {\n\t\terror = PTR_ERR(profile->xmatch);\n\t\tprofile->xmatch = NULL;\n\t\tinfo = \"bad xmatch\";\n\t\tgoto fail;\n\t}\n\t/* xmatch_len is not optional if xmatch is set */\n\tif (profile->xmatch) {\n\t\tif (!unpack_u32(e, &tmp, NULL)) {\n\t\t\tinfo = \"missing xmatch len\";\n\t\t\tgoto fail;\n\t\t}\n\t\tprofile->xmatch_len = tmp;\n\t}\n\n\t/* disconnected attachment string is optional */\n\t(void) unpack_str(e, &profile->disconnected, \"disconnected\");\n\n\t/* per profile debug flags (complain, audit) */\n\tif (!unpack_nameX(e, AA_STRUCT, \"flags\")) {\n\t\tinfo = \"profile missing flags\";\n\t\tgoto fail;\n\t}\n\tinfo = \"failed to unpack profile flags\";\n\tif (!unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp & PACKED_FLAG_HAT)\n\t\tprofile->label.flags |= FLAG_HAT;\n\tif (!unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp == PACKED_MODE_COMPLAIN || (e->version & FORCE_COMPLAIN_FLAG))\n\t\tprofile->mode = APPARMOR_COMPLAIN;\n\telse if (tmp == PACKED_MODE_KILL)\n\t\tprofile->mode = APPARMOR_KILL;\n\telse if (tmp == PACKED_MODE_UNCONFINED)\n\t\tprofile->mode = APPARMOR_UNCONFINED;\n\tif (!unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp)\n\t\tprofile->audit = AUDIT_ALL;\n\n\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\tgoto fail;\n\n\t/* path_flags is optional */\n\tif (unpack_u32(e, &profile->path_flags, \"path_flags\"))\n\t\tprofile->path_flags |= profile->label.flags &\n\t\t\tPATH_MEDIATE_DELETED;\n\telse\n\t\t/* set a default value if path_flags field is not present */\n\t\tprofile->path_flags = PATH_MEDIATE_DELETED;\n\n\tinfo = \"failed to unpack profile capabilities\";\n\tif (!unpack_u32(e, &(profile->caps.allow.cap[0]), NULL))\n\t\tgoto fail;\n\tif (!unpack_u32(e, &(profile->caps.audit.cap[0]), NULL))\n\t\tgoto fail;\n\tif (!unpack_u32(e, &(profile->caps.quiet.cap[0]), NULL))\n\t\tgoto fail;\n\tif (!unpack_u32(e, &tmpcap.cap[0], NULL))\n\t\tgoto fail;\n\n\tinfo = \"failed to unpack upper profile capabilities\";\n\tif (unpack_nameX(e, AA_STRUCT, \"caps64\")) {\n\t\t/* optional upper half of 64 bit caps */\n\t\tif (!unpack_u32(e, &(profile->caps.allow.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(profile->caps.audit.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(profile->caps.quiet.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(tmpcap.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\n\tinfo = \"failed to unpack extended profile capabilities\";\n\tif (unpack_nameX(e, AA_STRUCT, \"capsx\")) {\n\t\t/* optional extended caps mediation mask */\n\t\tif (!unpack_u32(e, &(profile->caps.extended.cap[0]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(profile->caps.extended.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\n\tif (!unpack_rlimits(e, profile)) {\n\t\tinfo = \"failed to unpack profile rlimits\";\n\t\tgoto fail;\n\t}\n\n\tif (unpack_nameX(e, AA_STRUCT, \"policydb\")) {\n\t\t/* generic policy dfa - optional and may be NULL */\n\t\tinfo = \"failed to unpack policydb\";\n\t\tprofile->policy.dfa = unpack_dfa(e);\n\t\tif (IS_ERR(profile->policy.dfa)) {\n\t\t\terror = PTR_ERR(profile->policy.dfa);\n\t\t\tprofile->policy.dfa = NULL;\n\t\t\tgoto fail;\n\t\t} else if (!profile->policy.dfa) {\n\t\t\terror = -EPROTO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (!unpack_u32(e, &profile->policy.start[0], \"start\"))\n\t\t\t/* default start state */\n\t\t\tprofile->policy.start[0] = DFA_START;\n\t\t/* setup class index */\n\t\tfor (i = AA_CLASS_FILE; i <= AA_CLASS_LAST; i++) {\n\t\t\tprofile->policy.start[i] =\n\t\t\t\taa_dfa_next(profile->policy.dfa,\n\t\t\t\t\t    profile->policy.start[0],\n\t\t\t\t\t    i);\n\t\t}\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t} else\n\t\tprofile->policy.dfa = aa_get_dfa(nulldfa);\n\n\t/* get file rules */\n\tprofile->file.dfa = unpack_dfa(e);\n\tif (IS_ERR(profile->file.dfa)) {\n\t\terror = PTR_ERR(profile->file.dfa);\n\t\tprofile->file.dfa = NULL;\n\t\tinfo = \"failed to unpack profile file rules\";\n\t\tgoto fail;\n\t} else if (profile->file.dfa) {\n\t\tif (!unpack_u32(e, &profile->file.start, \"dfa_start\"))\n\t\t\t/* default start state */\n\t\t\tprofile->file.start = DFA_START;\n\t} else if (profile->policy.dfa &&\n\t\t   profile->policy.start[AA_CLASS_FILE]) {\n\t\tprofile->file.dfa = aa_get_dfa(profile->policy.dfa);\n\t\tprofile->file.start = profile->policy.start[AA_CLASS_FILE];\n\t} else\n\t\tprofile->file.dfa = aa_get_dfa(nulldfa);\n\n\tif (!unpack_trans_table(e, profile)) {\n\t\tinfo = \"failed to unpack profile transition table\";\n\t\tgoto fail;\n\t}\n\n\tif (unpack_nameX(e, AA_STRUCT, \"data\")) {\n\t\tinfo = \"out of memory\";\n\t\tprofile->data = kzalloc(sizeof(*profile->data), GFP_KERNEL);\n\t\tif (!profile->data)\n\t\t\tgoto fail;\n\n\t\tparams.nelem_hint = 3;\n\t\tparams.key_len = sizeof(void *);\n\t\tparams.key_offset = offsetof(struct aa_data, key);\n\t\tparams.head_offset = offsetof(struct aa_data, head);\n\t\tparams.hashfn = strhash;\n\t\tparams.obj_cmpfn = datacmp;\n\n\t\tif (rhashtable_init(profile->data, &params)) {\n\t\t\tinfo = \"failed to init key, value hash table\";\n\t\t\tgoto fail;\n\t\t}\n\n\t\twhile (unpack_strdup(e, &key, NULL)) {\n\t\t\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\t\t\tif (!data) {\n\t\t\t\tkzfree(key);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tdata->key = key;\n\t\t\tdata->size = unpack_blob(e, &data->data, NULL);\n\t\t\tdata->data = kvmemdup(data->data, data->size);\n\t\t\tif (data->size && !data->data) {\n\t\t\t\tkzfree(data->key);\n\t\t\t\tkzfree(data);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trhashtable_insert_fast(profile->data, &data->head,\n\t\t\t\t\t       profile->data->p);\n\t\t}\n\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL)) {\n\t\t\tinfo = \"failed to unpack end of key, value data table\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!unpack_nameX(e, AA_STRUCTEND, NULL)) {\n\t\tinfo = \"failed to unpack end of profile\";\n\t\tgoto fail;\n\t}\n\n\treturn profile;\n\nfail:\n\tif (profile)\n\t\tname = NULL;\n\telse if (!name)\n\t\tname = \"unknown\";\n\taudit_iface(profile, NULL, name, info, e, error);\n\taa_free_profile(profile);\n\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [
      "#define FORCE_COMPLAIN_FLAG 0x800"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_free_profile",
          "args": [
            "profile"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "aa_free_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "210-245",
          "snippet": "void aa_free_profile(struct aa_profile *profile)\n{\n\tstruct rhashtable *rht;\n\n\tAA_DEBUG(\"%s(%p)\\n\", __func__, profile);\n\n\tif (!profile)\n\t\treturn;\n\n\t/* free children profiles */\n\taa_policy_destroy(&profile->base);\n\taa_put_profile(rcu_access_pointer(profile->parent));\n\n\taa_put_ns(profile->ns);\n\tkzfree(profile->rename);\n\n\taa_free_file_rules(&profile->file);\n\taa_free_cap_rules(&profile->caps);\n\taa_free_rlimit_rules(&profile->rlimits);\n\n\tkzfree(profile->dirname);\n\taa_put_dfa(profile->xmatch);\n\taa_put_dfa(profile->policy.dfa);\n\n\tif (profile->data) {\n\t\trht = profile->data;\n\t\tprofile->data = NULL;\n\t\trhashtable_free_and_destroy(rht, aa_free_data, NULL);\n\t\tkzfree(rht);\n\t}\n\n\tkzfree(profile->hash);\n\taa_put_loaddata(profile->rawdata);\n\n\tkzfree(profile);\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid aa_free_profile(struct aa_profile *profile)\n{\n\tstruct rhashtable *rht;\n\n\tAA_DEBUG(\"%s(%p)\\n\", __func__, profile);\n\n\tif (!profile)\n\t\treturn;\n\n\t/* free children profiles */\n\taa_policy_destroy(&profile->base);\n\taa_put_profile(rcu_access_pointer(profile->parent));\n\n\taa_put_ns(profile->ns);\n\tkzfree(profile->rename);\n\n\taa_free_file_rules(&profile->file);\n\taa_free_cap_rules(&profile->caps);\n\taa_free_rlimit_rules(&profile->rlimits);\n\n\tkzfree(profile->dirname);\n\taa_put_dfa(profile->xmatch);\n\taa_put_dfa(profile->policy.dfa);\n\n\tif (profile->data) {\n\t\trht = profile->data;\n\t\tprofile->data = NULL;\n\t\trhashtable_free_and_destroy(rht, aa_free_data, NULL);\n\t\tkzfree(rht);\n\t}\n\n\tkzfree(profile->hash);\n\taa_put_loaddata(profile->rawdata);\n\n\tkzfree(profile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_iface",
          "args": [
            "profile",
            "NULL",
            "name",
            "info",
            "e",
            "error"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "audit_iface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "107-124",
          "snippet": "static int audit_iface(struct aa_profile *new, const char *ns_name,\n\t\t       const char *name, const char *info, struct aa_ext *e,\n\t\t       int error)\n{\n\tstruct aa_profile *profile = labels_profile(aa_current_raw_label());\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, NULL);\n\tif (e)\n\t\taad(&sa)->iface.pos = e->pos - e->start;\n\taad(&sa)->iface.ns = ns_name;\n\tif (new)\n\t\taad(&sa)->name = new->base.hname;\n\telse\n\t\taad(&sa)->name = name;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_STATUS, profile, &sa, audit_cb);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic int audit_iface(struct aa_profile *new, const char *ns_name,\n\t\t       const char *name, const char *info, struct aa_ext *e,\n\t\t       int error)\n{\n\tstruct aa_profile *profile = labels_profile(aa_current_raw_label());\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, NULL);\n\tif (e)\n\t\taad(&sa)->iface.pos = e->pos - e->start;\n\taad(&sa)->iface.ns = ns_name;\n\tif (new)\n\t\taad(&sa)->name = new->base.hname;\n\telse\n\t\taad(&sa)->name = name;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_STATUS, profile, &sa, audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpack_nameX",
          "args": [
            "e",
            "AA_STRUCTEND",
            "NULL"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_nameX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "248-276",
          "snippet": "static bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rhashtable_insert_fast",
          "args": [
            "profile->data",
            "&data->head",
            "profile->data->p"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "data"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "data->key"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmemdup",
          "args": [
            "data->data",
            "data->size"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "kvmemdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "552-559",
          "snippet": "static void *kvmemdup(const void *src, size_t len)\n{\n\tvoid *p = kvmalloc(len, GFP_KERNEL);\n\n\tif (p)\n\t\tmemcpy(p, src, len);\n\treturn p;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic void *kvmemdup(const void *src, size_t len)\n{\n\tvoid *p = kvmalloc(len, GFP_KERNEL);\n\n\tif (p)\n\t\tmemcpy(p, src, len);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpack_blob",
          "args": [
            "e",
            "&data->data",
            "NULL"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "317-332",
          "snippet": "static size_t unpack_blob(struct aa_ext *e, char **blob, const char *name)\n{\n\tif (unpack_nameX(e, AA_BLOB, name)) {\n\t\tu32 size;\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tsize = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\tif (inbounds(e, (size_t) size)) {\n\t\t\t*blob = e->pos;\n\t\t\te->pos += size;\n\t\t\treturn size;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic size_t unpack_blob(struct aa_ext *e, char **blob, const char *name)\n{\n\tif (unpack_nameX(e, AA_BLOB, name)) {\n\t\tu32 size;\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tsize = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\tif (inbounds(e, (size_t) size)) {\n\t\t\t*blob = e->pos;\n\t\t\te->pos += size;\n\t\t\treturn size;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "key"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_strdup",
          "args": [
            "e",
            "&key",
            "NULL"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "356-373",
          "snippet": "static int unpack_strdup(struct aa_ext *e, char **string, const char *name)\n{\n\tconst char *tmp;\n\tvoid *pos = e->pos;\n\tint res = unpack_str(e, &tmp, name);\n\t*string = NULL;\n\n\tif (!res)\n\t\treturn 0;\n\n\t*string = kmemdup(tmp, res, GFP_KERNEL);\n\tif (!*string) {\n\t\te->pos = pos;\n\t\treturn 0;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic int unpack_strdup(struct aa_ext *e, char **string, const char *name)\n{\n\tconst char *tmp;\n\tvoid *pos = e->pos;\n\tint res = unpack_str(e, &tmp, name);\n\t*string = NULL;\n\n\tif (!res)\n\t\treturn 0;\n\n\t*string = kmemdup(tmp, res, GFP_KERNEL);\n\tif (!*string) {\n\t\te->pos = pos;\n\t\treturn 0;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rhashtable_init",
          "args": [
            "profile->data",
            "&params"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*profile->data)",
            "GFP_KERNEL"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_trans_table",
          "args": [
            "e",
            "profile"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_trans_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "449-516",
          "snippet": "static bool unpack_trans_table(struct aa_ext *e, struct aa_profile *profile)\n{\n\tvoid *saved_pos = e->pos;\n\n\t/* exec table is optional */\n\tif (unpack_nameX(e, AA_STRUCT, \"xtable\")) {\n\t\tint i, size;\n\n\t\tsize = unpack_array(e, NULL);\n\t\t/* currently 4 exec bits and entries 0-3 are reserved iupcx */\n\t\tif (size > 16 - 4)\n\t\t\tgoto fail;\n\t\tprofile->file.trans.table = kzalloc(sizeof(char *) * size,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!profile->file.trans.table)\n\t\t\tgoto fail;\n\n\t\tprofile->file.trans.size = size;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tchar *str;\n\t\t\tint c, j, pos, size2 = unpack_strdup(e, &str, NULL);\n\t\t\t/* unpack_strdup verifies that the last character is\n\t\t\t * null termination byte.\n\t\t\t */\n\t\t\tif (!size2)\n\t\t\t\tgoto fail;\n\t\t\tprofile->file.trans.table[i] = str;\n\t\t\t/* verify that name doesn't start with space */\n\t\t\tif (isspace(*str))\n\t\t\t\tgoto fail;\n\n\t\t\t/* count internal #  of internal \\0 */\n\t\t\tfor (c = j = 0; j < size2 - 1; j++) {\n\t\t\t\tif (!str[j]) {\n\t\t\t\t\tpos = j;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*str == ':') {\n\t\t\t\t/* first character after : must be valid */\n\t\t\t\tif (!str[1])\n\t\t\t\t\tgoto fail;\n\t\t\t\t/* beginning with : requires an embedded \\0,\n\t\t\t\t * verify that exactly 1 internal \\0 exists\n\t\t\t\t * trailing \\0 already verified by unpack_strdup\n\t\t\t\t *\n\t\t\t\t * convert \\0 back to : for label_parse\n\t\t\t\t */\n\t\t\t\tif (c == 1)\n\t\t\t\t\tstr[pos] = ':';\n\t\t\t\telse if (c > 1)\n\t\t\t\t\tgoto fail;\n\t\t\t} else if (c)\n\t\t\t\t/* fail - all other cases with embedded \\0 */\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (!unpack_nameX(e, AA_ARRAYEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\treturn 1;\n\nfail:\n\taa_free_domain_entries(&profile->file.trans);\n\te->pos = saved_pos;\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_trans_table(struct aa_ext *e, struct aa_profile *profile)\n{\n\tvoid *saved_pos = e->pos;\n\n\t/* exec table is optional */\n\tif (unpack_nameX(e, AA_STRUCT, \"xtable\")) {\n\t\tint i, size;\n\n\t\tsize = unpack_array(e, NULL);\n\t\t/* currently 4 exec bits and entries 0-3 are reserved iupcx */\n\t\tif (size > 16 - 4)\n\t\t\tgoto fail;\n\t\tprofile->file.trans.table = kzalloc(sizeof(char *) * size,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!profile->file.trans.table)\n\t\t\tgoto fail;\n\n\t\tprofile->file.trans.size = size;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tchar *str;\n\t\t\tint c, j, pos, size2 = unpack_strdup(e, &str, NULL);\n\t\t\t/* unpack_strdup verifies that the last character is\n\t\t\t * null termination byte.\n\t\t\t */\n\t\t\tif (!size2)\n\t\t\t\tgoto fail;\n\t\t\tprofile->file.trans.table[i] = str;\n\t\t\t/* verify that name doesn't start with space */\n\t\t\tif (isspace(*str))\n\t\t\t\tgoto fail;\n\n\t\t\t/* count internal #  of internal \\0 */\n\t\t\tfor (c = j = 0; j < size2 - 1; j++) {\n\t\t\t\tif (!str[j]) {\n\t\t\t\t\tpos = j;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*str == ':') {\n\t\t\t\t/* first character after : must be valid */\n\t\t\t\tif (!str[1])\n\t\t\t\t\tgoto fail;\n\t\t\t\t/* beginning with : requires an embedded \\0,\n\t\t\t\t * verify that exactly 1 internal \\0 exists\n\t\t\t\t * trailing \\0 already verified by unpack_strdup\n\t\t\t\t *\n\t\t\t\t * convert \\0 back to : for label_parse\n\t\t\t\t */\n\t\t\t\tif (c == 1)\n\t\t\t\t\tstr[pos] = ':';\n\t\t\t\telse if (c > 1)\n\t\t\t\t\tgoto fail;\n\t\t\t} else if (c)\n\t\t\t\t/* fail - all other cases with embedded \\0 */\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (!unpack_nameX(e, AA_ARRAYEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\treturn 1;\n\nfail:\n\taa_free_domain_entries(&profile->file.trans);\n\te->pos = saved_pos;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_dfa",
          "args": [
            "nulldfa"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_dfa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/match.h",
          "lines": "142-148",
          "snippet": "static inline struct aa_dfa *aa_get_dfa(struct aa_dfa *dfa)\n{\n\tif (dfa)\n\t\tkref_get(&(dfa->count));\n\n\treturn dfa;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline struct aa_dfa *aa_get_dfa(struct aa_dfa *dfa)\n{\n\tif (dfa)\n\t\tkref_get(&(dfa->count));\n\n\treturn dfa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpack_u32",
          "args": [
            "e",
            "&profile->file.start",
            "\"dfa_start\""
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "278-289",
          "snippet": "static bool unpack_u32(struct aa_ext *e, u32 *data, const char *name)\n{\n\tif (unpack_nameX(e, AA_U32, name)) {\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tif (data)\n\t\t\t*data = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_u32(struct aa_ext *e, u32 *data, const char *name)\n{\n\tif (unpack_nameX(e, AA_U32, name)) {\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tif (data)\n\t\t\t*data = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "profile->file.dfa"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "profile->file.dfa"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_dfa",
          "args": [
            "e"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_dfa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "408-440",
          "snippet": "static struct aa_dfa *unpack_dfa(struct aa_ext *e)\n{\n\tchar *blob = NULL;\n\tsize_t size;\n\tstruct aa_dfa *dfa = NULL;\n\n\tsize = unpack_blob(e, &blob, \"aadfa\");\n\tif (size) {\n\t\t/*\n\t\t * The dfa is aligned with in the blob to 8 bytes\n\t\t * from the beginning of the stream.\n\t\t * alignment adjust needed by dfa unpack\n\t\t */\n\t\tsize_t sz = blob - (char *) e->start -\n\t\t\t((e->pos - e->start) & 7);\n\t\tsize_t pad = ALIGN(sz, 8) - sz;\n\t\tint flags = TO_ACCEPT1_FLAG(YYTD_DATA32) |\n\t\t\tTO_ACCEPT2_FLAG(YYTD_DATA32) | DFA_FLAG_VERIFY_STATES;\n\t\tdfa = aa_dfa_unpack(blob + pad, size - pad, flags);\n\n\t\tif (IS_ERR(dfa))\n\t\t\treturn dfa;\n\n\t\tif (!verify_accept(dfa, flags))\n\t\t\tgoto fail;\n\t}\n\n\treturn dfa;\n\nfail:\n\taa_put_dfa(dfa);\n\treturn ERR_PTR(-EPROTO);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic struct aa_dfa *unpack_dfa(struct aa_ext *e)\n{\n\tchar *blob = NULL;\n\tsize_t size;\n\tstruct aa_dfa *dfa = NULL;\n\n\tsize = unpack_blob(e, &blob, \"aadfa\");\n\tif (size) {\n\t\t/*\n\t\t * The dfa is aligned with in the blob to 8 bytes\n\t\t * from the beginning of the stream.\n\t\t * alignment adjust needed by dfa unpack\n\t\t */\n\t\tsize_t sz = blob - (char *) e->start -\n\t\t\t((e->pos - e->start) & 7);\n\t\tsize_t pad = ALIGN(sz, 8) - sz;\n\t\tint flags = TO_ACCEPT1_FLAG(YYTD_DATA32) |\n\t\t\tTO_ACCEPT2_FLAG(YYTD_DATA32) | DFA_FLAG_VERIFY_STATES;\n\t\tdfa = aa_dfa_unpack(blob + pad, size - pad, flags);\n\n\t\tif (IS_ERR(dfa))\n\t\t\treturn dfa;\n\n\t\tif (!verify_accept(dfa, flags))\n\t\t\tgoto fail;\n\t}\n\n\treturn dfa;\n\nfail:\n\taa_put_dfa(dfa);\n\treturn ERR_PTR(-EPROTO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_next",
          "args": [
            "profile->policy.dfa",
            "profile->policy.start[0]",
            "i"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "429-459",
          "snippet": "unsigned int aa_dfa_next(struct aa_dfa *dfa, unsigned int state,\n\t\t\t  const char c)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int pos;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\n\t\tpos = base_idx(base[state]) + equiv[(u8) c];\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t} else {\n\t\t/* default is direct to next state */\n\t\tpos = base_idx(base[state]) + (u8) c;\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_next(struct aa_dfa *dfa, unsigned int state,\n\t\t\t  const char c)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int pos;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\n\t\tpos = base_idx(base[state]) + equiv[(u8) c];\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t} else {\n\t\t/* default is direct to next state */\n\t\tpos = base_idx(base[state]) + (u8) c;\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "profile->policy.dfa"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "profile->policy.dfa"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_rlimits",
          "args": [
            "e",
            "profile"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_rlimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "518-550",
          "snippet": "static bool unpack_rlimits(struct aa_ext *e, struct aa_profile *profile)\n{\n\tvoid *pos = e->pos;\n\n\t/* rlimits are optional */\n\tif (unpack_nameX(e, AA_STRUCT, \"rlimits\")) {\n\t\tint i, size;\n\t\tu32 tmp = 0;\n\t\tif (!unpack_u32(e, &tmp, NULL))\n\t\t\tgoto fail;\n\t\tprofile->rlimits.mask = tmp;\n\n\t\tsize = unpack_array(e, NULL);\n\t\tif (size > RLIM_NLIMITS)\n\t\t\tgoto fail;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tu64 tmp2 = 0;\n\t\t\tint a = aa_map_resource(i);\n\t\t\tif (!unpack_u64(e, &tmp2, NULL))\n\t\t\t\tgoto fail;\n\t\t\tprofile->rlimits.limits[a].rlim_max = tmp2;\n\t\t}\n\t\tif (!unpack_nameX(e, AA_ARRAYEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_rlimits(struct aa_ext *e, struct aa_profile *profile)\n{\n\tvoid *pos = e->pos;\n\n\t/* rlimits are optional */\n\tif (unpack_nameX(e, AA_STRUCT, \"rlimits\")) {\n\t\tint i, size;\n\t\tu32 tmp = 0;\n\t\tif (!unpack_u32(e, &tmp, NULL))\n\t\t\tgoto fail;\n\t\tprofile->rlimits.mask = tmp;\n\n\t\tsize = unpack_array(e, NULL);\n\t\tif (size > RLIM_NLIMITS)\n\t\t\tgoto fail;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tu64 tmp2 = 0;\n\t\t\tint a = aa_map_resource(i);\n\t\t\tif (!unpack_u64(e, &tmp2, NULL))\n\t\t\t\tgoto fail;\n\t\t\tprofile->rlimits.limits[a].rlim_max = tmp2;\n\t\t}\n\t\tif (!unpack_nameX(e, AA_ARRAYEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "profile->xmatch"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "profile->xmatch"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_alloc_profile",
          "args": [
            "name",
            "NULL",
            "GFP_KERNEL"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "aa_alloc_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "254-290",
          "snippet": "struct aa_profile *aa_alloc_profile(const char *hname, struct aa_proxy *proxy,\n\t\t\t\t    gfp_t gfp)\n{\n\tstruct aa_profile *profile;\n\n\t/* freed by free_profile - usually through aa_put_profile */\n\tprofile = kzalloc(sizeof(*profile) + sizeof(struct aa_profile *) * 2,\n\t\t\t  gfp);\n\tif (!profile)\n\t\treturn NULL;\n\n\tif (!aa_policy_init(&profile->base, NULL, hname, gfp))\n\t\tgoto fail;\n\tif (!aa_label_init(&profile->label, 1))\n\t\tgoto fail;\n\n\t/* update being set needed by fs interface */\n\tif (!proxy) {\n\t\tproxy = aa_alloc_proxy(&profile->label, gfp);\n\t\tif (!proxy)\n\t\t\tgoto fail;\n\t} else\n\t\taa_get_proxy(proxy);\n\tprofile->label.proxy = proxy;\n\n\tprofile->label.hname = profile->base.hname;\n\tprofile->label.flags |= FLAG_PROFILE;\n\tprofile->label.vec[0] = profile;\n\n\t/* refcount released by caller */\n\treturn profile;\n\nfail:\n\taa_free_profile(profile);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct aa_profile *aa_alloc_profile(const char *hname, struct aa_proxy *proxy,\n\t\t\t\t    gfp_t gfp)\n{\n\tstruct aa_profile *profile;\n\n\t/* freed by free_profile - usually through aa_put_profile */\n\tprofile = kzalloc(sizeof(*profile) + sizeof(struct aa_profile *) * 2,\n\t\t\t  gfp);\n\tif (!profile)\n\t\treturn NULL;\n\n\tif (!aa_policy_init(&profile->base, NULL, hname, gfp))\n\t\tgoto fail;\n\tif (!aa_label_init(&profile->label, 1))\n\t\tgoto fail;\n\n\t/* update being set needed by fs interface */\n\tif (!proxy) {\n\t\tproxy = aa_alloc_proxy(&profile->label, gfp);\n\t\tif (!proxy)\n\t\t\tgoto fail;\n\t} else\n\t\taa_get_proxy(proxy);\n\tprofile->label.proxy = proxy;\n\n\tprofile->label.hname = profile->base.hname;\n\tprofile->label.flags |= FLAG_PROFILE;\n\tprofile->label.vec[0] = profile;\n\n\t/* refcount released by caller */\n\treturn profile;\n\nfail:\n\taa_free_profile(profile);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "tmpns",
            "ns_len",
            "GFP_KERNEL"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_splitn_fqname",
          "args": [
            "name",
            "strlen(name)",
            "&tmpns",
            "&ns_len"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "aa_splitn_fqname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "87-120",
          "snippet": "const char *aa_splitn_fqname(const char *fqname, size_t n, const char **ns_name,\n\t\t\t     size_t *ns_len)\n{\n\tconst char *end = fqname + n;\n\tconst char *name = skipn_spaces(fqname, n);\n\n\tif (!name)\n\t\treturn NULL;\n\t*ns_name = NULL;\n\t*ns_len = 0;\n\tif (name[0] == ':') {\n\t\tchar *split = strnchr(&name[1], end - &name[1], ':');\n\t\t*ns_name = skipn_spaces(&name[1], end - &name[1]);\n\t\tif (!*ns_name)\n\t\t\treturn NULL;\n\t\tif (split) {\n\t\t\t*ns_len = split - *ns_name;\n\t\t\tif (*ns_len == 0)\n\t\t\t\t*ns_name = NULL;\n\t\t\tsplit++;\n\t\t\tif (end - split > 1 && strncmp(split, \"//\", 2) == 0)\n\t\t\t\tsplit += 2;\n\t\t\tname = skipn_spaces(split, end - split);\n\t\t} else {\n\t\t\t/* a ns name without a following profile is allowed */\n\t\t\tname = NULL;\n\t\t\t*ns_len = end - *ns_name;\n\t\t}\n\t}\n\tif (name && *name == 0)\n\t\tname = NULL;\n\n\treturn name;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nconst char *aa_splitn_fqname(const char *fqname, size_t n, const char **ns_name,\n\t\t\t     size_t *ns_len)\n{\n\tconst char *end = fqname + n;\n\tconst char *name = skipn_spaces(fqname, n);\n\n\tif (!name)\n\t\treturn NULL;\n\t*ns_name = NULL;\n\t*ns_len = 0;\n\tif (name[0] == ':') {\n\t\tchar *split = strnchr(&name[1], end - &name[1], ':');\n\t\t*ns_name = skipn_spaces(&name[1], end - &name[1]);\n\t\tif (!*ns_name)\n\t\t\treturn NULL;\n\t\tif (split) {\n\t\t\t*ns_len = split - *ns_name;\n\t\t\tif (*ns_len == 0)\n\t\t\t\t*ns_name = NULL;\n\t\t\tsplit++;\n\t\t\tif (end - split > 1 && strncmp(split, \"//\", 2) == 0)\n\t\t\t\tsplit += 2;\n\t\t\tname = skipn_spaces(split, end - split);\n\t\t} else {\n\t\t\t/* a ns name without a following profile is allowed */\n\t\t\tname = NULL;\n\t\t\t*ns_len = end - *ns_name;\n\t\t}\n\t}\n\tif (name && *name == 0)\n\t\tname = NULL;\n\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\n#define FORCE_COMPLAIN_FLAG 0x800\n\nstatic struct aa_profile *unpack_profile(struct aa_ext *e, char **ns_name)\n{\n\tstruct aa_profile *profile = NULL;\n\tconst char *tmpname, *tmpns = NULL, *name = NULL;\n\tconst char *info = \"failed to unpack profile\";\n\tsize_t ns_len;\n\tstruct rhashtable_params params = { 0 };\n\tchar *key = NULL;\n\tstruct aa_data *data;\n\tint i, error = -EPROTO;\n\tkernel_cap_t tmpcap;\n\tu32 tmp;\n\n\t*ns_name = NULL;\n\n\t/* check that we have the right struct being passed */\n\tif (!unpack_nameX(e, AA_STRUCT, \"profile\"))\n\t\tgoto fail;\n\tif (!unpack_str(e, &name, NULL))\n\t\tgoto fail;\n\tif (*name == '\\0')\n\t\tgoto fail;\n\n\ttmpname = aa_splitn_fqname(name, strlen(name), &tmpns, &ns_len);\n\tif (tmpns) {\n\t\t*ns_name = kstrndup(tmpns, ns_len, GFP_KERNEL);\n\t\tif (!*ns_name) {\n\t\t\tinfo = \"out of memory\";\n\t\t\tgoto fail;\n\t\t}\n\t\tname = tmpname;\n\t}\n\n\tprofile = aa_alloc_profile(name, NULL, GFP_KERNEL);\n\tif (!profile)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* profile renaming is optional */\n\t(void) unpack_str(e, &profile->rename, \"rename\");\n\n\t/* attachment string is optional */\n\t(void) unpack_str(e, &profile->attach, \"attach\");\n\n\t/* xmatch is optional and may be NULL */\n\tprofile->xmatch = unpack_dfa(e);\n\tif (IS_ERR(profile->xmatch)) {\n\t\terror = PTR_ERR(profile->xmatch);\n\t\tprofile->xmatch = NULL;\n\t\tinfo = \"bad xmatch\";\n\t\tgoto fail;\n\t}\n\t/* xmatch_len is not optional if xmatch is set */\n\tif (profile->xmatch) {\n\t\tif (!unpack_u32(e, &tmp, NULL)) {\n\t\t\tinfo = \"missing xmatch len\";\n\t\t\tgoto fail;\n\t\t}\n\t\tprofile->xmatch_len = tmp;\n\t}\n\n\t/* disconnected attachment string is optional */\n\t(void) unpack_str(e, &profile->disconnected, \"disconnected\");\n\n\t/* per profile debug flags (complain, audit) */\n\tif (!unpack_nameX(e, AA_STRUCT, \"flags\")) {\n\t\tinfo = \"profile missing flags\";\n\t\tgoto fail;\n\t}\n\tinfo = \"failed to unpack profile flags\";\n\tif (!unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp & PACKED_FLAG_HAT)\n\t\tprofile->label.flags |= FLAG_HAT;\n\tif (!unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp == PACKED_MODE_COMPLAIN || (e->version & FORCE_COMPLAIN_FLAG))\n\t\tprofile->mode = APPARMOR_COMPLAIN;\n\telse if (tmp == PACKED_MODE_KILL)\n\t\tprofile->mode = APPARMOR_KILL;\n\telse if (tmp == PACKED_MODE_UNCONFINED)\n\t\tprofile->mode = APPARMOR_UNCONFINED;\n\tif (!unpack_u32(e, &tmp, NULL))\n\t\tgoto fail;\n\tif (tmp)\n\t\tprofile->audit = AUDIT_ALL;\n\n\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\tgoto fail;\n\n\t/* path_flags is optional */\n\tif (unpack_u32(e, &profile->path_flags, \"path_flags\"))\n\t\tprofile->path_flags |= profile->label.flags &\n\t\t\tPATH_MEDIATE_DELETED;\n\telse\n\t\t/* set a default value if path_flags field is not present */\n\t\tprofile->path_flags = PATH_MEDIATE_DELETED;\n\n\tinfo = \"failed to unpack profile capabilities\";\n\tif (!unpack_u32(e, &(profile->caps.allow.cap[0]), NULL))\n\t\tgoto fail;\n\tif (!unpack_u32(e, &(profile->caps.audit.cap[0]), NULL))\n\t\tgoto fail;\n\tif (!unpack_u32(e, &(profile->caps.quiet.cap[0]), NULL))\n\t\tgoto fail;\n\tif (!unpack_u32(e, &tmpcap.cap[0], NULL))\n\t\tgoto fail;\n\n\tinfo = \"failed to unpack upper profile capabilities\";\n\tif (unpack_nameX(e, AA_STRUCT, \"caps64\")) {\n\t\t/* optional upper half of 64 bit caps */\n\t\tif (!unpack_u32(e, &(profile->caps.allow.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(profile->caps.audit.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(profile->caps.quiet.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(tmpcap.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\n\tinfo = \"failed to unpack extended profile capabilities\";\n\tif (unpack_nameX(e, AA_STRUCT, \"capsx\")) {\n\t\t/* optional extended caps mediation mask */\n\t\tif (!unpack_u32(e, &(profile->caps.extended.cap[0]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_u32(e, &(profile->caps.extended.cap[1]), NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\n\tif (!unpack_rlimits(e, profile)) {\n\t\tinfo = \"failed to unpack profile rlimits\";\n\t\tgoto fail;\n\t}\n\n\tif (unpack_nameX(e, AA_STRUCT, \"policydb\")) {\n\t\t/* generic policy dfa - optional and may be NULL */\n\t\tinfo = \"failed to unpack policydb\";\n\t\tprofile->policy.dfa = unpack_dfa(e);\n\t\tif (IS_ERR(profile->policy.dfa)) {\n\t\t\terror = PTR_ERR(profile->policy.dfa);\n\t\t\tprofile->policy.dfa = NULL;\n\t\t\tgoto fail;\n\t\t} else if (!profile->policy.dfa) {\n\t\t\terror = -EPROTO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (!unpack_u32(e, &profile->policy.start[0], \"start\"))\n\t\t\t/* default start state */\n\t\t\tprofile->policy.start[0] = DFA_START;\n\t\t/* setup class index */\n\t\tfor (i = AA_CLASS_FILE; i <= AA_CLASS_LAST; i++) {\n\t\t\tprofile->policy.start[i] =\n\t\t\t\taa_dfa_next(profile->policy.dfa,\n\t\t\t\t\t    profile->policy.start[0],\n\t\t\t\t\t    i);\n\t\t}\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t} else\n\t\tprofile->policy.dfa = aa_get_dfa(nulldfa);\n\n\t/* get file rules */\n\tprofile->file.dfa = unpack_dfa(e);\n\tif (IS_ERR(profile->file.dfa)) {\n\t\terror = PTR_ERR(profile->file.dfa);\n\t\tprofile->file.dfa = NULL;\n\t\tinfo = \"failed to unpack profile file rules\";\n\t\tgoto fail;\n\t} else if (profile->file.dfa) {\n\t\tif (!unpack_u32(e, &profile->file.start, \"dfa_start\"))\n\t\t\t/* default start state */\n\t\t\tprofile->file.start = DFA_START;\n\t} else if (profile->policy.dfa &&\n\t\t   profile->policy.start[AA_CLASS_FILE]) {\n\t\tprofile->file.dfa = aa_get_dfa(profile->policy.dfa);\n\t\tprofile->file.start = profile->policy.start[AA_CLASS_FILE];\n\t} else\n\t\tprofile->file.dfa = aa_get_dfa(nulldfa);\n\n\tif (!unpack_trans_table(e, profile)) {\n\t\tinfo = \"failed to unpack profile transition table\";\n\t\tgoto fail;\n\t}\n\n\tif (unpack_nameX(e, AA_STRUCT, \"data\")) {\n\t\tinfo = \"out of memory\";\n\t\tprofile->data = kzalloc(sizeof(*profile->data), GFP_KERNEL);\n\t\tif (!profile->data)\n\t\t\tgoto fail;\n\n\t\tparams.nelem_hint = 3;\n\t\tparams.key_len = sizeof(void *);\n\t\tparams.key_offset = offsetof(struct aa_data, key);\n\t\tparams.head_offset = offsetof(struct aa_data, head);\n\t\tparams.hashfn = strhash;\n\t\tparams.obj_cmpfn = datacmp;\n\n\t\tif (rhashtable_init(profile->data, &params)) {\n\t\t\tinfo = \"failed to init key, value hash table\";\n\t\t\tgoto fail;\n\t\t}\n\n\t\twhile (unpack_strdup(e, &key, NULL)) {\n\t\t\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\t\t\tif (!data) {\n\t\t\t\tkzfree(key);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tdata->key = key;\n\t\t\tdata->size = unpack_blob(e, &data->data, NULL);\n\t\t\tdata->data = kvmemdup(data->data, data->size);\n\t\t\tif (data->size && !data->data) {\n\t\t\t\tkzfree(data->key);\n\t\t\t\tkzfree(data);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trhashtable_insert_fast(profile->data, &data->head,\n\t\t\t\t\t       profile->data->p);\n\t\t}\n\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL)) {\n\t\t\tinfo = \"failed to unpack end of key, value data table\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!unpack_nameX(e, AA_STRUCTEND, NULL)) {\n\t\tinfo = \"failed to unpack end of profile\";\n\t\tgoto fail;\n\t}\n\n\treturn profile;\n\nfail:\n\tif (profile)\n\t\tname = NULL;\n\telse if (!name)\n\t\tname = \"unknown\";\n\taudit_iface(profile, NULL, name, info, e, error);\n\taa_free_profile(profile);\n\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "datacmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "568-574",
    "snippet": "static int datacmp(struct rhashtable_compare_arg *arg, const void *obj)\n{\n\tconst struct aa_data *data = obj;\n\tconst char * const *key = arg->key;\n\n\treturn strcmp(data->key, *key);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data->key",
            "*key"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic int datacmp(struct rhashtable_compare_arg *arg, const void *obj)\n{\n\tconst struct aa_data *data = obj;\n\tconst char * const *key = arg->key;\n\n\treturn strcmp(data->key, *key);\n}"
  },
  {
    "function_name": "strhash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "561-566",
    "snippet": "static u32 strhash(const void *data, u32 len, u32 seed)\n{\n\tconst char * const *key = data;\n\n\treturn jhash(*key, strlen(*key), seed);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "*key",
            "strlen(*key)",
            "seed"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*key"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic u32 strhash(const void *data, u32 len, u32 seed)\n{\n\tconst char * const *key = data;\n\n\treturn jhash(*key, strlen(*key), seed);\n}"
  },
  {
    "function_name": "kvmemdup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "552-559",
    "snippet": "static void *kvmemdup(const void *src, size_t len)\n{\n\tvoid *p = kvmalloc(len, GFP_KERNEL);\n\n\tif (p)\n\t\tmemcpy(p, src, len);\n\treturn p;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "src",
            "len"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic void *kvmemdup(const void *src, size_t len)\n{\n\tvoid *p = kvmalloc(len, GFP_KERNEL);\n\n\tif (p)\n\t\tmemcpy(p, src, len);\n\treturn p;\n}"
  },
  {
    "function_name": "unpack_rlimits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "518-550",
    "snippet": "static bool unpack_rlimits(struct aa_ext *e, struct aa_profile *profile)\n{\n\tvoid *pos = e->pos;\n\n\t/* rlimits are optional */\n\tif (unpack_nameX(e, AA_STRUCT, \"rlimits\")) {\n\t\tint i, size;\n\t\tu32 tmp = 0;\n\t\tif (!unpack_u32(e, &tmp, NULL))\n\t\t\tgoto fail;\n\t\tprofile->rlimits.mask = tmp;\n\n\t\tsize = unpack_array(e, NULL);\n\t\tif (size > RLIM_NLIMITS)\n\t\t\tgoto fail;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tu64 tmp2 = 0;\n\t\t\tint a = aa_map_resource(i);\n\t\t\tif (!unpack_u64(e, &tmp2, NULL))\n\t\t\t\tgoto fail;\n\t\t\tprofile->rlimits.limits[a].rlim_max = tmp2;\n\t\t}\n\t\tif (!unpack_nameX(e, AA_ARRAYEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpack_nameX",
          "args": [
            "e",
            "AA_STRUCTEND",
            "NULL"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_nameX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "248-276",
          "snippet": "static bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpack_u64",
          "args": [
            "e",
            "&tmp2",
            "NULL"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "291-302",
          "snippet": "static bool unpack_u64(struct aa_ext *e, u64 *data, const char *name)\n{\n\tif (unpack_nameX(e, AA_U64, name)) {\n\t\tif (!inbounds(e, sizeof(u64)))\n\t\t\treturn 0;\n\t\tif (data)\n\t\t\t*data = le64_to_cpu(get_unaligned((__le64 *) e->pos));\n\t\te->pos += sizeof(u64);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_u64(struct aa_ext *e, u64 *data, const char *name)\n{\n\tif (unpack_nameX(e, AA_U64, name)) {\n\t\tif (!inbounds(e, sizeof(u64)))\n\t\t\treturn 0;\n\t\tif (data)\n\t\t\t*data = le64_to_cpu(get_unaligned((__le64 *) e->pos));\n\t\te->pos += sizeof(u64);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_map_resource",
          "args": [
            "i"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "aa_map_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/resource.c",
          "lines": "80-83",
          "snippet": "int aa_map_resource(int resource)\n{\n\treturn rlim_map[resource];\n}",
          "includes": [
            "#include \"rlim_names.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rlim_names.h\"\n#include \"include/policy.h\"\n#include \"include/resource.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include <linux/security.h>\n#include <linux/audit.h>\n\nint aa_map_resource(int resource)\n{\n\treturn rlim_map[resource];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpack_array",
          "args": [
            "e",
            "NULL"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "304-315",
          "snippet": "static size_t unpack_array(struct aa_ext *e, const char *name)\n{\n\tif (unpack_nameX(e, AA_ARRAY, name)) {\n\t\tint size;\n\t\tif (!inbounds(e, sizeof(u16)))\n\t\t\treturn 0;\n\t\tsize = (int)le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\t\te->pos += sizeof(u16);\n\t\treturn size;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic size_t unpack_array(struct aa_ext *e, const char *name)\n{\n\tif (unpack_nameX(e, AA_ARRAY, name)) {\n\t\tint size;\n\t\tif (!inbounds(e, sizeof(u16)))\n\t\t\treturn 0;\n\t\tsize = (int)le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\t\te->pos += sizeof(u16);\n\t\treturn size;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpack_u32",
          "args": [
            "e",
            "&tmp",
            "NULL"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "278-289",
          "snippet": "static bool unpack_u32(struct aa_ext *e, u32 *data, const char *name)\n{\n\tif (unpack_nameX(e, AA_U32, name)) {\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tif (data)\n\t\t\t*data = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_u32(struct aa_ext *e, u32 *data, const char *name)\n{\n\tif (unpack_nameX(e, AA_U32, name)) {\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tif (data)\n\t\t\t*data = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_rlimits(struct aa_ext *e, struct aa_profile *profile)\n{\n\tvoid *pos = e->pos;\n\n\t/* rlimits are optional */\n\tif (unpack_nameX(e, AA_STRUCT, \"rlimits\")) {\n\t\tint i, size;\n\t\tu32 tmp = 0;\n\t\tif (!unpack_u32(e, &tmp, NULL))\n\t\t\tgoto fail;\n\t\tprofile->rlimits.mask = tmp;\n\n\t\tsize = unpack_array(e, NULL);\n\t\tif (size > RLIM_NLIMITS)\n\t\t\tgoto fail;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tu64 tmp2 = 0;\n\t\t\tint a = aa_map_resource(i);\n\t\t\tif (!unpack_u64(e, &tmp2, NULL))\n\t\t\t\tgoto fail;\n\t\t\tprofile->rlimits.limits[a].rlim_max = tmp2;\n\t\t}\n\t\tif (!unpack_nameX(e, AA_ARRAYEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}"
  },
  {
    "function_name": "unpack_trans_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "449-516",
    "snippet": "static bool unpack_trans_table(struct aa_ext *e, struct aa_profile *profile)\n{\n\tvoid *saved_pos = e->pos;\n\n\t/* exec table is optional */\n\tif (unpack_nameX(e, AA_STRUCT, \"xtable\")) {\n\t\tint i, size;\n\n\t\tsize = unpack_array(e, NULL);\n\t\t/* currently 4 exec bits and entries 0-3 are reserved iupcx */\n\t\tif (size > 16 - 4)\n\t\t\tgoto fail;\n\t\tprofile->file.trans.table = kzalloc(sizeof(char *) * size,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!profile->file.trans.table)\n\t\t\tgoto fail;\n\n\t\tprofile->file.trans.size = size;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tchar *str;\n\t\t\tint c, j, pos, size2 = unpack_strdup(e, &str, NULL);\n\t\t\t/* unpack_strdup verifies that the last character is\n\t\t\t * null termination byte.\n\t\t\t */\n\t\t\tif (!size2)\n\t\t\t\tgoto fail;\n\t\t\tprofile->file.trans.table[i] = str;\n\t\t\t/* verify that name doesn't start with space */\n\t\t\tif (isspace(*str))\n\t\t\t\tgoto fail;\n\n\t\t\t/* count internal #  of internal \\0 */\n\t\t\tfor (c = j = 0; j < size2 - 1; j++) {\n\t\t\t\tif (!str[j]) {\n\t\t\t\t\tpos = j;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*str == ':') {\n\t\t\t\t/* first character after : must be valid */\n\t\t\t\tif (!str[1])\n\t\t\t\t\tgoto fail;\n\t\t\t\t/* beginning with : requires an embedded \\0,\n\t\t\t\t * verify that exactly 1 internal \\0 exists\n\t\t\t\t * trailing \\0 already verified by unpack_strdup\n\t\t\t\t *\n\t\t\t\t * convert \\0 back to : for label_parse\n\t\t\t\t */\n\t\t\t\tif (c == 1)\n\t\t\t\t\tstr[pos] = ':';\n\t\t\t\telse if (c > 1)\n\t\t\t\t\tgoto fail;\n\t\t\t} else if (c)\n\t\t\t\t/* fail - all other cases with embedded \\0 */\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (!unpack_nameX(e, AA_ARRAYEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\treturn 1;\n\nfail:\n\taa_free_domain_entries(&profile->file.trans);\n\te->pos = saved_pos;\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_free_domain_entries",
          "args": [
            "&profile->file.trans"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "aa_free_domain_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "38-50",
          "snippet": "void aa_free_domain_entries(struct aa_domain *domain)\n{\n\tint i;\n\tif (domain) {\n\t\tif (!domain->table)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < domain->size; i++)\n\t\t\tkzfree(domain->table[i]);\n\t\tkzfree(domain->table);\n\t\tdomain->table = NULL;\n\t}\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nvoid aa_free_domain_entries(struct aa_domain *domain)\n{\n\tint i;\n\tif (domain) {\n\t\tif (!domain->table)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < domain->size; i++)\n\t\t\tkzfree(domain->table[i]);\n\t\tkzfree(domain->table);\n\t\tdomain->table = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpack_nameX",
          "args": [
            "e",
            "AA_STRUCTEND",
            "NULL"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_nameX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "248-276",
          "snippet": "static bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*str"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_strdup",
          "args": [
            "e",
            "&str",
            "NULL"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "356-373",
          "snippet": "static int unpack_strdup(struct aa_ext *e, char **string, const char *name)\n{\n\tconst char *tmp;\n\tvoid *pos = e->pos;\n\tint res = unpack_str(e, &tmp, name);\n\t*string = NULL;\n\n\tif (!res)\n\t\treturn 0;\n\n\t*string = kmemdup(tmp, res, GFP_KERNEL);\n\tif (!*string) {\n\t\te->pos = pos;\n\t\treturn 0;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic int unpack_strdup(struct aa_ext *e, char **string, const char *name)\n{\n\tconst char *tmp;\n\tvoid *pos = e->pos;\n\tint res = unpack_str(e, &tmp, name);\n\t*string = NULL;\n\n\tif (!res)\n\t\treturn 0;\n\n\t*string = kmemdup(tmp, res, GFP_KERNEL);\n\tif (!*string) {\n\t\te->pos = pos;\n\t\treturn 0;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(char *) * size",
            "GFP_KERNEL"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_array",
          "args": [
            "e",
            "NULL"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "304-315",
          "snippet": "static size_t unpack_array(struct aa_ext *e, const char *name)\n{\n\tif (unpack_nameX(e, AA_ARRAY, name)) {\n\t\tint size;\n\t\tif (!inbounds(e, sizeof(u16)))\n\t\t\treturn 0;\n\t\tsize = (int)le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\t\te->pos += sizeof(u16);\n\t\treturn size;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic size_t unpack_array(struct aa_ext *e, const char *name)\n{\n\tif (unpack_nameX(e, AA_ARRAY, name)) {\n\t\tint size;\n\t\tif (!inbounds(e, sizeof(u16)))\n\t\t\treturn 0;\n\t\tsize = (int)le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\t\te->pos += sizeof(u16);\n\t\treturn size;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_trans_table(struct aa_ext *e, struct aa_profile *profile)\n{\n\tvoid *saved_pos = e->pos;\n\n\t/* exec table is optional */\n\tif (unpack_nameX(e, AA_STRUCT, \"xtable\")) {\n\t\tint i, size;\n\n\t\tsize = unpack_array(e, NULL);\n\t\t/* currently 4 exec bits and entries 0-3 are reserved iupcx */\n\t\tif (size > 16 - 4)\n\t\t\tgoto fail;\n\t\tprofile->file.trans.table = kzalloc(sizeof(char *) * size,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!profile->file.trans.table)\n\t\t\tgoto fail;\n\n\t\tprofile->file.trans.size = size;\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tchar *str;\n\t\t\tint c, j, pos, size2 = unpack_strdup(e, &str, NULL);\n\t\t\t/* unpack_strdup verifies that the last character is\n\t\t\t * null termination byte.\n\t\t\t */\n\t\t\tif (!size2)\n\t\t\t\tgoto fail;\n\t\t\tprofile->file.trans.table[i] = str;\n\t\t\t/* verify that name doesn't start with space */\n\t\t\tif (isspace(*str))\n\t\t\t\tgoto fail;\n\n\t\t\t/* count internal #  of internal \\0 */\n\t\t\tfor (c = j = 0; j < size2 - 1; j++) {\n\t\t\t\tif (!str[j]) {\n\t\t\t\t\tpos = j;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*str == ':') {\n\t\t\t\t/* first character after : must be valid */\n\t\t\t\tif (!str[1])\n\t\t\t\t\tgoto fail;\n\t\t\t\t/* beginning with : requires an embedded \\0,\n\t\t\t\t * verify that exactly 1 internal \\0 exists\n\t\t\t\t * trailing \\0 already verified by unpack_strdup\n\t\t\t\t *\n\t\t\t\t * convert \\0 back to : for label_parse\n\t\t\t\t */\n\t\t\t\tif (c == 1)\n\t\t\t\t\tstr[pos] = ':';\n\t\t\t\telse if (c > 1)\n\t\t\t\t\tgoto fail;\n\t\t\t} else if (c)\n\t\t\t\t/* fail - all other cases with embedded \\0 */\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (!unpack_nameX(e, AA_ARRAYEND, NULL))\n\t\t\tgoto fail;\n\t\tif (!unpack_nameX(e, AA_STRUCTEND, NULL))\n\t\t\tgoto fail;\n\t}\n\treturn 1;\n\nfail:\n\taa_free_domain_entries(&profile->file.trans);\n\te->pos = saved_pos;\n\treturn 0;\n}"
  },
  {
    "function_name": "unpack_dfa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "408-440",
    "snippet": "static struct aa_dfa *unpack_dfa(struct aa_ext *e)\n{\n\tchar *blob = NULL;\n\tsize_t size;\n\tstruct aa_dfa *dfa = NULL;\n\n\tsize = unpack_blob(e, &blob, \"aadfa\");\n\tif (size) {\n\t\t/*\n\t\t * The dfa is aligned with in the blob to 8 bytes\n\t\t * from the beginning of the stream.\n\t\t * alignment adjust needed by dfa unpack\n\t\t */\n\t\tsize_t sz = blob - (char *) e->start -\n\t\t\t((e->pos - e->start) & 7);\n\t\tsize_t pad = ALIGN(sz, 8) - sz;\n\t\tint flags = TO_ACCEPT1_FLAG(YYTD_DATA32) |\n\t\t\tTO_ACCEPT2_FLAG(YYTD_DATA32) | DFA_FLAG_VERIFY_STATES;\n\t\tdfa = aa_dfa_unpack(blob + pad, size - pad, flags);\n\n\t\tif (IS_ERR(dfa))\n\t\t\treturn dfa;\n\n\t\tif (!verify_accept(dfa, flags))\n\t\t\tgoto fail;\n\t}\n\n\treturn dfa;\n\nfail:\n\taa_put_dfa(dfa);\n\treturn ERR_PTR(-EPROTO);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPROTO"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_dfa",
          "args": [
            "dfa"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_dfa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/match.h",
          "lines": "156-160",
          "snippet": "static inline void aa_put_dfa(struct aa_dfa *dfa)\n{\n\tif (dfa)\n\t\tkref_put(&dfa->count, aa_dfa_free_kref);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void aa_put_dfa(struct aa_dfa *dfa)\n{\n\tif (dfa)\n\t\tkref_put(&dfa->count, aa_dfa_free_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_accept",
          "args": [
            "dfa",
            "flags"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "verify_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "385-400",
          "snippet": "static bool verify_accept(struct aa_dfa *dfa, int flags)\n{\n\tint i;\n\n\t/* verify accept permissions */\n\tfor (i = 0; i < dfa->tables[YYTD_ID_ACCEPT]->td_lolen; i++) {\n\t\tint mode = ACCEPT_TABLE(dfa)[i];\n\n\t\tif (mode & ~DFA_VALID_PERM_MASK)\n\t\t\treturn 0;\n\n\t\tif (ACCEPT_TABLE2(dfa)[i] & ~DFA_VALID_PERM2_MASK)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [
            "#define DFA_VALID_PERM2_MASK\t\t0xffffffff",
            "#define DFA_VALID_PERM_MASK\t\t0xffffffff"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\n#define DFA_VALID_PERM2_MASK\t\t0xffffffff\n#define DFA_VALID_PERM_MASK\t\t0xffffffff\n\nstatic bool verify_accept(struct aa_dfa *dfa, int flags)\n{\n\tint i;\n\n\t/* verify accept permissions */\n\tfor (i = 0; i < dfa->tables[YYTD_ID_ACCEPT]->td_lolen; i++) {\n\t\tint mode = ACCEPT_TABLE(dfa)[i];\n\n\t\tif (mode & ~DFA_VALID_PERM_MASK)\n\t\t\treturn 0;\n\n\t\tif (ACCEPT_TABLE2(dfa)[i] & ~DFA_VALID_PERM2_MASK)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dfa"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_dfa_unpack",
          "args": [
            "blob + pad",
            "size - pad",
            "flags"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_unpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "234-313",
          "snippet": "struct aa_dfa *aa_dfa_unpack(void *blob, size_t size, int flags)\n{\n\tint hsize;\n\tint error = -ENOMEM;\n\tchar *data = blob;\n\tstruct table_header *table = NULL;\n\tstruct aa_dfa *dfa = kzalloc(sizeof(struct aa_dfa), GFP_KERNEL);\n\tif (!dfa)\n\t\tgoto fail;\n\n\tkref_init(&dfa->count);\n\n\terror = -EPROTO;\n\n\t/* get dfa table set header */\n\tif (size < sizeof(struct table_set_header))\n\t\tgoto fail;\n\n\tif (ntohl(*(__be32 *) data) != YYTH_MAGIC)\n\t\tgoto fail;\n\n\thsize = ntohl(*(__be32 *) (data + 4));\n\tif (size < hsize)\n\t\tgoto fail;\n\n\tdfa->flags = ntohs(*(__be16 *) (data + 12));\n\tdata += hsize;\n\tsize -= hsize;\n\n\twhile (size > 0) {\n\t\ttable = unpack_table(data, size);\n\t\tif (!table)\n\t\t\tgoto fail;\n\n\t\tswitch (table->td_id) {\n\t\tcase YYTD_ID_ACCEPT:\n\t\t\tif (!(table->td_flags & ACCEPT1_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_ACCEPT2:\n\t\t\tif (!(table->td_flags & ACCEPT2_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_BASE:\n\t\t\tif (table->td_flags != YYTD_DATA32)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_DEF:\n\t\tcase YYTD_ID_NXT:\n\t\tcase YYTD_ID_CHK:\n\t\t\tif (table->td_flags != YYTD_DATA16)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_EC:\n\t\t\tif (table->td_flags != YYTD_DATA8)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t\t/* check for duplicate table entry */\n\t\tif (dfa->tables[table->td_id])\n\t\t\tgoto fail;\n\t\tdfa->tables[table->td_id] = table;\n\t\tdata += table_size(table->td_lolen, table->td_flags);\n\t\tsize -= table_size(table->td_lolen, table->td_flags);\n\t\ttable = NULL;\n\t}\n\n\terror = verify_dfa(dfa, flags);\n\tif (error)\n\t\tgoto fail;\n\n\treturn dfa;\n\nfail:\n\tkvfree(table);\n\tdfa_free(dfa);\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstruct aa_dfa *aa_dfa_unpack(void *blob, size_t size, int flags)\n{\n\tint hsize;\n\tint error = -ENOMEM;\n\tchar *data = blob;\n\tstruct table_header *table = NULL;\n\tstruct aa_dfa *dfa = kzalloc(sizeof(struct aa_dfa), GFP_KERNEL);\n\tif (!dfa)\n\t\tgoto fail;\n\n\tkref_init(&dfa->count);\n\n\terror = -EPROTO;\n\n\t/* get dfa table set header */\n\tif (size < sizeof(struct table_set_header))\n\t\tgoto fail;\n\n\tif (ntohl(*(__be32 *) data) != YYTH_MAGIC)\n\t\tgoto fail;\n\n\thsize = ntohl(*(__be32 *) (data + 4));\n\tif (size < hsize)\n\t\tgoto fail;\n\n\tdfa->flags = ntohs(*(__be16 *) (data + 12));\n\tdata += hsize;\n\tsize -= hsize;\n\n\twhile (size > 0) {\n\t\ttable = unpack_table(data, size);\n\t\tif (!table)\n\t\t\tgoto fail;\n\n\t\tswitch (table->td_id) {\n\t\tcase YYTD_ID_ACCEPT:\n\t\t\tif (!(table->td_flags & ACCEPT1_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_ACCEPT2:\n\t\t\tif (!(table->td_flags & ACCEPT2_FLAGS(flags)))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_BASE:\n\t\t\tif (table->td_flags != YYTD_DATA32)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_DEF:\n\t\tcase YYTD_ID_NXT:\n\t\tcase YYTD_ID_CHK:\n\t\t\tif (table->td_flags != YYTD_DATA16)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase YYTD_ID_EC:\n\t\t\tif (table->td_flags != YYTD_DATA8)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t\t/* check for duplicate table entry */\n\t\tif (dfa->tables[table->td_id])\n\t\t\tgoto fail;\n\t\tdfa->tables[table->td_id] = table;\n\t\tdata += table_size(table->td_lolen, table->td_flags);\n\t\tsize -= table_size(table->td_lolen, table->td_flags);\n\t\ttable = NULL;\n\t}\n\n\terror = verify_dfa(dfa, flags);\n\tif (error)\n\t\tgoto fail;\n\n\treturn dfa;\n\nfail:\n\tkvfree(table);\n\tdfa_free(dfa);\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TO_ACCEPT2_FLAG",
          "args": [
            "YYTD_DATA32"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TO_ACCEPT1_FLAG",
          "args": [
            "YYTD_DATA32"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "sz",
            "8"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_blob",
          "args": [
            "e",
            "&blob",
            "\"aadfa\""
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "317-332",
          "snippet": "static size_t unpack_blob(struct aa_ext *e, char **blob, const char *name)\n{\n\tif (unpack_nameX(e, AA_BLOB, name)) {\n\t\tu32 size;\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tsize = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\tif (inbounds(e, (size_t) size)) {\n\t\t\t*blob = e->pos;\n\t\t\te->pos += size;\n\t\t\treturn size;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic size_t unpack_blob(struct aa_ext *e, char **blob, const char *name)\n{\n\tif (unpack_nameX(e, AA_BLOB, name)) {\n\t\tu32 size;\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tsize = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\tif (inbounds(e, (size_t) size)) {\n\t\t\t*blob = e->pos;\n\t\t\te->pos += size;\n\t\t\treturn size;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic struct aa_dfa *unpack_dfa(struct aa_ext *e)\n{\n\tchar *blob = NULL;\n\tsize_t size;\n\tstruct aa_dfa *dfa = NULL;\n\n\tsize = unpack_blob(e, &blob, \"aadfa\");\n\tif (size) {\n\t\t/*\n\t\t * The dfa is aligned with in the blob to 8 bytes\n\t\t * from the beginning of the stream.\n\t\t * alignment adjust needed by dfa unpack\n\t\t */\n\t\tsize_t sz = blob - (char *) e->start -\n\t\t\t((e->pos - e->start) & 7);\n\t\tsize_t pad = ALIGN(sz, 8) - sz;\n\t\tint flags = TO_ACCEPT1_FLAG(YYTD_DATA32) |\n\t\t\tTO_ACCEPT2_FLAG(YYTD_DATA32) | DFA_FLAG_VERIFY_STATES;\n\t\tdfa = aa_dfa_unpack(blob + pad, size - pad, flags);\n\n\t\tif (IS_ERR(dfa))\n\t\t\treturn dfa;\n\n\t\tif (!verify_accept(dfa, flags))\n\t\t\tgoto fail;\n\t}\n\n\treturn dfa;\n\nfail:\n\taa_put_dfa(dfa);\n\treturn ERR_PTR(-EPROTO);\n}"
  },
  {
    "function_name": "verify_accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "385-400",
    "snippet": "static bool verify_accept(struct aa_dfa *dfa, int flags)\n{\n\tint i;\n\n\t/* verify accept permissions */\n\tfor (i = 0; i < dfa->tables[YYTD_ID_ACCEPT]->td_lolen; i++) {\n\t\tint mode = ACCEPT_TABLE(dfa)[i];\n\n\t\tif (mode & ~DFA_VALID_PERM_MASK)\n\t\t\treturn 0;\n\n\t\tif (ACCEPT_TABLE2(dfa)[i] & ~DFA_VALID_PERM2_MASK)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [
      "#define DFA_VALID_PERM2_MASK\t\t0xffffffff",
      "#define DFA_VALID_PERM_MASK\t\t0xffffffff"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACCEPT_TABLE2",
          "args": [
            "dfa"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCEPT_TABLE",
          "args": [
            "dfa"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\n#define DFA_VALID_PERM2_MASK\t\t0xffffffff\n#define DFA_VALID_PERM_MASK\t\t0xffffffff\n\nstatic bool verify_accept(struct aa_dfa *dfa, int flags)\n{\n\tint i;\n\n\t/* verify accept permissions */\n\tfor (i = 0; i < dfa->tables[YYTD_ID_ACCEPT]->td_lolen; i++) {\n\t\tint mode = ACCEPT_TABLE(dfa)[i];\n\n\t\tif (mode & ~DFA_VALID_PERM_MASK)\n\t\t\treturn 0;\n\n\t\tif (ACCEPT_TABLE2(dfa)[i] & ~DFA_VALID_PERM2_MASK)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "unpack_strdup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "356-373",
    "snippet": "static int unpack_strdup(struct aa_ext *e, char **string, const char *name)\n{\n\tconst char *tmp;\n\tvoid *pos = e->pos;\n\tint res = unpack_str(e, &tmp, name);\n\t*string = NULL;\n\n\tif (!res)\n\t\treturn 0;\n\n\t*string = kmemdup(tmp, res, GFP_KERNEL);\n\tif (!*string) {\n\t\te->pos = pos;\n\t\treturn 0;\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "tmp",
            "res",
            "GFP_KERNEL"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_str",
          "args": [
            "e",
            "&tmp",
            "name"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "356-373",
          "snippet": "static int unpack_strdup(struct aa_ext *e, char **string, const char *name)\n{\n\tconst char *tmp;\n\tvoid *pos = e->pos;\n\tint res = unpack_str(e, &tmp, name);\n\t*string = NULL;\n\n\tif (!res)\n\t\treturn 0;\n\n\t*string = kmemdup(tmp, res, GFP_KERNEL);\n\tif (!*string) {\n\t\te->pos = pos;\n\t\treturn 0;\n\t}\n\n\treturn res;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic int unpack_strdup(struct aa_ext *e, char **string, const char *name)\n{\n\tconst char *tmp;\n\tvoid *pos = e->pos;\n\tint res = unpack_str(e, &tmp, name);\n\t*string = NULL;\n\n\tif (!res)\n\t\treturn 0;\n\n\t*string = kmemdup(tmp, res, GFP_KERNEL);\n\tif (!*string) {\n\t\te->pos = pos;\n\t\treturn 0;\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "unpack_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "334-354",
    "snippet": "static int unpack_str(struct aa_ext *e, const char **string, const char *name)\n{\n\tchar *src_str;\n\tsize_t size = 0;\n\tvoid *pos = e->pos;\n\t*string = NULL;\n\tif (unpack_nameX(e, AA_STRING, name)) {\n\t\tsize = unpack_u16_chunk(e, &src_str);\n\t\tif (size) {\n\t\t\t/* strings are null terminated, length is size - 1 */\n\t\t\tif (src_str[size - 1] != 0)\n\t\t\t\tgoto fail;\n\t\t\t*string = src_str;\n\t\t}\n\t}\n\treturn size;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpack_u16_chunk",
          "args": [
            "e",
            "&src_str"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_u16_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "206-219",
          "snippet": "static size_t unpack_u16_chunk(struct aa_ext *e, char **chunk)\n{\n\tsize_t size = 0;\n\n\tif (!inbounds(e, sizeof(u16)))\n\t\treturn 0;\n\tsize = le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\te->pos += sizeof(__le16);\n\tif (!inbounds(e, size))\n\t\treturn 0;\n\t*chunk = e->pos;\n\te->pos += size;\n\treturn size;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic size_t unpack_u16_chunk(struct aa_ext *e, char **chunk)\n{\n\tsize_t size = 0;\n\n\tif (!inbounds(e, sizeof(u16)))\n\t\treturn 0;\n\tsize = le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\te->pos += sizeof(__le16);\n\tif (!inbounds(e, size))\n\t\treturn 0;\n\t*chunk = e->pos;\n\te->pos += size;\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpack_nameX",
          "args": [
            "e",
            "AA_STRING",
            "name"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_nameX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "248-276",
          "snippet": "static bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic int unpack_str(struct aa_ext *e, const char **string, const char *name)\n{\n\tchar *src_str;\n\tsize_t size = 0;\n\tvoid *pos = e->pos;\n\t*string = NULL;\n\tif (unpack_nameX(e, AA_STRING, name)) {\n\t\tsize = unpack_u16_chunk(e, &src_str);\n\t\tif (size) {\n\t\t\t/* strings are null terminated, length is size - 1 */\n\t\t\tif (src_str[size - 1] != 0)\n\t\t\t\tgoto fail;\n\t\t\t*string = src_str;\n\t\t}\n\t}\n\treturn size;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}"
  },
  {
    "function_name": "unpack_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "317-332",
    "snippet": "static size_t unpack_blob(struct aa_ext *e, char **blob, const char *name)\n{\n\tif (unpack_nameX(e, AA_BLOB, name)) {\n\t\tu32 size;\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tsize = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\tif (inbounds(e, (size_t) size)) {\n\t\t\t*blob = e->pos;\n\t\t\te->pos += size;\n\t\t\treturn size;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inbounds",
          "args": [
            "e",
            "(size_t) size"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "inbounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "194-197",
          "snippet": "static bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "get_unaligned((__le32 *) e->pos)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned",
          "args": [
            "(__le32 *) e->pos"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_nameX",
          "args": [
            "e",
            "AA_BLOB",
            "name"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_nameX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "248-276",
          "snippet": "static bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic size_t unpack_blob(struct aa_ext *e, char **blob, const char *name)\n{\n\tif (unpack_nameX(e, AA_BLOB, name)) {\n\t\tu32 size;\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tsize = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\tif (inbounds(e, (size_t) size)) {\n\t\t\t*blob = e->pos;\n\t\t\te->pos += size;\n\t\t\treturn size;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "unpack_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "304-315",
    "snippet": "static size_t unpack_array(struct aa_ext *e, const char *name)\n{\n\tif (unpack_nameX(e, AA_ARRAY, name)) {\n\t\tint size;\n\t\tif (!inbounds(e, sizeof(u16)))\n\t\t\treturn 0;\n\t\tsize = (int)le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\t\te->pos += sizeof(u16);\n\t\treturn size;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "get_unaligned((__le16 *) e->pos)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned",
          "args": [
            "(__le16 *) e->pos"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inbounds",
          "args": [
            "e",
            "sizeof(u16)"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "inbounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "194-197",
          "snippet": "static bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpack_nameX",
          "args": [
            "e",
            "AA_ARRAY",
            "name"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_nameX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "248-276",
          "snippet": "static bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic size_t unpack_array(struct aa_ext *e, const char *name)\n{\n\tif (unpack_nameX(e, AA_ARRAY, name)) {\n\t\tint size;\n\t\tif (!inbounds(e, sizeof(u16)))\n\t\t\treturn 0;\n\t\tsize = (int)le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\t\te->pos += sizeof(u16);\n\t\treturn size;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "unpack_u64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "291-302",
    "snippet": "static bool unpack_u64(struct aa_ext *e, u64 *data, const char *name)\n{\n\tif (unpack_nameX(e, AA_U64, name)) {\n\t\tif (!inbounds(e, sizeof(u64)))\n\t\t\treturn 0;\n\t\tif (data)\n\t\t\t*data = le64_to_cpu(get_unaligned((__le64 *) e->pos));\n\t\te->pos += sizeof(u64);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "get_unaligned((__le64 *) e->pos)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned",
          "args": [
            "(__le64 *) e->pos"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inbounds",
          "args": [
            "e",
            "sizeof(u64)"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "inbounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "194-197",
          "snippet": "static bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpack_nameX",
          "args": [
            "e",
            "AA_U64",
            "name"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_nameX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "248-276",
          "snippet": "static bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_u64(struct aa_ext *e, u64 *data, const char *name)\n{\n\tif (unpack_nameX(e, AA_U64, name)) {\n\t\tif (!inbounds(e, sizeof(u64)))\n\t\t\treturn 0;\n\t\tif (data)\n\t\t\t*data = le64_to_cpu(get_unaligned((__le64 *) e->pos));\n\t\te->pos += sizeof(u64);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "unpack_u32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "278-289",
    "snippet": "static bool unpack_u32(struct aa_ext *e, u32 *data, const char *name)\n{\n\tif (unpack_nameX(e, AA_U32, name)) {\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tif (data)\n\t\t\t*data = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "get_unaligned((__le32 *) e->pos)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned",
          "args": [
            "(__le32 *) e->pos"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inbounds",
          "args": [
            "e",
            "sizeof(u32)"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "inbounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "194-197",
          "snippet": "static bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpack_nameX",
          "args": [
            "e",
            "AA_U32",
            "name"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_nameX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "248-276",
          "snippet": "static bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_u32(struct aa_ext *e, u32 *data, const char *name)\n{\n\tif (unpack_nameX(e, AA_U32, name)) {\n\t\tif (!inbounds(e, sizeof(u32)))\n\t\t\treturn 0;\n\t\tif (data)\n\t\t\t*data = le32_to_cpu(get_unaligned((__le32 *) e->pos));\n\t\te->pos += sizeof(u32);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "unpack_nameX",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "248-276",
    "snippet": "static bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpack_X",
          "args": [
            "e",
            "code"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_X",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "222-230",
          "snippet": "static bool unpack_X(struct aa_ext *e, enum aa_code code)\n{\n\tif (!inbounds(e, 1))\n\t\treturn 0;\n\tif (*(u8 *) e->pos != code)\n\t\treturn 0;\n\te->pos++;\n\treturn 1;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_X(struct aa_ext *e, enum aa_code code)\n{\n\tif (!inbounds(e, 1))\n\t\treturn 0;\n\tif (*(u8 *) e->pos != code)\n\t\treturn 0;\n\te->pos++;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "tag"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_u16_chunk",
          "args": [
            "e",
            "&tag"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_u16_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "206-219",
          "snippet": "static size_t unpack_u16_chunk(struct aa_ext *e, char **chunk)\n{\n\tsize_t size = 0;\n\n\tif (!inbounds(e, sizeof(u16)))\n\t\treturn 0;\n\tsize = le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\te->pos += sizeof(__le16);\n\tif (!inbounds(e, size))\n\t\treturn 0;\n\t*chunk = e->pos;\n\te->pos += size;\n\treturn size;\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic size_t unpack_u16_chunk(struct aa_ext *e, char **chunk)\n{\n\tsize_t size = 0;\n\n\tif (!inbounds(e, sizeof(u16)))\n\t\treturn 0;\n\tsize = le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\te->pos += sizeof(__le16);\n\tif (!inbounds(e, size))\n\t\treturn 0;\n\t*chunk = e->pos;\n\te->pos += size;\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_nameX(struct aa_ext *e, enum aa_code code, const char *name)\n{\n\t/*\n\t * May need to reset pos if name or type doesn't match\n\t */\n\tvoid *pos = e->pos;\n\t/*\n\t * Check for presence of a tagname, and if present name size\n\t * AA_NAME tag value is a u16.\n\t */\n\tif (unpack_X(e, AA_NAME)) {\n\t\tchar *tag = NULL;\n\t\tsize_t size = unpack_u16_chunk(e, &tag);\n\t\t/* if a name is specified it must match. otherwise skip tag */\n\t\tif (name && (!size || strcmp(name, tag)))\n\t\t\tgoto fail;\n\t} else if (name) {\n\t\t/* if a name is specified and there is no name tag fail */\n\t\tgoto fail;\n\t}\n\n\t/* now check if type code matches */\n\tif (unpack_X(e, code))\n\t\treturn 1;\n\nfail:\n\te->pos = pos;\n\treturn 0;\n}"
  },
  {
    "function_name": "unpack_X",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "222-230",
    "snippet": "static bool unpack_X(struct aa_ext *e, enum aa_code code)\n{\n\tif (!inbounds(e, 1))\n\t\treturn 0;\n\tif (*(u8 *) e->pos != code)\n\t\treturn 0;\n\te->pos++;\n\treturn 1;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inbounds",
          "args": [
            "e",
            "1"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "inbounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "194-197",
          "snippet": "static bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool unpack_X(struct aa_ext *e, enum aa_code code)\n{\n\tif (!inbounds(e, 1))\n\t\treturn 0;\n\tif (*(u8 *) e->pos != code)\n\t\treturn 0;\n\te->pos++;\n\treturn 1;\n}"
  },
  {
    "function_name": "unpack_u16_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "206-219",
    "snippet": "static size_t unpack_u16_chunk(struct aa_ext *e, char **chunk)\n{\n\tsize_t size = 0;\n\n\tif (!inbounds(e, sizeof(u16)))\n\t\treturn 0;\n\tsize = le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\te->pos += sizeof(__le16);\n\tif (!inbounds(e, size))\n\t\treturn 0;\n\t*chunk = e->pos;\n\te->pos += size;\n\treturn size;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inbounds",
          "args": [
            "e",
            "size"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "inbounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
          "lines": "194-197",
          "snippet": "static bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <asm/unaligned.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "get_unaligned((__le16 *) e->pos)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned",
          "args": [
            "(__le16 *) e->pos"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic size_t unpack_u16_chunk(struct aa_ext *e, char **chunk)\n{\n\tsize_t size = 0;\n\n\tif (!inbounds(e, sizeof(u16)))\n\t\treturn 0;\n\tsize = le16_to_cpu(get_unaligned((__le16 *) e->pos));\n\te->pos += sizeof(__le16);\n\tif (!inbounds(e, size))\n\t\treturn 0;\n\t*chunk = e->pos;\n\te->pos += size;\n\treturn size;\n}"
  },
  {
    "function_name": "inbounds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "194-197",
    "snippet": "static bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic bool inbounds(struct aa_ext *e, size_t size)\n{\n\treturn (size <= e->end - e->pos);\n}"
  },
  {
    "function_name": "aa_loaddata_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "181-191",
    "snippet": "struct aa_loaddata *aa_loaddata_alloc(size_t size)\n{\n\tstruct aa_loaddata *d = kvzalloc(sizeof(*d) + size, GFP_KERNEL);\n\n\tif (d == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkref_init(&d->count);\n\tINIT_LIST_HEAD(&d->list);\n\n\treturn d;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&d->list"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&d->count"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvzalloc",
          "args": [
            "sizeof(*d) + size",
            "GFP_KERNEL"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstruct aa_loaddata *aa_loaddata_alloc(size_t size)\n{\n\tstruct aa_loaddata *d = kvzalloc(sizeof(*d) + size, GFP_KERNEL);\n\n\tif (d == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkref_init(&d->count);\n\tINIT_LIST_HEAD(&d->list);\n\n\treturn d;\n}"
  },
  {
    "function_name": "aa_loaddata_kref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "171-179",
    "snippet": "void aa_loaddata_kref(struct kref *kref)\n{\n\tstruct aa_loaddata *d = container_of(kref, struct aa_loaddata, count);\n\n\tif (d) {\n\t\tINIT_WORK(&d->work, do_loaddata_free);\n\t\tschedule_work(&d->work);\n\t}\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&d->work"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&d->work",
            "do_loaddata_free"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structaa_loaddata",
            "count"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nvoid aa_loaddata_kref(struct kref *kref)\n{\n\tstruct aa_loaddata *d = container_of(kref, struct aa_loaddata, count);\n\n\tif (d) {\n\t\tINIT_WORK(&d->work, do_loaddata_free);\n\t\tschedule_work(&d->work);\n\t}\n}"
  },
  {
    "function_name": "do_loaddata_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "154-169",
    "snippet": "static void do_loaddata_free(struct work_struct *work)\n{\n\tstruct aa_loaddata *d = container_of(work, struct aa_loaddata, work);\n\tstruct aa_ns *ns = aa_get_ns(d->ns);\n\n\tif (ns) {\n\t\tmutex_lock_nested(&ns->lock, ns->level);\n\t\t__aa_fs_remove_rawdata(d);\n\t\tmutex_unlock(&ns->lock);\n\t\taa_put_ns(ns);\n\t}\n\n\tkzfree(d->hash);\n\tkfree(d->name);\n\tkvfree(d);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "d"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "d->name"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "d->hash"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "ns"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ns->lock"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aa_fs_remove_rawdata",
          "args": [
            "d"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_fs_remove_rawdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1336-1346",
          "snippet": "void __aa_fs_remove_rawdata(struct aa_loaddata *rawdata)\n{\n\tAA_BUG(rawdata->ns && !mutex_is_locked(&rawdata->ns->lock));\n\n\tif (rawdata->ns) {\n\t\tremove_rawdata_dents(rawdata);\n\t\tlist_del_init(&rawdata->list);\n\t\taa_put_ns(rawdata->ns);\n\t\trawdata->ns = NULL;\n\t}\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nvoid __aa_fs_remove_rawdata(struct aa_loaddata *rawdata)\n{\n\tAA_BUG(rawdata->ns && !mutex_is_locked(&rawdata->ns->lock));\n\n\tif (rawdata->ns) {\n\t\tremove_rawdata_dents(rawdata);\n\t\tlist_del_init(&rawdata->list);\n\t\taa_put_ns(rawdata->ns);\n\t\trawdata->ns = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&ns->lock",
            "ns->level"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_ns",
          "args": [
            "d->ns"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "116-122",
          "snippet": "static inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline struct aa_ns *aa_get_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_get_profile(ns->unconfined);\n\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structaa_loaddata",
            "work"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic void do_loaddata_free(struct work_struct *work)\n{\n\tstruct aa_loaddata *d = container_of(work, struct aa_loaddata, work);\n\tstruct aa_ns *ns = aa_get_ns(d->ns);\n\n\tif (ns) {\n\t\tmutex_lock_nested(&ns->lock, ns->level);\n\t\t__aa_fs_remove_rawdata(d);\n\t\tmutex_unlock(&ns->lock);\n\t\taa_put_ns(ns);\n\t}\n\n\tkzfree(d->hash);\n\tkfree(d->name);\n\tkvfree(d);\n}"
  },
  {
    "function_name": "aa_rawdata_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "141-148",
    "snippet": "bool aa_rawdata_eq(struct aa_loaddata *l, struct aa_loaddata *r)\n{\n\tif (l->size != r->size)\n\t\treturn false;\n\tif (aa_g_hash_policy && memcmp(l->hash, r->hash, aa_hash_size()) != 0)\n\t\treturn false;\n\treturn memcmp(l->data, r->data, r->size) == 0;\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "l->data",
            "r->data",
            "r->size"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "l->hash",
            "r->hash",
            "aa_hash_size()"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_hash_size",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "aa_hash_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/crypto.c",
          "lines": "27-30",
          "snippet": "unsigned int aa_hash_size(void)\n{\n\treturn apparmor_hash_size;\n}",
          "includes": [
            "#include \"include/crypto.h\"",
            "#include \"include/apparmor.h\"",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int apparmor_hash_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/crypto.h\"\n#include \"include/apparmor.h\"\n#include <crypto/hash.h>\n\nstatic unsigned int apparmor_hash_size;\n\nunsigned int aa_hash_size(void)\n{\n\treturn apparmor_hash_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nbool aa_rawdata_eq(struct aa_loaddata *l, struct aa_loaddata *r)\n{\n\tif (l->size != r->size)\n\t\treturn false;\n\tif (aa_g_hash_policy && memcmp(l->hash, r->hash, aa_hash_size()) != 0)\n\t\treturn false;\n\treturn memcmp(l->data, r->data, r->size) == 0;\n}"
  },
  {
    "function_name": "__aa_loaddata_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "126-139",
    "snippet": "void __aa_loaddata_update(struct aa_loaddata *data, long revision)\n{\n\tAA_BUG(!data);\n\tAA_BUG(!data->ns);\n\tAA_BUG(!data->dents[AAFS_LOADDATA_REVISION]);\n\tAA_BUG(!mutex_is_locked(&data->ns->lock));\n\tAA_BUG(data->revision > revision);\n\n\tdata->revision = revision;\n\td_inode(data->dents[AAFS_LOADDATA_DIR])->i_mtime =\n\t\tcurrent_time(d_inode(data->dents[AAFS_LOADDATA_DIR]));\n\td_inode(data->dents[AAFS_LOADDATA_REVISION])->i_mtime =\n\t\tcurrent_time(d_inode(data->dents[AAFS_LOADDATA_REVISION]));\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "d_inode(data->dents[AAFS_LOADDATA_REVISION])"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "data->dents[AAFS_LOADDATA_REVISION]"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "data->dents[AAFS_LOADDATA_REVISION]"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "d_inode(data->dents[AAFS_LOADDATA_DIR])"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "data->dents[AAFS_LOADDATA_DIR]"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "data->dents[AAFS_LOADDATA_DIR]"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "data->revision > revision"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!mutex_is_locked(&data->ns->lock)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&data->ns->lock"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!data->dents[AAFS_LOADDATA_REVISION]"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!data->ns"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!data"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nvoid __aa_loaddata_update(struct aa_loaddata *data, long revision)\n{\n\tAA_BUG(!data);\n\tAA_BUG(!data->ns);\n\tAA_BUG(!data->dents[AAFS_LOADDATA_REVISION]);\n\tAA_BUG(!mutex_is_locked(&data->ns->lock));\n\tAA_BUG(data->revision > revision);\n\n\tdata->revision = revision;\n\td_inode(data->dents[AAFS_LOADDATA_DIR])->i_mtime =\n\t\tcurrent_time(d_inode(data->dents[AAFS_LOADDATA_DIR]));\n\td_inode(data->dents[AAFS_LOADDATA_REVISION])->i_mtime =\n\t\tcurrent_time(d_inode(data->dents[AAFS_LOADDATA_REVISION]));\n}"
  },
  {
    "function_name": "audit_iface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "107-124",
    "snippet": "static int audit_iface(struct aa_profile *new, const char *ns_name,\n\t\t       const char *name, const char *info, struct aa_ext *e,\n\t\t       int error)\n{\n\tstruct aa_profile *profile = labels_profile(aa_current_raw_label());\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, NULL);\n\tif (e)\n\t\taad(&sa)->iface.pos = e->pos - e->start;\n\taad(&sa)->iface.ns = ns_name;\n\tif (new)\n\t\taad(&sa)->name = new->base.hname;\n\telse\n\t\taad(&sa)->name = name;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_STATUS, profile, &sa, audit_cb);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_audit",
          "args": [
            "AUDIT_APPARMOR_STATUS",
            "profile",
            "&sa",
            "audit_cb"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/audit.c",
          "lines": "129-165",
          "snippet": "int aa_audit(int type, struct aa_profile *profile, struct common_audit_data *sa,\n\t     void (*cb) (struct audit_buffer *, void *))\n{\n\tAA_BUG(!profile);\n\n\tif (type == AUDIT_APPARMOR_AUTO) {\n\t\tif (likely(!aad(sa)->error)) {\n\t\t\tif (AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\t\treturn 0;\n\t\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\t} else if (COMPLAIN_MODE(profile))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\t}\n\tif (AUDIT_MODE(profile) == AUDIT_QUIET ||\n\t    (type == AUDIT_APPARMOR_DENIED &&\n\t     AUDIT_MODE(profile) == AUDIT_QUIET))\n\t\treturn aad(sa)->error;\n\n\tif (KILL_MODE(profile) && type == AUDIT_APPARMOR_DENIED)\n\t\ttype = AUDIT_APPARMOR_KILL;\n\n\taad(sa)->label = &profile->label;\n\n\taa_audit_msg(type, sa, cb);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_KILL)\n\t\t(void)send_sig_info(SIGKILL, NULL,\n\t\t\tsa->type == LSM_AUDIT_DATA_TASK && sa->u.tsk ?\n\t\t\t\t    sa->u.tsk : current);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_ALLOWED)\n\t\treturn complain_error(aad(sa)->error);\n\n\treturn aad(sa)->error;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/socket.h>\n#include <linux/audit.h>\n\nint aa_audit(int type, struct aa_profile *profile, struct common_audit_data *sa,\n\t     void (*cb) (struct audit_buffer *, void *))\n{\n\tAA_BUG(!profile);\n\n\tif (type == AUDIT_APPARMOR_AUTO) {\n\t\tif (likely(!aad(sa)->error)) {\n\t\t\tif (AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\t\treturn 0;\n\t\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\t} else if (COMPLAIN_MODE(profile))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\t}\n\tif (AUDIT_MODE(profile) == AUDIT_QUIET ||\n\t    (type == AUDIT_APPARMOR_DENIED &&\n\t     AUDIT_MODE(profile) == AUDIT_QUIET))\n\t\treturn aad(sa)->error;\n\n\tif (KILL_MODE(profile) && type == AUDIT_APPARMOR_DENIED)\n\t\ttype = AUDIT_APPARMOR_KILL;\n\n\taad(sa)->label = &profile->label;\n\n\taa_audit_msg(type, sa, cb);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_KILL)\n\t\t(void)send_sig_info(SIGKILL, NULL,\n\t\t\tsa->type == LSM_AUDIT_DATA_TASK && sa->u.tsk ?\n\t\t\t\t    sa->u.tsk : current);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_ALLOWED)\n\t\treturn complain_error(aad(sa)->error);\n\n\treturn aad(sa)->error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_AUDIT_DATA",
          "args": [
            "sa",
            "LSM_AUDIT_DATA_NONE",
            "NULL"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_profile",
          "args": [
            "aa_current_raw_label()"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_current_raw_label",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "aa_current_raw_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "117-120",
          "snippet": "static inline struct aa_label *aa_current_raw_label(void)\n{\n\treturn aa_cred_raw_label(current_cred());\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *aa_current_raw_label(void)\n{\n\treturn aa_cred_raw_label(current_cred());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic int audit_iface(struct aa_profile *new, const char *ns_name,\n\t\t       const char *name, const char *info, struct aa_ext *e,\n\t\t       int error)\n{\n\tstruct aa_profile *profile = labels_profile(aa_current_raw_label());\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, NULL);\n\tif (e)\n\t\taad(&sa)->iface.pos = e->pos - e->start;\n\taad(&sa)->iface.ns = ns_name;\n\tif (new)\n\t\taad(&sa)->name = new->base.hname;\n\telse\n\t\taad(&sa)->name = name;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_STATUS, profile, &sa, audit_cb);\n}"
  },
  {
    "function_name": "audit_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_unpack.c",
    "lines": "80-94",
    "snippet": "static void audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\n\tif (aad(sa)->iface.ns) {\n\t\taudit_log_format(ab, \" ns=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->iface.ns);\n\t}\n\tif (aad(sa)->name) {\n\t\taudit_log_format(ab, \" name=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->name);\n\t}\n\tif (aad(sa)->iface.pos)\n\t\taudit_log_format(ab, \" offset=%ld\", aad(sa)->iface.pos);\n}",
    "includes": [
      "#include \"include/policy_unpack.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/crypto.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/errno.h>",
      "#include <linux/ctype.h>",
      "#include <asm/unaligned.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" offset=%ld\"",
            "aad(sa)->iface.pos"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "aad(sa)->name"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" name=\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "aad(sa)->iface.ns"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" ns=\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n\nstatic void audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\n\tif (aad(sa)->iface.ns) {\n\t\taudit_log_format(ab, \" ns=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->iface.ns);\n\t}\n\tif (aad(sa)->name) {\n\t\taudit_log_format(ab, \" name=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->name);\n\t}\n\tif (aad(sa)->iface.pos)\n\t\taudit_log_format(ab, \" offset=%ld\", aad(sa)->iface.pos);\n}"
  }
]