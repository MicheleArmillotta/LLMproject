[
  {
    "function_name": "hashtab_cache_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
    "lines": "179-182",
    "snippet": "void hashtab_cache_destroy(void)\n{\n\t\tkmem_cache_destroy(hashtab_node_cachep);\n}",
    "includes": [
      "#include \"hashtab.h\"",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *hashtab_node_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "hashtab_node_cachep"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nvoid hashtab_cache_destroy(void)\n{\n\t\tkmem_cache_destroy(hashtab_node_cachep);\n}"
  },
  {
    "function_name": "hashtab_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
    "lines": "172-177",
    "snippet": "void hashtab_cache_init(void)\n{\n\t\thashtab_node_cachep = kmem_cache_create(\"hashtab_node\",\n\t\t\tsizeof(struct hashtab_node),\n\t\t\t0, SLAB_PANIC, NULL);\n}",
    "includes": [
      "#include \"hashtab.h\"",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *hashtab_node_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"hashtab_node\"",
            "sizeof(struct hashtab_node)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nvoid hashtab_cache_init(void)\n{\n\t\thashtab_node_cachep = kmem_cache_create(\"hashtab_node\",\n\t\t\tsizeof(struct hashtab_node),\n\t\t\t0, SLAB_PANIC, NULL);\n}"
  },
  {
    "function_name": "hashtab_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
    "lines": "147-171",
    "snippet": "void hashtab_stat(struct hashtab *h, struct hashtab_info *info)\n{\n\tu32 i, chain_len, slots_used, max_chain_len;\n\tstruct hashtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\tinfo->slots_used = slots_used;\n\tinfo->max_chain_len = max_chain_len;\n}",
    "includes": [
      "#include \"hashtab.h\"",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid hashtab_stat(struct hashtab *h, struct hashtab_info *info)\n{\n\tu32 i, chain_len, slots_used, max_chain_len;\n\tstruct hashtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\tinfo->slots_used = slots_used;\n\tinfo->max_chain_len = max_chain_len;\n}"
  },
  {
    "function_name": "hashtab_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
    "lines": "123-144",
    "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"hashtab.h\"",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply",
          "args": [
            "cur->key",
            "cur->datum",
            "args"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "hashtab_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
    "lines": "99-121",
    "snippet": "void hashtab_destroy(struct hashtab *h)\n{\n\tu32 i;\n\tstruct hashtab_node *cur, *temp;\n\n\tif (!h)\n\t\treturn;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tkmem_cache_free(hashtab_node_cachep, temp);\n\t\t}\n\t\th->htable[i] = NULL;\n\t}\n\n\tkfree(h->htable);\n\th->htable = NULL;\n\n\tkfree(h);\n}",
    "includes": [
      "#include \"hashtab.h\"",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *hashtab_node_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "h"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "h->htable"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "hashtab_node_cachep",
            "temp"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nvoid hashtab_destroy(struct hashtab *h)\n{\n\tu32 i;\n\tstruct hashtab_node *cur, *temp;\n\n\tif (!h)\n\t\treturn;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tkmem_cache_free(hashtab_node_cachep, temp);\n\t\t}\n\t\th->htable[i] = NULL;\n\t}\n\n\tkfree(h->htable);\n\th->htable = NULL;\n\n\tkfree(h);\n}"
  },
  {
    "function_name": "hashtab_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
    "lines": "80-97",
    "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
    "includes": [
      "#include \"hashtab.h\"",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "h->keycmp",
          "args": [
            "h",
            "key",
            "cur->key"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->keycmp",
          "args": [
            "h",
            "key",
            "cur->key"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->hash_value",
          "args": [
            "h",
            "key"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
  },
  {
    "function_name": "hashtab_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
    "lines": "42-78",
    "snippet": "int hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}",
    "includes": [
      "#include \"hashtab.h\"",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *hashtab_node_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "hashtab_node_cachep",
            "GFP_KERNEL"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->keycmp",
          "args": [
            "h",
            "key",
            "cur->key"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->keycmp",
          "args": [
            "h",
            "key",
            "cur->key"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->hash_value",
          "args": [
            "h",
            "key"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}"
  },
  {
    "function_name": "hashtab_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
    "lines": "15-40",
    "snippet": "struct hashtab *hashtab_create(u32 (*hash_value)(struct hashtab *h, const void *key),\n\t\t\t       int (*keycmp)(struct hashtab *h, const void *key1, const void *key2),\n\t\t\t       u32 size)\n{\n\tstruct hashtab *p;\n\tu32 i;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn p;\n\n\tp->size = size;\n\tp->nel = 0;\n\tp->hash_value = hash_value;\n\tp->keycmp = keycmp;\n\tp->htable = kmalloc_array(size, sizeof(*p->htable), GFP_KERNEL);\n\tif (!p->htable) {\n\t\tkfree(p);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++)\n\t\tp->htable[i] = NULL;\n\n\treturn p;\n}",
    "includes": [
      "#include \"hashtab.h\"",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "size",
            "sizeof(*p->htable)",
            "GFP_KERNEL"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*p)",
            "GFP_KERNEL"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct hashtab *hashtab_create(u32 (*hash_value)(struct hashtab *h, const void *key),\n\t\t\t       int (*keycmp)(struct hashtab *h, const void *key1, const void *key2),\n\t\t\t       u32 size)\n{\n\tstruct hashtab *p;\n\tu32 i;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn p;\n\n\tp->size = size;\n\tp->nel = 0;\n\tp->hash_value = hash_value;\n\tp->keycmp = keycmp;\n\tp->htable = kmalloc_array(size, sizeof(*p->htable), GFP_KERNEL);\n\tif (!p->htable) {\n\t\tkfree(p);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++)\n\t\tp->htable[i] = NULL;\n\n\treturn p;\n}"
  }
]