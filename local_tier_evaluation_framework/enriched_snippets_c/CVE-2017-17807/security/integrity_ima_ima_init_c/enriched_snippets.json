[
  {
    "function_name": "ima_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_init.c",
    "lines": "107-141",
    "snippet": "int __init ima_init(void)\n{\n\tu8 pcr_i[TPM_DIGEST_SIZE];\n\tint rc;\n\n\tima_used_chip = 0;\n\trc = tpm_pcr_read(TPM_ANY_NUM, 0, pcr_i);\n\tif (rc == 0)\n\t\tima_used_chip = 1;\n\n\tif (!ima_used_chip)\n\t\tpr_info(\"No TPM chip found, activating TPM-bypass! (rc=%d)\\n\",\n\t\t\trc);\n\n\trc = integrity_init_keyring(INTEGRITY_KEYRING_IMA);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ima_init_crypto();\n\tif (rc)\n\t\treturn rc;\n\trc = ima_init_template();\n\tif (rc != 0)\n\t\treturn rc;\n\n\tima_load_kexec_buffer();\n\n\trc = ima_add_boot_aggregate();\t/* boot aggregate must be first entry */\n\tif (rc != 0)\n\t\treturn rc;\n\n\tima_init_policy();\n\n\treturn ima_fs_init();\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ima_used_chip;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_fs_init",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "ima_fs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
          "lines": "449-497",
          "snippet": "int __init ima_fs_init(void)\n{\n\tima_dir = securityfs_create_dir(\"ima\", NULL);\n\tif (IS_ERR(ima_dir))\n\t\treturn -1;\n\n\tbinary_runtime_measurements =\n\t    securityfs_create_file(\"binary_runtime_measurements\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_measurements_ops);\n\tif (IS_ERR(binary_runtime_measurements))\n\t\tgoto out;\n\n\tascii_runtime_measurements =\n\t    securityfs_create_file(\"ascii_runtime_measurements\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_ascii_measurements_ops);\n\tif (IS_ERR(ascii_runtime_measurements))\n\t\tgoto out;\n\n\truntime_measurements_count =\n\t    securityfs_create_file(\"runtime_measurements_count\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_measurements_count_ops);\n\tif (IS_ERR(runtime_measurements_count))\n\t\tgoto out;\n\n\tviolations =\n\t    securityfs_create_file(\"violations\", S_IRUSR | S_IRGRP,\n\t\t\t\t   ima_dir, NULL, &ima_htable_violations_ops);\n\tif (IS_ERR(violations))\n\t\tgoto out;\n\n\tima_policy = securityfs_create_file(\"policy\", POLICY_FILE_FLAGS,\n\t\t\t\t\t    ima_dir, NULL,\n\t\t\t\t\t    &ima_measure_policy_ops);\n\tif (IS_ERR(ima_policy))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tsecurityfs_remove(violations);\n\tsecurityfs_remove(runtime_measurements_count);\n\tsecurityfs_remove(ascii_runtime_measurements);\n\tsecurityfs_remove(binary_runtime_measurements);\n\tsecurityfs_remove(ima_dir);\n\tsecurityfs_remove(ima_policy);\n\treturn -1;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/parser.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rculist.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations ima_htable_violations_ops = {\n\t.read = ima_show_htable_violations,\n\t.llseek = generic_file_llseek,\n};",
            "static const struct file_operations ima_measurements_count_ops = {\n\t.read = ima_show_measurements_count,\n\t.llseek = generic_file_llseek,\n};",
            "static const struct file_operations ima_measurements_ops = {\n\t.open = ima_measurements_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};",
            "static const struct file_operations ima_ascii_measurements_ops = {\n\t.open = ima_ascii_measurements_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};",
            "static struct dentry *ima_dir;",
            "static struct dentry *binary_runtime_measurements;",
            "static struct dentry *ascii_runtime_measurements;",
            "static struct dentry *runtime_measurements_count;",
            "static struct dentry *violations;",
            "static struct dentry *ima_policy;",
            "static const struct file_operations ima_measure_policy_ops = {\n\t.open = ima_open_policy,\n\t.write = ima_write_policy,\n\t.read = seq_read,\n\t.release = ima_release_policy,\n\t.llseek = generic_file_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic const struct file_operations ima_htable_violations_ops = {\n\t.read = ima_show_htable_violations,\n\t.llseek = generic_file_llseek,\n};\nstatic const struct file_operations ima_measurements_count_ops = {\n\t.read = ima_show_measurements_count,\n\t.llseek = generic_file_llseek,\n};\nstatic const struct file_operations ima_measurements_ops = {\n\t.open = ima_measurements_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\nstatic const struct file_operations ima_ascii_measurements_ops = {\n\t.open = ima_ascii_measurements_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\nstatic struct dentry *ima_dir;\nstatic struct dentry *binary_runtime_measurements;\nstatic struct dentry *ascii_runtime_measurements;\nstatic struct dentry *runtime_measurements_count;\nstatic struct dentry *violations;\nstatic struct dentry *ima_policy;\nstatic const struct file_operations ima_measure_policy_ops = {\n\t.open = ima_open_policy,\n\t.write = ima_write_policy,\n\t.read = seq_read,\n\t.release = ima_release_policy,\n\t.llseek = generic_file_llseek,\n};\n\nint __init ima_fs_init(void)\n{\n\tima_dir = securityfs_create_dir(\"ima\", NULL);\n\tif (IS_ERR(ima_dir))\n\t\treturn -1;\n\n\tbinary_runtime_measurements =\n\t    securityfs_create_file(\"binary_runtime_measurements\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_measurements_ops);\n\tif (IS_ERR(binary_runtime_measurements))\n\t\tgoto out;\n\n\tascii_runtime_measurements =\n\t    securityfs_create_file(\"ascii_runtime_measurements\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_ascii_measurements_ops);\n\tif (IS_ERR(ascii_runtime_measurements))\n\t\tgoto out;\n\n\truntime_measurements_count =\n\t    securityfs_create_file(\"runtime_measurements_count\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_measurements_count_ops);\n\tif (IS_ERR(runtime_measurements_count))\n\t\tgoto out;\n\n\tviolations =\n\t    securityfs_create_file(\"violations\", S_IRUSR | S_IRGRP,\n\t\t\t\t   ima_dir, NULL, &ima_htable_violations_ops);\n\tif (IS_ERR(violations))\n\t\tgoto out;\n\n\tima_policy = securityfs_create_file(\"policy\", POLICY_FILE_FLAGS,\n\t\t\t\t\t    ima_dir, NULL,\n\t\t\t\t\t    &ima_measure_policy_ops);\n\tif (IS_ERR(ima_policy))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tsecurityfs_remove(violations);\n\tsecurityfs_remove(runtime_measurements_count);\n\tsecurityfs_remove(ascii_runtime_measurements);\n\tsecurityfs_remove(binary_runtime_measurements);\n\tsecurityfs_remove(ima_dir);\n\tsecurityfs_remove(ima_policy);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_init_policy",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "ima_init_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "428-473",
          "snippet": "void __init ima_init_policy(void)\n{\n\tint i, measure_entries, appraise_entries, secure_boot_entries;\n\n\t/* if !ima_policy set entries = 0 so we load NO default rules */\n\tmeasure_entries = ima_policy ? ARRAY_SIZE(dont_measure_rules) : 0;\n\tappraise_entries = ima_use_appraise_tcb ?\n\t\t\t ARRAY_SIZE(default_appraise_rules) : 0;\n\tsecure_boot_entries = ima_use_secure_boot ?\n\t\t\tARRAY_SIZE(secure_boot_rules) : 0;\n\n\tfor (i = 0; i < measure_entries; i++)\n\t\tlist_add_tail(&dont_measure_rules[i].list, &ima_default_rules);\n\n\tswitch (ima_policy) {\n\tcase ORIGINAL_TCB:\n\t\tfor (i = 0; i < ARRAY_SIZE(original_measurement_rules); i++)\n\t\t\tlist_add_tail(&original_measurement_rules[i].list,\n\t\t\t\t      &ima_default_rules);\n\t\tbreak;\n\tcase DEFAULT_TCB:\n\t\tfor (i = 0; i < ARRAY_SIZE(default_measurement_rules); i++)\n\t\t\tlist_add_tail(&default_measurement_rules[i].list,\n\t\t\t\t      &ima_default_rules);\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Insert the appraise rules requiring file signatures, prior to\n\t * any other appraise rules.\n\t */\n\tfor (i = 0; i < secure_boot_entries; i++)\n\t\tlist_add_tail(&secure_boot_rules[i].list,\n\t\t\t      &ima_default_rules);\n\n\tfor (i = 0; i < appraise_entries; i++) {\n\t\tlist_add_tail(&default_appraise_rules[i].list,\n\t\t\t      &ima_default_rules);\n\t\tif (default_appraise_rules[i].func == POLICY_CHECK)\n\t\t\ttemp_ima_appraise |= IMA_APPRAISE_POLICY;\n\t}\n\n\tima_rules = &ima_default_rules;\n\tima_update_policy_flag();\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int temp_ima_appraise;",
            "static struct ima_rule_entry dont_measure_rules[] __ro_after_init = {\n\t{.action = DONT_MEASURE, .fsmagic = PROC_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SYSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = DEBUGFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = TMPFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = DEVPTS_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = CGROUP_SUPER_MAGIC,\n\t .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = CGROUP2_SUPER_MAGIC,\n\t .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC}\n};",
            "static struct ima_rule_entry original_measurement_rules[] __ro_after_init = {\n\t{.action = MEASURE, .func = MMAP_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = BPRM_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_MASK | IMA_UID},\n\t{.action = MEASURE, .func = MODULE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = FIRMWARE_CHECK, .flags = IMA_FUNC},\n};",
            "static struct ima_rule_entry default_measurement_rules[] __ro_after_init = {\n\t{.action = MEASURE, .func = MMAP_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = BPRM_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_INMASK | IMA_EUID},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_INMASK | IMA_UID},\n\t{.action = MEASURE, .func = MODULE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = FIRMWARE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = POLICY_CHECK, .flags = IMA_FUNC},\n};",
            "static struct ima_rule_entry default_appraise_rules[] __ro_after_init = {\n\t{.action = DONT_APPRAISE, .fsmagic = PROC_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SYSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = DEBUGFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = TMPFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = RAMFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = DEVPTS_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = CGROUP_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = CGROUP2_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n#ifdef CONFIG_IMA_WRITE_POLICY\n\t{.action = APPRAISE, .func = POLICY_CHECK,\n\t.flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n#endif\n#ifndef CONFIG_IMA_APPRAISE_SIGNED_INIT\n\t{.action = APPRAISE, .fowner = GLOBAL_ROOT_UID, .fowner_op = &uid_eq,\n\t .flags = IMA_FOWNER},\n#else\n\t/* force signature */\n\t{.action = APPRAISE, .fowner = GLOBAL_ROOT_UID, .fowner_op = &uid_eq,\n\t .flags = IMA_FOWNER | IMA_DIGSIG_REQUIRED},\n#endif\n};",
            "static struct ima_rule_entry secure_boot_rules[] __ro_after_init = {\n\t{.action = APPRAISE, .func = MODULE_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = FIRMWARE_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = KEXEC_KERNEL_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = POLICY_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n};",
            "static LIST_HEAD(ima_default_rules);",
            "static struct list_head *ima_rules;",
            "static int ima_policy",
            "static bool ima_use_appraise_tcb",
            "static bool ima_use_secure_boot"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic int temp_ima_appraise;\nstatic struct ima_rule_entry dont_measure_rules[] __ro_after_init = {\n\t{.action = DONT_MEASURE, .fsmagic = PROC_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SYSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = DEBUGFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = TMPFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = DEVPTS_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = CGROUP_SUPER_MAGIC,\n\t .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = CGROUP2_SUPER_MAGIC,\n\t .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC}\n};\nstatic struct ima_rule_entry original_measurement_rules[] __ro_after_init = {\n\t{.action = MEASURE, .func = MMAP_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = BPRM_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_MASK | IMA_UID},\n\t{.action = MEASURE, .func = MODULE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = FIRMWARE_CHECK, .flags = IMA_FUNC},\n};\nstatic struct ima_rule_entry default_measurement_rules[] __ro_after_init = {\n\t{.action = MEASURE, .func = MMAP_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = BPRM_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_INMASK | IMA_EUID},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_INMASK | IMA_UID},\n\t{.action = MEASURE, .func = MODULE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = FIRMWARE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = POLICY_CHECK, .flags = IMA_FUNC},\n};\nstatic struct ima_rule_entry default_appraise_rules[] __ro_after_init = {\n\t{.action = DONT_APPRAISE, .fsmagic = PROC_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SYSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = DEBUGFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = TMPFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = RAMFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = DEVPTS_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = CGROUP_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = CGROUP2_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n#ifdef CONFIG_IMA_WRITE_POLICY\n\t{.action = APPRAISE, .func = POLICY_CHECK,\n\t.flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n#endif\n#ifndef CONFIG_IMA_APPRAISE_SIGNED_INIT\n\t{.action = APPRAISE, .fowner = GLOBAL_ROOT_UID, .fowner_op = &uid_eq,\n\t .flags = IMA_FOWNER},\n#else\n\t/* force signature */\n\t{.action = APPRAISE, .fowner = GLOBAL_ROOT_UID, .fowner_op = &uid_eq,\n\t .flags = IMA_FOWNER | IMA_DIGSIG_REQUIRED},\n#endif\n};\nstatic struct ima_rule_entry secure_boot_rules[] __ro_after_init = {\n\t{.action = APPRAISE, .func = MODULE_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = FIRMWARE_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = KEXEC_KERNEL_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = POLICY_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n};\nstatic LIST_HEAD(ima_default_rules);\nstatic struct list_head *ima_rules;\nstatic int ima_policy;\nstatic bool ima_use_appraise_tcb;\nstatic bool ima_use_secure_boot;\n\nvoid __init ima_init_policy(void)\n{\n\tint i, measure_entries, appraise_entries, secure_boot_entries;\n\n\t/* if !ima_policy set entries = 0 so we load NO default rules */\n\tmeasure_entries = ima_policy ? ARRAY_SIZE(dont_measure_rules) : 0;\n\tappraise_entries = ima_use_appraise_tcb ?\n\t\t\t ARRAY_SIZE(default_appraise_rules) : 0;\n\tsecure_boot_entries = ima_use_secure_boot ?\n\t\t\tARRAY_SIZE(secure_boot_rules) : 0;\n\n\tfor (i = 0; i < measure_entries; i++)\n\t\tlist_add_tail(&dont_measure_rules[i].list, &ima_default_rules);\n\n\tswitch (ima_policy) {\n\tcase ORIGINAL_TCB:\n\t\tfor (i = 0; i < ARRAY_SIZE(original_measurement_rules); i++)\n\t\t\tlist_add_tail(&original_measurement_rules[i].list,\n\t\t\t\t      &ima_default_rules);\n\t\tbreak;\n\tcase DEFAULT_TCB:\n\t\tfor (i = 0; i < ARRAY_SIZE(default_measurement_rules); i++)\n\t\t\tlist_add_tail(&default_measurement_rules[i].list,\n\t\t\t\t      &ima_default_rules);\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Insert the appraise rules requiring file signatures, prior to\n\t * any other appraise rules.\n\t */\n\tfor (i = 0; i < secure_boot_entries; i++)\n\t\tlist_add_tail(&secure_boot_rules[i].list,\n\t\t\t      &ima_default_rules);\n\n\tfor (i = 0; i < appraise_entries; i++) {\n\t\tlist_add_tail(&default_appraise_rules[i].list,\n\t\t\t      &ima_default_rules);\n\t\tif (default_appraise_rules[i].func == POLICY_CHECK)\n\t\t\ttemp_ima_appraise |= IMA_APPRAISE_POLICY;\n\t}\n\n\tima_rules = &ima_default_rules;\n\tima_update_policy_flag();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_add_boot_aggregate",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "ima_add_boot_aggregate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_init.c",
          "lines": "46-94",
          "snippet": "static int __init ima_add_boot_aggregate(void)\n{\n\tstatic const char op[] = \"add_boot_aggregate\";\n\tconst char *audit_cause = \"ENOMEM\";\n\tstruct ima_template_entry *entry;\n\tstruct integrity_iint_cache tmp_iint, *iint = &tmp_iint;\n\tstruct ima_event_data event_data = {iint, NULL, boot_aggregate_name,\n\t\t\t\t\t    NULL, 0, NULL};\n\tint result = -ENOMEM;\n\tint violation = 0;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[TPM_DIGEST_SIZE];\n\t} hash;\n\n\tmemset(iint, 0, sizeof(*iint));\n\tmemset(&hash, 0, sizeof(hash));\n\tiint->ima_hash = &hash.hdr;\n\tiint->ima_hash->algo = HASH_ALGO_SHA1;\n\tiint->ima_hash->length = SHA1_DIGEST_SIZE;\n\n\tif (ima_used_chip) {\n\t\tresult = ima_calc_boot_aggregate(&hash.hdr);\n\t\tif (result < 0) {\n\t\t\taudit_cause = \"hashing_error\";\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tresult = ima_alloc_init_template(&event_data, &entry);\n\tif (result < 0) {\n\t\taudit_cause = \"alloc_entry\";\n\t\tgoto err_out;\n\t}\n\n\tresult = ima_store_template(entry, violation, NULL,\n\t\t\t\t    boot_aggregate_name,\n\t\t\t\t    CONFIG_IMA_MEASURE_PCR_IDX);\n\tif (result < 0) {\n\t\tima_free_template_entry(entry);\n\t\taudit_cause = \"store_entry\";\n\t\tgoto err_out;\n\t}\n\treturn 0;\nerr_out:\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, NULL, boot_aggregate_name, op,\n\t\t\t    audit_cause, result, 0);\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *boot_aggregate_name = \"boot_aggregate\";",
            "int ima_used_chip;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/module.h>\n\nstatic const char *boot_aggregate_name = \"boot_aggregate\";\nint ima_used_chip;\n\nstatic int __init ima_add_boot_aggregate(void)\n{\n\tstatic const char op[] = \"add_boot_aggregate\";\n\tconst char *audit_cause = \"ENOMEM\";\n\tstruct ima_template_entry *entry;\n\tstruct integrity_iint_cache tmp_iint, *iint = &tmp_iint;\n\tstruct ima_event_data event_data = {iint, NULL, boot_aggregate_name,\n\t\t\t\t\t    NULL, 0, NULL};\n\tint result = -ENOMEM;\n\tint violation = 0;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[TPM_DIGEST_SIZE];\n\t} hash;\n\n\tmemset(iint, 0, sizeof(*iint));\n\tmemset(&hash, 0, sizeof(hash));\n\tiint->ima_hash = &hash.hdr;\n\tiint->ima_hash->algo = HASH_ALGO_SHA1;\n\tiint->ima_hash->length = SHA1_DIGEST_SIZE;\n\n\tif (ima_used_chip) {\n\t\tresult = ima_calc_boot_aggregate(&hash.hdr);\n\t\tif (result < 0) {\n\t\t\taudit_cause = \"hashing_error\";\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tresult = ima_alloc_init_template(&event_data, &entry);\n\tif (result < 0) {\n\t\taudit_cause = \"alloc_entry\";\n\t\tgoto err_out;\n\t}\n\n\tresult = ima_store_template(entry, violation, NULL,\n\t\t\t\t    boot_aggregate_name,\n\t\t\t\t    CONFIG_IMA_MEASURE_PCR_IDX);\n\tif (result < 0) {\n\t\tima_free_template_entry(entry);\n\t\taudit_cause = \"store_entry\";\n\t\tgoto err_out;\n\t}\n\treturn 0;\nerr_out:\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, NULL, boot_aggregate_name, op,\n\t\t\t    audit_cause, result, 0);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_load_kexec_buffer",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "ima_load_kexec_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_kexec.c",
          "lines": "142-168",
          "snippet": "void ima_load_kexec_buffer(void)\n{\n\tvoid *kexec_buffer = NULL;\n\tsize_t kexec_buffer_size = 0;\n\tint rc;\n\n\trc = ima_get_kexec_buffer(&kexec_buffer, &kexec_buffer_size);\n\tswitch (rc) {\n\tcase 0:\n\t\trc = ima_restore_measurement_list(kexec_buffer_size,\n\t\t\t\t\t\t  kexec_buffer);\n\t\tif (rc != 0)\n\t\t\tpr_err(\"Failed to restore the measurement list: %d\\n\",\n\t\t\t\trc);\n\n\t\tima_free_kexec_buffer();\n\t\tbreak;\n\tcase -ENOTSUPP:\n\t\tpr_debug(\"Restoring the measurement list not supported\\n\");\n\t\tbreak;\n\tcase -ENOENT:\n\t\tpr_debug(\"No measurement list to restore\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Error restoring the measurement list: %d\\n\", rc);\n\t}\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/kexec.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/kexec.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n\nvoid ima_load_kexec_buffer(void)\n{\n\tvoid *kexec_buffer = NULL;\n\tsize_t kexec_buffer_size = 0;\n\tint rc;\n\n\trc = ima_get_kexec_buffer(&kexec_buffer, &kexec_buffer_size);\n\tswitch (rc) {\n\tcase 0:\n\t\trc = ima_restore_measurement_list(kexec_buffer_size,\n\t\t\t\t\t\t  kexec_buffer);\n\t\tif (rc != 0)\n\t\t\tpr_err(\"Failed to restore the measurement list: %d\\n\",\n\t\t\t\trc);\n\n\t\tima_free_kexec_buffer();\n\t\tbreak;\n\tcase -ENOTSUPP:\n\t\tpr_debug(\"Restoring the measurement list not supported\\n\");\n\t\tbreak;\n\tcase -ENOENT:\n\t\tpr_debug(\"No measurement list to restore\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Error restoring the measurement list: %d\\n\", rc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_init_template",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ima_init_template",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "231-245",
          "snippet": "int __init ima_init_template(void)\n{\n\tstruct ima_template_desc *template = ima_template_desc_current();\n\tint result;\n\n\tresult = template_desc_init_fields(template->fmt,\n\t\t\t\t\t   &(template->fields),\n\t\t\t\t\t   &(template->num_fields));\n\tif (result < 0)\n\t\tpr_err(\"template %s init failed, result: %d\\n\",\n\t\t       (strlen(template->name) ?\n\t\t       template->name : template->fmt), result);\n\n\treturn result;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ima_template_desc *lookup_template_desc(const char *name);",
            "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_desc *lookup_template_desc(const char *name);\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);\n\nint __init ima_init_template(void)\n{\n\tstruct ima_template_desc *template = ima_template_desc_current();\n\tint result;\n\n\tresult = template_desc_init_fields(template->fmt,\n\t\t\t\t\t   &(template->fields),\n\t\t\t\t\t   &(template->num_fields));\n\tif (result < 0)\n\t\tpr_err(\"template %s init failed, result: %d\\n\",\n\t\t       (strlen(template->name) ?\n\t\t       template->name : template->fmt), result);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_init_crypto",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "ima_init_crypto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "65-77",
          "snippet": "int __init ima_init_crypto(void)\n{\n\tlong rc;\n\n\tima_shash_tfm = crypto_alloc_shash(hash_algo_name[ima_hash_algo], 0, 0);\n\tif (IS_ERR(ima_shash_tfm)) {\n\t\trc = PTR_ERR(ima_shash_tfm);\n\t\tpr_err(\"Can not allocate %s (reason: %ld)\\n\",\n\t\t       hash_algo_name[ima_hash_algo], rc);\n\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *ima_shash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_shash *ima_shash_tfm;\n\nint __init ima_init_crypto(void)\n{\n\tlong rc;\n\n\tima_shash_tfm = crypto_alloc_shash(hash_algo_name[ima_hash_algo], 0, 0);\n\tif (IS_ERR(ima_shash_tfm)) {\n\t\trc = PTR_ERR(ima_shash_tfm);\n\t\tpr_err(\"Can not allocate %s (reason: %ld)\\n\",\n\t\t       hash_algo_name[ima_hash_algo], rc);\n\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "integrity_init_keyring",
          "args": [
            "INTEGRITY_KEYRING_IMA"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_init_keyring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "144-147",
          "snippet": "static inline int integrity_init_keyring(const unsigned int id)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstatic inline int integrity_init_keyring(const unsigned int id)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"No TPM chip found, activating TPM-bypass! (rc=%d)\\n\"",
            "rc"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tpm_pcr_read",
          "args": [
            "TPM_ANY_NUM",
            "0",
            "pcr_i"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/module.h>\n\nint ima_used_chip;\n\nint __init ima_init(void)\n{\n\tu8 pcr_i[TPM_DIGEST_SIZE];\n\tint rc;\n\n\tima_used_chip = 0;\n\trc = tpm_pcr_read(TPM_ANY_NUM, 0, pcr_i);\n\tif (rc == 0)\n\t\tima_used_chip = 1;\n\n\tif (!ima_used_chip)\n\t\tpr_info(\"No TPM chip found, activating TPM-bypass! (rc=%d)\\n\",\n\t\t\trc);\n\n\trc = integrity_init_keyring(INTEGRITY_KEYRING_IMA);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ima_init_crypto();\n\tif (rc)\n\t\treturn rc;\n\trc = ima_init_template();\n\tif (rc != 0)\n\t\treturn rc;\n\n\tima_load_kexec_buffer();\n\n\trc = ima_add_boot_aggregate();\t/* boot aggregate must be first entry */\n\tif (rc != 0)\n\t\treturn rc;\n\n\tima_init_policy();\n\n\treturn ima_fs_init();\n}"
  },
  {
    "function_name": "ima_load_x509",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_init.c",
    "lines": "97-104",
    "snippet": "void __init ima_load_x509(void)\n{\n\tint unset_flags = ima_policy_flag & IMA_APPRAISE;\n\n\tima_policy_flag &= ~unset_flags;\n\tintegrity_load_x509(INTEGRITY_KEYRING_IMA, CONFIG_IMA_X509_PATH);\n\tima_policy_flag |= unset_flags;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "integrity_load_x509",
          "args": [
            "INTEGRITY_KEYRING_IMA",
            "CONFIG_IMA_X509_PATH"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_load_x509",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/digsig.c",
          "lines": "112-148",
          "snippet": "int __init integrity_load_x509(const unsigned int id, const char *path)\n{\n\tkey_ref_t key;\n\tvoid *data;\n\tloff_t size;\n\tint rc;\n\n\tif (!keyring[id])\n\t\treturn -EINVAL;\n\n\trc = kernel_read_file_from_path(path, &data, &size, 0,\n\t\t\t\t\tREADING_X509_CERTIFICATE);\n\tif (rc < 0) {\n\t\tpr_err(\"Unable to open file: %s (%d)\", path, rc);\n\t\treturn rc;\n\t}\n\n\tkey = key_create_or_update(make_key_ref(keyring[id], 1),\n\t\t\t\t   \"asymmetric\",\n\t\t\t\t   NULL,\n\t\t\t\t   data,\n\t\t\t\t   size,\n\t\t\t\t   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\trc = PTR_ERR(key);\n\t\tpr_err(\"Problem loading X.509 certificate (%d): %s\\n\",\n\t\t       rc, path);\n\t} else {\n\t\tpr_notice(\"Loaded X.509 cert '%s': %s\\n\",\n\t\t\t  key_ref_to_ptr(key)->description, path);\n\t\tkey_ref_put(key);\n\t}\n\tvfree(data);\n\treturn 0;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <keys/system_keyring.h>",
            "#include <crypto/public_key.h>",
            "#include <linux/digsig.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct key *keyring[INTEGRITY_KEYRING_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <keys/system_keyring.h>\n#include <crypto/public_key.h>\n#include <linux/digsig.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n\nstatic struct key *keyring[INTEGRITY_KEYRING_MAX];\n\nint __init integrity_load_x509(const unsigned int id, const char *path)\n{\n\tkey_ref_t key;\n\tvoid *data;\n\tloff_t size;\n\tint rc;\n\n\tif (!keyring[id])\n\t\treturn -EINVAL;\n\n\trc = kernel_read_file_from_path(path, &data, &size, 0,\n\t\t\t\t\tREADING_X509_CERTIFICATE);\n\tif (rc < 0) {\n\t\tpr_err(\"Unable to open file: %s (%d)\", path, rc);\n\t\treturn rc;\n\t}\n\n\tkey = key_create_or_update(make_key_ref(keyring[id], 1),\n\t\t\t\t   \"asymmetric\",\n\t\t\t\t   NULL,\n\t\t\t\t   data,\n\t\t\t\t   size,\n\t\t\t\t   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\trc = PTR_ERR(key);\n\t\tpr_err(\"Problem loading X.509 certificate (%d): %s\\n\",\n\t\t       rc, path);\n\t} else {\n\t\tpr_notice(\"Loaded X.509 cert '%s': %s\\n\",\n\t\t\t  key_ref_to_ptr(key)->description, path);\n\t\tkey_ref_put(key);\n\t}\n\tvfree(data);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/module.h>\n\nvoid __init ima_load_x509(void)\n{\n\tint unset_flags = ima_policy_flag & IMA_APPRAISE;\n\n\tima_policy_flag &= ~unset_flags;\n\tintegrity_load_x509(INTEGRITY_KEYRING_IMA, CONFIG_IMA_X509_PATH);\n\tima_policy_flag |= unset_flags;\n}"
  },
  {
    "function_name": "ima_add_boot_aggregate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_init.c",
    "lines": "46-94",
    "snippet": "static int __init ima_add_boot_aggregate(void)\n{\n\tstatic const char op[] = \"add_boot_aggregate\";\n\tconst char *audit_cause = \"ENOMEM\";\n\tstruct ima_template_entry *entry;\n\tstruct integrity_iint_cache tmp_iint, *iint = &tmp_iint;\n\tstruct ima_event_data event_data = {iint, NULL, boot_aggregate_name,\n\t\t\t\t\t    NULL, 0, NULL};\n\tint result = -ENOMEM;\n\tint violation = 0;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[TPM_DIGEST_SIZE];\n\t} hash;\n\n\tmemset(iint, 0, sizeof(*iint));\n\tmemset(&hash, 0, sizeof(hash));\n\tiint->ima_hash = &hash.hdr;\n\tiint->ima_hash->algo = HASH_ALGO_SHA1;\n\tiint->ima_hash->length = SHA1_DIGEST_SIZE;\n\n\tif (ima_used_chip) {\n\t\tresult = ima_calc_boot_aggregate(&hash.hdr);\n\t\tif (result < 0) {\n\t\t\taudit_cause = \"hashing_error\";\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tresult = ima_alloc_init_template(&event_data, &entry);\n\tif (result < 0) {\n\t\taudit_cause = \"alloc_entry\";\n\t\tgoto err_out;\n\t}\n\n\tresult = ima_store_template(entry, violation, NULL,\n\t\t\t\t    boot_aggregate_name,\n\t\t\t\t    CONFIG_IMA_MEASURE_PCR_IDX);\n\tif (result < 0) {\n\t\tima_free_template_entry(entry);\n\t\taudit_cause = \"store_entry\";\n\t\tgoto err_out;\n\t}\n\treturn 0;\nerr_out:\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, NULL, boot_aggregate_name, op,\n\t\t\t    audit_cause, result, 0);\n\treturn result;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/err.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *boot_aggregate_name = \"boot_aggregate\";",
      "int ima_used_chip;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "integrity_audit_msg",
          "args": [
            "AUDIT_INTEGRITY_PCR",
            "NULL",
            "boot_aggregate_name",
            "op",
            "audit_cause",
            "result",
            "0"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "183-188",
          "snippet": "static inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct integrity_iint_cache *integrity_iint_find(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode);\n\nstatic inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_free_template_entry",
          "args": [
            "entry"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "ima_free_template_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "27-35",
          "snippet": "void ima_free_template_entry(struct ima_template_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < entry->template_desc->num_fields; i++)\n\t\tkfree(entry->template_data[i].data);\n\n\tkfree(entry);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid ima_free_template_entry(struct ima_template_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < entry->template_desc->num_fields; i++)\n\t\tkfree(entry->template_data[i].data);\n\n\tkfree(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_store_template",
          "args": [
            "entry",
            "violation",
            "NULL",
            "boot_aggregate_name",
            "CONFIG_IMA_MEASURE_PCR_IDX"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "ima_store_template",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "88-120",
          "snippet": "int ima_store_template(struct ima_template_entry *entry,\n\t\t       int violation, struct inode *inode,\n\t\t       const unsigned char *filename, int pcr)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"hashing_error\";\n\tchar *template_name = entry->template_desc->name;\n\tint result;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[TPM_DIGEST_SIZE];\n\t} hash;\n\n\tif (!violation) {\n\t\tint num_fields = entry->template_desc->num_fields;\n\n\t\t/* this function uses default algo */\n\t\thash.hdr.algo = HASH_ALGO_SHA1;\n\t\tresult = ima_calc_field_array_hash(&entry->template_data[0],\n\t\t\t\t\t\t   entry->template_desc,\n\t\t\t\t\t\t   num_fields, &hash.hdr);\n\t\tif (result < 0) {\n\t\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,\n\t\t\t\t\t    template_name, op,\n\t\t\t\t\t    audit_cause, result, 0);\n\t\t\treturn result;\n\t\t}\n\t\tmemcpy(entry->digest, hash.hdr.digest, hash.hdr.length);\n\t}\n\tentry->pcr = pcr;\n\tresult = ima_add_template_entry(entry, violation, op, inode, filename);\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint ima_store_template(struct ima_template_entry *entry,\n\t\t       int violation, struct inode *inode,\n\t\t       const unsigned char *filename, int pcr)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"hashing_error\";\n\tchar *template_name = entry->template_desc->name;\n\tint result;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[TPM_DIGEST_SIZE];\n\t} hash;\n\n\tif (!violation) {\n\t\tint num_fields = entry->template_desc->num_fields;\n\n\t\t/* this function uses default algo */\n\t\thash.hdr.algo = HASH_ALGO_SHA1;\n\t\tresult = ima_calc_field_array_hash(&entry->template_data[0],\n\t\t\t\t\t\t   entry->template_desc,\n\t\t\t\t\t\t   num_fields, &hash.hdr);\n\t\tif (result < 0) {\n\t\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,\n\t\t\t\t\t    template_name, op,\n\t\t\t\t\t    audit_cause, result, 0);\n\t\t\treturn result;\n\t\t}\n\t\tmemcpy(entry->digest, hash.hdr.digest, hash.hdr.length);\n\t}\n\tentry->pcr = pcr;\n\tresult = ima_add_template_entry(entry, violation, op, inode, filename);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_alloc_init_template",
          "args": [
            "&event_data",
            "&entry"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ima_alloc_init_template",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "40-70",
          "snippet": "int ima_alloc_init_template(struct ima_event_data *event_data,\n\t\t\t    struct ima_template_entry **entry)\n{\n\tstruct ima_template_desc *template_desc = ima_template_desc_current();\n\tint i, result = 0;\n\n\t*entry = kzalloc(sizeof(**entry) + template_desc->num_fields *\n\t\t\t sizeof(struct ima_field_data), GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tstruct ima_template_field *field = template_desc->fields[i];\n\t\tu32 len;\n\n\t\tresult = field->field_init(event_data,\n\t\t\t\t\t   &((*entry)->template_data[i]));\n\t\tif (result != 0)\n\t\t\tgoto out;\n\n\t\tlen = (*entry)->template_data[i].len;\n\t\t(*entry)->template_data_len += sizeof(len);\n\t\t(*entry)->template_data_len += len;\n\t}\n\treturn 0;\nout:\n\tima_free_template_entry(*entry);\n\t*entry = NULL;\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint ima_alloc_init_template(struct ima_event_data *event_data,\n\t\t\t    struct ima_template_entry **entry)\n{\n\tstruct ima_template_desc *template_desc = ima_template_desc_current();\n\tint i, result = 0;\n\n\t*entry = kzalloc(sizeof(**entry) + template_desc->num_fields *\n\t\t\t sizeof(struct ima_field_data), GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tstruct ima_template_field *field = template_desc->fields[i];\n\t\tu32 len;\n\n\t\tresult = field->field_init(event_data,\n\t\t\t\t\t   &((*entry)->template_data[i]));\n\t\tif (result != 0)\n\t\t\tgoto out;\n\n\t\tlen = (*entry)->template_data[i].len;\n\t\t(*entry)->template_data_len += sizeof(len);\n\t\t(*entry)->template_data_len += len;\n\t}\n\treturn 0;\nout:\n\tima_free_template_entry(*entry);\n\t*entry = NULL;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_calc_boot_aggregate",
          "args": [
            "&hash.hdr"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "ima_calc_boot_aggregate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "667-682",
          "snippet": "int __init ima_calc_boot_aggregate(struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\thash->length = crypto_shash_digestsize(tfm);\n\trc = ima_calc_boot_aggregate_tfm(hash->digest, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nint __init ima_calc_boot_aggregate(struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\thash->length = crypto_shash_digestsize(tfm);\n\trc = ima_calc_boot_aggregate_tfm(hash->digest, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hash",
            "0",
            "sizeof(hash)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "iint",
            "0",
            "sizeof(*iint)"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/module.h>\n\nstatic const char *boot_aggregate_name = \"boot_aggregate\";\nint ima_used_chip;\n\nstatic int __init ima_add_boot_aggregate(void)\n{\n\tstatic const char op[] = \"add_boot_aggregate\";\n\tconst char *audit_cause = \"ENOMEM\";\n\tstruct ima_template_entry *entry;\n\tstruct integrity_iint_cache tmp_iint, *iint = &tmp_iint;\n\tstruct ima_event_data event_data = {iint, NULL, boot_aggregate_name,\n\t\t\t\t\t    NULL, 0, NULL};\n\tint result = -ENOMEM;\n\tint violation = 0;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[TPM_DIGEST_SIZE];\n\t} hash;\n\n\tmemset(iint, 0, sizeof(*iint));\n\tmemset(&hash, 0, sizeof(hash));\n\tiint->ima_hash = &hash.hdr;\n\tiint->ima_hash->algo = HASH_ALGO_SHA1;\n\tiint->ima_hash->length = SHA1_DIGEST_SIZE;\n\n\tif (ima_used_chip) {\n\t\tresult = ima_calc_boot_aggregate(&hash.hdr);\n\t\tif (result < 0) {\n\t\t\taudit_cause = \"hashing_error\";\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tresult = ima_alloc_init_template(&event_data, &entry);\n\tif (result < 0) {\n\t\taudit_cause = \"alloc_entry\";\n\t\tgoto err_out;\n\t}\n\n\tresult = ima_store_template(entry, violation, NULL,\n\t\t\t\t    boot_aggregate_name,\n\t\t\t\t    CONFIG_IMA_MEASURE_PCR_IDX);\n\tif (result < 0) {\n\t\tima_free_template_entry(entry);\n\t\taudit_cause = \"store_entry\";\n\t\tgoto err_out;\n\t}\n\treturn 0;\nerr_out:\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, NULL, boot_aggregate_name, op,\n\t\t\t    audit_cause, result, 0);\n\treturn result;\n}"
  }
]