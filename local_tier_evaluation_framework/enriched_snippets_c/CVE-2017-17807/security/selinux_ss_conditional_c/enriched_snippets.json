[
  {
    "function_name": "cond_compute_av",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "638-666",
    "snippet": "void cond_compute_av(struct avtab *ctab, struct avtab_key *key,\n\t\tstruct av_decision *avd, struct extended_perms *xperms)\n{\n\tstruct avtab_node *node;\n\n\tif (!ctab || !key || !avd)\n\t\treturn;\n\n\tfor (node = avtab_search_node(ctab, key); node;\n\t\t\t\tnode = avtab_search_node_next(node, key->specified)) {\n\t\tif ((u16)(AVTAB_ALLOWED|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_ALLOWED|AVTAB_ENABLED)))\n\t\t\tavd->allowed |= node->datum.u.data;\n\t\tif ((u16)(AVTAB_AUDITDENY|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_AUDITDENY|AVTAB_ENABLED)))\n\t\t\t/* Since a '0' in an auditdeny mask represents a\n\t\t\t * permission we do NOT want to audit (dontaudit), we use\n\t\t\t * the '&' operand to ensure that all '0's in the mask\n\t\t\t * are retained (much unlike the allow and auditallow cases).\n\t\t\t */\n\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\tif ((u16)(AVTAB_AUDITALLOW|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_AUDITALLOW|AVTAB_ENABLED)))\n\t\t\tavd->auditallow |= node->datum.u.data;\n\t\tif (xperms && (node->key.specified & AVTAB_ENABLED) &&\n\t\t\t\t(node->key.specified & AVTAB_XPERMS))\n\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t}\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "services_compute_xperms_drivers",
          "args": [
            "xperms",
            "node"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "services_compute_xperms_drivers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "610-629",
          "snippet": "void services_compute_xperms_drivers(\n\t\tstruct extended_perms *xperms,\n\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t/* if one or more driver has all permissions allowed */\n\t\tfor (i = 0; i < ARRAY_SIZE(xperms->drivers.p); i++)\n\t\t\txperms->drivers.p[i] |= node->datum.u.xperms->perms.p[i];\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t/* if allowing permissions within a driver */\n\t\tsecurity_xperm_set(xperms->drivers.p,\n\t\t\t\t\tnode->datum.u.xperms->driver);\n\t}\n\n\t/* If no ioctl commands are allowed, ignore auditallow and auditdeny */\n\tif (node->key.specified & AVTAB_XPERMS_ALLOWED)\n\t\txperms->len = 1;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);",
            "static int security_preserve_bools(struct policydb *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);\nstatic int security_preserve_bools(struct policydb *p);\n\nvoid services_compute_xperms_drivers(\n\t\tstruct extended_perms *xperms,\n\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t/* if one or more driver has all permissions allowed */\n\t\tfor (i = 0; i < ARRAY_SIZE(xperms->drivers.p); i++)\n\t\t\txperms->drivers.p[i] |= node->datum.u.xperms->perms.p[i];\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t/* if allowing permissions within a driver */\n\t\tsecurity_xperm_set(xperms->drivers.p,\n\t\t\t\t\tnode->datum.u.xperms->driver);\n\t}\n\n\t/* If no ioctl commands are allowed, ignore auditallow and auditdeny */\n\tif (node->key.specified & AVTAB_XPERMS_ALLOWED)\n\t\txperms->len = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "AVTAB_AUDITALLOW|AVTAB_ENABLED"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "AVTAB_AUDITDENY|AVTAB_ENABLED"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "AVTAB_ALLOWED|AVTAB_ENABLED"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avtab_search_node_next",
          "args": [
            "node",
            "key->specified"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_search_node_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "250-277",
          "snippet": "struct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nvoid cond_compute_av(struct avtab *ctab, struct avtab_key *key,\n\t\tstruct av_decision *avd, struct extended_perms *xperms)\n{\n\tstruct avtab_node *node;\n\n\tif (!ctab || !key || !avd)\n\t\treturn;\n\n\tfor (node = avtab_search_node(ctab, key); node;\n\t\t\t\tnode = avtab_search_node_next(node, key->specified)) {\n\t\tif ((u16)(AVTAB_ALLOWED|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_ALLOWED|AVTAB_ENABLED)))\n\t\t\tavd->allowed |= node->datum.u.data;\n\t\tif ((u16)(AVTAB_AUDITDENY|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_AUDITDENY|AVTAB_ENABLED)))\n\t\t\t/* Since a '0' in an auditdeny mask represents a\n\t\t\t * permission we do NOT want to audit (dontaudit), we use\n\t\t\t * the '&' operand to ensure that all '0's in the mask\n\t\t\t * are retained (much unlike the allow and auditallow cases).\n\t\t\t */\n\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\tif ((u16)(AVTAB_AUDITALLOW|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_AUDITALLOW|AVTAB_ENABLED)))\n\t\t\tavd->auditallow |= node->datum.u.data;\n\t\tif (xperms && (node->key.specified & AVTAB_ENABLED) &&\n\t\t\t\t(node->key.specified & AVTAB_XPERMS))\n\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t}\n}"
  },
  {
    "function_name": "cond_compute_xperms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "619-634",
    "snippet": "void cond_compute_xperms(struct avtab *ctab, struct avtab_key *key,\n\t\tstruct extended_perms_decision *xpermd)\n{\n\tstruct avtab_node *node;\n\n\tif (!ctab || !key || !xpermd)\n\t\treturn;\n\n\tfor (node = avtab_search_node(ctab, key); node;\n\t\t\tnode = avtab_search_node_next(node, key->specified)) {\n\t\tif (node->key.specified & AVTAB_ENABLED)\n\t\t\tservices_compute_xperms_decision(xpermd, node);\n\t}\n\treturn;\n\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "services_compute_xperms_decision",
          "args": [
            "xpermd",
            "node"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "services_compute_xperms_decision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "946-998",
          "snippet": "void services_compute_xperms_decision(struct extended_perms_decision *xpermd,\n\t\t\t\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\tif (xpermd->driver != node->datum.u.xperms->driver)\n\t\t\treturn;\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\tif (!security_xperm_test(node->datum.u.xperms->perms.p,\n\t\t\t\t\txpermd->driver))\n\t\t\treturn;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (node->key.specified == AVTAB_XPERMS_ALLOWED) {\n\t\txpermd->used |= XPERMS_ALLOWED;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->allowed->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->allowed->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->allowed->p); i++)\n\t\t\t\txpermd->allowed->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_AUDITALLOW) {\n\t\txpermd->used |= XPERMS_AUDITALLOW;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->auditallow->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->auditallow->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->auditallow->p); i++)\n\t\t\t\txpermd->auditallow->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_DONTAUDIT) {\n\t\txpermd->used |= XPERMS_DONTAUDIT;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->dontaudit->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->dontaudit->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->dontaudit->p); i++)\n\t\t\t\txpermd->dontaudit->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else {\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);",
            "static int security_preserve_bools(struct policydb *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);\nstatic int security_preserve_bools(struct policydb *p);\n\nvoid services_compute_xperms_decision(struct extended_perms_decision *xpermd,\n\t\t\t\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\tif (xpermd->driver != node->datum.u.xperms->driver)\n\t\t\treturn;\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\tif (!security_xperm_test(node->datum.u.xperms->perms.p,\n\t\t\t\t\txpermd->driver))\n\t\t\treturn;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (node->key.specified == AVTAB_XPERMS_ALLOWED) {\n\t\txpermd->used |= XPERMS_ALLOWED;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->allowed->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->allowed->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->allowed->p); i++)\n\t\t\t\txpermd->allowed->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_AUDITALLOW) {\n\t\txpermd->used |= XPERMS_AUDITALLOW;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->auditallow->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->auditallow->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->auditallow->p); i++)\n\t\t\t\txpermd->auditallow->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_DONTAUDIT) {\n\t\txpermd->used |= XPERMS_DONTAUDIT;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->dontaudit->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->dontaudit->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->dontaudit->p); i++)\n\t\t\t\txpermd->dontaudit->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else {\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "avtab_search_node_next",
          "args": [
            "node",
            "key->specified"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_search_node_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "250-277",
          "snippet": "struct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nvoid cond_compute_xperms(struct avtab *ctab, struct avtab_key *key,\n\t\tstruct extended_perms_decision *xpermd)\n{\n\tstruct avtab_node *node;\n\n\tif (!ctab || !key || !xpermd)\n\t\treturn;\n\n\tfor (node = avtab_search_node(ctab, key); node;\n\t\t\tnode = avtab_search_node_next(node, key->specified)) {\n\t\tif (node->key.specified & AVTAB_ENABLED)\n\t\t\tservices_compute_xperms_decision(xpermd, node);\n\t}\n\treturn;\n\n}"
  },
  {
    "function_name": "cond_write_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "595-617",
    "snippet": "int cond_write_list(struct policydb *p, struct cond_node *list, void *fp)\n{\n\tstruct cond_node *cur;\n\tu32 len;\n\t__le32 buf[1];\n\tint rc;\n\n\tlen = 0;\n\tfor (cur = list; cur != NULL; cur = cur->next)\n\t\tlen++;\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (cur = list; cur != NULL; cur = cur->next) {\n\t\trc = cond_write_node(p, cur, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_write_node",
          "args": [
            "p",
            "cur",
            "fp"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "cond_write_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "556-593",
          "snippet": "static int cond_write_node(struct policydb *p, struct cond_node *node,\n\t\t    struct policy_file *fp)\n{\n\tstruct cond_expr *cur_expr;\n\t__le32 buf[2];\n\tint rc;\n\tu32 len = 0;\n\n\tbuf[0] = cpu_to_le32(node->cur_state);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (cur_expr = node->expr; cur_expr != NULL; cur_expr = cur_expr->next)\n\t\tlen++;\n\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (cur_expr = node->expr; cur_expr != NULL; cur_expr = cur_expr->next) {\n\t\tbuf[0] = cpu_to_le32(cur_expr->expr_type);\n\t\tbuf[1] = cpu_to_le32(cur_expr->bool);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = cond_write_av_list(p, node->true_list, fp);\n\tif (rc)\n\t\treturn rc;\n\trc = cond_write_av_list(p, node->false_list, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int cond_write_node(struct policydb *p, struct cond_node *node,\n\t\t    struct policy_file *fp)\n{\n\tstruct cond_expr *cur_expr;\n\t__le32 buf[2];\n\tint rc;\n\tu32 len = 0;\n\n\tbuf[0] = cpu_to_le32(node->cur_state);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (cur_expr = node->expr; cur_expr != NULL; cur_expr = cur_expr->next)\n\t\tlen++;\n\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (cur_expr = node->expr; cur_expr != NULL; cur_expr = cur_expr->next) {\n\t\tbuf[0] = cpu_to_le32(cur_expr->expr_type);\n\t\tbuf[1] = cpu_to_le32(cur_expr->bool);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = cond_write_av_list(p, node->true_list, fp);\n\tif (rc)\n\t\treturn rc;\n\trc = cond_write_av_list(p, node->false_list, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "1",
            "fp"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint cond_write_list(struct policydb *p, struct cond_node *list, void *fp)\n{\n\tstruct cond_node *cur;\n\tu32 len;\n\t__le32 buf[1];\n\tint rc;\n\n\tlen = 0;\n\tfor (cur = list; cur != NULL; cur = cur->next)\n\t\tlen++;\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (cur = list; cur != NULL; cur = cur->next) {\n\t\trc = cond_write_node(p, cur, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cond_write_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "556-593",
    "snippet": "static int cond_write_node(struct policydb *p, struct cond_node *node,\n\t\t    struct policy_file *fp)\n{\n\tstruct cond_expr *cur_expr;\n\t__le32 buf[2];\n\tint rc;\n\tu32 len = 0;\n\n\tbuf[0] = cpu_to_le32(node->cur_state);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (cur_expr = node->expr; cur_expr != NULL; cur_expr = cur_expr->next)\n\t\tlen++;\n\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (cur_expr = node->expr; cur_expr != NULL; cur_expr = cur_expr->next) {\n\t\tbuf[0] = cpu_to_le32(cur_expr->expr_type);\n\t\tbuf[1] = cpu_to_le32(cur_expr->bool);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = cond_write_av_list(p, node->true_list, fp);\n\tif (rc)\n\t\treturn rc;\n\trc = cond_write_av_list(p, node->false_list, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_write_av_list",
          "args": [
            "p",
            "node->false_list",
            "fp"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "cond_write_av_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "527-554",
          "snippet": "static int cond_write_av_list(struct policydb *p,\n\t\t\t      struct cond_av_list *list, struct policy_file *fp)\n{\n\t__le32 buf[1];\n\tstruct cond_av_list *cur_list;\n\tu32 len;\n\tint rc;\n\n\tlen = 0;\n\tfor (cur_list = list; cur_list != NULL; cur_list = cur_list->next)\n\t\tlen++;\n\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tfor (cur_list = list; cur_list != NULL; cur_list = cur_list->next) {\n\t\trc = avtab_write_item(p, cur_list->node, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int cond_write_av_list(struct policydb *p,\n\t\t\t      struct cond_av_list *list, struct policy_file *fp)\n{\n\t__le32 buf[1];\n\tstruct cond_av_list *cur_list;\n\tu32 len;\n\tint rc;\n\n\tlen = 0;\n\tfor (cur_list = list; cur_list != NULL; cur_list = cur_list->next)\n\t\tlen++;\n\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tfor (cur_list = list; cur_list != NULL; cur_list = cur_list->next) {\n\t\trc = avtab_write_item(p, cur_list->node, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "2",
            "fp"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cur_expr->bool"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cur_expr->expr_type"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "node->cur_state"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int cond_write_node(struct policydb *p, struct cond_node *node,\n\t\t    struct policy_file *fp)\n{\n\tstruct cond_expr *cur_expr;\n\t__le32 buf[2];\n\tint rc;\n\tu32 len = 0;\n\n\tbuf[0] = cpu_to_le32(node->cur_state);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (cur_expr = node->expr; cur_expr != NULL; cur_expr = cur_expr->next)\n\t\tlen++;\n\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (cur_expr = node->expr; cur_expr != NULL; cur_expr = cur_expr->next) {\n\t\tbuf[0] = cpu_to_le32(cur_expr->expr_type);\n\t\tbuf[1] = cpu_to_le32(cur_expr->bool);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = cond_write_av_list(p, node->true_list, fp);\n\tif (rc)\n\t\treturn rc;\n\trc = cond_write_av_list(p, node->false_list, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cond_write_av_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "527-554",
    "snippet": "static int cond_write_av_list(struct policydb *p,\n\t\t\t      struct cond_av_list *list, struct policy_file *fp)\n{\n\t__le32 buf[1];\n\tstruct cond_av_list *cur_list;\n\tu32 len;\n\tint rc;\n\n\tlen = 0;\n\tfor (cur_list = list; cur_list != NULL; cur_list = cur_list->next)\n\t\tlen++;\n\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tfor (cur_list = list; cur_list != NULL; cur_list = cur_list->next) {\n\t\trc = avtab_write_item(p, cur_list->node, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "avtab_write_item",
          "args": [
            "p",
            "cur_list->node",
            "fp"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_write_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "600-633",
          "snippet": "int avtab_write_item(struct policydb *p, struct avtab_node *cur, void *fp)\n{\n\t__le16 buf16[4];\n\t__le32 buf32[ARRAY_SIZE(cur->datum.u.xperms->perms.p)];\n\tint rc;\n\tunsigned int i;\n\n\tbuf16[0] = cpu_to_le16(cur->key.source_type);\n\tbuf16[1] = cpu_to_le16(cur->key.target_type);\n\tbuf16[2] = cpu_to_le16(cur->key.target_class);\n\tbuf16[3] = cpu_to_le16(cur->key.specified);\n\trc = put_entry(buf16, sizeof(u16), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cur->key.specified & AVTAB_XPERMS) {\n\t\trc = put_entry(&cur->datum.u.xperms->specified, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = put_entry(&cur->datum.u.xperms->driver, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (i = 0; i < ARRAY_SIZE(cur->datum.u.xperms->perms.p); i++)\n\t\t\tbuf32[i] = cpu_to_le32(cur->datum.u.xperms->perms.p[i]);\n\t\trc = put_entry(buf32, sizeof(u32),\n\t\t\t\tARRAY_SIZE(cur->datum.u.xperms->perms.p), fp);\n\t} else {\n\t\tbuf32[0] = cpu_to_le32(cur->datum.u.data);\n\t\trc = put_entry(buf32, sizeof(u32), 1, fp);\n\t}\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint avtab_write_item(struct policydb *p, struct avtab_node *cur, void *fp)\n{\n\t__le16 buf16[4];\n\t__le32 buf32[ARRAY_SIZE(cur->datum.u.xperms->perms.p)];\n\tint rc;\n\tunsigned int i;\n\n\tbuf16[0] = cpu_to_le16(cur->key.source_type);\n\tbuf16[1] = cpu_to_le16(cur->key.target_type);\n\tbuf16[2] = cpu_to_le16(cur->key.target_class);\n\tbuf16[3] = cpu_to_le16(cur->key.specified);\n\trc = put_entry(buf16, sizeof(u16), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cur->key.specified & AVTAB_XPERMS) {\n\t\trc = put_entry(&cur->datum.u.xperms->specified, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = put_entry(&cur->datum.u.xperms->driver, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (i = 0; i < ARRAY_SIZE(cur->datum.u.xperms->perms.p); i++)\n\t\t\tbuf32[i] = cpu_to_le32(cur->datum.u.xperms->perms.p[i]);\n\t\trc = put_entry(buf32, sizeof(u32),\n\t\t\t\tARRAY_SIZE(cur->datum.u.xperms->perms.p), fp);\n\t} else {\n\t\tbuf32[0] = cpu_to_le32(cur->datum.u.data);\n\t\trc = put_entry(buf32, sizeof(u32), 1, fp);\n\t}\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "1",
            "fp"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int cond_write_av_list(struct policydb *p,\n\t\t\t      struct cond_av_list *list, struct policy_file *fp)\n{\n\t__le32 buf[1];\n\tstruct cond_av_list *cur_list;\n\tu32 len;\n\tint rc;\n\n\tlen = 0;\n\tfor (cur_list = list; cur_list != NULL; cur_list = cur_list->next)\n\t\tlen++;\n\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tfor (cur_list = list; cur_list != NULL; cur_list = cur_list->next) {\n\t\trc = avtab_write_item(p, cur_list->node, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cond_write_bool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "495-516",
    "snippet": "int cond_write_bool(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct cond_bool_datum *booldatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\t__le32 buf[3];\n\tu32 len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(booldatum->value);\n\tbuf[1] = cpu_to_le32(booldatum->state);\n\tbuf[2] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "key",
            "1",
            "len",
            "fp"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "booldatum->state"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "booldatum->value"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint cond_write_bool(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct cond_bool_datum *booldatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\t__le32 buf[3];\n\tu32 len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(booldatum->value);\n\tbuf[1] = cpu_to_le32(booldatum->state);\n\tbuf[2] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}"
  },
  {
    "function_name": "cond_read_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "455-493",
    "snippet": "int cond_read_list(struct policydb *p, void *fp)\n{\n\tstruct cond_node *node, *last = NULL;\n\t__le32 buf[1];\n\tu32 i, len;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\treturn rc;\n\n\tlen = le32_to_cpu(buf[0]);\n\n\trc = avtab_alloc(&(p->te_cond_avtab), p->te_avtab.nel);\n\tif (rc)\n\t\tgoto err;\n\n\tfor (i = 0; i < len; i++) {\n\t\trc = -ENOMEM;\n\t\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\t\tif (!node)\n\t\t\tgoto err;\n\n\t\trc = cond_read_node(p, node, fp);\n\t\tif (rc)\n\t\t\tgoto err;\n\n\t\tif (i == 0)\n\t\t\tp->cond_list = node;\n\t\telse\n\t\t\tlast->next = node;\n\t\tlast = node;\n\t}\n\treturn 0;\nerr:\n\tcond_list_destroy(p->cond_list);\n\tp->cond_list = NULL;\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_list_destroy",
          "args": [
            "p->cond_list"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "cond_list_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "156-167",
          "snippet": "static void cond_list_destroy(struct cond_node *list)\n{\n\tstruct cond_node *next, *cur;\n\n\tif (list == NULL)\n\t\treturn;\n\n\tfor (cur = list; cur; cur = next) {\n\t\tnext = cur->next;\n\t\tcond_node_destroy(cur);\n\t}\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void cond_list_destroy(struct cond_node *list)\n{\n\tstruct cond_node *next, *cur;\n\n\tif (list == NULL)\n\t\treturn;\n\n\tfor (cur = list; cur; cur = next) {\n\t\tnext = cur->next;\n\t\tcond_node_destroy(cur);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_read_node",
          "args": [
            "p",
            "node",
            "fp"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "cond_read_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "401-453",
          "snippet": "static int cond_read_node(struct policydb *p, struct cond_node *node, void *fp)\n{\n\t__le32 buf[2];\n\tu32 len, i;\n\tint rc;\n\tstruct cond_expr *expr = NULL, *last = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\tif (rc)\n\t\tgoto err;\n\n\tnode->cur_state = le32_to_cpu(buf[0]);\n\n\t/* expr */\n\tlen = le32_to_cpu(buf[1]);\n\n\tfor (i = 0; i < len; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\t\tif (rc)\n\t\t\tgoto err;\n\n\t\trc = -ENOMEM;\n\t\texpr = kzalloc(sizeof(*expr), GFP_KERNEL);\n\t\tif (!expr)\n\t\t\tgoto err;\n\n\t\texpr->expr_type = le32_to_cpu(buf[0]);\n\t\texpr->bool = le32_to_cpu(buf[1]);\n\n\t\tif (!expr_isvalid(p, expr)) {\n\t\t\trc = -EINVAL;\n\t\t\tkfree(expr);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (i == 0)\n\t\t\tnode->expr = expr;\n\t\telse\n\t\t\tlast->next = expr;\n\t\tlast = expr;\n\t}\n\n\trc = cond_read_av_list(p, fp, &node->true_list, NULL);\n\tif (rc)\n\t\tgoto err;\n\trc = cond_read_av_list(p, fp, &node->false_list, node->true_list);\n\tif (rc)\n\t\tgoto err;\n\treturn 0;\nerr:\n\tcond_node_destroy(node);\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int cond_read_node(struct policydb *p, struct cond_node *node, void *fp)\n{\n\t__le32 buf[2];\n\tu32 len, i;\n\tint rc;\n\tstruct cond_expr *expr = NULL, *last = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\tif (rc)\n\t\tgoto err;\n\n\tnode->cur_state = le32_to_cpu(buf[0]);\n\n\t/* expr */\n\tlen = le32_to_cpu(buf[1]);\n\n\tfor (i = 0; i < len; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\t\tif (rc)\n\t\t\tgoto err;\n\n\t\trc = -ENOMEM;\n\t\texpr = kzalloc(sizeof(*expr), GFP_KERNEL);\n\t\tif (!expr)\n\t\t\tgoto err;\n\n\t\texpr->expr_type = le32_to_cpu(buf[0]);\n\t\texpr->bool = le32_to_cpu(buf[1]);\n\n\t\tif (!expr_isvalid(p, expr)) {\n\t\t\trc = -EINVAL;\n\t\t\tkfree(expr);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (i == 0)\n\t\t\tnode->expr = expr;\n\t\telse\n\t\t\tlast->next = expr;\n\t\tlast = expr;\n\t}\n\n\trc = cond_read_av_list(p, fp, &node->true_list, NULL);\n\tif (rc)\n\t\tgoto err;\n\trc = cond_read_av_list(p, fp, &node->false_list, node->true_list);\n\tif (rc)\n\t\tgoto err;\n\treturn 0;\nerr:\n\tcond_node_destroy(node);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*node)",
            "GFP_KERNEL"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avtab_alloc",
          "args": [
            "&(p->te_cond_avtab)",
            "p->te_avtab.nel"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "311-344",
          "snippet": "int avtab_alloc(struct avtab *h, u32 nrules)\n{\n\tu32 mask = 0;\n\tu32 shift = 0;\n\tu32 work = nrules;\n\tu32 nslot = 0;\n\n\tif (nrules == 0)\n\t\tgoto avtab_alloc_out;\n\n\twhile (work) {\n\t\twork  = work >> 1;\n\t\tshift++;\n\t}\n\tif (shift > 2)\n\t\tshift = shift - 2;\n\tnslot = 1 << shift;\n\tif (nslot > MAX_AVTAB_HASH_BUCKETS)\n\t\tnslot = MAX_AVTAB_HASH_BUCKETS;\n\tmask = nslot - 1;\n\n\th->htable = flex_array_alloc(sizeof(struct avtab_node *), nslot,\n\t\t\t\t     GFP_KERNEL | __GFP_ZERO);\n\tif (!h->htable)\n\t\treturn -ENOMEM;\n\n avtab_alloc_out:\n\th->nel = 0;\n\th->nslot = nslot;\n\th->mask = mask;\n\tprintk(KERN_DEBUG \"SELinux: %d avtab hash slots, %d rules.\\n\",\n\t       h->nslot, nrules);\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint avtab_alloc(struct avtab *h, u32 nrules)\n{\n\tu32 mask = 0;\n\tu32 shift = 0;\n\tu32 work = nrules;\n\tu32 nslot = 0;\n\n\tif (nrules == 0)\n\t\tgoto avtab_alloc_out;\n\n\twhile (work) {\n\t\twork  = work >> 1;\n\t\tshift++;\n\t}\n\tif (shift > 2)\n\t\tshift = shift - 2;\n\tnslot = 1 << shift;\n\tif (nslot > MAX_AVTAB_HASH_BUCKETS)\n\t\tnslot = MAX_AVTAB_HASH_BUCKETS;\n\tmask = nslot - 1;\n\n\th->htable = flex_array_alloc(sizeof(struct avtab_node *), nslot,\n\t\t\t\t     GFP_KERNEL | __GFP_ZERO);\n\tif (!h->htable)\n\t\treturn -ENOMEM;\n\n avtab_alloc_out:\n\th->nel = 0;\n\th->nslot = nslot;\n\th->mask = mask;\n\tprintk(KERN_DEBUG \"SELinux: %d avtab hash slots, %d rules.\\n\",\n\t       h->nslot, nrules);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof buf"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint cond_read_list(struct policydb *p, void *fp)\n{\n\tstruct cond_node *node, *last = NULL;\n\t__le32 buf[1];\n\tu32 i, len;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\treturn rc;\n\n\tlen = le32_to_cpu(buf[0]);\n\n\trc = avtab_alloc(&(p->te_cond_avtab), p->te_avtab.nel);\n\tif (rc)\n\t\tgoto err;\n\n\tfor (i = 0; i < len; i++) {\n\t\trc = -ENOMEM;\n\t\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\t\tif (!node)\n\t\t\tgoto err;\n\n\t\trc = cond_read_node(p, node, fp);\n\t\tif (rc)\n\t\t\tgoto err;\n\n\t\tif (i == 0)\n\t\t\tp->cond_list = node;\n\t\telse\n\t\t\tlast->next = node;\n\t\tlast = node;\n\t}\n\treturn 0;\nerr:\n\tcond_list_destroy(p->cond_list);\n\tp->cond_list = NULL;\n\treturn rc;\n}"
  },
  {
    "function_name": "cond_read_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "401-453",
    "snippet": "static int cond_read_node(struct policydb *p, struct cond_node *node, void *fp)\n{\n\t__le32 buf[2];\n\tu32 len, i;\n\tint rc;\n\tstruct cond_expr *expr = NULL, *last = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\tif (rc)\n\t\tgoto err;\n\n\tnode->cur_state = le32_to_cpu(buf[0]);\n\n\t/* expr */\n\tlen = le32_to_cpu(buf[1]);\n\n\tfor (i = 0; i < len; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\t\tif (rc)\n\t\t\tgoto err;\n\n\t\trc = -ENOMEM;\n\t\texpr = kzalloc(sizeof(*expr), GFP_KERNEL);\n\t\tif (!expr)\n\t\t\tgoto err;\n\n\t\texpr->expr_type = le32_to_cpu(buf[0]);\n\t\texpr->bool = le32_to_cpu(buf[1]);\n\n\t\tif (!expr_isvalid(p, expr)) {\n\t\t\trc = -EINVAL;\n\t\t\tkfree(expr);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (i == 0)\n\t\t\tnode->expr = expr;\n\t\telse\n\t\t\tlast->next = expr;\n\t\tlast = expr;\n\t}\n\n\trc = cond_read_av_list(p, fp, &node->true_list, NULL);\n\tif (rc)\n\t\tgoto err;\n\trc = cond_read_av_list(p, fp, &node->false_list, node->true_list);\n\tif (rc)\n\t\tgoto err;\n\treturn 0;\nerr:\n\tcond_node_destroy(node);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_node_destroy",
          "args": [
            "node"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "cond_node_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "143-154",
          "snippet": "static void cond_node_destroy(struct cond_node *node)\n{\n\tstruct cond_expr *cur_expr, *next_expr;\n\n\tfor (cur_expr = node->expr; cur_expr; cur_expr = next_expr) {\n\t\tnext_expr = cur_expr->next;\n\t\tkfree(cur_expr);\n\t}\n\tcond_av_list_destroy(node->true_list);\n\tcond_av_list_destroy(node->false_list);\n\tkfree(node);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void cond_node_destroy(struct cond_node *node)\n{\n\tstruct cond_expr *cur_expr, *next_expr;\n\n\tfor (cur_expr = node->expr; cur_expr; cur_expr = next_expr) {\n\t\tnext_expr = cur_expr->next;\n\t\tkfree(cur_expr);\n\t}\n\tcond_av_list_destroy(node->true_list);\n\tcond_av_list_destroy(node->false_list);\n\tkfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_read_av_list",
          "args": [
            "p",
            "fp",
            "&node->false_list",
            "node->true_list"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "cond_read_av_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "355-385",
          "snippet": "static int cond_read_av_list(struct policydb *p, void *fp, struct cond_av_list **ret_list, struct cond_av_list *other)\n{\n\tint i, rc;\n\t__le32 buf[1];\n\tu32 len;\n\tstruct cond_insertf_data data;\n\n\t*ret_list = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\n\tlen = le32_to_cpu(buf[0]);\n\tif (len == 0)\n\t\treturn 0;\n\n\tdata.p = p;\n\tdata.other = other;\n\tdata.head = NULL;\n\tdata.tail = NULL;\n\tfor (i = 0; i < len; i++) {\n\t\trc = avtab_read_item(&p->te_cond_avtab, fp, p, cond_insertf,\n\t\t\t\t     &data);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t*ret_list = data.head;\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int cond_read_av_list(struct policydb *p, void *fp, struct cond_av_list **ret_list, struct cond_av_list *other)\n{\n\tint i, rc;\n\t__le32 buf[1];\n\tu32 len;\n\tstruct cond_insertf_data data;\n\n\t*ret_list = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\n\tlen = le32_to_cpu(buf[0]);\n\tif (len == 0)\n\t\treturn 0;\n\n\tdata.p = p;\n\tdata.other = other;\n\tdata.head = NULL;\n\tdata.tail = NULL;\n\tfor (i = 0; i < len; i++) {\n\t\trc = avtab_read_item(&p->te_cond_avtab, fp, p, cond_insertf,\n\t\t\t\t     &data);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t*ret_list = data.head;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "expr"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr_isvalid",
          "args": [
            "p",
            "expr"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "expr_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "387-399",
          "snippet": "static int expr_isvalid(struct policydb *p, struct cond_expr *expr)\n{\n\tif (expr->expr_type <= 0 || expr->expr_type > COND_LAST) {\n\t\tprintk(KERN_ERR \"SELinux: conditional expressions uses unknown operator.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (expr->bool > p->p_bools.nprim) {\n\t\tprintk(KERN_ERR \"SELinux: conditional expressions uses unknown bool.\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int expr_isvalid(struct policydb *p, struct cond_expr *expr)\n{\n\tif (expr->expr_type <= 0 || expr->expr_type > COND_LAST) {\n\t\tprintk(KERN_ERR \"SELinux: conditional expressions uses unknown operator.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (expr->bool > p->p_bools.nprim) {\n\t\tprintk(KERN_ERR \"SELinux: conditional expressions uses unknown bool.\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*expr)",
            "GFP_KERNEL"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(u32) * 2"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int cond_read_node(struct policydb *p, struct cond_node *node, void *fp)\n{\n\t__le32 buf[2];\n\tu32 len, i;\n\tint rc;\n\tstruct cond_expr *expr = NULL, *last = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\tif (rc)\n\t\tgoto err;\n\n\tnode->cur_state = le32_to_cpu(buf[0]);\n\n\t/* expr */\n\tlen = le32_to_cpu(buf[1]);\n\n\tfor (i = 0; i < len; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\t\tif (rc)\n\t\t\tgoto err;\n\n\t\trc = -ENOMEM;\n\t\texpr = kzalloc(sizeof(*expr), GFP_KERNEL);\n\t\tif (!expr)\n\t\t\tgoto err;\n\n\t\texpr->expr_type = le32_to_cpu(buf[0]);\n\t\texpr->bool = le32_to_cpu(buf[1]);\n\n\t\tif (!expr_isvalid(p, expr)) {\n\t\t\trc = -EINVAL;\n\t\t\tkfree(expr);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (i == 0)\n\t\t\tnode->expr = expr;\n\t\telse\n\t\t\tlast->next = expr;\n\t\tlast = expr;\n\t}\n\n\trc = cond_read_av_list(p, fp, &node->true_list, NULL);\n\tif (rc)\n\t\tgoto err;\n\trc = cond_read_av_list(p, fp, &node->false_list, node->true_list);\n\tif (rc)\n\t\tgoto err;\n\treturn 0;\nerr:\n\tcond_node_destroy(node);\n\treturn rc;\n}"
  },
  {
    "function_name": "expr_isvalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "387-399",
    "snippet": "static int expr_isvalid(struct policydb *p, struct cond_expr *expr)\n{\n\tif (expr->expr_type <= 0 || expr->expr_type > COND_LAST) {\n\t\tprintk(KERN_ERR \"SELinux: conditional expressions uses unknown operator.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (expr->bool > p->p_bools.nprim) {\n\t\tprintk(KERN_ERR \"SELinux: conditional expressions uses unknown bool.\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: conditional expressions uses unknown bool.\\n\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: conditional expressions uses unknown operator.\\n\""
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int expr_isvalid(struct policydb *p, struct cond_expr *expr)\n{\n\tif (expr->expr_type <= 0 || expr->expr_type > COND_LAST) {\n\t\tprintk(KERN_ERR \"SELinux: conditional expressions uses unknown operator.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (expr->bool > p->p_bools.nprim) {\n\t\tprintk(KERN_ERR \"SELinux: conditional expressions uses unknown bool.\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "cond_read_av_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "355-385",
    "snippet": "static int cond_read_av_list(struct policydb *p, void *fp, struct cond_av_list **ret_list, struct cond_av_list *other)\n{\n\tint i, rc;\n\t__le32 buf[1];\n\tu32 len;\n\tstruct cond_insertf_data data;\n\n\t*ret_list = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\n\tlen = le32_to_cpu(buf[0]);\n\tif (len == 0)\n\t\treturn 0;\n\n\tdata.p = p;\n\tdata.other = other;\n\tdata.head = NULL;\n\tdata.tail = NULL;\n\tfor (i = 0; i < len; i++) {\n\t\trc = avtab_read_item(&p->te_cond_avtab, fp, p, cond_insertf,\n\t\t\t\t     &data);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t*ret_list = data.head;\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "avtab_read_item",
          "args": [
            "&p->te_cond_avtab",
            "fp",
            "p",
            "cond_insertf",
            "&data"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_read_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "389-548",
          "snippet": "int avtab_read_item(struct avtab *a, void *fp, struct policydb *pol,\n\t\t    int (*insertf)(struct avtab *a, struct avtab_key *k,\n\t\t\t\t   struct avtab_datum *d, void *p),\n\t\t    void *p)\n{\n\t__le16 buf16[4];\n\tu16 enabled;\n\tu32 items, items2, val, vers = pol->policyvers;\n\tstruct avtab_key key;\n\tstruct avtab_datum datum;\n\tstruct avtab_extended_perms xperms;\n\t__le32 buf32[ARRAY_SIZE(xperms.perms.p)];\n\tint i, rc;\n\tunsigned set;\n\n\tmemset(&key, 0, sizeof(struct avtab_key));\n\tmemset(&datum, 0, sizeof(struct avtab_datum));\n\n\tif (vers < POLICYDB_VERSION_AVTAB) {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems2 = le32_to_cpu(buf32[0]);\n\t\tif (items2 > ARRAY_SIZE(buf32)) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry overflow\\n\");\n\t\t\treturn -EINVAL;\n\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*items2);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems = 0;\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.source_type = (u16)val;\n\t\tif (key.source_type != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated source type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_type = (u16)val;\n\t\tif (key.target_type != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated target type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_class = (u16)val;\n\t\tif (key.target_class != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated target class\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tenabled = (val & AVTAB_ENABLED_OLD) ? AVTAB_ENABLED : 0;\n\n\t\tif (!(val & (AVTAB_AV | AVTAB_TYPE))) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: null entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((val & AVTAB_AV) &&\n\t\t    (val & AVTAB_TYPE)) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry has both access vectors and types\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (val & AVTAB_XPERMS) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry has extended permissions\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\t\tif (val & spec_order[i]) {\n\t\t\t\tkey.specified = spec_order[i] | enabled;\n\t\t\t\tdatum.u.data = le32_to_cpu(buf32[items++]);\n\t\t\t\trc = insertf(a, &key, &datum, p);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (items != items2) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry only had %d items, expected %d\\n\", items2, items);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\trc = next_entry(buf16, fp, sizeof(u16)*4);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\treturn rc;\n\t}\n\n\titems = 0;\n\tkey.source_type = le16_to_cpu(buf16[items++]);\n\tkey.target_type = le16_to_cpu(buf16[items++]);\n\tkey.target_class = le16_to_cpu(buf16[items++]);\n\tkey.specified = le16_to_cpu(buf16[items++]);\n\n\tif (!policydb_type_isvalid(pol, key.source_type) ||\n\t    !policydb_type_isvalid(pol, key.target_type) ||\n\t    !policydb_class_isvalid(pol, key.target_class)) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: invalid type or class\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tset = 0;\n\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\tif (key.specified & spec_order[i])\n\t\t\tset++;\n\t}\n\tif (!set || set > 1) {\n\t\tprintk(KERN_ERR \"SELinux:  avtab:  more than one specifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((vers < POLICYDB_VERSION_XPERMS_IOCTL) &&\n\t\t\t(key.specified & AVTAB_XPERMS)) {\n\t\tprintk(KERN_ERR \"SELinux:  avtab:  policy version %u does not \"\n\t\t\t\t\"support extended permissions rules and one \"\n\t\t\t\t\"was specified\\n\", vers);\n\t\treturn -EINVAL;\n\t} else if (key.specified & AVTAB_XPERMS) {\n\t\tmemset(&xperms, 0, sizeof(struct avtab_extended_perms));\n\t\trc = next_entry(&xperms.specified, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(&xperms.driver, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*ARRAY_SIZE(xperms.perms.p));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(xperms.perms.p); i++)\n\t\t\txperms.perms.p[i] = le32_to_cpu(buf32[i]);\n\t\tdatum.u.xperms = &xperms;\n\t} else {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tdatum.u.data = le32_to_cpu(*buf32);\n\t}\n\tif ((key.specified & AVTAB_TYPE) &&\n\t    !policydb_type_isvalid(pol, datum.u.data)) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: invalid type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn insertf(a, &key, &datum, p);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static uint16_t spec_order[] = {\n\tAVTAB_ALLOWED,\n\tAVTAB_AUDITDENY,\n\tAVTAB_AUDITALLOW,\n\tAVTAB_TRANSITION,\n\tAVTAB_CHANGE,\n\tAVTAB_MEMBER,\n\tAVTAB_XPERMS_ALLOWED,\n\tAVTAB_XPERMS_AUDITALLOW,\n\tAVTAB_XPERMS_DONTAUDIT\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic uint16_t spec_order[] = {\n\tAVTAB_ALLOWED,\n\tAVTAB_AUDITDENY,\n\tAVTAB_AUDITALLOW,\n\tAVTAB_TRANSITION,\n\tAVTAB_CHANGE,\n\tAVTAB_MEMBER,\n\tAVTAB_XPERMS_ALLOWED,\n\tAVTAB_XPERMS_AUDITALLOW,\n\tAVTAB_XPERMS_DONTAUDIT\n};\n\nint avtab_read_item(struct avtab *a, void *fp, struct policydb *pol,\n\t\t    int (*insertf)(struct avtab *a, struct avtab_key *k,\n\t\t\t\t   struct avtab_datum *d, void *p),\n\t\t    void *p)\n{\n\t__le16 buf16[4];\n\tu16 enabled;\n\tu32 items, items2, val, vers = pol->policyvers;\n\tstruct avtab_key key;\n\tstruct avtab_datum datum;\n\tstruct avtab_extended_perms xperms;\n\t__le32 buf32[ARRAY_SIZE(xperms.perms.p)];\n\tint i, rc;\n\tunsigned set;\n\n\tmemset(&key, 0, sizeof(struct avtab_key));\n\tmemset(&datum, 0, sizeof(struct avtab_datum));\n\n\tif (vers < POLICYDB_VERSION_AVTAB) {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems2 = le32_to_cpu(buf32[0]);\n\t\tif (items2 > ARRAY_SIZE(buf32)) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry overflow\\n\");\n\t\t\treturn -EINVAL;\n\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*items2);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems = 0;\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.source_type = (u16)val;\n\t\tif (key.source_type != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated source type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_type = (u16)val;\n\t\tif (key.target_type != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated target type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_class = (u16)val;\n\t\tif (key.target_class != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated target class\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tenabled = (val & AVTAB_ENABLED_OLD) ? AVTAB_ENABLED : 0;\n\n\t\tif (!(val & (AVTAB_AV | AVTAB_TYPE))) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: null entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((val & AVTAB_AV) &&\n\t\t    (val & AVTAB_TYPE)) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry has both access vectors and types\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (val & AVTAB_XPERMS) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry has extended permissions\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\t\tif (val & spec_order[i]) {\n\t\t\t\tkey.specified = spec_order[i] | enabled;\n\t\t\t\tdatum.u.data = le32_to_cpu(buf32[items++]);\n\t\t\t\trc = insertf(a, &key, &datum, p);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (items != items2) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry only had %d items, expected %d\\n\", items2, items);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\trc = next_entry(buf16, fp, sizeof(u16)*4);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\treturn rc;\n\t}\n\n\titems = 0;\n\tkey.source_type = le16_to_cpu(buf16[items++]);\n\tkey.target_type = le16_to_cpu(buf16[items++]);\n\tkey.target_class = le16_to_cpu(buf16[items++]);\n\tkey.specified = le16_to_cpu(buf16[items++]);\n\n\tif (!policydb_type_isvalid(pol, key.source_type) ||\n\t    !policydb_type_isvalid(pol, key.target_type) ||\n\t    !policydb_class_isvalid(pol, key.target_class)) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: invalid type or class\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tset = 0;\n\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\tif (key.specified & spec_order[i])\n\t\t\tset++;\n\t}\n\tif (!set || set > 1) {\n\t\tprintk(KERN_ERR \"SELinux:  avtab:  more than one specifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((vers < POLICYDB_VERSION_XPERMS_IOCTL) &&\n\t\t\t(key.specified & AVTAB_XPERMS)) {\n\t\tprintk(KERN_ERR \"SELinux:  avtab:  policy version %u does not \"\n\t\t\t\t\"support extended permissions rules and one \"\n\t\t\t\t\"was specified\\n\", vers);\n\t\treturn -EINVAL;\n\t} else if (key.specified & AVTAB_XPERMS) {\n\t\tmemset(&xperms, 0, sizeof(struct avtab_extended_perms));\n\t\trc = next_entry(&xperms.specified, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(&xperms.driver, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*ARRAY_SIZE(xperms.perms.p));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(xperms.perms.p); i++)\n\t\t\txperms.perms.p[i] = le32_to_cpu(buf32[i]);\n\t\tdatum.u.xperms = &xperms;\n\t} else {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tdatum.u.data = le32_to_cpu(*buf32);\n\t}\n\tif ((key.specified & AVTAB_TYPE) &&\n\t    !policydb_type_isvalid(pol, datum.u.data)) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: invalid type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn insertf(a, &key, &datum, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(u32)"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int cond_read_av_list(struct policydb *p, void *fp, struct cond_av_list **ret_list, struct cond_av_list *other)\n{\n\tint i, rc;\n\t__le32 buf[1];\n\tu32 len;\n\tstruct cond_insertf_data data;\n\n\t*ret_list = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\n\tlen = le32_to_cpu(buf[0]);\n\tif (len == 0)\n\t\treturn 0;\n\n\tdata.p = p;\n\tdata.other = other;\n\tdata.head = NULL;\n\tdata.tail = NULL;\n\tfor (i = 0; i < len; i++) {\n\t\trc = avtab_read_item(&p->te_cond_avtab, fp, p, cond_insertf,\n\t\t\t\t     &data);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t*ret_list = data.head;\n\treturn 0;\n}"
  },
  {
    "function_name": "cond_insertf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "274-353",
    "snippet": "static int cond_insertf(struct avtab *a, struct avtab_key *k, struct avtab_datum *d, void *ptr)\n{\n\tstruct cond_insertf_data *data = ptr;\n\tstruct policydb *p = data->p;\n\tstruct cond_av_list *other = data->other, *list, *cur;\n\tstruct avtab_node *node_ptr;\n\tu8 found;\n\tint rc = -EINVAL;\n\n\t/*\n\t * For type rules we have to make certain there aren't any\n\t * conflicting rules by searching the te_avtab and the\n\t * cond_te_avtab.\n\t */\n\tif (k->specified & AVTAB_TYPE) {\n\t\tif (avtab_search(&p->te_avtab, k)) {\n\t\t\tprintk(KERN_ERR \"SELinux: type rule already exists outside of a conditional.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * If we are reading the false list other will be a pointer to\n\t\t * the true list. We can have duplicate entries if there is only\n\t\t * 1 other entry and it is in our true list.\n\t\t *\n\t\t * If we are reading the true list (other == NULL) there shouldn't\n\t\t * be any other entries.\n\t\t */\n\t\tif (other) {\n\t\t\tnode_ptr = avtab_search_node(&p->te_cond_avtab, k);\n\t\t\tif (node_ptr) {\n\t\t\t\tif (avtab_search_node_next(node_ptr, k->specified)) {\n\t\t\t\t\tprintk(KERN_ERR \"SELinux: too many conflicting type rules.\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tfound = 0;\n\t\t\t\tfor (cur = other; cur; cur = cur->next) {\n\t\t\t\t\tif (cur->node == node_ptr) {\n\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tprintk(KERN_ERR \"SELinux: conflicting type rules.\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (avtab_search(&p->te_cond_avtab, k)) {\n\t\t\t\tprintk(KERN_ERR \"SELinux: conflicting type rules when adding type rule for true.\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tnode_ptr = avtab_insert_nonunique(&p->te_cond_avtab, k, d);\n\tif (!node_ptr) {\n\t\tprintk(KERN_ERR \"SELinux: could not insert rule.\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tlist = kzalloc(sizeof(*list), GFP_KERNEL);\n\tif (!list) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tlist->node = node_ptr;\n\tif (!data->head)\n\t\tdata->head = list;\n\telse\n\t\tdata->tail->next = list;\n\tdata->tail = list;\n\treturn 0;\n\nerr:\n\tcond_av_list_destroy(data->head);\n\tdata->head = NULL;\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_av_list_destroy",
          "args": [
            "data->head"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "cond_av_list_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "133-141",
          "snippet": "static void cond_av_list_destroy(struct cond_av_list *list)\n{\n\tstruct cond_av_list *cur, *next;\n\tfor (cur = list; cur; cur = next) {\n\t\tnext = cur->next;\n\t\t/* the avtab_ptr_t node is destroy by the avtab */\n\t\tkfree(cur);\n\t}\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void cond_av_list_destroy(struct cond_av_list *list)\n{\n\tstruct cond_av_list *cur, *next;\n\tfor (cur = list; cur; cur = next) {\n\t\tnext = cur->next;\n\t\t/* the avtab_ptr_t node is destroy by the avtab */\n\t\tkfree(cur);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*list)",
            "GFP_KERNEL"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: could not insert rule.\\n\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avtab_insert_nonunique",
          "args": [
            "&p->te_cond_avtab",
            "k",
            "d"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_insert_nonunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "152-181",
          "snippet": "struct avtab_node *\navtab_insert_nonunique(struct avtab *h, struct avtab_key *key, struct avtab_datum *datum)\n{\n\tint hvalue;\n\tstruct avtab_node *prev, *cur;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->htable)\n\t\treturn NULL;\n\thvalue = avtab_hash(key, h->mask);\n\tfor (prev = NULL, cur = flex_array_get_ptr(h->htable, hvalue);\n\t     cur;\n\t     prev = cur, cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\tbreak;\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn avtab_insert_node(h, hvalue, prev, cur, key, datum);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct avtab_node *\navtab_insert_nonunique(struct avtab *h, struct avtab_key *key, struct avtab_datum *datum)\n{\n\tint hvalue;\n\tstruct avtab_node *prev, *cur;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->htable)\n\t\treturn NULL;\n\thvalue = avtab_hash(key, h->mask);\n\tfor (prev = NULL, cur = flex_array_get_ptr(h->htable, hvalue);\n\t     cur;\n\t     prev = cur, cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\tbreak;\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn avtab_insert_node(h, hvalue, prev, cur, key, datum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: conflicting type rules when adding type rule for true.\\n\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avtab_search",
          "args": [
            "&p->te_cond_avtab",
            "k"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_search_node_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "250-277",
          "snippet": "struct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: conflicting type rules.\\n\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: too many conflicting type rules.\\n\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: type rule already exists outside of a conditional.\\n\""
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int cond_insertf(struct avtab *a, struct avtab_key *k, struct avtab_datum *d, void *ptr)\n{\n\tstruct cond_insertf_data *data = ptr;\n\tstruct policydb *p = data->p;\n\tstruct cond_av_list *other = data->other, *list, *cur;\n\tstruct avtab_node *node_ptr;\n\tu8 found;\n\tint rc = -EINVAL;\n\n\t/*\n\t * For type rules we have to make certain there aren't any\n\t * conflicting rules by searching the te_avtab and the\n\t * cond_te_avtab.\n\t */\n\tif (k->specified & AVTAB_TYPE) {\n\t\tif (avtab_search(&p->te_avtab, k)) {\n\t\t\tprintk(KERN_ERR \"SELinux: type rule already exists outside of a conditional.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * If we are reading the false list other will be a pointer to\n\t\t * the true list. We can have duplicate entries if there is only\n\t\t * 1 other entry and it is in our true list.\n\t\t *\n\t\t * If we are reading the true list (other == NULL) there shouldn't\n\t\t * be any other entries.\n\t\t */\n\t\tif (other) {\n\t\t\tnode_ptr = avtab_search_node(&p->te_cond_avtab, k);\n\t\t\tif (node_ptr) {\n\t\t\t\tif (avtab_search_node_next(node_ptr, k->specified)) {\n\t\t\t\t\tprintk(KERN_ERR \"SELinux: too many conflicting type rules.\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tfound = 0;\n\t\t\t\tfor (cur = other; cur; cur = cur->next) {\n\t\t\t\t\tif (cur->node == node_ptr) {\n\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tprintk(KERN_ERR \"SELinux: conflicting type rules.\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (avtab_search(&p->te_cond_avtab, k)) {\n\t\t\t\tprintk(KERN_ERR \"SELinux: conflicting type rules when adding type rule for true.\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tnode_ptr = avtab_insert_nonunique(&p->te_cond_avtab, k, d);\n\tif (!node_ptr) {\n\t\tprintk(KERN_ERR \"SELinux: could not insert rule.\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tlist = kzalloc(sizeof(*list), GFP_KERNEL);\n\tif (!list) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tlist->node = node_ptr;\n\tif (!data->head)\n\t\tdata->head = list;\n\telse\n\t\tdata->tail->next = list;\n\tdata->tail = list;\n\treturn 0;\n\nerr:\n\tcond_av_list_destroy(data->head);\n\tdata->head = NULL;\n\treturn rc;\n}"
  },
  {
    "function_name": "cond_read_bool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "222-265",
    "snippet": "int cond_read_bool(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct cond_bool_datum *booldatum;\n\t__le32 buf[3];\n\tu32 len;\n\tint rc;\n\n\tbooldatum = kzalloc(sizeof(*booldatum), GFP_KERNEL);\n\tif (!booldatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto err;\n\n\tbooldatum->value = le32_to_cpu(buf[0]);\n\tbooldatum->state = le32_to_cpu(buf[1]);\n\n\trc = -EINVAL;\n\tif (!bool_isvalid(booldatum))\n\t\tgoto err;\n\n\tlen = le32_to_cpu(buf[2]);\n\tif (((len == 0) || (len == (u32)-1)))\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\tkey = kmalloc(len + 1, GFP_KERNEL);\n\tif (!key)\n\t\tgoto err;\n\trc = next_entry(key, fp, len);\n\tif (rc)\n\t\tgoto err;\n\tkey[len] = '\\0';\n\trc = hashtab_insert(h, key, booldatum);\n\tif (rc)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tcond_destroy_bool(key, booldatum, NULL);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_destroy_bool",
          "args": [
            "key",
            "booldatum",
            "NULL"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "cond_destroy_bool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "187-192",
          "snippet": "int cond_destroy_bool(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint cond_destroy_bool(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_insert",
          "args": [
            "h",
            "key",
            "booldatum"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "42-78",
          "snippet": "int hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "key",
            "fp",
            "len"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool_isvalid",
          "args": [
            "booldatum"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "bool_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "215-220",
          "snippet": "static int bool_isvalid(struct cond_bool_datum *b)\n{\n\tif (!(b->state == 0 || b->state == 1))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int bool_isvalid(struct cond_bool_datum *b)\n{\n\tif (!(b->state == 0 || b->state == 1))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*booldatum)",
            "GFP_KERNEL"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint cond_read_bool(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct cond_bool_datum *booldatum;\n\t__le32 buf[3];\n\tu32 len;\n\tint rc;\n\n\tbooldatum = kzalloc(sizeof(*booldatum), GFP_KERNEL);\n\tif (!booldatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto err;\n\n\tbooldatum->value = le32_to_cpu(buf[0]);\n\tbooldatum->state = le32_to_cpu(buf[1]);\n\n\trc = -EINVAL;\n\tif (!bool_isvalid(booldatum))\n\t\tgoto err;\n\n\tlen = le32_to_cpu(buf[2]);\n\tif (((len == 0) || (len == (u32)-1)))\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\tkey = kmalloc(len + 1, GFP_KERNEL);\n\tif (!key)\n\t\tgoto err;\n\trc = next_entry(key, fp, len);\n\tif (rc)\n\t\tgoto err;\n\tkey[len] = '\\0';\n\trc = hashtab_insert(h, key, booldatum);\n\tif (rc)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tcond_destroy_bool(key, booldatum, NULL);\n\treturn rc;\n}"
  },
  {
    "function_name": "bool_isvalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "215-220",
    "snippet": "static int bool_isvalid(struct cond_bool_datum *b)\n{\n\tif (!(b->state == 0 || b->state == 1))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int bool_isvalid(struct cond_bool_datum *b)\n{\n\tif (!(b->state == 0 || b->state == 1))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "cond_index_bool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "194-213",
    "snippet": "int cond_index_bool(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct cond_bool_datum *booldatum;\n\tstruct flex_array *fa;\n\n\tbooldatum = datum;\n\tp = datap;\n\n\tif (!booldatum->value || booldatum->value > p->p_bools.nprim)\n\t\treturn -EINVAL;\n\n\tfa = p->sym_val_to_name[SYM_BOOLS];\n\tif (flex_array_put_ptr(fa, booldatum->value - 1, key,\n\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\tBUG();\n\tp->bool_val_to_struct[booldatum->value - 1] = booldatum;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_put_ptr",
          "args": [
            "fa",
            "booldatum->value - 1",
            "key",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint cond_index_bool(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct cond_bool_datum *booldatum;\n\tstruct flex_array *fa;\n\n\tbooldatum = datum;\n\tp = datap;\n\n\tif (!booldatum->value || booldatum->value > p->p_bools.nprim)\n\t\treturn -EINVAL;\n\n\tfa = p->sym_val_to_name[SYM_BOOLS];\n\tif (flex_array_put_ptr(fa, booldatum->value - 1, key,\n\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\tBUG();\n\tp->bool_val_to_struct[booldatum->value - 1] = booldatum;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cond_destroy_bool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "187-192",
    "snippet": "int cond_destroy_bool(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "datum"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint cond_destroy_bool(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}"
  },
  {
    "function_name": "cond_init_bool_indexes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "176-185",
    "snippet": "int cond_init_bool_indexes(struct policydb *p)\n{\n\tkfree(p->bool_val_to_struct);\n\tp->bool_val_to_struct = kmalloc_array(p->p_bools.nprim,\n\t\t\t\t\t      sizeof(*p->bool_val_to_struct),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!p->bool_val_to_struct)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "p->p_bools.nprim",
            "sizeof(*p->bool_val_to_struct)",
            "GFP_KERNEL"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p->bool_val_to_struct"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint cond_init_bool_indexes(struct policydb *p)\n{\n\tkfree(p->bool_val_to_struct);\n\tp->bool_val_to_struct = kmalloc_array(p->p_bools.nprim,\n\t\t\t\t\t      sizeof(*p->bool_val_to_struct),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!p->bool_val_to_struct)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "cond_policydb_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "169-174",
    "snippet": "void cond_policydb_destroy(struct policydb *p)\n{\n\tkfree(p->bool_val_to_struct);\n\tavtab_destroy(&p->te_cond_avtab);\n\tcond_list_destroy(p->cond_list);\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_list_destroy",
          "args": [
            "p->cond_list"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "cond_list_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "156-167",
          "snippet": "static void cond_list_destroy(struct cond_node *list)\n{\n\tstruct cond_node *next, *cur;\n\n\tif (list == NULL)\n\t\treturn;\n\n\tfor (cur = list; cur; cur = next) {\n\t\tnext = cur->next;\n\t\tcond_node_destroy(cur);\n\t}\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void cond_list_destroy(struct cond_node *list)\n{\n\tstruct cond_node *next, *cur;\n\n\tif (list == NULL)\n\t\treturn;\n\n\tfor (cur = list; cur; cur = next) {\n\t\tnext = cur->next;\n\t\tcond_node_destroy(cur);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "avtab_destroy",
          "args": [
            "&p->te_cond_avtab"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "279-302",
          "snippet": "void avtab_destroy(struct avtab *h)\n{\n\tint i;\n\tstruct avtab_node *cur, *temp;\n\n\tif (!h || !h->htable)\n\t\treturn;\n\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tif (temp->key.specified & AVTAB_XPERMS)\n\t\t\t\tkmem_cache_free(avtab_xperms_cachep,\n\t\t\t\t\t\ttemp->datum.u.xperms);\n\t\t\tkmem_cache_free(avtab_node_cachep, temp);\n\t\t}\n\t}\n\tflex_array_free(h->htable);\n\th->htable = NULL;\n\th->nslot = 0;\n\th->mask = 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avtab_node_cachep;",
            "static struct kmem_cache *avtab_xperms_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *avtab_node_cachep;\nstatic struct kmem_cache *avtab_xperms_cachep;\n\nvoid avtab_destroy(struct avtab *h)\n{\n\tint i;\n\tstruct avtab_node *cur, *temp;\n\n\tif (!h || !h->htable)\n\t\treturn;\n\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tif (temp->key.specified & AVTAB_XPERMS)\n\t\t\t\tkmem_cache_free(avtab_xperms_cachep,\n\t\t\t\t\t\ttemp->datum.u.xperms);\n\t\t\tkmem_cache_free(avtab_node_cachep, temp);\n\t\t}\n\t}\n\tflex_array_free(h->htable);\n\th->htable = NULL;\n\th->nslot = 0;\n\th->mask = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p->bool_val_to_struct"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nvoid cond_policydb_destroy(struct policydb *p)\n{\n\tkfree(p->bool_val_to_struct);\n\tavtab_destroy(&p->te_cond_avtab);\n\tcond_list_destroy(p->cond_list);\n}"
  },
  {
    "function_name": "cond_list_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "156-167",
    "snippet": "static void cond_list_destroy(struct cond_node *list)\n{\n\tstruct cond_node *next, *cur;\n\n\tif (list == NULL)\n\t\treturn;\n\n\tfor (cur = list; cur; cur = next) {\n\t\tnext = cur->next;\n\t\tcond_node_destroy(cur);\n\t}\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_node_destroy",
          "args": [
            "cur"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "cond_node_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "143-154",
          "snippet": "static void cond_node_destroy(struct cond_node *node)\n{\n\tstruct cond_expr *cur_expr, *next_expr;\n\n\tfor (cur_expr = node->expr; cur_expr; cur_expr = next_expr) {\n\t\tnext_expr = cur_expr->next;\n\t\tkfree(cur_expr);\n\t}\n\tcond_av_list_destroy(node->true_list);\n\tcond_av_list_destroy(node->false_list);\n\tkfree(node);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void cond_node_destroy(struct cond_node *node)\n{\n\tstruct cond_expr *cur_expr, *next_expr;\n\n\tfor (cur_expr = node->expr; cur_expr; cur_expr = next_expr) {\n\t\tnext_expr = cur_expr->next;\n\t\tkfree(cur_expr);\n\t}\n\tcond_av_list_destroy(node->true_list);\n\tcond_av_list_destroy(node->false_list);\n\tkfree(node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void cond_list_destroy(struct cond_node *list)\n{\n\tstruct cond_node *next, *cur;\n\n\tif (list == NULL)\n\t\treturn;\n\n\tfor (cur = list; cur; cur = next) {\n\t\tnext = cur->next;\n\t\tcond_node_destroy(cur);\n\t}\n}"
  },
  {
    "function_name": "cond_node_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "143-154",
    "snippet": "static void cond_node_destroy(struct cond_node *node)\n{\n\tstruct cond_expr *cur_expr, *next_expr;\n\n\tfor (cur_expr = node->expr; cur_expr; cur_expr = next_expr) {\n\t\tnext_expr = cur_expr->next;\n\t\tkfree(cur_expr);\n\t}\n\tcond_av_list_destroy(node->true_list);\n\tcond_av_list_destroy(node->false_list);\n\tkfree(node);\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_av_list_destroy",
          "args": [
            "node->false_list"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "cond_av_list_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "133-141",
          "snippet": "static void cond_av_list_destroy(struct cond_av_list *list)\n{\n\tstruct cond_av_list *cur, *next;\n\tfor (cur = list; cur; cur = next) {\n\t\tnext = cur->next;\n\t\t/* the avtab_ptr_t node is destroy by the avtab */\n\t\tkfree(cur);\n\t}\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void cond_av_list_destroy(struct cond_av_list *list)\n{\n\tstruct cond_av_list *cur, *next;\n\tfor (cur = list; cur; cur = next) {\n\t\tnext = cur->next;\n\t\t/* the avtab_ptr_t node is destroy by the avtab */\n\t\tkfree(cur);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cur_expr"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void cond_node_destroy(struct cond_node *node)\n{\n\tstruct cond_expr *cur_expr, *next_expr;\n\n\tfor (cur_expr = node->expr; cur_expr; cur_expr = next_expr) {\n\t\tnext_expr = cur_expr->next;\n\t\tkfree(cur_expr);\n\t}\n\tcond_av_list_destroy(node->true_list);\n\tcond_av_list_destroy(node->false_list);\n\tkfree(node);\n}"
  },
  {
    "function_name": "cond_av_list_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "133-141",
    "snippet": "static void cond_av_list_destroy(struct cond_av_list *list)\n{\n\tstruct cond_av_list *cur, *next;\n\tfor (cur = list; cur; cur = next) {\n\t\tnext = cur->next;\n\t\t/* the avtab_ptr_t node is destroy by the avtab */\n\t\tkfree(cur);\n\t}\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cur"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic void cond_av_list_destroy(struct cond_av_list *list)\n{\n\tstruct cond_av_list *cur, *next;\n\tfor (cur = list; cur; cur = next) {\n\t\tnext = cur->next;\n\t\t/* the avtab_ptr_t node is destroy by the avtab */\n\t\tkfree(cur);\n\t}\n}"
  },
  {
    "function_name": "cond_policydb_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "119-131",
    "snippet": "int cond_policydb_init(struct policydb *p)\n{\n\tint rc;\n\n\tp->bool_val_to_struct = NULL;\n\tp->cond_list = NULL;\n\n\trc = avtab_init(&p->te_cond_avtab);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "avtab_init",
          "args": [
            "&p->te_cond_avtab"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "304-309",
          "snippet": "int avtab_init(struct avtab *h)\n{\n\th->htable = NULL;\n\th->nel = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint avtab_init(struct avtab *h)\n{\n\th->htable = NULL;\n\th->nel = 0;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint cond_policydb_init(struct policydb *p)\n{\n\tint rc;\n\n\tp->bool_val_to_struct = NULL;\n\tp->cond_list = NULL;\n\n\trc = avtab_init(&p->te_cond_avtab);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "evaluate_cond_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "90-117",
    "snippet": "int evaluate_cond_node(struct policydb *p, struct cond_node *node)\n{\n\tint new_state;\n\tstruct cond_av_list *cur;\n\n\tnew_state = cond_evaluate_expr(p, node->expr);\n\tif (new_state != node->cur_state) {\n\t\tnode->cur_state = new_state;\n\t\tif (new_state == -1)\n\t\t\tprintk(KERN_ERR \"SELinux: expression result was undefined - disabling all rules.\\n\");\n\t\t/* turn the rules on or off */\n\t\tfor (cur = node->true_list; cur; cur = cur->next) {\n\t\t\tif (new_state <= 0)\n\t\t\t\tcur->node->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tcur->node->key.specified |= AVTAB_ENABLED;\n\t\t}\n\n\t\tfor (cur = node->false_list; cur; cur = cur->next) {\n\t\t\t/* -1 or 1 */\n\t\t\tif (new_state)\n\t\t\t\tcur->node->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tcur->node->key.specified |= AVTAB_ENABLED;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: expression result was undefined - disabling all rules.\\n\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_evaluate_expr",
          "args": [
            "p",
            "node->expr"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "cond_evaluate_expr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "26-81",
          "snippet": "static int cond_evaluate_expr(struct policydb *p, struct cond_expr *expr)\n{\n\n\tstruct cond_expr *cur;\n\tint s[COND_EXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tfor (cur = expr; cur; cur = cur->next) {\n\t\tswitch (cur->expr_type) {\n\t\tcase COND_BOOL:\n\t\t\tif (sp == (COND_EXPR_MAXDEPTH - 1))\n\t\t\t\treturn -1;\n\t\t\tsp++;\n\t\t\ts[sp] = p->bool_val_to_struct[cur->bool - 1]->state;\n\t\t\tbreak;\n\t\tcase COND_NOT:\n\t\t\tif (sp < 0)\n\t\t\t\treturn -1;\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase COND_OR:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_AND:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_XOR:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] ^= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_EQ:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] = (s[sp] == s[sp + 1]);\n\t\t\tbreak;\n\t\tcase COND_NEQ:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] = (s[sp] != s[sp + 1]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn s[0];\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int cond_evaluate_expr(struct policydb *p, struct cond_expr *expr)\n{\n\n\tstruct cond_expr *cur;\n\tint s[COND_EXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tfor (cur = expr; cur; cur = cur->next) {\n\t\tswitch (cur->expr_type) {\n\t\tcase COND_BOOL:\n\t\t\tif (sp == (COND_EXPR_MAXDEPTH - 1))\n\t\t\t\treturn -1;\n\t\t\tsp++;\n\t\t\ts[sp] = p->bool_val_to_struct[cur->bool - 1]->state;\n\t\t\tbreak;\n\t\tcase COND_NOT:\n\t\t\tif (sp < 0)\n\t\t\t\treturn -1;\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase COND_OR:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_AND:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_XOR:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] ^= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_EQ:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] = (s[sp] == s[sp + 1]);\n\t\t\tbreak;\n\t\tcase COND_NEQ:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] = (s[sp] != s[sp + 1]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn s[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint evaluate_cond_node(struct policydb *p, struct cond_node *node)\n{\n\tint new_state;\n\tstruct cond_av_list *cur;\n\n\tnew_state = cond_evaluate_expr(p, node->expr);\n\tif (new_state != node->cur_state) {\n\t\tnode->cur_state = new_state;\n\t\tif (new_state == -1)\n\t\t\tprintk(KERN_ERR \"SELinux: expression result was undefined - disabling all rules.\\n\");\n\t\t/* turn the rules on or off */\n\t\tfor (cur = node->true_list; cur; cur = cur->next) {\n\t\t\tif (new_state <= 0)\n\t\t\t\tcur->node->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tcur->node->key.specified |= AVTAB_ENABLED;\n\t\t}\n\n\t\tfor (cur = node->false_list; cur; cur = cur->next) {\n\t\t\t/* -1 or 1 */\n\t\t\tif (new_state)\n\t\t\t\tcur->node->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tcur->node->key.specified |= AVTAB_ENABLED;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cond_evaluate_expr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
    "lines": "26-81",
    "snippet": "static int cond_evaluate_expr(struct policydb *p, struct cond_expr *expr)\n{\n\n\tstruct cond_expr *cur;\n\tint s[COND_EXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tfor (cur = expr; cur; cur = cur->next) {\n\t\tswitch (cur->expr_type) {\n\t\tcase COND_BOOL:\n\t\t\tif (sp == (COND_EXPR_MAXDEPTH - 1))\n\t\t\t\treturn -1;\n\t\t\tsp++;\n\t\t\ts[sp] = p->bool_val_to_struct[cur->bool - 1]->state;\n\t\t\tbreak;\n\t\tcase COND_NOT:\n\t\t\tif (sp < 0)\n\t\t\t\treturn -1;\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase COND_OR:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_AND:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_XOR:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] ^= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_EQ:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] = (s[sp] == s[sp + 1]);\n\t\t\tbreak;\n\t\tcase COND_NEQ:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] = (s[sp] != s[sp + 1]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn s[0];\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"conditional.h\"",
      "#include \"security.h\"",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nstatic int cond_evaluate_expr(struct policydb *p, struct cond_expr *expr)\n{\n\n\tstruct cond_expr *cur;\n\tint s[COND_EXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tfor (cur = expr; cur; cur = cur->next) {\n\t\tswitch (cur->expr_type) {\n\t\tcase COND_BOOL:\n\t\t\tif (sp == (COND_EXPR_MAXDEPTH - 1))\n\t\t\t\treturn -1;\n\t\t\tsp++;\n\t\t\ts[sp] = p->bool_val_to_struct[cur->bool - 1]->state;\n\t\t\tbreak;\n\t\tcase COND_NOT:\n\t\t\tif (sp < 0)\n\t\t\t\treturn -1;\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase COND_OR:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_AND:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_XOR:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] ^= s[sp + 1];\n\t\t\tbreak;\n\t\tcase COND_EQ:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] = (s[sp] == s[sp + 1]);\n\t\t\tbreak;\n\t\tcase COND_NEQ:\n\t\t\tif (sp < 1)\n\t\t\t\treturn -1;\n\t\t\tsp--;\n\t\t\ts[sp] = (s[sp] != s[sp + 1]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn s[0];\n}"
  }
]