[
  {
    "function_name": "ima_d_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
    "lines": "349-369",
    "snippet": "const char *ima_d_path(const struct path *path, char **pathbuf, char *namebuf)\n{\n\tchar *pathname = NULL;\n\n\t*pathbuf = __getname();\n\tif (*pathbuf) {\n\t\tpathname = d_absolute_path(path, *pathbuf, PATH_MAX);\n\t\tif (IS_ERR(pathname)) {\n\t\t\t__putname(*pathbuf);\n\t\t\t*pathbuf = NULL;\n\t\t\tpathname = NULL;\n\t\t}\n\t}\n\n\tif (!pathname) {\n\t\tstrlcpy(namebuf, path->dentry->d_name.name, NAME_MAX);\n\t\tpathname = namebuf;\n\t}\n\n\treturn pathname;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "namebuf",
            "path->dentry->d_name.name",
            "NAME_MAX"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "*pathbuf"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pathname"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_absolute_path",
          "args": [
            "path",
            "*pathbuf",
            "PATH_MAX"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getname",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nconst char *ima_d_path(const struct path *path, char **pathbuf, char *namebuf)\n{\n\tchar *pathname = NULL;\n\n\t*pathbuf = __getname();\n\tif (*pathbuf) {\n\t\tpathname = d_absolute_path(path, *pathbuf, PATH_MAX);\n\t\tif (IS_ERR(pathname)) {\n\t\t\t__putname(*pathbuf);\n\t\t\t*pathbuf = NULL;\n\t\t\tpathname = NULL;\n\t\t}\n\t}\n\n\tif (!pathname) {\n\t\tstrlcpy(namebuf, path->dentry->d_name.name, NAME_MAX);\n\t\tpathname = namebuf;\n\t}\n\n\treturn pathname;\n}"
  },
  {
    "function_name": "ima_audit_measurement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
    "lines": "306-337",
    "snippet": "void ima_audit_measurement(struct integrity_iint_cache *iint,\n\t\t\t   const unsigned char *filename)\n{\n\tstruct audit_buffer *ab;\n\tchar hash[(iint->ima_hash->length * 2) + 1];\n\tconst char *algo_name = hash_algo_name[iint->ima_hash->algo];\n\tchar algo_hash[sizeof(hash) + strlen(algo_name) + 2];\n\tint i;\n\n\tif (iint->flags & IMA_AUDITED)\n\t\treturn;\n\n\tfor (i = 0; i < iint->ima_hash->length; i++)\n\t\thex_byte_pack(hash + (i * 2), iint->ima_hash->digest[i]);\n\thash[i * 2] = '\\0';\n\n\tab = audit_log_start(current->audit_context, GFP_KERNEL,\n\t\t\t     AUDIT_INTEGRITY_RULE);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"file=\");\n\taudit_log_untrustedstring(ab, filename);\n\taudit_log_format(ab, \" hash=\");\n\tsnprintf(algo_hash, sizeof(algo_hash), \"%s:%s\", algo_name, hash);\n\taudit_log_untrustedstring(ab, algo_hash);\n\n\taudit_log_task_info(ab, current);\n\taudit_log_end(ab);\n\n\tiint->flags |= IMA_AUDITED;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_task_info",
          "args": [
            "ab",
            "current"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "algo_hash"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "algo_hash",
            "sizeof(algo_hash)",
            "\"%s:%s\"",
            "algo_name",
            "hash"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" hash=\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "filename"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"file=\""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "current->audit_context",
            "GFP_KERNEL",
            "AUDIT_INTEGRITY_RULE"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_byte_pack",
          "args": [
            "hash + (i * 2)",
            "iint->ima_hash->digest[i]"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "algo_name"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid ima_audit_measurement(struct integrity_iint_cache *iint,\n\t\t\t   const unsigned char *filename)\n{\n\tstruct audit_buffer *ab;\n\tchar hash[(iint->ima_hash->length * 2) + 1];\n\tconst char *algo_name = hash_algo_name[iint->ima_hash->algo];\n\tchar algo_hash[sizeof(hash) + strlen(algo_name) + 2];\n\tint i;\n\n\tif (iint->flags & IMA_AUDITED)\n\t\treturn;\n\n\tfor (i = 0; i < iint->ima_hash->length; i++)\n\t\thex_byte_pack(hash + (i * 2), iint->ima_hash->digest[i]);\n\thash[i * 2] = '\\0';\n\n\tab = audit_log_start(current->audit_context, GFP_KERNEL,\n\t\t\t     AUDIT_INTEGRITY_RULE);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"file=\");\n\taudit_log_untrustedstring(ab, filename);\n\taudit_log_format(ab, \" hash=\");\n\tsnprintf(algo_hash, sizeof(algo_hash), \"%s:%s\", algo_name, hash);\n\taudit_log_untrustedstring(ab, algo_hash);\n\n\taudit_log_task_info(ab, current);\n\taudit_log_end(ab);\n\n\tiint->flags |= IMA_AUDITED;\n}"
  },
  {
    "function_name": "ima_store_measurement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
    "lines": "273-304",
    "snippet": "void ima_store_measurement(struct integrity_iint_cache *iint,\n\t\t\t   struct file *file, const unsigned char *filename,\n\t\t\t   struct evm_ima_xattr_data *xattr_value,\n\t\t\t   int xattr_len, int pcr)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"ENOMEM\";\n\tint result = -ENOMEM;\n\tstruct inode *inode = file_inode(file);\n\tstruct ima_template_entry *entry;\n\tstruct ima_event_data event_data = {iint, file, filename, xattr_value,\n\t\t\t\t\t    xattr_len, NULL};\n\tint violation = 0;\n\n\tif (iint->measured_pcrs & (0x1 << pcr))\n\t\treturn;\n\n\tresult = ima_alloc_init_template(&event_data, &entry);\n\tif (result < 0) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t\t    op, audit_cause, result, 0);\n\t\treturn;\n\t}\n\n\tresult = ima_store_template(entry, violation, inode, filename, pcr);\n\tif ((!result || result == -EEXIST) && !(file->f_flags & O_DIRECT)) {\n\t\tiint->flags |= IMA_MEASURED;\n\t\tiint->measured_pcrs |= (0x1 << pcr);\n\t}\n\tif (result < 0)\n\t\tima_free_template_entry(entry);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_free_template_entry",
          "args": [
            "entry"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "ima_free_template_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "27-35",
          "snippet": "void ima_free_template_entry(struct ima_template_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < entry->template_desc->num_fields; i++)\n\t\tkfree(entry->template_data[i].data);\n\n\tkfree(entry);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid ima_free_template_entry(struct ima_template_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < entry->template_desc->num_fields; i++)\n\t\tkfree(entry->template_data[i].data);\n\n\tkfree(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_store_template",
          "args": [
            "entry",
            "violation",
            "inode",
            "filename",
            "pcr"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ima_store_template",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "88-120",
          "snippet": "int ima_store_template(struct ima_template_entry *entry,\n\t\t       int violation, struct inode *inode,\n\t\t       const unsigned char *filename, int pcr)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"hashing_error\";\n\tchar *template_name = entry->template_desc->name;\n\tint result;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[TPM_DIGEST_SIZE];\n\t} hash;\n\n\tif (!violation) {\n\t\tint num_fields = entry->template_desc->num_fields;\n\n\t\t/* this function uses default algo */\n\t\thash.hdr.algo = HASH_ALGO_SHA1;\n\t\tresult = ima_calc_field_array_hash(&entry->template_data[0],\n\t\t\t\t\t\t   entry->template_desc,\n\t\t\t\t\t\t   num_fields, &hash.hdr);\n\t\tif (result < 0) {\n\t\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,\n\t\t\t\t\t    template_name, op,\n\t\t\t\t\t    audit_cause, result, 0);\n\t\t\treturn result;\n\t\t}\n\t\tmemcpy(entry->digest, hash.hdr.digest, hash.hdr.length);\n\t}\n\tentry->pcr = pcr;\n\tresult = ima_add_template_entry(entry, violation, op, inode, filename);\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint ima_store_template(struct ima_template_entry *entry,\n\t\t       int violation, struct inode *inode,\n\t\t       const unsigned char *filename, int pcr)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"hashing_error\";\n\tchar *template_name = entry->template_desc->name;\n\tint result;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[TPM_DIGEST_SIZE];\n\t} hash;\n\n\tif (!violation) {\n\t\tint num_fields = entry->template_desc->num_fields;\n\n\t\t/* this function uses default algo */\n\t\thash.hdr.algo = HASH_ALGO_SHA1;\n\t\tresult = ima_calc_field_array_hash(&entry->template_data[0],\n\t\t\t\t\t\t   entry->template_desc,\n\t\t\t\t\t\t   num_fields, &hash.hdr);\n\t\tif (result < 0) {\n\t\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,\n\t\t\t\t\t    template_name, op,\n\t\t\t\t\t    audit_cause, result, 0);\n\t\t\treturn result;\n\t\t}\n\t\tmemcpy(entry->digest, hash.hdr.digest, hash.hdr.length);\n\t}\n\tentry->pcr = pcr;\n\tresult = ima_add_template_entry(entry, violation, op, inode, filename);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "integrity_audit_msg",
          "args": [
            "AUDIT_INTEGRITY_PCR",
            "inode",
            "filename",
            "op",
            "audit_cause",
            "result",
            "0"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "183-188",
          "snippet": "static inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct integrity_iint_cache *integrity_iint_find(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode);\n\nstatic inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_alloc_init_template",
          "args": [
            "&event_data",
            "&entry"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ima_alloc_init_template",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "40-70",
          "snippet": "int ima_alloc_init_template(struct ima_event_data *event_data,\n\t\t\t    struct ima_template_entry **entry)\n{\n\tstruct ima_template_desc *template_desc = ima_template_desc_current();\n\tint i, result = 0;\n\n\t*entry = kzalloc(sizeof(**entry) + template_desc->num_fields *\n\t\t\t sizeof(struct ima_field_data), GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tstruct ima_template_field *field = template_desc->fields[i];\n\t\tu32 len;\n\n\t\tresult = field->field_init(event_data,\n\t\t\t\t\t   &((*entry)->template_data[i]));\n\t\tif (result != 0)\n\t\t\tgoto out;\n\n\t\tlen = (*entry)->template_data[i].len;\n\t\t(*entry)->template_data_len += sizeof(len);\n\t\t(*entry)->template_data_len += len;\n\t}\n\treturn 0;\nout:\n\tima_free_template_entry(*entry);\n\t*entry = NULL;\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint ima_alloc_init_template(struct ima_event_data *event_data,\n\t\t\t    struct ima_template_entry **entry)\n{\n\tstruct ima_template_desc *template_desc = ima_template_desc_current();\n\tint i, result = 0;\n\n\t*entry = kzalloc(sizeof(**entry) + template_desc->num_fields *\n\t\t\t sizeof(struct ima_field_data), GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tstruct ima_template_field *field = template_desc->fields[i];\n\t\tu32 len;\n\n\t\tresult = field->field_init(event_data,\n\t\t\t\t\t   &((*entry)->template_data[i]));\n\t\tif (result != 0)\n\t\t\tgoto out;\n\n\t\tlen = (*entry)->template_data[i].len;\n\t\t(*entry)->template_data_len += sizeof(len);\n\t\t(*entry)->template_data_len += len;\n\t}\n\treturn 0;\nout:\n\tima_free_template_entry(*entry);\n\t*entry = NULL;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid ima_store_measurement(struct integrity_iint_cache *iint,\n\t\t\t   struct file *file, const unsigned char *filename,\n\t\t\t   struct evm_ima_xattr_data *xattr_value,\n\t\t\t   int xattr_len, int pcr)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"ENOMEM\";\n\tint result = -ENOMEM;\n\tstruct inode *inode = file_inode(file);\n\tstruct ima_template_entry *entry;\n\tstruct ima_event_data event_data = {iint, file, filename, xattr_value,\n\t\t\t\t\t    xattr_len, NULL};\n\tint violation = 0;\n\n\tif (iint->measured_pcrs & (0x1 << pcr))\n\t\treturn;\n\n\tresult = ima_alloc_init_template(&event_data, &entry);\n\tif (result < 0) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t\t    op, audit_cause, result, 0);\n\t\treturn;\n\t}\n\n\tresult = ima_store_template(entry, violation, inode, filename, pcr);\n\tif ((!result || result == -EEXIST) && !(file->f_flags & O_DIRECT)) {\n\t\tiint->flags |= IMA_MEASURED;\n\t\tiint->measured_pcrs |= (0x1 << pcr);\n\t}\n\tif (result < 0)\n\t\tima_free_template_entry(entry);\n}"
  },
  {
    "function_name": "ima_collect_measurement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
    "lines": "194-256",
    "snippet": "int ima_collect_measurement(struct integrity_iint_cache *iint,\n\t\t\t    struct file *file, void *buf, loff_t size,\n\t\t\t    enum hash_algo algo)\n{\n\tconst char *audit_cause = \"failed\";\n\tstruct inode *inode = file_inode(file);\n\tconst char *filename = file->f_path.dentry->d_name.name;\n\tint result = 0;\n\tint length;\n\tvoid *tmpbuf;\n\tu64 i_version;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[IMA_MAX_DIGEST_SIZE];\n\t} hash;\n\n\tif (iint->flags & IMA_COLLECTED)\n\t\tgoto out;\n\n\t/*\n\t * Dectecting file change is based on i_version. On filesystems\n\t * which do not support i_version, support is limited to an initial\n\t * measurement/appraisal/audit.\n\t */\n\ti_version = file_inode(file)->i_version;\n\thash.hdr.algo = algo;\n\n\t/* Initialize hash digest to 0's in case of failure */\n\tmemset(&hash.digest, 0, sizeof(hash.digest));\n\n\tif (buf)\n\t\tresult = ima_calc_buffer_hash(buf, size, &hash.hdr);\n\telse\n\t\tresult = ima_calc_file_hash(file, &hash.hdr);\n\n\tif (result && result != -EBADF && result != -EINVAL)\n\t\tgoto out;\n\n\tlength = sizeof(hash.hdr) + hash.hdr.length;\n\ttmpbuf = krealloc(iint->ima_hash, length, GFP_NOFS);\n\tif (!tmpbuf) {\n\t\tresult = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tiint->ima_hash = tmpbuf;\n\tmemcpy(iint->ima_hash, &hash, length);\n\tiint->version = i_version;\n\n\t/* Possibly temporary failure due to type of read (eg. O_DIRECT) */\n\tif (!result)\n\t\tiint->flags |= IMA_COLLECTED;\nout:\n\tif (result) {\n\t\tif (file->f_flags & O_DIRECT)\n\t\t\taudit_cause = \"failed(directio)\";\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,\n\t\t\t\t    filename, \"collect_data\", audit_cause,\n\t\t\t\t    result, 0);\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "integrity_audit_msg",
          "args": [
            "AUDIT_INTEGRITY_DATA",
            "inode",
            "filename",
            "\"collect_data\"",
            "audit_cause",
            "result",
            "0"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "183-188",
          "snippet": "static inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct integrity_iint_cache *integrity_iint_find(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode);\n\nstatic inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iint->ima_hash",
            "&hash",
            "length"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krealloc",
          "args": [
            "iint->ima_hash",
            "length",
            "GFP_NOFS"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_calc_file_hash",
          "args": [
            "file",
            "&hash.hdr"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "ima_calc_file_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "417-441",
          "snippet": "int ima_calc_file_hash(struct file *file, struct ima_digest_data *hash)\n{\n\tloff_t i_size;\n\tint rc;\n\n\t/*\n\t * For consistency, fail file's opened with the O_DIRECT flag on\n\t * filesystems mounted with/without DAX option.\n\t */\n\tif (file->f_flags & O_DIRECT) {\n\t\thash->length = hash_digest_size[ima_hash_algo];\n\t\thash->algo = ima_hash_algo;\n\t\treturn -EINVAL;\n\t}\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (ima_ahash_minsize && i_size >= ima_ahash_minsize) {\n\t\trc = ima_calc_file_ahash(file, hash);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\treturn ima_calc_file_shash(file, hash);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long ima_ahash_minsize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic unsigned long ima_ahash_minsize;\n\nint ima_calc_file_hash(struct file *file, struct ima_digest_data *hash)\n{\n\tloff_t i_size;\n\tint rc;\n\n\t/*\n\t * For consistency, fail file's opened with the O_DIRECT flag on\n\t * filesystems mounted with/without DAX option.\n\t */\n\tif (file->f_flags & O_DIRECT) {\n\t\thash->length = hash_digest_size[ima_hash_algo];\n\t\thash->algo = ima_hash_algo;\n\t\treturn -EINVAL;\n\t}\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (ima_ahash_minsize && i_size >= ima_ahash_minsize) {\n\t\trc = ima_calc_file_ahash(file, hash);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\treturn ima_calc_file_shash(file, hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_calc_buffer_hash",
          "args": [
            "buf",
            "size",
            "&hash.hdr"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "ima_calc_buffer_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "616-628",
          "snippet": "int ima_calc_buffer_hash(const void *buf, loff_t len,\n\t\t\t struct ima_digest_data *hash)\n{\n\tint rc;\n\n\tif (ima_ahash_minsize && len >= ima_ahash_minsize) {\n\t\trc = calc_buffer_ahash(buf, len, hash);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\treturn calc_buffer_shash(buf, len, hash);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long ima_ahash_minsize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic unsigned long ima_ahash_minsize;\n\nint ima_calc_buffer_hash(const void *buf, loff_t len,\n\t\t\t struct ima_digest_data *hash)\n{\n\tint rc;\n\n\tif (ima_ahash_minsize && len >= ima_ahash_minsize) {\n\t\trc = calc_buffer_ahash(buf, len, hash);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\treturn calc_buffer_shash(buf, len, hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hash.digest",
            "0",
            "sizeof(hash.digest)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint ima_collect_measurement(struct integrity_iint_cache *iint,\n\t\t\t    struct file *file, void *buf, loff_t size,\n\t\t\t    enum hash_algo algo)\n{\n\tconst char *audit_cause = \"failed\";\n\tstruct inode *inode = file_inode(file);\n\tconst char *filename = file->f_path.dentry->d_name.name;\n\tint result = 0;\n\tint length;\n\tvoid *tmpbuf;\n\tu64 i_version;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[IMA_MAX_DIGEST_SIZE];\n\t} hash;\n\n\tif (iint->flags & IMA_COLLECTED)\n\t\tgoto out;\n\n\t/*\n\t * Dectecting file change is based on i_version. On filesystems\n\t * which do not support i_version, support is limited to an initial\n\t * measurement/appraisal/audit.\n\t */\n\ti_version = file_inode(file)->i_version;\n\thash.hdr.algo = algo;\n\n\t/* Initialize hash digest to 0's in case of failure */\n\tmemset(&hash.digest, 0, sizeof(hash.digest));\n\n\tif (buf)\n\t\tresult = ima_calc_buffer_hash(buf, size, &hash.hdr);\n\telse\n\t\tresult = ima_calc_file_hash(file, &hash.hdr);\n\n\tif (result && result != -EBADF && result != -EINVAL)\n\t\tgoto out;\n\n\tlength = sizeof(hash.hdr) + hash.hdr.length;\n\ttmpbuf = krealloc(iint->ima_hash, length, GFP_NOFS);\n\tif (!tmpbuf) {\n\t\tresult = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tiint->ima_hash = tmpbuf;\n\tmemcpy(iint->ima_hash, &hash, length);\n\tiint->version = i_version;\n\n\t/* Possibly temporary failure due to type of read (eg. O_DIRECT) */\n\tif (!result)\n\t\tiint->flags |= IMA_COLLECTED;\nout:\n\tif (result) {\n\t\tif (file->f_flags & O_DIRECT)\n\t\t\taudit_cause = \"failed(directio)\";\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,\n\t\t\t\t    filename, \"collect_data\", audit_cause,\n\t\t\t\t    result, 0);\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "ima_get_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
    "lines": "175-182",
    "snippet": "int ima_get_action(struct inode *inode, int mask, enum ima_hooks func, int *pcr)\n{\n\tint flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE;\n\n\tflags &= ima_policy_flag;\n\n\treturn ima_match_policy(inode, func, mask, flags, pcr);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_match_policy",
          "args": [
            "inode",
            "func",
            "mask",
            "flags",
            "pcr"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "ima_match_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "365-400",
          "snippet": "int ima_match_policy(struct inode *inode, enum ima_hooks func, int mask,\n\t\t     int flags, int *pcr)\n{\n\tstruct ima_rule_entry *entry;\n\tint action = 0, actmask = flags | (flags << 1);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, ima_rules, list) {\n\n\t\tif (!(entry->action & actmask))\n\t\t\tcontinue;\n\n\t\tif (!ima_match_rules(entry, inode, func, mask))\n\t\t\tcontinue;\n\n\t\taction |= entry->flags & IMA_ACTION_FLAGS;\n\n\t\taction |= entry->action & IMA_DO_MASK;\n\t\tif (entry->action & IMA_APPRAISE)\n\t\t\taction |= get_subaction(entry, func);\n\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tactmask &= ~(entry->action | entry->action << 1);\n\t\telse\n\t\t\tactmask &= ~(entry->action | entry->action >> 1);\n\n\t\tif ((pcr) && (entry->flags & IMA_PCR))\n\t\t\t*pcr = entry->pcr;\n\n\t\tif (!actmask)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn action;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define IMA_PCR\t\t0x0100"
          ],
          "globals_used": [
            "static struct list_head *ima_rules;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define IMA_PCR\t\t0x0100\n\nstatic struct list_head *ima_rules;\n\nint ima_match_policy(struct inode *inode, enum ima_hooks func, int mask,\n\t\t     int flags, int *pcr)\n{\n\tstruct ima_rule_entry *entry;\n\tint action = 0, actmask = flags | (flags << 1);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, ima_rules, list) {\n\n\t\tif (!(entry->action & actmask))\n\t\t\tcontinue;\n\n\t\tif (!ima_match_rules(entry, inode, func, mask))\n\t\t\tcontinue;\n\n\t\taction |= entry->flags & IMA_ACTION_FLAGS;\n\n\t\taction |= entry->action & IMA_DO_MASK;\n\t\tif (entry->action & IMA_APPRAISE)\n\t\t\taction |= get_subaction(entry, func);\n\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tactmask &= ~(entry->action | entry->action << 1);\n\t\telse\n\t\t\tactmask &= ~(entry->action | entry->action >> 1);\n\n\t\tif ((pcr) && (entry->flags & IMA_PCR))\n\t\t\t*pcr = entry->pcr;\n\n\t\tif (!actmask)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn action;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint ima_get_action(struct inode *inode, int mask, enum ima_hooks func, int *pcr)\n{\n\tint flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE;\n\n\tflags &= ima_policy_flag;\n\n\treturn ima_match_policy(inode, func, mask, flags, pcr);\n}"
  },
  {
    "function_name": "ima_add_violation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
    "lines": "129-155",
    "snippet": "void ima_add_violation(struct file *file, const unsigned char *filename,\n\t\t       struct integrity_iint_cache *iint,\n\t\t       const char *op, const char *cause)\n{\n\tstruct ima_template_entry *entry;\n\tstruct inode *inode = file_inode(file);\n\tstruct ima_event_data event_data = {iint, file, filename, NULL, 0,\n\t\t\t\t\t    cause};\n\tint violation = 1;\n\tint result;\n\n\t/* can overflow, only indicator */\n\tatomic_long_inc(&ima_htable.violations);\n\n\tresult = ima_alloc_init_template(&event_data, &entry);\n\tif (result < 0) {\n\t\tresult = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tresult = ima_store_template(entry, violation, inode,\n\t\t\t\t    filename, CONFIG_IMA_MEASURE_PCR_IDX);\n\tif (result < 0)\n\t\tima_free_template_entry(entry);\nerr_out:\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t    op, cause, result, 0);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "integrity_audit_msg",
          "args": [
            "AUDIT_INTEGRITY_PCR",
            "inode",
            "filename",
            "op",
            "cause",
            "result",
            "0"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "183-188",
          "snippet": "static inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct integrity_iint_cache *integrity_iint_find(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode);\n\nstatic inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_free_template_entry",
          "args": [
            "entry"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "ima_free_template_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "27-35",
          "snippet": "void ima_free_template_entry(struct ima_template_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < entry->template_desc->num_fields; i++)\n\t\tkfree(entry->template_data[i].data);\n\n\tkfree(entry);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid ima_free_template_entry(struct ima_template_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < entry->template_desc->num_fields; i++)\n\t\tkfree(entry->template_data[i].data);\n\n\tkfree(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_store_template",
          "args": [
            "entry",
            "violation",
            "inode",
            "filename",
            "CONFIG_IMA_MEASURE_PCR_IDX"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ima_store_template",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "88-120",
          "snippet": "int ima_store_template(struct ima_template_entry *entry,\n\t\t       int violation, struct inode *inode,\n\t\t       const unsigned char *filename, int pcr)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"hashing_error\";\n\tchar *template_name = entry->template_desc->name;\n\tint result;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[TPM_DIGEST_SIZE];\n\t} hash;\n\n\tif (!violation) {\n\t\tint num_fields = entry->template_desc->num_fields;\n\n\t\t/* this function uses default algo */\n\t\thash.hdr.algo = HASH_ALGO_SHA1;\n\t\tresult = ima_calc_field_array_hash(&entry->template_data[0],\n\t\t\t\t\t\t   entry->template_desc,\n\t\t\t\t\t\t   num_fields, &hash.hdr);\n\t\tif (result < 0) {\n\t\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,\n\t\t\t\t\t    template_name, op,\n\t\t\t\t\t    audit_cause, result, 0);\n\t\t\treturn result;\n\t\t}\n\t\tmemcpy(entry->digest, hash.hdr.digest, hash.hdr.length);\n\t}\n\tentry->pcr = pcr;\n\tresult = ima_add_template_entry(entry, violation, op, inode, filename);\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint ima_store_template(struct ima_template_entry *entry,\n\t\t       int violation, struct inode *inode,\n\t\t       const unsigned char *filename, int pcr)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"hashing_error\";\n\tchar *template_name = entry->template_desc->name;\n\tint result;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[TPM_DIGEST_SIZE];\n\t} hash;\n\n\tif (!violation) {\n\t\tint num_fields = entry->template_desc->num_fields;\n\n\t\t/* this function uses default algo */\n\t\thash.hdr.algo = HASH_ALGO_SHA1;\n\t\tresult = ima_calc_field_array_hash(&entry->template_data[0],\n\t\t\t\t\t\t   entry->template_desc,\n\t\t\t\t\t\t   num_fields, &hash.hdr);\n\t\tif (result < 0) {\n\t\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,\n\t\t\t\t\t    template_name, op,\n\t\t\t\t\t    audit_cause, result, 0);\n\t\t\treturn result;\n\t\t}\n\t\tmemcpy(entry->digest, hash.hdr.digest, hash.hdr.length);\n\t}\n\tentry->pcr = pcr;\n\tresult = ima_add_template_entry(entry, violation, op, inode, filename);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_alloc_init_template",
          "args": [
            "&event_data",
            "&entry"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "ima_alloc_init_template",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "40-70",
          "snippet": "int ima_alloc_init_template(struct ima_event_data *event_data,\n\t\t\t    struct ima_template_entry **entry)\n{\n\tstruct ima_template_desc *template_desc = ima_template_desc_current();\n\tint i, result = 0;\n\n\t*entry = kzalloc(sizeof(**entry) + template_desc->num_fields *\n\t\t\t sizeof(struct ima_field_data), GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tstruct ima_template_field *field = template_desc->fields[i];\n\t\tu32 len;\n\n\t\tresult = field->field_init(event_data,\n\t\t\t\t\t   &((*entry)->template_data[i]));\n\t\tif (result != 0)\n\t\t\tgoto out;\n\n\t\tlen = (*entry)->template_data[i].len;\n\t\t(*entry)->template_data_len += sizeof(len);\n\t\t(*entry)->template_data_len += len;\n\t}\n\treturn 0;\nout:\n\tima_free_template_entry(*entry);\n\t*entry = NULL;\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint ima_alloc_init_template(struct ima_event_data *event_data,\n\t\t\t    struct ima_template_entry **entry)\n{\n\tstruct ima_template_desc *template_desc = ima_template_desc_current();\n\tint i, result = 0;\n\n\t*entry = kzalloc(sizeof(**entry) + template_desc->num_fields *\n\t\t\t sizeof(struct ima_field_data), GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tstruct ima_template_field *field = template_desc->fields[i];\n\t\tu32 len;\n\n\t\tresult = field->field_init(event_data,\n\t\t\t\t\t   &((*entry)->template_data[i]));\n\t\tif (result != 0)\n\t\t\tgoto out;\n\n\t\tlen = (*entry)->template_data[i].len;\n\t\t(*entry)->template_data_len += sizeof(len);\n\t\t(*entry)->template_data_len += len;\n\t}\n\treturn 0;\nout:\n\tima_free_template_entry(*entry);\n\t*entry = NULL;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&ima_htable.violations"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid ima_add_violation(struct file *file, const unsigned char *filename,\n\t\t       struct integrity_iint_cache *iint,\n\t\t       const char *op, const char *cause)\n{\n\tstruct ima_template_entry *entry;\n\tstruct inode *inode = file_inode(file);\n\tstruct ima_event_data event_data = {iint, file, filename, NULL, 0,\n\t\t\t\t\t    cause};\n\tint violation = 1;\n\tint result;\n\n\t/* can overflow, only indicator */\n\tatomic_long_inc(&ima_htable.violations);\n\n\tresult = ima_alloc_init_template(&event_data, &entry);\n\tif (result < 0) {\n\t\tresult = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tresult = ima_store_template(entry, violation, inode,\n\t\t\t\t    filename, CONFIG_IMA_MEASURE_PCR_IDX);\n\tif (result < 0)\n\t\tima_free_template_entry(entry);\nerr_out:\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t    op, cause, result, 0);\n}"
  },
  {
    "function_name": "ima_store_template",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
    "lines": "88-120",
    "snippet": "int ima_store_template(struct ima_template_entry *entry,\n\t\t       int violation, struct inode *inode,\n\t\t       const unsigned char *filename, int pcr)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"hashing_error\";\n\tchar *template_name = entry->template_desc->name;\n\tint result;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[TPM_DIGEST_SIZE];\n\t} hash;\n\n\tif (!violation) {\n\t\tint num_fields = entry->template_desc->num_fields;\n\n\t\t/* this function uses default algo */\n\t\thash.hdr.algo = HASH_ALGO_SHA1;\n\t\tresult = ima_calc_field_array_hash(&entry->template_data[0],\n\t\t\t\t\t\t   entry->template_desc,\n\t\t\t\t\t\t   num_fields, &hash.hdr);\n\t\tif (result < 0) {\n\t\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,\n\t\t\t\t\t    template_name, op,\n\t\t\t\t\t    audit_cause, result, 0);\n\t\t\treturn result;\n\t\t}\n\t\tmemcpy(entry->digest, hash.hdr.digest, hash.hdr.length);\n\t}\n\tentry->pcr = pcr;\n\tresult = ima_add_template_entry(entry, violation, op, inode, filename);\n\treturn result;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_add_template_entry",
          "args": [
            "entry",
            "violation",
            "op",
            "inode",
            "filename"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "ima_add_template_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
          "lines": "162-204",
          "snippet": "int ima_add_template_entry(struct ima_template_entry *entry, int violation,\n\t\t\t   const char *op, struct inode *inode,\n\t\t\t   const unsigned char *filename)\n{\n\tu8 digest[TPM_DIGEST_SIZE];\n\tconst char *audit_cause = \"hash_added\";\n\tchar tpm_audit_cause[AUDIT_CAUSE_LEN_MAX];\n\tint audit_info = 1;\n\tint result = 0, tpmresult = 0;\n\n\tmutex_lock(&ima_extend_list_mutex);\n\tif (!violation) {\n\t\tmemcpy(digest, entry->digest, sizeof(digest));\n\t\tif (ima_lookup_digest_entry(digest, entry->pcr)) {\n\t\t\taudit_cause = \"hash_exists\";\n\t\t\tresult = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tresult = ima_add_digest_entry(entry, 1);\n\tif (result < 0) {\n\t\taudit_cause = \"ENOMEM\";\n\t\taudit_info = 0;\n\t\tgoto out;\n\t}\n\n\tif (violation)\t\t/* invalidate pcr */\n\t\tmemset(digest, 0xff, sizeof(digest));\n\n\ttpmresult = ima_pcr_extend(digest, entry->pcr);\n\tif (tpmresult != 0) {\n\t\tsnprintf(tpm_audit_cause, AUDIT_CAUSE_LEN_MAX, \"TPM_error(%d)\",\n\t\t\t tpmresult);\n\t\taudit_cause = tpm_audit_cause;\n\t\taudit_info = 0;\n\t}\nout:\n\tmutex_unlock(&ima_extend_list_mutex);\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t    op, audit_cause, result, audit_info);\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define AUDIT_CAUSE_LEN_MAX 32"
          ],
          "globals_used": [
            "static DEFINE_MUTEX(ima_extend_list_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\n#define AUDIT_CAUSE_LEN_MAX 32\n\nstatic DEFINE_MUTEX(ima_extend_list_mutex);\n\nint ima_add_template_entry(struct ima_template_entry *entry, int violation,\n\t\t\t   const char *op, struct inode *inode,\n\t\t\t   const unsigned char *filename)\n{\n\tu8 digest[TPM_DIGEST_SIZE];\n\tconst char *audit_cause = \"hash_added\";\n\tchar tpm_audit_cause[AUDIT_CAUSE_LEN_MAX];\n\tint audit_info = 1;\n\tint result = 0, tpmresult = 0;\n\n\tmutex_lock(&ima_extend_list_mutex);\n\tif (!violation) {\n\t\tmemcpy(digest, entry->digest, sizeof(digest));\n\t\tif (ima_lookup_digest_entry(digest, entry->pcr)) {\n\t\t\taudit_cause = \"hash_exists\";\n\t\t\tresult = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tresult = ima_add_digest_entry(entry, 1);\n\tif (result < 0) {\n\t\taudit_cause = \"ENOMEM\";\n\t\taudit_info = 0;\n\t\tgoto out;\n\t}\n\n\tif (violation)\t\t/* invalidate pcr */\n\t\tmemset(digest, 0xff, sizeof(digest));\n\n\ttpmresult = ima_pcr_extend(digest, entry->pcr);\n\tif (tpmresult != 0) {\n\t\tsnprintf(tpm_audit_cause, AUDIT_CAUSE_LEN_MAX, \"TPM_error(%d)\",\n\t\t\t tpmresult);\n\t\taudit_cause = tpm_audit_cause;\n\t\taudit_info = 0;\n\t}\nout:\n\tmutex_unlock(&ima_extend_list_mutex);\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t    op, audit_cause, result, audit_info);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry->digest",
            "hash.hdr.digest",
            "hash.hdr.length"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "integrity_audit_msg",
          "args": [
            "AUDIT_INTEGRITY_PCR",
            "inode",
            "template_name",
            "op",
            "audit_cause",
            "result",
            "0"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "183-188",
          "snippet": "static inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct integrity_iint_cache *integrity_iint_find(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode);\n\nstatic inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_calc_field_array_hash",
          "args": [
            "&entry->template_data[0]",
            "entry->template_desc",
            "num_fields",
            "&hash.hdr"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ima_calc_field_array_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "493-510",
          "snippet": "int ima_calc_field_array_hash(struct ima_field_data *field_data,\n\t\t\t      struct ima_template_desc *desc, int num_fields,\n\t\t\t      struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_field_array_hash_tfm(field_data, desc, num_fields,\n\t\t\t\t\t   hash, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nint ima_calc_field_array_hash(struct ima_field_data *field_data,\n\t\t\t      struct ima_template_desc *desc, int num_fields,\n\t\t\t      struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_field_array_hash_tfm(field_data, desc, num_fields,\n\t\t\t\t\t   hash, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint ima_store_template(struct ima_template_entry *entry,\n\t\t       int violation, struct inode *inode,\n\t\t       const unsigned char *filename, int pcr)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"hashing_error\";\n\tchar *template_name = entry->template_desc->name;\n\tint result;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[TPM_DIGEST_SIZE];\n\t} hash;\n\n\tif (!violation) {\n\t\tint num_fields = entry->template_desc->num_fields;\n\n\t\t/* this function uses default algo */\n\t\thash.hdr.algo = HASH_ALGO_SHA1;\n\t\tresult = ima_calc_field_array_hash(&entry->template_data[0],\n\t\t\t\t\t\t   entry->template_desc,\n\t\t\t\t\t\t   num_fields, &hash.hdr);\n\t\tif (result < 0) {\n\t\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,\n\t\t\t\t\t    template_name, op,\n\t\t\t\t\t    audit_cause, result, 0);\n\t\t\treturn result;\n\t\t}\n\t\tmemcpy(entry->digest, hash.hdr.digest, hash.hdr.length);\n\t}\n\tentry->pcr = pcr;\n\tresult = ima_add_template_entry(entry, violation, op, inode, filename);\n\treturn result;\n}"
  },
  {
    "function_name": "ima_alloc_init_template",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
    "lines": "40-70",
    "snippet": "int ima_alloc_init_template(struct ima_event_data *event_data,\n\t\t\t    struct ima_template_entry **entry)\n{\n\tstruct ima_template_desc *template_desc = ima_template_desc_current();\n\tint i, result = 0;\n\n\t*entry = kzalloc(sizeof(**entry) + template_desc->num_fields *\n\t\t\t sizeof(struct ima_field_data), GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tstruct ima_template_field *field = template_desc->fields[i];\n\t\tu32 len;\n\n\t\tresult = field->field_init(event_data,\n\t\t\t\t\t   &((*entry)->template_data[i]));\n\t\tif (result != 0)\n\t\t\tgoto out;\n\n\t\tlen = (*entry)->template_data[i].len;\n\t\t(*entry)->template_data_len += sizeof(len);\n\t\t(*entry)->template_data_len += len;\n\t}\n\treturn 0;\nout:\n\tima_free_template_entry(*entry);\n\t*entry = NULL;\n\treturn result;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_free_template_entry",
          "args": [
            "*entry"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "ima_free_template_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "27-35",
          "snippet": "void ima_free_template_entry(struct ima_template_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < entry->template_desc->num_fields; i++)\n\t\tkfree(entry->template_data[i].data);\n\n\tkfree(entry);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid ima_free_template_entry(struct ima_template_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < entry->template_desc->num_fields; i++)\n\t\tkfree(entry->template_data[i].data);\n\n\tkfree(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "field->field_init",
          "args": [
            "event_data",
            "&((*entry)->template_data[i])"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(**entry) + template_desc->num_fields *\n\t\t\t sizeof(struct ima_field_data)",
            "GFP_NOFS"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_template_desc_current",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "ima_template_desc_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "221-229",
          "snippet": "struct ima_template_desc *ima_template_desc_current(void)\n{\n\tif (!ima_template) {\n\t\tima_init_template_list();\n\t\tima_template =\n\t\t    lookup_template_desc(CONFIG_IMA_DEFAULT_TEMPLATE);\n\t}\n\treturn ima_template;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ima_template_desc *ima_template;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_desc *ima_template;\n\nstruct ima_template_desc *ima_template_desc_current(void)\n{\n\tif (!ima_template) {\n\t\tima_init_template_list();\n\t\tima_template =\n\t\t    lookup_template_desc(CONFIG_IMA_DEFAULT_TEMPLATE);\n\t}\n\treturn ima_template;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint ima_alloc_init_template(struct ima_event_data *event_data,\n\t\t\t    struct ima_template_entry **entry)\n{\n\tstruct ima_template_desc *template_desc = ima_template_desc_current();\n\tint i, result = 0;\n\n\t*entry = kzalloc(sizeof(**entry) + template_desc->num_fields *\n\t\t\t sizeof(struct ima_field_data), GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tstruct ima_template_field *field = template_desc->fields[i];\n\t\tu32 len;\n\n\t\tresult = field->field_init(event_data,\n\t\t\t\t\t   &((*entry)->template_data[i]));\n\t\tif (result != 0)\n\t\t\tgoto out;\n\n\t\tlen = (*entry)->template_data[i].len;\n\t\t(*entry)->template_data_len += sizeof(len);\n\t\t(*entry)->template_data_len += len;\n\t}\n\treturn 0;\nout:\n\tima_free_template_entry(*entry);\n\t*entry = NULL;\n\treturn result;\n}"
  },
  {
    "function_name": "ima_free_template_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
    "lines": "27-35",
    "snippet": "void ima_free_template_entry(struct ima_template_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < entry->template_desc->num_fields; i++)\n\t\tkfree(entry->template_data[i].data);\n\n\tkfree(entry);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry->template_data[i].data"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid ima_free_template_entry(struct ima_template_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < entry->template_desc->num_fields; i++)\n\t\tkfree(entry->template_data[i].data);\n\n\tkfree(entry);\n}"
  }
]