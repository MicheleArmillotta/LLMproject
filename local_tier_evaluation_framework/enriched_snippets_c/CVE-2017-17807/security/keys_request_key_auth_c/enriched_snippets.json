[
  {
    "function_name": "key_get_instantiation_authkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
    "lines": "234-268",
    "snippet": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}",
    "includes": [
      "#include <keys/user-type.h>",
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/err.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void request_key_auth_revoke(struct key *);",
      "static void request_key_auth_destroy(struct key *);",
      "struct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EKEYREVOKED"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "authkey"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_REVOKED",
            "&authkey->flags"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "authkey_ref"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOKEY"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EAGAIN"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "authkey_ref"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "authkey_ref"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_process_keyrings",
          "args": [
            "&ctx"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "search_process_keyrings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "451-504",
          "snippet": "key_ref_t search_process_keyrings(struct keyring_search_context *ctx)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\n\tmight_sleep();\n\n\tkey_ref = search_my_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\n\t/* if this process has an instantiation authorisation key, then we also\n\t * search the keyrings of the process mentioned there\n\t * - we don't permit access to request_key auth keys via this method\n\t */\n\tif (ctx->cred->request_key_auth &&\n\t    ctx->cred == current_cred() &&\n\t    ctx->index_key.type != &key_type_request_key_auth\n\t    ) {\n\t\tconst struct cred *cred = ctx->cred;\n\n\t\t/* defend against the auth key being revoked */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\tif (key_validate(ctx->cred->request_key_auth) == 0) {\n\t\t\trka = ctx->cred->request_key_auth->payload.data[0];\n\n\t\t\tctx->cred = rka->cred;\n\t\t\tkey_ref = search_process_keyrings(ctx);\n\t\t\tctx->cred = cred;\n\n\t\t\tup_read(&cred->request_key_auth->sem);\n\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\n\t\t\tret = key_ref;\n\t\t} else {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\n\nfound:\n\treturn key_ref;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t search_process_keyrings(struct keyring_search_context *ctx)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\n\tmight_sleep();\n\n\tkey_ref = search_my_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\n\t/* if this process has an instantiation authorisation key, then we also\n\t * search the keyrings of the process mentioned there\n\t * - we don't permit access to request_key auth keys via this method\n\t */\n\tif (ctx->cred->request_key_auth &&\n\t    ctx->cred == current_cred() &&\n\t    ctx->index_key.type != &key_type_request_key_auth\n\t    ) {\n\t\tconst struct cred *cred = ctx->cred;\n\n\t\t/* defend against the auth key being revoked */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\tif (key_validate(ctx->cred->request_key_auth) == 0) {\n\t\t\trka = ctx->cred->request_key_auth->payload.data[0];\n\n\t\t\tctx->cred = rka->cred;\n\t\t\tkey_ref = search_process_keyrings(ctx);\n\t\t\tctx->cred = cred;\n\n\t\t\tup_read(&cred->request_key_auth->sem);\n\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\n\t\t\tret = key_ref;\n\t\t} else {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\n\nfound:\n\treturn key_ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "description",
            "\"%x\"",
            "target_id"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}"
  },
  {
    "function_name": "request_key_auth_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
    "lines": "151-228",
    "snippet": "struct key *request_key_auth_new(struct key *target, const void *callout_info,\n\t\t\t\t size_t callout_len, struct key *dest_keyring)\n{\n\tstruct request_key_auth *rka, *irka;\n\tconst struct cred *cred = current->cred;\n\tstruct key *authkey = NULL;\n\tchar desc[20];\n\tint ret = -ENOMEM;\n\n\tkenter(\"%d,\", target->serial);\n\n\t/* allocate a auth record */\n\trka = kzalloc(sizeof(*rka), GFP_KERNEL);\n\tif (!rka)\n\t\tgoto error;\n\trka->callout_info = kmemdup(callout_info, callout_len, GFP_KERNEL);\n\tif (!rka->callout_info)\n\t\tgoto error_free_rka;\n\trka->callout_len = callout_len;\n\n\t/* see if the calling process is already servicing the key request of\n\t * another process */\n\tif (cred->request_key_auth) {\n\t\t/* it is - use that instantiation context here too */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\t/* if the auth key has been revoked, then the key we're\n\t\t * servicing is already instantiated */\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &cred->request_key_auth->flags)) {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t\tret = -EKEYREVOKED;\n\t\t\tgoto error_free_rka;\n\t\t}\n\n\t\tirka = cred->request_key_auth->payload.data[0];\n\t\trka->cred = get_cred(irka->cred);\n\t\trka->pid = irka->pid;\n\n\t\tup_read(&cred->request_key_auth->sem);\n\t}\n\telse {\n\t\t/* it isn't - use this process as the context */\n\t\trka->cred = get_cred(cred);\n\t\trka->pid = current->pid;\n\t}\n\n\trka->target_key = key_get(target);\n\trka->dest_keyring = key_get(dest_keyring);\n\n\t/* allocate the auth key */\n\tsprintf(desc, \"%x\", target->serial);\n\n\tauthkey = key_alloc(&key_type_request_key_auth, desc,\n\t\t\t    cred->fsuid, cred->fsgid, cred,\n\t\t\t    KEY_POS_VIEW | KEY_POS_READ | KEY_POS_SEARCH |\n\t\t\t    KEY_USR_VIEW, KEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error_free_rka;\n\t}\n\n\t/* construct the auth key */\n\tret = key_instantiate_and_link(authkey, rka, 0, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto error_put_authkey;\n\n\tkleave(\" = {%d,%d}\", authkey->serial, refcount_read(&authkey->usage));\n\treturn authkey;\n\nerror_put_authkey:\n\tkey_put(authkey);\nerror_free_rka:\n\tfree_request_key_auth(rka);\nerror:\n\tkleave(\"= %d\", ret);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include <keys/user-type.h>",
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/err.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void request_key_auth_revoke(struct key *);",
      "static void request_key_auth_destroy(struct key *);",
      "static long request_key_auth_read(const struct key *, char __user *, size_t);",
      "struct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\"= %d\"",
            "ret"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_request_key_auth",
          "args": [
            "rka"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "free_request_key_auth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "123-133",
          "snippet": "static void free_request_key_auth(struct request_key_auth *rka)\n{\n\tif (!rka)\n\t\treturn;\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tif (rka->cred)\n\t\tput_cred(rka->cred);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void free_request_key_auth(struct request_key_auth *rka)\n{\n\tif (!rka)\n\t\treturn;\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tif (rka->cred)\n\t\tput_cred(rka->cred);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "authkey"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = {%d,%d}\"",
            "authkey->serial",
            "refcount_read(&authkey->usage)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&authkey->usage"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_instantiate_and_link",
          "args": [
            "authkey",
            "rka",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "key_instantiate_and_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "495-541",
          "snippet": "int key_instantiate_and_link(struct key *key,\n\t\t\t     const void *data,\n\t\t\t     size_t datalen,\n\t\t\t     struct key *keyring,\n\t\t\t     struct key *authkey)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = data;\n\tprep.datalen = datalen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME64_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (keyring) {\n\t\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tif (keyring->restrict_link && keyring->restrict_link->check) {\n\t\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\t\tret = keyres->check(keyring, key->type, &prep.payload,\n\t\t\t\t\t    keyres->key);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\tret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);\n\nerror_link_end:\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint key_instantiate_and_link(struct key *key,\n\t\t\t     const void *data,\n\t\t\t     size_t datalen,\n\t\t\t     struct key *keyring,\n\t\t\t     struct key *authkey)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = data;\n\tprep.datalen = datalen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME64_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (keyring) {\n\t\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tif (keyring->restrict_link && keyring->restrict_link->check) {\n\t\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\t\tret = keyres->check(keyring, key->type, &prep.payload,\n\t\t\t\t\t    keyres->key);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\tret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);\n\nerror_link_end:\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "authkey"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "authkey"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_alloc",
          "args": [
            "&key_type_request_key_auth",
            "desc",
            "cred->fsuid",
            "cred->fsgid",
            "cred",
            "KEY_POS_VIEW | KEY_POS_READ | KEY_POS_SEARCH |\n\t\t\t    KEY_USR_VIEW",
            "KEY_ALLOC_NOT_IN_QUOTA",
            "NULL"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "key_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "228-356",
          "snippet": "struct key *key_alloc(struct key_type *type, const char *desc,\n\t\t      kuid_t uid, kgid_t gid, const struct cred *cred,\n\t\t      key_perm_t perm, unsigned long flags,\n\t\t      struct key_restriction *restrict_link)\n{\n\tstruct key_user *user = NULL;\n\tstruct key *key;\n\tsize_t desclen, quotalen;\n\tint ret;\n\n\tkey = ERR_PTR(-EINVAL);\n\tif (!desc || !*desc)\n\t\tgoto error;\n\n\tif (type->vet_description) {\n\t\tret = type->vet_description(desc);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdesclen = strlen(desc);\n\tquotalen = desclen + 1 + type->def_datalen;\n\n\t/* get hold of the key tracking for this user */\n\tuser = key_user_lookup(uid);\n\tif (!user)\n\t\tgoto no_memory_1;\n\n\t/* check that the user's quota permits allocation of another key and\n\t * its description */\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&user->lock);\n\t\tif (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) {\n\t\t\tif (user->qnkeys + 1 >= maxkeys ||\n\t\t\t    user->qnbytes + quotalen >= maxbytes ||\n\t\t\t    user->qnbytes + quotalen < user->qnbytes)\n\t\t\t\tgoto no_quota;\n\t\t}\n\n\t\tuser->qnkeys++;\n\t\tuser->qnbytes += quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\n\t/* allocate and initialise the key and its description */\n\tkey = kmem_cache_zalloc(key_jar, GFP_KERNEL);\n\tif (!key)\n\t\tgoto no_memory_2;\n\n\tkey->index_key.desc_len = desclen;\n\tkey->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);\n\tif (!key->index_key.description)\n\t\tgoto no_memory_3;\n\n\trefcount_set(&key->usage, 1);\n\tinit_rwsem(&key->sem);\n\tlockdep_set_class(&key->sem, &type->lock_class);\n\tkey->index_key.type = type;\n\tkey->user = user;\n\tkey->quotalen = quotalen;\n\tkey->datalen = type->def_datalen;\n\tkey->uid = uid;\n\tkey->gid = gid;\n\tkey->perm = perm;\n\tkey->restrict_link = restrict_link;\n\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA))\n\t\tkey->flags |= 1 << KEY_FLAG_IN_QUOTA;\n\tif (flags & KEY_ALLOC_BUILT_IN)\n\t\tkey->flags |= 1 << KEY_FLAG_BUILTIN;\n\tif (flags & KEY_ALLOC_UID_KEYRING)\n\t\tkey->flags |= 1 << KEY_FLAG_UID_KEYRING;\n\n#ifdef KEY_DEBUGGING\n\tkey->magic = KEY_DEBUG_MAGIC;\n#endif\n\n\t/* let the security module know about the key */\n\tret = security_key_alloc(key, cred, flags);\n\tif (ret < 0)\n\t\tgoto security_error;\n\n\t/* publish the key by giving it a serial number */\n\tatomic_inc(&user->nkeys);\n\tkey_alloc_serial(key);\n\nerror:\n\treturn key;\n\nsecurity_error:\n\tkfree(key->description);\n\tkmem_cache_free(key_jar, key);\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\n\tkey = ERR_PTR(ret);\n\tgoto error;\n\nno_memory_3:\n\tkmem_cache_free(key_jar, key);\nno_memory_2:\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\nno_memory_1:\n\tkey = ERR_PTR(-ENOMEM);\n\tgoto error;\n\nno_quota:\n\tspin_unlock(&user->lock);\n\tkey_user_put(user);\n\tkey = ERR_PTR(-EDQUOT);\n\tgoto error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *key_jar;",
            "unsigned int key_quota_root_maxkeys = 1000000;",
            "unsigned int key_quota_root_maxbytes = 25000000;",
            "unsigned int key_quota_maxkeys = 200;",
            "unsigned int key_quota_maxbytes = 20000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct kmem_cache *key_jar;\nunsigned int key_quota_root_maxkeys = 1000000;\nunsigned int key_quota_root_maxbytes = 25000000;\nunsigned int key_quota_maxkeys = 200;\nunsigned int key_quota_maxbytes = 20000;\n\nstruct key *key_alloc(struct key_type *type, const char *desc,\n\t\t      kuid_t uid, kgid_t gid, const struct cred *cred,\n\t\t      key_perm_t perm, unsigned long flags,\n\t\t      struct key_restriction *restrict_link)\n{\n\tstruct key_user *user = NULL;\n\tstruct key *key;\n\tsize_t desclen, quotalen;\n\tint ret;\n\n\tkey = ERR_PTR(-EINVAL);\n\tif (!desc || !*desc)\n\t\tgoto error;\n\n\tif (type->vet_description) {\n\t\tret = type->vet_description(desc);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdesclen = strlen(desc);\n\tquotalen = desclen + 1 + type->def_datalen;\n\n\t/* get hold of the key tracking for this user */\n\tuser = key_user_lookup(uid);\n\tif (!user)\n\t\tgoto no_memory_1;\n\n\t/* check that the user's quota permits allocation of another key and\n\t * its description */\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&user->lock);\n\t\tif (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) {\n\t\t\tif (user->qnkeys + 1 >= maxkeys ||\n\t\t\t    user->qnbytes + quotalen >= maxbytes ||\n\t\t\t    user->qnbytes + quotalen < user->qnbytes)\n\t\t\t\tgoto no_quota;\n\t\t}\n\n\t\tuser->qnkeys++;\n\t\tuser->qnbytes += quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\n\t/* allocate and initialise the key and its description */\n\tkey = kmem_cache_zalloc(key_jar, GFP_KERNEL);\n\tif (!key)\n\t\tgoto no_memory_2;\n\n\tkey->index_key.desc_len = desclen;\n\tkey->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);\n\tif (!key->index_key.description)\n\t\tgoto no_memory_3;\n\n\trefcount_set(&key->usage, 1);\n\tinit_rwsem(&key->sem);\n\tlockdep_set_class(&key->sem, &type->lock_class);\n\tkey->index_key.type = type;\n\tkey->user = user;\n\tkey->quotalen = quotalen;\n\tkey->datalen = type->def_datalen;\n\tkey->uid = uid;\n\tkey->gid = gid;\n\tkey->perm = perm;\n\tkey->restrict_link = restrict_link;\n\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA))\n\t\tkey->flags |= 1 << KEY_FLAG_IN_QUOTA;\n\tif (flags & KEY_ALLOC_BUILT_IN)\n\t\tkey->flags |= 1 << KEY_FLAG_BUILTIN;\n\tif (flags & KEY_ALLOC_UID_KEYRING)\n\t\tkey->flags |= 1 << KEY_FLAG_UID_KEYRING;\n\n#ifdef KEY_DEBUGGING\n\tkey->magic = KEY_DEBUG_MAGIC;\n#endif\n\n\t/* let the security module know about the key */\n\tret = security_key_alloc(key, cred, flags);\n\tif (ret < 0)\n\t\tgoto security_error;\n\n\t/* publish the key by giving it a serial number */\n\tatomic_inc(&user->nkeys);\n\tkey_alloc_serial(key);\n\nerror:\n\treturn key;\n\nsecurity_error:\n\tkfree(key->description);\n\tkmem_cache_free(key_jar, key);\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\n\tkey = ERR_PTR(ret);\n\tgoto error;\n\nno_memory_3:\n\tkmem_cache_free(key_jar, key);\nno_memory_2:\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\nno_memory_1:\n\tkey = ERR_PTR(-ENOMEM);\n\tgoto error;\n\nno_quota:\n\tspin_unlock(&user->lock);\n\tkey_user_put(user);\n\tkey = ERR_PTR(-EDQUOT);\n\tgoto error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "desc",
            "\"%x\"",
            "target->serial"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "dest_keyring"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "key_get_instantiation_authkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "234-268",
          "snippet": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void request_key_auth_revoke(struct key *);",
            "static void request_key_auth_destroy(struct key *);",
            "struct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cred",
          "args": [
            "cred"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&cred->request_key_auth->sem"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cred",
          "args": [
            "irka->cred"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&cred->request_key_auth->sem"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_REVOKED",
            "&cred->request_key_auth->flags"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&cred->request_key_auth->sem"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "callout_info",
            "callout_len",
            "GFP_KERNEL"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*rka)",
            "GFP_KERNEL"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"%d,\"",
            "target->serial"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstatic long request_key_auth_read(const struct key *, char __user *, size_t);\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstruct key *request_key_auth_new(struct key *target, const void *callout_info,\n\t\t\t\t size_t callout_len, struct key *dest_keyring)\n{\n\tstruct request_key_auth *rka, *irka;\n\tconst struct cred *cred = current->cred;\n\tstruct key *authkey = NULL;\n\tchar desc[20];\n\tint ret = -ENOMEM;\n\n\tkenter(\"%d,\", target->serial);\n\n\t/* allocate a auth record */\n\trka = kzalloc(sizeof(*rka), GFP_KERNEL);\n\tif (!rka)\n\t\tgoto error;\n\trka->callout_info = kmemdup(callout_info, callout_len, GFP_KERNEL);\n\tif (!rka->callout_info)\n\t\tgoto error_free_rka;\n\trka->callout_len = callout_len;\n\n\t/* see if the calling process is already servicing the key request of\n\t * another process */\n\tif (cred->request_key_auth) {\n\t\t/* it is - use that instantiation context here too */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\t/* if the auth key has been revoked, then the key we're\n\t\t * servicing is already instantiated */\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &cred->request_key_auth->flags)) {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t\tret = -EKEYREVOKED;\n\t\t\tgoto error_free_rka;\n\t\t}\n\n\t\tirka = cred->request_key_auth->payload.data[0];\n\t\trka->cred = get_cred(irka->cred);\n\t\trka->pid = irka->pid;\n\n\t\tup_read(&cred->request_key_auth->sem);\n\t}\n\telse {\n\t\t/* it isn't - use this process as the context */\n\t\trka->cred = get_cred(cred);\n\t\trka->pid = current->pid;\n\t}\n\n\trka->target_key = key_get(target);\n\trka->dest_keyring = key_get(dest_keyring);\n\n\t/* allocate the auth key */\n\tsprintf(desc, \"%x\", target->serial);\n\n\tauthkey = key_alloc(&key_type_request_key_auth, desc,\n\t\t\t    cred->fsuid, cred->fsgid, cred,\n\t\t\t    KEY_POS_VIEW | KEY_POS_READ | KEY_POS_SEARCH |\n\t\t\t    KEY_USR_VIEW, KEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error_free_rka;\n\t}\n\n\t/* construct the auth key */\n\tret = key_instantiate_and_link(authkey, rka, 0, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto error_put_authkey;\n\n\tkleave(\" = {%d,%d}\", authkey->serial, refcount_read(&authkey->usage));\n\treturn authkey;\n\nerror_put_authkey:\n\tkey_put(authkey);\nerror_free_rka:\n\tfree_request_key_auth(rka);\nerror:\n\tkleave(\"= %d\", ret);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "request_key_auth_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
    "lines": "138-145",
    "snippet": "static void request_key_auth_destroy(struct key *key)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tkenter(\"{%d}\", key->serial);\n\n\tfree_request_key_auth(rka);\n}",
    "includes": [
      "#include <keys/user-type.h>",
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/err.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void request_key_auth_revoke(struct key *);",
      "static void request_key_auth_destroy(struct key *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_request_key_auth",
          "args": [
            "rka"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "free_request_key_auth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "123-133",
          "snippet": "static void free_request_key_auth(struct request_key_auth *rka)\n{\n\tif (!rka)\n\t\treturn;\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tif (rka->cred)\n\t\tput_cred(rka->cred);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void free_request_key_auth(struct request_key_auth *rka)\n{\n\tif (!rka)\n\t\treturn;\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tif (rka->cred)\n\t\tput_cred(rka->cred);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"{%d}\"",
            "key->serial"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\n\nstatic void request_key_auth_destroy(struct key *key)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tkenter(\"{%d}\", key->serial);\n\n\tfree_request_key_auth(rka);\n}"
  },
  {
    "function_name": "free_request_key_auth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
    "lines": "123-133",
    "snippet": "static void free_request_key_auth(struct request_key_auth *rka)\n{\n\tif (!rka)\n\t\treturn;\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tif (rka->cred)\n\t\tput_cred(rka->cred);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n}",
    "includes": [
      "#include <keys/user-type.h>",
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/err.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rka"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rka->callout_info"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "rka->cred"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "rka->dest_keyring"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void free_request_key_auth(struct request_key_auth *rka)\n{\n\tif (!rka)\n\t\treturn;\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tif (rka->cred)\n\t\tput_cred(rka->cred);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n}"
  },
  {
    "function_name": "request_key_auth_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
    "lines": "111-121",
    "snippet": "static void request_key_auth_revoke(struct key *key)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tkenter(\"{%d}\", key->serial);\n\n\tif (rka->cred) {\n\t\tput_cred(rka->cred);\n\t\trka->cred = NULL;\n\t}\n}",
    "includes": [
      "#include <keys/user-type.h>",
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/err.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void request_key_auth_revoke(struct key *);",
      "static void request_key_auth_destroy(struct key *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "rka->cred"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"{%d}\"",
            "key->serial"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\n\nstatic void request_key_auth_revoke(struct key *key)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tkenter(\"{%d}\", key->serial);\n\n\tif (rka->cred) {\n\t\tput_cred(rka->cred);\n\t\trka->cred = NULL;\n\t}\n}"
  },
  {
    "function_name": "request_key_auth_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
    "lines": "84-104",
    "snippet": "static long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <keys/user-type.h>",
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/err.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void request_key_auth_revoke(struct key *);",
      "static void request_key_auth_destroy(struct key *);",
      "static long request_key_auth_read(const struct key *, char __user *, size_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer",
            "rka->callout_info",
            "buflen"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstatic long request_key_auth_read(const struct key *, char __user *, size_t);\n\nstatic long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "request_key_auth_describe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
    "lines": "69-78",
    "snippet": "static void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}",
    "includes": [
      "#include <keys/user-type.h>",
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/err.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void request_key_auth_describe(const struct key *, struct seq_file *);",
      "static void request_key_auth_revoke(struct key *);",
      "static void request_key_auth_destroy(struct key *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" pid:%d ci:%zu\"",
            "rka->pid",
            "rka->callout_len"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_is_positive",
          "args": [
            "key"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "key->description"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"key:\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_describe(const struct key *, struct seq_file *);\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\n\nstatic void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}"
  },
  {
    "function_name": "request_key_auth_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
    "lines": "59-64",
    "snippet": "static int request_key_auth_instantiate(struct key *key,\n\t\t\t\t\tstruct key_preparsed_payload *prep)\n{\n\tkey->payload.data[0] = (struct request_key_auth *)prep->data;\n\treturn 0;\n}",
    "includes": [
      "#include <keys/user-type.h>",
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/err.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int request_key_auth_preparse(struct key_preparsed_payload *);",
      "static void request_key_auth_free_preparse(struct key_preparsed_payload *);",
      "static int request_key_auth_instantiate(struct key *,\n\t\t\t\t\tstruct key_preparsed_payload *);",
      "static void request_key_auth_revoke(struct key *);",
      "static void request_key_auth_destroy(struct key *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *);\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *);\nstatic int request_key_auth_instantiate(struct key *,\n\t\t\t\t\tstruct key_preparsed_payload *);\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\n\nstatic int request_key_auth_instantiate(struct key *key,\n\t\t\t\t\tstruct key_preparsed_payload *prep)\n{\n\tkey->payload.data[0] = (struct request_key_auth *)prep->data;\n\treturn 0;\n}"
  },
  {
    "function_name": "request_key_auth_free_preparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
    "lines": "52-54",
    "snippet": "static void request_key_auth_free_preparse(struct key_preparsed_payload *prep)\n{\n}",
    "includes": [
      "#include <keys/user-type.h>",
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/err.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int request_key_auth_preparse(struct key_preparsed_payload *);",
      "static void request_key_auth_free_preparse(struct key_preparsed_payload *);",
      "static int request_key_auth_instantiate(struct key *,\n\t\t\t\t\tstruct key_preparsed_payload *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *);\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *);\nstatic int request_key_auth_instantiate(struct key *,\n\t\t\t\t\tstruct key_preparsed_payload *);\n\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *prep)\n{\n}"
  },
  {
    "function_name": "request_key_auth_preparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
    "lines": "47-50",
    "snippet": "static int request_key_auth_preparse(struct key_preparsed_payload *prep)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <keys/user-type.h>",
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/err.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int request_key_auth_preparse(struct key_preparsed_payload *);",
      "static void request_key_auth_free_preparse(struct key_preparsed_payload *);",
      "static int request_key_auth_instantiate(struct key *,\n\t\t\t\t\tstruct key_preparsed_payload *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *);\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *);\nstatic int request_key_auth_instantiate(struct key *,\n\t\t\t\t\tstruct key_preparsed_payload *);\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *prep)\n{\n\treturn 0;\n}"
  }
]