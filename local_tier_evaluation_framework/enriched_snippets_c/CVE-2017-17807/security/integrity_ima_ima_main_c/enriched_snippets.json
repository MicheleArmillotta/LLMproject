[
  {
    "function_name": "init_ima",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
    "lines": "426-438",
    "snippet": "static int __init init_ima(void)\n{\n\tint error;\n\n\tima_init_template_list();\n\thash_setup(CONFIG_IMA_DEFAULT_HASH);\n\terror = ima_init();\n\tif (!error) {\n\t\tima_initialized = 1;\n\t\tima_update_policy_flag();\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/ima.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/mount.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ima_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_update_policy_flag",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "ima_update_policy_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "408-420",
          "snippet": "void ima_update_policy_flag(void)\n{\n\tstruct ima_rule_entry *entry;\n\n\tlist_for_each_entry(entry, ima_rules, list) {\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tima_policy_flag |= entry->action;\n\t}\n\n\tima_appraise |= temp_ima_appraise;\n\tif (!ima_appraise)\n\t\tima_policy_flag &= ~IMA_APPRAISE;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ima_policy_flag;",
            "static int temp_ima_appraise;",
            "static struct list_head *ima_rules;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nint ima_policy_flag;\nstatic int temp_ima_appraise;\nstatic struct list_head *ima_rules;\n\nvoid ima_update_policy_flag(void)\n{\n\tstruct ima_rule_entry *entry;\n\n\tlist_for_each_entry(entry, ima_rules, list) {\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tima_policy_flag |= entry->action;\n\t}\n\n\tima_appraise |= temp_ima_appraise;\n\tif (!ima_appraise)\n\t\tima_policy_flag &= ~IMA_APPRAISE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_init",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "ima_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_init.c",
          "lines": "107-141",
          "snippet": "int __init ima_init(void)\n{\n\tu8 pcr_i[TPM_DIGEST_SIZE];\n\tint rc;\n\n\tima_used_chip = 0;\n\trc = tpm_pcr_read(TPM_ANY_NUM, 0, pcr_i);\n\tif (rc == 0)\n\t\tima_used_chip = 1;\n\n\tif (!ima_used_chip)\n\t\tpr_info(\"No TPM chip found, activating TPM-bypass! (rc=%d)\\n\",\n\t\t\trc);\n\n\trc = integrity_init_keyring(INTEGRITY_KEYRING_IMA);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ima_init_crypto();\n\tif (rc)\n\t\treturn rc;\n\trc = ima_init_template();\n\tif (rc != 0)\n\t\treturn rc;\n\n\tima_load_kexec_buffer();\n\n\trc = ima_add_boot_aggregate();\t/* boot aggregate must be first entry */\n\tif (rc != 0)\n\t\treturn rc;\n\n\tima_init_policy();\n\n\treturn ima_fs_init();\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ima_used_chip;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/module.h>\n\nint ima_used_chip;\n\nint __init ima_init(void)\n{\n\tu8 pcr_i[TPM_DIGEST_SIZE];\n\tint rc;\n\n\tima_used_chip = 0;\n\trc = tpm_pcr_read(TPM_ANY_NUM, 0, pcr_i);\n\tif (rc == 0)\n\t\tima_used_chip = 1;\n\n\tif (!ima_used_chip)\n\t\tpr_info(\"No TPM chip found, activating TPM-bypass! (rc=%d)\\n\",\n\t\t\trc);\n\n\trc = integrity_init_keyring(INTEGRITY_KEYRING_IMA);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ima_init_crypto();\n\tif (rc)\n\t\treturn rc;\n\trc = ima_init_template();\n\tif (rc != 0)\n\t\treturn rc;\n\n\tima_load_kexec_buffer();\n\n\trc = ima_add_boot_aggregate();\t/* boot aggregate must be first entry */\n\tif (rc != 0)\n\t\treturn rc;\n\n\tima_init_policy();\n\n\treturn ima_fs_init();\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_setup",
          "args": [
            "CONFIG_IMA_DEFAULT_HASH"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "hash_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
          "lines": "41-70",
          "snippet": "static int __init hash_setup(char *str)\n{\n\tstruct ima_template_desc *template_desc = ima_template_desc_current();\n\tint i;\n\n\tif (hash_setup_done)\n\t\treturn 1;\n\n\tif (strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) == 0) {\n\t\tif (strncmp(str, \"sha1\", 4) == 0)\n\t\t\tima_hash_algo = HASH_ALGO_SHA1;\n\t\telse if (strncmp(str, \"md5\", 3) == 0)\n\t\t\tima_hash_algo = HASH_ALGO_MD5;\n\t\telse\n\t\t\treturn 1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < HASH_ALGO__LAST; i++) {\n\t\tif (strcmp(str, hash_algo_name[i]) == 0) {\n\t\t\tima_hash_algo = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == HASH_ALGO__LAST)\n\t\treturn 1;\nout:\n\thash_setup_done = 1;\n\treturn 1;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/ima.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/mount.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ima_hash_algo = HASH_ALGO_SHA1;",
            "static int hash_setup_done;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint ima_hash_algo = HASH_ALGO_SHA1;\nstatic int hash_setup_done;\n\nstatic int __init hash_setup(char *str)\n{\n\tstruct ima_template_desc *template_desc = ima_template_desc_current();\n\tint i;\n\n\tif (hash_setup_done)\n\t\treturn 1;\n\n\tif (strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) == 0) {\n\t\tif (strncmp(str, \"sha1\", 4) == 0)\n\t\t\tima_hash_algo = HASH_ALGO_SHA1;\n\t\telse if (strncmp(str, \"md5\", 3) == 0)\n\t\t\tima_hash_algo = HASH_ALGO_MD5;\n\t\telse\n\t\t\treturn 1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < HASH_ALGO__LAST; i++) {\n\t\tif (strcmp(str, hash_algo_name[i]) == 0) {\n\t\t\tima_hash_algo = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == HASH_ALGO__LAST)\n\t\treturn 1;\nout:\n\thash_setup_done = 1;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_init_template_list",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "ima_init_template_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "206-219",
          "snippet": "void ima_init_template_list(void)\n{\n\tint i;\n\n\tif (!list_empty(&defined_templates))\n\t\treturn;\n\n\tspin_lock(&template_list);\n\tfor (i = 0; i < ARRAY_SIZE(builtin_templates); i++) {\n\t\tlist_add_tail_rcu(&builtin_templates[i].list,\n\t\t\t\t  &defined_templates);\n\t}\n\tspin_unlock(&template_list);\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ima_template_desc builtin_templates[] = {\n\t{.name = IMA_TEMPLATE_IMA_NAME, .fmt = IMA_TEMPLATE_IMA_FMT},\n\t{.name = \"ima-ng\", .fmt = \"d-ng|n-ng\"},\n\t{.name = \"ima-sig\", .fmt = \"d-ng|n-ng|sig\"},\n\t{.name = \"\", .fmt = \"\"},\t/* placeholder for a custom format */\n};",
            "static LIST_HEAD(defined_templates);",
            "static DEFINE_SPINLOCK(template_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_desc builtin_templates[] = {\n\t{.name = IMA_TEMPLATE_IMA_NAME, .fmt = IMA_TEMPLATE_IMA_FMT},\n\t{.name = \"ima-ng\", .fmt = \"d-ng|n-ng\"},\n\t{.name = \"ima-sig\", .fmt = \"d-ng|n-ng|sig\"},\n\t{.name = \"\", .fmt = \"\"},\t/* placeholder for a custom format */\n};\nstatic LIST_HEAD(defined_templates);\nstatic DEFINE_SPINLOCK(template_list);\n\nvoid ima_init_template_list(void)\n{\n\tint i;\n\n\tif (!list_empty(&defined_templates))\n\t\treturn;\n\n\tspin_lock(&template_list);\n\tfor (i = 0; i < ARRAY_SIZE(builtin_templates); i++) {\n\t\tlist_add_tail_rcu(&builtin_templates[i].list,\n\t\t\t\t  &defined_templates);\n\t}\n\tspin_unlock(&template_list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint ima_initialized;\n\nstatic int __init init_ima(void)\n{\n\tint error;\n\n\tima_init_template_list();\n\thash_setup(CONFIG_IMA_DEFAULT_HASH);\n\terror = ima_init();\n\tif (!error) {\n\t\tima_initialized = 1;\n\t\tima_update_policy_flag();\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "ima_post_read_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
    "lines": "397-424",
    "snippet": "int ima_post_read_file(struct file *file, void *buf, loff_t size,\n\t\t       enum kernel_read_file_id read_id)\n{\n\tenum ima_hooks func;\n\n\tif (!file && read_id == READING_FIRMWARE) {\n\t\tif ((ima_appraise & IMA_APPRAISE_FIRMWARE) &&\n\t\t    (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\t\treturn -EACCES;\t/* INTEGRITY_UNKNOWN */\n\t\treturn 0;\n\t}\n\n\tif (!file && read_id == READING_MODULE) /* MODULE_SIG_FORCE enabled */\n\t\treturn 0;\n\n\t/* permit signed certs */\n\tif (!file && read_id == READING_X509_CERTIFICATE)\n\t\treturn 0;\n\n\tif (!file || !buf || size == 0) { /* should never happen */\n\t\tif (ima_appraise & IMA_APPRAISE_ENFORCE)\n\t\t\treturn -EACCES;\n\t\treturn 0;\n\t}\n\n\tfunc = read_idmap[read_id] ?: FILE_CHECK;\n\treturn process_measurement(file, buf, size, MAY_READ, func, 0);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/ima.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/mount.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_idmap[READING_MAX_ID] = {\n\t[READING_FIRMWARE] = FIRMWARE_CHECK,\n\t[READING_MODULE] = MODULE_CHECK,\n\t[READING_KEXEC_IMAGE] = KEXEC_KERNEL_CHECK,\n\t[READING_KEXEC_INITRAMFS] = KEXEC_INITRAMFS_CHECK,\n\t[READING_POLICY] = POLICY_CHECK\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_measurement",
          "args": [
            "file",
            "buf",
            "size",
            "MAY_READ",
            "func",
            "0"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "process_measurement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
          "lines": "162-272",
          "snippet": "static int process_measurement(struct file *file, char *buf, loff_t size,\n\t\t\t       int mask, enum ima_hooks func, int opened)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint = NULL;\n\tstruct ima_template_desc *template_desc;\n\tchar *pathbuf = NULL;\n\tchar filename[NAME_MAX];\n\tconst char *pathname = NULL;\n\tint rc = -ENOMEM, action, must_appraise;\n\tint pcr = CONFIG_IMA_MEASURE_PCR_IDX;\n\tstruct evm_ima_xattr_data *xattr_value = NULL;\n\tint xattr_len = 0;\n\tbool violation_check;\n\tenum hash_algo hash_algo;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\t/* Return an IMA_MEASURE, IMA_APPRAISE, IMA_AUDIT action\n\t * bitmask based on the appraise/audit/measurement policy.\n\t * Included is the appraise submask.\n\t */\n\taction = ima_get_action(inode, mask, func, &pcr);\n\tviolation_check = ((func == FILE_CHECK || func == MMAP_CHECK) &&\n\t\t\t   (ima_policy_flag & IMA_MEASURE));\n\tif (!action && !violation_check)\n\t\treturn 0;\n\n\tmust_appraise = action & IMA_APPRAISE;\n\n\t/*  Is the appraise rule hook specific?  */\n\tif (action & IMA_FILE_APPRAISE)\n\t\tfunc = FILE_CHECK;\n\n\tinode_lock(inode);\n\n\tif (action) {\n\t\tiint = integrity_inode_get(inode);\n\t\tif (!iint)\n\t\t\tgoto out;\n\t}\n\n\tif (violation_check) {\n\t\tima_rdwr_violation_check(file, iint, action & IMA_MEASURE,\n\t\t\t\t\t &pathbuf, &pathname);\n\t\tif (!action) {\n\t\t\trc = 0;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/* Determine if already appraised/measured based on bitmask\n\t * (IMA_MEASURE, IMA_MEASURED, IMA_XXXX_APPRAISE, IMA_XXXX_APPRAISED,\n\t *  IMA_AUDIT, IMA_AUDITED)\n\t */\n\tiint->flags |= action;\n\taction &= IMA_DO_MASK;\n\taction &= ~((iint->flags & (IMA_DONE_MASK ^ IMA_MEASURED)) >> 1);\n\n\t/* If target pcr is already measured, unset IMA_MEASURE action */\n\tif ((action & IMA_MEASURE) && (iint->measured_pcrs & (0x1 << pcr)))\n\t\taction ^= IMA_MEASURE;\n\n\t/* Nothing to do, just return existing appraised status */\n\tif (!action) {\n\t\tif (must_appraise)\n\t\t\trc = ima_get_cache_status(iint, func);\n\t\tgoto out_digsig;\n\t}\n\n\ttemplate_desc = ima_template_desc_current();\n\tif ((action & IMA_APPRAISE_SUBMASK) ||\n\t\t    strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) != 0)\n\t\t/* read 'security.ima' */\n\t\txattr_len = ima_read_xattr(file_dentry(file), &xattr_value);\n\n\thash_algo = ima_get_hash_algo(xattr_value, xattr_len);\n\n\trc = ima_collect_measurement(iint, file, buf, size, hash_algo);\n\tif (rc != 0 && rc != -EBADF && rc != -EINVAL)\n\t\tgoto out_digsig;\n\n\tif (!pathbuf)\t/* ima_rdwr_violation possibly pre-fetched */\n\t\tpathname = ima_d_path(&file->f_path, &pathbuf, filename);\n\n\tif (action & IMA_MEASURE)\n\t\tima_store_measurement(iint, file, pathname,\n\t\t\t\t      xattr_value, xattr_len, pcr);\n\tif (rc == 0 && (action & IMA_APPRAISE_SUBMASK))\n\t\trc = ima_appraise_measurement(func, iint, file, pathname,\n\t\t\t\t\t      xattr_value, xattr_len, opened);\n\tif (action & IMA_AUDIT)\n\t\tima_audit_measurement(iint, pathname);\n\n\tif ((file->f_flags & O_DIRECT) && (iint->flags & IMA_PERMIT_DIRECTIO))\n\t\trc = 0;\nout_digsig:\n\tif ((mask & MAY_WRITE) && (iint->flags & IMA_DIGSIG) &&\n\t     !(iint->flags & IMA_NEW_FILE))\n\t\trc = -EACCES;\n\tkfree(xattr_value);\nout_free:\n\tif (pathbuf)\n\t\t__putname(pathbuf);\nout:\n\tinode_unlock(inode);\n\tif ((rc && must_appraise) && (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\treturn -EACCES;\n\treturn 0;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/ima.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/mount.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int process_measurement(struct file *file, char *buf, loff_t size,\n\t\t\t       int mask, enum ima_hooks func, int opened)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint = NULL;\n\tstruct ima_template_desc *template_desc;\n\tchar *pathbuf = NULL;\n\tchar filename[NAME_MAX];\n\tconst char *pathname = NULL;\n\tint rc = -ENOMEM, action, must_appraise;\n\tint pcr = CONFIG_IMA_MEASURE_PCR_IDX;\n\tstruct evm_ima_xattr_data *xattr_value = NULL;\n\tint xattr_len = 0;\n\tbool violation_check;\n\tenum hash_algo hash_algo;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\t/* Return an IMA_MEASURE, IMA_APPRAISE, IMA_AUDIT action\n\t * bitmask based on the appraise/audit/measurement policy.\n\t * Included is the appraise submask.\n\t */\n\taction = ima_get_action(inode, mask, func, &pcr);\n\tviolation_check = ((func == FILE_CHECK || func == MMAP_CHECK) &&\n\t\t\t   (ima_policy_flag & IMA_MEASURE));\n\tif (!action && !violation_check)\n\t\treturn 0;\n\n\tmust_appraise = action & IMA_APPRAISE;\n\n\t/*  Is the appraise rule hook specific?  */\n\tif (action & IMA_FILE_APPRAISE)\n\t\tfunc = FILE_CHECK;\n\n\tinode_lock(inode);\n\n\tif (action) {\n\t\tiint = integrity_inode_get(inode);\n\t\tif (!iint)\n\t\t\tgoto out;\n\t}\n\n\tif (violation_check) {\n\t\tima_rdwr_violation_check(file, iint, action & IMA_MEASURE,\n\t\t\t\t\t &pathbuf, &pathname);\n\t\tif (!action) {\n\t\t\trc = 0;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/* Determine if already appraised/measured based on bitmask\n\t * (IMA_MEASURE, IMA_MEASURED, IMA_XXXX_APPRAISE, IMA_XXXX_APPRAISED,\n\t *  IMA_AUDIT, IMA_AUDITED)\n\t */\n\tiint->flags |= action;\n\taction &= IMA_DO_MASK;\n\taction &= ~((iint->flags & (IMA_DONE_MASK ^ IMA_MEASURED)) >> 1);\n\n\t/* If target pcr is already measured, unset IMA_MEASURE action */\n\tif ((action & IMA_MEASURE) && (iint->measured_pcrs & (0x1 << pcr)))\n\t\taction ^= IMA_MEASURE;\n\n\t/* Nothing to do, just return existing appraised status */\n\tif (!action) {\n\t\tif (must_appraise)\n\t\t\trc = ima_get_cache_status(iint, func);\n\t\tgoto out_digsig;\n\t}\n\n\ttemplate_desc = ima_template_desc_current();\n\tif ((action & IMA_APPRAISE_SUBMASK) ||\n\t\t    strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) != 0)\n\t\t/* read 'security.ima' */\n\t\txattr_len = ima_read_xattr(file_dentry(file), &xattr_value);\n\n\thash_algo = ima_get_hash_algo(xattr_value, xattr_len);\n\n\trc = ima_collect_measurement(iint, file, buf, size, hash_algo);\n\tif (rc != 0 && rc != -EBADF && rc != -EINVAL)\n\t\tgoto out_digsig;\n\n\tif (!pathbuf)\t/* ima_rdwr_violation possibly pre-fetched */\n\t\tpathname = ima_d_path(&file->f_path, &pathbuf, filename);\n\n\tif (action & IMA_MEASURE)\n\t\tima_store_measurement(iint, file, pathname,\n\t\t\t\t      xattr_value, xattr_len, pcr);\n\tif (rc == 0 && (action & IMA_APPRAISE_SUBMASK))\n\t\trc = ima_appraise_measurement(func, iint, file, pathname,\n\t\t\t\t\t      xattr_value, xattr_len, opened);\n\tif (action & IMA_AUDIT)\n\t\tima_audit_measurement(iint, pathname);\n\n\tif ((file->f_flags & O_DIRECT) && (iint->flags & IMA_PERMIT_DIRECTIO))\n\t\trc = 0;\nout_digsig:\n\tif ((mask & MAY_WRITE) && (iint->flags & IMA_DIGSIG) &&\n\t     !(iint->flags & IMA_NEW_FILE))\n\t\trc = -EACCES;\n\tkfree(xattr_value);\nout_free:\n\tif (pathbuf)\n\t\t__putname(pathbuf);\nout:\n\tinode_unlock(inode);\n\tif ((rc && must_appraise) && (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\treturn -EACCES;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int read_idmap[READING_MAX_ID] = {\n\t[READING_FIRMWARE] = FIRMWARE_CHECK,\n\t[READING_MODULE] = MODULE_CHECK,\n\t[READING_KEXEC_IMAGE] = KEXEC_KERNEL_CHECK,\n\t[READING_KEXEC_INITRAMFS] = KEXEC_INITRAMFS_CHECK,\n\t[READING_POLICY] = POLICY_CHECK\n};\n\nint ima_post_read_file(struct file *file, void *buf, loff_t size,\n\t\t       enum kernel_read_file_id read_id)\n{\n\tenum ima_hooks func;\n\n\tif (!file && read_id == READING_FIRMWARE) {\n\t\tif ((ima_appraise & IMA_APPRAISE_FIRMWARE) &&\n\t\t    (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\t\treturn -EACCES;\t/* INTEGRITY_UNKNOWN */\n\t\treturn 0;\n\t}\n\n\tif (!file && read_id == READING_MODULE) /* MODULE_SIG_FORCE enabled */\n\t\treturn 0;\n\n\t/* permit signed certs */\n\tif (!file && read_id == READING_X509_CERTIFICATE)\n\t\treturn 0;\n\n\tif (!file || !buf || size == 0) { /* should never happen */\n\t\tif (ima_appraise & IMA_APPRAISE_ENFORCE)\n\t\t\treturn -EACCES;\n\t\treturn 0;\n\t}\n\n\tfunc = read_idmap[read_id] ?: FILE_CHECK;\n\treturn process_measurement(file, buf, size, MAY_READ, func, 0);\n}"
  },
  {
    "function_name": "ima_read_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
    "lines": "363-374",
    "snippet": "int ima_read_file(struct file *file, enum kernel_read_file_id read_id)\n{\n\tbool sig_enforce = is_module_sig_enforced();\n\n\tif (!file && read_id == READING_MODULE) {\n\t\tif (!sig_enforce && (ima_appraise & IMA_APPRAISE_MODULES) &&\n\t\t    (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\t\treturn -EACCES;\t/* INTEGRITY_UNKNOWN */\n\t\treturn 0;\t/* We rely on module signature checking */\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/ima.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/mount.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_module_sig_enforced",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint ima_read_file(struct file *file, enum kernel_read_file_id read_id)\n{\n\tbool sig_enforce = is_module_sig_enforced();\n\n\tif (!file && read_id == READING_MODULE) {\n\t\tif (!sig_enforce && (ima_appraise & IMA_APPRAISE_MODULES) &&\n\t\t    (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\t\treturn -EACCES;\t/* INTEGRITY_UNKNOWN */\n\t\treturn 0;\t/* We rely on module signature checking */\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ima_post_path_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
    "lines": "337-350",
    "snippet": "void ima_post_path_mknod(struct dentry *dentry)\n{\n\tstruct integrity_iint_cache *iint;\n\tstruct inode *inode = dentry->d_inode;\n\tint must_appraise;\n\n\tmust_appraise = ima_must_appraise(inode, MAY_ACCESS, FILE_CHECK);\n\tif (!must_appraise)\n\t\treturn;\n\n\tiint = integrity_inode_get(inode);\n\tif (iint)\n\t\tiint->flags |= IMA_NEW_FILE;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/ima.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/mount.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "integrity_inode_get",
          "args": [
            "inode"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_inode_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/iint.c",
          "lines": "93-128",
          "snippet": "struct integrity_iint_cache *integrity_inode_get(struct inode *inode)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *node, *parent = NULL;\n\tstruct integrity_iint_cache *iint, *test_iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\treturn iint;\n\n\tiint = kmem_cache_alloc(iint_cache, GFP_NOFS);\n\tif (!iint)\n\t\treturn NULL;\n\n\twrite_lock(&integrity_iint_lock);\n\n\tp = &integrity_iint_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\ttest_iint = rb_entry(parent, struct integrity_iint_cache,\n\t\t\t\t     rb_node);\n\t\tif (inode < test_iint->inode)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tiint->inode = inode;\n\tnode = &iint->rb_node;\n\tinode->i_flags |= S_IMA;\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, &integrity_iint_tree);\n\n\twrite_unlock(&integrity_iint_lock);\n\treturn iint;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root integrity_iint_tree = RB_ROOT;",
            "static DEFINE_RWLOCK(integrity_iint_lock);",
            "static struct kmem_cache *iint_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic struct rb_root integrity_iint_tree = RB_ROOT;\nstatic DEFINE_RWLOCK(integrity_iint_lock);\nstatic struct kmem_cache *iint_cache;\n\nstruct integrity_iint_cache *integrity_inode_get(struct inode *inode)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *node, *parent = NULL;\n\tstruct integrity_iint_cache *iint, *test_iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\treturn iint;\n\n\tiint = kmem_cache_alloc(iint_cache, GFP_NOFS);\n\tif (!iint)\n\t\treturn NULL;\n\n\twrite_lock(&integrity_iint_lock);\n\n\tp = &integrity_iint_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\ttest_iint = rb_entry(parent, struct integrity_iint_cache,\n\t\t\t\t     rb_node);\n\t\tif (inode < test_iint->inode)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tiint->inode = inode;\n\tnode = &iint->rb_node;\n\tinode->i_flags |= S_IMA;\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, &integrity_iint_tree);\n\n\twrite_unlock(&integrity_iint_lock);\n\treturn iint;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_must_appraise",
          "args": [
            "inode",
            "MAY_ACCESS",
            "FILE_CHECK"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ima_must_appraise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima.h",
          "lines": "262-266",
          "snippet": "static inline int ima_must_appraise(struct inode *inode, int mask,\n\t\t\t\t    enum ima_hooks func)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ima.h>",
            "#include \"../integrity.h\"",
            "#include <crypto/hash_info.h>",
            "#include <linux/audit.h>",
            "#include <linux/tpm.h>",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/crypto.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ima.h>\n#include \"../integrity.h\"\n#include <crypto/hash_info.h>\n#include <linux/audit.h>\n#include <linux/tpm.h>\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n\nstatic inline int ima_must_appraise(struct inode *inode, int mask,\n\t\t\t\t    enum ima_hooks func)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nvoid ima_post_path_mknod(struct dentry *dentry)\n{\n\tstruct integrity_iint_cache *iint;\n\tstruct inode *inode = dentry->d_inode;\n\tint must_appraise;\n\n\tmust_appraise = ima_must_appraise(inode, MAY_ACCESS, FILE_CHECK);\n\tif (!must_appraise)\n\t\treturn;\n\n\tiint = integrity_inode_get(inode);\n\tif (iint)\n\t\tiint->flags |= IMA_NEW_FILE;\n}"
  },
  {
    "function_name": "ima_file_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
    "lines": "322-327",
    "snippet": "int ima_file_check(struct file *file, int mask, int opened)\n{\n\treturn process_measurement(file, NULL, 0,\n\t\t\t\t   mask & (MAY_READ | MAY_WRITE | MAY_EXEC |\n\t\t\t\t\t   MAY_APPEND), FILE_CHECK, opened);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/ima.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/mount.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_measurement",
          "args": [
            "file",
            "NULL",
            "0",
            "mask & (MAY_READ | MAY_WRITE | MAY_EXEC |\n\t\t\t\t\t   MAY_APPEND)",
            "FILE_CHECK",
            "opened"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "process_measurement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
          "lines": "162-272",
          "snippet": "static int process_measurement(struct file *file, char *buf, loff_t size,\n\t\t\t       int mask, enum ima_hooks func, int opened)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint = NULL;\n\tstruct ima_template_desc *template_desc;\n\tchar *pathbuf = NULL;\n\tchar filename[NAME_MAX];\n\tconst char *pathname = NULL;\n\tint rc = -ENOMEM, action, must_appraise;\n\tint pcr = CONFIG_IMA_MEASURE_PCR_IDX;\n\tstruct evm_ima_xattr_data *xattr_value = NULL;\n\tint xattr_len = 0;\n\tbool violation_check;\n\tenum hash_algo hash_algo;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\t/* Return an IMA_MEASURE, IMA_APPRAISE, IMA_AUDIT action\n\t * bitmask based on the appraise/audit/measurement policy.\n\t * Included is the appraise submask.\n\t */\n\taction = ima_get_action(inode, mask, func, &pcr);\n\tviolation_check = ((func == FILE_CHECK || func == MMAP_CHECK) &&\n\t\t\t   (ima_policy_flag & IMA_MEASURE));\n\tif (!action && !violation_check)\n\t\treturn 0;\n\n\tmust_appraise = action & IMA_APPRAISE;\n\n\t/*  Is the appraise rule hook specific?  */\n\tif (action & IMA_FILE_APPRAISE)\n\t\tfunc = FILE_CHECK;\n\n\tinode_lock(inode);\n\n\tif (action) {\n\t\tiint = integrity_inode_get(inode);\n\t\tif (!iint)\n\t\t\tgoto out;\n\t}\n\n\tif (violation_check) {\n\t\tima_rdwr_violation_check(file, iint, action & IMA_MEASURE,\n\t\t\t\t\t &pathbuf, &pathname);\n\t\tif (!action) {\n\t\t\trc = 0;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/* Determine if already appraised/measured based on bitmask\n\t * (IMA_MEASURE, IMA_MEASURED, IMA_XXXX_APPRAISE, IMA_XXXX_APPRAISED,\n\t *  IMA_AUDIT, IMA_AUDITED)\n\t */\n\tiint->flags |= action;\n\taction &= IMA_DO_MASK;\n\taction &= ~((iint->flags & (IMA_DONE_MASK ^ IMA_MEASURED)) >> 1);\n\n\t/* If target pcr is already measured, unset IMA_MEASURE action */\n\tif ((action & IMA_MEASURE) && (iint->measured_pcrs & (0x1 << pcr)))\n\t\taction ^= IMA_MEASURE;\n\n\t/* Nothing to do, just return existing appraised status */\n\tif (!action) {\n\t\tif (must_appraise)\n\t\t\trc = ima_get_cache_status(iint, func);\n\t\tgoto out_digsig;\n\t}\n\n\ttemplate_desc = ima_template_desc_current();\n\tif ((action & IMA_APPRAISE_SUBMASK) ||\n\t\t    strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) != 0)\n\t\t/* read 'security.ima' */\n\t\txattr_len = ima_read_xattr(file_dentry(file), &xattr_value);\n\n\thash_algo = ima_get_hash_algo(xattr_value, xattr_len);\n\n\trc = ima_collect_measurement(iint, file, buf, size, hash_algo);\n\tif (rc != 0 && rc != -EBADF && rc != -EINVAL)\n\t\tgoto out_digsig;\n\n\tif (!pathbuf)\t/* ima_rdwr_violation possibly pre-fetched */\n\t\tpathname = ima_d_path(&file->f_path, &pathbuf, filename);\n\n\tif (action & IMA_MEASURE)\n\t\tima_store_measurement(iint, file, pathname,\n\t\t\t\t      xattr_value, xattr_len, pcr);\n\tif (rc == 0 && (action & IMA_APPRAISE_SUBMASK))\n\t\trc = ima_appraise_measurement(func, iint, file, pathname,\n\t\t\t\t\t      xattr_value, xattr_len, opened);\n\tif (action & IMA_AUDIT)\n\t\tima_audit_measurement(iint, pathname);\n\n\tif ((file->f_flags & O_DIRECT) && (iint->flags & IMA_PERMIT_DIRECTIO))\n\t\trc = 0;\nout_digsig:\n\tif ((mask & MAY_WRITE) && (iint->flags & IMA_DIGSIG) &&\n\t     !(iint->flags & IMA_NEW_FILE))\n\t\trc = -EACCES;\n\tkfree(xattr_value);\nout_free:\n\tif (pathbuf)\n\t\t__putname(pathbuf);\nout:\n\tinode_unlock(inode);\n\tif ((rc && must_appraise) && (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\treturn -EACCES;\n\treturn 0;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/ima.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/mount.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int process_measurement(struct file *file, char *buf, loff_t size,\n\t\t\t       int mask, enum ima_hooks func, int opened)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint = NULL;\n\tstruct ima_template_desc *template_desc;\n\tchar *pathbuf = NULL;\n\tchar filename[NAME_MAX];\n\tconst char *pathname = NULL;\n\tint rc = -ENOMEM, action, must_appraise;\n\tint pcr = CONFIG_IMA_MEASURE_PCR_IDX;\n\tstruct evm_ima_xattr_data *xattr_value = NULL;\n\tint xattr_len = 0;\n\tbool violation_check;\n\tenum hash_algo hash_algo;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\t/* Return an IMA_MEASURE, IMA_APPRAISE, IMA_AUDIT action\n\t * bitmask based on the appraise/audit/measurement policy.\n\t * Included is the appraise submask.\n\t */\n\taction = ima_get_action(inode, mask, func, &pcr);\n\tviolation_check = ((func == FILE_CHECK || func == MMAP_CHECK) &&\n\t\t\t   (ima_policy_flag & IMA_MEASURE));\n\tif (!action && !violation_check)\n\t\treturn 0;\n\n\tmust_appraise = action & IMA_APPRAISE;\n\n\t/*  Is the appraise rule hook specific?  */\n\tif (action & IMA_FILE_APPRAISE)\n\t\tfunc = FILE_CHECK;\n\n\tinode_lock(inode);\n\n\tif (action) {\n\t\tiint = integrity_inode_get(inode);\n\t\tif (!iint)\n\t\t\tgoto out;\n\t}\n\n\tif (violation_check) {\n\t\tima_rdwr_violation_check(file, iint, action & IMA_MEASURE,\n\t\t\t\t\t &pathbuf, &pathname);\n\t\tif (!action) {\n\t\t\trc = 0;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/* Determine if already appraised/measured based on bitmask\n\t * (IMA_MEASURE, IMA_MEASURED, IMA_XXXX_APPRAISE, IMA_XXXX_APPRAISED,\n\t *  IMA_AUDIT, IMA_AUDITED)\n\t */\n\tiint->flags |= action;\n\taction &= IMA_DO_MASK;\n\taction &= ~((iint->flags & (IMA_DONE_MASK ^ IMA_MEASURED)) >> 1);\n\n\t/* If target pcr is already measured, unset IMA_MEASURE action */\n\tif ((action & IMA_MEASURE) && (iint->measured_pcrs & (0x1 << pcr)))\n\t\taction ^= IMA_MEASURE;\n\n\t/* Nothing to do, just return existing appraised status */\n\tif (!action) {\n\t\tif (must_appraise)\n\t\t\trc = ima_get_cache_status(iint, func);\n\t\tgoto out_digsig;\n\t}\n\n\ttemplate_desc = ima_template_desc_current();\n\tif ((action & IMA_APPRAISE_SUBMASK) ||\n\t\t    strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) != 0)\n\t\t/* read 'security.ima' */\n\t\txattr_len = ima_read_xattr(file_dentry(file), &xattr_value);\n\n\thash_algo = ima_get_hash_algo(xattr_value, xattr_len);\n\n\trc = ima_collect_measurement(iint, file, buf, size, hash_algo);\n\tif (rc != 0 && rc != -EBADF && rc != -EINVAL)\n\t\tgoto out_digsig;\n\n\tif (!pathbuf)\t/* ima_rdwr_violation possibly pre-fetched */\n\t\tpathname = ima_d_path(&file->f_path, &pathbuf, filename);\n\n\tif (action & IMA_MEASURE)\n\t\tima_store_measurement(iint, file, pathname,\n\t\t\t\t      xattr_value, xattr_len, pcr);\n\tif (rc == 0 && (action & IMA_APPRAISE_SUBMASK))\n\t\trc = ima_appraise_measurement(func, iint, file, pathname,\n\t\t\t\t\t      xattr_value, xattr_len, opened);\n\tif (action & IMA_AUDIT)\n\t\tima_audit_measurement(iint, pathname);\n\n\tif ((file->f_flags & O_DIRECT) && (iint->flags & IMA_PERMIT_DIRECTIO))\n\t\trc = 0;\nout_digsig:\n\tif ((mask & MAY_WRITE) && (iint->flags & IMA_DIGSIG) &&\n\t     !(iint->flags & IMA_NEW_FILE))\n\t\trc = -EACCES;\n\tkfree(xattr_value);\nout_free:\n\tif (pathbuf)\n\t\t__putname(pathbuf);\nout:\n\tinode_unlock(inode);\n\tif ((rc && must_appraise) && (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\treturn -EACCES;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint ima_file_check(struct file *file, int mask, int opened)\n{\n\treturn process_measurement(file, NULL, 0,\n\t\t\t\t   mask & (MAY_READ | MAY_WRITE | MAY_EXEC |\n\t\t\t\t\t   MAY_APPEND), FILE_CHECK, opened);\n}"
  },
  {
    "function_name": "ima_bprm_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
    "lines": "306-310",
    "snippet": "int ima_bprm_check(struct linux_binprm *bprm)\n{\n\treturn process_measurement(bprm->file, NULL, 0, MAY_EXEC,\n\t\t\t\t   BPRM_CHECK, 0);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/ima.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/mount.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_measurement",
          "args": [
            "bprm->file",
            "NULL",
            "0",
            "MAY_EXEC",
            "BPRM_CHECK",
            "0"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "process_measurement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
          "lines": "162-272",
          "snippet": "static int process_measurement(struct file *file, char *buf, loff_t size,\n\t\t\t       int mask, enum ima_hooks func, int opened)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint = NULL;\n\tstruct ima_template_desc *template_desc;\n\tchar *pathbuf = NULL;\n\tchar filename[NAME_MAX];\n\tconst char *pathname = NULL;\n\tint rc = -ENOMEM, action, must_appraise;\n\tint pcr = CONFIG_IMA_MEASURE_PCR_IDX;\n\tstruct evm_ima_xattr_data *xattr_value = NULL;\n\tint xattr_len = 0;\n\tbool violation_check;\n\tenum hash_algo hash_algo;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\t/* Return an IMA_MEASURE, IMA_APPRAISE, IMA_AUDIT action\n\t * bitmask based on the appraise/audit/measurement policy.\n\t * Included is the appraise submask.\n\t */\n\taction = ima_get_action(inode, mask, func, &pcr);\n\tviolation_check = ((func == FILE_CHECK || func == MMAP_CHECK) &&\n\t\t\t   (ima_policy_flag & IMA_MEASURE));\n\tif (!action && !violation_check)\n\t\treturn 0;\n\n\tmust_appraise = action & IMA_APPRAISE;\n\n\t/*  Is the appraise rule hook specific?  */\n\tif (action & IMA_FILE_APPRAISE)\n\t\tfunc = FILE_CHECK;\n\n\tinode_lock(inode);\n\n\tif (action) {\n\t\tiint = integrity_inode_get(inode);\n\t\tif (!iint)\n\t\t\tgoto out;\n\t}\n\n\tif (violation_check) {\n\t\tima_rdwr_violation_check(file, iint, action & IMA_MEASURE,\n\t\t\t\t\t &pathbuf, &pathname);\n\t\tif (!action) {\n\t\t\trc = 0;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/* Determine if already appraised/measured based on bitmask\n\t * (IMA_MEASURE, IMA_MEASURED, IMA_XXXX_APPRAISE, IMA_XXXX_APPRAISED,\n\t *  IMA_AUDIT, IMA_AUDITED)\n\t */\n\tiint->flags |= action;\n\taction &= IMA_DO_MASK;\n\taction &= ~((iint->flags & (IMA_DONE_MASK ^ IMA_MEASURED)) >> 1);\n\n\t/* If target pcr is already measured, unset IMA_MEASURE action */\n\tif ((action & IMA_MEASURE) && (iint->measured_pcrs & (0x1 << pcr)))\n\t\taction ^= IMA_MEASURE;\n\n\t/* Nothing to do, just return existing appraised status */\n\tif (!action) {\n\t\tif (must_appraise)\n\t\t\trc = ima_get_cache_status(iint, func);\n\t\tgoto out_digsig;\n\t}\n\n\ttemplate_desc = ima_template_desc_current();\n\tif ((action & IMA_APPRAISE_SUBMASK) ||\n\t\t    strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) != 0)\n\t\t/* read 'security.ima' */\n\t\txattr_len = ima_read_xattr(file_dentry(file), &xattr_value);\n\n\thash_algo = ima_get_hash_algo(xattr_value, xattr_len);\n\n\trc = ima_collect_measurement(iint, file, buf, size, hash_algo);\n\tif (rc != 0 && rc != -EBADF && rc != -EINVAL)\n\t\tgoto out_digsig;\n\n\tif (!pathbuf)\t/* ima_rdwr_violation possibly pre-fetched */\n\t\tpathname = ima_d_path(&file->f_path, &pathbuf, filename);\n\n\tif (action & IMA_MEASURE)\n\t\tima_store_measurement(iint, file, pathname,\n\t\t\t\t      xattr_value, xattr_len, pcr);\n\tif (rc == 0 && (action & IMA_APPRAISE_SUBMASK))\n\t\trc = ima_appraise_measurement(func, iint, file, pathname,\n\t\t\t\t\t      xattr_value, xattr_len, opened);\n\tif (action & IMA_AUDIT)\n\t\tima_audit_measurement(iint, pathname);\n\n\tif ((file->f_flags & O_DIRECT) && (iint->flags & IMA_PERMIT_DIRECTIO))\n\t\trc = 0;\nout_digsig:\n\tif ((mask & MAY_WRITE) && (iint->flags & IMA_DIGSIG) &&\n\t     !(iint->flags & IMA_NEW_FILE))\n\t\trc = -EACCES;\n\tkfree(xattr_value);\nout_free:\n\tif (pathbuf)\n\t\t__putname(pathbuf);\nout:\n\tinode_unlock(inode);\n\tif ((rc && must_appraise) && (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\treturn -EACCES;\n\treturn 0;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/ima.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/mount.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int process_measurement(struct file *file, char *buf, loff_t size,\n\t\t\t       int mask, enum ima_hooks func, int opened)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint = NULL;\n\tstruct ima_template_desc *template_desc;\n\tchar *pathbuf = NULL;\n\tchar filename[NAME_MAX];\n\tconst char *pathname = NULL;\n\tint rc = -ENOMEM, action, must_appraise;\n\tint pcr = CONFIG_IMA_MEASURE_PCR_IDX;\n\tstruct evm_ima_xattr_data *xattr_value = NULL;\n\tint xattr_len = 0;\n\tbool violation_check;\n\tenum hash_algo hash_algo;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\t/* Return an IMA_MEASURE, IMA_APPRAISE, IMA_AUDIT action\n\t * bitmask based on the appraise/audit/measurement policy.\n\t * Included is the appraise submask.\n\t */\n\taction = ima_get_action(inode, mask, func, &pcr);\n\tviolation_check = ((func == FILE_CHECK || func == MMAP_CHECK) &&\n\t\t\t   (ima_policy_flag & IMA_MEASURE));\n\tif (!action && !violation_check)\n\t\treturn 0;\n\n\tmust_appraise = action & IMA_APPRAISE;\n\n\t/*  Is the appraise rule hook specific?  */\n\tif (action & IMA_FILE_APPRAISE)\n\t\tfunc = FILE_CHECK;\n\n\tinode_lock(inode);\n\n\tif (action) {\n\t\tiint = integrity_inode_get(inode);\n\t\tif (!iint)\n\t\t\tgoto out;\n\t}\n\n\tif (violation_check) {\n\t\tima_rdwr_violation_check(file, iint, action & IMA_MEASURE,\n\t\t\t\t\t &pathbuf, &pathname);\n\t\tif (!action) {\n\t\t\trc = 0;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/* Determine if already appraised/measured based on bitmask\n\t * (IMA_MEASURE, IMA_MEASURED, IMA_XXXX_APPRAISE, IMA_XXXX_APPRAISED,\n\t *  IMA_AUDIT, IMA_AUDITED)\n\t */\n\tiint->flags |= action;\n\taction &= IMA_DO_MASK;\n\taction &= ~((iint->flags & (IMA_DONE_MASK ^ IMA_MEASURED)) >> 1);\n\n\t/* If target pcr is already measured, unset IMA_MEASURE action */\n\tif ((action & IMA_MEASURE) && (iint->measured_pcrs & (0x1 << pcr)))\n\t\taction ^= IMA_MEASURE;\n\n\t/* Nothing to do, just return existing appraised status */\n\tif (!action) {\n\t\tif (must_appraise)\n\t\t\trc = ima_get_cache_status(iint, func);\n\t\tgoto out_digsig;\n\t}\n\n\ttemplate_desc = ima_template_desc_current();\n\tif ((action & IMA_APPRAISE_SUBMASK) ||\n\t\t    strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) != 0)\n\t\t/* read 'security.ima' */\n\t\txattr_len = ima_read_xattr(file_dentry(file), &xattr_value);\n\n\thash_algo = ima_get_hash_algo(xattr_value, xattr_len);\n\n\trc = ima_collect_measurement(iint, file, buf, size, hash_algo);\n\tif (rc != 0 && rc != -EBADF && rc != -EINVAL)\n\t\tgoto out_digsig;\n\n\tif (!pathbuf)\t/* ima_rdwr_violation possibly pre-fetched */\n\t\tpathname = ima_d_path(&file->f_path, &pathbuf, filename);\n\n\tif (action & IMA_MEASURE)\n\t\tima_store_measurement(iint, file, pathname,\n\t\t\t\t      xattr_value, xattr_len, pcr);\n\tif (rc == 0 && (action & IMA_APPRAISE_SUBMASK))\n\t\trc = ima_appraise_measurement(func, iint, file, pathname,\n\t\t\t\t\t      xattr_value, xattr_len, opened);\n\tif (action & IMA_AUDIT)\n\t\tima_audit_measurement(iint, pathname);\n\n\tif ((file->f_flags & O_DIRECT) && (iint->flags & IMA_PERMIT_DIRECTIO))\n\t\trc = 0;\nout_digsig:\n\tif ((mask & MAY_WRITE) && (iint->flags & IMA_DIGSIG) &&\n\t     !(iint->flags & IMA_NEW_FILE))\n\t\trc = -EACCES;\n\tkfree(xattr_value);\nout_free:\n\tif (pathbuf)\n\t\t__putname(pathbuf);\nout:\n\tinode_unlock(inode);\n\tif ((rc && must_appraise) && (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\treturn -EACCES;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint ima_bprm_check(struct linux_binprm *bprm)\n{\n\treturn process_measurement(bprm->file, NULL, 0, MAY_EXEC,\n\t\t\t\t   BPRM_CHECK, 0);\n}"
  },
  {
    "function_name": "ima_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
    "lines": "285-291",
    "snippet": "int ima_file_mmap(struct file *file, unsigned long prot)\n{\n\tif (file && (prot & PROT_EXEC))\n\t\treturn process_measurement(file, NULL, 0, MAY_EXEC,\n\t\t\t\t\t   MMAP_CHECK, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/ima.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/mount.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_measurement",
          "args": [
            "file",
            "NULL",
            "0",
            "MAY_EXEC",
            "MMAP_CHECK",
            "0"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "process_measurement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
          "lines": "162-272",
          "snippet": "static int process_measurement(struct file *file, char *buf, loff_t size,\n\t\t\t       int mask, enum ima_hooks func, int opened)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint = NULL;\n\tstruct ima_template_desc *template_desc;\n\tchar *pathbuf = NULL;\n\tchar filename[NAME_MAX];\n\tconst char *pathname = NULL;\n\tint rc = -ENOMEM, action, must_appraise;\n\tint pcr = CONFIG_IMA_MEASURE_PCR_IDX;\n\tstruct evm_ima_xattr_data *xattr_value = NULL;\n\tint xattr_len = 0;\n\tbool violation_check;\n\tenum hash_algo hash_algo;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\t/* Return an IMA_MEASURE, IMA_APPRAISE, IMA_AUDIT action\n\t * bitmask based on the appraise/audit/measurement policy.\n\t * Included is the appraise submask.\n\t */\n\taction = ima_get_action(inode, mask, func, &pcr);\n\tviolation_check = ((func == FILE_CHECK || func == MMAP_CHECK) &&\n\t\t\t   (ima_policy_flag & IMA_MEASURE));\n\tif (!action && !violation_check)\n\t\treturn 0;\n\n\tmust_appraise = action & IMA_APPRAISE;\n\n\t/*  Is the appraise rule hook specific?  */\n\tif (action & IMA_FILE_APPRAISE)\n\t\tfunc = FILE_CHECK;\n\n\tinode_lock(inode);\n\n\tif (action) {\n\t\tiint = integrity_inode_get(inode);\n\t\tif (!iint)\n\t\t\tgoto out;\n\t}\n\n\tif (violation_check) {\n\t\tima_rdwr_violation_check(file, iint, action & IMA_MEASURE,\n\t\t\t\t\t &pathbuf, &pathname);\n\t\tif (!action) {\n\t\t\trc = 0;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/* Determine if already appraised/measured based on bitmask\n\t * (IMA_MEASURE, IMA_MEASURED, IMA_XXXX_APPRAISE, IMA_XXXX_APPRAISED,\n\t *  IMA_AUDIT, IMA_AUDITED)\n\t */\n\tiint->flags |= action;\n\taction &= IMA_DO_MASK;\n\taction &= ~((iint->flags & (IMA_DONE_MASK ^ IMA_MEASURED)) >> 1);\n\n\t/* If target pcr is already measured, unset IMA_MEASURE action */\n\tif ((action & IMA_MEASURE) && (iint->measured_pcrs & (0x1 << pcr)))\n\t\taction ^= IMA_MEASURE;\n\n\t/* Nothing to do, just return existing appraised status */\n\tif (!action) {\n\t\tif (must_appraise)\n\t\t\trc = ima_get_cache_status(iint, func);\n\t\tgoto out_digsig;\n\t}\n\n\ttemplate_desc = ima_template_desc_current();\n\tif ((action & IMA_APPRAISE_SUBMASK) ||\n\t\t    strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) != 0)\n\t\t/* read 'security.ima' */\n\t\txattr_len = ima_read_xattr(file_dentry(file), &xattr_value);\n\n\thash_algo = ima_get_hash_algo(xattr_value, xattr_len);\n\n\trc = ima_collect_measurement(iint, file, buf, size, hash_algo);\n\tif (rc != 0 && rc != -EBADF && rc != -EINVAL)\n\t\tgoto out_digsig;\n\n\tif (!pathbuf)\t/* ima_rdwr_violation possibly pre-fetched */\n\t\tpathname = ima_d_path(&file->f_path, &pathbuf, filename);\n\n\tif (action & IMA_MEASURE)\n\t\tima_store_measurement(iint, file, pathname,\n\t\t\t\t      xattr_value, xattr_len, pcr);\n\tif (rc == 0 && (action & IMA_APPRAISE_SUBMASK))\n\t\trc = ima_appraise_measurement(func, iint, file, pathname,\n\t\t\t\t\t      xattr_value, xattr_len, opened);\n\tif (action & IMA_AUDIT)\n\t\tima_audit_measurement(iint, pathname);\n\n\tif ((file->f_flags & O_DIRECT) && (iint->flags & IMA_PERMIT_DIRECTIO))\n\t\trc = 0;\nout_digsig:\n\tif ((mask & MAY_WRITE) && (iint->flags & IMA_DIGSIG) &&\n\t     !(iint->flags & IMA_NEW_FILE))\n\t\trc = -EACCES;\n\tkfree(xattr_value);\nout_free:\n\tif (pathbuf)\n\t\t__putname(pathbuf);\nout:\n\tinode_unlock(inode);\n\tif ((rc && must_appraise) && (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\treturn -EACCES;\n\treturn 0;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/ima.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/mount.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int process_measurement(struct file *file, char *buf, loff_t size,\n\t\t\t       int mask, enum ima_hooks func, int opened)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint = NULL;\n\tstruct ima_template_desc *template_desc;\n\tchar *pathbuf = NULL;\n\tchar filename[NAME_MAX];\n\tconst char *pathname = NULL;\n\tint rc = -ENOMEM, action, must_appraise;\n\tint pcr = CONFIG_IMA_MEASURE_PCR_IDX;\n\tstruct evm_ima_xattr_data *xattr_value = NULL;\n\tint xattr_len = 0;\n\tbool violation_check;\n\tenum hash_algo hash_algo;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\t/* Return an IMA_MEASURE, IMA_APPRAISE, IMA_AUDIT action\n\t * bitmask based on the appraise/audit/measurement policy.\n\t * Included is the appraise submask.\n\t */\n\taction = ima_get_action(inode, mask, func, &pcr);\n\tviolation_check = ((func == FILE_CHECK || func == MMAP_CHECK) &&\n\t\t\t   (ima_policy_flag & IMA_MEASURE));\n\tif (!action && !violation_check)\n\t\treturn 0;\n\n\tmust_appraise = action & IMA_APPRAISE;\n\n\t/*  Is the appraise rule hook specific?  */\n\tif (action & IMA_FILE_APPRAISE)\n\t\tfunc = FILE_CHECK;\n\n\tinode_lock(inode);\n\n\tif (action) {\n\t\tiint = integrity_inode_get(inode);\n\t\tif (!iint)\n\t\t\tgoto out;\n\t}\n\n\tif (violation_check) {\n\t\tima_rdwr_violation_check(file, iint, action & IMA_MEASURE,\n\t\t\t\t\t &pathbuf, &pathname);\n\t\tif (!action) {\n\t\t\trc = 0;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/* Determine if already appraised/measured based on bitmask\n\t * (IMA_MEASURE, IMA_MEASURED, IMA_XXXX_APPRAISE, IMA_XXXX_APPRAISED,\n\t *  IMA_AUDIT, IMA_AUDITED)\n\t */\n\tiint->flags |= action;\n\taction &= IMA_DO_MASK;\n\taction &= ~((iint->flags & (IMA_DONE_MASK ^ IMA_MEASURED)) >> 1);\n\n\t/* If target pcr is already measured, unset IMA_MEASURE action */\n\tif ((action & IMA_MEASURE) && (iint->measured_pcrs & (0x1 << pcr)))\n\t\taction ^= IMA_MEASURE;\n\n\t/* Nothing to do, just return existing appraised status */\n\tif (!action) {\n\t\tif (must_appraise)\n\t\t\trc = ima_get_cache_status(iint, func);\n\t\tgoto out_digsig;\n\t}\n\n\ttemplate_desc = ima_template_desc_current();\n\tif ((action & IMA_APPRAISE_SUBMASK) ||\n\t\t    strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) != 0)\n\t\t/* read 'security.ima' */\n\t\txattr_len = ima_read_xattr(file_dentry(file), &xattr_value);\n\n\thash_algo = ima_get_hash_algo(xattr_value, xattr_len);\n\n\trc = ima_collect_measurement(iint, file, buf, size, hash_algo);\n\tif (rc != 0 && rc != -EBADF && rc != -EINVAL)\n\t\tgoto out_digsig;\n\n\tif (!pathbuf)\t/* ima_rdwr_violation possibly pre-fetched */\n\t\tpathname = ima_d_path(&file->f_path, &pathbuf, filename);\n\n\tif (action & IMA_MEASURE)\n\t\tima_store_measurement(iint, file, pathname,\n\t\t\t\t      xattr_value, xattr_len, pcr);\n\tif (rc == 0 && (action & IMA_APPRAISE_SUBMASK))\n\t\trc = ima_appraise_measurement(func, iint, file, pathname,\n\t\t\t\t\t      xattr_value, xattr_len, opened);\n\tif (action & IMA_AUDIT)\n\t\tima_audit_measurement(iint, pathname);\n\n\tif ((file->f_flags & O_DIRECT) && (iint->flags & IMA_PERMIT_DIRECTIO))\n\t\trc = 0;\nout_digsig:\n\tif ((mask & MAY_WRITE) && (iint->flags & IMA_DIGSIG) &&\n\t     !(iint->flags & IMA_NEW_FILE))\n\t\trc = -EACCES;\n\tkfree(xattr_value);\nout_free:\n\tif (pathbuf)\n\t\t__putname(pathbuf);\nout:\n\tinode_unlock(inode);\n\tif ((rc && must_appraise) && (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\treturn -EACCES;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint ima_file_mmap(struct file *file, unsigned long prot)\n{\n\tif (file && (prot & PROT_EXEC))\n\t\treturn process_measurement(file, NULL, 0, MAY_EXEC,\n\t\t\t\t\t   MMAP_CHECK, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "process_measurement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
    "lines": "162-272",
    "snippet": "static int process_measurement(struct file *file, char *buf, loff_t size,\n\t\t\t       int mask, enum ima_hooks func, int opened)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint = NULL;\n\tstruct ima_template_desc *template_desc;\n\tchar *pathbuf = NULL;\n\tchar filename[NAME_MAX];\n\tconst char *pathname = NULL;\n\tint rc = -ENOMEM, action, must_appraise;\n\tint pcr = CONFIG_IMA_MEASURE_PCR_IDX;\n\tstruct evm_ima_xattr_data *xattr_value = NULL;\n\tint xattr_len = 0;\n\tbool violation_check;\n\tenum hash_algo hash_algo;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\t/* Return an IMA_MEASURE, IMA_APPRAISE, IMA_AUDIT action\n\t * bitmask based on the appraise/audit/measurement policy.\n\t * Included is the appraise submask.\n\t */\n\taction = ima_get_action(inode, mask, func, &pcr);\n\tviolation_check = ((func == FILE_CHECK || func == MMAP_CHECK) &&\n\t\t\t   (ima_policy_flag & IMA_MEASURE));\n\tif (!action && !violation_check)\n\t\treturn 0;\n\n\tmust_appraise = action & IMA_APPRAISE;\n\n\t/*  Is the appraise rule hook specific?  */\n\tif (action & IMA_FILE_APPRAISE)\n\t\tfunc = FILE_CHECK;\n\n\tinode_lock(inode);\n\n\tif (action) {\n\t\tiint = integrity_inode_get(inode);\n\t\tif (!iint)\n\t\t\tgoto out;\n\t}\n\n\tif (violation_check) {\n\t\tima_rdwr_violation_check(file, iint, action & IMA_MEASURE,\n\t\t\t\t\t &pathbuf, &pathname);\n\t\tif (!action) {\n\t\t\trc = 0;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/* Determine if already appraised/measured based on bitmask\n\t * (IMA_MEASURE, IMA_MEASURED, IMA_XXXX_APPRAISE, IMA_XXXX_APPRAISED,\n\t *  IMA_AUDIT, IMA_AUDITED)\n\t */\n\tiint->flags |= action;\n\taction &= IMA_DO_MASK;\n\taction &= ~((iint->flags & (IMA_DONE_MASK ^ IMA_MEASURED)) >> 1);\n\n\t/* If target pcr is already measured, unset IMA_MEASURE action */\n\tif ((action & IMA_MEASURE) && (iint->measured_pcrs & (0x1 << pcr)))\n\t\taction ^= IMA_MEASURE;\n\n\t/* Nothing to do, just return existing appraised status */\n\tif (!action) {\n\t\tif (must_appraise)\n\t\t\trc = ima_get_cache_status(iint, func);\n\t\tgoto out_digsig;\n\t}\n\n\ttemplate_desc = ima_template_desc_current();\n\tif ((action & IMA_APPRAISE_SUBMASK) ||\n\t\t    strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) != 0)\n\t\t/* read 'security.ima' */\n\t\txattr_len = ima_read_xattr(file_dentry(file), &xattr_value);\n\n\thash_algo = ima_get_hash_algo(xattr_value, xattr_len);\n\n\trc = ima_collect_measurement(iint, file, buf, size, hash_algo);\n\tif (rc != 0 && rc != -EBADF && rc != -EINVAL)\n\t\tgoto out_digsig;\n\n\tif (!pathbuf)\t/* ima_rdwr_violation possibly pre-fetched */\n\t\tpathname = ima_d_path(&file->f_path, &pathbuf, filename);\n\n\tif (action & IMA_MEASURE)\n\t\tima_store_measurement(iint, file, pathname,\n\t\t\t\t      xattr_value, xattr_len, pcr);\n\tif (rc == 0 && (action & IMA_APPRAISE_SUBMASK))\n\t\trc = ima_appraise_measurement(func, iint, file, pathname,\n\t\t\t\t\t      xattr_value, xattr_len, opened);\n\tif (action & IMA_AUDIT)\n\t\tima_audit_measurement(iint, pathname);\n\n\tif ((file->f_flags & O_DIRECT) && (iint->flags & IMA_PERMIT_DIRECTIO))\n\t\trc = 0;\nout_digsig:\n\tif ((mask & MAY_WRITE) && (iint->flags & IMA_DIGSIG) &&\n\t     !(iint->flags & IMA_NEW_FILE))\n\t\trc = -EACCES;\n\tkfree(xattr_value);\nout_free:\n\tif (pathbuf)\n\t\t__putname(pathbuf);\nout:\n\tinode_unlock(inode);\n\tif ((rc && must_appraise) && (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\treturn -EACCES;\n\treturn 0;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/ima.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/mount.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "pathbuf"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr_value"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_audit_measurement",
          "args": [
            "iint",
            "pathname"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "ima_audit_measurement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "306-337",
          "snippet": "void ima_audit_measurement(struct integrity_iint_cache *iint,\n\t\t\t   const unsigned char *filename)\n{\n\tstruct audit_buffer *ab;\n\tchar hash[(iint->ima_hash->length * 2) + 1];\n\tconst char *algo_name = hash_algo_name[iint->ima_hash->algo];\n\tchar algo_hash[sizeof(hash) + strlen(algo_name) + 2];\n\tint i;\n\n\tif (iint->flags & IMA_AUDITED)\n\t\treturn;\n\n\tfor (i = 0; i < iint->ima_hash->length; i++)\n\t\thex_byte_pack(hash + (i * 2), iint->ima_hash->digest[i]);\n\thash[i * 2] = '\\0';\n\n\tab = audit_log_start(current->audit_context, GFP_KERNEL,\n\t\t\t     AUDIT_INTEGRITY_RULE);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"file=\");\n\taudit_log_untrustedstring(ab, filename);\n\taudit_log_format(ab, \" hash=\");\n\tsnprintf(algo_hash, sizeof(algo_hash), \"%s:%s\", algo_name, hash);\n\taudit_log_untrustedstring(ab, algo_hash);\n\n\taudit_log_task_info(ab, current);\n\taudit_log_end(ab);\n\n\tiint->flags |= IMA_AUDITED;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid ima_audit_measurement(struct integrity_iint_cache *iint,\n\t\t\t   const unsigned char *filename)\n{\n\tstruct audit_buffer *ab;\n\tchar hash[(iint->ima_hash->length * 2) + 1];\n\tconst char *algo_name = hash_algo_name[iint->ima_hash->algo];\n\tchar algo_hash[sizeof(hash) + strlen(algo_name) + 2];\n\tint i;\n\n\tif (iint->flags & IMA_AUDITED)\n\t\treturn;\n\n\tfor (i = 0; i < iint->ima_hash->length; i++)\n\t\thex_byte_pack(hash + (i * 2), iint->ima_hash->digest[i]);\n\thash[i * 2] = '\\0';\n\n\tab = audit_log_start(current->audit_context, GFP_KERNEL,\n\t\t\t     AUDIT_INTEGRITY_RULE);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"file=\");\n\taudit_log_untrustedstring(ab, filename);\n\taudit_log_format(ab, \" hash=\");\n\tsnprintf(algo_hash, sizeof(algo_hash), \"%s:%s\", algo_name, hash);\n\taudit_log_untrustedstring(ab, algo_hash);\n\n\taudit_log_task_info(ab, current);\n\taudit_log_end(ab);\n\n\tiint->flags |= IMA_AUDITED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_appraise_measurement",
          "args": [
            "func",
            "iint",
            "file",
            "pathname",
            "xattr_value",
            "xattr_len",
            "opened"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ima_appraise_measurement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima.h",
          "lines": "252-260",
          "snippet": "static inline int ima_appraise_measurement(enum ima_hooks func,\n\t\t\t\t\t   struct integrity_iint_cache *iint,\n\t\t\t\t\t   struct file *file,\n\t\t\t\t\t   const unsigned char *filename,\n\t\t\t\t\t   struct evm_ima_xattr_data *xattr_value,\n\t\t\t\t\t   int xattr_len, int opened)\n{\n\treturn INTEGRITY_UNKNOWN;\n}",
          "includes": [
            "#include <asm/ima.h>",
            "#include \"../integrity.h\"",
            "#include <crypto/hash_info.h>",
            "#include <linux/audit.h>",
            "#include <linux/tpm.h>",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/crypto.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ima.h>\n#include \"../integrity.h\"\n#include <crypto/hash_info.h>\n#include <linux/audit.h>\n#include <linux/tpm.h>\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n\nstatic inline int ima_appraise_measurement(enum ima_hooks func,\n\t\t\t\t\t   struct integrity_iint_cache *iint,\n\t\t\t\t\t   struct file *file,\n\t\t\t\t\t   const unsigned char *filename,\n\t\t\t\t\t   struct evm_ima_xattr_data *xattr_value,\n\t\t\t\t\t   int xattr_len, int opened)\n{\n\treturn INTEGRITY_UNKNOWN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_store_measurement",
          "args": [
            "iint",
            "file",
            "pathname",
            "xattr_value",
            "xattr_len",
            "pcr"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "ima_store_measurement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "273-304",
          "snippet": "void ima_store_measurement(struct integrity_iint_cache *iint,\n\t\t\t   struct file *file, const unsigned char *filename,\n\t\t\t   struct evm_ima_xattr_data *xattr_value,\n\t\t\t   int xattr_len, int pcr)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"ENOMEM\";\n\tint result = -ENOMEM;\n\tstruct inode *inode = file_inode(file);\n\tstruct ima_template_entry *entry;\n\tstruct ima_event_data event_data = {iint, file, filename, xattr_value,\n\t\t\t\t\t    xattr_len, NULL};\n\tint violation = 0;\n\n\tif (iint->measured_pcrs & (0x1 << pcr))\n\t\treturn;\n\n\tresult = ima_alloc_init_template(&event_data, &entry);\n\tif (result < 0) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t\t    op, audit_cause, result, 0);\n\t\treturn;\n\t}\n\n\tresult = ima_store_template(entry, violation, inode, filename, pcr);\n\tif ((!result || result == -EEXIST) && !(file->f_flags & O_DIRECT)) {\n\t\tiint->flags |= IMA_MEASURED;\n\t\tiint->measured_pcrs |= (0x1 << pcr);\n\t}\n\tif (result < 0)\n\t\tima_free_template_entry(entry);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid ima_store_measurement(struct integrity_iint_cache *iint,\n\t\t\t   struct file *file, const unsigned char *filename,\n\t\t\t   struct evm_ima_xattr_data *xattr_value,\n\t\t\t   int xattr_len, int pcr)\n{\n\tstatic const char op[] = \"add_template_measure\";\n\tstatic const char audit_cause[] = \"ENOMEM\";\n\tint result = -ENOMEM;\n\tstruct inode *inode = file_inode(file);\n\tstruct ima_template_entry *entry;\n\tstruct ima_event_data event_data = {iint, file, filename, xattr_value,\n\t\t\t\t\t    xattr_len, NULL};\n\tint violation = 0;\n\n\tif (iint->measured_pcrs & (0x1 << pcr))\n\t\treturn;\n\n\tresult = ima_alloc_init_template(&event_data, &entry);\n\tif (result < 0) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t\t    op, audit_cause, result, 0);\n\t\treturn;\n\t}\n\n\tresult = ima_store_template(entry, violation, inode, filename, pcr);\n\tif ((!result || result == -EEXIST) && !(file->f_flags & O_DIRECT)) {\n\t\tiint->flags |= IMA_MEASURED;\n\t\tiint->measured_pcrs |= (0x1 << pcr);\n\t}\n\tif (result < 0)\n\t\tima_free_template_entry(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_d_path",
          "args": [
            "&file->f_path",
            "&pathbuf",
            "filename"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ima_d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "349-369",
          "snippet": "const char *ima_d_path(const struct path *path, char **pathbuf, char *namebuf)\n{\n\tchar *pathname = NULL;\n\n\t*pathbuf = __getname();\n\tif (*pathbuf) {\n\t\tpathname = d_absolute_path(path, *pathbuf, PATH_MAX);\n\t\tif (IS_ERR(pathname)) {\n\t\t\t__putname(*pathbuf);\n\t\t\t*pathbuf = NULL;\n\t\t\tpathname = NULL;\n\t\t}\n\t}\n\n\tif (!pathname) {\n\t\tstrlcpy(namebuf, path->dentry->d_name.name, NAME_MAX);\n\t\tpathname = namebuf;\n\t}\n\n\treturn pathname;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nconst char *ima_d_path(const struct path *path, char **pathbuf, char *namebuf)\n{\n\tchar *pathname = NULL;\n\n\t*pathbuf = __getname();\n\tif (*pathbuf) {\n\t\tpathname = d_absolute_path(path, *pathbuf, PATH_MAX);\n\t\tif (IS_ERR(pathname)) {\n\t\t\t__putname(*pathbuf);\n\t\t\t*pathbuf = NULL;\n\t\t\tpathname = NULL;\n\t\t}\n\t}\n\n\tif (!pathname) {\n\t\tstrlcpy(namebuf, path->dentry->d_name.name, NAME_MAX);\n\t\tpathname = namebuf;\n\t}\n\n\treturn pathname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_collect_measurement",
          "args": [
            "iint",
            "file",
            "buf",
            "size",
            "hash_algo"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ima_collect_measurement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "194-256",
          "snippet": "int ima_collect_measurement(struct integrity_iint_cache *iint,\n\t\t\t    struct file *file, void *buf, loff_t size,\n\t\t\t    enum hash_algo algo)\n{\n\tconst char *audit_cause = \"failed\";\n\tstruct inode *inode = file_inode(file);\n\tconst char *filename = file->f_path.dentry->d_name.name;\n\tint result = 0;\n\tint length;\n\tvoid *tmpbuf;\n\tu64 i_version;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[IMA_MAX_DIGEST_SIZE];\n\t} hash;\n\n\tif (iint->flags & IMA_COLLECTED)\n\t\tgoto out;\n\n\t/*\n\t * Dectecting file change is based on i_version. On filesystems\n\t * which do not support i_version, support is limited to an initial\n\t * measurement/appraisal/audit.\n\t */\n\ti_version = file_inode(file)->i_version;\n\thash.hdr.algo = algo;\n\n\t/* Initialize hash digest to 0's in case of failure */\n\tmemset(&hash.digest, 0, sizeof(hash.digest));\n\n\tif (buf)\n\t\tresult = ima_calc_buffer_hash(buf, size, &hash.hdr);\n\telse\n\t\tresult = ima_calc_file_hash(file, &hash.hdr);\n\n\tif (result && result != -EBADF && result != -EINVAL)\n\t\tgoto out;\n\n\tlength = sizeof(hash.hdr) + hash.hdr.length;\n\ttmpbuf = krealloc(iint->ima_hash, length, GFP_NOFS);\n\tif (!tmpbuf) {\n\t\tresult = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tiint->ima_hash = tmpbuf;\n\tmemcpy(iint->ima_hash, &hash, length);\n\tiint->version = i_version;\n\n\t/* Possibly temporary failure due to type of read (eg. O_DIRECT) */\n\tif (!result)\n\t\tiint->flags |= IMA_COLLECTED;\nout:\n\tif (result) {\n\t\tif (file->f_flags & O_DIRECT)\n\t\t\taudit_cause = \"failed(directio)\";\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,\n\t\t\t\t    filename, \"collect_data\", audit_cause,\n\t\t\t\t    result, 0);\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint ima_collect_measurement(struct integrity_iint_cache *iint,\n\t\t\t    struct file *file, void *buf, loff_t size,\n\t\t\t    enum hash_algo algo)\n{\n\tconst char *audit_cause = \"failed\";\n\tstruct inode *inode = file_inode(file);\n\tconst char *filename = file->f_path.dentry->d_name.name;\n\tint result = 0;\n\tint length;\n\tvoid *tmpbuf;\n\tu64 i_version;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[IMA_MAX_DIGEST_SIZE];\n\t} hash;\n\n\tif (iint->flags & IMA_COLLECTED)\n\t\tgoto out;\n\n\t/*\n\t * Dectecting file change is based on i_version. On filesystems\n\t * which do not support i_version, support is limited to an initial\n\t * measurement/appraisal/audit.\n\t */\n\ti_version = file_inode(file)->i_version;\n\thash.hdr.algo = algo;\n\n\t/* Initialize hash digest to 0's in case of failure */\n\tmemset(&hash.digest, 0, sizeof(hash.digest));\n\n\tif (buf)\n\t\tresult = ima_calc_buffer_hash(buf, size, &hash.hdr);\n\telse\n\t\tresult = ima_calc_file_hash(file, &hash.hdr);\n\n\tif (result && result != -EBADF && result != -EINVAL)\n\t\tgoto out;\n\n\tlength = sizeof(hash.hdr) + hash.hdr.length;\n\ttmpbuf = krealloc(iint->ima_hash, length, GFP_NOFS);\n\tif (!tmpbuf) {\n\t\tresult = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tiint->ima_hash = tmpbuf;\n\tmemcpy(iint->ima_hash, &hash, length);\n\tiint->version = i_version;\n\n\t/* Possibly temporary failure due to type of read (eg. O_DIRECT) */\n\tif (!result)\n\t\tiint->flags |= IMA_COLLECTED;\nout:\n\tif (result) {\n\t\tif (file->f_flags & O_DIRECT)\n\t\t\taudit_cause = \"failed(directio)\";\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,\n\t\t\t\t    filename, \"collect_data\", audit_cause,\n\t\t\t\t    result, 0);\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_get_hash_algo",
          "args": [
            "xattr_value",
            "xattr_len"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "ima_get_hash_algo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima.h",
          "lines": "280-284",
          "snippet": "static inline enum hash_algo\nima_get_hash_algo(struct evm_ima_xattr_data *xattr_value, int xattr_len)\n{\n\treturn ima_hash_algo;\n}",
          "includes": [
            "#include <asm/ima.h>",
            "#include \"../integrity.h\"",
            "#include <crypto/hash_info.h>",
            "#include <linux/audit.h>",
            "#include <linux/tpm.h>",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/crypto.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ima.h>\n#include \"../integrity.h\"\n#include <crypto/hash_info.h>\n#include <linux/audit.h>\n#include <linux/tpm.h>\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n\nstatic inline enum hash_algo\nima_get_hash_algo(struct evm_ima_xattr_data *xattr_value, int xattr_len)\n{\n\treturn ima_hash_algo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_read_xattr",
          "args": [
            "file_dentry(file)",
            "&xattr_value"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "ima_read_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima.h",
          "lines": "286-290",
          "snippet": "static inline int ima_read_xattr(struct dentry *dentry,\n\t\t\t\t struct evm_ima_xattr_data **xattr_value)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ima.h>",
            "#include \"../integrity.h\"",
            "#include <crypto/hash_info.h>",
            "#include <linux/audit.h>",
            "#include <linux/tpm.h>",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/crypto.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ima.h>\n#include \"../integrity.h\"\n#include <crypto/hash_info.h>\n#include <linux/audit.h>\n#include <linux/tpm.h>\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n\nstatic inline int ima_read_xattr(struct dentry *dentry,\n\t\t\t\t struct evm_ima_xattr_data **xattr_value)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_dentry",
          "args": [
            "file"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "template_desc->name",
            "IMA_TEMPLATE_IMA_NAME"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_template_desc_current",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ima_template_desc_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "221-229",
          "snippet": "struct ima_template_desc *ima_template_desc_current(void)\n{\n\tif (!ima_template) {\n\t\tima_init_template_list();\n\t\tima_template =\n\t\t    lookup_template_desc(CONFIG_IMA_DEFAULT_TEMPLATE);\n\t}\n\treturn ima_template;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ima_template_desc *ima_template;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_desc *ima_template;\n\nstruct ima_template_desc *ima_template_desc_current(void)\n{\n\tif (!ima_template) {\n\t\tima_init_template_list();\n\t\tima_template =\n\t\t    lookup_template_desc(CONFIG_IMA_DEFAULT_TEMPLATE);\n\t}\n\treturn ima_template;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_get_cache_status",
          "args": [
            "iint",
            "func"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ima_get_cache_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima.h",
          "lines": "273-278",
          "snippet": "static inline enum integrity_status ima_get_cache_status(struct integrity_iint_cache\n\t\t\t\t\t\t\t *iint,\n\t\t\t\t\t\t\t enum ima_hooks func)\n{\n\treturn INTEGRITY_UNKNOWN;\n}",
          "includes": [
            "#include <asm/ima.h>",
            "#include \"../integrity.h\"",
            "#include <crypto/hash_info.h>",
            "#include <linux/audit.h>",
            "#include <linux/tpm.h>",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/crypto.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ima.h>\n#include \"../integrity.h\"\n#include <crypto/hash_info.h>\n#include <linux/audit.h>\n#include <linux/tpm.h>\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n\nstatic inline enum integrity_status ima_get_cache_status(struct integrity_iint_cache\n\t\t\t\t\t\t\t *iint,\n\t\t\t\t\t\t\t enum ima_hooks func)\n{\n\treturn INTEGRITY_UNKNOWN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_rdwr_violation_check",
          "args": [
            "file",
            "iint",
            "action & IMA_MEASURE",
            "&pathbuf",
            "&pathname"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "ima_rdwr_violation_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
          "lines": "83-118",
          "snippet": "static void ima_rdwr_violation_check(struct file *file,\n\t\t\t\t     struct integrity_iint_cache *iint,\n\t\t\t\t     int must_measure,\n\t\t\t\t     char **pathbuf,\n\t\t\t\t     const char **pathname)\n{\n\tstruct inode *inode = file_inode(file);\n\tchar filename[NAME_MAX];\n\tfmode_t mode = file->f_mode;\n\tbool send_tomtou = false, send_writers = false;\n\n\tif (mode & FMODE_WRITE) {\n\t\tif (atomic_read(&inode->i_readcount) && IS_IMA(inode)) {\n\t\t\tif (!iint)\n\t\t\t\tiint = integrity_iint_find(inode);\n\t\t\t/* IMA_MEASURE is set from reader side */\n\t\t\tif (iint && (iint->flags & IMA_MEASURE))\n\t\t\t\tsend_tomtou = true;\n\t\t}\n\t} else {\n\t\tif ((atomic_read(&inode->i_writecount) > 0) && must_measure)\n\t\t\tsend_writers = true;\n\t}\n\n\tif (!send_tomtou && !send_writers)\n\t\treturn;\n\n\t*pathname = ima_d_path(&file->f_path, pathbuf, filename);\n\n\tif (send_tomtou)\n\t\tima_add_violation(file, *pathname, iint,\n\t\t\t\t  \"invalid_pcr\", \"ToMToU\");\n\tif (send_writers)\n\t\tima_add_violation(file, *pathname, iint,\n\t\t\t\t  \"invalid_pcr\", \"open_writers\");\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/ima.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/mount.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void ima_rdwr_violation_check(struct file *file,\n\t\t\t\t     struct integrity_iint_cache *iint,\n\t\t\t\t     int must_measure,\n\t\t\t\t     char **pathbuf,\n\t\t\t\t     const char **pathname)\n{\n\tstruct inode *inode = file_inode(file);\n\tchar filename[NAME_MAX];\n\tfmode_t mode = file->f_mode;\n\tbool send_tomtou = false, send_writers = false;\n\n\tif (mode & FMODE_WRITE) {\n\t\tif (atomic_read(&inode->i_readcount) && IS_IMA(inode)) {\n\t\t\tif (!iint)\n\t\t\t\tiint = integrity_iint_find(inode);\n\t\t\t/* IMA_MEASURE is set from reader side */\n\t\t\tif (iint && (iint->flags & IMA_MEASURE))\n\t\t\t\tsend_tomtou = true;\n\t\t}\n\t} else {\n\t\tif ((atomic_read(&inode->i_writecount) > 0) && must_measure)\n\t\t\tsend_writers = true;\n\t}\n\n\tif (!send_tomtou && !send_writers)\n\t\treturn;\n\n\t*pathname = ima_d_path(&file->f_path, pathbuf, filename);\n\n\tif (send_tomtou)\n\t\tima_add_violation(file, *pathname, iint,\n\t\t\t\t  \"invalid_pcr\", \"ToMToU\");\n\tif (send_writers)\n\t\tima_add_violation(file, *pathname, iint,\n\t\t\t\t  \"invalid_pcr\", \"open_writers\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "integrity_inode_get",
          "args": [
            "inode"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_inode_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/iint.c",
          "lines": "93-128",
          "snippet": "struct integrity_iint_cache *integrity_inode_get(struct inode *inode)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *node, *parent = NULL;\n\tstruct integrity_iint_cache *iint, *test_iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\treturn iint;\n\n\tiint = kmem_cache_alloc(iint_cache, GFP_NOFS);\n\tif (!iint)\n\t\treturn NULL;\n\n\twrite_lock(&integrity_iint_lock);\n\n\tp = &integrity_iint_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\ttest_iint = rb_entry(parent, struct integrity_iint_cache,\n\t\t\t\t     rb_node);\n\t\tif (inode < test_iint->inode)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tiint->inode = inode;\n\tnode = &iint->rb_node;\n\tinode->i_flags |= S_IMA;\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, &integrity_iint_tree);\n\n\twrite_unlock(&integrity_iint_lock);\n\treturn iint;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root integrity_iint_tree = RB_ROOT;",
            "static DEFINE_RWLOCK(integrity_iint_lock);",
            "static struct kmem_cache *iint_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic struct rb_root integrity_iint_tree = RB_ROOT;\nstatic DEFINE_RWLOCK(integrity_iint_lock);\nstatic struct kmem_cache *iint_cache;\n\nstruct integrity_iint_cache *integrity_inode_get(struct inode *inode)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *node, *parent = NULL;\n\tstruct integrity_iint_cache *iint, *test_iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\treturn iint;\n\n\tiint = kmem_cache_alloc(iint_cache, GFP_NOFS);\n\tif (!iint)\n\t\treturn NULL;\n\n\twrite_lock(&integrity_iint_lock);\n\n\tp = &integrity_iint_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\ttest_iint = rb_entry(parent, struct integrity_iint_cache,\n\t\t\t\t     rb_node);\n\t\tif (inode < test_iint->inode)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tiint->inode = inode;\n\tnode = &iint->rb_node;\n\tinode->i_flags |= S_IMA;\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, &integrity_iint_tree);\n\n\twrite_unlock(&integrity_iint_lock);\n\treturn iint;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_get_action",
          "args": [
            "inode",
            "mask",
            "func",
            "&pcr"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "ima_get_action",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "175-182",
          "snippet": "int ima_get_action(struct inode *inode, int mask, enum ima_hooks func, int *pcr)\n{\n\tint flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE;\n\n\tflags &= ima_policy_flag;\n\n\treturn ima_match_policy(inode, func, mask, flags, pcr);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint ima_get_action(struct inode *inode, int mask, enum ima_hooks func, int *pcr)\n{\n\tint flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE;\n\n\tflags &= ima_policy_flag;\n\n\treturn ima_match_policy(inode, func, mask, flags, pcr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int process_measurement(struct file *file, char *buf, loff_t size,\n\t\t\t       int mask, enum ima_hooks func, int opened)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint = NULL;\n\tstruct ima_template_desc *template_desc;\n\tchar *pathbuf = NULL;\n\tchar filename[NAME_MAX];\n\tconst char *pathname = NULL;\n\tint rc = -ENOMEM, action, must_appraise;\n\tint pcr = CONFIG_IMA_MEASURE_PCR_IDX;\n\tstruct evm_ima_xattr_data *xattr_value = NULL;\n\tint xattr_len = 0;\n\tbool violation_check;\n\tenum hash_algo hash_algo;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn 0;\n\n\t/* Return an IMA_MEASURE, IMA_APPRAISE, IMA_AUDIT action\n\t * bitmask based on the appraise/audit/measurement policy.\n\t * Included is the appraise submask.\n\t */\n\taction = ima_get_action(inode, mask, func, &pcr);\n\tviolation_check = ((func == FILE_CHECK || func == MMAP_CHECK) &&\n\t\t\t   (ima_policy_flag & IMA_MEASURE));\n\tif (!action && !violation_check)\n\t\treturn 0;\n\n\tmust_appraise = action & IMA_APPRAISE;\n\n\t/*  Is the appraise rule hook specific?  */\n\tif (action & IMA_FILE_APPRAISE)\n\t\tfunc = FILE_CHECK;\n\n\tinode_lock(inode);\n\n\tif (action) {\n\t\tiint = integrity_inode_get(inode);\n\t\tif (!iint)\n\t\t\tgoto out;\n\t}\n\n\tif (violation_check) {\n\t\tima_rdwr_violation_check(file, iint, action & IMA_MEASURE,\n\t\t\t\t\t &pathbuf, &pathname);\n\t\tif (!action) {\n\t\t\trc = 0;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\t/* Determine if already appraised/measured based on bitmask\n\t * (IMA_MEASURE, IMA_MEASURED, IMA_XXXX_APPRAISE, IMA_XXXX_APPRAISED,\n\t *  IMA_AUDIT, IMA_AUDITED)\n\t */\n\tiint->flags |= action;\n\taction &= IMA_DO_MASK;\n\taction &= ~((iint->flags & (IMA_DONE_MASK ^ IMA_MEASURED)) >> 1);\n\n\t/* If target pcr is already measured, unset IMA_MEASURE action */\n\tif ((action & IMA_MEASURE) && (iint->measured_pcrs & (0x1 << pcr)))\n\t\taction ^= IMA_MEASURE;\n\n\t/* Nothing to do, just return existing appraised status */\n\tif (!action) {\n\t\tif (must_appraise)\n\t\t\trc = ima_get_cache_status(iint, func);\n\t\tgoto out_digsig;\n\t}\n\n\ttemplate_desc = ima_template_desc_current();\n\tif ((action & IMA_APPRAISE_SUBMASK) ||\n\t\t    strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) != 0)\n\t\t/* read 'security.ima' */\n\t\txattr_len = ima_read_xattr(file_dentry(file), &xattr_value);\n\n\thash_algo = ima_get_hash_algo(xattr_value, xattr_len);\n\n\trc = ima_collect_measurement(iint, file, buf, size, hash_algo);\n\tif (rc != 0 && rc != -EBADF && rc != -EINVAL)\n\t\tgoto out_digsig;\n\n\tif (!pathbuf)\t/* ima_rdwr_violation possibly pre-fetched */\n\t\tpathname = ima_d_path(&file->f_path, &pathbuf, filename);\n\n\tif (action & IMA_MEASURE)\n\t\tima_store_measurement(iint, file, pathname,\n\t\t\t\t      xattr_value, xattr_len, pcr);\n\tif (rc == 0 && (action & IMA_APPRAISE_SUBMASK))\n\t\trc = ima_appraise_measurement(func, iint, file, pathname,\n\t\t\t\t\t      xattr_value, xattr_len, opened);\n\tif (action & IMA_AUDIT)\n\t\tima_audit_measurement(iint, pathname);\n\n\tif ((file->f_flags & O_DIRECT) && (iint->flags & IMA_PERMIT_DIRECTIO))\n\t\trc = 0;\nout_digsig:\n\tif ((mask & MAY_WRITE) && (iint->flags & IMA_DIGSIG) &&\n\t     !(iint->flags & IMA_NEW_FILE))\n\t\trc = -EACCES;\n\tkfree(xattr_value);\nout_free:\n\tif (pathbuf)\n\t\t__putname(pathbuf);\nout:\n\tinode_unlock(inode);\n\tif ((rc && must_appraise) && (ima_appraise & IMA_APPRAISE_ENFORCE))\n\t\treturn -EACCES;\n\treturn 0;\n}"
  },
  {
    "function_name": "ima_file_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
    "lines": "147-160",
    "snippet": "void ima_file_free(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tiint = integrity_iint_find(inode);\n\tif (!iint)\n\t\treturn;\n\n\tima_check_last_writer(iint, inode, file);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/ima.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/mount.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_check_last_writer",
          "args": [
            "iint",
            "inode",
            "file"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "ima_check_last_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
          "lines": "120-139",
          "snippet": "static void ima_check_last_writer(struct integrity_iint_cache *iint,\n\t\t\t\t  struct inode *inode, struct file *file)\n{\n\tfmode_t mode = file->f_mode;\n\n\tif (!(mode & FMODE_WRITE))\n\t\treturn;\n\n\tinode_lock(inode);\n\tif (atomic_read(&inode->i_writecount) == 1) {\n\t\tif ((iint->version != inode->i_version) ||\n\t\t    (iint->flags & IMA_NEW_FILE)) {\n\t\t\tiint->flags &= ~(IMA_DONE_MASK | IMA_NEW_FILE);\n\t\t\tiint->measured_pcrs = 0;\n\t\t\tif (iint->flags & IMA_APPRAISE)\n\t\t\t\tima_update_xattr(iint, file);\n\t\t}\n\t}\n\tinode_unlock(inode);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/ima.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/mount.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void ima_check_last_writer(struct integrity_iint_cache *iint,\n\t\t\t\t  struct inode *inode, struct file *file)\n{\n\tfmode_t mode = file->f_mode;\n\n\tif (!(mode & FMODE_WRITE))\n\t\treturn;\n\n\tinode_lock(inode);\n\tif (atomic_read(&inode->i_writecount) == 1) {\n\t\tif ((iint->version != inode->i_version) ||\n\t\t    (iint->flags & IMA_NEW_FILE)) {\n\t\t\tiint->flags &= ~(IMA_DONE_MASK | IMA_NEW_FILE);\n\t\t\tiint->measured_pcrs = 0;\n\t\t\tif (iint->flags & IMA_APPRAISE)\n\t\t\t\tima_update_xattr(iint, file);\n\t\t}\n\t}\n\tinode_unlock(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "integrity_iint_find",
          "args": [
            "inode"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_iint_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/iint.c",
          "lines": "57-69",
          "snippet": "struct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(integrity_iint_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(integrity_iint_lock);\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nvoid ima_file_free(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct integrity_iint_cache *iint;\n\n\tif (!ima_policy_flag || !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tiint = integrity_iint_find(inode);\n\tif (!iint)\n\t\treturn;\n\n\tima_check_last_writer(iint, inode, file);\n}"
  },
  {
    "function_name": "ima_check_last_writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
    "lines": "120-139",
    "snippet": "static void ima_check_last_writer(struct integrity_iint_cache *iint,\n\t\t\t\t  struct inode *inode, struct file *file)\n{\n\tfmode_t mode = file->f_mode;\n\n\tif (!(mode & FMODE_WRITE))\n\t\treturn;\n\n\tinode_lock(inode);\n\tif (atomic_read(&inode->i_writecount) == 1) {\n\t\tif ((iint->version != inode->i_version) ||\n\t\t    (iint->flags & IMA_NEW_FILE)) {\n\t\t\tiint->flags &= ~(IMA_DONE_MASK | IMA_NEW_FILE);\n\t\t\tiint->measured_pcrs = 0;\n\t\t\tif (iint->flags & IMA_APPRAISE)\n\t\t\t\tima_update_xattr(iint, file);\n\t\t}\n\t}\n\tinode_unlock(inode);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/ima.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/mount.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_update_xattr",
          "args": [
            "iint",
            "file"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ima_update_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima.h",
          "lines": "268-271",
          "snippet": "static inline void ima_update_xattr(struct integrity_iint_cache *iint,\n\t\t\t\t    struct file *file)\n{\n}",
          "includes": [
            "#include <asm/ima.h>",
            "#include \"../integrity.h\"",
            "#include <crypto/hash_info.h>",
            "#include <linux/audit.h>",
            "#include <linux/tpm.h>",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/crypto.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ima.h>\n#include \"../integrity.h\"\n#include <crypto/hash_info.h>\n#include <linux/audit.h>\n#include <linux/tpm.h>\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n\nstatic inline void ima_update_xattr(struct integrity_iint_cache *iint,\n\t\t\t\t    struct file *file)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_writecount"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void ima_check_last_writer(struct integrity_iint_cache *iint,\n\t\t\t\t  struct inode *inode, struct file *file)\n{\n\tfmode_t mode = file->f_mode;\n\n\tif (!(mode & FMODE_WRITE))\n\t\treturn;\n\n\tinode_lock(inode);\n\tif (atomic_read(&inode->i_writecount) == 1) {\n\t\tif ((iint->version != inode->i_version) ||\n\t\t    (iint->flags & IMA_NEW_FILE)) {\n\t\t\tiint->flags &= ~(IMA_DONE_MASK | IMA_NEW_FILE);\n\t\t\tiint->measured_pcrs = 0;\n\t\t\tif (iint->flags & IMA_APPRAISE)\n\t\t\t\tima_update_xattr(iint, file);\n\t\t}\n\t}\n\tinode_unlock(inode);\n}"
  },
  {
    "function_name": "ima_rdwr_violation_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
    "lines": "83-118",
    "snippet": "static void ima_rdwr_violation_check(struct file *file,\n\t\t\t\t     struct integrity_iint_cache *iint,\n\t\t\t\t     int must_measure,\n\t\t\t\t     char **pathbuf,\n\t\t\t\t     const char **pathname)\n{\n\tstruct inode *inode = file_inode(file);\n\tchar filename[NAME_MAX];\n\tfmode_t mode = file->f_mode;\n\tbool send_tomtou = false, send_writers = false;\n\n\tif (mode & FMODE_WRITE) {\n\t\tif (atomic_read(&inode->i_readcount) && IS_IMA(inode)) {\n\t\t\tif (!iint)\n\t\t\t\tiint = integrity_iint_find(inode);\n\t\t\t/* IMA_MEASURE is set from reader side */\n\t\t\tif (iint && (iint->flags & IMA_MEASURE))\n\t\t\t\tsend_tomtou = true;\n\t\t}\n\t} else {\n\t\tif ((atomic_read(&inode->i_writecount) > 0) && must_measure)\n\t\t\tsend_writers = true;\n\t}\n\n\tif (!send_tomtou && !send_writers)\n\t\treturn;\n\n\t*pathname = ima_d_path(&file->f_path, pathbuf, filename);\n\n\tif (send_tomtou)\n\t\tima_add_violation(file, *pathname, iint,\n\t\t\t\t  \"invalid_pcr\", \"ToMToU\");\n\tif (send_writers)\n\t\tima_add_violation(file, *pathname, iint,\n\t\t\t\t  \"invalid_pcr\", \"open_writers\");\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/ima.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/mount.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_add_violation",
          "args": [
            "file",
            "*pathname",
            "iint",
            "\"invalid_pcr\"",
            "\"open_writers\""
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "ima_add_violation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "129-155",
          "snippet": "void ima_add_violation(struct file *file, const unsigned char *filename,\n\t\t       struct integrity_iint_cache *iint,\n\t\t       const char *op, const char *cause)\n{\n\tstruct ima_template_entry *entry;\n\tstruct inode *inode = file_inode(file);\n\tstruct ima_event_data event_data = {iint, file, filename, NULL, 0,\n\t\t\t\t\t    cause};\n\tint violation = 1;\n\tint result;\n\n\t/* can overflow, only indicator */\n\tatomic_long_inc(&ima_htable.violations);\n\n\tresult = ima_alloc_init_template(&event_data, &entry);\n\tif (result < 0) {\n\t\tresult = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tresult = ima_store_template(entry, violation, inode,\n\t\t\t\t    filename, CONFIG_IMA_MEASURE_PCR_IDX);\n\tif (result < 0)\n\t\tima_free_template_entry(entry);\nerr_out:\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t    op, cause, result, 0);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid ima_add_violation(struct file *file, const unsigned char *filename,\n\t\t       struct integrity_iint_cache *iint,\n\t\t       const char *op, const char *cause)\n{\n\tstruct ima_template_entry *entry;\n\tstruct inode *inode = file_inode(file);\n\tstruct ima_event_data event_data = {iint, file, filename, NULL, 0,\n\t\t\t\t\t    cause};\n\tint violation = 1;\n\tint result;\n\n\t/* can overflow, only indicator */\n\tatomic_long_inc(&ima_htable.violations);\n\n\tresult = ima_alloc_init_template(&event_data, &entry);\n\tif (result < 0) {\n\t\tresult = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tresult = ima_store_template(entry, violation, inode,\n\t\t\t\t    filename, CONFIG_IMA_MEASURE_PCR_IDX);\n\tif (result < 0)\n\t\tima_free_template_entry(entry);\nerr_out:\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t    op, cause, result, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_d_path",
          "args": [
            "&file->f_path",
            "pathbuf",
            "filename"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "ima_d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "349-369",
          "snippet": "const char *ima_d_path(const struct path *path, char **pathbuf, char *namebuf)\n{\n\tchar *pathname = NULL;\n\n\t*pathbuf = __getname();\n\tif (*pathbuf) {\n\t\tpathname = d_absolute_path(path, *pathbuf, PATH_MAX);\n\t\tif (IS_ERR(pathname)) {\n\t\t\t__putname(*pathbuf);\n\t\t\t*pathbuf = NULL;\n\t\t\tpathname = NULL;\n\t\t}\n\t}\n\n\tif (!pathname) {\n\t\tstrlcpy(namebuf, path->dentry->d_name.name, NAME_MAX);\n\t\tpathname = namebuf;\n\t}\n\n\treturn pathname;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nconst char *ima_d_path(const struct path *path, char **pathbuf, char *namebuf)\n{\n\tchar *pathname = NULL;\n\n\t*pathbuf = __getname();\n\tif (*pathbuf) {\n\t\tpathname = d_absolute_path(path, *pathbuf, PATH_MAX);\n\t\tif (IS_ERR(pathname)) {\n\t\t\t__putname(*pathbuf);\n\t\t\t*pathbuf = NULL;\n\t\t\tpathname = NULL;\n\t\t}\n\t}\n\n\tif (!pathname) {\n\t\tstrlcpy(namebuf, path->dentry->d_name.name, NAME_MAX);\n\t\tpathname = namebuf;\n\t}\n\n\treturn pathname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_writecount"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "integrity_iint_find",
          "args": [
            "inode"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_iint_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/iint.c",
          "lines": "57-69",
          "snippet": "struct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(integrity_iint_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(integrity_iint_lock);\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_IMA",
          "args": [
            "inode"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_readcount"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void ima_rdwr_violation_check(struct file *file,\n\t\t\t\t     struct integrity_iint_cache *iint,\n\t\t\t\t     int must_measure,\n\t\t\t\t     char **pathbuf,\n\t\t\t\t     const char **pathname)\n{\n\tstruct inode *inode = file_inode(file);\n\tchar filename[NAME_MAX];\n\tfmode_t mode = file->f_mode;\n\tbool send_tomtou = false, send_writers = false;\n\n\tif (mode & FMODE_WRITE) {\n\t\tif (atomic_read(&inode->i_readcount) && IS_IMA(inode)) {\n\t\t\tif (!iint)\n\t\t\t\tiint = integrity_iint_find(inode);\n\t\t\t/* IMA_MEASURE is set from reader side */\n\t\t\tif (iint && (iint->flags & IMA_MEASURE))\n\t\t\t\tsend_tomtou = true;\n\t\t}\n\t} else {\n\t\tif ((atomic_read(&inode->i_writecount) > 0) && must_measure)\n\t\t\tsend_writers = true;\n\t}\n\n\tif (!send_tomtou && !send_writers)\n\t\treturn;\n\n\t*pathname = ima_d_path(&file->f_path, pathbuf, filename);\n\n\tif (send_tomtou)\n\t\tima_add_violation(file, *pathname, iint,\n\t\t\t\t  \"invalid_pcr\", \"ToMToU\");\n\tif (send_writers)\n\t\tima_add_violation(file, *pathname, iint,\n\t\t\t\t  \"invalid_pcr\", \"open_writers\");\n}"
  },
  {
    "function_name": "hash_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_main.c",
    "lines": "41-70",
    "snippet": "static int __init hash_setup(char *str)\n{\n\tstruct ima_template_desc *template_desc = ima_template_desc_current();\n\tint i;\n\n\tif (hash_setup_done)\n\t\treturn 1;\n\n\tif (strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) == 0) {\n\t\tif (strncmp(str, \"sha1\", 4) == 0)\n\t\t\tima_hash_algo = HASH_ALGO_SHA1;\n\t\telse if (strncmp(str, \"md5\", 3) == 0)\n\t\t\tima_hash_algo = HASH_ALGO_MD5;\n\t\telse\n\t\t\treturn 1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < HASH_ALGO__LAST; i++) {\n\t\tif (strcmp(str, hash_algo_name[i]) == 0) {\n\t\t\tima_hash_algo = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == HASH_ALGO__LAST)\n\t\treturn 1;\nout:\n\thash_setup_done = 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/ima.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/mman.h>",
      "#include <linux/mount.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ima_hash_algo = HASH_ALGO_SHA1;",
      "static int hash_setup_done;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "hash_algo_name[i]"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"md5\"",
            "3"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"sha1\"",
            "4"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "template_desc->name",
            "IMA_TEMPLATE_IMA_NAME"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_template_desc_current",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "ima_template_desc_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "221-229",
          "snippet": "struct ima_template_desc *ima_template_desc_current(void)\n{\n\tif (!ima_template) {\n\t\tima_init_template_list();\n\t\tima_template =\n\t\t    lookup_template_desc(CONFIG_IMA_DEFAULT_TEMPLATE);\n\t}\n\treturn ima_template;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ima_template_desc *ima_template;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_desc *ima_template;\n\nstruct ima_template_desc *ima_template_desc_current(void)\n{\n\tif (!ima_template) {\n\t\tima_init_template_list();\n\t\tima_template =\n\t\t    lookup_template_desc(CONFIG_IMA_DEFAULT_TEMPLATE);\n\t}\n\treturn ima_template;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/ima.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/binfmts.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint ima_hash_algo = HASH_ALGO_SHA1;\nstatic int hash_setup_done;\n\nstatic int __init hash_setup(char *str)\n{\n\tstruct ima_template_desc *template_desc = ima_template_desc_current();\n\tint i;\n\n\tif (hash_setup_done)\n\t\treturn 1;\n\n\tif (strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) == 0) {\n\t\tif (strncmp(str, \"sha1\", 4) == 0)\n\t\t\tima_hash_algo = HASH_ALGO_SHA1;\n\t\telse if (strncmp(str, \"md5\", 3) == 0)\n\t\t\tima_hash_algo = HASH_ALGO_MD5;\n\t\telse\n\t\t\treturn 1;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < HASH_ALGO__LAST; i++) {\n\t\tif (strcmp(str, hash_algo_name[i]) == 0) {\n\t\t\tima_hash_algo = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == HASH_ALGO__LAST)\n\t\treturn 1;\nout:\n\thash_setup_done = 1;\n\treturn 1;\n}"
  }
]