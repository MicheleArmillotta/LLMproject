[
  {
    "function_name": "__devcgroup_check_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "804-826",
    "snippet": "int __devcgroup_check_permission(short type, u32 major, u32 minor,\n\t\t\t\t short access)\n{\n\tstruct dev_cgroup *dev_cgroup;\n\tbool rc;\n\n\trcu_read_lock();\n\tdev_cgroup = task_devcgroup(current);\n\tif (dev_cgroup->behavior == DEVCG_DEFAULT_ALLOW)\n\t\t/* Can't match any of the exceptions, even partially */\n\t\trc = !match_exception_partial(&dev_cgroup->exceptions,\n\t\t\t\t\t      type, major, minor, access);\n\telse\n\t\t/* Need to match completely one exception to be allowed */\n\t\trc = match_exception(&dev_cgroup->exceptions, type, major,\n\t\t\t\t     minor, access);\n\trcu_read_unlock();\n\n\tif (!rc)\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_exception",
          "args": [
            "&dev_cgroup->exceptions",
            "type",
            "major",
            "minor",
            "access"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "match_exception_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "350-378",
          "snippet": "static bool match_exception_partial(struct list_head *exceptions, short type,\n\t\t\t\t    u32 major, u32 minor, short access)\n{\n\tstruct dev_exception_item *ex;\n\n\tlist_for_each_entry_rcu(ex, exceptions, list) {\n\t\tif ((type & DEVCG_DEV_BLOCK) && !(ex->type & DEVCG_DEV_BLOCK))\n\t\t\tcontinue;\n\t\tif ((type & DEVCG_DEV_CHAR) && !(ex->type & DEVCG_DEV_CHAR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We must be sure that both the exception and the provided\n\t\t * range aren't masking all devices\n\t\t */\n\t\tif (ex->major != ~0 && major != ~0 && ex->major != major)\n\t\t\tcontinue;\n\t\tif (ex->minor != ~0 && minor != ~0 && ex->minor != minor)\n\t\t\tcontinue;\n\t\t/*\n\t\t * In order to make sure the provided range isn't matching\n\t\t * an exception, all its access bits shouldn't match the\n\t\t * exception's access bits\n\t\t */\n\t\tif (!(access & ex->access))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic bool match_exception_partial(struct list_head *exceptions, short type,\n\t\t\t\t    u32 major, u32 minor, short access)\n{\n\tstruct dev_exception_item *ex;\n\n\tlist_for_each_entry_rcu(ex, exceptions, list) {\n\t\tif ((type & DEVCG_DEV_BLOCK) && !(ex->type & DEVCG_DEV_BLOCK))\n\t\t\tcontinue;\n\t\tif ((type & DEVCG_DEV_CHAR) && !(ex->type & DEVCG_DEV_CHAR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We must be sure that both the exception and the provided\n\t\t * range aren't masking all devices\n\t\t */\n\t\tif (ex->major != ~0 && major != ~0 && ex->major != major)\n\t\t\tcontinue;\n\t\tif (ex->minor != ~0 && minor != ~0 && ex->minor != minor)\n\t\t\tcontinue;\n\t\t/*\n\t\t * In order to make sure the provided range isn't matching\n\t\t * an exception, all its access bits shouldn't match the\n\t\t * exception's access bits\n\t\t */\n\t\tif (!(access & ex->access))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_devcgroup",
          "args": [
            "current"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "task_devcgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "51-54",
          "snippet": "static inline struct dev_cgroup *task_devcgroup(struct task_struct *task)\n{\n\treturn css_to_devcgroup(task_css(task, devices_cgrp_id));\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline struct dev_cgroup *task_devcgroup(struct task_struct *task)\n{\n\treturn css_to_devcgroup(task_css(task, devices_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nint __devcgroup_check_permission(short type, u32 major, u32 minor,\n\t\t\t\t short access)\n{\n\tstruct dev_cgroup *dev_cgroup;\n\tbool rc;\n\n\trcu_read_lock();\n\tdev_cgroup = task_devcgroup(current);\n\tif (dev_cgroup->behavior == DEVCG_DEFAULT_ALLOW)\n\t\t/* Can't match any of the exceptions, even partially */\n\t\trc = !match_exception_partial(&dev_cgroup->exceptions,\n\t\t\t\t\t      type, major, minor, access);\n\telse\n\t\t/* Need to match completely one exception to be allowed */\n\t\trc = match_exception(&dev_cgroup->exceptions, type, major,\n\t\t\t\t     minor, access);\n\trcu_read_unlock();\n\n\tif (!rc)\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "devcgroup_access_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "755-765",
    "snippet": "static ssize_t devcgroup_access_write(struct kernfs_open_file *of,\n\t\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tint retval;\n\n\tmutex_lock(&devcgroup_mutex);\n\tretval = devcgroup_update_access(css_to_devcgroup(of_css(of)),\n\t\t\t\t\t of_cft(of)->private, strstrip(buf));\n\tmutex_unlock(&devcgroup_mutex);\n\treturn retval ?: nbytes;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(devcgroup_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&devcgroup_mutex"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devcgroup_update_access",
          "args": [
            "css_to_devcgroup(of_css(of))",
            "of_cft(of)->private",
            "strstrip(buf)"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "devcgroup_update_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "595-753",
          "snippet": "static int devcgroup_update_access(struct dev_cgroup *devcgroup,\n\t\t\t\t   int filetype, char *buffer)\n{\n\tconst char *b;\n\tchar temp[12];\t\t/* 11 + 1 characters needed for a u32 */\n\tint count, rc = 0;\n\tstruct dev_exception_item ex;\n\tstruct dev_cgroup *parent = css_to_devcgroup(devcgroup->css.parent);\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(&ex, 0, sizeof(ex));\n\tb = buffer;\n\n\tswitch (*b) {\n\tcase 'a':\n\t\tswitch (filetype) {\n\t\tcase DEVCG_ALLOW:\n\t\t\tif (css_has_online_children(&devcgroup->css))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (!may_allow_all(parent))\n\t\t\t\treturn -EPERM;\n\t\t\tdev_exception_clean(devcgroup);\n\t\t\tdevcgroup->behavior = DEVCG_DEFAULT_ALLOW;\n\t\t\tif (!parent)\n\t\t\t\tbreak;\n\n\t\t\trc = dev_exceptions_copy(&devcgroup->exceptions,\n\t\t\t\t\t\t &parent->exceptions);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase DEVCG_DENY:\n\t\t\tif (css_has_online_children(&devcgroup->css))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdev_exception_clean(devcgroup);\n\t\t\tdevcgroup->behavior = DEVCG_DEFAULT_DENY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tcase 'b':\n\t\tex.type = DEVCG_DEV_BLOCK;\n\t\tbreak;\n\tcase 'c':\n\t\tex.type = DEVCG_DEV_CHAR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tb++;\n\tif (!isspace(*b))\n\t\treturn -EINVAL;\n\tb++;\n\tif (*b == '*') {\n\t\tex.major = ~0;\n\t\tb++;\n\t} else if (isdigit(*b)) {\n\t\tmemset(temp, 0, sizeof(temp));\n\t\tfor (count = 0; count < sizeof(temp) - 1; count++) {\n\t\t\ttemp[count] = *b;\n\t\t\tb++;\n\t\t\tif (!isdigit(*b))\n\t\t\t\tbreak;\n\t\t}\n\t\trc = kstrtou32(temp, 10, &ex.major);\n\t\tif (rc)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (*b != ':')\n\t\treturn -EINVAL;\n\tb++;\n\n\t/* read minor */\n\tif (*b == '*') {\n\t\tex.minor = ~0;\n\t\tb++;\n\t} else if (isdigit(*b)) {\n\t\tmemset(temp, 0, sizeof(temp));\n\t\tfor (count = 0; count < sizeof(temp) - 1; count++) {\n\t\t\ttemp[count] = *b;\n\t\t\tb++;\n\t\t\tif (!isdigit(*b))\n\t\t\t\tbreak;\n\t\t}\n\t\trc = kstrtou32(temp, 10, &ex.minor);\n\t\tif (rc)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (!isspace(*b))\n\t\treturn -EINVAL;\n\tfor (b++, count = 0; count < 3; count++, b++) {\n\t\tswitch (*b) {\n\t\tcase 'r':\n\t\t\tex.access |= DEVCG_ACC_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tex.access |= DEVCG_ACC_WRITE;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tex.access |= DEVCG_ACC_MKNOD;\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase '\\0':\n\t\t\tcount = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (filetype) {\n\tcase DEVCG_ALLOW:\n\t\t/*\n\t\t * If the default policy is to allow by default, try to remove\n\t\t * an matching exception instead. And be silent about it: we\n\t\t * don't want to break compatibility\n\t\t */\n\t\tif (devcgroup->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\t/* Check if the parent allows removing it first */\n\t\t\tif (!parent_allows_removal(devcgroup, &ex))\n\t\t\t\treturn -EPERM;\n\t\t\tdev_exception_rm(devcgroup, &ex);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!parent_has_perm(devcgroup, &ex))\n\t\t\treturn -EPERM;\n\t\trc = dev_exception_add(devcgroup, &ex);\n\t\tbreak;\n\tcase DEVCG_DENY:\n\t\t/*\n\t\t * If the default policy is to deny by default, try to remove\n\t\t * an matching exception instead. And be silent about it: we\n\t\t * don't want to break compatibility\n\t\t */\n\t\tif (devcgroup->behavior == DEVCG_DEFAULT_DENY)\n\t\t\tdev_exception_rm(devcgroup, &ex);\n\t\telse\n\t\t\trc = dev_exception_add(devcgroup, &ex);\n\n\t\tif (rc)\n\t\t\tbreak;\n\t\t/* we only propagate new restrictions */\n\t\trc = propagate_exception(devcgroup, &ex);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [
            "#define DEVCG_DENY 2",
            "#define DEVCG_ALLOW 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\n#define DEVCG_DENY 2\n#define DEVCG_ALLOW 1\n\nstatic int devcgroup_update_access(struct dev_cgroup *devcgroup,\n\t\t\t\t   int filetype, char *buffer)\n{\n\tconst char *b;\n\tchar temp[12];\t\t/* 11 + 1 characters needed for a u32 */\n\tint count, rc = 0;\n\tstruct dev_exception_item ex;\n\tstruct dev_cgroup *parent = css_to_devcgroup(devcgroup->css.parent);\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(&ex, 0, sizeof(ex));\n\tb = buffer;\n\n\tswitch (*b) {\n\tcase 'a':\n\t\tswitch (filetype) {\n\t\tcase DEVCG_ALLOW:\n\t\t\tif (css_has_online_children(&devcgroup->css))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (!may_allow_all(parent))\n\t\t\t\treturn -EPERM;\n\t\t\tdev_exception_clean(devcgroup);\n\t\t\tdevcgroup->behavior = DEVCG_DEFAULT_ALLOW;\n\t\t\tif (!parent)\n\t\t\t\tbreak;\n\n\t\t\trc = dev_exceptions_copy(&devcgroup->exceptions,\n\t\t\t\t\t\t &parent->exceptions);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase DEVCG_DENY:\n\t\t\tif (css_has_online_children(&devcgroup->css))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdev_exception_clean(devcgroup);\n\t\t\tdevcgroup->behavior = DEVCG_DEFAULT_DENY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tcase 'b':\n\t\tex.type = DEVCG_DEV_BLOCK;\n\t\tbreak;\n\tcase 'c':\n\t\tex.type = DEVCG_DEV_CHAR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tb++;\n\tif (!isspace(*b))\n\t\treturn -EINVAL;\n\tb++;\n\tif (*b == '*') {\n\t\tex.major = ~0;\n\t\tb++;\n\t} else if (isdigit(*b)) {\n\t\tmemset(temp, 0, sizeof(temp));\n\t\tfor (count = 0; count < sizeof(temp) - 1; count++) {\n\t\t\ttemp[count] = *b;\n\t\t\tb++;\n\t\t\tif (!isdigit(*b))\n\t\t\t\tbreak;\n\t\t}\n\t\trc = kstrtou32(temp, 10, &ex.major);\n\t\tif (rc)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (*b != ':')\n\t\treturn -EINVAL;\n\tb++;\n\n\t/* read minor */\n\tif (*b == '*') {\n\t\tex.minor = ~0;\n\t\tb++;\n\t} else if (isdigit(*b)) {\n\t\tmemset(temp, 0, sizeof(temp));\n\t\tfor (count = 0; count < sizeof(temp) - 1; count++) {\n\t\t\ttemp[count] = *b;\n\t\t\tb++;\n\t\t\tif (!isdigit(*b))\n\t\t\t\tbreak;\n\t\t}\n\t\trc = kstrtou32(temp, 10, &ex.minor);\n\t\tif (rc)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (!isspace(*b))\n\t\treturn -EINVAL;\n\tfor (b++, count = 0; count < 3; count++, b++) {\n\t\tswitch (*b) {\n\t\tcase 'r':\n\t\t\tex.access |= DEVCG_ACC_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tex.access |= DEVCG_ACC_WRITE;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tex.access |= DEVCG_ACC_MKNOD;\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase '\\0':\n\t\t\tcount = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (filetype) {\n\tcase DEVCG_ALLOW:\n\t\t/*\n\t\t * If the default policy is to allow by default, try to remove\n\t\t * an matching exception instead. And be silent about it: we\n\t\t * don't want to break compatibility\n\t\t */\n\t\tif (devcgroup->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\t/* Check if the parent allows removing it first */\n\t\t\tif (!parent_allows_removal(devcgroup, &ex))\n\t\t\t\treturn -EPERM;\n\t\t\tdev_exception_rm(devcgroup, &ex);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!parent_has_perm(devcgroup, &ex))\n\t\t\treturn -EPERM;\n\t\trc = dev_exception_add(devcgroup, &ex);\n\t\tbreak;\n\tcase DEVCG_DENY:\n\t\t/*\n\t\t * If the default policy is to deny by default, try to remove\n\t\t * an matching exception instead. And be silent about it: we\n\t\t * don't want to break compatibility\n\t\t */\n\t\tif (devcgroup->behavior == DEVCG_DEFAULT_DENY)\n\t\t\tdev_exception_rm(devcgroup, &ex);\n\t\telse\n\t\t\trc = dev_exception_add(devcgroup, &ex);\n\n\t\tif (rc)\n\t\t\tbreak;\n\t\t/* we only propagate new restrictions */\n\t\trc = propagate_exception(devcgroup, &ex);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_to_devcgroup",
          "args": [
            "of_css(of)"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "css_to_devcgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "46-49",
          "snippet": "static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&devcgroup_mutex"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic ssize_t devcgroup_access_write(struct kernfs_open_file *of,\n\t\t\t\t      char *buf, size_t nbytes, loff_t off)\n{\n\tint retval;\n\n\tmutex_lock(&devcgroup_mutex);\n\tretval = devcgroup_update_access(css_to_devcgroup(of_css(of)),\n\t\t\t\t\t of_cft(of)->private, strstrip(buf));\n\tmutex_unlock(&devcgroup_mutex);\n\treturn retval ?: nbytes;\n}"
  },
  {
    "function_name": "devcgroup_update_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "595-753",
    "snippet": "static int devcgroup_update_access(struct dev_cgroup *devcgroup,\n\t\t\t\t   int filetype, char *buffer)\n{\n\tconst char *b;\n\tchar temp[12];\t\t/* 11 + 1 characters needed for a u32 */\n\tint count, rc = 0;\n\tstruct dev_exception_item ex;\n\tstruct dev_cgroup *parent = css_to_devcgroup(devcgroup->css.parent);\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(&ex, 0, sizeof(ex));\n\tb = buffer;\n\n\tswitch (*b) {\n\tcase 'a':\n\t\tswitch (filetype) {\n\t\tcase DEVCG_ALLOW:\n\t\t\tif (css_has_online_children(&devcgroup->css))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (!may_allow_all(parent))\n\t\t\t\treturn -EPERM;\n\t\t\tdev_exception_clean(devcgroup);\n\t\t\tdevcgroup->behavior = DEVCG_DEFAULT_ALLOW;\n\t\t\tif (!parent)\n\t\t\t\tbreak;\n\n\t\t\trc = dev_exceptions_copy(&devcgroup->exceptions,\n\t\t\t\t\t\t &parent->exceptions);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase DEVCG_DENY:\n\t\t\tif (css_has_online_children(&devcgroup->css))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdev_exception_clean(devcgroup);\n\t\t\tdevcgroup->behavior = DEVCG_DEFAULT_DENY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tcase 'b':\n\t\tex.type = DEVCG_DEV_BLOCK;\n\t\tbreak;\n\tcase 'c':\n\t\tex.type = DEVCG_DEV_CHAR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tb++;\n\tif (!isspace(*b))\n\t\treturn -EINVAL;\n\tb++;\n\tif (*b == '*') {\n\t\tex.major = ~0;\n\t\tb++;\n\t} else if (isdigit(*b)) {\n\t\tmemset(temp, 0, sizeof(temp));\n\t\tfor (count = 0; count < sizeof(temp) - 1; count++) {\n\t\t\ttemp[count] = *b;\n\t\t\tb++;\n\t\t\tif (!isdigit(*b))\n\t\t\t\tbreak;\n\t\t}\n\t\trc = kstrtou32(temp, 10, &ex.major);\n\t\tif (rc)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (*b != ':')\n\t\treturn -EINVAL;\n\tb++;\n\n\t/* read minor */\n\tif (*b == '*') {\n\t\tex.minor = ~0;\n\t\tb++;\n\t} else if (isdigit(*b)) {\n\t\tmemset(temp, 0, sizeof(temp));\n\t\tfor (count = 0; count < sizeof(temp) - 1; count++) {\n\t\t\ttemp[count] = *b;\n\t\t\tb++;\n\t\t\tif (!isdigit(*b))\n\t\t\t\tbreak;\n\t\t}\n\t\trc = kstrtou32(temp, 10, &ex.minor);\n\t\tif (rc)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (!isspace(*b))\n\t\treturn -EINVAL;\n\tfor (b++, count = 0; count < 3; count++, b++) {\n\t\tswitch (*b) {\n\t\tcase 'r':\n\t\t\tex.access |= DEVCG_ACC_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tex.access |= DEVCG_ACC_WRITE;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tex.access |= DEVCG_ACC_MKNOD;\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase '\\0':\n\t\t\tcount = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (filetype) {\n\tcase DEVCG_ALLOW:\n\t\t/*\n\t\t * If the default policy is to allow by default, try to remove\n\t\t * an matching exception instead. And be silent about it: we\n\t\t * don't want to break compatibility\n\t\t */\n\t\tif (devcgroup->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\t/* Check if the parent allows removing it first */\n\t\t\tif (!parent_allows_removal(devcgroup, &ex))\n\t\t\t\treturn -EPERM;\n\t\t\tdev_exception_rm(devcgroup, &ex);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!parent_has_perm(devcgroup, &ex))\n\t\t\treturn -EPERM;\n\t\trc = dev_exception_add(devcgroup, &ex);\n\t\tbreak;\n\tcase DEVCG_DENY:\n\t\t/*\n\t\t * If the default policy is to deny by default, try to remove\n\t\t * an matching exception instead. And be silent about it: we\n\t\t * don't want to break compatibility\n\t\t */\n\t\tif (devcgroup->behavior == DEVCG_DEFAULT_DENY)\n\t\t\tdev_exception_rm(devcgroup, &ex);\n\t\telse\n\t\t\trc = dev_exception_add(devcgroup, &ex);\n\n\t\tif (rc)\n\t\t\tbreak;\n\t\t/* we only propagate new restrictions */\n\t\trc = propagate_exception(devcgroup, &ex);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [
      "#define DEVCG_DENY 2",
      "#define DEVCG_ALLOW 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "propagate_exception",
          "args": [
            "devcgroup",
            "&ex"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "533-580",
          "snippet": "static int propagate_exception(struct dev_cgroup *devcg_root,\n\t\t\t       struct dev_exception_item *ex)\n{\n\tstruct cgroup_subsys_state *pos;\n\tint rc = 0;\n\n\trcu_read_lock();\n\n\tcss_for_each_descendant_pre(pos, &devcg_root->css) {\n\t\tstruct dev_cgroup *devcg = css_to_devcgroup(pos);\n\n\t\t/*\n\t\t * Because devcgroup_mutex is held, no devcg will become\n\t\t * online or offline during the tree walk (see on/offline\n\t\t * methods), and online ones are safe to access outside RCU\n\t\t * read lock without bumping refcnt.\n\t\t */\n\t\tif (pos == &devcg_root->css || !is_devcg_online(devcg))\n\t\t\tcontinue;\n\n\t\trcu_read_unlock();\n\n\t\t/*\n\t\t * in case both root's behavior and devcg is allow, a new\n\t\t * restriction means adding to the exception list\n\t\t */\n\t\tif (devcg_root->behavior == DEVCG_DEFAULT_ALLOW &&\n\t\t    devcg->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\trc = dev_exception_add(devcg, ex);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * in the other possible cases:\n\t\t\t * root's behavior: allow, devcg's: deny\n\t\t\t * root's behavior: deny, devcg's: deny\n\t\t\t * the exception will be removed\n\t\t\t */\n\t\t\tdev_exception_rm(devcg, ex);\n\t\t}\n\t\trevalidate_active_exceptions(devcg);\n\n\t\trcu_read_lock();\n\t}\n\n\trcu_read_unlock();\n\treturn rc;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(devcgroup_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic int propagate_exception(struct dev_cgroup *devcg_root,\n\t\t\t       struct dev_exception_item *ex)\n{\n\tstruct cgroup_subsys_state *pos;\n\tint rc = 0;\n\n\trcu_read_lock();\n\n\tcss_for_each_descendant_pre(pos, &devcg_root->css) {\n\t\tstruct dev_cgroup *devcg = css_to_devcgroup(pos);\n\n\t\t/*\n\t\t * Because devcgroup_mutex is held, no devcg will become\n\t\t * online or offline during the tree walk (see on/offline\n\t\t * methods), and online ones are safe to access outside RCU\n\t\t * read lock without bumping refcnt.\n\t\t */\n\t\tif (pos == &devcg_root->css || !is_devcg_online(devcg))\n\t\t\tcontinue;\n\n\t\trcu_read_unlock();\n\n\t\t/*\n\t\t * in case both root's behavior and devcg is allow, a new\n\t\t * restriction means adding to the exception list\n\t\t */\n\t\tif (devcg_root->behavior == DEVCG_DEFAULT_ALLOW &&\n\t\t    devcg->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\trc = dev_exception_add(devcg, ex);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * in the other possible cases:\n\t\t\t * root's behavior: allow, devcg's: deny\n\t\t\t * root's behavior: deny, devcg's: deny\n\t\t\t * the exception will be removed\n\t\t\t */\n\t\t\tdev_exception_rm(devcg, ex);\n\t\t}\n\t\trevalidate_active_exceptions(devcg);\n\n\t\trcu_read_lock();\n\t}\n\n\trcu_read_unlock();\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_exception_add",
          "args": [
            "devcgroup",
            "&ex"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "dev_exception_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "85-112",
          "snippet": "static int dev_exception_add(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *excopy, *walk;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\texcopy = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\tif (!excopy)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(walk, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access |= ex->access;\n\t\tkfree(excopy);\n\t\texcopy = NULL;\n\t}\n\n\tif (excopy != NULL)\n\t\tlist_add_tail_rcu(&excopy->list, &dev_cgroup->exceptions);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(devcgroup_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic int dev_exception_add(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *excopy, *walk;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\texcopy = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\tif (!excopy)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(walk, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access |= ex->access;\n\t\tkfree(excopy);\n\t\texcopy = NULL;\n\t}\n\n\tif (excopy != NULL)\n\t\tlist_add_tail_rcu(&excopy->list, &dev_cgroup->exceptions);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_exception_rm",
          "args": [
            "devcgroup",
            "&ex"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "dev_exception_rm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "117-138",
          "snippet": "static void dev_exception_rm(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *walk, *tmp;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry_safe(walk, tmp, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access &= ~ex->access;\n\t\tif (!walk->access) {\n\t\t\tlist_del_rcu(&walk->list);\n\t\t\tkfree_rcu(walk, rcu);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(devcgroup_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic void dev_exception_rm(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *walk, *tmp;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry_safe(walk, tmp, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access &= ~ex->access;\n\t\tif (!walk->access) {\n\t\t\tlist_del_rcu(&walk->list);\n\t\t\tkfree_rcu(walk, rcu);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_has_perm",
          "args": [
            "devcgroup",
            "&ex"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "parent_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "447-455",
          "snippet": "static int parent_has_perm(struct dev_cgroup *childcg,\n\t\t\t\t  struct dev_exception_item *ex)\n{\n\tstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\n\n\tif (!parent)\n\t\treturn 1;\n\treturn verify_new_ex(parent, ex, childcg->behavior);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic int parent_has_perm(struct dev_cgroup *childcg,\n\t\t\t\t  struct dev_exception_item *ex)\n{\n\tstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\n\n\tif (!parent)\n\t\treturn 1;\n\treturn verify_new_ex(parent, ex, childcg->behavior);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_allows_removal",
          "args": [
            "devcgroup",
            "&ex"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "parent_allows_removal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "468-486",
          "snippet": "static bool parent_allows_removal(struct dev_cgroup *childcg,\n\t\t\t\t  struct dev_exception_item *ex)\n{\n\tstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\n\n\tif (!parent)\n\t\treturn true;\n\n\t/* It's always allowed to remove access to devices */\n\tif (childcg->behavior == DEVCG_DEFAULT_DENY)\n\t\treturn true;\n\n\t/*\n\t * Make sure you're not removing part or a whole exception existing in\n\t * the parent cgroup\n\t */\n\treturn !match_exception_partial(&parent->exceptions, ex->type,\n\t\t\t\t\tex->major, ex->minor, ex->access);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic bool parent_allows_removal(struct dev_cgroup *childcg,\n\t\t\t\t  struct dev_exception_item *ex)\n{\n\tstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\n\n\tif (!parent)\n\t\treturn true;\n\n\t/* It's always allowed to remove access to devices */\n\tif (childcg->behavior == DEVCG_DEFAULT_DENY)\n\t\treturn true;\n\n\t/*\n\t * Make sure you're not removing part or a whole exception existing in\n\t * the parent cgroup\n\t */\n\treturn !match_exception_partial(&parent->exceptions, ex->type,\n\t\t\t\t\tex->major, ex->minor, ex->access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*b"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtou32",
          "args": [
            "temp",
            "10",
            "&ex.minor"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*b"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "temp",
            "0",
            "sizeof(temp)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*b"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtou32",
          "args": [
            "temp",
            "10",
            "&ex.major"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*b"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "temp",
            "0",
            "sizeof(temp)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*b"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*b"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_exception_clean",
          "args": [
            "devcgroup"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "dev_exception_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "156-161",
          "snippet": "static void dev_exception_clean(struct dev_cgroup *dev_cgroup)\n{\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\t__dev_exception_clean(dev_cgroup);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(devcgroup_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic void dev_exception_clean(struct dev_cgroup *dev_cgroup)\n{\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\t__dev_exception_clean(dev_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_has_online_children",
          "args": [
            "&devcgroup->css"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_exceptions_copy",
          "args": [
            "&devcgroup->exceptions",
            "&parent->exceptions"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "dev_exceptions_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "59-80",
          "snippet": "static int dev_exceptions_copy(struct list_head *dest, struct list_head *orig)\n{\n\tstruct dev_exception_item *ex, *tmp, *new;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry(ex, orig, list) {\n\t\tnew = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\t\tif (!new)\n\t\t\tgoto free_and_exit;\n\t\tlist_add_tail(&new->list, dest);\n\t}\n\n\treturn 0;\n\nfree_and_exit:\n\tlist_for_each_entry_safe(ex, tmp, dest, list) {\n\t\tlist_del(&ex->list);\n\t\tkfree(ex);\n\t}\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(devcgroup_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic int dev_exceptions_copy(struct list_head *dest, struct list_head *orig)\n{\n\tstruct dev_exception_item *ex, *tmp, *new;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry(ex, orig, list) {\n\t\tnew = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\t\tif (!new)\n\t\t\tgoto free_and_exit;\n\t\tlist_add_tail(&new->list, dest);\n\t}\n\n\treturn 0;\n\nfree_and_exit:\n\tlist_for_each_entry_safe(ex, tmp, dest, list) {\n\t\tlist_del(&ex->list);\n\t\tkfree(ex);\n\t}\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "may_allow_all",
          "args": [
            "parent"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "may_allow_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "494-499",
          "snippet": "static inline int may_allow_all(struct dev_cgroup *parent)\n{\n\tif (!parent)\n\t\treturn 1;\n\treturn parent->behavior == DEVCG_DEFAULT_ALLOW;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline int may_allow_all(struct dev_cgroup *parent)\n{\n\tif (!parent)\n\t\treturn 1;\n\treturn parent->behavior == DEVCG_DEFAULT_ALLOW;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_has_online_children",
          "args": [
            "&devcgroup->css"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ex",
            "0",
            "sizeof(ex)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_to_devcgroup",
          "args": [
            "devcgroup->css.parent"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "css_to_devcgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "46-49",
          "snippet": "static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\n#define DEVCG_DENY 2\n#define DEVCG_ALLOW 1\n\nstatic int devcgroup_update_access(struct dev_cgroup *devcgroup,\n\t\t\t\t   int filetype, char *buffer)\n{\n\tconst char *b;\n\tchar temp[12];\t\t/* 11 + 1 characters needed for a u32 */\n\tint count, rc = 0;\n\tstruct dev_exception_item ex;\n\tstruct dev_cgroup *parent = css_to_devcgroup(devcgroup->css.parent);\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmemset(&ex, 0, sizeof(ex));\n\tb = buffer;\n\n\tswitch (*b) {\n\tcase 'a':\n\t\tswitch (filetype) {\n\t\tcase DEVCG_ALLOW:\n\t\t\tif (css_has_online_children(&devcgroup->css))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (!may_allow_all(parent))\n\t\t\t\treturn -EPERM;\n\t\t\tdev_exception_clean(devcgroup);\n\t\t\tdevcgroup->behavior = DEVCG_DEFAULT_ALLOW;\n\t\t\tif (!parent)\n\t\t\t\tbreak;\n\n\t\t\trc = dev_exceptions_copy(&devcgroup->exceptions,\n\t\t\t\t\t\t &parent->exceptions);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase DEVCG_DENY:\n\t\t\tif (css_has_online_children(&devcgroup->css))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdev_exception_clean(devcgroup);\n\t\t\tdevcgroup->behavior = DEVCG_DEFAULT_DENY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tcase 'b':\n\t\tex.type = DEVCG_DEV_BLOCK;\n\t\tbreak;\n\tcase 'c':\n\t\tex.type = DEVCG_DEV_CHAR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tb++;\n\tif (!isspace(*b))\n\t\treturn -EINVAL;\n\tb++;\n\tif (*b == '*') {\n\t\tex.major = ~0;\n\t\tb++;\n\t} else if (isdigit(*b)) {\n\t\tmemset(temp, 0, sizeof(temp));\n\t\tfor (count = 0; count < sizeof(temp) - 1; count++) {\n\t\t\ttemp[count] = *b;\n\t\t\tb++;\n\t\t\tif (!isdigit(*b))\n\t\t\t\tbreak;\n\t\t}\n\t\trc = kstrtou32(temp, 10, &ex.major);\n\t\tif (rc)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (*b != ':')\n\t\treturn -EINVAL;\n\tb++;\n\n\t/* read minor */\n\tif (*b == '*') {\n\t\tex.minor = ~0;\n\t\tb++;\n\t} else if (isdigit(*b)) {\n\t\tmemset(temp, 0, sizeof(temp));\n\t\tfor (count = 0; count < sizeof(temp) - 1; count++) {\n\t\t\ttemp[count] = *b;\n\t\t\tb++;\n\t\t\tif (!isdigit(*b))\n\t\t\t\tbreak;\n\t\t}\n\t\trc = kstrtou32(temp, 10, &ex.minor);\n\t\tif (rc)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (!isspace(*b))\n\t\treturn -EINVAL;\n\tfor (b++, count = 0; count < 3; count++, b++) {\n\t\tswitch (*b) {\n\t\tcase 'r':\n\t\t\tex.access |= DEVCG_ACC_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tex.access |= DEVCG_ACC_WRITE;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tex.access |= DEVCG_ACC_MKNOD;\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase '\\0':\n\t\t\tcount = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (filetype) {\n\tcase DEVCG_ALLOW:\n\t\t/*\n\t\t * If the default policy is to allow by default, try to remove\n\t\t * an matching exception instead. And be silent about it: we\n\t\t * don't want to break compatibility\n\t\t */\n\t\tif (devcgroup->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\t/* Check if the parent allows removing it first */\n\t\t\tif (!parent_allows_removal(devcgroup, &ex))\n\t\t\t\treturn -EPERM;\n\t\t\tdev_exception_rm(devcgroup, &ex);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!parent_has_perm(devcgroup, &ex))\n\t\t\treturn -EPERM;\n\t\trc = dev_exception_add(devcgroup, &ex);\n\t\tbreak;\n\tcase DEVCG_DENY:\n\t\t/*\n\t\t * If the default policy is to deny by default, try to remove\n\t\t * an matching exception instead. And be silent about it: we\n\t\t * don't want to break compatibility\n\t\t */\n\t\tif (devcgroup->behavior == DEVCG_DEFAULT_DENY)\n\t\t\tdev_exception_rm(devcgroup, &ex);\n\t\telse\n\t\t\trc = dev_exception_add(devcgroup, &ex);\n\n\t\tif (rc)\n\t\t\tbreak;\n\t\t/* we only propagate new restrictions */\n\t\trc = propagate_exception(devcgroup, &ex);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "propagate_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "533-580",
    "snippet": "static int propagate_exception(struct dev_cgroup *devcg_root,\n\t\t\t       struct dev_exception_item *ex)\n{\n\tstruct cgroup_subsys_state *pos;\n\tint rc = 0;\n\n\trcu_read_lock();\n\n\tcss_for_each_descendant_pre(pos, &devcg_root->css) {\n\t\tstruct dev_cgroup *devcg = css_to_devcgroup(pos);\n\n\t\t/*\n\t\t * Because devcgroup_mutex is held, no devcg will become\n\t\t * online or offline during the tree walk (see on/offline\n\t\t * methods), and online ones are safe to access outside RCU\n\t\t * read lock without bumping refcnt.\n\t\t */\n\t\tif (pos == &devcg_root->css || !is_devcg_online(devcg))\n\t\t\tcontinue;\n\n\t\trcu_read_unlock();\n\n\t\t/*\n\t\t * in case both root's behavior and devcg is allow, a new\n\t\t * restriction means adding to the exception list\n\t\t */\n\t\tif (devcg_root->behavior == DEVCG_DEFAULT_ALLOW &&\n\t\t    devcg->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\trc = dev_exception_add(devcg, ex);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * in the other possible cases:\n\t\t\t * root's behavior: allow, devcg's: deny\n\t\t\t * root's behavior: deny, devcg's: deny\n\t\t\t * the exception will be removed\n\t\t\t */\n\t\t\tdev_exception_rm(devcg, ex);\n\t\t}\n\t\trevalidate_active_exceptions(devcg);\n\n\t\trcu_read_lock();\n\t}\n\n\trcu_read_unlock();\n\treturn rc;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(devcgroup_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revalidate_active_exceptions",
          "args": [
            "devcg"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "revalidate_active_exceptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "514-524",
          "snippet": "static void revalidate_active_exceptions(struct dev_cgroup *devcg)\n{\n\tstruct dev_exception_item *ex;\n\tstruct list_head *this, *tmp;\n\n\tlist_for_each_safe(this, tmp, &devcg->exceptions) {\n\t\tex = container_of(this, struct dev_exception_item, list);\n\t\tif (!parent_has_perm(devcg, ex))\n\t\t\tdev_exception_rm(devcg, ex);\n\t}\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic void revalidate_active_exceptions(struct dev_cgroup *devcg)\n{\n\tstruct dev_exception_item *ex;\n\tstruct list_head *this, *tmp;\n\n\tlist_for_each_safe(this, tmp, &devcg->exceptions) {\n\t\tex = container_of(this, struct dev_exception_item, list);\n\t\tif (!parent_has_perm(devcg, ex))\n\t\t\tdev_exception_rm(devcg, ex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_exception_rm",
          "args": [
            "devcg",
            "ex"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "dev_exception_rm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "117-138",
          "snippet": "static void dev_exception_rm(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *walk, *tmp;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry_safe(walk, tmp, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access &= ~ex->access;\n\t\tif (!walk->access) {\n\t\t\tlist_del_rcu(&walk->list);\n\t\t\tkfree_rcu(walk, rcu);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(devcgroup_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic void dev_exception_rm(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *walk, *tmp;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry_safe(walk, tmp, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access &= ~ex->access;\n\t\tif (!walk->access) {\n\t\t\tlist_del_rcu(&walk->list);\n\t\t\tkfree_rcu(walk, rcu);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_exception_add",
          "args": [
            "devcg",
            "ex"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "dev_exception_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "85-112",
          "snippet": "static int dev_exception_add(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *excopy, *walk;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\texcopy = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\tif (!excopy)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(walk, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access |= ex->access;\n\t\tkfree(excopy);\n\t\texcopy = NULL;\n\t}\n\n\tif (excopy != NULL)\n\t\tlist_add_tail_rcu(&excopy->list, &dev_cgroup->exceptions);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(devcgroup_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic int dev_exception_add(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *excopy, *walk;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\texcopy = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\tif (!excopy)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(walk, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access |= ex->access;\n\t\tkfree(excopy);\n\t\texcopy = NULL;\n\t}\n\n\tif (excopy != NULL)\n\t\tlist_add_tail_rcu(&excopy->list, &dev_cgroup->exceptions);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_devcg_online",
          "args": [
            "devcg"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "is_devcg_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "163-166",
          "snippet": "static inline bool is_devcg_online(const struct dev_cgroup *devcg)\n{\n\treturn (devcg->behavior != DEVCG_DEFAULT_NONE);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline bool is_devcg_online(const struct dev_cgroup *devcg)\n{\n\treturn (devcg->behavior != DEVCG_DEFAULT_NONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_to_devcgroup",
          "args": [
            "pos"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "css_to_devcgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "46-49",
          "snippet": "static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_for_each_descendant_pre",
          "args": [
            "pos",
            "&devcg_root->css"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic int propagate_exception(struct dev_cgroup *devcg_root,\n\t\t\t       struct dev_exception_item *ex)\n{\n\tstruct cgroup_subsys_state *pos;\n\tint rc = 0;\n\n\trcu_read_lock();\n\n\tcss_for_each_descendant_pre(pos, &devcg_root->css) {\n\t\tstruct dev_cgroup *devcg = css_to_devcgroup(pos);\n\n\t\t/*\n\t\t * Because devcgroup_mutex is held, no devcg will become\n\t\t * online or offline during the tree walk (see on/offline\n\t\t * methods), and online ones are safe to access outside RCU\n\t\t * read lock without bumping refcnt.\n\t\t */\n\t\tif (pos == &devcg_root->css || !is_devcg_online(devcg))\n\t\t\tcontinue;\n\n\t\trcu_read_unlock();\n\n\t\t/*\n\t\t * in case both root's behavior and devcg is allow, a new\n\t\t * restriction means adding to the exception list\n\t\t */\n\t\tif (devcg_root->behavior == DEVCG_DEFAULT_ALLOW &&\n\t\t    devcg->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\trc = dev_exception_add(devcg, ex);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * in the other possible cases:\n\t\t\t * root's behavior: allow, devcg's: deny\n\t\t\t * root's behavior: deny, devcg's: deny\n\t\t\t * the exception will be removed\n\t\t\t */\n\t\t\tdev_exception_rm(devcg, ex);\n\t\t}\n\t\trevalidate_active_exceptions(devcg);\n\n\t\trcu_read_lock();\n\t}\n\n\trcu_read_unlock();\n\treturn rc;\n}"
  },
  {
    "function_name": "revalidate_active_exceptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "514-524",
    "snippet": "static void revalidate_active_exceptions(struct dev_cgroup *devcg)\n{\n\tstruct dev_exception_item *ex;\n\tstruct list_head *this, *tmp;\n\n\tlist_for_each_safe(this, tmp, &devcg->exceptions) {\n\t\tex = container_of(this, struct dev_exception_item, list);\n\t\tif (!parent_has_perm(devcg, ex))\n\t\t\tdev_exception_rm(devcg, ex);\n\t}\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_exception_rm",
          "args": [
            "devcg",
            "ex"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "dev_exception_rm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "117-138",
          "snippet": "static void dev_exception_rm(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *walk, *tmp;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry_safe(walk, tmp, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access &= ~ex->access;\n\t\tif (!walk->access) {\n\t\t\tlist_del_rcu(&walk->list);\n\t\t\tkfree_rcu(walk, rcu);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(devcgroup_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic void dev_exception_rm(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *walk, *tmp;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry_safe(walk, tmp, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access &= ~ex->access;\n\t\tif (!walk->access) {\n\t\t\tlist_del_rcu(&walk->list);\n\t\t\tkfree_rcu(walk, rcu);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_has_perm",
          "args": [
            "devcg",
            "ex"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "parent_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "447-455",
          "snippet": "static int parent_has_perm(struct dev_cgroup *childcg,\n\t\t\t\t  struct dev_exception_item *ex)\n{\n\tstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\n\n\tif (!parent)\n\t\treturn 1;\n\treturn verify_new_ex(parent, ex, childcg->behavior);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic int parent_has_perm(struct dev_cgroup *childcg,\n\t\t\t\t  struct dev_exception_item *ex)\n{\n\tstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\n\n\tif (!parent)\n\t\treturn 1;\n\treturn verify_new_ex(parent, ex, childcg->behavior);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "this",
            "structdev_exception_item",
            "list"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "this",
            "tmp",
            "&devcg->exceptions"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic void revalidate_active_exceptions(struct dev_cgroup *devcg)\n{\n\tstruct dev_exception_item *ex;\n\tstruct list_head *this, *tmp;\n\n\tlist_for_each_safe(this, tmp, &devcg->exceptions) {\n\t\tex = container_of(this, struct dev_exception_item, list);\n\t\tif (!parent_has_perm(devcg, ex))\n\t\t\tdev_exception_rm(devcg, ex);\n\t}\n}"
  },
  {
    "function_name": "may_allow_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "494-499",
    "snippet": "static inline int may_allow_all(struct dev_cgroup *parent)\n{\n\tif (!parent)\n\t\treturn 1;\n\treturn parent->behavior == DEVCG_DEFAULT_ALLOW;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline int may_allow_all(struct dev_cgroup *parent)\n{\n\tif (!parent)\n\t\treturn 1;\n\treturn parent->behavior == DEVCG_DEFAULT_ALLOW;\n}"
  },
  {
    "function_name": "parent_allows_removal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "468-486",
    "snippet": "static bool parent_allows_removal(struct dev_cgroup *childcg,\n\t\t\t\t  struct dev_exception_item *ex)\n{\n\tstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\n\n\tif (!parent)\n\t\treturn true;\n\n\t/* It's always allowed to remove access to devices */\n\tif (childcg->behavior == DEVCG_DEFAULT_DENY)\n\t\treturn true;\n\n\t/*\n\t * Make sure you're not removing part or a whole exception existing in\n\t * the parent cgroup\n\t */\n\treturn !match_exception_partial(&parent->exceptions, ex->type,\n\t\t\t\t\tex->major, ex->minor, ex->access);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_exception_partial",
          "args": [
            "&parent->exceptions",
            "ex->type",
            "ex->major",
            "ex->minor",
            "ex->access"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "match_exception_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "350-378",
          "snippet": "static bool match_exception_partial(struct list_head *exceptions, short type,\n\t\t\t\t    u32 major, u32 minor, short access)\n{\n\tstruct dev_exception_item *ex;\n\n\tlist_for_each_entry_rcu(ex, exceptions, list) {\n\t\tif ((type & DEVCG_DEV_BLOCK) && !(ex->type & DEVCG_DEV_BLOCK))\n\t\t\tcontinue;\n\t\tif ((type & DEVCG_DEV_CHAR) && !(ex->type & DEVCG_DEV_CHAR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We must be sure that both the exception and the provided\n\t\t * range aren't masking all devices\n\t\t */\n\t\tif (ex->major != ~0 && major != ~0 && ex->major != major)\n\t\t\tcontinue;\n\t\tif (ex->minor != ~0 && minor != ~0 && ex->minor != minor)\n\t\t\tcontinue;\n\t\t/*\n\t\t * In order to make sure the provided range isn't matching\n\t\t * an exception, all its access bits shouldn't match the\n\t\t * exception's access bits\n\t\t */\n\t\tif (!(access & ex->access))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic bool match_exception_partial(struct list_head *exceptions, short type,\n\t\t\t\t    u32 major, u32 minor, short access)\n{\n\tstruct dev_exception_item *ex;\n\n\tlist_for_each_entry_rcu(ex, exceptions, list) {\n\t\tif ((type & DEVCG_DEV_BLOCK) && !(ex->type & DEVCG_DEV_BLOCK))\n\t\t\tcontinue;\n\t\tif ((type & DEVCG_DEV_CHAR) && !(ex->type & DEVCG_DEV_CHAR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We must be sure that both the exception and the provided\n\t\t * range aren't masking all devices\n\t\t */\n\t\tif (ex->major != ~0 && major != ~0 && ex->major != major)\n\t\t\tcontinue;\n\t\tif (ex->minor != ~0 && minor != ~0 && ex->minor != minor)\n\t\t\tcontinue;\n\t\t/*\n\t\t * In order to make sure the provided range isn't matching\n\t\t * an exception, all its access bits shouldn't match the\n\t\t * exception's access bits\n\t\t */\n\t\tif (!(access & ex->access))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_to_devcgroup",
          "args": [
            "childcg->css.parent"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "css_to_devcgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "46-49",
          "snippet": "static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic bool parent_allows_removal(struct dev_cgroup *childcg,\n\t\t\t\t  struct dev_exception_item *ex)\n{\n\tstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\n\n\tif (!parent)\n\t\treturn true;\n\n\t/* It's always allowed to remove access to devices */\n\tif (childcg->behavior == DEVCG_DEFAULT_DENY)\n\t\treturn true;\n\n\t/*\n\t * Make sure you're not removing part or a whole exception existing in\n\t * the parent cgroup\n\t */\n\treturn !match_exception_partial(&parent->exceptions, ex->type,\n\t\t\t\t\tex->major, ex->minor, ex->access);\n}"
  },
  {
    "function_name": "parent_has_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "447-455",
    "snippet": "static int parent_has_perm(struct dev_cgroup *childcg,\n\t\t\t\t  struct dev_exception_item *ex)\n{\n\tstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\n\n\tif (!parent)\n\t\treturn 1;\n\treturn verify_new_ex(parent, ex, childcg->behavior);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verify_new_ex",
          "args": [
            "parent",
            "ex",
            "childcg->behavior"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "verify_new_ex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "389-440",
          "snippet": "static bool verify_new_ex(struct dev_cgroup *dev_cgroup,\n\t\t          struct dev_exception_item *refex,\n\t\t          enum devcg_behavior behavior)\n{\n\tbool match = false;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held() &&\n\t\t\t !lockdep_is_held(&devcgroup_mutex),\n\t\t\t \"device_cgroup:verify_new_ex called without proper synchronization\");\n\n\tif (dev_cgroup->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\tif (behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\t/*\n\t\t\t * new exception in the child doesn't matter, only\n\t\t\t * adding extra restrictions\n\t\t\t */ \n\t\t\treturn true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * new exception in the child will add more devices\n\t\t\t * that can be acessed, so it can't match any of\n\t\t\t * parent's exceptions, even slightly\n\t\t\t */ \n\t\t\tmatch = match_exception_partial(&dev_cgroup->exceptions,\n\t\t\t\t\t\t\trefex->type,\n\t\t\t\t\t\t\trefex->major,\n\t\t\t\t\t\t\trefex->minor,\n\t\t\t\t\t\t\trefex->access);\n\n\t\t\tif (match)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Only behavior == DEVCG_DEFAULT_DENY allowed here, therefore\n\t\t * the new exception will add access to more devices and must\n\t\t * be contained completely in an parent's exception to be\n\t\t * allowed\n\t\t */\n\t\tmatch = match_exception(&dev_cgroup->exceptions, refex->type,\n\t\t\t\t\trefex->major, refex->minor,\n\t\t\t\t\trefex->access);\n\n\t\tif (match)\n\t\t\t/* parent has an exception that matches the proposed */\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(devcgroup_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic bool verify_new_ex(struct dev_cgroup *dev_cgroup,\n\t\t          struct dev_exception_item *refex,\n\t\t          enum devcg_behavior behavior)\n{\n\tbool match = false;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held() &&\n\t\t\t !lockdep_is_held(&devcgroup_mutex),\n\t\t\t \"device_cgroup:verify_new_ex called without proper synchronization\");\n\n\tif (dev_cgroup->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\tif (behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\t/*\n\t\t\t * new exception in the child doesn't matter, only\n\t\t\t * adding extra restrictions\n\t\t\t */ \n\t\t\treturn true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * new exception in the child will add more devices\n\t\t\t * that can be acessed, so it can't match any of\n\t\t\t * parent's exceptions, even slightly\n\t\t\t */ \n\t\t\tmatch = match_exception_partial(&dev_cgroup->exceptions,\n\t\t\t\t\t\t\trefex->type,\n\t\t\t\t\t\t\trefex->major,\n\t\t\t\t\t\t\trefex->minor,\n\t\t\t\t\t\t\trefex->access);\n\n\t\t\tif (match)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Only behavior == DEVCG_DEFAULT_DENY allowed here, therefore\n\t\t * the new exception will add access to more devices and must\n\t\t * be contained completely in an parent's exception to be\n\t\t * allowed\n\t\t */\n\t\tmatch = match_exception(&dev_cgroup->exceptions, refex->type,\n\t\t\t\t\trefex->major, refex->minor,\n\t\t\t\t\trefex->access);\n\n\t\tif (match)\n\t\t\t/* parent has an exception that matches the proposed */\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_to_devcgroup",
          "args": [
            "childcg->css.parent"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "css_to_devcgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "46-49",
          "snippet": "static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic int parent_has_perm(struct dev_cgroup *childcg,\n\t\t\t\t  struct dev_exception_item *ex)\n{\n\tstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\n\n\tif (!parent)\n\t\treturn 1;\n\treturn verify_new_ex(parent, ex, childcg->behavior);\n}"
  },
  {
    "function_name": "verify_new_ex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "389-440",
    "snippet": "static bool verify_new_ex(struct dev_cgroup *dev_cgroup,\n\t\t          struct dev_exception_item *refex,\n\t\t          enum devcg_behavior behavior)\n{\n\tbool match = false;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held() &&\n\t\t\t !lockdep_is_held(&devcgroup_mutex),\n\t\t\t \"device_cgroup:verify_new_ex called without proper synchronization\");\n\n\tif (dev_cgroup->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\tif (behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\t/*\n\t\t\t * new exception in the child doesn't matter, only\n\t\t\t * adding extra restrictions\n\t\t\t */ \n\t\t\treturn true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * new exception in the child will add more devices\n\t\t\t * that can be acessed, so it can't match any of\n\t\t\t * parent's exceptions, even slightly\n\t\t\t */ \n\t\t\tmatch = match_exception_partial(&dev_cgroup->exceptions,\n\t\t\t\t\t\t\trefex->type,\n\t\t\t\t\t\t\trefex->major,\n\t\t\t\t\t\t\trefex->minor,\n\t\t\t\t\t\t\trefex->access);\n\n\t\t\tif (match)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Only behavior == DEVCG_DEFAULT_DENY allowed here, therefore\n\t\t * the new exception will add access to more devices and must\n\t\t * be contained completely in an parent's exception to be\n\t\t * allowed\n\t\t */\n\t\tmatch = match_exception(&dev_cgroup->exceptions, refex->type,\n\t\t\t\t\trefex->major, refex->minor,\n\t\t\t\t\trefex->access);\n\n\t\tif (match)\n\t\t\t/* parent has an exception that matches the proposed */\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(devcgroup_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_exception",
          "args": [
            "&dev_cgroup->exceptions",
            "refex->type",
            "refex->major",
            "refex->minor",
            "refex->access"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "match_exception_partial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "350-378",
          "snippet": "static bool match_exception_partial(struct list_head *exceptions, short type,\n\t\t\t\t    u32 major, u32 minor, short access)\n{\n\tstruct dev_exception_item *ex;\n\n\tlist_for_each_entry_rcu(ex, exceptions, list) {\n\t\tif ((type & DEVCG_DEV_BLOCK) && !(ex->type & DEVCG_DEV_BLOCK))\n\t\t\tcontinue;\n\t\tif ((type & DEVCG_DEV_CHAR) && !(ex->type & DEVCG_DEV_CHAR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We must be sure that both the exception and the provided\n\t\t * range aren't masking all devices\n\t\t */\n\t\tif (ex->major != ~0 && major != ~0 && ex->major != major)\n\t\t\tcontinue;\n\t\tif (ex->minor != ~0 && minor != ~0 && ex->minor != minor)\n\t\t\tcontinue;\n\t\t/*\n\t\t * In order to make sure the provided range isn't matching\n\t\t * an exception, all its access bits shouldn't match the\n\t\t * exception's access bits\n\t\t */\n\t\tif (!(access & ex->access))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic bool match_exception_partial(struct list_head *exceptions, short type,\n\t\t\t\t    u32 major, u32 minor, short access)\n{\n\tstruct dev_exception_item *ex;\n\n\tlist_for_each_entry_rcu(ex, exceptions, list) {\n\t\tif ((type & DEVCG_DEV_BLOCK) && !(ex->type & DEVCG_DEV_BLOCK))\n\t\t\tcontinue;\n\t\tif ((type & DEVCG_DEV_CHAR) && !(ex->type & DEVCG_DEV_CHAR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We must be sure that both the exception and the provided\n\t\t * range aren't masking all devices\n\t\t */\n\t\tif (ex->major != ~0 && major != ~0 && ex->major != major)\n\t\t\tcontinue;\n\t\tif (ex->minor != ~0 && minor != ~0 && ex->minor != minor)\n\t\t\tcontinue;\n\t\t/*\n\t\t * In order to make sure the provided range isn't matching\n\t\t * an exception, all its access bits shouldn't match the\n\t\t * exception's access bits\n\t\t */\n\t\tif (!(access & ex->access))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "!rcu_read_lock_held() &&\n\t\t\t !lockdep_is_held(&devcgroup_mutex)",
            "\"device_cgroup:verify_new_ex called without proper synchronization\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&devcgroup_mutex"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic bool verify_new_ex(struct dev_cgroup *dev_cgroup,\n\t\t          struct dev_exception_item *refex,\n\t\t          enum devcg_behavior behavior)\n{\n\tbool match = false;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held() &&\n\t\t\t !lockdep_is_held(&devcgroup_mutex),\n\t\t\t \"device_cgroup:verify_new_ex called without proper synchronization\");\n\n\tif (dev_cgroup->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\tif (behavior == DEVCG_DEFAULT_ALLOW) {\n\t\t\t/*\n\t\t\t * new exception in the child doesn't matter, only\n\t\t\t * adding extra restrictions\n\t\t\t */ \n\t\t\treturn true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * new exception in the child will add more devices\n\t\t\t * that can be acessed, so it can't match any of\n\t\t\t * parent's exceptions, even slightly\n\t\t\t */ \n\t\t\tmatch = match_exception_partial(&dev_cgroup->exceptions,\n\t\t\t\t\t\t\trefex->type,\n\t\t\t\t\t\t\trefex->major,\n\t\t\t\t\t\t\trefex->minor,\n\t\t\t\t\t\t\trefex->access);\n\n\t\t\tif (match)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Only behavior == DEVCG_DEFAULT_DENY allowed here, therefore\n\t\t * the new exception will add access to more devices and must\n\t\t * be contained completely in an parent's exception to be\n\t\t * allowed\n\t\t */\n\t\tmatch = match_exception(&dev_cgroup->exceptions, refex->type,\n\t\t\t\t\trefex->major, refex->minor,\n\t\t\t\t\trefex->access);\n\n\t\tif (match)\n\t\t\t/* parent has an exception that matches the proposed */\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "match_exception_partial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "350-378",
    "snippet": "static bool match_exception_partial(struct list_head *exceptions, short type,\n\t\t\t\t    u32 major, u32 minor, short access)\n{\n\tstruct dev_exception_item *ex;\n\n\tlist_for_each_entry_rcu(ex, exceptions, list) {\n\t\tif ((type & DEVCG_DEV_BLOCK) && !(ex->type & DEVCG_DEV_BLOCK))\n\t\t\tcontinue;\n\t\tif ((type & DEVCG_DEV_CHAR) && !(ex->type & DEVCG_DEV_CHAR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We must be sure that both the exception and the provided\n\t\t * range aren't masking all devices\n\t\t */\n\t\tif (ex->major != ~0 && major != ~0 && ex->major != major)\n\t\t\tcontinue;\n\t\tif (ex->minor != ~0 && minor != ~0 && ex->minor != minor)\n\t\t\tcontinue;\n\t\t/*\n\t\t * In order to make sure the provided range isn't matching\n\t\t * an exception, all its access bits shouldn't match the\n\t\t * exception's access bits\n\t\t */\n\t\tif (!(access & ex->access))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "ex",
            "exceptions",
            "list"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic bool match_exception_partial(struct list_head *exceptions, short type,\n\t\t\t\t    u32 major, u32 minor, short access)\n{\n\tstruct dev_exception_item *ex;\n\n\tlist_for_each_entry_rcu(ex, exceptions, list) {\n\t\tif ((type & DEVCG_DEV_BLOCK) && !(ex->type & DEVCG_DEV_BLOCK))\n\t\t\tcontinue;\n\t\tif ((type & DEVCG_DEV_CHAR) && !(ex->type & DEVCG_DEV_CHAR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * We must be sure that both the exception and the provided\n\t\t * range aren't masking all devices\n\t\t */\n\t\tif (ex->major != ~0 && major != ~0 && ex->major != major)\n\t\t\tcontinue;\n\t\tif (ex->minor != ~0 && minor != ~0 && ex->minor != minor)\n\t\t\tcontinue;\n\t\t/*\n\t\t * In order to make sure the provided range isn't matching\n\t\t * an exception, all its access bits shouldn't match the\n\t\t * exception's access bits\n\t\t */\n\t\tif (!(access & ex->access))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "match_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "313-333",
    "snippet": "static bool match_exception(struct list_head *exceptions, short type,\n\t\t\t    u32 major, u32 minor, short access)\n{\n\tstruct dev_exception_item *ex;\n\n\tlist_for_each_entry_rcu(ex, exceptions, list) {\n\t\tif ((type & DEVCG_DEV_BLOCK) && !(ex->type & DEVCG_DEV_BLOCK))\n\t\t\tcontinue;\n\t\tif ((type & DEVCG_DEV_CHAR) && !(ex->type & DEVCG_DEV_CHAR))\n\t\t\tcontinue;\n\t\tif (ex->major != ~0 && ex->major != major)\n\t\t\tcontinue;\n\t\tif (ex->minor != ~0 && ex->minor != minor)\n\t\t\tcontinue;\n\t\t/* provided access cannot have more than the exception rule */\n\t\tif (access & (~ex->access))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "ex",
            "exceptions",
            "list"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic bool match_exception(struct list_head *exceptions, short type,\n\t\t\t    u32 major, u32 minor, short access)\n{\n\tstruct dev_exception_item *ex;\n\n\tlist_for_each_entry_rcu(ex, exceptions, list) {\n\t\tif ((type & DEVCG_DEV_BLOCK) && !(ex->type & DEVCG_DEV_BLOCK))\n\t\t\tcontinue;\n\t\tif ((type & DEVCG_DEV_CHAR) && !(ex->type & DEVCG_DEV_CHAR))\n\t\t\tcontinue;\n\t\tif (ex->major != ~0 && ex->major != major)\n\t\t\tcontinue;\n\t\tif (ex->minor != ~0 && ex->minor != minor)\n\t\t\tcontinue;\n\t\t/* provided access cannot have more than the exception rule */\n\t\tif (access & (~ex->access))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "devcgroup_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "267-298",
    "snippet": "static int devcgroup_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dev_cgroup *devcgroup = css_to_devcgroup(seq_css(m));\n\tstruct dev_exception_item *ex;\n\tchar maj[MAJMINLEN], min[MAJMINLEN], acc[ACCLEN];\n\n\trcu_read_lock();\n\t/*\n\t * To preserve the compatibility:\n\t * - Only show the \"all devices\" when the default policy is to allow\n\t * - List the exceptions in case the default policy is to deny\n\t * This way, the file remains as a \"whitelist of devices\"\n\t */\n\tif (devcgroup->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\tset_access(acc, DEVCG_ACC_MASK);\n\t\tset_majmin(maj, ~0);\n\t\tset_majmin(min, ~0);\n\t\tseq_printf(m, \"%c %s:%s %s\\n\", type_to_char(DEVCG_DEV_ALL),\n\t\t\t   maj, min, acc);\n\t} else {\n\t\tlist_for_each_entry_rcu(ex, &devcgroup->exceptions, list) {\n\t\t\tset_access(acc, ex->access);\n\t\t\tset_majmin(maj, ex->major);\n\t\t\tset_majmin(min, ex->minor);\n\t\t\tseq_printf(m, \"%c %s:%s %s\\n\", type_to_char(ex->type),\n\t\t\t\t   maj, min, acc);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [
      "#define ACCLEN 4",
      "#define MAJMINLEN 13"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%c %s:%s %s\\n\"",
            "type_to_char(ex->type)",
            "maj",
            "min",
            "acc"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type_to_char",
          "args": [
            "ex->type"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "type_to_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "248-257",
          "snippet": "static char type_to_char(short type)\n{\n\tif (type == DEVCG_DEV_ALL)\n\t\treturn 'a';\n\tif (type == DEVCG_DEV_CHAR)\n\t\treturn 'c';\n\tif (type == DEVCG_DEV_BLOCK)\n\t\treturn 'b';\n\treturn 'X';\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic char type_to_char(short type)\n{\n\tif (type == DEVCG_DEV_ALL)\n\t\treturn 'a';\n\tif (type == DEVCG_DEV_CHAR)\n\t\treturn 'c';\n\tif (type == DEVCG_DEV_BLOCK)\n\t\treturn 'b';\n\treturn 'X';\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_majmin",
          "args": [
            "min",
            "ex->minor"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "set_majmin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "259-265",
          "snippet": "static void set_majmin(char *str, unsigned m)\n{\n\tif (m == ~0)\n\t\tstrcpy(str, \"*\");\n\telse\n\t\tsprintf(str, \"%u\", m);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic void set_majmin(char *str, unsigned m)\n{\n\tif (m == ~0)\n\t\tstrcpy(str, \"*\");\n\telse\n\t\tsprintf(str, \"%u\", m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_access",
          "args": [
            "acc",
            "ex->access"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "set_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "236-246",
          "snippet": "static void set_access(char *acc, short access)\n{\n\tint idx = 0;\n\tmemset(acc, 0, ACCLEN);\n\tif (access & DEVCG_ACC_READ)\n\t\tacc[idx++] = 'r';\n\tif (access & DEVCG_ACC_WRITE)\n\t\tacc[idx++] = 'w';\n\tif (access & DEVCG_ACC_MKNOD)\n\t\tacc[idx++] = 'm';\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [
            "#define ACCLEN 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\n#define ACCLEN 4\n\nstatic void set_access(char *acc, short access)\n{\n\tint idx = 0;\n\tmemset(acc, 0, ACCLEN);\n\tif (access & DEVCG_ACC_READ)\n\t\tacc[idx++] = 'r';\n\tif (access & DEVCG_ACC_WRITE)\n\t\tacc[idx++] = 'w';\n\tif (access & DEVCG_ACC_MKNOD)\n\t\tacc[idx++] = 'm';\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "ex",
            "&devcgroup->exceptions",
            "list"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%c %s:%s %s\\n\"",
            "type_to_char(DEVCG_DEV_ALL)",
            "maj",
            "min",
            "acc"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_to_devcgroup",
          "args": [
            "seq_css(m)"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "css_to_devcgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "46-49",
          "snippet": "static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "m"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\n#define ACCLEN 4\n#define MAJMINLEN 13\n\nstatic int devcgroup_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dev_cgroup *devcgroup = css_to_devcgroup(seq_css(m));\n\tstruct dev_exception_item *ex;\n\tchar maj[MAJMINLEN], min[MAJMINLEN], acc[ACCLEN];\n\n\trcu_read_lock();\n\t/*\n\t * To preserve the compatibility:\n\t * - Only show the \"all devices\" when the default policy is to allow\n\t * - List the exceptions in case the default policy is to deny\n\t * This way, the file remains as a \"whitelist of devices\"\n\t */\n\tif (devcgroup->behavior == DEVCG_DEFAULT_ALLOW) {\n\t\tset_access(acc, DEVCG_ACC_MASK);\n\t\tset_majmin(maj, ~0);\n\t\tset_majmin(min, ~0);\n\t\tseq_printf(m, \"%c %s:%s %s\\n\", type_to_char(DEVCG_DEV_ALL),\n\t\t\t   maj, min, acc);\n\t} else {\n\t\tlist_for_each_entry_rcu(ex, &devcgroup->exceptions, list) {\n\t\t\tset_access(acc, ex->access);\n\t\t\tset_majmin(maj, ex->major);\n\t\t\tset_majmin(min, ex->minor);\n\t\t\tseq_printf(m, \"%c %s:%s %s\\n\", type_to_char(ex->type),\n\t\t\t\t   maj, min, acc);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_majmin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "259-265",
    "snippet": "static void set_majmin(char *str, unsigned m)\n{\n\tif (m == ~0)\n\t\tstrcpy(str, \"*\");\n\telse\n\t\tsprintf(str, \"%u\", m);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%u\"",
            "m"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "str",
            "\"*\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic void set_majmin(char *str, unsigned m)\n{\n\tif (m == ~0)\n\t\tstrcpy(str, \"*\");\n\telse\n\t\tsprintf(str, \"%u\", m);\n}"
  },
  {
    "function_name": "type_to_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "248-257",
    "snippet": "static char type_to_char(short type)\n{\n\tif (type == DEVCG_DEV_ALL)\n\t\treturn 'a';\n\tif (type == DEVCG_DEV_CHAR)\n\t\treturn 'c';\n\tif (type == DEVCG_DEV_BLOCK)\n\t\treturn 'b';\n\treturn 'X';\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic char type_to_char(short type)\n{\n\tif (type == DEVCG_DEV_ALL)\n\t\treturn 'a';\n\tif (type == DEVCG_DEV_CHAR)\n\t\treturn 'c';\n\tif (type == DEVCG_DEV_BLOCK)\n\t\treturn 'b';\n\treturn 'X';\n}"
  },
  {
    "function_name": "set_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "236-246",
    "snippet": "static void set_access(char *acc, short access)\n{\n\tint idx = 0;\n\tmemset(acc, 0, ACCLEN);\n\tif (access & DEVCG_ACC_READ)\n\t\tacc[idx++] = 'r';\n\tif (access & DEVCG_ACC_WRITE)\n\t\tacc[idx++] = 'w';\n\tif (access & DEVCG_ACC_MKNOD)\n\t\tacc[idx++] = 'm';\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [
      "#define ACCLEN 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "acc",
            "0",
            "ACCLEN"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\n#define ACCLEN 4\n\nstatic void set_access(char *acc, short access)\n{\n\tint idx = 0;\n\tmemset(acc, 0, ACCLEN);\n\tif (access & DEVCG_ACC_READ)\n\t\tacc[idx++] = 'r';\n\tif (access & DEVCG_ACC_WRITE)\n\t\tacc[idx++] = 'w';\n\tif (access & DEVCG_ACC_MKNOD)\n\t\tacc[idx++] = 'm';\n}"
  },
  {
    "function_name": "devcgroup_css_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "221-227",
    "snippet": "static void devcgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct dev_cgroup *dev_cgroup = css_to_devcgroup(css);\n\n\t__dev_exception_clean(dev_cgroup);\n\tkfree(dev_cgroup);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dev_cgroup"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dev_exception_clean",
          "args": [
            "dev_cgroup"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "__dev_exception_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "140-148",
          "snippet": "static void __dev_exception_clean(struct dev_cgroup *dev_cgroup)\n{\n\tstruct dev_exception_item *ex, *tmp;\n\n\tlist_for_each_entry_safe(ex, tmp, &dev_cgroup->exceptions, list) {\n\t\tlist_del_rcu(&ex->list);\n\t\tkfree_rcu(ex, rcu);\n\t}\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic void __dev_exception_clean(struct dev_cgroup *dev_cgroup)\n{\n\tstruct dev_exception_item *ex, *tmp;\n\n\tlist_for_each_entry_safe(ex, tmp, &dev_cgroup->exceptions, list) {\n\t\tlist_del_rcu(&ex->list);\n\t\tkfree_rcu(ex, rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_to_devcgroup",
          "args": [
            "css"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "css_to_devcgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "46-49",
          "snippet": "static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic void devcgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct dev_cgroup *dev_cgroup = css_to_devcgroup(css);\n\n\t__dev_exception_clean(dev_cgroup);\n\tkfree(dev_cgroup);\n}"
  },
  {
    "function_name": "devcgroup_css_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "207-219",
    "snippet": "static struct cgroup_subsys_state *\ndevcgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct dev_cgroup *dev_cgroup;\n\n\tdev_cgroup = kzalloc(sizeof(*dev_cgroup), GFP_KERNEL);\n\tif (!dev_cgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\tINIT_LIST_HEAD(&dev_cgroup->exceptions);\n\tdev_cgroup->behavior = DEVCG_DEFAULT_NONE;\n\n\treturn &dev_cgroup->css;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dev_cgroup->exceptions"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*dev_cgroup)",
            "GFP_KERNEL"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic struct cgroup_subsys_state *\ndevcgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct dev_cgroup *dev_cgroup;\n\n\tdev_cgroup = kzalloc(sizeof(*dev_cgroup), GFP_KERNEL);\n\tif (!dev_cgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\tINIT_LIST_HEAD(&dev_cgroup->exceptions);\n\tdev_cgroup->behavior = DEVCG_DEFAULT_NONE;\n\n\treturn &dev_cgroup->css;\n}"
  },
  {
    "function_name": "devcgroup_offline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "195-202",
    "snippet": "static void devcgroup_offline(struct cgroup_subsys_state *css)\n{\n\tstruct dev_cgroup *dev_cgroup = css_to_devcgroup(css);\n\n\tmutex_lock(&devcgroup_mutex);\n\tdev_cgroup->behavior = DEVCG_DEFAULT_NONE;\n\tmutex_unlock(&devcgroup_mutex);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(devcgroup_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&devcgroup_mutex"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&devcgroup_mutex"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_to_devcgroup",
          "args": [
            "css"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "css_to_devcgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "46-49",
          "snippet": "static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic void devcgroup_offline(struct cgroup_subsys_state *css)\n{\n\tstruct dev_cgroup *dev_cgroup = css_to_devcgroup(css);\n\n\tmutex_lock(&devcgroup_mutex);\n\tdev_cgroup->behavior = DEVCG_DEFAULT_NONE;\n\tmutex_unlock(&devcgroup_mutex);\n}"
  },
  {
    "function_name": "devcgroup_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "174-193",
    "snippet": "static int devcgroup_online(struct cgroup_subsys_state *css)\n{\n\tstruct dev_cgroup *dev_cgroup = css_to_devcgroup(css);\n\tstruct dev_cgroup *parent_dev_cgroup = css_to_devcgroup(css->parent);\n\tint ret = 0;\n\n\tmutex_lock(&devcgroup_mutex);\n\n\tif (parent_dev_cgroup == NULL)\n\t\tdev_cgroup->behavior = DEVCG_DEFAULT_ALLOW;\n\telse {\n\t\tret = dev_exceptions_copy(&dev_cgroup->exceptions,\n\t\t\t\t\t  &parent_dev_cgroup->exceptions);\n\t\tif (!ret)\n\t\t\tdev_cgroup->behavior = parent_dev_cgroup->behavior;\n\t}\n\tmutex_unlock(&devcgroup_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(devcgroup_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&devcgroup_mutex"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_exceptions_copy",
          "args": [
            "&dev_cgroup->exceptions",
            "&parent_dev_cgroup->exceptions"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "dev_exceptions_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "59-80",
          "snippet": "static int dev_exceptions_copy(struct list_head *dest, struct list_head *orig)\n{\n\tstruct dev_exception_item *ex, *tmp, *new;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry(ex, orig, list) {\n\t\tnew = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\t\tif (!new)\n\t\t\tgoto free_and_exit;\n\t\tlist_add_tail(&new->list, dest);\n\t}\n\n\treturn 0;\n\nfree_and_exit:\n\tlist_for_each_entry_safe(ex, tmp, dest, list) {\n\t\tlist_del(&ex->list);\n\t\tkfree(ex);\n\t}\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(devcgroup_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic int dev_exceptions_copy(struct list_head *dest, struct list_head *orig)\n{\n\tstruct dev_exception_item *ex, *tmp, *new;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry(ex, orig, list) {\n\t\tnew = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\t\tif (!new)\n\t\t\tgoto free_and_exit;\n\t\tlist_add_tail(&new->list, dest);\n\t}\n\n\treturn 0;\n\nfree_and_exit:\n\tlist_for_each_entry_safe(ex, tmp, dest, list) {\n\t\tlist_del(&ex->list);\n\t\tkfree(ex);\n\t}\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&devcgroup_mutex"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_to_devcgroup",
          "args": [
            "css->parent"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "css_to_devcgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "46-49",
          "snippet": "static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic int devcgroup_online(struct cgroup_subsys_state *css)\n{\n\tstruct dev_cgroup *dev_cgroup = css_to_devcgroup(css);\n\tstruct dev_cgroup *parent_dev_cgroup = css_to_devcgroup(css->parent);\n\tint ret = 0;\n\n\tmutex_lock(&devcgroup_mutex);\n\n\tif (parent_dev_cgroup == NULL)\n\t\tdev_cgroup->behavior = DEVCG_DEFAULT_ALLOW;\n\telse {\n\t\tret = dev_exceptions_copy(&dev_cgroup->exceptions,\n\t\t\t\t\t  &parent_dev_cgroup->exceptions);\n\t\tif (!ret)\n\t\t\tdev_cgroup->behavior = parent_dev_cgroup->behavior;\n\t}\n\tmutex_unlock(&devcgroup_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "is_devcg_online",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "163-166",
    "snippet": "static inline bool is_devcg_online(const struct dev_cgroup *devcg)\n{\n\treturn (devcg->behavior != DEVCG_DEFAULT_NONE);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline bool is_devcg_online(const struct dev_cgroup *devcg)\n{\n\treturn (devcg->behavior != DEVCG_DEFAULT_NONE);\n}"
  },
  {
    "function_name": "dev_exception_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "156-161",
    "snippet": "static void dev_exception_clean(struct dev_cgroup *dev_cgroup)\n{\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\t__dev_exception_clean(dev_cgroup);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(devcgroup_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dev_exception_clean",
          "args": [
            "dev_cgroup"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "__dev_exception_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "140-148",
          "snippet": "static void __dev_exception_clean(struct dev_cgroup *dev_cgroup)\n{\n\tstruct dev_exception_item *ex, *tmp;\n\n\tlist_for_each_entry_safe(ex, tmp, &dev_cgroup->exceptions, list) {\n\t\tlist_del_rcu(&ex->list);\n\t\tkfree_rcu(ex, rcu);\n\t}\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic void __dev_exception_clean(struct dev_cgroup *dev_cgroup)\n{\n\tstruct dev_exception_item *ex, *tmp;\n\n\tlist_for_each_entry_safe(ex, tmp, &dev_cgroup->exceptions, list) {\n\t\tlist_del_rcu(&ex->list);\n\t\tkfree_rcu(ex, rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&devcgroup_mutex"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic void dev_exception_clean(struct dev_cgroup *dev_cgroup)\n{\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\t__dev_exception_clean(dev_cgroup);\n}"
  },
  {
    "function_name": "__dev_exception_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "140-148",
    "snippet": "static void __dev_exception_clean(struct dev_cgroup *dev_cgroup)\n{\n\tstruct dev_exception_item *ex, *tmp;\n\n\tlist_for_each_entry_safe(ex, tmp, &dev_cgroup->exceptions, list) {\n\t\tlist_del_rcu(&ex->list);\n\t\tkfree_rcu(ex, rcu);\n\t}\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "ex",
            "rcu"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&ex->list"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ex",
            "tmp",
            "&dev_cgroup->exceptions",
            "list"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic void __dev_exception_clean(struct dev_cgroup *dev_cgroup)\n{\n\tstruct dev_exception_item *ex, *tmp;\n\n\tlist_for_each_entry_safe(ex, tmp, &dev_cgroup->exceptions, list) {\n\t\tlist_del_rcu(&ex->list);\n\t\tkfree_rcu(ex, rcu);\n\t}\n}"
  },
  {
    "function_name": "dev_exception_rm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "117-138",
    "snippet": "static void dev_exception_rm(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *walk, *tmp;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry_safe(walk, tmp, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access &= ~ex->access;\n\t\tif (!walk->access) {\n\t\t\tlist_del_rcu(&walk->list);\n\t\t\tkfree_rcu(walk, rcu);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(devcgroup_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "walk",
            "rcu"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&walk->list"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "walk",
            "tmp",
            "&dev_cgroup->exceptions",
            "list"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&devcgroup_mutex"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic void dev_exception_rm(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *walk, *tmp;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry_safe(walk, tmp, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access &= ~ex->access;\n\t\tif (!walk->access) {\n\t\t\tlist_del_rcu(&walk->list);\n\t\t\tkfree_rcu(walk, rcu);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "dev_exception_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "85-112",
    "snippet": "static int dev_exception_add(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *excopy, *walk;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\texcopy = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\tif (!excopy)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(walk, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access |= ex->access;\n\t\tkfree(excopy);\n\t\texcopy = NULL;\n\t}\n\n\tif (excopy != NULL)\n\t\tlist_add_tail_rcu(&excopy->list, &dev_cgroup->exceptions);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(devcgroup_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&excopy->list",
            "&dev_cgroup->exceptions"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "excopy"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "walk",
            "&dev_cgroup->exceptions",
            "list"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "ex",
            "sizeof(*ex)",
            "GFP_KERNEL"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&devcgroup_mutex"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic int dev_exception_add(struct dev_cgroup *dev_cgroup,\n\t\t\t     struct dev_exception_item *ex)\n{\n\tstruct dev_exception_item *excopy, *walk;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\texcopy = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\tif (!excopy)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(walk, &dev_cgroup->exceptions, list) {\n\t\tif (walk->type != ex->type)\n\t\t\tcontinue;\n\t\tif (walk->major != ex->major)\n\t\t\tcontinue;\n\t\tif (walk->minor != ex->minor)\n\t\t\tcontinue;\n\n\t\twalk->access |= ex->access;\n\t\tkfree(excopy);\n\t\texcopy = NULL;\n\t}\n\n\tif (excopy != NULL)\n\t\tlist_add_tail_rcu(&excopy->list, &dev_cgroup->exceptions);\n\treturn 0;\n}"
  },
  {
    "function_name": "dev_exceptions_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "59-80",
    "snippet": "static int dev_exceptions_copy(struct list_head *dest, struct list_head *orig)\n{\n\tstruct dev_exception_item *ex, *tmp, *new;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry(ex, orig, list) {\n\t\tnew = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\t\tif (!new)\n\t\t\tgoto free_and_exit;\n\t\tlist_add_tail(&new->list, dest);\n\t}\n\n\treturn 0;\n\nfree_and_exit:\n\tlist_for_each_entry_safe(ex, tmp, dest, list) {\n\t\tlist_del(&ex->list);\n\t\tkfree(ex);\n\t}\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(devcgroup_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ex"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ex->list"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ex",
            "tmp",
            "dest",
            "list"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new->list",
            "dest"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "ex",
            "sizeof(*ex)",
            "GFP_KERNEL"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ex",
            "orig",
            "list"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&devcgroup_mutex"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic DEFINE_MUTEX(devcgroup_mutex);\n\nstatic int dev_exceptions_copy(struct list_head *dest, struct list_head *orig)\n{\n\tstruct dev_exception_item *ex, *tmp, *new;\n\n\tlockdep_assert_held(&devcgroup_mutex);\n\n\tlist_for_each_entry(ex, orig, list) {\n\t\tnew = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\n\t\tif (!new)\n\t\t\tgoto free_and_exit;\n\t\tlist_add_tail(&new->list, dest);\n\t}\n\n\treturn 0;\n\nfree_and_exit:\n\tlist_for_each_entry_safe(ex, tmp, dest, list) {\n\t\tlist_del(&ex->list);\n\t\tkfree(ex);\n\t}\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "task_devcgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "51-54",
    "snippet": "static inline struct dev_cgroup *task_devcgroup(struct task_struct *task)\n{\n\treturn css_to_devcgroup(task_css(task, devices_cgrp_id));\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_to_devcgroup",
          "args": [
            "task_css(task, devices_cgrp_id)"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "css_to_devcgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "46-49",
          "snippet": "static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css",
          "args": [
            "task",
            "devices_cgrp_id"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline struct dev_cgroup *task_devcgroup(struct task_struct *task)\n{\n\treturn css_to_devcgroup(task_css(task, devices_cgrp_id));\n}"
  },
  {
    "function_name": "css_to_devcgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
    "lines": "46-49",
    "snippet": "static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/list.h>",
      "#include <linux/ctype.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/device_cgroup.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "s",
            "structdev_cgroup",
            "css"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\n{\n\treturn s ? container_of(s, struct dev_cgroup, css) : NULL;\n}"
  }
]