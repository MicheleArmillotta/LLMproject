[
  {
    "function_name": "key_garbage_collector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/gc.c",
    "lines": "173-369",
    "snippet": "static void key_garbage_collector(struct work_struct *work)\n{\n\tstatic LIST_HEAD(graveyard);\n\tstatic u8 gc_state;\t\t/* Internal persistent state */\n#define KEY_GC_REAP_AGAIN\t0x01\t/* - Need another cycle */\n#define KEY_GC_REAPING_LINKS\t0x02\t/* - We need to reap links */\n#define KEY_GC_SET_TIMER\t0x04\t/* - We need to restart the timer */\n#define KEY_GC_REAPING_DEAD_1\t0x10\t/* - We need to mark dead keys */\n#define KEY_GC_REAPING_DEAD_2\t0x20\t/* - We need to reap dead key links */\n#define KEY_GC_REAPING_DEAD_3\t0x40\t/* - We need to reap dead keys */\n#define KEY_GC_FOUND_DEAD_KEY\t0x80\t/* - We found at least one dead key */\n\n\tstruct rb_node *cursor;\n\tstruct key *key;\n\ttime64_t new_timer, limit;\n\n\tkenter(\"[%lx,%x]\", key_gc_flags, gc_state);\n\n\tlimit = ktime_get_real_seconds();\n\tif (limit > key_gc_delay)\n\t\tlimit -= key_gc_delay;\n\telse\n\t\tlimit = key_gc_delay;\n\n\t/* Work out what we're going to be doing in this pass */\n\tgc_state &= KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2;\n\tgc_state <<= 1;\n\tif (test_and_clear_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_LINKS | KEY_GC_SET_TIMER;\n\n\tif (test_and_clear_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_DEAD_1;\n\tkdebug(\"new pass %x\", gc_state);\n\n\tnew_timer = TIME64_MAX;\n\n\t/* As only this function is permitted to remove things from the key\n\t * serial tree, if cursor is non-NULL then it will always point to a\n\t * valid node in the tree - even if lock got dropped.\n\t */\n\tspin_lock(&key_serial_lock);\n\tcursor = rb_first(&key_serial_tree);\n\ncontinue_scanning:\n\twhile (cursor) {\n\t\tkey = rb_entry(cursor, struct key, serial_node);\n\t\tcursor = rb_next(cursor);\n\n\t\tif (refcount_read(&key->usage) == 0)\n\t\t\tgoto found_unreferenced_key;\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_1)) {\n\t\t\tif (key->type == key_gc_dead_keytype) {\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\t\t\t\tset_bit(KEY_FLAG_DEAD, &key->flags);\n\t\t\t\tkey->perm = 0;\n\t\t\t\tgoto skip_dead_key;\n\t\t\t} else if (key->type == &key_type_keyring &&\n\t\t\t\t   key->restrict_link) {\n\t\t\t\tgoto found_restricted_keyring;\n\t\t\t}\n\t\t}\n\n\t\tif (gc_state & KEY_GC_SET_TIMER) {\n\t\t\tif (key->expiry > limit && key->expiry < new_timer) {\n\t\t\t\tkdebug(\"will expire %x in %lld\",\n\t\t\t\t       key_serial(key), key->expiry - limit);\n\t\t\t\tnew_timer = key->expiry;\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\n\t\tif ((gc_state & KEY_GC_REAPING_LINKS) ||\n\t\t    unlikely(gc_state & KEY_GC_REAPING_DEAD_2)) {\n\t\t\tif (key->type == &key_type_keyring)\n\t\t\t\tgoto found_keyring;\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgoto destroy_dead_key;\n\n\tskip_dead_key:\n\t\tif (spin_is_contended(&key_serial_lock) || need_resched())\n\t\t\tgoto contended;\n\t}\n\ncontended:\n\tspin_unlock(&key_serial_lock);\n\nmaybe_resched:\n\tif (cursor) {\n\t\tcond_resched();\n\t\tspin_lock(&key_serial_lock);\n\t\tgoto continue_scanning;\n\t}\n\n\t/* We've completed the pass.  Set the timer if we need to and queue a\n\t * new cycle if necessary.  We keep executing cycles until we find one\n\t * where we didn't reap any keys.\n\t */\n\tkdebug(\"pass complete\");\n\n\tif (gc_state & KEY_GC_SET_TIMER && new_timer != (time64_t)TIME64_MAX) {\n\t\tnew_timer += key_gc_delay;\n\t\tkey_schedule_gc(new_timer);\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2) ||\n\t    !list_empty(&graveyard)) {\n\t\t/* Make sure that all pending keyring payload destructions are\n\t\t * fulfilled and that people aren't now looking at dead or\n\t\t * dying keys that they don't have a reference upon or a link\n\t\t * to.\n\t\t */\n\t\tkdebug(\"gc sync\");\n\t\tsynchronize_rcu();\n\t}\n\n\tif (!list_empty(&graveyard)) {\n\t\tkdebug(\"gc keys\");\n\t\tkey_gc_unused_keys(&graveyard);\n\t}\n\n\tif (unlikely(gc_state & (KEY_GC_REAPING_DEAD_1 |\n\t\t\t\t KEY_GC_REAPING_DEAD_2))) {\n\t\tif (!(gc_state & KEY_GC_FOUND_DEAD_KEY)) {\n\t\t\t/* No remaining dead keys: short circuit the remaining\n\t\t\t * keytype reap cycles.\n\t\t\t */\n\t\t\tkdebug(\"dead short\");\n\t\t\tgc_state &= ~(KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2);\n\t\t\tgc_state |= KEY_GC_REAPING_DEAD_3;\n\t\t} else {\n\t\t\tgc_state |= KEY_GC_REAP_AGAIN;\n\t\t}\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3)) {\n\t\tkdebug(\"dead wake\");\n\t\tsmp_mb();\n\t\tclear_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\t\twake_up_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE);\n\t}\n\n\tif (gc_state & KEY_GC_REAP_AGAIN)\n\t\tschedule_work(&key_gc_work);\n\tkleave(\" [end %x]\", gc_state);\n\treturn;\n\n\t/* We found an unreferenced key - once we've removed it from the tree,\n\t * we can safely drop the lock.\n\t */\nfound_unreferenced_key:\n\tkdebug(\"unrefd key %d\", key->serial);\n\trb_erase(&key->serial_node, &key_serial_tree);\n\tspin_unlock(&key_serial_lock);\n\n\tlist_add_tail(&key->graveyard_link, &graveyard);\n\tgc_state |= KEY_GC_REAP_AGAIN;\n\tgoto maybe_resched;\n\n\t/* We found a restricted keyring and need to update the restriction if\n\t * it is associated with the dead key type.\n\t */\nfound_restricted_keyring:\n\tspin_unlock(&key_serial_lock);\n\tkeyring_restriction_gc(key, key_gc_dead_keytype);\n\tgoto maybe_resched;\n\n\t/* We found a keyring and we need to check the payload for links to\n\t * dead or expired keys.  We don't flag another reap immediately as we\n\t * have to wait for the old payload to be destroyed by RCU before we\n\t * can reap the keys to which it refers.\n\t */\nfound_keyring:\n\tspin_unlock(&key_serial_lock);\n\tkeyring_gc(key, limit);\n\tgoto maybe_resched;\n\n\t/* We found a dead key that is still referenced.  Reset its type and\n\t * destroy its payload with its semaphore held.\n\t */\ndestroy_dead_key:\n\tspin_unlock(&key_serial_lock);\n\tkdebug(\"destroy key %d\", key->serial);\n\tdown_write(&key->sem);\n\tkey->type = &key_type_dead;\n\tif (key_gc_dead_keytype->destroy)\n\t\tkey_gc_dead_keytype->destroy(key);\n\tmemset(&key->payload, KEY_DESTROY, sizeof(key->payload));\n\tup_write(&key->sem);\n\tgoto maybe_resched;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/keyring-type.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define KEY_GC_FOUND_DEAD_KEY\t0x80\t/* - We found at least one dead key */",
      "#define KEY_GC_REAPING_DEAD_3\t0x40\t/* - We need to reap dead keys */",
      "#define KEY_GC_REAPING_DEAD_2\t0x20\t/* - We need to reap dead key links */",
      "#define KEY_GC_REAPING_DEAD_1\t0x10\t/* - We need to mark dead keys */",
      "#define KEY_GC_SET_TIMER\t0x04\t/* - We need to restart the timer */",
      "#define KEY_GC_REAPING_LINKS\t0x02\t/* - We need to reap links */",
      "#define KEY_GC_REAP_AGAIN\t0x01\t/* - Need another cycle */",
      "#define KEY_GC_REAPING_KEYTYPE\t2\t/* Cleared when keytype reaped */",
      "#define KEY_GC_REAP_KEYTYPE\t1\t/* A keytype is being unregistered */",
      "#define KEY_GC_KEY_EXPIRED\t0\t/* A key expired and needs unlinking */"
    ],
    "globals_used": [
      "unsigned key_gc_delay = 5 * 60;",
      "static void key_garbage_collector(struct work_struct *work);",
      "static struct key_type *key_gc_dead_keytype;",
      "static unsigned long key_gc_flags;",
      "struct key_type key_type_dead = {\n\t.name = \".dead\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&key->sem"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&key->payload",
            "KEY_DESTROY",
            "sizeof(key->payload)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_gc_dead_keytype->destroy",
          "args": [
            "key"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&key->sem"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"destroy key %d\"",
            "key->serial"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&key_serial_lock"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_gc",
          "args": [
            "key",
            "limit"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "1515-1543",
          "snippet": "void keyring_gc(struct key *keyring, time64_t limit)\n{\n\tint result;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto dont_gc;\n\n\t/* scan the keyring looking for dead keys */\n\trcu_read_lock();\n\tresult = assoc_array_iterate(&keyring->keys,\n\t\t\t\t     keyring_gc_check_iterator, &limit);\n\trcu_read_unlock();\n\tif (result == true)\n\t\tgoto do_gc;\n\ndont_gc:\n\tkleave(\" [no gc]\");\n\treturn;\n\ndo_gc:\n\tdown_write(&keyring->sem);\n\tassoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,\n\t\t       keyring_gc_select_iterator, &limit);\n\tup_write(&keyring->sem);\n\tkleave(\" [gc]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);",
            "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nvoid keyring_gc(struct key *keyring, time64_t limit)\n{\n\tint result;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto dont_gc;\n\n\t/* scan the keyring looking for dead keys */\n\trcu_read_lock();\n\tresult = assoc_array_iterate(&keyring->keys,\n\t\t\t\t     keyring_gc_check_iterator, &limit);\n\trcu_read_unlock();\n\tif (result == true)\n\t\tgoto do_gc;\n\ndont_gc:\n\tkleave(\" [no gc]\");\n\treturn;\n\ndo_gc:\n\tdown_write(&keyring->sem);\n\tassoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,\n\t\t       keyring_gc_select_iterator, &limit);\n\tup_write(&keyring->sem);\n\tkleave(\" [gc]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&key_serial_lock"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_restriction_gc",
          "args": [
            "key",
            "key_gc_dead_keytype"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_restriction_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "1560-1593",
          "snippet": "void keyring_restriction_gc(struct key *keyring, struct key_type *dead_type)\n{\n\tstruct key_restriction *keyres;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\t/*\n\t * keyring->restrict_link is only assigned at key allocation time\n\t * or with the key type locked, so the only values that could be\n\t * concurrently assigned to keyring->restrict_link are for key\n\t * types other than dead_type. Given this, it's ok to check\n\t * the key type before acquiring keyring->sem.\n\t */\n\tif (!dead_type || !keyring->restrict_link ||\n\t    keyring->restrict_link->keytype != dead_type) {\n\t\tkleave(\" [no restriction gc]\");\n\t\treturn;\n\t}\n\n\t/* Lock the keyring to ensure that a link is not in progress */\n\tdown_write(&keyring->sem);\n\n\tkeyres = keyring->restrict_link;\n\n\tkeyres->check = restrict_link_reject;\n\n\tkey_put(keyres->key);\n\tkeyres->key = NULL;\n\tkeyres->keytype = NULL;\n\n\tup_write(&keyring->sem);\n\n\tkleave(\" [restriction gc]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nvoid keyring_restriction_gc(struct key *keyring, struct key_type *dead_type)\n{\n\tstruct key_restriction *keyres;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\t/*\n\t * keyring->restrict_link is only assigned at key allocation time\n\t * or with the key type locked, so the only values that could be\n\t * concurrently assigned to keyring->restrict_link are for key\n\t * types other than dead_type. Given this, it's ok to check\n\t * the key type before acquiring keyring->sem.\n\t */\n\tif (!dead_type || !keyring->restrict_link ||\n\t    keyring->restrict_link->keytype != dead_type) {\n\t\tkleave(\" [no restriction gc]\");\n\t\treturn;\n\t}\n\n\t/* Lock the keyring to ensure that a link is not in progress */\n\tdown_write(&keyring->sem);\n\n\tkeyres = keyring->restrict_link;\n\n\tkeyres->check = restrict_link_reject;\n\n\tkey_put(keyres->key);\n\tkeyres->key = NULL;\n\tkeyres->keytype = NULL;\n\n\tup_write(&keyring->sem);\n\n\tkleave(\" [restriction gc]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&key_serial_lock"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&key->graveyard_link",
            "&graveyard"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&key_serial_lock"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&key->serial_node",
            "&key_serial_tree"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"unrefd key %d\"",
            "key->serial"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" [end %x]\"",
            "gc_state"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&key_gc_work"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&key_gc_flags",
            "KEY_GC_REAPING_KEYTYPE"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "KEY_GC_REAPING_KEYTYPE",
            "&key_gc_flags"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"dead wake\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gc_state & KEY_GC_REAPING_DEAD_3"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"dead short\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gc_state & (KEY_GC_REAPING_DEAD_1 |\n\t\t\t\t KEY_GC_REAPING_DEAD_2)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_gc_unused_keys",
          "args": [
            "&graveyard"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "key_gc_unused_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/gc.c",
          "lines": "127-164",
          "snippet": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tshort state = key->state;\n\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\t/* Throw away the key data if the key is instantiated */\n\t\tif (state == KEY_IS_POSITIVE && key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (state != KEY_IS_UNINSTANTIATED)\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/keyring-type.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/keyring-type.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tshort state = key->state;\n\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\t/* Throw away the key data if the key is instantiated */\n\t\tif (state == KEY_IS_POSITIVE && key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (state != KEY_IS_UNINSTANTIATED)\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"gc keys\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&graveyard"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"gc sync\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&graveyard"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gc_state & KEY_GC_REAPING_DEAD_2"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_schedule_gc",
          "args": [
            "new_timer"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "key_schedule_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/gc.c",
          "lines": "56-72",
          "snippet": "void key_schedule_gc(time64_t gc_at)\n{\n\tunsigned long expires;\n\ttime64_t now = ktime_get_real_seconds();\n\n\tkenter(\"%lld\", gc_at - now);\n\n\tif (gc_at <= now || test_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags)) {\n\t\tkdebug(\"IMMEDIATE\");\n\t\tschedule_work(&key_gc_work);\n\t} else if (gc_at < key_gc_next_run) {\n\t\tkdebug(\"DEFERRED\");\n\t\tkey_gc_next_run = gc_at;\n\t\texpires = jiffies + (gc_at - now) * HZ;\n\t\tmod_timer(&key_gc_timer, expires);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/keyring-type.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEY_GC_REAP_KEYTYPE\t1\t/* A keytype is being unregistered */"
          ],
          "globals_used": [
            "static time64_t key_gc_next_run = TIME64_MAX;",
            "static unsigned long key_gc_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/keyring-type.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define KEY_GC_REAP_KEYTYPE\t1\t/* A keytype is being unregistered */\n\nstatic time64_t key_gc_next_run = TIME64_MAX;\nstatic unsigned long key_gc_flags;\n\nvoid key_schedule_gc(time64_t gc_at)\n{\n\tunsigned long expires;\n\ttime64_t now = ktime_get_real_seconds();\n\n\tkenter(\"%lld\", gc_at - now);\n\n\tif (gc_at <= now || test_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags)) {\n\t\tkdebug(\"IMMEDIATE\");\n\t\tschedule_work(&key_gc_work);\n\t} else if (gc_at < key_gc_next_run) {\n\t\tkdebug(\"DEFERRED\");\n\t\tkey_gc_next_run = gc_at;\n\t\texpires = jiffies + (gc_at - now) * HZ;\n\t\tmod_timer(&key_gc_timer, expires);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"pass complete\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&key_serial_lock"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&key_serial_lock"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_is_contended",
          "args": [
            "&key_serial_lock"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gc_state & KEY_GC_REAPING_DEAD_3"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gc_state & KEY_GC_REAPING_DEAD_2"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gc_state & KEY_GC_REAPING_DEAD_2"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"will expire %x in %lld\"",
            "key_serial(key)",
            "key->expiry - limit"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KEY_FLAG_DEAD",
            "&key->flags"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_node_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.h",
          "lines": "100-108",
          "snippet": "static inline void ebitmap_node_set_bit(struct ebitmap_node *n,\n\t\t\t\t\tunsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tn->maps[index] |= (EBITMAP_BIT << ofs);\n}",
          "includes": [
            "#include <net/netlabel.h>"
          ],
          "macros_used": [
            "#define EBITMAP_BIT\t\t1ULL",
            "#define EBITMAP_UNIT_NUMS\t((EBITMAP_NODE_SIZE-sizeof(void *)-sizeof(u32))\\\n\t\t\t\t\t/ sizeof(unsigned long))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/netlabel.h>\n\n#define EBITMAP_BIT\t\t1ULL\n#define EBITMAP_UNIT_NUMS\t((EBITMAP_NODE_SIZE-sizeof(void *)-sizeof(u32))\\\n\t\t\t\t\t/ sizeof(unsigned long))\n\nstatic inline void ebitmap_node_set_bit(struct ebitmap_node *n,\n\t\t\t\t\tunsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tn->maps[index] |= (EBITMAP_BIT << ofs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gc_state & KEY_GC_REAPING_DEAD_1"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&key->usage"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "cursor"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "cursor",
            "structkey",
            "serial_node"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&key_serial_tree"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&key_serial_lock"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"new pass %x\"",
            "gc_state"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "KEY_GC_REAP_KEYTYPE",
            "&key_gc_flags"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "KEY_GC_KEY_EXPIRED",
            "&key_gc_flags"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"[%lx,%x]\"",
            "key_gc_flags",
            "gc_state"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/keyring-type.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define KEY_GC_FOUND_DEAD_KEY\t0x80\t/* - We found at least one dead key */\n#define KEY_GC_REAPING_DEAD_3\t0x40\t/* - We need to reap dead keys */\n#define KEY_GC_REAPING_DEAD_2\t0x20\t/* - We need to reap dead key links */\n#define KEY_GC_REAPING_DEAD_1\t0x10\t/* - We need to mark dead keys */\n#define KEY_GC_SET_TIMER\t0x04\t/* - We need to restart the timer */\n#define KEY_GC_REAPING_LINKS\t0x02\t/* - We need to reap links */\n#define KEY_GC_REAP_AGAIN\t0x01\t/* - Need another cycle */\n#define KEY_GC_REAPING_KEYTYPE\t2\t/* Cleared when keytype reaped */\n#define KEY_GC_REAP_KEYTYPE\t1\t/* A keytype is being unregistered */\n#define KEY_GC_KEY_EXPIRED\t0\t/* A key expired and needs unlinking */\n\nunsigned key_gc_delay = 5 * 60;\nstatic void key_garbage_collector(struct work_struct *work);\nstatic struct key_type *key_gc_dead_keytype;\nstatic unsigned long key_gc_flags;\nstruct key_type key_type_dead = {\n\t.name = \".dead\",\n};\n\nstatic void key_garbage_collector(struct work_struct *work)\n{\n\tstatic LIST_HEAD(graveyard);\n\tstatic u8 gc_state;\t\t/* Internal persistent state */\n#define KEY_GC_REAP_AGAIN\t0x01\t/* - Need another cycle */\n#define KEY_GC_REAPING_LINKS\t0x02\t/* - We need to reap links */\n#define KEY_GC_SET_TIMER\t0x04\t/* - We need to restart the timer */\n#define KEY_GC_REAPING_DEAD_1\t0x10\t/* - We need to mark dead keys */\n#define KEY_GC_REAPING_DEAD_2\t0x20\t/* - We need to reap dead key links */\n#define KEY_GC_REAPING_DEAD_3\t0x40\t/* - We need to reap dead keys */\n#define KEY_GC_FOUND_DEAD_KEY\t0x80\t/* - We found at least one dead key */\n\n\tstruct rb_node *cursor;\n\tstruct key *key;\n\ttime64_t new_timer, limit;\n\n\tkenter(\"[%lx,%x]\", key_gc_flags, gc_state);\n\n\tlimit = ktime_get_real_seconds();\n\tif (limit > key_gc_delay)\n\t\tlimit -= key_gc_delay;\n\telse\n\t\tlimit = key_gc_delay;\n\n\t/* Work out what we're going to be doing in this pass */\n\tgc_state &= KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2;\n\tgc_state <<= 1;\n\tif (test_and_clear_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_LINKS | KEY_GC_SET_TIMER;\n\n\tif (test_and_clear_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_DEAD_1;\n\tkdebug(\"new pass %x\", gc_state);\n\n\tnew_timer = TIME64_MAX;\n\n\t/* As only this function is permitted to remove things from the key\n\t * serial tree, if cursor is non-NULL then it will always point to a\n\t * valid node in the tree - even if lock got dropped.\n\t */\n\tspin_lock(&key_serial_lock);\n\tcursor = rb_first(&key_serial_tree);\n\ncontinue_scanning:\n\twhile (cursor) {\n\t\tkey = rb_entry(cursor, struct key, serial_node);\n\t\tcursor = rb_next(cursor);\n\n\t\tif (refcount_read(&key->usage) == 0)\n\t\t\tgoto found_unreferenced_key;\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_1)) {\n\t\t\tif (key->type == key_gc_dead_keytype) {\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\t\t\t\tset_bit(KEY_FLAG_DEAD, &key->flags);\n\t\t\t\tkey->perm = 0;\n\t\t\t\tgoto skip_dead_key;\n\t\t\t} else if (key->type == &key_type_keyring &&\n\t\t\t\t   key->restrict_link) {\n\t\t\t\tgoto found_restricted_keyring;\n\t\t\t}\n\t\t}\n\n\t\tif (gc_state & KEY_GC_SET_TIMER) {\n\t\t\tif (key->expiry > limit && key->expiry < new_timer) {\n\t\t\t\tkdebug(\"will expire %x in %lld\",\n\t\t\t\t       key_serial(key), key->expiry - limit);\n\t\t\t\tnew_timer = key->expiry;\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\n\t\tif ((gc_state & KEY_GC_REAPING_LINKS) ||\n\t\t    unlikely(gc_state & KEY_GC_REAPING_DEAD_2)) {\n\t\t\tif (key->type == &key_type_keyring)\n\t\t\t\tgoto found_keyring;\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgoto destroy_dead_key;\n\n\tskip_dead_key:\n\t\tif (spin_is_contended(&key_serial_lock) || need_resched())\n\t\t\tgoto contended;\n\t}\n\ncontended:\n\tspin_unlock(&key_serial_lock);\n\nmaybe_resched:\n\tif (cursor) {\n\t\tcond_resched();\n\t\tspin_lock(&key_serial_lock);\n\t\tgoto continue_scanning;\n\t}\n\n\t/* We've completed the pass.  Set the timer if we need to and queue a\n\t * new cycle if necessary.  We keep executing cycles until we find one\n\t * where we didn't reap any keys.\n\t */\n\tkdebug(\"pass complete\");\n\n\tif (gc_state & KEY_GC_SET_TIMER && new_timer != (time64_t)TIME64_MAX) {\n\t\tnew_timer += key_gc_delay;\n\t\tkey_schedule_gc(new_timer);\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2) ||\n\t    !list_empty(&graveyard)) {\n\t\t/* Make sure that all pending keyring payload destructions are\n\t\t * fulfilled and that people aren't now looking at dead or\n\t\t * dying keys that they don't have a reference upon or a link\n\t\t * to.\n\t\t */\n\t\tkdebug(\"gc sync\");\n\t\tsynchronize_rcu();\n\t}\n\n\tif (!list_empty(&graveyard)) {\n\t\tkdebug(\"gc keys\");\n\t\tkey_gc_unused_keys(&graveyard);\n\t}\n\n\tif (unlikely(gc_state & (KEY_GC_REAPING_DEAD_1 |\n\t\t\t\t KEY_GC_REAPING_DEAD_2))) {\n\t\tif (!(gc_state & KEY_GC_FOUND_DEAD_KEY)) {\n\t\t\t/* No remaining dead keys: short circuit the remaining\n\t\t\t * keytype reap cycles.\n\t\t\t */\n\t\t\tkdebug(\"dead short\");\n\t\t\tgc_state &= ~(KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2);\n\t\t\tgc_state |= KEY_GC_REAPING_DEAD_3;\n\t\t} else {\n\t\t\tgc_state |= KEY_GC_REAP_AGAIN;\n\t\t}\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3)) {\n\t\tkdebug(\"dead wake\");\n\t\tsmp_mb();\n\t\tclear_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\t\twake_up_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE);\n\t}\n\n\tif (gc_state & KEY_GC_REAP_AGAIN)\n\t\tschedule_work(&key_gc_work);\n\tkleave(\" [end %x]\", gc_state);\n\treturn;\n\n\t/* We found an unreferenced key - once we've removed it from the tree,\n\t * we can safely drop the lock.\n\t */\nfound_unreferenced_key:\n\tkdebug(\"unrefd key %d\", key->serial);\n\trb_erase(&key->serial_node, &key_serial_tree);\n\tspin_unlock(&key_serial_lock);\n\n\tlist_add_tail(&key->graveyard_link, &graveyard);\n\tgc_state |= KEY_GC_REAP_AGAIN;\n\tgoto maybe_resched;\n\n\t/* We found a restricted keyring and need to update the restriction if\n\t * it is associated with the dead key type.\n\t */\nfound_restricted_keyring:\n\tspin_unlock(&key_serial_lock);\n\tkeyring_restriction_gc(key, key_gc_dead_keytype);\n\tgoto maybe_resched;\n\n\t/* We found a keyring and we need to check the payload for links to\n\t * dead or expired keys.  We don't flag another reap immediately as we\n\t * have to wait for the old payload to be destroyed by RCU before we\n\t * can reap the keys to which it refers.\n\t */\nfound_keyring:\n\tspin_unlock(&key_serial_lock);\n\tkeyring_gc(key, limit);\n\tgoto maybe_resched;\n\n\t/* We found a dead key that is still referenced.  Reset its type and\n\t * destroy its payload with its semaphore held.\n\t */\ndestroy_dead_key:\n\tspin_unlock(&key_serial_lock);\n\tkdebug(\"destroy key %d\", key->serial);\n\tdown_write(&key->sem);\n\tkey->type = &key_type_dead;\n\tif (key_gc_dead_keytype->destroy)\n\t\tkey_gc_dead_keytype->destroy(key);\n\tmemset(&key->payload, KEY_DESTROY, sizeof(key->payload));\n\tup_write(&key->sem);\n\tgoto maybe_resched;\n}"
  },
  {
    "function_name": "key_gc_unused_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/gc.c",
    "lines": "127-164",
    "snippet": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tshort state = key->state;\n\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\t/* Throw away the key data if the key is instantiated */\n\t\tif (state == KEY_IS_POSITIVE && key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (state != KEY_IS_UNINSTANTIATED)\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/keyring-type.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "key_jar",
            "key"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memzero_explicit",
          "args": [
            "key",
            "sizeof(*key)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key->description"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_user_put",
          "args": [
            "key->user"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "key_user_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "123-131",
          "snippet": "void key_user_put(struct key_user *user)\n{\n\tif (refcount_dec_and_lock(&user->usage, &key_user_lock)) {\n\t\trb_erase(&user->node, &key_user_tree);\n\t\tspin_unlock(&key_user_lock);\n\n\t\tkfree(user);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rb_root\tkey_user_tree;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct rb_root\tkey_user_tree;\n\nvoid key_user_put(struct key_user *user)\n{\n\tif (refcount_dec_and_lock(&user->usage, &key_user_lock)) {\n\t\trb_erase(&user->node, &key_user_tree);\n\t\tspin_unlock(&key_user_lock);\n\n\t\tkfree(user);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&key->user->nikeys"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&key->user->nkeys"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&key->user->lock"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&key->user->lock"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_IN_QUOTA",
            "&key->flags"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_key_free",
          "args": [
            "key"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "security_key_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "1664-1667",
          "snippet": "void security_key_free(struct key *key)\n{\n\tcall_void_hook(key_free, key);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nvoid security_key_free(struct key *key)\n{\n\tcall_void_hook(key_free, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key->type->destroy",
          "args": [
            "key"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_check",
          "args": [
            "key"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "key_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/internal.h",
          "lines": "307-311",
          "snippet": "static inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/refcount.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/task_work.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/refcount.h>\n#include <linux/keyctl.h>\n#include <linux/task_work.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/wait_bit.h>\n#include <linux/sched.h>\n\nstatic inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"- %u\"",
            "key->serial"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&key->graveyard_link"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "keys->next",
            "structkey",
            "graveyard_link"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "keys"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/keyring-type.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tshort state = key->state;\n\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\t/* Throw away the key data if the key is instantiated */\n\t\tif (state == KEY_IS_POSITIVE && key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (state != KEY_IS_UNINSTANTIATED)\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}"
  },
  {
    "function_name": "key_gc_keytype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/gc.c",
    "lines": "104-122",
    "snippet": "void key_gc_keytype(struct key_type *ktype)\n{\n\tkenter(\"%s\", ktype->name);\n\n\tkey_gc_dead_keytype = ktype;\n\tset_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\tsmp_mb();\n\tset_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags);\n\n\tkdebug(\"schedule\");\n\tschedule_work(&key_gc_work);\n\n\tkdebug(\"sleep\");\n\twait_on_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\tkey_gc_dead_keytype = NULL;\n\tkleave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/keyring-type.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define KEY_GC_REAPING_KEYTYPE\t2\t/* Cleared when keytype reaped */",
      "#define KEY_GC_REAP_KEYTYPE\t1\t/* A keytype is being unregistered */"
    ],
    "globals_used": [
      "static struct key_type *key_gc_dead_keytype;",
      "static unsigned long key_gc_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\"\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&key_gc_flags",
            "KEY_GC_REAPING_KEYTYPE",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"sleep\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&key_gc_work"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"schedule\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KEY_GC_REAP_KEYTYPE",
            "&key_gc_flags"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_node_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.h",
          "lines": "100-108",
          "snippet": "static inline void ebitmap_node_set_bit(struct ebitmap_node *n,\n\t\t\t\t\tunsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tn->maps[index] |= (EBITMAP_BIT << ofs);\n}",
          "includes": [
            "#include <net/netlabel.h>"
          ],
          "macros_used": [
            "#define EBITMAP_BIT\t\t1ULL",
            "#define EBITMAP_UNIT_NUMS\t((EBITMAP_NODE_SIZE-sizeof(void *)-sizeof(u32))\\\n\t\t\t\t\t/ sizeof(unsigned long))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/netlabel.h>\n\n#define EBITMAP_BIT\t\t1ULL\n#define EBITMAP_UNIT_NUMS\t((EBITMAP_NODE_SIZE-sizeof(void *)-sizeof(u32))\\\n\t\t\t\t\t/ sizeof(unsigned long))\n\nstatic inline void ebitmap_node_set_bit(struct ebitmap_node *n,\n\t\t\t\t\tunsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tn->maps[index] |= (EBITMAP_BIT << ofs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"%s\"",
            "ktype->name"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/keyring-type.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define KEY_GC_REAPING_KEYTYPE\t2\t/* Cleared when keytype reaped */\n#define KEY_GC_REAP_KEYTYPE\t1\t/* A keytype is being unregistered */\n\nstatic struct key_type *key_gc_dead_keytype;\nstatic unsigned long key_gc_flags;\n\nvoid key_gc_keytype(struct key_type *ktype)\n{\n\tkenter(\"%s\", ktype->name);\n\n\tkey_gc_dead_keytype = ktype;\n\tset_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\tsmp_mb();\n\tset_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags);\n\n\tkdebug(\"schedule\");\n\tschedule_work(&key_gc_work);\n\n\tkdebug(\"sleep\");\n\twait_on_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\tkey_gc_dead_keytype = NULL;\n\tkleave(\"\");\n}"
  },
  {
    "function_name": "key_gc_timer_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/gc.c",
    "lines": "87-92",
    "snippet": "static void key_gc_timer_func(struct timer_list *unused)\n{\n\tkenter(\"\");\n\tkey_gc_next_run = TIME64_MAX;\n\tkey_schedule_gc_links();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/keyring-type.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void key_gc_timer_func(struct timer_list *);",
      "static DEFINE_TIMER(key_gc_timer, key_gc_timer_func);",
      "static time64_t key_gc_next_run = TIME64_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_schedule_gc_links",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "key_schedule_gc_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/gc.c",
          "lines": "77-81",
          "snippet": "void key_schedule_gc_links(void)\n{\n\tset_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags);\n\tschedule_work(&key_gc_work);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/keyring-type.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEY_GC_KEY_EXPIRED\t0\t/* A key expired and needs unlinking */"
          ],
          "globals_used": [
            "static unsigned long key_gc_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/keyring-type.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define KEY_GC_KEY_EXPIRED\t0\t/* A key expired and needs unlinking */\n\nstatic unsigned long key_gc_flags;\n\nvoid key_schedule_gc_links(void)\n{\n\tset_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags);\n\tschedule_work(&key_gc_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/keyring-type.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void key_gc_timer_func(struct timer_list *);\nstatic DEFINE_TIMER(key_gc_timer, key_gc_timer_func);\nstatic time64_t key_gc_next_run = TIME64_MAX;\n\nstatic void key_gc_timer_func(struct timer_list *unused)\n{\n\tkenter(\"\");\n\tkey_gc_next_run = TIME64_MAX;\n\tkey_schedule_gc_links();\n}"
  },
  {
    "function_name": "key_schedule_gc_links",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/gc.c",
    "lines": "77-81",
    "snippet": "void key_schedule_gc_links(void)\n{\n\tset_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags);\n\tschedule_work(&key_gc_work);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/keyring-type.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define KEY_GC_KEY_EXPIRED\t0\t/* A key expired and needs unlinking */"
    ],
    "globals_used": [
      "static unsigned long key_gc_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&key_gc_work"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KEY_GC_KEY_EXPIRED",
            "&key_gc_flags"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_node_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.h",
          "lines": "100-108",
          "snippet": "static inline void ebitmap_node_set_bit(struct ebitmap_node *n,\n\t\t\t\t\tunsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tn->maps[index] |= (EBITMAP_BIT << ofs);\n}",
          "includes": [
            "#include <net/netlabel.h>"
          ],
          "macros_used": [
            "#define EBITMAP_BIT\t\t1ULL",
            "#define EBITMAP_UNIT_NUMS\t((EBITMAP_NODE_SIZE-sizeof(void *)-sizeof(u32))\\\n\t\t\t\t\t/ sizeof(unsigned long))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/netlabel.h>\n\n#define EBITMAP_BIT\t\t1ULL\n#define EBITMAP_UNIT_NUMS\t((EBITMAP_NODE_SIZE-sizeof(void *)-sizeof(u32))\\\n\t\t\t\t\t/ sizeof(unsigned long))\n\nstatic inline void ebitmap_node_set_bit(struct ebitmap_node *n,\n\t\t\t\t\tunsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tn->maps[index] |= (EBITMAP_BIT << ofs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/keyring-type.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define KEY_GC_KEY_EXPIRED\t0\t/* A key expired and needs unlinking */\n\nstatic unsigned long key_gc_flags;\n\nvoid key_schedule_gc_links(void)\n{\n\tset_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags);\n\tschedule_work(&key_gc_work);\n}"
  },
  {
    "function_name": "key_schedule_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/gc.c",
    "lines": "56-72",
    "snippet": "void key_schedule_gc(time64_t gc_at)\n{\n\tunsigned long expires;\n\ttime64_t now = ktime_get_real_seconds();\n\n\tkenter(\"%lld\", gc_at - now);\n\n\tif (gc_at <= now || test_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags)) {\n\t\tkdebug(\"IMMEDIATE\");\n\t\tschedule_work(&key_gc_work);\n\t} else if (gc_at < key_gc_next_run) {\n\t\tkdebug(\"DEFERRED\");\n\t\tkey_gc_next_run = gc_at;\n\t\texpires = jiffies + (gc_at - now) * HZ;\n\t\tmod_timer(&key_gc_timer, expires);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/keyring-type.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define KEY_GC_REAP_KEYTYPE\t1\t/* A keytype is being unregistered */"
    ],
    "globals_used": [
      "static time64_t key_gc_next_run = TIME64_MAX;",
      "static unsigned long key_gc_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&key_gc_timer",
            "expires"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"DEFERRED\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&key_gc_work"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"IMMEDIATE\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_GC_REAP_KEYTYPE",
            "&key_gc_flags"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"%lld\"",
            "gc_at - now"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/keyring-type.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define KEY_GC_REAP_KEYTYPE\t1\t/* A keytype is being unregistered */\n\nstatic time64_t key_gc_next_run = TIME64_MAX;\nstatic unsigned long key_gc_flags;\n\nvoid key_schedule_gc(time64_t gc_at)\n{\n\tunsigned long expires;\n\ttime64_t now = ktime_get_real_seconds();\n\n\tkenter(\"%lld\", gc_at - now);\n\n\tif (gc_at <= now || test_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags)) {\n\t\tkdebug(\"IMMEDIATE\");\n\t\tschedule_work(&key_gc_work);\n\t} else if (gc_at < key_gc_next_run) {\n\t\tkdebug(\"DEFERRED\");\n\t\tkey_gc_next_run = gc_at;\n\t\texpires = jiffies + (gc_at - now) * HZ;\n\t\tmod_timer(&key_gc_timer, expires);\n\t}\n}"
  }
]