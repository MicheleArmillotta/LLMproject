[
  {
    "function_name": "avc_audit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/avc.h",
    "lines": "130-144",
    "snippet": "static inline int avc_audit(u32 ssid, u32 tsid,\n\t\t\t    u16 tclass, u32 requested,\n\t\t\t    struct av_decision *avd,\n\t\t\t    int result,\n\t\t\t    struct common_audit_data *a,\n\t\t\t    int flags)\n{\n\tu32 audited, denied;\n\taudited = avc_audit_required(requested, avd, result, 0, &denied);\n\tif (likely(!audited))\n\t\treturn 0;\n\treturn slow_avc_audit(ssid, tsid, tclass,\n\t\t\t      requested, audited, denied, result,\n\t\t\t      a, flags);\n}",
    "includes": [
      "#include \"security.h\"",
      "#include \"av_permissions.h\"",
      "#include \"flask.h\"",
      "#include <linux/in6.h>",
      "#include <linux/lsm_audit.h>",
      "#include <linux/audit.h>",
      "#include <linux/init.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slow_avc_audit",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "requested",
            "audited",
            "denied",
            "result",
            "a",
            "flags"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "slow_avc_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "737-773",
          "snippet": "noinline int slow_avc_audit(u32 ssid, u32 tsid, u16 tclass,\n\t\tu32 requested, u32 audited, u32 denied, int result,\n\t\tstruct common_audit_data *a,\n\t\tunsigned flags)\n{\n\tstruct common_audit_data stack_data;\n\tstruct selinux_audit_data sad;\n\n\tif (!a) {\n\t\ta = &stack_data;\n\t\ta->type = LSM_AUDIT_DATA_NONE;\n\t}\n\n\t/*\n\t * When in a RCU walk do the audit on the RCU retry.  This is because\n\t * the collection of the dname in an inode audit message is not RCU\n\t * safe.  Note this may drop some audits when the situation changes\n\t * during retry. However this is logically just as if the operation\n\t * happened a little later.\n\t */\n\tif ((a->type == LSM_AUDIT_DATA_INODE) &&\n\t    (flags & MAY_NOT_BLOCK))\n\t\treturn -ECHILD;\n\n\tsad.tclass = tclass;\n\tsad.requested = requested;\n\tsad.ssid = ssid;\n\tsad.tsid = tsid;\n\tsad.audited = audited;\n\tsad.denied = denied;\n\tsad.result = result;\n\n\ta->selinux_audit_data = &sad;\n\n\tcommon_lsm_audit(a, avc_audit_pre_callback, avc_audit_post_callback);\n\treturn 0;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nnoinline int slow_avc_audit(u32 ssid, u32 tsid, u16 tclass,\n\t\tu32 requested, u32 audited, u32 denied, int result,\n\t\tstruct common_audit_data *a,\n\t\tunsigned flags)\n{\n\tstruct common_audit_data stack_data;\n\tstruct selinux_audit_data sad;\n\n\tif (!a) {\n\t\ta = &stack_data;\n\t\ta->type = LSM_AUDIT_DATA_NONE;\n\t}\n\n\t/*\n\t * When in a RCU walk do the audit on the RCU retry.  This is because\n\t * the collection of the dname in an inode audit message is not RCU\n\t * safe.  Note this may drop some audits when the situation changes\n\t * during retry. However this is logically just as if the operation\n\t * happened a little later.\n\t */\n\tif ((a->type == LSM_AUDIT_DATA_INODE) &&\n\t    (flags & MAY_NOT_BLOCK))\n\t\treturn -ECHILD;\n\n\tsad.tclass = tclass;\n\tsad.requested = requested;\n\tsad.ssid = ssid;\n\tsad.tsid = tsid;\n\tsad.audited = audited;\n\tsad.denied = denied;\n\tsad.result = result;\n\n\ta->selinux_audit_data = &sad;\n\n\tcommon_lsm_audit(a, avc_audit_pre_callback, avc_audit_post_callback);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!audited"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_audit_required",
          "args": [
            "requested",
            "avd",
            "result",
            "0",
            "&denied"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "avc_audit_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/avc.h",
          "lines": "69-103",
          "snippet": "static inline u32 avc_audit_required(u32 requested,\n\t\t\t      struct av_decision *avd,\n\t\t\t      int result,\n\t\t\t      u32 auditdeny,\n\t\t\t      u32 *deniedp)\n{\n\tu32 denied, audited;\n\tdenied = requested & ~avd->allowed;\n\tif (unlikely(denied)) {\n\t\taudited = denied & avd->auditdeny;\n\t\t/*\n\t\t * auditdeny is TRICKY!  Setting a bit in\n\t\t * this field means that ANY denials should NOT be audited if\n\t\t * the policy contains an explicit dontaudit rule for that\n\t\t * permission.  Take notice that this is unrelated to the\n\t\t * actual permissions that were denied.  As an example lets\n\t\t * assume:\n\t\t *\n\t\t * denied == READ\n\t\t * avd.auditdeny & ACCESS == 0 (not set means explicit rule)\n\t\t * auditdeny & ACCESS == 1\n\t\t *\n\t\t * We will NOT audit the denial even though the denied\n\t\t * permission was READ and the auditdeny checks were for\n\t\t * ACCESS\n\t\t */\n\t\tif (auditdeny && !(auditdeny & avd->auditdeny))\n\t\t\taudited = 0;\n\t} else if (result)\n\t\taudited = denied = requested;\n\telse\n\t\taudited = requested & avd->auditallow;\n\t*deniedp = denied;\n\treturn audited;\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"av_permissions.h\"",
            "#include \"flask.h\"",
            "#include <linux/in6.h>",
            "#include <linux/lsm_audit.h>",
            "#include <linux/audit.h>",
            "#include <linux/init.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"av_permissions.h\"\n#include \"flask.h\"\n#include <linux/in6.h>\n#include <linux/lsm_audit.h>\n#include <linux/audit.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/kdev_t.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n\nstatic inline u32 avc_audit_required(u32 requested,\n\t\t\t      struct av_decision *avd,\n\t\t\t      int result,\n\t\t\t      u32 auditdeny,\n\t\t\t      u32 *deniedp)\n{\n\tu32 denied, audited;\n\tdenied = requested & ~avd->allowed;\n\tif (unlikely(denied)) {\n\t\taudited = denied & avd->auditdeny;\n\t\t/*\n\t\t * auditdeny is TRICKY!  Setting a bit in\n\t\t * this field means that ANY denials should NOT be audited if\n\t\t * the policy contains an explicit dontaudit rule for that\n\t\t * permission.  Take notice that this is unrelated to the\n\t\t * actual permissions that were denied.  As an example lets\n\t\t * assume:\n\t\t *\n\t\t * denied == READ\n\t\t * avd.auditdeny & ACCESS == 0 (not set means explicit rule)\n\t\t * auditdeny & ACCESS == 1\n\t\t *\n\t\t * We will NOT audit the denial even though the denied\n\t\t * permission was READ and the auditdeny checks were for\n\t\t * ACCESS\n\t\t */\n\t\tif (auditdeny && !(auditdeny & avd->auditdeny))\n\t\t\taudited = 0;\n\t} else if (result)\n\t\taudited = denied = requested;\n\telse\n\t\taudited = requested & avd->auditallow;\n\t*deniedp = denied;\n\treturn audited;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"security.h\"\n#include \"av_permissions.h\"\n#include \"flask.h\"\n#include <linux/in6.h>\n#include <linux/lsm_audit.h>\n#include <linux/audit.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/kdev_t.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n\nstatic inline int avc_audit(u32 ssid, u32 tsid,\n\t\t\t    u16 tclass, u32 requested,\n\t\t\t    struct av_decision *avd,\n\t\t\t    int result,\n\t\t\t    struct common_audit_data *a,\n\t\t\t    int flags)\n{\n\tu32 audited, denied;\n\taudited = avc_audit_required(requested, avd, result, 0, &denied);\n\tif (likely(!audited))\n\t\treturn 0;\n\treturn slow_avc_audit(ssid, tsid, tclass,\n\t\t\t      requested, audited, denied, result,\n\t\t\t      a, flags);\n}"
  },
  {
    "function_name": "avc_audit_required",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/avc.h",
    "lines": "69-103",
    "snippet": "static inline u32 avc_audit_required(u32 requested,\n\t\t\t      struct av_decision *avd,\n\t\t\t      int result,\n\t\t\t      u32 auditdeny,\n\t\t\t      u32 *deniedp)\n{\n\tu32 denied, audited;\n\tdenied = requested & ~avd->allowed;\n\tif (unlikely(denied)) {\n\t\taudited = denied & avd->auditdeny;\n\t\t/*\n\t\t * auditdeny is TRICKY!  Setting a bit in\n\t\t * this field means that ANY denials should NOT be audited if\n\t\t * the policy contains an explicit dontaudit rule for that\n\t\t * permission.  Take notice that this is unrelated to the\n\t\t * actual permissions that were denied.  As an example lets\n\t\t * assume:\n\t\t *\n\t\t * denied == READ\n\t\t * avd.auditdeny & ACCESS == 0 (not set means explicit rule)\n\t\t * auditdeny & ACCESS == 1\n\t\t *\n\t\t * We will NOT audit the denial even though the denied\n\t\t * permission was READ and the auditdeny checks were for\n\t\t * ACCESS\n\t\t */\n\t\tif (auditdeny && !(auditdeny & avd->auditdeny))\n\t\t\taudited = 0;\n\t} else if (result)\n\t\taudited = denied = requested;\n\telse\n\t\taudited = requested & avd->auditallow;\n\t*deniedp = denied;\n\treturn audited;\n}",
    "includes": [
      "#include \"security.h\"",
      "#include \"av_permissions.h\"",
      "#include \"flask.h\"",
      "#include <linux/in6.h>",
      "#include <linux/lsm_audit.h>",
      "#include <linux/audit.h>",
      "#include <linux/init.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "denied"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"security.h\"\n#include \"av_permissions.h\"\n#include \"flask.h\"\n#include <linux/in6.h>\n#include <linux/lsm_audit.h>\n#include <linux/audit.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/kdev_t.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n\nstatic inline u32 avc_audit_required(u32 requested,\n\t\t\t      struct av_decision *avd,\n\t\t\t      int result,\n\t\t\t      u32 auditdeny,\n\t\t\t      u32 *deniedp)\n{\n\tu32 denied, audited;\n\tdenied = requested & ~avd->allowed;\n\tif (unlikely(denied)) {\n\t\taudited = denied & avd->auditdeny;\n\t\t/*\n\t\t * auditdeny is TRICKY!  Setting a bit in\n\t\t * this field means that ANY denials should NOT be audited if\n\t\t * the policy contains an explicit dontaudit rule for that\n\t\t * permission.  Take notice that this is unrelated to the\n\t\t * actual permissions that were denied.  As an example lets\n\t\t * assume:\n\t\t *\n\t\t * denied == READ\n\t\t * avd.auditdeny & ACCESS == 0 (not set means explicit rule)\n\t\t * auditdeny & ACCESS == 1\n\t\t *\n\t\t * We will NOT audit the denial even though the denied\n\t\t * permission was READ and the auditdeny checks were for\n\t\t * ACCESS\n\t\t */\n\t\tif (auditdeny && !(auditdeny & avd->auditdeny))\n\t\t\taudited = 0;\n\t} else if (result)\n\t\taudited = denied = requested;\n\telse\n\t\taudited = requested & avd->auditallow;\n\t*deniedp = denied;\n\treturn audited;\n}"
  }
]