[
  {
    "function_name": "tomoyo_address_matches_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/group.c",
    "lines": "182-201",
    "snippet": "bool tomoyo_address_matches_group(const bool is_ipv6, const __be32 *address,\n\t\t\t\t  const struct tomoyo_group *group)\n{\n\tstruct tomoyo_address_group *member;\n\tbool matched = false;\n\tconst u8 size = is_ipv6 ? 16 : 4;\n\n\tlist_for_each_entry_rcu(member, &group->member_list, head.list) {\n\t\tif (member->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (member->address.is_ipv6 != is_ipv6)\n\t\t\tcontinue;\n\t\tif (memcmp(&member->address.ip[0], address, size) > 0 ||\n\t\t    memcmp(address, &member->address.ip[1], size) > 0)\n\t\t\tcontinue;\n\t\tmatched = true;\n\t\tbreak;\n\t}\n\treturn matched;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "address",
            "&member->address.ip[1]",
            "size"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&member->address.ip[0]",
            "address",
            "size"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "member",
            "&group->member_list",
            "head.list"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_address_matches_group(const bool is_ipv6, const __be32 *address,\n\t\t\t\t  const struct tomoyo_group *group)\n{\n\tstruct tomoyo_address_group *member;\n\tbool matched = false;\n\tconst u8 size = is_ipv6 ? 16 : 4;\n\n\tlist_for_each_entry_rcu(member, &group->member_list, head.list) {\n\t\tif (member->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (member->address.is_ipv6 != is_ipv6)\n\t\t\tcontinue;\n\t\tif (memcmp(&member->address.ip[0], address, size) > 0 ||\n\t\t    memcmp(address, &member->address.ip[1], size) > 0)\n\t\t\tcontinue;\n\t\tmatched = true;\n\t\tbreak;\n\t}\n\treturn matched;\n}"
  },
  {
    "function_name": "tomoyo_number_matches_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/group.c",
    "lines": "153-169",
    "snippet": "bool tomoyo_number_matches_group(const unsigned long min,\n\t\t\t\t const unsigned long max,\n\t\t\t\t const struct tomoyo_group *group)\n{\n\tstruct tomoyo_number_group *member;\n\tbool matched = false;\n\tlist_for_each_entry_rcu(member, &group->member_list, head.list) {\n\t\tif (member->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (min > member->number.values[1] ||\n\t\t    max < member->number.values[0])\n\t\t\tcontinue;\n\t\tmatched = true;\n\t\tbreak;\n\t}\n\treturn matched;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "member",
            "&group->member_list",
            "head.list"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_number_matches_group(const unsigned long min,\n\t\t\t\t const unsigned long max,\n\t\t\t\t const struct tomoyo_group *group)\n{\n\tstruct tomoyo_number_group *member;\n\tbool matched = false;\n\tlist_for_each_entry_rcu(member, &group->member_list, head.list) {\n\t\tif (member->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (min > member->number.values[1] ||\n\t\t    max < member->number.values[0])\n\t\t\tcontinue;\n\t\tmatched = true;\n\t\tbreak;\n\t}\n\treturn matched;\n}"
  },
  {
    "function_name": "tomoyo_path_matches_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/group.c",
    "lines": "127-140",
    "snippet": "const struct tomoyo_path_info *\ntomoyo_path_matches_group(const struct tomoyo_path_info *pathname,\n\t\t\t  const struct tomoyo_group *group)\n{\n\tstruct tomoyo_path_group *member;\n\tlist_for_each_entry_rcu(member, &group->member_list, head.list) {\n\t\tif (member->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (!tomoyo_path_matches_pattern(pathname, member->member_name))\n\t\t\tcontinue;\n\t\treturn member->member_name;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_matches_pattern",
          "args": [
            "pathname",
            "member->member_name"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_matches_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "902-921",
          "snippet": "bool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,\n\t\t\t\t const struct tomoyo_path_info *pattern)\n{\n\tconst char *f = filename->name;\n\tconst char *p = pattern->name;\n\tconst int len = pattern->const_len;\n\n\t/* If @pattern doesn't contain pattern, I can use strcmp(). */\n\tif (!pattern->is_patterned)\n\t\treturn !tomoyo_pathcmp(filename, pattern);\n\t/* Don't compare directory and non-directory. */\n\tif (filename->is_dir != pattern->is_dir)\n\t\treturn false;\n\t/* Compare the initial length without patterns. */\n\tif (strncmp(f, p, len))\n\t\treturn false;\n\tf += len;\n\tp += len;\n\treturn tomoyo_path_matches_pattern2(f, p);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,\n\t\t\t\t const struct tomoyo_path_info *pattern)\n{\n\tconst char *f = filename->name;\n\tconst char *p = pattern->name;\n\tconst int len = pattern->const_len;\n\n\t/* If @pattern doesn't contain pattern, I can use strcmp(). */\n\tif (!pattern->is_patterned)\n\t\treturn !tomoyo_pathcmp(filename, pattern);\n\t/* Don't compare directory and non-directory. */\n\tif (filename->is_dir != pattern->is_dir)\n\t\treturn false;\n\t/* Compare the initial length without patterns. */\n\tif (strncmp(f, p, len))\n\t\treturn false;\n\tf += len;\n\tp += len;\n\treturn tomoyo_path_matches_pattern2(f, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "member",
            "&group->member_list",
            "head.list"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nconst struct tomoyo_path_info *\ntomoyo_path_matches_group(const struct tomoyo_path_info *pathname,\n\t\t\t  const struct tomoyo_group *group)\n{\n\tstruct tomoyo_path_group *member;\n\tlist_for_each_entry_rcu(member, &group->member_list, head.list) {\n\t\tif (member->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (!tomoyo_path_matches_pattern(pathname, member->member_name))\n\t\t\tcontinue;\n\t\treturn member->member_name;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "tomoyo_write_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/group.c",
    "lines": "74-114",
    "snippet": "int tomoyo_write_group(struct tomoyo_acl_param *param, const u8 type)\n{\n\tstruct tomoyo_group *group = tomoyo_get_group(param, type);\n\tint error = -EINVAL;\n\tif (!group)\n\t\treturn -ENOMEM;\n\tparam->list = &group->member_list;\n\tif (type == TOMOYO_PATH_GROUP) {\n\t\tstruct tomoyo_path_group e = { };\n\t\te.member_name = tomoyo_get_name(tomoyo_read_token(param));\n\t\tif (!e.member_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t  tomoyo_same_path_group);\n\t\ttomoyo_put_name(e.member_name);\n\t} else if (type == TOMOYO_NUMBER_GROUP) {\n\t\tstruct tomoyo_number_group e = { };\n\t\tif (param->data[0] == '@' ||\n\t\t    !tomoyo_parse_number_union(param, &e.number))\n\t\t\tgoto out;\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t  tomoyo_same_number_group);\n\t\t/*\n\t\t * tomoyo_put_number_union() is not needed because\n\t\t * param->data[0] != '@'.\n\t\t */\n\t} else {\n\t\tstruct tomoyo_address_group e = { };\n\n\t\tif (param->data[0] == '@' ||\n\t\t    !tomoyo_parse_ipaddr_union(param, &e.address))\n\t\t\tgoto out;\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t     tomoyo_same_address_group);\n\t}\nout:\n\ttomoyo_put_group(group);\n\treturn error;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_group",
          "args": [
            "group"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1193-1197",
          "snippet": "static inline void tomoyo_put_group(struct tomoyo_group *group)\n{\n\tif (group)\n\t\tatomic_dec(&group->head.users);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_group(struct tomoyo_group *group)\n{\n\tif (group)\n\t\tatomic_dec(&group->head.users);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_update_policy",
          "args": [
            "&e.head",
            "sizeof(e)",
            "param",
            "tomoyo_same_address_group"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_update_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "31-62",
          "snippet": "int tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_head\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_head\n\t\t\t\t\t\t  *))\n{\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_head *entry;\n\tstruct list_head *list = param->list;\n\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -ENOMEM;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tentry->is_deleted = param->is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !param->is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn error;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_head\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_head\n\t\t\t\t\t\t  *))\n{\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_head *entry;\n\tstruct list_head *list = param->list;\n\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -ENOMEM;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tentry->is_deleted = param->is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !param->is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_parse_ipaddr_union",
          "args": [
            "param",
            "&e.address"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_parse_ipaddr_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "50-78",
          "snippet": "bool tomoyo_parse_ipaddr_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_ipaddr_union *ptr)\n{\n\tu8 * const min = ptr->ip[0].in6_u.u6_addr8;\n\tu8 * const max = ptr->ip[1].in6_u.u6_addr8;\n\tchar *address = tomoyo_read_token(param);\n\tconst char *end;\n\n\tif (!strchr(address, ':') &&\n\t    in4_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = false;\n\t\tif (!*end)\n\t\t\tptr->ip[1].s6_addr32[0] = ptr->ip[0].s6_addr32[0];\n\t\telse if (*end++ != '-' ||\n\t\t\t in4_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tif (in6_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = true;\n\t\tif (!*end)\n\t\t\tmemmove(max, min, sizeof(u16) * 8);\n\t\telse if (*end++ != '-' ||\n\t\t\t in6_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nbool tomoyo_parse_ipaddr_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_ipaddr_union *ptr)\n{\n\tu8 * const min = ptr->ip[0].in6_u.u6_addr8;\n\tu8 * const max = ptr->ip[1].in6_u.u6_addr8;\n\tchar *address = tomoyo_read_token(param);\n\tconst char *end;\n\n\tif (!strchr(address, ':') &&\n\t    in4_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = false;\n\t\tif (!*end)\n\t\t\tptr->ip[1].s6_addr32[0] = ptr->ip[0].s6_addr32[0];\n\t\telse if (*end++ != '-' ||\n\t\t\t in4_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tif (in6_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = true;\n\t\tif (!*end)\n\t\t\tmemmove(max, min, sizeof(u16) * 8);\n\t\telse if (*end++ != '-' ||\n\t\t\t in6_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_parse_number_union",
          "args": [
            "param",
            "&e.number"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_parse_number_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "263-294",
          "snippet": "bool tomoyo_parse_number_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_number_union *ptr)\n{\n\tchar *data;\n\tu8 type;\n\tunsigned long v;\n\tmemset(ptr, 0, sizeof(*ptr));\n\tif (param->data[0] == '@') {\n\t\tparam->data++;\n\t\tptr->group = tomoyo_get_group(param, TOMOYO_NUMBER_GROUP);\n\t\treturn ptr->group != NULL;\n\t}\n\tdata = tomoyo_read_token(param);\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID)\n\t\treturn false;\n\tptr->values[0] = v;\n\tptr->value_type[0] = type;\n\tif (!*data) {\n\t\tptr->values[1] = v;\n\t\tptr->value_type[1] = type;\n\t\treturn true;\n\t}\n\tif (*data++ != '-')\n\t\treturn false;\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID || *data || ptr->values[0] > v)\n\t\treturn false;\n\tptr->values[1] = v;\n\tptr->value_type[1] = type;\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_parse_number_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_number_union *ptr)\n{\n\tchar *data;\n\tu8 type;\n\tunsigned long v;\n\tmemset(ptr, 0, sizeof(*ptr));\n\tif (param->data[0] == '@') {\n\t\tparam->data++;\n\t\tptr->group = tomoyo_get_group(param, TOMOYO_NUMBER_GROUP);\n\t\treturn ptr->group != NULL;\n\t}\n\tdata = tomoyo_read_token(param);\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID)\n\t\treturn false;\n\tptr->values[0] = v;\n\tptr->value_type[0] = type;\n\tif (!*data) {\n\t\tptr->values[1] = v;\n\t\tptr->value_type[1] = type;\n\t\treturn true;\n\t}\n\tif (*data++ != '-')\n\t\treturn false;\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID || *data || ptr->values[0] > v)\n\t\treturn false;\n\tptr->values[1] = v;\n\tptr->value_type[1] = type;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "e.member_name"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_get_name",
          "args": [
            "tomoyo_read_token(param)"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "148-183",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_token",
          "args": [
            "param"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "131-141",
          "snippet": "char *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nchar *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_get_group",
          "args": [
            "param",
            "type"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "93-131",
          "snippet": "struct tomoyo_group *tomoyo_get_group(struct tomoyo_acl_param *param,\n\t\t\t\t      const u8 idx)\n{\n\tstruct tomoyo_group e = { };\n\tstruct tomoyo_group *group = NULL;\n\tstruct list_head *list;\n\tconst char *group_name = tomoyo_read_token(param);\n\tbool found = false;\n\tif (!tomoyo_correct_word(group_name) || idx >= TOMOYO_MAX_GROUP)\n\t\treturn NULL;\n\te.group_name = tomoyo_get_name(group_name);\n\tif (!e.group_name)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist = &param->ns->group_list[idx];\n\tlist_for_each_entry(group, list, head.list) {\n\t\tif (e.group_name != group->group_name ||\n\t\t    atomic_read(&group->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&group->head.users);\n\t\tfound = true;\n\t\tbreak;\n\t}\n\tif (!found) {\n\t\tstruct tomoyo_group *entry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->member_list);\n\t\t\tatomic_set(&entry->head.users, 1);\n\t\t\tlist_add_tail_rcu(&entry->head.list, list);\n\t\t\tgroup = entry;\n\t\t\tfound = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.group_name);\n\treturn found ? group : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct tomoyo_group *tomoyo_get_group(struct tomoyo_acl_param *param,\n\t\t\t\t      const u8 idx)\n{\n\tstruct tomoyo_group e = { };\n\tstruct tomoyo_group *group = NULL;\n\tstruct list_head *list;\n\tconst char *group_name = tomoyo_read_token(param);\n\tbool found = false;\n\tif (!tomoyo_correct_word(group_name) || idx >= TOMOYO_MAX_GROUP)\n\t\treturn NULL;\n\te.group_name = tomoyo_get_name(group_name);\n\tif (!e.group_name)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist = &param->ns->group_list[idx];\n\tlist_for_each_entry(group, list, head.list) {\n\t\tif (e.group_name != group->group_name ||\n\t\t    atomic_read(&group->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&group->head.users);\n\t\tfound = true;\n\t\tbreak;\n\t}\n\tif (!found) {\n\t\tstruct tomoyo_group *entry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->member_list);\n\t\t\tatomic_set(&entry->head.users, 1);\n\t\t\tlist_add_tail_rcu(&entry->head.list, list);\n\t\t\tgroup = entry;\n\t\t\tfound = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.group_name);\n\treturn found ? group : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nint tomoyo_write_group(struct tomoyo_acl_param *param, const u8 type)\n{\n\tstruct tomoyo_group *group = tomoyo_get_group(param, type);\n\tint error = -EINVAL;\n\tif (!group)\n\t\treturn -ENOMEM;\n\tparam->list = &group->member_list;\n\tif (type == TOMOYO_PATH_GROUP) {\n\t\tstruct tomoyo_path_group e = { };\n\t\te.member_name = tomoyo_get_name(tomoyo_read_token(param));\n\t\tif (!e.member_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t  tomoyo_same_path_group);\n\t\ttomoyo_put_name(e.member_name);\n\t} else if (type == TOMOYO_NUMBER_GROUP) {\n\t\tstruct tomoyo_number_group e = { };\n\t\tif (param->data[0] == '@' ||\n\t\t    !tomoyo_parse_number_union(param, &e.number))\n\t\t\tgoto out;\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t  tomoyo_same_number_group);\n\t\t/*\n\t\t * tomoyo_put_number_union() is not needed because\n\t\t * param->data[0] != '@'.\n\t\t */\n\t} else {\n\t\tstruct tomoyo_address_group e = { };\n\n\t\tif (param->data[0] == '@' ||\n\t\t    !tomoyo_parse_ipaddr_union(param, &e.address))\n\t\t\tgoto out;\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t     tomoyo_same_address_group);\n\t}\nout:\n\ttomoyo_put_group(group);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_same_address_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/group.c",
    "lines": "55-64",
    "snippet": "static bool tomoyo_same_address_group(const struct tomoyo_acl_head *a,\n\t\t\t\t      const struct tomoyo_acl_head *b)\n{\n\tconst struct tomoyo_address_group *p1 = container_of(a, typeof(*p1),\n\t\t\t\t\t\t\t     head);\n\tconst struct tomoyo_address_group *p2 = container_of(b, typeof(*p2),\n\t\t\t\t\t\t\t     head);\n\n\treturn tomoyo_same_ipaddr_union(&p1->address, &p2->address);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_same_ipaddr_union",
          "args": [
            "&p1->address",
            "&p2->address"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_same_ipaddr_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1260-1265",
          "snippet": "static inline bool tomoyo_same_ipaddr_union\n(const struct tomoyo_ipaddr_union *a, const struct tomoyo_ipaddr_union *b)\n{\n\treturn !memcmp(a->ip, b->ip, sizeof(a->ip)) && a->group == b->group &&\n\t\ta->is_ipv6 == b->is_ipv6;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline bool tomoyo_same_ipaddr_union\n(const struct tomoyo_ipaddr_union *a, const struct tomoyo_ipaddr_union *b)\n{\n\treturn !memcmp(a->ip, b->ip, sizeof(a->ip)) && a->group == b->group &&\n\t\ta->is_ipv6 == b->is_ipv6;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "typeof(*p2)",
            "head"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p2"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "typeof(*p1)",
            "head"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p1"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nstatic bool tomoyo_same_address_group(const struct tomoyo_acl_head *a,\n\t\t\t\t      const struct tomoyo_acl_head *b)\n{\n\tconst struct tomoyo_address_group *p1 = container_of(a, typeof(*p1),\n\t\t\t\t\t\t\t     head);\n\tconst struct tomoyo_address_group *p2 = container_of(b, typeof(*p2),\n\t\t\t\t\t\t\t     head);\n\n\treturn tomoyo_same_ipaddr_union(&p1->address, &p2->address);\n}"
  },
  {
    "function_name": "tomoyo_same_number_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/group.c",
    "lines": "36-45",
    "snippet": "static bool tomoyo_same_number_group(const struct tomoyo_acl_head *a,\n\t\t\t\t     const struct tomoyo_acl_head *b)\n{\n\treturn !memcmp(&container_of(a, struct tomoyo_number_group, head)\n\t\t       ->number,\n\t\t       &container_of(b, struct tomoyo_number_group, head)\n\t\t       ->number,\n\t\t       sizeof(container_of(a, struct tomoyo_number_group, head)\n\t\t\t      ->number));\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&container_of(a, struct tomoyo_number_group, head)\n\t\t       ->number",
            "&container_of(b, struct tomoyo_number_group, head)\n\t\t       ->number",
            "sizeof(container_of(a, struct tomoyo_number_group, head)\n\t\t\t      ->number"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "structtomoyo_number_group",
            "head"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "structtomoyo_number_group",
            "head"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nstatic bool tomoyo_same_number_group(const struct tomoyo_acl_head *a,\n\t\t\t\t     const struct tomoyo_acl_head *b)\n{\n\treturn !memcmp(&container_of(a, struct tomoyo_number_group, head)\n\t\t       ->number,\n\t\t       &container_of(b, struct tomoyo_number_group, head)\n\t\t       ->number,\n\t\t       sizeof(container_of(a, struct tomoyo_number_group, head)\n\t\t\t      ->number));\n}"
  },
  {
    "function_name": "tomoyo_same_path_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/group.c",
    "lines": "21-26",
    "snippet": "static bool tomoyo_same_path_group(const struct tomoyo_acl_head *a,\n\t\t\t\t   const struct tomoyo_acl_head *b)\n{\n\treturn container_of(a, struct tomoyo_path_group, head)->member_name ==\n\t\tcontainer_of(b, struct tomoyo_path_group, head)->member_name;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "structtomoyo_path_group",
            "head"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "structtomoyo_path_group",
            "head"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nstatic bool tomoyo_same_path_group(const struct tomoyo_acl_head *a,\n\t\t\t\t   const struct tomoyo_acl_head *b)\n{\n\treturn container_of(a, struct tomoyo_path_group, head)->member_name ==\n\t\tcontainer_of(b, struct tomoyo_path_group, head)->member_name;\n}"
  }
]