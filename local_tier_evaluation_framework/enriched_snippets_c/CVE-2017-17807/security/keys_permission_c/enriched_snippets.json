[
  {
    "function_name": "key_validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/permission.c",
    "lines": "89-109",
    "snippet": "int key_validate(const struct key *key)\n{\n\tunsigned long flags = READ_ONCE(key->flags);\n\ttime64_t expiry = READ_ONCE(key->expiry);\n\n\tif (flags & (1 << KEY_FLAG_INVALIDATED))\n\t\treturn -ENOKEY;\n\n\t/* check it's still accessible */\n\tif (flags & ((1 << KEY_FLAG_REVOKED) |\n\t\t     (1 << KEY_FLAG_DEAD)))\n\t\treturn -EKEYREVOKED;\n\n\t/* check it hasn't expired */\n\tif (expiry) {\n\t\tif (ktime_get_real_seconds() >= expiry)\n\t\t\treturn -EKEYEXPIRED;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "key->expiry"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "key->flags"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/security.h>\n#include <linux/module.h>\n\nint key_validate(const struct key *key)\n{\n\tunsigned long flags = READ_ONCE(key->flags);\n\ttime64_t expiry = READ_ONCE(key->expiry);\n\n\tif (flags & (1 << KEY_FLAG_INVALIDATED))\n\t\treturn -ENOKEY;\n\n\t/* check it's still accessible */\n\tif (flags & ((1 << KEY_FLAG_REVOKED) |\n\t\t     (1 << KEY_FLAG_DEAD)))\n\t\treturn -EKEYREVOKED;\n\n\t/* check it hasn't expired */\n\tif (expiry) {\n\t\tif (ktime_get_real_seconds() >= expiry)\n\t\t\treturn -EKEYEXPIRED;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "key_task_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/permission.c",
    "lines": "30-78",
    "snippet": "int key_task_permission(const key_ref_t key_ref, const struct cred *cred,\n\t\t\tunsigned perm)\n{\n\tstruct key *key;\n\tkey_perm_t kperm;\n\tint ret;\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* use the second 8-bits of permissions for keys the caller owns */\n\tif (uid_eq(key->uid, cred->fsuid)) {\n\t\tkperm = key->perm >> 16;\n\t\tgoto use_these_perms;\n\t}\n\n\t/* use the third 8-bits of permissions for keys the caller has a group\n\t * membership in common with */\n\tif (gid_valid(key->gid) && key->perm & KEY_GRP_ALL) {\n\t\tif (gid_eq(key->gid, cred->fsgid)) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\n\t\tret = groups_search(cred->group_info, key->gid);\n\t\tif (ret) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\t}\n\n\t/* otherwise use the least-significant 8-bits */\n\tkperm = key->perm;\n\nuse_these_perms:\n\n\t/* use the top 8-bits of permissions for keys the caller possesses\n\t * - possessor permissions are additive with other permissions\n\t */\n\tif (is_key_possessed(key_ref))\n\t\tkperm |= key->perm >> 24;\n\n\tkperm = kperm & perm & KEY_NEED_ALL;\n\n\tif (kperm != perm)\n\t\treturn -EACCES;\n\n\t/* let LSM be the final arbiter */\n\treturn security_key_permission(key_ref, cred, perm);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/security.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_key_permission",
          "args": [
            "key_ref",
            "cred",
            "perm"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "security_key_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "1669-1673",
          "snippet": "int security_key_permission(key_ref_t key_ref,\n\t\t\t    const struct cred *cred, unsigned perm)\n{\n\treturn call_int_hook(key_permission, 0, key_ref, cred, perm);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nint security_key_permission(key_ref_t key_ref,\n\t\t\t    const struct cred *cred, unsigned perm)\n{\n\treturn call_int_hook(key_permission, 0, key_ref, cred, perm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_key_possessed",
          "args": [
            "key_ref"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "groups_search",
          "args": [
            "cred->group_info",
            "key->gid"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "key->gid",
            "cred->fsgid"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "key->gid"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "key->uid",
            "cred->fsuid"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/security.h>\n#include <linux/module.h>\n\nint key_task_permission(const key_ref_t key_ref, const struct cred *cred,\n\t\t\tunsigned perm)\n{\n\tstruct key *key;\n\tkey_perm_t kperm;\n\tint ret;\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* use the second 8-bits of permissions for keys the caller owns */\n\tif (uid_eq(key->uid, cred->fsuid)) {\n\t\tkperm = key->perm >> 16;\n\t\tgoto use_these_perms;\n\t}\n\n\t/* use the third 8-bits of permissions for keys the caller has a group\n\t * membership in common with */\n\tif (gid_valid(key->gid) && key->perm & KEY_GRP_ALL) {\n\t\tif (gid_eq(key->gid, cred->fsgid)) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\n\t\tret = groups_search(cred->group_info, key->gid);\n\t\tif (ret) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\t}\n\n\t/* otherwise use the least-significant 8-bits */\n\tkperm = key->perm;\n\nuse_these_perms:\n\n\t/* use the top 8-bits of permissions for keys the caller possesses\n\t * - possessor permissions are additive with other permissions\n\t */\n\tif (is_key_possessed(key_ref))\n\t\tkperm |= key->perm >> 24;\n\n\tkperm = kperm & perm & KEY_NEED_ALL;\n\n\tif (kperm != perm)\n\t\treturn -EACCES;\n\n\t/* let LSM be the final arbiter */\n\treturn security_key_permission(key_ref, cred, perm);\n}"
  }
]