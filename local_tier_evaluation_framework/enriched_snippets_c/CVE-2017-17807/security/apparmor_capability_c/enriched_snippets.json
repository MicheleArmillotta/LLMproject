[
  {
    "function_name": "aa_capable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/capability.c",
    "lines": "151-162",
    "snippet": "int aa_capable(struct aa_label *label, int cap, int audit)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_CAP, OP_CAPABLE);\n\n\tsa.u.cap = cap;\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_capable(profile, cap, audit, &sa));\n\n\treturn error;\n}",
    "includes": [
      "#include \"capability_names.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/security.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn_for_each_confined",
          "args": [
            "label",
            "profile",
            "profile_capable(profile, cap, audit, &sa)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_capable",
          "args": [
            "profile",
            "cap",
            "audit",
            "&sa"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "profile_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/capability.c",
          "lines": "118-139",
          "snippet": "static int profile_capable(struct aa_profile *profile, int cap, int audit,\n\t\t\t   struct common_audit_data *sa)\n{\n\tint error;\n\n\tif (cap_raised(profile->caps.allow, cap) &&\n\t    !cap_raised(profile->caps.denied, cap))\n\t\terror = 0;\n\telse\n\t\terror = -EPERM;\n\n\tif (audit == SECURITY_CAP_NOAUDIT) {\n\t\tif (!COMPLAIN_MODE(profile))\n\t\t\treturn error;\n\t\t/* audit the cap request in complain mode but note that it\n\t\t * should be optional.\n\t\t */\n\t\taad(sa)->info = \"optional: no audit\";\n\t}\n\n\treturn audit_caps(sa, profile, cap, error);\n}",
          "includes": [
            "#include \"capability_names.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/security.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability_names.h\"\n#include \"include/audit.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/security.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int profile_capable(struct aa_profile *profile, int cap, int audit,\n\t\t\t   struct common_audit_data *sa)\n{\n\tint error;\n\n\tif (cap_raised(profile->caps.allow, cap) &&\n\t    !cap_raised(profile->caps.denied, cap))\n\t\terror = 0;\n\telse\n\t\terror = -EPERM;\n\n\tif (audit == SECURITY_CAP_NOAUDIT) {\n\t\tif (!COMPLAIN_MODE(profile))\n\t\t\treturn error;\n\t\t/* audit the cap request in complain mode but note that it\n\t\t * should be optional.\n\t\t */\n\t\taad(sa)->info = \"optional: no audit\";\n\t}\n\n\treturn audit_caps(sa, profile, cap, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_AUDIT_DATA",
          "args": [
            "sa",
            "LSM_AUDIT_DATA_CAP",
            "OP_CAPABLE"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability_names.h\"\n#include \"include/audit.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/security.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nint aa_capable(struct aa_label *label, int cap, int audit)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_CAP, OP_CAPABLE);\n\n\tsa.u.cap = cap;\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_capable(profile, cap, audit, &sa));\n\n\treturn error;\n}"
  },
  {
    "function_name": "profile_capable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/capability.c",
    "lines": "118-139",
    "snippet": "static int profile_capable(struct aa_profile *profile, int cap, int audit,\n\t\t\t   struct common_audit_data *sa)\n{\n\tint error;\n\n\tif (cap_raised(profile->caps.allow, cap) &&\n\t    !cap_raised(profile->caps.denied, cap))\n\t\terror = 0;\n\telse\n\t\terror = -EPERM;\n\n\tif (audit == SECURITY_CAP_NOAUDIT) {\n\t\tif (!COMPLAIN_MODE(profile))\n\t\t\treturn error;\n\t\t/* audit the cap request in complain mode but note that it\n\t\t * should be optional.\n\t\t */\n\t\taad(sa)->info = \"optional: no audit\";\n\t}\n\n\treturn audit_caps(sa, profile, cap, error);\n}",
    "includes": [
      "#include \"capability_names.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/security.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_caps",
          "args": [
            "sa",
            "profile",
            "cap",
            "error"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "audit_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/capability.c",
          "lines": "68-107",
          "snippet": "static int audit_caps(struct common_audit_data *sa, struct aa_profile *profile,\n\t\t      int cap, int error)\n{\n\tstruct audit_cache *ent;\n\tint type = AUDIT_APPARMOR_AUTO;\n\n\taad(sa)->error = error;\n\n\tif (likely(!error)) {\n\t\t/* test if auditing is being forced */\n\t\tif (likely((AUDIT_MODE(profile) != AUDIT_ALL) &&\n\t\t\t   !cap_raised(profile->caps.audit, cap)))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else if (KILL_MODE(profile) ||\n\t\t   cap_raised(profile->caps.kill, cap)) {\n\t\ttype = AUDIT_APPARMOR_KILL;\n\t} else if (cap_raised(profile->caps.quiet, cap) &&\n\t\t   AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t   AUDIT_MODE(profile) != AUDIT_ALL) {\n\t\t/* quiet auditing */\n\t\treturn error;\n\t}\n\n\t/* Do simple duplicate message elimination */\n\tent = &get_cpu_var(audit_cache);\n\tif (profile == ent->profile && cap_raised(ent->caps, cap)) {\n\t\tput_cpu_var(audit_cache);\n\t\tif (COMPLAIN_MODE(profile))\n\t\t\treturn complain_error(error);\n\t\treturn error;\n\t} else {\n\t\taa_put_profile(ent->profile);\n\t\tent->profile = aa_get_profile(profile);\n\t\tcap_raise(ent->caps, cap);\n\t}\n\tput_cpu_var(audit_cache);\n\n\treturn aa_audit(type, profile, sa, audit_cb);\n}",
          "includes": [
            "#include \"capability_names.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/security.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct audit_cache, audit_cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"capability_names.h\"\n#include \"include/audit.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/security.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct audit_cache, audit_cache);\n\nstatic int audit_caps(struct common_audit_data *sa, struct aa_profile *profile,\n\t\t      int cap, int error)\n{\n\tstruct audit_cache *ent;\n\tint type = AUDIT_APPARMOR_AUTO;\n\n\taad(sa)->error = error;\n\n\tif (likely(!error)) {\n\t\t/* test if auditing is being forced */\n\t\tif (likely((AUDIT_MODE(profile) != AUDIT_ALL) &&\n\t\t\t   !cap_raised(profile->caps.audit, cap)))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else if (KILL_MODE(profile) ||\n\t\t   cap_raised(profile->caps.kill, cap)) {\n\t\ttype = AUDIT_APPARMOR_KILL;\n\t} else if (cap_raised(profile->caps.quiet, cap) &&\n\t\t   AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t   AUDIT_MODE(profile) != AUDIT_ALL) {\n\t\t/* quiet auditing */\n\t\treturn error;\n\t}\n\n\t/* Do simple duplicate message elimination */\n\tent = &get_cpu_var(audit_cache);\n\tif (profile == ent->profile && cap_raised(ent->caps, cap)) {\n\t\tput_cpu_var(audit_cache);\n\t\tif (COMPLAIN_MODE(profile))\n\t\t\treturn complain_error(error);\n\t\treturn error;\n\t} else {\n\t\taa_put_profile(ent->profile);\n\t\tent->profile = aa_get_profile(profile);\n\t\tcap_raise(ent->caps, cap);\n\t}\n\tput_cpu_var(audit_cache);\n\n\treturn aa_audit(type, profile, sa, audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPLAIN_MODE",
          "args": [
            "profile"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raised",
          "args": [
            "profile->caps.denied",
            "cap"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raised",
          "args": [
            "profile->caps.allow",
            "cap"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability_names.h\"\n#include \"include/audit.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/security.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int profile_capable(struct aa_profile *profile, int cap, int audit,\n\t\t\t   struct common_audit_data *sa)\n{\n\tint error;\n\n\tif (cap_raised(profile->caps.allow, cap) &&\n\t    !cap_raised(profile->caps.denied, cap))\n\t\terror = 0;\n\telse\n\t\terror = -EPERM;\n\n\tif (audit == SECURITY_CAP_NOAUDIT) {\n\t\tif (!COMPLAIN_MODE(profile))\n\t\t\treturn error;\n\t\t/* audit the cap request in complain mode but note that it\n\t\t * should be optional.\n\t\t */\n\t\taad(sa)->info = \"optional: no audit\";\n\t}\n\n\treturn audit_caps(sa, profile, cap, error);\n}"
  },
  {
    "function_name": "audit_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/capability.c",
    "lines": "68-107",
    "snippet": "static int audit_caps(struct common_audit_data *sa, struct aa_profile *profile,\n\t\t      int cap, int error)\n{\n\tstruct audit_cache *ent;\n\tint type = AUDIT_APPARMOR_AUTO;\n\n\taad(sa)->error = error;\n\n\tif (likely(!error)) {\n\t\t/* test if auditing is being forced */\n\t\tif (likely((AUDIT_MODE(profile) != AUDIT_ALL) &&\n\t\t\t   !cap_raised(profile->caps.audit, cap)))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else if (KILL_MODE(profile) ||\n\t\t   cap_raised(profile->caps.kill, cap)) {\n\t\ttype = AUDIT_APPARMOR_KILL;\n\t} else if (cap_raised(profile->caps.quiet, cap) &&\n\t\t   AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t   AUDIT_MODE(profile) != AUDIT_ALL) {\n\t\t/* quiet auditing */\n\t\treturn error;\n\t}\n\n\t/* Do simple duplicate message elimination */\n\tent = &get_cpu_var(audit_cache);\n\tif (profile == ent->profile && cap_raised(ent->caps, cap)) {\n\t\tput_cpu_var(audit_cache);\n\t\tif (COMPLAIN_MODE(profile))\n\t\t\treturn complain_error(error);\n\t\treturn error;\n\t} else {\n\t\taa_put_profile(ent->profile);\n\t\tent->profile = aa_get_profile(profile);\n\t\tcap_raise(ent->caps, cap);\n\t}\n\tput_cpu_var(audit_cache);\n\n\treturn aa_audit(type, profile, sa, audit_cb);\n}",
    "includes": [
      "#include \"capability_names.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/security.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct audit_cache, audit_cache);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_audit",
          "args": [
            "type",
            "profile",
            "sa",
            "audit_cb"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/audit.c",
          "lines": "129-165",
          "snippet": "int aa_audit(int type, struct aa_profile *profile, struct common_audit_data *sa,\n\t     void (*cb) (struct audit_buffer *, void *))\n{\n\tAA_BUG(!profile);\n\n\tif (type == AUDIT_APPARMOR_AUTO) {\n\t\tif (likely(!aad(sa)->error)) {\n\t\t\tif (AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\t\treturn 0;\n\t\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\t} else if (COMPLAIN_MODE(profile))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\t}\n\tif (AUDIT_MODE(profile) == AUDIT_QUIET ||\n\t    (type == AUDIT_APPARMOR_DENIED &&\n\t     AUDIT_MODE(profile) == AUDIT_QUIET))\n\t\treturn aad(sa)->error;\n\n\tif (KILL_MODE(profile) && type == AUDIT_APPARMOR_DENIED)\n\t\ttype = AUDIT_APPARMOR_KILL;\n\n\taad(sa)->label = &profile->label;\n\n\taa_audit_msg(type, sa, cb);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_KILL)\n\t\t(void)send_sig_info(SIGKILL, NULL,\n\t\t\tsa->type == LSM_AUDIT_DATA_TASK && sa->u.tsk ?\n\t\t\t\t    sa->u.tsk : current);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_ALLOWED)\n\t\treturn complain_error(aad(sa)->error);\n\n\treturn aad(sa)->error;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/socket.h>\n#include <linux/audit.h>\n\nint aa_audit(int type, struct aa_profile *profile, struct common_audit_data *sa,\n\t     void (*cb) (struct audit_buffer *, void *))\n{\n\tAA_BUG(!profile);\n\n\tif (type == AUDIT_APPARMOR_AUTO) {\n\t\tif (likely(!aad(sa)->error)) {\n\t\t\tif (AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\t\treturn 0;\n\t\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\t} else if (COMPLAIN_MODE(profile))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\t}\n\tif (AUDIT_MODE(profile) == AUDIT_QUIET ||\n\t    (type == AUDIT_APPARMOR_DENIED &&\n\t     AUDIT_MODE(profile) == AUDIT_QUIET))\n\t\treturn aad(sa)->error;\n\n\tif (KILL_MODE(profile) && type == AUDIT_APPARMOR_DENIED)\n\t\ttype = AUDIT_APPARMOR_KILL;\n\n\taad(sa)->label = &profile->label;\n\n\taa_audit_msg(type, sa, cb);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_KILL)\n\t\t(void)send_sig_info(SIGKILL, NULL,\n\t\t\tsa->type == LSM_AUDIT_DATA_TASK && sa->u.tsk ?\n\t\t\t\t    sa->u.tsk : current);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_ALLOWED)\n\t\treturn complain_error(aad(sa)->error);\n\n\treturn aad(sa)->error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "audit_cache"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "ent->caps",
            "cap"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_profile",
          "args": [
            "profile"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_profile_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "260-271",
          "snippet": "static inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_put_profile",
          "args": [
            "ent->profile"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "277-281",
          "snippet": "static inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complain_error",
          "args": [
            "error"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "complain_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/audit.h",
          "lines": "176-181",
          "snippet": "static inline int complain_error(int error)\n{\n\tif (error == -EPERM || error == -EACCES)\n\t\treturn 0;\n\treturn error;\n}",
          "includes": [
            "#include \"label.h\"",
            "#include \"file.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/lsm_audit.h>",
            "#include <linux/fs.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"label.h\"\n#include \"file.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/lsm_audit.h>\n#include <linux/fs.h>\n#include <linux/audit.h>\n\nstatic inline int complain_error(int error)\n{\n\tif (error == -EPERM || error == -EACCES)\n\t\treturn 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COMPLAIN_MODE",
          "args": [
            "profile"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "audit_cache"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raised",
          "args": [
            "ent->caps",
            "cap"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "audit_cache"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_MODE",
          "args": [
            "profile"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "AUDIT_MODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "283-289",
          "snippet": "static inline int AUDIT_MODE(struct aa_profile *profile)\n{\n\tif (aa_g_audit != AUDIT_NORMAL)\n\t\treturn aa_g_audit;\n\n\treturn profile->audit;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline int AUDIT_MODE(struct aa_profile *profile)\n{\n\tif (aa_g_audit != AUDIT_NORMAL)\n\t\treturn aa_g_audit;\n\n\treturn profile->audit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_raised",
          "args": [
            "profile->caps.quiet",
            "cap"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raised",
          "args": [
            "profile->caps.kill",
            "cap"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KILL_MODE",
          "args": [
            "profile"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "(AUDIT_MODE(profile) != AUDIT_ALL) &&\n\t\t\t   !cap_raised(profile->caps.audit, cap)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raised",
          "args": [
            "profile->caps.audit",
            "cap"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!error"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability_names.h\"\n#include \"include/audit.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/security.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic DEFINE_PER_CPU(struct audit_cache, audit_cache);\n\nstatic int audit_caps(struct common_audit_data *sa, struct aa_profile *profile,\n\t\t      int cap, int error)\n{\n\tstruct audit_cache *ent;\n\tint type = AUDIT_APPARMOR_AUTO;\n\n\taad(sa)->error = error;\n\n\tif (likely(!error)) {\n\t\t/* test if auditing is being forced */\n\t\tif (likely((AUDIT_MODE(profile) != AUDIT_ALL) &&\n\t\t\t   !cap_raised(profile->caps.audit, cap)))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else if (KILL_MODE(profile) ||\n\t\t   cap_raised(profile->caps.kill, cap)) {\n\t\ttype = AUDIT_APPARMOR_KILL;\n\t} else if (cap_raised(profile->caps.quiet, cap) &&\n\t\t   AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t   AUDIT_MODE(profile) != AUDIT_ALL) {\n\t\t/* quiet auditing */\n\t\treturn error;\n\t}\n\n\t/* Do simple duplicate message elimination */\n\tent = &get_cpu_var(audit_cache);\n\tif (profile == ent->profile && cap_raised(ent->caps, cap)) {\n\t\tput_cpu_var(audit_cache);\n\t\tif (COMPLAIN_MODE(profile))\n\t\t\treturn complain_error(error);\n\t\treturn error;\n\t} else {\n\t\taa_put_profile(ent->profile);\n\t\tent->profile = aa_get_profile(profile);\n\t\tcap_raise(ent->caps, cap);\n\t}\n\tput_cpu_var(audit_cache);\n\n\treturn aa_audit(type, profile, sa, audit_cb);\n}"
  },
  {
    "function_name": "audit_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/capability.c",
    "lines": "48-54",
    "snippet": "static void audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\n\taudit_log_format(ab, \" capname=\");\n\taudit_log_untrustedstring(ab, capability_names[sa->u.cap]);\n}",
    "includes": [
      "#include \"capability_names.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/security.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "capability_names[sa->u.cap]"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" capname=\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability_names.h\"\n#include \"include/audit.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/security.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic void audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\n\taudit_log_format(ab, \" capname=\");\n\taudit_log_untrustedstring(ab, capability_names[sa->u.cap]);\n}"
  }
]