[
  {
    "function_name": "tomoyo_realpath_nofollow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
    "lines": "320-330",
    "snippet": "char *tomoyo_realpath_nofollow(const char *pathname)\n{\n\tstruct path path;\n\n\tif (pathname && kern_path(pathname, 0, &path) == 0) {\n\t\tchar *buf = tomoyo_realpath_from_path(&path);\n\t\tpath_put(&path);\n\t\treturn buf;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_realpath_from_path",
          "args": [
            "&path"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_realpath_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "251-311",
          "snippet": "char *tomoyo_realpath_from_path(const struct path *path)\n{\n\tchar *buf = NULL;\n\tchar *name = NULL;\n\tunsigned int buf_len = PAGE_SIZE / 2;\n\tstruct dentry *dentry = path->dentry;\n\tstruct super_block *sb;\n\tif (!dentry)\n\t\treturn NULL;\n\tsb = dentry->d_sb;\n\twhile (1) {\n\t\tchar *pos;\n\t\tstruct inode *inode;\n\t\tbuf_len <<= 1;\n\t\tkfree(buf);\n\t\tbuf = kmalloc(buf_len, GFP_NOFS);\n\t\tif (!buf)\n\t\t\tbreak;\n\t\t/* To make sure that pos is '\\0' terminated. */\n\t\tbuf[buf_len - 1] = '\\0';\n\t\t/* Get better name for socket. */\n\t\tif (sb->s_magic == SOCKFS_MAGIC) {\n\t\t\tpos = tomoyo_get_socket_name(path, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\t/* For \"pipe:[\\$]\". */\n\t\tif (dentry->d_op && dentry->d_op->d_dname) {\n\t\t\tpos = dentry->d_op->d_dname(dentry, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\tinode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Get local name for filesystems without rename() operation\n\t\t * or dentry without vfsmount.\n\t\t */\n\t\tif (!path->mnt ||\n\t\t    (!inode->i_op->rename))\n\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t    buf_len - 1);\n\t\t/* Get absolute name for the rest. */\n\t\telse {\n\t\t\tpos = tomoyo_get_absolute_path(path, buf, buf_len - 1);\n\t\t\t/*\n\t\t\t * Fall back to local name if absolute name is not\n\t\t\t * available.\n\t\t\t */\n\t\t\tif (pos == ERR_PTR(-EINVAL))\n\t\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t\t    buf_len - 1);\n\t\t}\nencode:\n\t\tif (IS_ERR(pos))\n\t\t\tcontinue;\n\t\tname = tomoyo_encode(pos);\n\t\tbreak;\n\t}\n\tkfree(buf);\n\tif (!name)\n\t\ttomoyo_warn_oom(__func__);\n\treturn name;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nchar *tomoyo_realpath_from_path(const struct path *path)\n{\n\tchar *buf = NULL;\n\tchar *name = NULL;\n\tunsigned int buf_len = PAGE_SIZE / 2;\n\tstruct dentry *dentry = path->dentry;\n\tstruct super_block *sb;\n\tif (!dentry)\n\t\treturn NULL;\n\tsb = dentry->d_sb;\n\twhile (1) {\n\t\tchar *pos;\n\t\tstruct inode *inode;\n\t\tbuf_len <<= 1;\n\t\tkfree(buf);\n\t\tbuf = kmalloc(buf_len, GFP_NOFS);\n\t\tif (!buf)\n\t\t\tbreak;\n\t\t/* To make sure that pos is '\\0' terminated. */\n\t\tbuf[buf_len - 1] = '\\0';\n\t\t/* Get better name for socket. */\n\t\tif (sb->s_magic == SOCKFS_MAGIC) {\n\t\t\tpos = tomoyo_get_socket_name(path, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\t/* For \"pipe:[\\$]\". */\n\t\tif (dentry->d_op && dentry->d_op->d_dname) {\n\t\t\tpos = dentry->d_op->d_dname(dentry, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\tinode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Get local name for filesystems without rename() operation\n\t\t * or dentry without vfsmount.\n\t\t */\n\t\tif (!path->mnt ||\n\t\t    (!inode->i_op->rename))\n\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t    buf_len - 1);\n\t\t/* Get absolute name for the rest. */\n\t\telse {\n\t\t\tpos = tomoyo_get_absolute_path(path, buf, buf_len - 1);\n\t\t\t/*\n\t\t\t * Fall back to local name if absolute name is not\n\t\t\t * available.\n\t\t\t */\n\t\t\tif (pos == ERR_PTR(-EINVAL))\n\t\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t\t    buf_len - 1);\n\t\t}\nencode:\n\t\tif (IS_ERR(pos))\n\t\t\tcontinue;\n\t\tname = tomoyo_encode(pos);\n\t\tbreak;\n\t}\n\tkfree(buf);\n\tif (!name)\n\t\ttomoyo_warn_oom(__func__);\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "pathname",
            "0",
            "&path"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nchar *tomoyo_realpath_nofollow(const char *pathname)\n{\n\tstruct path path;\n\n\tif (pathname && kern_path(pathname, 0, &path) == 0) {\n\t\tchar *buf = tomoyo_realpath_from_path(&path);\n\t\tpath_put(&path);\n\t\treturn buf;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "tomoyo_realpath_from_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
    "lines": "251-311",
    "snippet": "char *tomoyo_realpath_from_path(const struct path *path)\n{\n\tchar *buf = NULL;\n\tchar *name = NULL;\n\tunsigned int buf_len = PAGE_SIZE / 2;\n\tstruct dentry *dentry = path->dentry;\n\tstruct super_block *sb;\n\tif (!dentry)\n\t\treturn NULL;\n\tsb = dentry->d_sb;\n\twhile (1) {\n\t\tchar *pos;\n\t\tstruct inode *inode;\n\t\tbuf_len <<= 1;\n\t\tkfree(buf);\n\t\tbuf = kmalloc(buf_len, GFP_NOFS);\n\t\tif (!buf)\n\t\t\tbreak;\n\t\t/* To make sure that pos is '\\0' terminated. */\n\t\tbuf[buf_len - 1] = '\\0';\n\t\t/* Get better name for socket. */\n\t\tif (sb->s_magic == SOCKFS_MAGIC) {\n\t\t\tpos = tomoyo_get_socket_name(path, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\t/* For \"pipe:[\\$]\". */\n\t\tif (dentry->d_op && dentry->d_op->d_dname) {\n\t\t\tpos = dentry->d_op->d_dname(dentry, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\tinode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Get local name for filesystems without rename() operation\n\t\t * or dentry without vfsmount.\n\t\t */\n\t\tif (!path->mnt ||\n\t\t    (!inode->i_op->rename))\n\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t    buf_len - 1);\n\t\t/* Get absolute name for the rest. */\n\t\telse {\n\t\t\tpos = tomoyo_get_absolute_path(path, buf, buf_len - 1);\n\t\t\t/*\n\t\t\t * Fall back to local name if absolute name is not\n\t\t\t * available.\n\t\t\t */\n\t\t\tif (pos == ERR_PTR(-EINVAL))\n\t\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t\t    buf_len - 1);\n\t\t}\nencode:\n\t\tif (IS_ERR(pos))\n\t\t\tcontinue;\n\t\tname = tomoyo_encode(pos);\n\t\tbreak;\n\t}\n\tkfree(buf);\n\tif (!name)\n\t\ttomoyo_warn_oom(__func__);\n\treturn name;\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_warn_oom",
          "args": [
            "__func__"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_warn_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "17-29",
          "snippet": "void tomoyo_warn_oom(const char *function)\n{\n\t/* Reduce error messages. */\n\tstatic pid_t tomoyo_last_pid;\n\tconst pid_t pid = current->pid;\n\tif (tomoyo_last_pid != pid) {\n\t\tprintk(KERN_WARNING \"ERROR: Out of memory at %s.\\n\",\n\t\t       function);\n\t\ttomoyo_last_pid = pid;\n\t}\n\tif (!tomoyo_policy_loaded)\n\t\tpanic(\"MAC Initialization failed.\\n\");\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nvoid tomoyo_warn_oom(const char *function)\n{\n\t/* Reduce error messages. */\n\tstatic pid_t tomoyo_last_pid;\n\tconst pid_t pid = current->pid;\n\tif (tomoyo_last_pid != pid) {\n\t\tprintk(KERN_WARNING \"ERROR: Out of memory at %s.\\n\",\n\t\t       function);\n\t\ttomoyo_last_pid = pid;\n\t}\n\tif (!tomoyo_policy_loaded)\n\t\tpanic(\"MAC Initialization failed.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_encode",
          "args": [
            "pos"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "77-80",
          "snippet": "char *tomoyo_encode(const char *str)\n{\n\treturn str ? tomoyo_encode2(str, strlen(str)) : NULL;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nchar *tomoyo_encode(const char *str)\n{\n\treturn str ? tomoyo_encode2(str, strlen(str)) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pos"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_local_path",
          "args": [
            "path->dentry",
            "buf",
            "buf_len - 1"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_local_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "148-209",
          "snippet": "static char *tomoyo_get_local_path(struct dentry *dentry, char * const buffer,\n\t\t\t\t   const int buflen)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tchar *pos = tomoyo_get_dentry_path(dentry, buffer, buflen);\n\tif (IS_ERR(pos))\n\t\treturn pos;\n\t/* Convert from $PID to self if $PID is current thread. */\n\tif (sb->s_magic == PROC_SUPER_MAGIC && *pos == '/') {\n\t\tchar *ep;\n\t\tconst pid_t pid = (pid_t) simple_strtoul(pos + 1, &ep, 10);\n\t\tif (*ep == '/' && pid && pid ==\n\t\t    task_tgid_nr_ns(current, sb->s_fs_info)) {\n\t\t\tpos = ep - 5;\n\t\t\tif (pos < buffer)\n\t\t\t\tgoto out;\n\t\t\tmemmove(pos, \"/self\", 5);\n\t\t}\n\t\tgoto prepend_filesystem_name;\n\t}\n\t/* Use filesystem name for unnamed devices. */\n\tif (!MAJOR(sb->s_dev))\n\t\tgoto prepend_filesystem_name;\n\t{\n\t\tstruct inode *inode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Use filesystem name if filesystem does not support rename()\n\t\t * operation.\n\t\t */\n\t\tif (!inode->i_op->rename)\n\t\t\tgoto prepend_filesystem_name;\n\t}\n\t/* Prepend device name. */\n\t{\n\t\tchar name[64];\n\t\tint name_len;\n\t\tconst dev_t dev = sb->s_dev;\n\t\tname[sizeof(name) - 1] = '\\0';\n\t\tsnprintf(name, sizeof(name) - 1, \"dev(%u,%u):\", MAJOR(dev),\n\t\t\t MINOR(dev));\n\t\tname_len = strlen(name);\n\t\tpos -= name_len;\n\t\tif (pos < buffer)\n\t\t\tgoto out;\n\t\tmemmove(pos, name, name_len);\n\t\treturn pos;\n\t}\n\t/* Prepend filesystem name. */\nprepend_filesystem_name:\n\t{\n\t\tconst char *name = sb->s_type->name;\n\t\tconst int name_len = strlen(name);\n\t\tpos -= name_len + 1;\n\t\tif (pos < buffer)\n\t\t\tgoto out;\n\t\tmemmove(pos, name, name_len);\n\t\tpos[name_len] = ':';\n\t}\n\treturn pos;\nout:\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nstatic char *tomoyo_get_local_path(struct dentry *dentry, char * const buffer,\n\t\t\t\t   const int buflen)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tchar *pos = tomoyo_get_dentry_path(dentry, buffer, buflen);\n\tif (IS_ERR(pos))\n\t\treturn pos;\n\t/* Convert from $PID to self if $PID is current thread. */\n\tif (sb->s_magic == PROC_SUPER_MAGIC && *pos == '/') {\n\t\tchar *ep;\n\t\tconst pid_t pid = (pid_t) simple_strtoul(pos + 1, &ep, 10);\n\t\tif (*ep == '/' && pid && pid ==\n\t\t    task_tgid_nr_ns(current, sb->s_fs_info)) {\n\t\t\tpos = ep - 5;\n\t\t\tif (pos < buffer)\n\t\t\t\tgoto out;\n\t\t\tmemmove(pos, \"/self\", 5);\n\t\t}\n\t\tgoto prepend_filesystem_name;\n\t}\n\t/* Use filesystem name for unnamed devices. */\n\tif (!MAJOR(sb->s_dev))\n\t\tgoto prepend_filesystem_name;\n\t{\n\t\tstruct inode *inode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Use filesystem name if filesystem does not support rename()\n\t\t * operation.\n\t\t */\n\t\tif (!inode->i_op->rename)\n\t\t\tgoto prepend_filesystem_name;\n\t}\n\t/* Prepend device name. */\n\t{\n\t\tchar name[64];\n\t\tint name_len;\n\t\tconst dev_t dev = sb->s_dev;\n\t\tname[sizeof(name) - 1] = '\\0';\n\t\tsnprintf(name, sizeof(name) - 1, \"dev(%u,%u):\", MAJOR(dev),\n\t\t\t MINOR(dev));\n\t\tname_len = strlen(name);\n\t\tpos -= name_len;\n\t\tif (pos < buffer)\n\t\t\tgoto out;\n\t\tmemmove(pos, name, name_len);\n\t\treturn pos;\n\t}\n\t/* Prepend filesystem name. */\nprepend_filesystem_name:\n\t{\n\t\tconst char *name = sb->s_type->name;\n\t\tconst int name_len = strlen(name);\n\t\tpos -= name_len + 1;\n\t\tif (pos < buffer)\n\t\t\tgoto out;\n\t\tmemmove(pos, name, name_len);\n\t\tpos[name_len] = ':';\n\t}\n\treturn pos;\nout:\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_absolute_path",
          "args": [
            "path",
            "buf",
            "buf_len - 1"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_absolute_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "93-109",
          "snippet": "static char *tomoyo_get_absolute_path(const struct path *path, char * const buffer,\n\t\t\t\t      const int buflen)\n{\n\tchar *pos = ERR_PTR(-ENOMEM);\n\tif (buflen >= 256) {\n\t\t/* go to whatever namespace root we are under */\n\t\tpos = d_absolute_path(path, buffer, buflen - 1);\n\t\tif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\n\t\t\tstruct inode *inode = d_backing_inode(path->dentry);\n\t\t\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t\t\tbuffer[buflen - 2] = '/';\n\t\t\t\tbuffer[buflen - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nstatic char *tomoyo_get_absolute_path(const struct path *path, char * const buffer,\n\t\t\t\t      const int buflen)\n{\n\tchar *pos = ERR_PTR(-ENOMEM);\n\tif (buflen >= 256) {\n\t\t/* go to whatever namespace root we are under */\n\t\tpos = d_absolute_path(path, buffer, buflen - 1);\n\t\tif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\n\t\t\tstruct inode *inode = d_backing_inode(path->dentry);\n\t\t\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t\t\tbuffer[buflen - 2] = '/';\n\t\t\t\tbuffer[buflen - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "sb->s_root"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry->d_op->d_dname",
          "args": [
            "dentry",
            "buf",
            "buf_len - 1"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_socket_name",
          "args": [
            "path",
            "buf",
            "buf_len - 1"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_socket_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "220-234",
          "snippet": "static char *tomoyo_get_socket_name(const struct path *path, char * const buffer,\n\t\t\t\t    const int buflen)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct socket *sock = inode ? SOCKET_I(inode) : NULL;\n\tstruct sock *sk = sock ? sock->sk : NULL;\n\tif (sk) {\n\t\tsnprintf(buffer, buflen, \"socket:[family=%u:type=%u:\"\n\t\t\t \"protocol=%u]\", sk->sk_family, sk->sk_type,\n\t\t\t sk->sk_protocol);\n\t} else {\n\t\tsnprintf(buffer, buflen, \"socket:[unknown]\");\n\t}\n\treturn buffer;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nstatic char *tomoyo_get_socket_name(const struct path *path, char * const buffer,\n\t\t\t\t    const int buflen)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct socket *sock = inode ? SOCKET_I(inode) : NULL;\n\tstruct sock *sk = sock ? sock->sk : NULL;\n\tif (sk) {\n\t\tsnprintf(buffer, buflen, \"socket:[family=%u:type=%u:\"\n\t\t\t \"protocol=%u]\", sk->sk_family, sk->sk_type,\n\t\t\t sk->sk_protocol);\n\t} else {\n\t\tsnprintf(buffer, buflen, \"socket:[unknown]\");\n\t}\n\treturn buffer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "buf_len",
            "GFP_NOFS"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nchar *tomoyo_realpath_from_path(const struct path *path)\n{\n\tchar *buf = NULL;\n\tchar *name = NULL;\n\tunsigned int buf_len = PAGE_SIZE / 2;\n\tstruct dentry *dentry = path->dentry;\n\tstruct super_block *sb;\n\tif (!dentry)\n\t\treturn NULL;\n\tsb = dentry->d_sb;\n\twhile (1) {\n\t\tchar *pos;\n\t\tstruct inode *inode;\n\t\tbuf_len <<= 1;\n\t\tkfree(buf);\n\t\tbuf = kmalloc(buf_len, GFP_NOFS);\n\t\tif (!buf)\n\t\t\tbreak;\n\t\t/* To make sure that pos is '\\0' terminated. */\n\t\tbuf[buf_len - 1] = '\\0';\n\t\t/* Get better name for socket. */\n\t\tif (sb->s_magic == SOCKFS_MAGIC) {\n\t\t\tpos = tomoyo_get_socket_name(path, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\t/* For \"pipe:[\\$]\". */\n\t\tif (dentry->d_op && dentry->d_op->d_dname) {\n\t\t\tpos = dentry->d_op->d_dname(dentry, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\tinode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Get local name for filesystems without rename() operation\n\t\t * or dentry without vfsmount.\n\t\t */\n\t\tif (!path->mnt ||\n\t\t    (!inode->i_op->rename))\n\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t    buf_len - 1);\n\t\t/* Get absolute name for the rest. */\n\t\telse {\n\t\t\tpos = tomoyo_get_absolute_path(path, buf, buf_len - 1);\n\t\t\t/*\n\t\t\t * Fall back to local name if absolute name is not\n\t\t\t * available.\n\t\t\t */\n\t\t\tif (pos == ERR_PTR(-EINVAL))\n\t\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t\t    buf_len - 1);\n\t\t}\nencode:\n\t\tif (IS_ERR(pos))\n\t\t\tcontinue;\n\t\tname = tomoyo_encode(pos);\n\t\tbreak;\n\t}\n\tkfree(buf);\n\tif (!name)\n\t\ttomoyo_warn_oom(__func__);\n\treturn name;\n}"
  },
  {
    "function_name": "tomoyo_get_socket_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
    "lines": "220-234",
    "snippet": "static char *tomoyo_get_socket_name(const struct path *path, char * const buffer,\n\t\t\t\t    const int buflen)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct socket *sock = inode ? SOCKET_I(inode) : NULL;\n\tstruct sock *sk = sock ? sock->sk : NULL;\n\tif (sk) {\n\t\tsnprintf(buffer, buflen, \"socket:[family=%u:type=%u:\"\n\t\t\t \"protocol=%u]\", sk->sk_family, sk->sk_type,\n\t\t\t sk->sk_protocol);\n\t} else {\n\t\tsnprintf(buffer, buflen, \"socket:[unknown]\");\n\t}\n\treturn buffer;\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "buflen",
            "\"socket:[unknown]\""
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "buflen",
            "\"socket:[family=%u:type=%u:\"\n\t\t\t \"protocol=%u]\"",
            "sk->sk_family",
            "sk->sk_type",
            "sk->sk_protocol"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOCKET_I",
          "args": [
            "inode"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "path->dentry"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nstatic char *tomoyo_get_socket_name(const struct path *path, char * const buffer,\n\t\t\t\t    const int buflen)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct socket *sock = inode ? SOCKET_I(inode) : NULL;\n\tstruct sock *sk = sock ? sock->sk : NULL;\n\tif (sk) {\n\t\tsnprintf(buffer, buflen, \"socket:[family=%u:type=%u:\"\n\t\t\t \"protocol=%u]\", sk->sk_family, sk->sk_type,\n\t\t\t sk->sk_protocol);\n\t} else {\n\t\tsnprintf(buffer, buflen, \"socket:[unknown]\");\n\t}\n\treturn buffer;\n}"
  },
  {
    "function_name": "tomoyo_get_local_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
    "lines": "148-209",
    "snippet": "static char *tomoyo_get_local_path(struct dentry *dentry, char * const buffer,\n\t\t\t\t   const int buflen)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tchar *pos = tomoyo_get_dentry_path(dentry, buffer, buflen);\n\tif (IS_ERR(pos))\n\t\treturn pos;\n\t/* Convert from $PID to self if $PID is current thread. */\n\tif (sb->s_magic == PROC_SUPER_MAGIC && *pos == '/') {\n\t\tchar *ep;\n\t\tconst pid_t pid = (pid_t) simple_strtoul(pos + 1, &ep, 10);\n\t\tif (*ep == '/' && pid && pid ==\n\t\t    task_tgid_nr_ns(current, sb->s_fs_info)) {\n\t\t\tpos = ep - 5;\n\t\t\tif (pos < buffer)\n\t\t\t\tgoto out;\n\t\t\tmemmove(pos, \"/self\", 5);\n\t\t}\n\t\tgoto prepend_filesystem_name;\n\t}\n\t/* Use filesystem name for unnamed devices. */\n\tif (!MAJOR(sb->s_dev))\n\t\tgoto prepend_filesystem_name;\n\t{\n\t\tstruct inode *inode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Use filesystem name if filesystem does not support rename()\n\t\t * operation.\n\t\t */\n\t\tif (!inode->i_op->rename)\n\t\t\tgoto prepend_filesystem_name;\n\t}\n\t/* Prepend device name. */\n\t{\n\t\tchar name[64];\n\t\tint name_len;\n\t\tconst dev_t dev = sb->s_dev;\n\t\tname[sizeof(name) - 1] = '\\0';\n\t\tsnprintf(name, sizeof(name) - 1, \"dev(%u,%u):\", MAJOR(dev),\n\t\t\t MINOR(dev));\n\t\tname_len = strlen(name);\n\t\tpos -= name_len;\n\t\tif (pos < buffer)\n\t\t\tgoto out;\n\t\tmemmove(pos, name, name_len);\n\t\treturn pos;\n\t}\n\t/* Prepend filesystem name. */\nprepend_filesystem_name:\n\t{\n\t\tconst char *name = sb->s_type->name;\n\t\tconst int name_len = strlen(name);\n\t\tpos -= name_len + 1;\n\t\tif (pos < buffer)\n\t\t\tgoto out;\n\t\tmemmove(pos, name, name_len);\n\t\tpos[name_len] = ':';\n\t}\n\treturn pos;\nout:\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "pos",
            "name",
            "name_len"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "pos",
            "name",
            "name_len"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "sizeof(name) - 1",
            "\"dev(%u,%u):\"",
            "MAJOR(dev)",
            "MINOR(dev)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "sb->s_root"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "sb->s_dev"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "pos",
            "\"/self\"",
            "5"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr_ns",
          "args": [
            "current",
            "sb->s_fs_info"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "pos + 1",
            "&ep",
            "10"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pos"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_dentry_path",
          "args": [
            "dentry",
            "buffer",
            "buflen"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_dentry_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "122-137",
          "snippet": "static char *tomoyo_get_dentry_path(struct dentry *dentry, char * const buffer,\n\t\t\t\t    const int buflen)\n{\n\tchar *pos = ERR_PTR(-ENOMEM);\n\tif (buflen >= 256) {\n\t\tpos = dentry_path_raw(dentry, buffer, buflen - 1);\n\t\tif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\n\t\t\tstruct inode *inode = d_backing_inode(dentry);\n\t\t\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t\t\tbuffer[buflen - 2] = '/';\n\t\t\t\tbuffer[buflen - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nstatic char *tomoyo_get_dentry_path(struct dentry *dentry, char * const buffer,\n\t\t\t\t    const int buflen)\n{\n\tchar *pos = ERR_PTR(-ENOMEM);\n\tif (buflen >= 256) {\n\t\tpos = dentry_path_raw(dentry, buffer, buflen - 1);\n\t\tif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\n\t\t\tstruct inode *inode = d_backing_inode(dentry);\n\t\t\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t\t\tbuffer[buflen - 2] = '/';\n\t\t\t\tbuffer[buflen - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nstatic char *tomoyo_get_local_path(struct dentry *dentry, char * const buffer,\n\t\t\t\t   const int buflen)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tchar *pos = tomoyo_get_dentry_path(dentry, buffer, buflen);\n\tif (IS_ERR(pos))\n\t\treturn pos;\n\t/* Convert from $PID to self if $PID is current thread. */\n\tif (sb->s_magic == PROC_SUPER_MAGIC && *pos == '/') {\n\t\tchar *ep;\n\t\tconst pid_t pid = (pid_t) simple_strtoul(pos + 1, &ep, 10);\n\t\tif (*ep == '/' && pid && pid ==\n\t\t    task_tgid_nr_ns(current, sb->s_fs_info)) {\n\t\t\tpos = ep - 5;\n\t\t\tif (pos < buffer)\n\t\t\t\tgoto out;\n\t\t\tmemmove(pos, \"/self\", 5);\n\t\t}\n\t\tgoto prepend_filesystem_name;\n\t}\n\t/* Use filesystem name for unnamed devices. */\n\tif (!MAJOR(sb->s_dev))\n\t\tgoto prepend_filesystem_name;\n\t{\n\t\tstruct inode *inode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Use filesystem name if filesystem does not support rename()\n\t\t * operation.\n\t\t */\n\t\tif (!inode->i_op->rename)\n\t\t\tgoto prepend_filesystem_name;\n\t}\n\t/* Prepend device name. */\n\t{\n\t\tchar name[64];\n\t\tint name_len;\n\t\tconst dev_t dev = sb->s_dev;\n\t\tname[sizeof(name) - 1] = '\\0';\n\t\tsnprintf(name, sizeof(name) - 1, \"dev(%u,%u):\", MAJOR(dev),\n\t\t\t MINOR(dev));\n\t\tname_len = strlen(name);\n\t\tpos -= name_len;\n\t\tif (pos < buffer)\n\t\t\tgoto out;\n\t\tmemmove(pos, name, name_len);\n\t\treturn pos;\n\t}\n\t/* Prepend filesystem name. */\nprepend_filesystem_name:\n\t{\n\t\tconst char *name = sb->s_type->name;\n\t\tconst int name_len = strlen(name);\n\t\tpos -= name_len + 1;\n\t\tif (pos < buffer)\n\t\t\tgoto out;\n\t\tmemmove(pos, name, name_len);\n\t\tpos[name_len] = ':';\n\t}\n\treturn pos;\nout:\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "tomoyo_get_dentry_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
    "lines": "122-137",
    "snippet": "static char *tomoyo_get_dentry_path(struct dentry *dentry, char * const buffer,\n\t\t\t\t    const int buflen)\n{\n\tchar *pos = ERR_PTR(-ENOMEM);\n\tif (buflen >= 256) {\n\t\tpos = dentry_path_raw(dentry, buffer, buflen - 1);\n\t\tif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\n\t\t\tstruct inode *inode = d_backing_inode(dentry);\n\t\t\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t\t\tbuffer[buflen - 2] = '/';\n\t\t\t\tbuffer[buflen - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pos"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_path_raw",
          "args": [
            "dentry",
            "buffer",
            "buflen - 1"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nstatic char *tomoyo_get_dentry_path(struct dentry *dentry, char * const buffer,\n\t\t\t\t    const int buflen)\n{\n\tchar *pos = ERR_PTR(-ENOMEM);\n\tif (buflen >= 256) {\n\t\tpos = dentry_path_raw(dentry, buffer, buflen - 1);\n\t\tif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\n\t\t\tstruct inode *inode = d_backing_inode(dentry);\n\t\t\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t\t\tbuffer[buflen - 2] = '/';\n\t\t\t\tbuffer[buflen - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}"
  },
  {
    "function_name": "tomoyo_get_absolute_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
    "lines": "93-109",
    "snippet": "static char *tomoyo_get_absolute_path(const struct path *path, char * const buffer,\n\t\t\t\t      const int buflen)\n{\n\tchar *pos = ERR_PTR(-ENOMEM);\n\tif (buflen >= 256) {\n\t\t/* go to whatever namespace root we are under */\n\t\tpos = d_absolute_path(path, buffer, buflen - 1);\n\t\tif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\n\t\t\tstruct inode *inode = d_backing_inode(path->dentry);\n\t\t\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t\t\tbuffer[buflen - 2] = '/';\n\t\t\t\tbuffer[buflen - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "path->dentry"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pos"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_absolute_path",
          "args": [
            "path",
            "buffer",
            "buflen - 1"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nstatic char *tomoyo_get_absolute_path(const struct path *path, char * const buffer,\n\t\t\t\t      const int buflen)\n{\n\tchar *pos = ERR_PTR(-ENOMEM);\n\tif (buflen >= 256) {\n\t\t/* go to whatever namespace root we are under */\n\t\tpos = d_absolute_path(path, buffer, buflen - 1);\n\t\tif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\n\t\t\tstruct inode *inode = d_backing_inode(path->dentry);\n\t\t\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t\t\tbuffer[buflen - 2] = '/';\n\t\t\t\tbuffer[buflen - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}"
  },
  {
    "function_name": "tomoyo_encode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
    "lines": "77-80",
    "snippet": "char *tomoyo_encode(const char *str)\n{\n\treturn str ? tomoyo_encode2(str, strlen(str)) : NULL;\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_encode2",
          "args": [
            "str",
            "strlen(str)"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_encode2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "22-65",
          "snippet": "char *tomoyo_encode2(const char *str, int str_len)\n{\n\tint i;\n\tint len = 0;\n\tconst char *p = str;\n\tchar *cp;\n\tchar *cp0;\n\n\tif (!p)\n\t\treturn NULL;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\')\n\t\t\tlen += 2;\n\t\telse if (c > ' ' && c < 127)\n\t\t\tlen++;\n\t\telse\n\t\t\tlen += 4;\n\t}\n\tlen++;\n\t/* Reserve space for appending \"/\". */\n\tcp = kzalloc(len + 10, GFP_NOFS);\n\tif (!cp)\n\t\treturn NULL;\n\tcp0 = cp;\n\tp = str;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\') {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = '\\\\';\n\t\t} else if (c > ' ' && c < 127) {\n\t\t\t*cp++ = c;\n\t\t} else {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = (c >> 6) + '0';\n\t\t\t*cp++ = ((c >> 3) & 7) + '0';\n\t\t\t*cp++ = (c & 7) + '0';\n\t\t}\n\t}\n\treturn cp0;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nchar *tomoyo_encode2(const char *str, int str_len)\n{\n\tint i;\n\tint len = 0;\n\tconst char *p = str;\n\tchar *cp;\n\tchar *cp0;\n\n\tif (!p)\n\t\treturn NULL;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\')\n\t\t\tlen += 2;\n\t\telse if (c > ' ' && c < 127)\n\t\t\tlen++;\n\t\telse\n\t\t\tlen += 4;\n\t}\n\tlen++;\n\t/* Reserve space for appending \"/\". */\n\tcp = kzalloc(len + 10, GFP_NOFS);\n\tif (!cp)\n\t\treturn NULL;\n\tcp0 = cp;\n\tp = str;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\') {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = '\\\\';\n\t\t} else if (c > ' ' && c < 127) {\n\t\t\t*cp++ = c;\n\t\t} else {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = (c >> 6) + '0';\n\t\t\t*cp++ = ((c >> 3) & 7) + '0';\n\t\t\t*cp++ = (c & 7) + '0';\n\t\t}\n\t}\n\treturn cp0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nchar *tomoyo_encode(const char *str)\n{\n\treturn str ? tomoyo_encode2(str, strlen(str)) : NULL;\n}"
  },
  {
    "function_name": "tomoyo_encode2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
    "lines": "22-65",
    "snippet": "char *tomoyo_encode2(const char *str, int str_len)\n{\n\tint i;\n\tint len = 0;\n\tconst char *p = str;\n\tchar *cp;\n\tchar *cp0;\n\n\tif (!p)\n\t\treturn NULL;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\')\n\t\t\tlen += 2;\n\t\telse if (c > ' ' && c < 127)\n\t\t\tlen++;\n\t\telse\n\t\t\tlen += 4;\n\t}\n\tlen++;\n\t/* Reserve space for appending \"/\". */\n\tcp = kzalloc(len + 10, GFP_NOFS);\n\tif (!cp)\n\t\treturn NULL;\n\tcp0 = cp;\n\tp = str;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\') {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = '\\\\';\n\t\t} else if (c > ' ' && c < 127) {\n\t\t\t*cp++ = c;\n\t\t} else {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = (c >> 6) + '0';\n\t\t\t*cp++ = ((c >> 3) & 7) + '0';\n\t\t\t*cp++ = (c & 7) + '0';\n\t\t}\n\t}\n\treturn cp0;\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len + 10",
            "GFP_NOFS"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nchar *tomoyo_encode2(const char *str, int str_len)\n{\n\tint i;\n\tint len = 0;\n\tconst char *p = str;\n\tchar *cp;\n\tchar *cp0;\n\n\tif (!p)\n\t\treturn NULL;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\')\n\t\t\tlen += 2;\n\t\telse if (c > ' ' && c < 127)\n\t\t\tlen++;\n\t\telse\n\t\t\tlen += 4;\n\t}\n\tlen++;\n\t/* Reserve space for appending \"/\". */\n\tcp = kzalloc(len + 10, GFP_NOFS);\n\tif (!cp)\n\t\treturn NULL;\n\tcp0 = cp;\n\tp = str;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\') {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = '\\\\';\n\t\t} else if (c > ' ' && c < 127) {\n\t\t\t*cp++ = c;\n\t\t} else {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = (c >> 6) + '0';\n\t\t\t*cp++ = ((c >> 3) & 7) + '0';\n\t\t\t*cp++ = (c & 7) + '0';\n\t\t}\n\t}\n\treturn cp0;\n}"
  }
]