[
  {
    "function_name": "security_read_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3543-3570",
    "snippet": "int security_read_policy(void **data, size_t *len)\n{\n\tint rc;\n\tstruct policy_file fp;\n\n\tif (!ss_initialized)\n\t\treturn -EINVAL;\n\n\t*len = security_policydb_len();\n\n\t*data = vmalloc_user(*len);\n\tif (!*data)\n\t\treturn -ENOMEM;\n\n\tfp.data = *data;\n\tfp.len = *len;\n\n\tread_lock(&policy_rwlock);\n\trc = policydb_write(&policydb, &fp);\n\tread_unlock(&policy_rwlock);\n\n\tif (rc)\n\t\treturn rc;\n\n\t*len = (unsigned long)fp.data - (unsigned long)*data;\n\treturn 0;\n\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "struct policydb policydb;",
      "int ss_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3562
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policydb_write",
          "args": [
            "&policydb",
            "&fp"
          ],
          "line": 3561
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "3404-3535",
          "snippet": "int policydb_write(struct policydb *p, void *fp)\n{\n\tunsigned int i, num_syms;\n\tint rc;\n\t__le32 buf[4];\n\tu32 config;\n\tsize_t len;\n\tstruct policydb_compat_info *info;\n\n\t/*\n\t * refuse to write policy older than compressed avtab\n\t * to simplify the writer.  There are other tests dropped\n\t * since we assume this throughout the writer code.  Be\n\t * careful if you ever try to remove this restriction\n\t */\n\tif (p->policyvers < POLICYDB_VERSION_AVTAB) {\n\t\tprintk(KERN_ERR \"SELinux: refusing to write policy version %d.\"\n\t\t       \"  Because it is less than version %d\\n\", p->policyvers,\n\t\t       POLICYDB_VERSION_AVTAB);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig = 0;\n\tif (p->mls_enabled)\n\t\tconfig |= POLICYDB_CONFIG_MLS;\n\n\tif (p->reject_unknown)\n\t\tconfig |= REJECT_UNKNOWN;\n\tif (p->allow_unknown)\n\t\tconfig |= ALLOW_UNKNOWN;\n\n\t/* Write the magic number and string identifiers. */\n\tbuf[0] = cpu_to_le32(POLICYDB_MAGIC);\n\tlen = strlen(POLICYDB_STRING);\n\tbuf[1] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\trc = put_entry(POLICYDB_STRING, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Write the version, config, and table sizes. */\n\tinfo = policydb_lookup_compat(p->policyvers);\n\tif (!info) {\n\t\tprintk(KERN_ERR \"SELinux: compatibility lookup failed for policy \"\n\t\t    \"version %d\", p->policyvers);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf[0] = cpu_to_le32(p->policyvers);\n\tbuf[1] = cpu_to_le32(config);\n\tbuf[2] = cpu_to_le32(info->sym_num);\n\tbuf[3] = cpu_to_le32(info->ocon_num);\n\n\trc = put_entry(buf, sizeof(u32), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (p->policyvers >= POLICYDB_VERSION_POLCAP) {\n\t\trc = ebitmap_write(&p->policycaps, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_PERMISSIVE) {\n\t\trc = ebitmap_write(&p->permissive_map, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tnum_syms = info->sym_num;\n\tfor (i = 0; i < num_syms; i++) {\n\t\tstruct policy_data pd;\n\n\t\tpd.fp = fp;\n\t\tpd.p = p;\n\n\t\tbuf[0] = cpu_to_le32(p->symtab[i].nprim);\n\t\tbuf[1] = cpu_to_le32(p->symtab[i].table->nel);\n\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = hashtab_map(p->symtab[i].table, write_f[i], &pd);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = avtab_write(p, &p->te_avtab, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cond_write_list(p, p->cond_list, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = role_trans_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = role_allow_write(p->role_allow, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = filename_trans_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ocontext_write(p, info, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = genfs_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = range_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\tstruct ebitmap *e = flex_array_get(p->type_attr_map_array, i);\n\n\t\tBUG_ON(!e);\n\t\trc = ebitmap_write(e, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*write_f[SYM_NUM]) (void *key, void *datum,\n\t\t\t\tvoid *datap) =\n{\n\tcommon_write,\n\tclass_write,\n\trole_write,\n\ttype_write,\n\tuser_write,\n\tcond_write_bool,\n\tsens_write,\n\tcat_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int (*write_f[SYM_NUM]) (void *key, void *datum,\n\t\t\t\tvoid *datap) =\n{\n\tcommon_write,\n\tclass_write,\n\trole_write,\n\ttype_write,\n\tuser_write,\n\tcond_write_bool,\n\tsens_write,\n\tcat_write,\n};\n\nint policydb_write(struct policydb *p, void *fp)\n{\n\tunsigned int i, num_syms;\n\tint rc;\n\t__le32 buf[4];\n\tu32 config;\n\tsize_t len;\n\tstruct policydb_compat_info *info;\n\n\t/*\n\t * refuse to write policy older than compressed avtab\n\t * to simplify the writer.  There are other tests dropped\n\t * since we assume this throughout the writer code.  Be\n\t * careful if you ever try to remove this restriction\n\t */\n\tif (p->policyvers < POLICYDB_VERSION_AVTAB) {\n\t\tprintk(KERN_ERR \"SELinux: refusing to write policy version %d.\"\n\t\t       \"  Because it is less than version %d\\n\", p->policyvers,\n\t\t       POLICYDB_VERSION_AVTAB);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig = 0;\n\tif (p->mls_enabled)\n\t\tconfig |= POLICYDB_CONFIG_MLS;\n\n\tif (p->reject_unknown)\n\t\tconfig |= REJECT_UNKNOWN;\n\tif (p->allow_unknown)\n\t\tconfig |= ALLOW_UNKNOWN;\n\n\t/* Write the magic number and string identifiers. */\n\tbuf[0] = cpu_to_le32(POLICYDB_MAGIC);\n\tlen = strlen(POLICYDB_STRING);\n\tbuf[1] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\trc = put_entry(POLICYDB_STRING, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Write the version, config, and table sizes. */\n\tinfo = policydb_lookup_compat(p->policyvers);\n\tif (!info) {\n\t\tprintk(KERN_ERR \"SELinux: compatibility lookup failed for policy \"\n\t\t    \"version %d\", p->policyvers);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf[0] = cpu_to_le32(p->policyvers);\n\tbuf[1] = cpu_to_le32(config);\n\tbuf[2] = cpu_to_le32(info->sym_num);\n\tbuf[3] = cpu_to_le32(info->ocon_num);\n\n\trc = put_entry(buf, sizeof(u32), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (p->policyvers >= POLICYDB_VERSION_POLCAP) {\n\t\trc = ebitmap_write(&p->policycaps, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_PERMISSIVE) {\n\t\trc = ebitmap_write(&p->permissive_map, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tnum_syms = info->sym_num;\n\tfor (i = 0; i < num_syms; i++) {\n\t\tstruct policy_data pd;\n\n\t\tpd.fp = fp;\n\t\tpd.p = p;\n\n\t\tbuf[0] = cpu_to_le32(p->symtab[i].nprim);\n\t\tbuf[1] = cpu_to_le32(p->symtab[i].table->nel);\n\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = hashtab_map(p->symtab[i].table, write_f[i], &pd);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = avtab_write(p, &p->te_avtab, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cond_write_list(p, p->cond_list, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = role_trans_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = role_allow_write(p->role_allow, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = filename_trans_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ocontext_write(p, info, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = genfs_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = range_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\tstruct ebitmap *e = flex_array_get(p->type_attr_map_array, i);\n\n\t\tBUG_ON(!e);\n\t\trc = ebitmap_write(e, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_user",
          "args": [
            "*len"
          ],
          "line": 3553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_policydb_len",
          "args": [],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "security_policydb_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2197-2206",
          "snippet": "size_t security_policydb_len(void)\n{\n\tsize_t len;\n\n\tread_lock(&policy_rwlock);\n\tlen = policydb.len;\n\tread_unlock(&policy_rwlock);\n\n\treturn len;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nsize_t security_policydb_len(void)\n{\n\tsize_t len;\n\n\tread_lock(&policy_rwlock);\n\tlen = policydb.len;\n\tread_unlock(&policy_rwlock);\n\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\nint ss_initialized;\n\nint security_read_policy(void **data, size_t *len)\n{\n\tint rc;\n\tstruct policy_file fp;\n\n\tif (!ss_initialized)\n\t\treturn -EINVAL;\n\n\t*len = security_policydb_len();\n\n\t*data = vmalloc_user(*len);\n\tif (!*data)\n\t\treturn -ENOMEM;\n\n\tfp.data = *data;\n\tfp.len = *len;\n\n\tread_lock(&policy_rwlock);\n\trc = policydb_write(&policydb, &fp);\n\tread_unlock(&policy_rwlock);\n\n\tif (rc)\n\t\treturn rc;\n\n\t*len = (unsigned long)fp.data - (unsigned long)*data;\n\treturn 0;\n\n}"
  },
  {
    "function_name": "security_netlbl_sid_to_secattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3506-3534",
    "snippet": "int security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\tstruct context *ctx;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOENT;\n\tctx = sidtab_search(&sidtab, sid);\n\tif (ctx == NULL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsecattr->domain = kstrdup(sym_name(&policydb, SYM_TYPES, ctx->type - 1),\n\t\t\t\t  GFP_ATOMIC);\n\tif (secattr->domain == NULL)\n\t\tgoto out;\n\n\tsecattr->attr.secid = sid;\n\tsecattr->flags |= NETLBL_SECATTR_DOMAIN_CPY | NETLBL_SECATTR_SECID;\n\tmls_export_netlbl_lvl(ctx, secattr);\n\trc = mls_export_netlbl_cat(ctx, secattr);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;",
      "int ss_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3532
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_export_netlbl_cat",
          "args": [
            "ctx",
            "secattr"
          ],
          "line": 3530
        },
        "resolved": true,
        "details": {
          "function_name": "mls_export_netlbl_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.h",
          "lines": "79-83",
          "snippet": "static inline int mls_export_netlbl_cat(struct context *context,\n\t\t\t\t\tstruct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"context.h\"\n\nstatic inline int mls_export_netlbl_cat(struct context *context,\n\t\t\t\t\tstruct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_export_netlbl_lvl",
          "args": [
            "ctx",
            "secattr"
          ],
          "line": 3529
        },
        "resolved": true,
        "details": {
          "function_name": "mls_export_netlbl_lvl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.h",
          "lines": "69-73",
          "snippet": "static inline void mls_export_netlbl_lvl(struct context *context,\n\t\t\t\t\t struct netlbl_lsm_secattr *secattr)\n{\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"context.h\"\n\nstatic inline void mls_export_netlbl_lvl(struct context *context,\n\t\t\t\t\t struct netlbl_lsm_secattr *secattr)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "sym_name(&policydb, SYM_TYPES, ctx->type - 1)",
            "GFP_ATOMIC"
          ],
          "line": 3522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "&policydb",
            "SYM_TYPES",
            "ctx->type - 1"
          ],
          "line": 3522
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "&sidtab",
            "sid"
          ],
          "line": 3517
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nint security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\tstruct context *ctx;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOENT;\n\tctx = sidtab_search(&sidtab, sid);\n\tif (ctx == NULL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsecattr->domain = kstrdup(sym_name(&policydb, SYM_TYPES, ctx->type - 1),\n\t\t\t\t  GFP_ATOMIC);\n\tif (secattr->domain == NULL)\n\t\tgoto out;\n\n\tsecattr->attr.secid = sid;\n\tsecattr->flags |= NETLBL_SECATTR_DOMAIN_CPY | NETLBL_SECATTR_SECID;\n\tmls_export_netlbl_lvl(ctx, secattr);\n\trc = mls_export_netlbl_cat(ctx, secattr);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
  },
  {
    "function_name": "security_netlbl_secattr_to_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3439-3494",
    "snippet": "int security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\tstruct context *ctx;\n\tstruct context ctx_new;\n\n\tif (!ss_initialized) {\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\n\tread_lock(&policy_rwlock);\n\n\tif (secattr->flags & NETLBL_SECATTR_CACHE)\n\t\t*sid = *(u32 *)secattr->cache->data;\n\telse if (secattr->flags & NETLBL_SECATTR_SECID)\n\t\t*sid = secattr->attr.secid;\n\telse if (secattr->flags & NETLBL_SECATTR_MLS_LVL) {\n\t\trc = -EIDRM;\n\t\tctx = sidtab_search(&sidtab, SECINITSID_NETMSG);\n\t\tif (ctx == NULL)\n\t\t\tgoto out;\n\n\t\tcontext_init(&ctx_new);\n\t\tctx_new.user = ctx->user;\n\t\tctx_new.role = ctx->role;\n\t\tctx_new.type = ctx->type;\n\t\tmls_import_netlbl_lvl(&ctx_new, secattr);\n\t\tif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\n\t\t\trc = mls_import_netlbl_cat(&ctx_new, secattr);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\trc = -EIDRM;\n\t\tif (!mls_context_isvalid(&policydb, &ctx_new))\n\t\t\tgoto out_free;\n\n\t\trc = sidtab_context_to_sid(&sidtab, &ctx_new, sid);\n\t\tif (rc)\n\t\t\tgoto out_free;\n\n\t\tsecurity_netlbl_cache_add(secattr, *sid);\n\n\t\tebitmap_destroy(&ctx_new.range.level[0].cat);\n\t} else\n\t\t*sid = SECSID_NULL;\n\n\tread_unlock(&policy_rwlock);\n\treturn 0;\nout_free:\n\tebitmap_destroy(&ctx_new.range.level[0].cat);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;",
      "int ss_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3492
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_destroy",
          "args": [
            "&ctx_new.range.level[0].cat"
          ],
          "line": 3490
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "327-344",
          "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_netlbl_cache_add",
          "args": [
            "secattr",
            "*sid"
          ],
          "line": 3481
        },
        "resolved": true,
        "details": {
          "function_name": "security_netlbl_cache_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3404-3422",
          "snippet": "static void security_netlbl_cache_add(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t      u32 sid)\n{\n\tu32 *sid_cache;\n\n\tsid_cache = kmalloc(sizeof(*sid_cache), GFP_ATOMIC);\n\tif (sid_cache == NULL)\n\t\treturn;\n\tsecattr->cache = netlbl_secattr_cache_alloc(GFP_ATOMIC);\n\tif (secattr->cache == NULL) {\n\t\tkfree(sid_cache);\n\t\treturn;\n\t}\n\n\t*sid_cache = sid;\n\tsecattr->cache->free = kfree;\n\tsecattr->cache->data = sid_cache;\n\tsecattr->flags |= NETLBL_SECATTR_CACHE;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void security_netlbl_cache_add(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t      u32 sid)\n{\n\tu32 *sid_cache;\n\n\tsid_cache = kmalloc(sizeof(*sid_cache), GFP_ATOMIC);\n\tif (sid_cache == NULL)\n\t\treturn;\n\tsecattr->cache = netlbl_secattr_cache_alloc(GFP_ATOMIC);\n\tif (secattr->cache == NULL) {\n\t\tkfree(sid_cache);\n\t\treturn;\n\t}\n\n\t*sid_cache = sid;\n\tsecattr->cache->free = kfree;\n\tsecattr->cache->data = sid_cache;\n\tsecattr->flags |= NETLBL_SECATTR_CACHE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_context_to_sid",
          "args": [
            "&sidtab",
            "&ctx_new",
            "sid"
          ],
          "line": 3477
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "191-232",
          "snippet": "int sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_context_isvalid",
          "args": [
            "&policydb",
            "&ctx_new"
          ],
          "line": 3474
        },
        "resolved": true,
        "details": {
          "function_name": "mls_context_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "192-215",
          "snippet": "int mls_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct user_datum *usrdatum;\n\n\tif (!p->mls_enabled)\n\t\treturn 1;\n\n\tif (!mls_range_isvalid(p, &c->range))\n\t\treturn 0;\n\n\tif (c->role == OBJECT_R_VAL)\n\t\treturn 1;\n\n\t/*\n\t * User must be authorized for the MLS range.\n\t */\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\tusrdatum = p->user_val_to_struct[c->user - 1];\n\tif (!mls_range_contains(usrdatum->range, c->range))\n\t\treturn 0; /* user may not be associated with range */\n\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct user_datum *usrdatum;\n\n\tif (!p->mls_enabled)\n\t\treturn 1;\n\n\tif (!mls_range_isvalid(p, &c->range))\n\t\treturn 0;\n\n\tif (c->role == OBJECT_R_VAL)\n\t\treturn 1;\n\n\t/*\n\t * User must be authorized for the MLS range.\n\t */\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\tusrdatum = p->user_val_to_struct[c->user - 1];\n\tif (!mls_range_contains(usrdatum->range, c->range))\n\t\treturn 0; /* user may not be associated with range */\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_import_netlbl_cat",
          "args": [
            "&ctx_new",
            "secattr"
          ],
          "line": 3469
        },
        "resolved": true,
        "details": {
          "function_name": "mls_import_netlbl_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.h",
          "lines": "84-88",
          "snippet": "static inline int mls_import_netlbl_cat(struct context *context,\n\t\t\t\t\tstruct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"context.h\"\n\nstatic inline int mls_import_netlbl_cat(struct context *context,\n\t\t\t\t\tstruct netlbl_lsm_secattr *secattr)\n{\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_import_netlbl_lvl",
          "args": [
            "&ctx_new",
            "secattr"
          ],
          "line": 3467
        },
        "resolved": true,
        "details": {
          "function_name": "mls_import_netlbl_lvl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.h",
          "lines": "74-78",
          "snippet": "static inline void mls_import_netlbl_lvl(struct context *context,\n\t\t\t\t\t struct netlbl_lsm_secattr *secattr)\n{\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"context.h\"\n\nstatic inline void mls_import_netlbl_lvl(struct context *context,\n\t\t\t\t\t struct netlbl_lsm_secattr *secattr)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_init",
          "args": [
            "&ctx_new"
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "context_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "113-116",
          "snippet": "static inline void context_init(struct context *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_init(struct context *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "&sidtab",
            "SECINITSID_NETMSG"
          ],
          "line": 3459
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nint security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\tstruct context *ctx;\n\tstruct context ctx_new;\n\n\tif (!ss_initialized) {\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\n\tread_lock(&policy_rwlock);\n\n\tif (secattr->flags & NETLBL_SECATTR_CACHE)\n\t\t*sid = *(u32 *)secattr->cache->data;\n\telse if (secattr->flags & NETLBL_SECATTR_SECID)\n\t\t*sid = secattr->attr.secid;\n\telse if (secattr->flags & NETLBL_SECATTR_MLS_LVL) {\n\t\trc = -EIDRM;\n\t\tctx = sidtab_search(&sidtab, SECINITSID_NETMSG);\n\t\tif (ctx == NULL)\n\t\t\tgoto out;\n\n\t\tcontext_init(&ctx_new);\n\t\tctx_new.user = ctx->user;\n\t\tctx_new.role = ctx->role;\n\t\tctx_new.type = ctx->type;\n\t\tmls_import_netlbl_lvl(&ctx_new, secattr);\n\t\tif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\n\t\t\trc = mls_import_netlbl_cat(&ctx_new, secattr);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\trc = -EIDRM;\n\t\tif (!mls_context_isvalid(&policydb, &ctx_new))\n\t\t\tgoto out_free;\n\n\t\trc = sidtab_context_to_sid(&sidtab, &ctx_new, sid);\n\t\tif (rc)\n\t\t\tgoto out_free;\n\n\t\tsecurity_netlbl_cache_add(secattr, *sid);\n\n\t\tebitmap_destroy(&ctx_new.range.level[0].cat);\n\t} else\n\t\t*sid = SECSID_NULL;\n\n\tread_unlock(&policy_rwlock);\n\treturn 0;\nout_free:\n\tebitmap_destroy(&ctx_new.range.level[0].cat);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
  },
  {
    "function_name": "security_netlbl_cache_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3404-3422",
    "snippet": "static void security_netlbl_cache_add(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t      u32 sid)\n{\n\tu32 *sid_cache;\n\n\tsid_cache = kmalloc(sizeof(*sid_cache), GFP_ATOMIC);\n\tif (sid_cache == NULL)\n\t\treturn;\n\tsecattr->cache = netlbl_secattr_cache_alloc(GFP_ATOMIC);\n\tif (secattr->cache == NULL) {\n\t\tkfree(sid_cache);\n\t\treturn;\n\t}\n\n\t*sid_cache = sid;\n\tsecattr->cache->free = kfree;\n\tsecattr->cache->data = sid_cache;\n\tsecattr->flags |= NETLBL_SECATTR_CACHE;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sid_cache"
          ],
          "line": 3414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_secattr_cache_alloc",
          "args": [
            "GFP_ATOMIC"
          ],
          "line": 3412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*sid_cache)",
            "GFP_ATOMIC"
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void security_netlbl_cache_add(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t      u32 sid)\n{\n\tu32 *sid_cache;\n\n\tsid_cache = kmalloc(sizeof(*sid_cache), GFP_ATOMIC);\n\tif (sid_cache == NULL)\n\t\treturn;\n\tsecattr->cache = netlbl_secattr_cache_alloc(GFP_ATOMIC);\n\tif (secattr->cache == NULL) {\n\t\tkfree(sid_cache);\n\t\treturn;\n\t}\n\n\t*sid_cache = sid;\n\tsecattr->cache->free = kfree;\n\tsecattr->cache->data = sid_cache;\n\tsecattr->flags |= NETLBL_SECATTR_CACHE;\n}"
  },
  {
    "function_name": "aurule_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3380-3389",
    "snippet": "static int __init aurule_init(void)\n{\n\tint err;\n\n\terr = avc_add_callback(aurule_avc_callback, AVC_CALLBACK_RESET);\n\tif (err)\n\t\tpanic(\"avc_add_callback() failed, error %d\\n\", err);\n\n\treturn err;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"avc_add_callback() failed, error %d\\n\"",
            "err"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_add_callback",
          "args": [
            "aurule_avc_callback",
            "AVC_CALLBACK_RESET"
          ],
          "line": 3384
        },
        "resolved": true,
        "details": {
          "function_name": "avc_add_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "784-801",
          "snippet": "int __init avc_add_callback(int (*callback)(u32 event), u32 events)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0;\n\n\tc = kmalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tc->callback = callback;\n\tc->events = events;\n\tc->next = avc_callbacks;\n\tavc_callbacks = c;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_callback_node *avc_callbacks;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_callback_node *avc_callbacks;\nstatic noinline struct;\n\nint __init avc_add_callback(int (*callback)(u32 event), u32 events)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0;\n\n\tc = kmalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tc->callback = callback;\n\tc->events = events;\n\tc->next = avc_callbacks;\n\tavc_callbacks = c;\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int __init aurule_init(void)\n{\n\tint err;\n\n\terr = avc_add_callback(aurule_avc_callback, AVC_CALLBACK_RESET);\n\tif (err)\n\t\tpanic(\"avc_add_callback() failed, error %d\\n\", err);\n\n\treturn err;\n}"
  },
  {
    "function_name": "aurule_avc_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3371-3378",
    "snippet": "static int aurule_avc_callback(u32 event)\n{\n\tint err = 0;\n\n\tif (event == AVC_CALLBACK_RESET && aurule_callback)\n\t\terr = aurule_callback();\n\treturn err;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int (*aurule_callback)(void) = audit_update_lsm_rules;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aurule_callback",
          "args": [],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int (*aurule_callback)(void) = audit_update_lsm_rules;\n\nstatic int aurule_avc_callback(u32 event)\n{\n\tint err = 0;\n\n\tif (event == AVC_CALLBACK_RESET && aurule_callback)\n\t\terr = aurule_callback();\n\treturn err;\n}"
  },
  {
    "function_name": "selinux_audit_rule_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3261-3367",
    "snippet": "int selinux_audit_rule_match(u32 sid, u32 field, u32 op, void *vrule,\n\t\t\t     struct audit_context *actx)\n{\n\tstruct context *ctxt;\n\tstruct mls_level *level;\n\tstruct selinux_audit_rule *rule = vrule;\n\tint match = 0;\n\n\tif (unlikely(!rule)) {\n\t\tWARN_ONCE(1, \"selinux_audit_rule_match: missing rule\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tread_lock(&policy_rwlock);\n\n\tif (rule->au_seqno < latest_granting) {\n\t\tmatch = -ESTALE;\n\t\tgoto out;\n\t}\n\n\tctxt = sidtab_search(&sidtab, sid);\n\tif (unlikely(!ctxt)) {\n\t\tWARN_ONCE(1, \"selinux_audit_rule_match: unrecognized SID %d\\n\",\n\t\t\t  sid);\n\t\tmatch = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* a field/op pair that is not caught here will simply fall through\n\t   without a match */\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_OBJ_USER:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->user == rule->au_ctxt.user);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->user != rule->au_ctxt.user);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_OBJ_ROLE:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->role == rule->au_ctxt.role);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->role != rule->au_ctxt.role);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_TYPE:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->type == rule->au_ctxt.type);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->type != rule->au_ctxt.type);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tlevel = ((field == AUDIT_SUBJ_SEN ||\n\t\t\t  field == AUDIT_OBJ_LEV_LOW) ?\n\t\t\t &ctxt->range.level[0] : &ctxt->range.level[1]);\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t     level);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = !mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t      level);\n\t\t\tbreak;\n\t\tcase Audit_lt:\n\t\t\tmatch = (mls_level_dom(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t       level) &&\n\t\t\t\t !mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t       level));\n\t\t\tbreak;\n\t\tcase Audit_le:\n\t\t\tmatch = mls_level_dom(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t      level);\n\t\t\tbreak;\n\t\tcase Audit_gt:\n\t\t\tmatch = (mls_level_dom(level,\n\t\t\t\t\t      &rule->au_ctxt.range.level[0]) &&\n\t\t\t\t !mls_level_eq(level,\n\t\t\t\t\t       &rule->au_ctxt.range.level[0]));\n\t\t\tbreak;\n\t\tcase Audit_ge:\n\t\t\tmatch = mls_level_dom(level,\n\t\t\t\t\t      &rule->au_ctxt.range.level[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn match;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "static u32 latest_granting;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3365
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_level_dom",
          "args": [
            "level",
            "&rule->au_ctxt.range.level[0]"
          ],
          "line": 3358
        },
        "resolved": true,
        "details": {
          "function_name": "mls_level_dom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls_types.h",
          "lines": "36-40",
          "snippet": "static inline int mls_level_dom(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens >= l2->sens) &&\n\t\tebitmap_contains(&l1->cat, &l2->cat, 0));\n}",
          "includes": [
            "#include \"ebitmap.h\"",
            "#include \"security.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebitmap.h\"\n#include \"security.h\"\n\nstatic inline int mls_level_dom(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens >= l2->sens) &&\n\t\tebitmap_contains(&l1->cat, &l2->cat, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_level_eq",
          "args": [
            "level",
            "&rule->au_ctxt.range.level[0]"
          ],
          "line": 3354
        },
        "resolved": true,
        "details": {
          "function_name": "mls_level_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls_types.h",
          "lines": "30-34",
          "snippet": "static inline int mls_level_eq(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens == l2->sens) &&\n\t\tebitmap_cmp(&l1->cat, &l2->cat));\n}",
          "includes": [
            "#include \"ebitmap.h\"",
            "#include \"security.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebitmap.h\"\n#include \"security.h\"\n\nstatic inline int mls_level_eq(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens == l2->sens) &&\n\t\tebitmap_cmp(&l1->cat, &l2->cat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"selinux_audit_rule_match: unrecognized SID %d\\n\"",
            "sid"
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctxt"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "&sidtab",
            "sid"
          ],
          "line": 3281
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"selinux_audit_rule_match: missing rule\\n\""
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rule"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstatic u32 latest_granting;\n\nint selinux_audit_rule_match(u32 sid, u32 field, u32 op, void *vrule,\n\t\t\t     struct audit_context *actx)\n{\n\tstruct context *ctxt;\n\tstruct mls_level *level;\n\tstruct selinux_audit_rule *rule = vrule;\n\tint match = 0;\n\n\tif (unlikely(!rule)) {\n\t\tWARN_ONCE(1, \"selinux_audit_rule_match: missing rule\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tread_lock(&policy_rwlock);\n\n\tif (rule->au_seqno < latest_granting) {\n\t\tmatch = -ESTALE;\n\t\tgoto out;\n\t}\n\n\tctxt = sidtab_search(&sidtab, sid);\n\tif (unlikely(!ctxt)) {\n\t\tWARN_ONCE(1, \"selinux_audit_rule_match: unrecognized SID %d\\n\",\n\t\t\t  sid);\n\t\tmatch = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* a field/op pair that is not caught here will simply fall through\n\t   without a match */\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_OBJ_USER:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->user == rule->au_ctxt.user);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->user != rule->au_ctxt.user);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_OBJ_ROLE:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->role == rule->au_ctxt.role);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->role != rule->au_ctxt.role);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_TYPE:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->type == rule->au_ctxt.type);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->type != rule->au_ctxt.type);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tlevel = ((field == AUDIT_SUBJ_SEN ||\n\t\t\t  field == AUDIT_OBJ_LEV_LOW) ?\n\t\t\t &ctxt->range.level[0] : &ctxt->range.level[1]);\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t     level);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = !mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t      level);\n\t\t\tbreak;\n\t\tcase Audit_lt:\n\t\t\tmatch = (mls_level_dom(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t       level) &&\n\t\t\t\t !mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t       level));\n\t\t\tbreak;\n\t\tcase Audit_le:\n\t\t\tmatch = mls_level_dom(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t      level);\n\t\t\tbreak;\n\t\tcase Audit_gt:\n\t\t\tmatch = (mls_level_dom(level,\n\t\t\t\t\t      &rule->au_ctxt.range.level[0]) &&\n\t\t\t\t !mls_level_eq(level,\n\t\t\t\t\t       &rule->au_ctxt.range.level[0]));\n\t\t\tbreak;\n\t\tcase Audit_ge:\n\t\t\tmatch = mls_level_dom(level,\n\t\t\t\t\t      &rule->au_ctxt.range.level[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn match;\n}"
  },
  {
    "function_name": "selinux_audit_rule_known",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3237-3259",
    "snippet": "int selinux_audit_rule_known(struct audit_krule *rule)\n{\n\tint i;\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tswitch (f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint selinux_audit_rule_known(struct audit_krule *rule)\n{\n\tint i;\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tswitch (f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "selinux_audit_rule_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3140-3234",
    "snippet": "int selinux_audit_rule_init(u32 field, u32 op, char *rulestr, void **vrule)\n{\n\tstruct selinux_audit_rule *tmprule;\n\tstruct role_datum *roledatum;\n\tstruct type_datum *typedatum;\n\tstruct user_datum *userdatum;\n\tstruct selinux_audit_rule **rule = (struct selinux_audit_rule **)vrule;\n\tint rc = 0;\n\n\t*rule = NULL;\n\n\tif (!ss_initialized)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\t\t/* only 'equals' and 'not equals' fit user, role, and type */\n\t\tif (op != Audit_equal && op != Audit_not_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t/* we do not allow a range, indicated by the presence of '-' */\n\t\tif (strchr(rulestr, '-'))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\t/* only the above fields are valid */\n\t\treturn -EINVAL;\n\t}\n\n\ttmprule = kzalloc(sizeof(struct selinux_audit_rule), GFP_KERNEL);\n\tif (!tmprule)\n\t\treturn -ENOMEM;\n\n\tcontext_init(&tmprule->au_ctxt);\n\n\tread_lock(&policy_rwlock);\n\n\ttmprule->au_seqno = latest_granting;\n\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_OBJ_USER:\n\t\trc = -EINVAL;\n\t\tuserdatum = hashtab_search(policydb.p_users.table, rulestr);\n\t\tif (!userdatum)\n\t\t\tgoto out;\n\t\ttmprule->au_ctxt.user = userdatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_OBJ_ROLE:\n\t\trc = -EINVAL;\n\t\troledatum = hashtab_search(policydb.p_roles.table, rulestr);\n\t\tif (!roledatum)\n\t\t\tgoto out;\n\t\ttmprule->au_ctxt.role = roledatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_TYPE:\n\t\trc = -EINVAL;\n\t\ttypedatum = hashtab_search(policydb.p_types.table, rulestr);\n\t\tif (!typedatum)\n\t\t\tgoto out;\n\t\ttmprule->au_ctxt.type = typedatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\trc = mls_from_string(rulestr, &tmprule->au_ctxt, GFP_ATOMIC);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\n\tif (rc) {\n\t\tselinux_audit_rule_free(tmprule);\n\t\ttmprule = NULL;\n\t}\n\n\t*rule = tmprule;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "struct policydb policydb;",
      "int ss_initialized;",
      "static u32 latest_granting;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_audit_rule_free",
          "args": [
            "tmprule"
          ],
          "line": 3227
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_audit_rule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3130-3138",
          "snippet": "void selinux_audit_rule_free(void *vrule)\n{\n\tstruct selinux_audit_rule *rule = vrule;\n\n\tif (rule) {\n\t\tcontext_destroy(&rule->au_ctxt);\n\t\tkfree(rule);\n\t}\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid selinux_audit_rule_free(void *vrule)\n{\n\tstruct selinux_audit_rule *rule = vrule;\n\n\tif (rule) {\n\t\tcontext_destroy(&rule->au_ctxt);\n\t\tkfree(rule);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_from_string",
          "args": [
            "rulestr",
            "&tmprule->au_ctxt",
            "GFP_ATOMIC"
          ],
          "line": 3217
        },
        "resolved": true,
        "details": {
          "function_name": "mls_from_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "378-398",
          "snippet": "int mls_from_string(char *str, struct context *context, gfp_t gfp_mask)\n{\n\tchar *tmpstr, *freestr;\n\tint rc;\n\n\tif (!policydb.mls_enabled)\n\t\treturn -EINVAL;\n\n\t/* we need freestr because mls_context_to_sid will change\n\t   the value of tmpstr */\n\ttmpstr = freestr = kstrdup(str, gfp_mask);\n\tif (!tmpstr) {\n\t\trc = -ENOMEM;\n\t} else {\n\t\trc = mls_context_to_sid(&policydb, ':', &tmpstr, context,\n\t\t\t\t\tNULL, SECSID_NULL);\n\t\tkfree(freestr);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_from_string(char *str, struct context *context, gfp_t gfp_mask)\n{\n\tchar *tmpstr, *freestr;\n\tint rc;\n\n\tif (!policydb.mls_enabled)\n\t\treturn -EINVAL;\n\n\t/* we need freestr because mls_context_to_sid will change\n\t   the value of tmpstr */\n\ttmpstr = freestr = kstrdup(str, gfp_mask);\n\tif (!tmpstr) {\n\t\trc = -ENOMEM;\n\t} else {\n\t\trc = mls_context_to_sid(&policydb, ':', &tmpstr, context,\n\t\t\t\t\tNULL, SECSID_NULL);\n\t\tkfree(freestr);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "policydb.p_types.table",
            "rulestr"
          ],
          "line": 3208
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_init",
          "args": [
            "&tmprule->au_ctxt"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "context_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "113-116",
          "snippet": "static inline void context_init(struct context *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_init(struct context *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct selinux_audit_rule)",
            "GFP_KERNEL"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "rulestr",
            "'-'"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\nint ss_initialized;\nstatic u32 latest_granting;\n\nint selinux_audit_rule_init(u32 field, u32 op, char *rulestr, void **vrule)\n{\n\tstruct selinux_audit_rule *tmprule;\n\tstruct role_datum *roledatum;\n\tstruct type_datum *typedatum;\n\tstruct user_datum *userdatum;\n\tstruct selinux_audit_rule **rule = (struct selinux_audit_rule **)vrule;\n\tint rc = 0;\n\n\t*rule = NULL;\n\n\tif (!ss_initialized)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\t\t/* only 'equals' and 'not equals' fit user, role, and type */\n\t\tif (op != Audit_equal && op != Audit_not_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t/* we do not allow a range, indicated by the presence of '-' */\n\t\tif (strchr(rulestr, '-'))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\t/* only the above fields are valid */\n\t\treturn -EINVAL;\n\t}\n\n\ttmprule = kzalloc(sizeof(struct selinux_audit_rule), GFP_KERNEL);\n\tif (!tmprule)\n\t\treturn -ENOMEM;\n\n\tcontext_init(&tmprule->au_ctxt);\n\n\tread_lock(&policy_rwlock);\n\n\ttmprule->au_seqno = latest_granting;\n\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_OBJ_USER:\n\t\trc = -EINVAL;\n\t\tuserdatum = hashtab_search(policydb.p_users.table, rulestr);\n\t\tif (!userdatum)\n\t\t\tgoto out;\n\t\ttmprule->au_ctxt.user = userdatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_OBJ_ROLE:\n\t\trc = -EINVAL;\n\t\troledatum = hashtab_search(policydb.p_roles.table, rulestr);\n\t\tif (!roledatum)\n\t\t\tgoto out;\n\t\ttmprule->au_ctxt.role = roledatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_TYPE:\n\t\trc = -EINVAL;\n\t\ttypedatum = hashtab_search(policydb.p_types.table, rulestr);\n\t\tif (!typedatum)\n\t\t\tgoto out;\n\t\ttmprule->au_ctxt.type = typedatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\trc = mls_from_string(rulestr, &tmprule->au_ctxt, GFP_ATOMIC);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\n\tif (rc) {\n\t\tselinux_audit_rule_free(tmprule);\n\t\ttmprule = NULL;\n\t}\n\n\t*rule = tmprule;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "selinux_audit_rule_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3130-3138",
    "snippet": "void selinux_audit_rule_free(void *vrule)\n{\n\tstruct selinux_audit_rule *rule = vrule;\n\n\tif (rule) {\n\t\tcontext_destroy(&rule->au_ctxt);\n\t\tkfree(rule);\n\t}\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rule"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_destroy",
          "args": [
            "&rule->au_ctxt"
          ],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "context_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "142-149",
          "snippet": "static inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid selinux_audit_rule_free(void *vrule)\n{\n\tstruct selinux_audit_rule *rule = vrule;\n\n\tif (rule) {\n\t\tcontext_destroy(&rule->au_ctxt);\n\t\tkfree(rule);\n\t}\n}"
  },
  {
    "function_name": "security_policycap_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3114-3123",
    "snippet": "int security_policycap_supported(unsigned int req_cap)\n{\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\trc = ebitmap_get_bit(&policydb.policycaps, req_cap);\n\tread_unlock(&policy_rwlock);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3120
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_get_bit",
          "args": [
            "&policydb.policycaps",
            "req_cap"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_get_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "242-257",
          "snippet": "int ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nint security_policycap_supported(unsigned int req_cap)\n{\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\trc = ebitmap_get_bit(&policydb.policycaps, req_cap);\n\tread_unlock(&policy_rwlock);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "security_get_allow_unknown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3099-3102",
    "snippet": "int security_get_allow_unknown(void)\n{\n\treturn policydb.allow_unknown;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct policydb policydb;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nint security_get_allow_unknown(void)\n{\n\treturn policydb.allow_unknown;\n}"
  },
  {
    "function_name": "security_get_reject_unknown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3094-3097",
    "snippet": "int security_get_reject_unknown(void)\n{\n\treturn policydb.reject_unknown;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct policydb policydb;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nint security_get_reject_unknown(void)\n{\n\treturn policydb.reject_unknown;\n}"
  },
  {
    "function_name": "security_get_permissions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3049-3092",
    "snippet": "int security_get_permissions(char *class, char ***perms, int *nperms)\n{\n\tint rc, i;\n\tstruct class_datum *match;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tmatch = hashtab_search(policydb.p_classes.table, class);\n\tif (!match) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized class %s\\n\",\n\t\t\t__func__, class);\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\t*nperms = match->permissions.nprim;\n\t*perms = kcalloc(*nperms, sizeof(**perms), GFP_ATOMIC);\n\tif (!*perms)\n\t\tgoto out;\n\n\tif (match->comdatum) {\n\t\trc = hashtab_map(match->comdatum->permissions.table,\n\t\t\t\tget_permissions_callback, *perms);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\trc = hashtab_map(match->permissions.table, get_permissions_callback,\n\t\t\t*perms);\n\tif (rc)\n\t\tgoto err;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n\nerr:\n\tread_unlock(&policy_rwlock);\n\tfor (i = 0; i < *nperms; i++)\n\t\tkfree((*perms)[i]);\n\tkfree(*perms);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*perms"
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(*perms)[i]"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_map",
          "args": [
            "match->permissions.table",
            "get_permissions_callback",
            "*perms"
          ],
          "line": 3077
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "123-144",
          "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "*nperms",
            "sizeof(**perms)",
            "GFP_ATOMIC"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized class %s\\n\"",
            "__func__",
            "class"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "policydb.p_classes.table",
            "class"
          ],
          "line": 3057
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nint security_get_permissions(char *class, char ***perms, int *nperms)\n{\n\tint rc, i;\n\tstruct class_datum *match;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tmatch = hashtab_search(policydb.p_classes.table, class);\n\tif (!match) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized class %s\\n\",\n\t\t\t__func__, class);\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\t*nperms = match->permissions.nprim;\n\t*perms = kcalloc(*nperms, sizeof(**perms), GFP_ATOMIC);\n\tif (!*perms)\n\t\tgoto out;\n\n\tif (match->comdatum) {\n\t\trc = hashtab_map(match->comdatum->permissions.table,\n\t\t\t\tget_permissions_callback, *perms);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\trc = hashtab_map(match->permissions.table, get_permissions_callback,\n\t\t\t*perms);\n\tif (rc)\n\t\tgoto err;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n\nerr:\n\tread_unlock(&policy_rwlock);\n\tfor (i = 0; i < *nperms; i++)\n\t\tkfree((*perms)[i]);\n\tkfree(*perms);\n\treturn rc;\n}"
  },
  {
    "function_name": "get_permissions_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3036-3047",
    "snippet": "static int get_permissions_callback(void *k, void *d, void *args)\n{\n\tstruct perm_datum *datum = d;\n\tchar *name = k, **perms = args;\n\tint value = datum->value - 1;\n\n\tperms[value] = kstrdup(name, GFP_ATOMIC);\n\tif (!perms[value])\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_ATOMIC"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int get_permissions_callback(void *k, void *d, void *args)\n{\n\tstruct perm_datum *datum = d;\n\tchar *name = k, **perms = args;\n\tint value = datum->value - 1;\n\n\tperms[value] = kstrdup(name, GFP_ATOMIC);\n\tif (!perms[value])\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "security_get_classes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "3010-3034",
    "snippet": "int security_get_classes(char ***classes, int *nclasses)\n{\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOMEM;\n\t*nclasses = policydb.p_classes.nprim;\n\t*classes = kcalloc(*nclasses, sizeof(**classes), GFP_ATOMIC);\n\tif (!*classes)\n\t\tgoto out;\n\n\trc = hashtab_map(policydb.p_classes.table, get_classes_callback,\n\t\t\t*classes);\n\tif (rc) {\n\t\tint i;\n\t\tfor (i = 0; i < *nclasses; i++)\n\t\t\tkfree((*classes)[i]);\n\t\tkfree(*classes);\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3032
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*classes"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(*classes)[i]"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashtab_map",
          "args": [
            "policydb.p_classes.table",
            "get_classes_callback",
            "*classes"
          ],
          "line": 3022
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "123-144",
          "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "*nclasses",
            "sizeof(**classes)",
            "GFP_ATOMIC"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nint security_get_classes(char ***classes, int *nclasses)\n{\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOMEM;\n\t*nclasses = policydb.p_classes.nprim;\n\t*classes = kcalloc(*nclasses, sizeof(**classes), GFP_ATOMIC);\n\tif (!*classes)\n\t\tgoto out;\n\n\trc = hashtab_map(policydb.p_classes.table, get_classes_callback,\n\t\t\t*classes);\n\tif (rc) {\n\t\tint i;\n\t\tfor (i = 0; i < *nclasses; i++)\n\t\t\tkfree((*classes)[i]);\n\t\tkfree(*classes);\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
  },
  {
    "function_name": "get_classes_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2997-3008",
    "snippet": "static int get_classes_callback(void *k, void *d, void *args)\n{\n\tstruct class_datum *datum = d;\n\tchar *name = k, **classes = args;\n\tint value = datum->value - 1;\n\n\tclasses[value] = kstrdup(name, GFP_ATOMIC);\n\tif (!classes[value])\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_ATOMIC"
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int get_classes_callback(void *k, void *d, void *args)\n{\n\tstruct class_datum *datum = d;\n\tchar *name = k, **classes = args;\n\tint value = datum->value - 1;\n\n\tclasses[value] = kstrdup(name, GFP_ATOMIC);\n\tif (!classes[value])\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "security_net_peersid_resolve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2935-2995",
    "snippet": "int security_net_peersid_resolve(u32 nlbl_sid, u32 nlbl_type,\n\t\t\t\t u32 xfrm_sid,\n\t\t\t\t u32 *peer_sid)\n{\n\tint rc;\n\tstruct context *nlbl_ctx;\n\tstruct context *xfrm_ctx;\n\n\t*peer_sid = SECSID_NULL;\n\n\t/* handle the common (which also happens to be the set of easy) cases\n\t * right away, these two if statements catch everything involving a\n\t * single or absent peer SID/label */\n\tif (xfrm_sid == SECSID_NULL) {\n\t\t*peer_sid = nlbl_sid;\n\t\treturn 0;\n\t}\n\t/* NOTE: an nlbl_type == NETLBL_NLTYPE_UNLABELED is a \"fallback\" label\n\t * and is treated as if nlbl_sid == SECSID_NULL when a XFRM SID/label\n\t * is present */\n\tif (nlbl_sid == SECSID_NULL || nlbl_type == NETLBL_NLTYPE_UNLABELED) {\n\t\t*peer_sid = xfrm_sid;\n\t\treturn 0;\n\t}\n\n\t/* we don't need to check ss_initialized here since the only way both\n\t * nlbl_sid and xfrm_sid are not equal to SECSID_NULL would be if the\n\t * security server was initialized and ss_initialized was true */\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tnlbl_ctx = sidtab_search(&sidtab, nlbl_sid);\n\tif (!nlbl_ctx) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, nlbl_sid);\n\t\tgoto out;\n\t}\n\trc = -EINVAL;\n\txfrm_ctx = sidtab_search(&sidtab, xfrm_sid);\n\tif (!xfrm_ctx) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, xfrm_sid);\n\t\tgoto out;\n\t}\n\trc = (mls_context_cmp(nlbl_ctx, xfrm_ctx) ? 0 : -EACCES);\n\tif (rc)\n\t\tgoto out;\n\n\t/* at present NetLabel SIDs/labels really only carry MLS\n\t * information so if the MLS portion of the NetLabel SID\n\t * matches the MLS portion of the labeled XFRM SID/label\n\t * then pass along the XFRM SID as it is the most\n\t * expressive */\n\t*peer_sid = xfrm_sid;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;",
      "int ss_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2993
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_context_cmp",
          "args": [
            "nlbl_ctx",
            "xfrm_ctx"
          ],
          "line": 2982
        },
        "resolved": true,
        "details": {
          "function_name": "mls_context_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "98-104",
          "snippet": "static inline int mls_context_cmp(struct context *c1, struct context *c2)\n{\n\treturn ((c1->range.level[0].sens == c2->range.level[0].sens) &&\n\t\tebitmap_cmp(&c1->range.level[0].cat, &c2->range.level[0].cat) &&\n\t\t(c1->range.level[1].sens == c2->range.level[1].sens) &&\n\t\tebitmap_cmp(&c1->range.level[1].cat, &c2->range.level[1].cat));\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline int mls_context_cmp(struct context *c1, struct context *c2)\n{\n\treturn ((c1->range.level[0].sens == c2->range.level[0].sens) &&\n\t\tebitmap_cmp(&c1->range.level[0].cat, &c2->range.level[0].cat) &&\n\t\t(c1->range.level[1].sens == c2->range.level[1].sens) &&\n\t\tebitmap_cmp(&c1->range.level[1].cat, &c2->range.level[1].cat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "xfrm_sid"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "&sidtab",
            "xfrm_sid"
          ],
          "line": 2976
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "nlbl_sid"
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nint security_net_peersid_resolve(u32 nlbl_sid, u32 nlbl_type,\n\t\t\t\t u32 xfrm_sid,\n\t\t\t\t u32 *peer_sid)\n{\n\tint rc;\n\tstruct context *nlbl_ctx;\n\tstruct context *xfrm_ctx;\n\n\t*peer_sid = SECSID_NULL;\n\n\t/* handle the common (which also happens to be the set of easy) cases\n\t * right away, these two if statements catch everything involving a\n\t * single or absent peer SID/label */\n\tif (xfrm_sid == SECSID_NULL) {\n\t\t*peer_sid = nlbl_sid;\n\t\treturn 0;\n\t}\n\t/* NOTE: an nlbl_type == NETLBL_NLTYPE_UNLABELED is a \"fallback\" label\n\t * and is treated as if nlbl_sid == SECSID_NULL when a XFRM SID/label\n\t * is present */\n\tif (nlbl_sid == SECSID_NULL || nlbl_type == NETLBL_NLTYPE_UNLABELED) {\n\t\t*peer_sid = xfrm_sid;\n\t\treturn 0;\n\t}\n\n\t/* we don't need to check ss_initialized here since the only way both\n\t * nlbl_sid and xfrm_sid are not equal to SECSID_NULL would be if the\n\t * security server was initialized and ss_initialized was true */\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tnlbl_ctx = sidtab_search(&sidtab, nlbl_sid);\n\tif (!nlbl_ctx) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, nlbl_sid);\n\t\tgoto out;\n\t}\n\trc = -EINVAL;\n\txfrm_ctx = sidtab_search(&sidtab, xfrm_sid);\n\tif (!xfrm_ctx) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, xfrm_sid);\n\t\tgoto out;\n\t}\n\trc = (mls_context_cmp(nlbl_ctx, xfrm_ctx) ? 0 : -EACCES);\n\tif (rc)\n\t\tgoto out;\n\n\t/* at present NetLabel SIDs/labels really only carry MLS\n\t * information so if the MLS portion of the NetLabel SID\n\t * matches the MLS portion of the labeled XFRM SID/label\n\t * then pass along the XFRM SID as it is the most\n\t * expressive */\n\t*peer_sid = xfrm_sid;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
  },
  {
    "function_name": "security_sid_mls_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2850-2913",
    "snippet": "int security_sid_mls_copy(u32 sid, u32 mls_sid, u32 *new_sid)\n{\n\tstruct context *context1;\n\tstruct context *context2;\n\tstruct context newcon;\n\tchar *s;\n\tu32 len;\n\tint rc;\n\n\trc = 0;\n\tif (!ss_initialized || !policydb.mls_enabled) {\n\t\t*new_sid = sid;\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcon);\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tcontext1 = sidtab_search(&sidtab, sid);\n\tif (!context1) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\tgoto out_unlock;\n\t}\n\n\trc = -EINVAL;\n\tcontext2 = sidtab_search(&sidtab, mls_sid);\n\tif (!context2) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, mls_sid);\n\t\tgoto out_unlock;\n\t}\n\n\tnewcon.user = context1->user;\n\tnewcon.role = context1->role;\n\tnewcon.type = context1->type;\n\trc = mls_context_cpy(&newcon, context2);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(&policydb, &newcon)) {\n\t\trc = convert_context_handle_invalid_context(&newcon);\n\t\tif (rc) {\n\t\t\tif (!context_struct_to_string(&newcon, &s, &len)) {\n\t\t\t\taudit_log(current->audit_context,\n\t\t\t\t\t  GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t\t\t  \"op=security_sid_mls_copy \"\n\t\t\t\t\t  \"invalid_context=%s\", s);\n\t\t\t\tkfree(s);\n\t\t\t}\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\trc = sidtab_context_to_sid(&sidtab, &newcon, new_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcon);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;",
      "int ss_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_destroy",
          "args": [
            "&newcon"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "context_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "142-149",
          "snippet": "static inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_context_to_sid",
          "args": [
            "&sidtab",
            "&newcon",
            "new_sid"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "191-232",
          "snippet": "int sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "current->audit_context",
            "GFP_ATOMIC",
            "AUDIT_SELINUX_ERR",
            "\"op=security_sid_mls_copy \"\n\t\t\t\t\t  \"invalid_context=%s\"",
            "s"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_struct_to_string",
          "args": [
            "&newcon",
            "&s",
            "&len"
          ],
          "line": 2896
        },
        "resolved": true,
        "details": {
          "function_name": "context_struct_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1192-1238",
          "snippet": "static int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_context_handle_invalid_context",
          "args": [
            "&newcon"
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "convert_context_handle_invalid_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1831-1844",
          "snippet": "static inline int convert_context_handle_invalid_context(struct context *context)\n{\n\tchar *s;\n\tu32 len;\n\n\tif (selinux_enforcing)\n\t\treturn -EINVAL;\n\n\tif (!context_struct_to_string(context, &s, &len)) {\n\t\tprintk(KERN_WARNING \"SELinux:  Context %s would be invalid if enforcing\\n\", s);\n\t\tkfree(s);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int convert_context_handle_invalid_context(struct context *context)\n{\n\tchar *s;\n\tu32 len;\n\n\tif (selinux_enforcing)\n\t\treturn -EINVAL;\n\n\tif (!context_struct_to_string(context, &s, &len)) {\n\t\tprintk(KERN_WARNING \"SELinux:  Context %s would be invalid if enforcing\\n\", s);\n\t\tkfree(s);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "policydb_context_isvalid",
          "args": [
            "&policydb",
            "&newcon"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_context_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "950-989",
          "snippet": "int policydb_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct role_datum *role;\n\tstruct user_datum *usrdatum;\n\n\tif (!c->role || c->role > p->p_roles.nprim)\n\t\treturn 0;\n\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\n\tif (!c->type || c->type > p->p_types.nprim)\n\t\treturn 0;\n\n\tif (c->role != OBJECT_R_VAL) {\n\t\t/*\n\t\t * Role must be authorized for the type.\n\t\t */\n\t\trole = p->role_val_to_struct[c->role - 1];\n\t\tif (!role || !ebitmap_get_bit(&role->types, c->type - 1))\n\t\t\t/* role may not be associated with type */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * User must be authorized for the role.\n\t\t */\n\t\tusrdatum = p->user_val_to_struct[c->user - 1];\n\t\tif (!usrdatum)\n\t\t\treturn 0;\n\n\t\tif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\n\t\t\t/* user may not be associated with role */\n\t\t\treturn 0;\n\t}\n\n\tif (!mls_context_isvalid(p, c))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct role_datum *role;\n\tstruct user_datum *usrdatum;\n\n\tif (!c->role || c->role > p->p_roles.nprim)\n\t\treturn 0;\n\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\n\tif (!c->type || c->type > p->p_types.nprim)\n\t\treturn 0;\n\n\tif (c->role != OBJECT_R_VAL) {\n\t\t/*\n\t\t * Role must be authorized for the type.\n\t\t */\n\t\trole = p->role_val_to_struct[c->role - 1];\n\t\tif (!role || !ebitmap_get_bit(&role->types, c->type - 1))\n\t\t\t/* role may not be associated with type */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * User must be authorized for the role.\n\t\t */\n\t\tusrdatum = p->user_val_to_struct[c->user - 1];\n\t\tif (!usrdatum)\n\t\t\treturn 0;\n\n\t\tif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\n\t\t\t/* user may not be associated with role */\n\t\t\treturn 0;\n\t}\n\n\tif (!mls_context_isvalid(p, c))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_context_cpy",
          "args": [
            "&newcon",
            "context2"
          ],
          "line": 2888
        },
        "resolved": true,
        "details": {
          "function_name": "mls_context_cpy_high",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "81-96",
          "snippet": "static inline int mls_context_cpy_high(struct context *dst, struct context *src)\n{\n\tint rc;\n\n\tdst->range.level[0].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[0].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tgoto out;\n\n\tdst->range.level[1].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[1].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tebitmap_destroy(&dst->range.level[0].cat);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline int mls_context_cpy_high(struct context *dst, struct context *src)\n{\n\tint rc;\n\n\tdst->range.level[0].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[0].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tgoto out;\n\n\tdst->range.level[1].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[1].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tebitmap_destroy(&dst->range.level[0].cat);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "mls_sid"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "&sidtab",
            "mls_sid"
          ],
          "line": 2878
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "sid"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_init",
          "args": [
            "&newcon"
          ],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "context_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "113-116",
          "snippet": "static inline void context_init(struct context *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_init(struct context *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nint security_sid_mls_copy(u32 sid, u32 mls_sid, u32 *new_sid)\n{\n\tstruct context *context1;\n\tstruct context *context2;\n\tstruct context newcon;\n\tchar *s;\n\tu32 len;\n\tint rc;\n\n\trc = 0;\n\tif (!ss_initialized || !policydb.mls_enabled) {\n\t\t*new_sid = sid;\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcon);\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tcontext1 = sidtab_search(&sidtab, sid);\n\tif (!context1) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\tgoto out_unlock;\n\t}\n\n\trc = -EINVAL;\n\tcontext2 = sidtab_search(&sidtab, mls_sid);\n\tif (!context2) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, mls_sid);\n\t\tgoto out_unlock;\n\t}\n\n\tnewcon.user = context1->user;\n\tnewcon.role = context1->role;\n\tnewcon.type = context1->type;\n\trc = mls_context_cpy(&newcon, context2);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(&policydb, &newcon)) {\n\t\trc = convert_context_handle_invalid_context(&newcon);\n\t\tif (rc) {\n\t\t\tif (!context_struct_to_string(&newcon, &s, &len)) {\n\t\t\t\taudit_log(current->audit_context,\n\t\t\t\t\t  GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t\t\t  \"op=security_sid_mls_copy \"\n\t\t\t\t\t  \"invalid_context=%s\", s);\n\t\t\t\tkfree(s);\n\t\t\t}\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\trc = sidtab_context_to_sid(&sidtab, &newcon, new_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcon);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "security_preserve_bools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2815-2844",
    "snippet": "static int security_preserve_bools(struct policydb *p)\n{\n\tint rc, nbools = 0, *bvalues = NULL, i;\n\tchar **bnames = NULL;\n\tstruct cond_bool_datum *booldatum;\n\tstruct cond_node *cur;\n\n\trc = security_get_bools(&nbools, &bnames, &bvalues);\n\tif (rc)\n\t\tgoto out;\n\tfor (i = 0; i < nbools; i++) {\n\t\tbooldatum = hashtab_search(p->p_bools.table, bnames[i]);\n\t\tif (booldatum)\n\t\t\tbooldatum->state = bvalues[i];\n\t}\n\tfor (cur = p->cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(p, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (bnames) {\n\t\tfor (i = 0; i < nbools; i++)\n\t\t\tkfree(bnames[i]);\n\t}\n\tkfree(bnames);\n\tkfree(bvalues);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct policydb policydb;",
      "static int security_preserve_bools(struct policydb *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bvalues"
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bnames"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bnames[i]"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evaluate_cond_node",
          "args": [
            "p",
            "cur"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate_cond_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "90-117",
          "snippet": "int evaluate_cond_node(struct policydb *p, struct cond_node *node)\n{\n\tint new_state;\n\tstruct cond_av_list *cur;\n\n\tnew_state = cond_evaluate_expr(p, node->expr);\n\tif (new_state != node->cur_state) {\n\t\tnode->cur_state = new_state;\n\t\tif (new_state == -1)\n\t\t\tprintk(KERN_ERR \"SELinux: expression result was undefined - disabling all rules.\\n\");\n\t\t/* turn the rules on or off */\n\t\tfor (cur = node->true_list; cur; cur = cur->next) {\n\t\t\tif (new_state <= 0)\n\t\t\t\tcur->node->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tcur->node->key.specified |= AVTAB_ENABLED;\n\t\t}\n\n\t\tfor (cur = node->false_list; cur; cur = cur->next) {\n\t\t\t/* -1 or 1 */\n\t\t\tif (new_state)\n\t\t\t\tcur->node->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tcur->node->key.specified |= AVTAB_ENABLED;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint evaluate_cond_node(struct policydb *p, struct cond_node *node)\n{\n\tint new_state;\n\tstruct cond_av_list *cur;\n\n\tnew_state = cond_evaluate_expr(p, node->expr);\n\tif (new_state != node->cur_state) {\n\t\tnode->cur_state = new_state;\n\t\tif (new_state == -1)\n\t\t\tprintk(KERN_ERR \"SELinux: expression result was undefined - disabling all rules.\\n\");\n\t\t/* turn the rules on or off */\n\t\tfor (cur = node->true_list; cur; cur = cur->next) {\n\t\t\tif (new_state <= 0)\n\t\t\t\tcur->node->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tcur->node->key.specified |= AVTAB_ENABLED;\n\t\t}\n\n\t\tfor (cur = node->false_list; cur; cur = cur->next) {\n\t\t\t/* -1 or 1 */\n\t\t\tif (new_state)\n\t\t\t\tcur->node->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tcur->node->key.specified |= AVTAB_ENABLED;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "p->p_bools.table",
            "bnames[i]"
          ],
          "line": 2826
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_get_bools",
          "args": [
            "&nbools",
            "&bnames",
            "&bvalues"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "security_get_bools",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2703-2745",
          "snippet": "int security_get_bools(int *len, char ***names, int **values)\n{\n\tint i, rc;\n\n\tread_lock(&policy_rwlock);\n\t*names = NULL;\n\t*values = NULL;\n\n\trc = 0;\n\t*len = policydb.p_bools.nprim;\n\tif (!*len)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\t*names = kcalloc(*len, sizeof(char *), GFP_ATOMIC);\n\tif (!*names)\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\t*values = kcalloc(*len, sizeof(int), GFP_ATOMIC);\n\tif (!*values)\n\t\tgoto err;\n\n\tfor (i = 0; i < *len; i++) {\n\t\t(*values)[i] = policydb.bool_val_to_struct[i]->state;\n\n\t\trc = -ENOMEM;\n\t\t(*names)[i] = kstrdup(sym_name(&policydb, SYM_BOOLS, i), GFP_ATOMIC);\n\t\tif (!(*names)[i])\n\t\t\tgoto err;\n\t}\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\nerr:\n\tif (*names) {\n\t\tfor (i = 0; i < *len; i++)\n\t\t\tkfree((*names)[i]);\n\t}\n\tkfree(*values);\n\tgoto out;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nint security_get_bools(int *len, char ***names, int **values)\n{\n\tint i, rc;\n\n\tread_lock(&policy_rwlock);\n\t*names = NULL;\n\t*values = NULL;\n\n\trc = 0;\n\t*len = policydb.p_bools.nprim;\n\tif (!*len)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\t*names = kcalloc(*len, sizeof(char *), GFP_ATOMIC);\n\tif (!*names)\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\t*values = kcalloc(*len, sizeof(int), GFP_ATOMIC);\n\tif (!*values)\n\t\tgoto err;\n\n\tfor (i = 0; i < *len; i++) {\n\t\t(*values)[i] = policydb.bool_val_to_struct[i]->state;\n\n\t\trc = -ENOMEM;\n\t\t(*names)[i] = kstrdup(sym_name(&policydb, SYM_BOOLS, i), GFP_ATOMIC);\n\t\tif (!(*names)[i])\n\t\t\tgoto err;\n\t}\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\nerr:\n\tif (*names) {\n\t\tfor (i = 0; i < *len; i++)\n\t\t\tkfree((*names)[i]);\n\t}\n\tkfree(*values);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic int security_preserve_bools(struct policydb *p);\n\nstatic int security_preserve_bools(struct policydb *p)\n{\n\tint rc, nbools = 0, *bvalues = NULL, i;\n\tchar **bnames = NULL;\n\tstruct cond_bool_datum *booldatum;\n\tstruct cond_node *cur;\n\n\trc = security_get_bools(&nbools, &bnames, &bvalues);\n\tif (rc)\n\t\tgoto out;\n\tfor (i = 0; i < nbools; i++) {\n\t\tbooldatum = hashtab_search(p->p_bools.table, bnames[i]);\n\t\tif (booldatum)\n\t\t\tbooldatum->state = bvalues[i];\n\t}\n\tfor (cur = p->cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(p, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (bnames) {\n\t\tfor (i = 0; i < nbools; i++)\n\t\t\tkfree(bnames[i]);\n\t}\n\tkfree(bnames);\n\tkfree(bvalues);\n\treturn rc;\n}"
  },
  {
    "function_name": "security_get_bool_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2797-2813",
    "snippet": "int security_get_bool_value(int index)\n{\n\tint rc;\n\tint len;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlen = policydb.p_bools.nprim;\n\tif (index >= len)\n\t\tgoto out;\n\n\trc = policydb.bool_val_to_struct[index]->state;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2811
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nint security_get_bool_value(int index)\n{\n\tint rc;\n\tint len;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlen = policydb.p_bools.nprim;\n\tif (index >= len)\n\t\tgoto out;\n\n\trc = policydb.bool_val_to_struct[index]->state;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
  },
  {
    "function_name": "security_set_bools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2748-2795",
    "snippet": "int security_set_bools(int len, int *values)\n{\n\tint i, rc;\n\tint lenp, seqno = 0;\n\tstruct cond_node *cur;\n\n\twrite_lock_irq(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlenp = policydb.p_bools.nprim;\n\tif (len != lenp)\n\t\tgoto out;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!!values[i] != policydb.bool_val_to_struct[i]->state) {\n\t\t\taudit_log(current->audit_context, GFP_ATOMIC,\n\t\t\t\tAUDIT_MAC_CONFIG_CHANGE,\n\t\t\t\t\"bool=%s val=%d old_val=%d auid=%u ses=%u\",\n\t\t\t\tsym_name(&policydb, SYM_BOOLS, i),\n\t\t\t\t!!values[i],\n\t\t\t\tpolicydb.bool_val_to_struct[i]->state,\n\t\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t\taudit_get_sessionid(current));\n\t\t}\n\t\tif (values[i])\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 1;\n\t\telse\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 0;\n\t}\n\n\tfor (cur = policydb.cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(&policydb, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tseqno = ++latest_granting;\n\trc = 0;\nout:\n\twrite_unlock_irq(&policy_rwlock);\n\tif (!rc) {\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_xfrm_notify_policyload();\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "struct policydb policydb;",
      "static u32 latest_granting;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_xfrm_notify_policyload",
          "args": [],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_xfrm_notify_policyload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/xfrm.h",
          "lines": "81-83",
          "snippet": "static inline void selinux_xfrm_notify_policyload(void)\n{\n}",
          "includes": [
            "#include <net/flow.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n\nstatic inline void selinux_xfrm_notify_policyload(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_status_update_policyload",
          "args": [
            "seqno"
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_status_update_policyload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/status.c",
          "lines": "108-126",
          "snippet": "void selinux_status_update_policyload(int seqno)\n{\n\tstruct selinux_kernel_status   *status;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (selinux_status_page) {\n\t\tstatus = page_address(selinux_status_page);\n\n\t\tstatus->sequence++;\n\t\tsmp_wmb();\n\n\t\tstatus->policyload = seqno;\n\t\tstatus->deny_unknown = !security_get_allow_unknown();\n\n\t\tsmp_wmb();\n\t\tstatus->sequence++;\n\t}\n\tmutex_unlock(&selinux_status_lock);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"avc.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct page *selinux_status_page;",
            "static DEFINE_MUTEX(selinux_status_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"avc.h\"\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n\nstatic struct page *selinux_status_page;\nstatic DEFINE_MUTEX(selinux_status_lock);\n\nvoid selinux_status_update_policyload(int seqno)\n{\n\tstruct selinux_kernel_status   *status;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (selinux_status_page) {\n\t\tstatus = page_address(selinux_status_page);\n\n\t\tstatus->sequence++;\n\t\tsmp_wmb();\n\n\t\tstatus->policyload = seqno;\n\t\tstatus->deny_unknown = !security_get_allow_unknown();\n\n\t\tsmp_wmb();\n\t\tstatus->sequence++;\n\t}\n\tmutex_unlock(&selinux_status_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "selnl_notify_policyload",
          "args": [
            "seqno"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "selnl_notify_policyload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlink.c",
          "lines": "106-109",
          "snippet": "void selnl_notify_policyload(u32 seqno)\n{\n\tselnl_notify(SELNL_MSG_POLICYLOAD, &seqno);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include <net/netlink.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/selinux_netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include <net/netlink.h>\n#include <net/net_namespace.h>\n#include <linux/selinux_netlink.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid selnl_notify_policyload(u32 seqno)\n{\n\tselnl_notify(SELNL_MSG_POLICYLOAD, &seqno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_ss_reset",
          "args": [
            "seqno"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "avc_ss_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "936-955",
          "snippet": "int avc_ss_reset(u32 seqno)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0, tmprc;\n\n\tavc_flush();\n\n\tfor (c = avc_callbacks; c; c = c->next) {\n\t\tif (c->events & AVC_CALLBACK_RESET) {\n\t\t\ttmprc = c->callback(AVC_CALLBACK_RESET);\n\t\t\t/* save the first error encountered for the return\n\t\t\t   value and continue processing the callbacks */\n\t\t\tif (!rc)\n\t\t\t\trc = tmprc;\n\t\t}\n\t}\n\n\tavc_latest_notif_update(seqno, 0);\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_callback_node *avc_callbacks;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_callback_node *avc_callbacks;\nstatic noinline struct;\n\nint avc_ss_reset(u32 seqno)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0, tmprc;\n\n\tavc_flush();\n\n\tfor (c = avc_callbacks; c; c = c->next) {\n\t\tif (c->events & AVC_CALLBACK_RESET) {\n\t\t\ttmprc = c->callback(AVC_CALLBACK_RESET);\n\t\t\t/* save the first error encountered for the return\n\t\t\t   value and continue processing the callbacks */\n\t\t\tif (!rc)\n\t\t\t\trc = tmprc;\n\t\t}\n\t}\n\n\tavc_latest_notif_update(seqno, 0);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evaluate_cond_node",
          "args": [
            "&policydb",
            "cur"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate_cond_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "90-117",
          "snippet": "int evaluate_cond_node(struct policydb *p, struct cond_node *node)\n{\n\tint new_state;\n\tstruct cond_av_list *cur;\n\n\tnew_state = cond_evaluate_expr(p, node->expr);\n\tif (new_state != node->cur_state) {\n\t\tnode->cur_state = new_state;\n\t\tif (new_state == -1)\n\t\t\tprintk(KERN_ERR \"SELinux: expression result was undefined - disabling all rules.\\n\");\n\t\t/* turn the rules on or off */\n\t\tfor (cur = node->true_list; cur; cur = cur->next) {\n\t\t\tif (new_state <= 0)\n\t\t\t\tcur->node->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tcur->node->key.specified |= AVTAB_ENABLED;\n\t\t}\n\n\t\tfor (cur = node->false_list; cur; cur = cur->next) {\n\t\t\t/* -1 or 1 */\n\t\t\tif (new_state)\n\t\t\t\tcur->node->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tcur->node->key.specified |= AVTAB_ENABLED;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint evaluate_cond_node(struct policydb *p, struct cond_node *node)\n{\n\tint new_state;\n\tstruct cond_av_list *cur;\n\n\tnew_state = cond_evaluate_expr(p, node->expr);\n\tif (new_state != node->cur_state) {\n\t\tnode->cur_state = new_state;\n\t\tif (new_state == -1)\n\t\t\tprintk(KERN_ERR \"SELinux: expression result was undefined - disabling all rules.\\n\");\n\t\t/* turn the rules on or off */\n\t\tfor (cur = node->true_list; cur; cur = cur->next) {\n\t\t\tif (new_state <= 0)\n\t\t\t\tcur->node->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tcur->node->key.specified |= AVTAB_ENABLED;\n\t\t}\n\n\t\tfor (cur = node->false_list; cur; cur = cur->next) {\n\t\t\t/* -1 or 1 */\n\t\t\tif (new_state)\n\t\t\t\tcur->node->key.specified &= ~AVTAB_ENABLED;\n\t\t\telse\n\t\t\t\tcur->node->key.specified |= AVTAB_ENABLED;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "current->audit_context",
            "GFP_ATOMIC",
            "AUDIT_MAC_CONFIG_CHANGE",
            "\"bool=%s val=%d old_val=%d auid=%u ses=%u\"",
            "sym_name(&policydb, SYM_BOOLS, i)",
            "!!values[i]",
            "policydb.bool_val_to_struct[i]->state",
            "from_kuid(&init_user_ns, audit_get_loginuid(current))",
            "audit_get_sessionid(current)"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "audit_get_loginuid(current)"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "&policydb",
            "SYM_BOOLS",
            "i"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\nstatic u32 latest_granting;\n\nint security_set_bools(int len, int *values)\n{\n\tint i, rc;\n\tint lenp, seqno = 0;\n\tstruct cond_node *cur;\n\n\twrite_lock_irq(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlenp = policydb.p_bools.nprim;\n\tif (len != lenp)\n\t\tgoto out;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!!values[i] != policydb.bool_val_to_struct[i]->state) {\n\t\t\taudit_log(current->audit_context, GFP_ATOMIC,\n\t\t\t\tAUDIT_MAC_CONFIG_CHANGE,\n\t\t\t\t\"bool=%s val=%d old_val=%d auid=%u ses=%u\",\n\t\t\t\tsym_name(&policydb, SYM_BOOLS, i),\n\t\t\t\t!!values[i],\n\t\t\t\tpolicydb.bool_val_to_struct[i]->state,\n\t\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t\taudit_get_sessionid(current));\n\t\t}\n\t\tif (values[i])\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 1;\n\t\telse\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 0;\n\t}\n\n\tfor (cur = policydb.cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(&policydb, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tseqno = ++latest_granting;\n\trc = 0;\nout:\n\twrite_unlock_irq(&policy_rwlock);\n\tif (!rc) {\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_xfrm_notify_policyload();\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "security_get_bools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2703-2745",
    "snippet": "int security_get_bools(int *len, char ***names, int **values)\n{\n\tint i, rc;\n\n\tread_lock(&policy_rwlock);\n\t*names = NULL;\n\t*values = NULL;\n\n\trc = 0;\n\t*len = policydb.p_bools.nprim;\n\tif (!*len)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\t*names = kcalloc(*len, sizeof(char *), GFP_ATOMIC);\n\tif (!*names)\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\t*values = kcalloc(*len, sizeof(int), GFP_ATOMIC);\n\tif (!*values)\n\t\tgoto err;\n\n\tfor (i = 0; i < *len; i++) {\n\t\t(*values)[i] = policydb.bool_val_to_struct[i]->state;\n\n\t\trc = -ENOMEM;\n\t\t(*names)[i] = kstrdup(sym_name(&policydb, SYM_BOOLS, i), GFP_ATOMIC);\n\t\tif (!(*names)[i])\n\t\t\tgoto err;\n\t}\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\nerr:\n\tif (*names) {\n\t\tfor (i = 0; i < *len; i++)\n\t\t\tkfree((*names)[i]);\n\t}\n\tkfree(*values);\n\tgoto out;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*values"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(*names)[i]"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2736
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "sym_name(&policydb, SYM_BOOLS, i)",
            "GFP_ATOMIC"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "&policydb",
            "SYM_BOOLS",
            "i"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "*len",
            "sizeof(int)",
            "GFP_ATOMIC"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "*len",
            "sizeof(char *)",
            "GFP_ATOMIC"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nint security_get_bools(int *len, char ***names, int **values)\n{\n\tint i, rc;\n\n\tread_lock(&policy_rwlock);\n\t*names = NULL;\n\t*values = NULL;\n\n\trc = 0;\n\t*len = policydb.p_bools.nprim;\n\tif (!*len)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\t*names = kcalloc(*len, sizeof(char *), GFP_ATOMIC);\n\tif (!*names)\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\t*values = kcalloc(*len, sizeof(int), GFP_ATOMIC);\n\tif (!*values)\n\t\tgoto err;\n\n\tfor (i = 0; i < *len; i++) {\n\t\t(*values)[i] = policydb.bool_val_to_struct[i]->state;\n\n\t\trc = -ENOMEM;\n\t\t(*names)[i] = kstrdup(sym_name(&policydb, SYM_BOOLS, i), GFP_ATOMIC);\n\t\tif (!(*names)[i])\n\t\t\tgoto err;\n\t}\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\nerr:\n\tif (*names) {\n\t\tfor (i = 0; i < *len; i++)\n\t\t\tkfree((*names)[i]);\n\t}\n\tkfree(*values);\n\tgoto out;\n}"
  },
  {
    "function_name": "security_fs_use",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2662-2701",
    "snippet": "int security_fs_use(struct super_block *sb)\n{\n\tint rc = 0;\n\tstruct ocontext *c;\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tconst char *fstype = sb->s_type->name;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_FSUSE];\n\twhile (c) {\n\t\tif (strcmp(fstype, c->u.name) == 0)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tsbsec->behavior = c->v.behavior;\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab, &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\tsbsec->sid = c->sid[0];\n\t} else {\n\t\trc = __security_genfs_sid(fstype, \"/\", SECCLASS_DIR,\n\t\t\t\t\t  &sbsec->sid);\n\t\tif (rc) {\n\t\t\tsbsec->behavior = SECURITY_FS_USE_NONE;\n\t\t\trc = 0;\n\t\t} else {\n\t\t\tsbsec->behavior = SECURITY_FS_USE_GENFS;\n\t\t}\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__security_genfs_sid",
          "args": [
            "fstype",
            "\"/\"",
            "SECCLASS_DIR",
            "&sbsec->sid"
          ],
          "line": 2688
        },
        "resolved": true,
        "details": {
          "function_name": "__security_genfs_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2585-2633",
          "snippet": "static inline int __security_genfs_sid(const char *fstype,\n\t\t\t\t       char *path,\n\t\t\t\t       u16 orig_sclass,\n\t\t\t\t       u32 *sid)\n{\n\tint len;\n\tu16 sclass;\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tint rc, cmp = 0;\n\n\twhile (path[0] == '/' && path[1] == '/')\n\t\tpath++;\n\n\tsclass = unmap_class(orig_sclass);\n\t*sid = SECINITSID_UNLABELED;\n\n\tfor (genfs = policydb.genfs; genfs; genfs = genfs->next) {\n\t\tcmp = strcmp(fstype, genfs->fstype);\n\t\tif (cmp <= 0)\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!genfs || cmp)\n\t\tgoto out;\n\n\tfor (c = genfs->head; c; c = c->next) {\n\t\tlen = strlen(c->u.name);\n\t\tif ((!c->v.sclass || sclass == c->v.sclass) &&\n\t\t    (strncmp(c->u.name, path, len) == 0))\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!c)\n\t\tgoto out;\n\n\tif (!c->sid[0]) {\n\t\trc = sidtab_context_to_sid(&sidtab, &c->context[0], &c->sid[0]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\t*sid = c->sid[0];\n\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sidtab sidtab;",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct sidtab sidtab;\nstruct policydb policydb;\n\nstatic inline int __security_genfs_sid(const char *fstype,\n\t\t\t\t       char *path,\n\t\t\t\t       u16 orig_sclass,\n\t\t\t\t       u32 *sid)\n{\n\tint len;\n\tu16 sclass;\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tint rc, cmp = 0;\n\n\twhile (path[0] == '/' && path[1] == '/')\n\t\tpath++;\n\n\tsclass = unmap_class(orig_sclass);\n\t*sid = SECINITSID_UNLABELED;\n\n\tfor (genfs = policydb.genfs; genfs; genfs = genfs->next) {\n\t\tcmp = strcmp(fstype, genfs->fstype);\n\t\tif (cmp <= 0)\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!genfs || cmp)\n\t\tgoto out;\n\n\tfor (c = genfs->head; c; c = c->next) {\n\t\tlen = strlen(c->u.name);\n\t\tif ((!c->v.sclass || sclass == c->v.sclass) &&\n\t\t    (strncmp(c->u.name, path, len) == 0))\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!c)\n\t\tgoto out;\n\n\tif (!c->sid[0]) {\n\t\trc = sidtab_context_to_sid(&sidtab, &c->context[0], &c->sid[0]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\t*sid = c->sid[0];\n\trc = 0;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_context_to_sid",
          "args": [
            "&sidtab",
            "&c->context[0]",
            "&c->sid[0]"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "191-232",
          "snippet": "int sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fstype",
            "c->u.name"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\n\nint security_fs_use(struct super_block *sb)\n{\n\tint rc = 0;\n\tstruct ocontext *c;\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tconst char *fstype = sb->s_type->name;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_FSUSE];\n\twhile (c) {\n\t\tif (strcmp(fstype, c->u.name) == 0)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tsbsec->behavior = c->v.behavior;\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab, &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\tsbsec->sid = c->sid[0];\n\t} else {\n\t\trc = __security_genfs_sid(fstype, \"/\", SECCLASS_DIR,\n\t\t\t\t\t  &sbsec->sid);\n\t\tif (rc) {\n\t\t\tsbsec->behavior = SECURITY_FS_USE_NONE;\n\t\t\trc = 0;\n\t\t} else {\n\t\t\tsbsec->behavior = SECURITY_FS_USE_GENFS;\n\t\t}\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
  },
  {
    "function_name": "security_genfs_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2645-2656",
    "snippet": "int security_genfs_sid(const char *fstype,\n\t\t       char *path,\n\t\t       u16 orig_sclass,\n\t\t       u32 *sid)\n{\n\tint retval;\n\n\tread_lock(&policy_rwlock);\n\tretval = __security_genfs_sid(fstype, path, orig_sclass, sid);\n\tread_unlock(&policy_rwlock);\n\treturn retval;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__security_genfs_sid",
          "args": [
            "fstype",
            "path",
            "orig_sclass",
            "sid"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "__security_genfs_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2585-2633",
          "snippet": "static inline int __security_genfs_sid(const char *fstype,\n\t\t\t\t       char *path,\n\t\t\t\t       u16 orig_sclass,\n\t\t\t\t       u32 *sid)\n{\n\tint len;\n\tu16 sclass;\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tint rc, cmp = 0;\n\n\twhile (path[0] == '/' && path[1] == '/')\n\t\tpath++;\n\n\tsclass = unmap_class(orig_sclass);\n\t*sid = SECINITSID_UNLABELED;\n\n\tfor (genfs = policydb.genfs; genfs; genfs = genfs->next) {\n\t\tcmp = strcmp(fstype, genfs->fstype);\n\t\tif (cmp <= 0)\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!genfs || cmp)\n\t\tgoto out;\n\n\tfor (c = genfs->head; c; c = c->next) {\n\t\tlen = strlen(c->u.name);\n\t\tif ((!c->v.sclass || sclass == c->v.sclass) &&\n\t\t    (strncmp(c->u.name, path, len) == 0))\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!c)\n\t\tgoto out;\n\n\tif (!c->sid[0]) {\n\t\trc = sidtab_context_to_sid(&sidtab, &c->context[0], &c->sid[0]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\t*sid = c->sid[0];\n\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sidtab sidtab;",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct sidtab sidtab;\nstruct policydb policydb;\n\nstatic inline int __security_genfs_sid(const char *fstype,\n\t\t\t\t       char *path,\n\t\t\t\t       u16 orig_sclass,\n\t\t\t\t       u32 *sid)\n{\n\tint len;\n\tu16 sclass;\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tint rc, cmp = 0;\n\n\twhile (path[0] == '/' && path[1] == '/')\n\t\tpath++;\n\n\tsclass = unmap_class(orig_sclass);\n\t*sid = SECINITSID_UNLABELED;\n\n\tfor (genfs = policydb.genfs; genfs; genfs = genfs->next) {\n\t\tcmp = strcmp(fstype, genfs->fstype);\n\t\tif (cmp <= 0)\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!genfs || cmp)\n\t\tgoto out;\n\n\tfor (c = genfs->head; c; c = c->next) {\n\t\tlen = strlen(c->u.name);\n\t\tif ((!c->v.sclass || sclass == c->v.sclass) &&\n\t\t    (strncmp(c->u.name, path, len) == 0))\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!c)\n\t\tgoto out;\n\n\tif (!c->sid[0]) {\n\t\trc = sidtab_context_to_sid(&sidtab, &c->context[0], &c->sid[0]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\t*sid = c->sid[0];\n\trc = 0;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\n\nint security_genfs_sid(const char *fstype,\n\t\t       char *path,\n\t\t       u16 orig_sclass,\n\t\t       u32 *sid)\n{\n\tint retval;\n\n\tread_lock(&policy_rwlock);\n\tretval = __security_genfs_sid(fstype, path, orig_sclass, sid);\n\tread_unlock(&policy_rwlock);\n\treturn retval;\n}"
  },
  {
    "function_name": "__security_genfs_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2585-2633",
    "snippet": "static inline int __security_genfs_sid(const char *fstype,\n\t\t\t\t       char *path,\n\t\t\t\t       u16 orig_sclass,\n\t\t\t\t       u32 *sid)\n{\n\tint len;\n\tu16 sclass;\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tint rc, cmp = 0;\n\n\twhile (path[0] == '/' && path[1] == '/')\n\t\tpath++;\n\n\tsclass = unmap_class(orig_sclass);\n\t*sid = SECINITSID_UNLABELED;\n\n\tfor (genfs = policydb.genfs; genfs; genfs = genfs->next) {\n\t\tcmp = strcmp(fstype, genfs->fstype);\n\t\tif (cmp <= 0)\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!genfs || cmp)\n\t\tgoto out;\n\n\tfor (c = genfs->head; c; c = c->next) {\n\t\tlen = strlen(c->u.name);\n\t\tif ((!c->v.sclass || sclass == c->v.sclass) &&\n\t\t    (strncmp(c->u.name, path, len) == 0))\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!c)\n\t\tgoto out;\n\n\tif (!c->sid[0]) {\n\t\trc = sidtab_context_to_sid(&sidtab, &c->context[0], &c->sid[0]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\t*sid = c->sid[0];\n\trc = 0;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sidtab sidtab;",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sidtab_context_to_sid",
          "args": [
            "&sidtab",
            "&c->context[0]",
            "&c->sid[0]"
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "191-232",
          "snippet": "int sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "c->u.name",
            "path",
            "len"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->u.name"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fstype",
            "genfs->fstype"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_class",
          "args": [
            "orig_sclass"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "209-215",
          "snippet": "static u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct selinux_mapping *current_mapping;",
            "static u16 current_mapping_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nstatic u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct sidtab sidtab;\nstruct policydb policydb;\n\nstatic inline int __security_genfs_sid(const char *fstype,\n\t\t\t\t       char *path,\n\t\t\t\t       u16 orig_sclass,\n\t\t\t\t       u32 *sid)\n{\n\tint len;\n\tu16 sclass;\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tint rc, cmp = 0;\n\n\twhile (path[0] == '/' && path[1] == '/')\n\t\tpath++;\n\n\tsclass = unmap_class(orig_sclass);\n\t*sid = SECINITSID_UNLABELED;\n\n\tfor (genfs = policydb.genfs; genfs; genfs = genfs->next) {\n\t\tcmp = strcmp(fstype, genfs->fstype);\n\t\tif (cmp <= 0)\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!genfs || cmp)\n\t\tgoto out;\n\n\tfor (c = genfs->head; c; c = c->next) {\n\t\tlen = strlen(c->u.name);\n\t\tif ((!c->v.sclass || sclass == c->v.sclass) &&\n\t\t    (strncmp(c->u.name, path, len) == 0))\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!c)\n\t\tgoto out;\n\n\tif (!c->sid[0]) {\n\t\trc = sidtab_context_to_sid(&sidtab, &c->context[0], &c->sid[0]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\t*sid = c->sid[0];\n\trc = 0;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "security_get_user_sids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2473-2570",
    "snippet": "int security_get_user_sids(u32 fromsid,\n\t\t\t   char *username,\n\t\t\t   u32 **sids,\n\t\t\t   u32 *nel)\n{\n\tstruct context *fromcon, usercon;\n\tu32 *mysids = NULL, *mysids2, sid;\n\tu32 mynel = 0, maxnel = SIDS_NEL;\n\tstruct user_datum *user;\n\tstruct role_datum *role;\n\tstruct ebitmap_node *rnode, *tnode;\n\tint rc = 0, i, j;\n\n\t*sids = NULL;\n\t*nel = 0;\n\n\tif (!ss_initialized)\n\t\tgoto out;\n\n\tread_lock(&policy_rwlock);\n\n\tcontext_init(&usercon);\n\n\trc = -EINVAL;\n\tfromcon = sidtab_search(&sidtab, fromsid);\n\tif (!fromcon)\n\t\tgoto out_unlock;\n\n\trc = -EINVAL;\n\tuser = hashtab_search(policydb.p_users.table, username);\n\tif (!user)\n\t\tgoto out_unlock;\n\n\tusercon.user = user->value;\n\n\trc = -ENOMEM;\n\tmysids = kcalloc(maxnel, sizeof(*mysids), GFP_ATOMIC);\n\tif (!mysids)\n\t\tgoto out_unlock;\n\n\tebitmap_for_each_positive_bit(&user->roles, rnode, i) {\n\t\trole = policydb.role_val_to_struct[i];\n\t\tusercon.role = i + 1;\n\t\tebitmap_for_each_positive_bit(&role->types, tnode, j) {\n\t\t\tusercon.type = j + 1;\n\n\t\t\tif (mls_setup_user_range(fromcon, user, &usercon))\n\t\t\t\tcontinue;\n\n\t\t\trc = sidtab_context_to_sid(&sidtab, &usercon, &sid);\n\t\t\tif (rc)\n\t\t\t\tgoto out_unlock;\n\t\t\tif (mynel < maxnel) {\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t} else {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tmaxnel += SIDS_NEL;\n\t\t\t\tmysids2 = kcalloc(maxnel, sizeof(*mysids2), GFP_ATOMIC);\n\t\t\t\tif (!mysids2)\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\tmemcpy(mysids2, mysids, mynel * sizeof(*mysids2));\n\t\t\t\tkfree(mysids);\n\t\t\t\tmysids = mysids2;\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tif (rc || !mynel) {\n\t\tkfree(mysids);\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\tmysids2 = kcalloc(mynel, sizeof(*mysids2), GFP_KERNEL);\n\tif (!mysids2) {\n\t\tkfree(mysids);\n\t\tgoto out;\n\t}\n\tfor (i = 0, j = 0; i < mynel; i++) {\n\t\tstruct av_decision dummy_avd;\n\t\trc = avc_has_perm_noaudit(fromsid, mysids[i],\n\t\t\t\t\t  SECCLASS_PROCESS, /* kernel value */\n\t\t\t\t\t  PROCESS__TRANSITION, AVC_STRICT,\n\t\t\t\t\t  &dummy_avd);\n\t\tif (!rc)\n\t\t\tmysids2[j++] = mysids[i];\n\t\tcond_resched();\n\t}\n\trc = 0;\n\tkfree(mysids);\n\t*sids = mysids2;\n\t*nel = j;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SIDS_NEL 25"
    ],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;",
      "int ss_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mysids"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm_noaudit",
          "args": [
            "fromsid",
            "mysids[i]",
            "SECCLASS_PROCESS",
            "/* kernel value */PROCESS__TRANSITION",
            "AVC_STRICT",
            "&dummy_avd"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1094-1120",
          "snippet": "inline int avc_has_perm_noaudit(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, u32 requested,\n\t\t\t unsigned flags,\n\t\t\t struct av_decision *avd)\n{\n\tstruct avc_node *node;\n\tstruct avc_xperms_node xp_node;\n\tint rc = 0;\n\tu32 denied;\n\n\tBUG_ON(!requested);\n\n\trcu_read_lock();\n\n\tnode = avc_lookup(ssid, tsid, tclass);\n\tif (unlikely(!node))\n\t\tnode = avc_compute_av(ssid, tsid, tclass, avd, &xp_node);\n\telse\n\t\tmemcpy(avd, &node->ae.avd, sizeof(*avd));\n\n\tdenied = requested & ~(avd->allowed);\n\tif (unlikely(denied))\n\t\trc = avc_denied(ssid, tsid, tclass, requested, 0, 0, flags, avd);\n\n\trcu_read_unlock();\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\ninline int avc_has_perm_noaudit(u32 ssid, u32 tsid,\n\t\t\t u16 tclass, u32 requested,\n\t\t\t unsigned flags,\n\t\t\t struct av_decision *avd)\n{\n\tstruct avc_node *node;\n\tstruct avc_xperms_node xp_node;\n\tint rc = 0;\n\tu32 denied;\n\n\tBUG_ON(!requested);\n\n\trcu_read_lock();\n\n\tnode = avc_lookup(ssid, tsid, tclass);\n\tif (unlikely(!node))\n\t\tnode = avc_compute_av(ssid, tsid, tclass, avd, &xp_node);\n\telse\n\t\tmemcpy(avd, &node->ae.avd, sizeof(*avd));\n\n\tdenied = requested & ~(avd->allowed);\n\tif (unlikely(denied))\n\t\trc = avc_denied(ssid, tsid, tclass, requested, 0, 0, flags, avd);\n\n\trcu_read_unlock();\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mysids"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "mynel",
            "sizeof(*mysids2)",
            "GFP_KERNEL"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mysids"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mysids"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mysids2",
            "mysids",
            "mynel * sizeof(*mysids2)"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "maxnel",
            "sizeof(*mysids2)",
            "GFP_ATOMIC"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_context_to_sid",
          "args": [
            "&sidtab",
            "&usercon",
            "&sid"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "191-232",
          "snippet": "int sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_setup_user_range",
          "args": [
            "fromcon",
            "user",
            "&usercon"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "mls_setup_user_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "420-456",
          "snippet": "int mls_setup_user_range(struct context *fromcon, struct user_datum *user,\n\t\t\t struct context *usercon)\n{\n\tif (policydb.mls_enabled) {\n\t\tstruct mls_level *fromcon_sen = &(fromcon->range.level[0]);\n\t\tstruct mls_level *fromcon_clr = &(fromcon->range.level[1]);\n\t\tstruct mls_level *user_low = &(user->range.level[0]);\n\t\tstruct mls_level *user_clr = &(user->range.level[1]);\n\t\tstruct mls_level *user_def = &(user->dfltlevel);\n\t\tstruct mls_level *usercon_sen = &(usercon->range.level[0]);\n\t\tstruct mls_level *usercon_clr = &(usercon->range.level[1]);\n\n\t\t/* Honor the user's default level if we can */\n\t\tif (mls_level_between(user_def, fromcon_sen, fromcon_clr))\n\t\t\t*usercon_sen = *user_def;\n\t\telse if (mls_level_between(fromcon_sen, user_def, user_clr))\n\t\t\t*usercon_sen = *fromcon_sen;\n\t\telse if (mls_level_between(fromcon_clr, user_low, user_def))\n\t\t\t*usercon_sen = *user_low;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\t/* Lower the clearance of available contexts\n\t\t   if the clearance of \"fromcon\" is lower than\n\t\t   that of the user's default clearance (but\n\t\t   only if the \"fromcon\" clearance dominates\n\t\t   the user's computed sensitivity level) */\n\t\tif (mls_level_dom(user_clr, fromcon_clr))\n\t\t\t*usercon_clr = *fromcon_clr;\n\t\telse if (mls_level_dom(fromcon_clr, user_clr))\n\t\t\t*usercon_clr = *user_clr;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_setup_user_range(struct context *fromcon, struct user_datum *user,\n\t\t\t struct context *usercon)\n{\n\tif (policydb.mls_enabled) {\n\t\tstruct mls_level *fromcon_sen = &(fromcon->range.level[0]);\n\t\tstruct mls_level *fromcon_clr = &(fromcon->range.level[1]);\n\t\tstruct mls_level *user_low = &(user->range.level[0]);\n\t\tstruct mls_level *user_clr = &(user->range.level[1]);\n\t\tstruct mls_level *user_def = &(user->dfltlevel);\n\t\tstruct mls_level *usercon_sen = &(usercon->range.level[0]);\n\t\tstruct mls_level *usercon_clr = &(usercon->range.level[1]);\n\n\t\t/* Honor the user's default level if we can */\n\t\tif (mls_level_between(user_def, fromcon_sen, fromcon_clr))\n\t\t\t*usercon_sen = *user_def;\n\t\telse if (mls_level_between(fromcon_sen, user_def, user_clr))\n\t\t\t*usercon_sen = *fromcon_sen;\n\t\telse if (mls_level_between(fromcon_clr, user_low, user_def))\n\t\t\t*usercon_sen = *user_low;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\t/* Lower the clearance of available contexts\n\t\t   if the clearance of \"fromcon\" is lower than\n\t\t   that of the user's default clearance (but\n\t\t   only if the \"fromcon\" clearance dominates\n\t\t   the user's computed sensitivity level) */\n\t\tif (mls_level_dom(user_clr, fromcon_clr))\n\t\t\t*usercon_clr = *fromcon_clr;\n\t\telse if (mls_level_dom(fromcon_clr, user_clr))\n\t\t\t*usercon_clr = *user_clr;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "&role->types",
            "tnode",
            "j"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "&user->roles",
            "rnode",
            "i"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "maxnel",
            "sizeof(*mysids)",
            "GFP_ATOMIC"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "policydb.p_users.table",
            "username"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "&sidtab",
            "fromsid"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_init",
          "args": [
            "&usercon"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "context_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "113-116",
          "snippet": "static inline void context_init(struct context *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_init(struct context *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define SIDS_NEL 25\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nint security_get_user_sids(u32 fromsid,\n\t\t\t   char *username,\n\t\t\t   u32 **sids,\n\t\t\t   u32 *nel)\n{\n\tstruct context *fromcon, usercon;\n\tu32 *mysids = NULL, *mysids2, sid;\n\tu32 mynel = 0, maxnel = SIDS_NEL;\n\tstruct user_datum *user;\n\tstruct role_datum *role;\n\tstruct ebitmap_node *rnode, *tnode;\n\tint rc = 0, i, j;\n\n\t*sids = NULL;\n\t*nel = 0;\n\n\tif (!ss_initialized)\n\t\tgoto out;\n\n\tread_lock(&policy_rwlock);\n\n\tcontext_init(&usercon);\n\n\trc = -EINVAL;\n\tfromcon = sidtab_search(&sidtab, fromsid);\n\tif (!fromcon)\n\t\tgoto out_unlock;\n\n\trc = -EINVAL;\n\tuser = hashtab_search(policydb.p_users.table, username);\n\tif (!user)\n\t\tgoto out_unlock;\n\n\tusercon.user = user->value;\n\n\trc = -ENOMEM;\n\tmysids = kcalloc(maxnel, sizeof(*mysids), GFP_ATOMIC);\n\tif (!mysids)\n\t\tgoto out_unlock;\n\n\tebitmap_for_each_positive_bit(&user->roles, rnode, i) {\n\t\trole = policydb.role_val_to_struct[i];\n\t\tusercon.role = i + 1;\n\t\tebitmap_for_each_positive_bit(&role->types, tnode, j) {\n\t\t\tusercon.type = j + 1;\n\n\t\t\tif (mls_setup_user_range(fromcon, user, &usercon))\n\t\t\t\tcontinue;\n\n\t\t\trc = sidtab_context_to_sid(&sidtab, &usercon, &sid);\n\t\t\tif (rc)\n\t\t\t\tgoto out_unlock;\n\t\t\tif (mynel < maxnel) {\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t} else {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tmaxnel += SIDS_NEL;\n\t\t\t\tmysids2 = kcalloc(maxnel, sizeof(*mysids2), GFP_ATOMIC);\n\t\t\t\tif (!mysids2)\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\tmemcpy(mysids2, mysids, mynel * sizeof(*mysids2));\n\t\t\t\tkfree(mysids);\n\t\t\t\tmysids = mysids2;\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tif (rc || !mynel) {\n\t\tkfree(mysids);\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\tmysids2 = kcalloc(mynel, sizeof(*mysids2), GFP_KERNEL);\n\tif (!mysids2) {\n\t\tkfree(mysids);\n\t\tgoto out;\n\t}\n\tfor (i = 0, j = 0; i < mynel; i++) {\n\t\tstruct av_decision dummy_avd;\n\t\trc = avc_has_perm_noaudit(fromsid, mysids[i],\n\t\t\t\t\t  SECCLASS_PROCESS, /* kernel value */\n\t\t\t\t\t  PROCESS__TRANSITION, AVC_STRICT,\n\t\t\t\t\t  &dummy_avd);\n\t\tif (!rc)\n\t\t\tmysids2[j++] = mysids[i];\n\t\tcond_resched();\n\t}\n\trc = 0;\n\tkfree(mysids);\n\t*sids = mysids2;\n\t*nel = j;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "security_node_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2390-2455",
    "snippet": "int security_node_sid(u16 domain,\n\t\t      void *addrp,\n\t\t      u32 addrlen,\n\t\t      u32 *out_sid)\n{\n\tint rc;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tswitch (domain) {\n\tcase AF_INET: {\n\t\tu32 addr;\n\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u32))\n\t\t\tgoto out;\n\n\t\taddr = *((u32 *)addrp);\n\n\t\tc = policydb.ocontexts[OCON_NODE];\n\t\twhile (c) {\n\t\t\tif (c->u.node.addr == (addr & c->u.node.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase AF_INET6:\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u64) * 2)\n\t\t\tgoto out;\n\t\tc = policydb.ocontexts[OCON_NODE6];\n\t\twhile (c) {\n\t\t\tif (match_ipv6_addrmask(addrp, c->u.node6.addr,\n\t\t\t\t\t\tc->u.node6.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = 0;\n\t\t*out_sid = SECINITSID_NODE;\n\t\tgoto out;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else {\n\t\t*out_sid = SECINITSID_NODE;\n\t}\n\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_context_to_sid",
          "args": [
            "&sidtab",
            "&c->context[0]",
            "&c->sid[0]"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "191-232",
          "snippet": "int sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_ipv6_addrmask",
          "args": [
            "addrp",
            "c->u.node6.addr",
            "c->u.node6.mask"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "match_ipv6_addrmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2370-2381",
          "snippet": "static int match_ipv6_addrmask(u32 *input, u32 *addr, u32 *mask)\n{\n\tint i, fail = 0;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (addr[i] != (input[i] & mask[i])) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\n\treturn !fail;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int match_ipv6_addrmask(u32 *input, u32 *addr, u32 *mask)\n{\n\tint i, fail = 0;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (addr[i] != (input[i] & mask[i])) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\n\treturn !fail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\n\nint security_node_sid(u16 domain,\n\t\t      void *addrp,\n\t\t      u32 addrlen,\n\t\t      u32 *out_sid)\n{\n\tint rc;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tswitch (domain) {\n\tcase AF_INET: {\n\t\tu32 addr;\n\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u32))\n\t\t\tgoto out;\n\n\t\taddr = *((u32 *)addrp);\n\n\t\tc = policydb.ocontexts[OCON_NODE];\n\t\twhile (c) {\n\t\t\tif (c->u.node.addr == (addr & c->u.node.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase AF_INET6:\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u64) * 2)\n\t\t\tgoto out;\n\t\tc = policydb.ocontexts[OCON_NODE6];\n\t\twhile (c) {\n\t\t\tif (match_ipv6_addrmask(addrp, c->u.node6.addr,\n\t\t\t\t\t\tc->u.node6.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = 0;\n\t\t*out_sid = SECINITSID_NODE;\n\t\tgoto out;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else {\n\t\t*out_sid = SECINITSID_NODE;\n\t}\n\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
  },
  {
    "function_name": "match_ipv6_addrmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2370-2381",
    "snippet": "static int match_ipv6_addrmask(u32 *input, u32 *addr, u32 *mask)\n{\n\tint i, fail = 0;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (addr[i] != (input[i] & mask[i])) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\n\treturn !fail;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int match_ipv6_addrmask(u32 *input, u32 *addr, u32 *mask)\n{\n\tint i, fail = 0;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (addr[i] != (input[i] & mask[i])) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\n\treturn !fail;\n}"
  },
  {
    "function_name": "security_netif_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2334-2368",
    "snippet": "int security_netif_sid(char *name, u32 *if_sid)\n{\n\tint rc = 0;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_NETIF];\n\twhile (c) {\n\t\tif (strcmp(name, c->u.name) == 0)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0] || !c->sid[1]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t  &c->context[0],\n\t\t\t\t\t\t  &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[1],\n\t\t\t\t\t\t   &c->sid[1]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*if_sid = c->sid[0];\n\t} else\n\t\t*if_sid = SECINITSID_NETIF;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_context_to_sid",
          "args": [
            "&sidtab",
            "&c->context[1]",
            "&c->sid[1]"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "191-232",
          "snippet": "int sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "c->u.name"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\n\nint security_netif_sid(char *name, u32 *if_sid)\n{\n\tint rc = 0;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_NETIF];\n\twhile (c) {\n\t\tif (strcmp(name, c->u.name) == 0)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0] || !c->sid[1]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t  &c->context[0],\n\t\t\t\t\t\t  &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[1],\n\t\t\t\t\t\t   &c->sid[1]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*if_sid = c->sid[0];\n\t} else\n\t\t*if_sid = SECINITSID_NETIF;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
  },
  {
    "function_name": "security_ib_endport_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2294-2327",
    "snippet": "int security_ib_endport_sid(const char *dev_name, u8 port_num, u32 *out_sid)\n{\n\tstruct ocontext *c;\n\tint rc = 0;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_IBENDPORT];\n\twhile (c) {\n\t\tif (c->u.ibendport.port == port_num &&\n\t\t    !strncmp(c->u.ibendport.dev_name,\n\t\t\t     dev_name,\n\t\t\t     IB_DEVICE_NAME_MAX))\n\t\t\tbreak;\n\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else\n\t\t*out_sid = SECINITSID_UNLABELED;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_context_to_sid",
          "args": [
            "&sidtab",
            "&c->context[0]",
            "&c->sid[0]"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "191-232",
          "snippet": "int sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "c->u.ibendport.dev_name",
            "dev_name",
            "IB_DEVICE_NAME_MAX"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\n\nint security_ib_endport_sid(const char *dev_name, u8 port_num, u32 *out_sid)\n{\n\tstruct ocontext *c;\n\tint rc = 0;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_IBENDPORT];\n\twhile (c) {\n\t\tif (c->u.ibendport.port == port_num &&\n\t\t    !strncmp(c->u.ibendport.dev_name,\n\t\t\t     dev_name,\n\t\t\t     IB_DEVICE_NAME_MAX))\n\t\t\tbreak;\n\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else\n\t\t*out_sid = SECINITSID_UNLABELED;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
  },
  {
    "function_name": "security_ib_pkey_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2254-2286",
    "snippet": "int security_ib_pkey_sid(u64 subnet_prefix, u16 pkey_num, u32 *out_sid)\n{\n\tstruct ocontext *c;\n\tint rc = 0;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_IBPKEY];\n\twhile (c) {\n\t\tif (c->u.ibpkey.low_pkey <= pkey_num &&\n\t\t    c->u.ibpkey.high_pkey >= pkey_num &&\n\t\t    c->u.ibpkey.subnet_prefix == subnet_prefix)\n\t\t\tbreak;\n\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else\n\t\t*out_sid = SECINITSID_UNLABELED;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_context_to_sid",
          "args": [
            "&sidtab",
            "&c->context[0]",
            "&c->sid[0]"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "191-232",
          "snippet": "int sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\n\nint security_ib_pkey_sid(u64 subnet_prefix, u16 pkey_num, u32 *out_sid)\n{\n\tstruct ocontext *c;\n\tint rc = 0;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_IBPKEY];\n\twhile (c) {\n\t\tif (c->u.ibpkey.low_pkey <= pkey_num &&\n\t\t    c->u.ibpkey.high_pkey >= pkey_num &&\n\t\t    c->u.ibpkey.subnet_prefix == subnet_prefix)\n\t\t\tbreak;\n\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else\n\t\t*out_sid = SECINITSID_UNLABELED;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
  },
  {
    "function_name": "security_port_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2214-2246",
    "snippet": "int security_port_sid(u8 protocol, u16 port, u32 *out_sid)\n{\n\tstruct ocontext *c;\n\tint rc = 0;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_PORT];\n\twhile (c) {\n\t\tif (c->u.port.protocol == protocol &&\n\t\t    c->u.port.low_port <= port &&\n\t\t    c->u.port.high_port >= port)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else {\n\t\t*out_sid = SECINITSID_PORT;\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_context_to_sid",
          "args": [
            "&sidtab",
            "&c->context[0]",
            "&c->sid[0]"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "191-232",
          "snippet": "int sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\n\nint security_port_sid(u8 protocol, u16 port, u32 *out_sid)\n{\n\tstruct ocontext *c;\n\tint rc = 0;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_PORT];\n\twhile (c) {\n\t\tif (c->u.port.protocol == protocol &&\n\t\t    c->u.port.low_port <= port &&\n\t\t    c->u.port.high_port >= port)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else {\n\t\t*out_sid = SECINITSID_PORT;\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
  },
  {
    "function_name": "security_policydb_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2197-2206",
    "snippet": "size_t security_policydb_len(void)\n{\n\tsize_t len;\n\n\tread_lock(&policy_rwlock);\n\tlen = policydb.len;\n\tread_unlock(&policy_rwlock);\n\n\treturn len;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstruct policydb policydb;\n\nsize_t security_policydb_len(void)\n{\n\tsize_t len;\n\n\tread_lock(&policy_rwlock);\n\tlen = policydb.len;\n\tread_unlock(&policy_rwlock);\n\n\treturn len;\n}"
  },
  {
    "function_name": "security_load_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "2042-2195",
    "snippet": "int security_load_policy(void *data, size_t len)\n{\n\tstruct policydb *oldpolicydb, *newpolicydb;\n\tstruct sidtab oldsidtab, newsidtab;\n\tstruct selinux_mapping *oldmap, *map = NULL;\n\tstruct convert_context_args args;\n\tu32 seqno;\n\tu16 map_size;\n\tint rc = 0;\n\tstruct policy_file file = { data, len }, *fp = &file;\n\n\toldpolicydb = kzalloc(2 * sizeof(*oldpolicydb), GFP_KERNEL);\n\tif (!oldpolicydb) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnewpolicydb = oldpolicydb + 1;\n\n\tif (!ss_initialized) {\n\t\tavtab_cache_init();\n\t\tebitmap_cache_init();\n\t\thashtab_cache_init();\n\t\trc = policydb_read(&policydb, fp);\n\t\tif (rc) {\n\t\t\tavtab_cache_destroy();\n\t\t\tebitmap_cache_destroy();\n\t\t\thashtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\tpolicydb.len = len;\n\t\trc = selinux_set_mapping(&policydb, secclass_map,\n\t\t\t\t\t &current_mapping,\n\t\t\t\t\t &current_mapping_size);\n\t\tif (rc) {\n\t\t\tpolicydb_destroy(&policydb);\n\t\t\tavtab_cache_destroy();\n\t\t\tebitmap_cache_destroy();\n\t\t\thashtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = policydb_load_isids(&policydb, &sidtab);\n\t\tif (rc) {\n\t\t\tpolicydb_destroy(&policydb);\n\t\t\tavtab_cache_destroy();\n\t\t\tebitmap_cache_destroy();\n\t\t\thashtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\tsecurity_load_policycaps();\n\t\tss_initialized = 1;\n\t\tseqno = ++latest_granting;\n\t\tselinux_complete_init();\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_netlbl_cache_invalidate();\n\t\tselinux_xfrm_notify_policyload();\n\t\tgoto out;\n\t}\n\n#if 0\n\tsidtab_hash_eval(&sidtab, \"sids\");\n#endif\n\n\trc = policydb_read(newpolicydb, fp);\n\tif (rc)\n\t\tgoto out;\n\n\tnewpolicydb->len = len;\n\t/* If switching between different policy types, log MLS status */\n\tif (policydb.mls_enabled && !newpolicydb->mls_enabled)\n\t\tprintk(KERN_INFO \"SELinux: Disabling MLS support...\\n\");\n\telse if (!policydb.mls_enabled && newpolicydb->mls_enabled)\n\t\tprintk(KERN_INFO \"SELinux: Enabling MLS support...\\n\");\n\n\trc = policydb_load_isids(newpolicydb, &newsidtab);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to load the initial SIDs\\n\");\n\t\tpolicydb_destroy(newpolicydb);\n\t\tgoto out;\n\t}\n\n\trc = selinux_set_mapping(newpolicydb, secclass_map, &map, &map_size);\n\tif (rc)\n\t\tgoto err;\n\n\trc = security_preserve_bools(newpolicydb);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to preserve booleans\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Clone the SID table. */\n\tsidtab_shutdown(&sidtab);\n\n\trc = sidtab_map(&sidtab, clone_sid, &newsidtab);\n\tif (rc)\n\t\tgoto err;\n\n\t/*\n\t * Convert the internal representations of contexts\n\t * in the new SID table.\n\t */\n\targs.oldp = &policydb;\n\targs.newp = newpolicydb;\n\trc = sidtab_map(&newsidtab, convert_context, &args);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to convert the internal\"\n\t\t\t\" representation of contexts in the new SID\"\n\t\t\t\" table\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Save the old policydb and SID table to free later. */\n\tmemcpy(oldpolicydb, &policydb, sizeof(policydb));\n\tsidtab_set(&oldsidtab, &sidtab);\n\n\t/* Install the new policydb and SID table. */\n\twrite_lock_irq(&policy_rwlock);\n\tmemcpy(&policydb, newpolicydb, sizeof(policydb));\n\tsidtab_set(&sidtab, &newsidtab);\n\tsecurity_load_policycaps();\n\toldmap = current_mapping;\n\tcurrent_mapping = map;\n\tcurrent_mapping_size = map_size;\n\tseqno = ++latest_granting;\n\twrite_unlock_irq(&policy_rwlock);\n\n\t/* Free the old policydb and SID table. */\n\tpolicydb_destroy(oldpolicydb);\n\tsidtab_destroy(&oldsidtab);\n\tkfree(oldmap);\n\n\tavc_ss_reset(seqno);\n\tselnl_notify_policyload(seqno);\n\tselinux_status_update_policyload(seqno);\n\tselinux_netlbl_cache_invalidate();\n\tselinux_xfrm_notify_policyload();\n\n\trc = 0;\n\tgoto out;\n\nerr:\n\tkfree(map);\n\tsidtab_destroy(&newsidtab);\n\tpolicydb_destroy(newpolicydb);\n\nout:\n\tkfree(oldpolicydb);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;",
      "int ss_initialized;",
      "static u32 latest_granting;",
      "static struct selinux_mapping *current_mapping;",
      "static u16 current_mapping_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oldpolicydb"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policydb_destroy",
          "args": [
            "newpolicydb"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "796-887",
          "snippet": "void policydb_destroy(struct policydb *p)\n{\n\tstruct ocontext *c, *ctmp;\n\tstruct genfs *g, *gtmp;\n\tint i;\n\tstruct role_allow *ra, *lra = NULL;\n\tstruct role_trans *tr, *ltr = NULL;\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tcond_resched();\n\t\thashtab_map(p->symtab[i].table, destroy_f[i], NULL);\n\t\thashtab_destroy(p->symtab[i].table);\n\t}\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tif (p->sym_val_to_name[i])\n\t\t\tflex_array_free(p->sym_val_to_name[i]);\n\t}\n\n\tkfree(p->class_val_to_struct);\n\tkfree(p->role_val_to_struct);\n\tkfree(p->user_val_to_struct);\n\tif (p->type_val_to_struct_array)\n\t\tflex_array_free(p->type_val_to_struct_array);\n\n\tavtab_destroy(&p->te_avtab);\n\n\tfor (i = 0; i < OCON_NUM; i++) {\n\t\tcond_resched();\n\t\tc = p->ocontexts[i];\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, i);\n\t\t}\n\t\tp->ocontexts[i] = NULL;\n\t}\n\n\tg = p->genfs;\n\twhile (g) {\n\t\tcond_resched();\n\t\tkfree(g->fstype);\n\t\tc = g->head;\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, OCON_FSUSE);\n\t\t}\n\t\tgtmp = g;\n\t\tg = g->next;\n\t\tkfree(gtmp);\n\t}\n\tp->genfs = NULL;\n\n\tcond_policydb_destroy(p);\n\n\tfor (tr = p->role_tr; tr; tr = tr->next) {\n\t\tcond_resched();\n\t\tkfree(ltr);\n\t\tltr = tr;\n\t}\n\tkfree(ltr);\n\n\tfor (ra = p->role_allow; ra; ra = ra->next) {\n\t\tcond_resched();\n\t\tkfree(lra);\n\t\tlra = ra;\n\t}\n\tkfree(lra);\n\n\thashtab_map(p->filename_trans, filenametr_destroy, NULL);\n\thashtab_destroy(p->filename_trans);\n\n\thashtab_map(p->range_tr, range_tr_destroy, NULL);\n\thashtab_destroy(p->range_tr);\n\n\tif (p->type_attr_map_array) {\n\t\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\t\tstruct ebitmap *e;\n\n\t\t\te = flex_array_get(p->type_attr_map_array, i);\n\t\t\tif (!e)\n\t\t\t\tcontinue;\n\t\t\tebitmap_destroy(e);\n\t\t}\n\t\tflex_array_free(p->type_attr_map_array);\n\t}\n\n\tebitmap_destroy(&p->filename_trans_ttypes);\n\tebitmap_destroy(&p->policycaps);\n\tebitmap_destroy(&p->permissive_map);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*destroy_f[SYM_NUM]) (void *key, void *datum, void *datap) =\n{\n\tcommon_destroy,\n\tcls_destroy,\n\trole_destroy,\n\ttype_destroy,\n\tuser_destroy,\n\tcond_destroy_bool,\n\tsens_destroy,\n\tcat_destroy,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int (*destroy_f[SYM_NUM]) (void *key, void *datum, void *datap) =\n{\n\tcommon_destroy,\n\tcls_destroy,\n\trole_destroy,\n\ttype_destroy,\n\tuser_destroy,\n\tcond_destroy_bool,\n\tsens_destroy,\n\tcat_destroy,\n};\n\nvoid policydb_destroy(struct policydb *p)\n{\n\tstruct ocontext *c, *ctmp;\n\tstruct genfs *g, *gtmp;\n\tint i;\n\tstruct role_allow *ra, *lra = NULL;\n\tstruct role_trans *tr, *ltr = NULL;\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tcond_resched();\n\t\thashtab_map(p->symtab[i].table, destroy_f[i], NULL);\n\t\thashtab_destroy(p->symtab[i].table);\n\t}\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tif (p->sym_val_to_name[i])\n\t\t\tflex_array_free(p->sym_val_to_name[i]);\n\t}\n\n\tkfree(p->class_val_to_struct);\n\tkfree(p->role_val_to_struct);\n\tkfree(p->user_val_to_struct);\n\tif (p->type_val_to_struct_array)\n\t\tflex_array_free(p->type_val_to_struct_array);\n\n\tavtab_destroy(&p->te_avtab);\n\n\tfor (i = 0; i < OCON_NUM; i++) {\n\t\tcond_resched();\n\t\tc = p->ocontexts[i];\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, i);\n\t\t}\n\t\tp->ocontexts[i] = NULL;\n\t}\n\n\tg = p->genfs;\n\twhile (g) {\n\t\tcond_resched();\n\t\tkfree(g->fstype);\n\t\tc = g->head;\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, OCON_FSUSE);\n\t\t}\n\t\tgtmp = g;\n\t\tg = g->next;\n\t\tkfree(gtmp);\n\t}\n\tp->genfs = NULL;\n\n\tcond_policydb_destroy(p);\n\n\tfor (tr = p->role_tr; tr; tr = tr->next) {\n\t\tcond_resched();\n\t\tkfree(ltr);\n\t\tltr = tr;\n\t}\n\tkfree(ltr);\n\n\tfor (ra = p->role_allow; ra; ra = ra->next) {\n\t\tcond_resched();\n\t\tkfree(lra);\n\t\tlra = ra;\n\t}\n\tkfree(lra);\n\n\thashtab_map(p->filename_trans, filenametr_destroy, NULL);\n\thashtab_destroy(p->filename_trans);\n\n\thashtab_map(p->range_tr, range_tr_destroy, NULL);\n\thashtab_destroy(p->range_tr);\n\n\tif (p->type_attr_map_array) {\n\t\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\t\tstruct ebitmap *e;\n\n\t\t\te = flex_array_get(p->type_attr_map_array, i);\n\t\t\tif (!e)\n\t\t\t\tcontinue;\n\t\t\tebitmap_destroy(e);\n\t\t}\n\t\tflex_array_free(p->type_attr_map_array);\n\t}\n\n\tebitmap_destroy(&p->filename_trans_ttypes);\n\tebitmap_destroy(&p->policycaps);\n\tebitmap_destroy(&p->permissive_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_destroy",
          "args": [
            "&newsidtab"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "261-283",
          "snippet": "void sidtab_destroy(struct sidtab *s)\n{\n\tint i;\n\tstruct sidtab_node *cur, *temp;\n\n\tif (!s)\n\t\treturn;\n\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = s->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tcontext_destroy(&temp->context);\n\t\t\tkfree(temp);\n\t\t}\n\t\ts->htable[i] = NULL;\n\t}\n\tkfree(s->htable);\n\ts->htable = NULL;\n\ts->nel = 0;\n\ts->next_sid = 1;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid sidtab_destroy(struct sidtab *s)\n{\n\tint i;\n\tstruct sidtab_node *cur, *temp;\n\n\tif (!s)\n\t\treturn;\n\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = s->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tcontext_destroy(&temp->context);\n\t\t\tkfree(temp);\n\t\t}\n\t\ts->htable[i] = NULL;\n\t}\n\tkfree(s->htable);\n\ts->htable = NULL;\n\ts->nel = 0;\n\ts->next_sid = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "map"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_xfrm_notify_policyload",
          "args": [],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_xfrm_notify_policyload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/include/xfrm.h",
          "lines": "81-83",
          "snippet": "static inline void selinux_xfrm_notify_policyload(void)\n{\n}",
          "includes": [
            "#include <net/flow.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n\nstatic inline void selinux_xfrm_notify_policyload(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_netlbl_cache_invalidate",
          "args": [],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_netlbl_cache_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
          "lines": "137-140",
          "snippet": "void selinux_netlbl_cache_invalidate(void)\n{\n\tnetlbl_cache_invalidate();\n}",
          "includes": [
            "#include \"netlabel.h\"",
            "#include \"security.h\"",
            "#include \"objsec.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/netlabel.h>",
            "#include <net/sock.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/gfp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nvoid selinux_netlbl_cache_invalidate(void)\n{\n\tnetlbl_cache_invalidate();\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_status_update_policyload",
          "args": [
            "seqno"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_status_update_policyload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/status.c",
          "lines": "108-126",
          "snippet": "void selinux_status_update_policyload(int seqno)\n{\n\tstruct selinux_kernel_status   *status;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (selinux_status_page) {\n\t\tstatus = page_address(selinux_status_page);\n\n\t\tstatus->sequence++;\n\t\tsmp_wmb();\n\n\t\tstatus->policyload = seqno;\n\t\tstatus->deny_unknown = !security_get_allow_unknown();\n\n\t\tsmp_wmb();\n\t\tstatus->sequence++;\n\t}\n\tmutex_unlock(&selinux_status_lock);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"avc.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct page *selinux_status_page;",
            "static DEFINE_MUTEX(selinux_status_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"avc.h\"\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n\nstatic struct page *selinux_status_page;\nstatic DEFINE_MUTEX(selinux_status_lock);\n\nvoid selinux_status_update_policyload(int seqno)\n{\n\tstruct selinux_kernel_status   *status;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (selinux_status_page) {\n\t\tstatus = page_address(selinux_status_page);\n\n\t\tstatus->sequence++;\n\t\tsmp_wmb();\n\n\t\tstatus->policyload = seqno;\n\t\tstatus->deny_unknown = !security_get_allow_unknown();\n\n\t\tsmp_wmb();\n\t\tstatus->sequence++;\n\t}\n\tmutex_unlock(&selinux_status_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "selnl_notify_policyload",
          "args": [
            "seqno"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "selnl_notify_policyload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlink.c",
          "lines": "106-109",
          "snippet": "void selnl_notify_policyload(u32 seqno)\n{\n\tselnl_notify(SELNL_MSG_POLICYLOAD, &seqno);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include <net/netlink.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/selinux_netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include <net/netlink.h>\n#include <net/net_namespace.h>\n#include <linux/selinux_netlink.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nvoid selnl_notify_policyload(u32 seqno)\n{\n\tselnl_notify(SELNL_MSG_POLICYLOAD, &seqno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avc_ss_reset",
          "args": [
            "seqno"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "avc_ss_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "936-955",
          "snippet": "int avc_ss_reset(u32 seqno)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0, tmprc;\n\n\tavc_flush();\n\n\tfor (c = avc_callbacks; c; c = c->next) {\n\t\tif (c->events & AVC_CALLBACK_RESET) {\n\t\t\ttmprc = c->callback(AVC_CALLBACK_RESET);\n\t\t\t/* save the first error encountered for the return\n\t\t\t   value and continue processing the callbacks */\n\t\t\tif (!rc)\n\t\t\t\trc = tmprc;\n\t\t}\n\t}\n\n\tavc_latest_notif_update(seqno, 0);\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct avc_callback_node *avc_callbacks;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic struct avc_callback_node *avc_callbacks;\nstatic noinline struct;\n\nint avc_ss_reset(u32 seqno)\n{\n\tstruct avc_callback_node *c;\n\tint rc = 0, tmprc;\n\n\tavc_flush();\n\n\tfor (c = avc_callbacks; c; c = c->next) {\n\t\tif (c->events & AVC_CALLBACK_RESET) {\n\t\t\ttmprc = c->callback(AVC_CALLBACK_RESET);\n\t\t\t/* save the first error encountered for the return\n\t\t\t   value and continue processing the callbacks */\n\t\t\tif (!rc)\n\t\t\t\trc = tmprc;\n\t\t}\n\t}\n\n\tavc_latest_notif_update(seqno, 0);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oldmap"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_load_policycaps",
          "args": [],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "security_load_policycaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1998-2028",
          "snippet": "static void security_load_policycaps(void)\n{\n\tunsigned int i;\n\tstruct ebitmap_node *node;\n\n\tselinux_policycap_netpeer = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_NETPEER);\n\tselinux_policycap_openperm = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_OPENPERM);\n\tselinux_policycap_extsockclass = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t  POLICYDB_CAPABILITY_EXTSOCKCLASS);\n\tselinux_policycap_alwaysnetwork = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_ALWAYSNETWORK);\n\tselinux_policycap_cgroupseclabel =\n\t\tebitmap_get_bit(&policydb.policycaps,\n\t\t\t\tPOLICYDB_CAPABILITY_CGROUPSECLABEL);\n\tselinux_policycap_nnp_nosuid_transition =\n\t\tebitmap_get_bit(&policydb.policycaps,\n\t\t\t\tPOLICYDB_CAPABILITY_NNP_NOSUID_TRANSITION);\n\n\tfor (i = 0; i < ARRAY_SIZE(selinux_policycap_names); i++)\n\t\tpr_info(\"SELinux:  policy capability %s=%d\\n\",\n\t\t\tselinux_policycap_names[i],\n\t\t\tebitmap_get_bit(&policydb.policycaps, i));\n\n\tebitmap_for_each_positive_bit(&policydb.policycaps, node, i) {\n\t\tif (i >= ARRAY_SIZE(selinux_policycap_names))\n\t\t\tpr_info(\"SELinux:  unknown policy capability %u\\n\",\n\t\t\t\ti);\n\t}\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *selinux_policycap_names[__POLICYDB_CAPABILITY_MAX] = {\n\t\"network_peer_controls\",\n\t\"open_perms\",\n\t\"extended_socket_class\",\n\t\"always_check_network\",\n\t\"cgroup_seclabel\",\n\t\"nnp_nosuid_transition\"\n};",
            "int selinux_policycap_netpeer;",
            "int selinux_policycap_openperm;",
            "int selinux_policycap_extsockclass;",
            "int selinux_policycap_alwaysnetwork;",
            "int selinux_policycap_cgroupseclabel;",
            "int selinux_policycap_nnp_nosuid_transition;",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nchar *selinux_policycap_names[__POLICYDB_CAPABILITY_MAX] = {\n\t\"network_peer_controls\",\n\t\"open_perms\",\n\t\"extended_socket_class\",\n\t\"always_check_network\",\n\t\"cgroup_seclabel\",\n\t\"nnp_nosuid_transition\"\n};\nint selinux_policycap_netpeer;\nint selinux_policycap_openperm;\nint selinux_policycap_extsockclass;\nint selinux_policycap_alwaysnetwork;\nint selinux_policycap_cgroupseclabel;\nint selinux_policycap_nnp_nosuid_transition;\nstruct policydb policydb;\n\nstatic void security_load_policycaps(void)\n{\n\tunsigned int i;\n\tstruct ebitmap_node *node;\n\n\tselinux_policycap_netpeer = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_NETPEER);\n\tselinux_policycap_openperm = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_OPENPERM);\n\tselinux_policycap_extsockclass = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t  POLICYDB_CAPABILITY_EXTSOCKCLASS);\n\tselinux_policycap_alwaysnetwork = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_ALWAYSNETWORK);\n\tselinux_policycap_cgroupseclabel =\n\t\tebitmap_get_bit(&policydb.policycaps,\n\t\t\t\tPOLICYDB_CAPABILITY_CGROUPSECLABEL);\n\tselinux_policycap_nnp_nosuid_transition =\n\t\tebitmap_get_bit(&policydb.policycaps,\n\t\t\t\tPOLICYDB_CAPABILITY_NNP_NOSUID_TRANSITION);\n\n\tfor (i = 0; i < ARRAY_SIZE(selinux_policycap_names); i++)\n\t\tpr_info(\"SELinux:  policy capability %s=%d\\n\",\n\t\t\tselinux_policycap_names[i],\n\t\t\tebitmap_get_bit(&policydb.policycaps, i));\n\n\tebitmap_for_each_positive_bit(&policydb.policycaps, node, i) {\n\t\tif (i >= ARRAY_SIZE(selinux_policycap_names))\n\t\t\tpr_info(\"SELinux:  unknown policy capability %u\\n\",\n\t\t\t\ti);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_set",
          "args": [
            "&sidtab",
            "&newsidtab"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "285-298",
          "snippet": "void sidtab_set(struct sidtab *dst, struct sidtab *src)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&src->lock, flags);\n\tdst->htable = src->htable;\n\tdst->nel = src->nel;\n\tdst->next_sid = src->next_sid;\n\tdst->shutdown = 0;\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++)\n\t\tdst->cache[i] = NULL;\n\tspin_unlock_irqrestore(&src->lock, flags);\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid sidtab_set(struct sidtab *dst, struct sidtab *src)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&src->lock, flags);\n\tdst->htable = src->htable;\n\tdst->nel = src->nel;\n\tdst->next_sid = src->next_sid;\n\tdst->shutdown = 0;\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++)\n\t\tdst->cache[i] = NULL;\n\tspin_unlock_irqrestore(&src->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&policydb",
            "newpolicydb",
            "sizeof(policydb)"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&policy_rwlock"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "oldpolicydb",
            "&policydb",
            "sizeof(policydb)"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  unable to convert the internal\"\n\t\t\t\" representation of contexts in the new SID\"\n\t\t\t\" table\\n\""
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_map",
          "args": [
            "&newsidtab",
            "convert_context",
            "&args"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "119-142",
          "snippet": "int sidtab_map(struct sidtab *s,\n\t       int (*apply) (u32 sid,\n\t\t\t     struct context *context,\n\t\t\t     void *args),\n\t       void *args)\n{\n\tint i, rc = 0;\n\tstruct sidtab_node *cur;\n\n\tif (!s)\n\t\tgoto out;\n\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = s->htable[i];\n\t\twhile (cur) {\n\t\t\trc = apply(cur->sid, &cur->context, args);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_map(struct sidtab *s,\n\t       int (*apply) (u32 sid,\n\t\t\t     struct context *context,\n\t\t\t     void *args),\n\t       void *args)\n{\n\tint i, rc = 0;\n\tstruct sidtab_node *cur;\n\n\tif (!s)\n\t\tgoto out;\n\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = s->htable[i];\n\t\twhile (cur) {\n\t\t\trc = apply(cur->sid, &cur->context, args);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_shutdown",
          "args": [
            "&sidtab"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "300-307",
          "snippet": "void sidtab_shutdown(struct sidtab *s)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\ts->shutdown = 1;\n\tspin_unlock_irqrestore(&s->lock, flags);\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid sidtab_shutdown(struct sidtab *s)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->lock, flags);\n\ts->shutdown = 1;\n\tspin_unlock_irqrestore(&s->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  unable to preserve booleans\\n\""
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_preserve_bools",
          "args": [
            "newpolicydb"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "security_preserve_bools",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2815-2844",
          "snippet": "static int security_preserve_bools(struct policydb *p)\n{\n\tint rc, nbools = 0, *bvalues = NULL, i;\n\tchar **bnames = NULL;\n\tstruct cond_bool_datum *booldatum;\n\tstruct cond_node *cur;\n\n\trc = security_get_bools(&nbools, &bnames, &bvalues);\n\tif (rc)\n\t\tgoto out;\n\tfor (i = 0; i < nbools; i++) {\n\t\tbooldatum = hashtab_search(p->p_bools.table, bnames[i]);\n\t\tif (booldatum)\n\t\t\tbooldatum->state = bvalues[i];\n\t}\n\tfor (cur = p->cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(p, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (bnames) {\n\t\tfor (i = 0; i < nbools; i++)\n\t\t\tkfree(bnames[i]);\n\t}\n\tkfree(bnames);\n\tkfree(bvalues);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;",
            "static int security_preserve_bools(struct policydb *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic int security_preserve_bools(struct policydb *p);\n\nstatic int security_preserve_bools(struct policydb *p)\n{\n\tint rc, nbools = 0, *bvalues = NULL, i;\n\tchar **bnames = NULL;\n\tstruct cond_bool_datum *booldatum;\n\tstruct cond_node *cur;\n\n\trc = security_get_bools(&nbools, &bnames, &bvalues);\n\tif (rc)\n\t\tgoto out;\n\tfor (i = 0; i < nbools; i++) {\n\t\tbooldatum = hashtab_search(p->p_bools.table, bnames[i]);\n\t\tif (booldatum)\n\t\t\tbooldatum->state = bvalues[i];\n\t}\n\tfor (cur = p->cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(p, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (bnames) {\n\t\tfor (i = 0; i < nbools; i++)\n\t\t\tkfree(bnames[i]);\n\t}\n\tkfree(bnames);\n\tkfree(bvalues);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_set_mapping",
          "args": [
            "newpolicydb",
            "secclass_map",
            "&map",
            "&map_size"
          ],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_set_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "123-203",
          "snippet": "static int selinux_set_mapping(struct policydb *pol,\n\t\t\t       struct security_class_mapping *map,\n\t\t\t       struct selinux_mapping **out_map_p,\n\t\t\t       u16 *out_map_size)\n{\n\tstruct selinux_mapping *out_map = NULL;\n\tsize_t size = sizeof(struct selinux_mapping);\n\tu16 i, j;\n\tunsigned k;\n\tbool print_unknown_handle = false;\n\n\t/* Find number of classes in the input mapping */\n\tif (!map)\n\t\treturn -EINVAL;\n\ti = 0;\n\twhile (map[i].name)\n\t\ti++;\n\n\t/* Allocate space for the class records, plus one for class zero */\n\tout_map = kcalloc(++i, size, GFP_ATOMIC);\n\tif (!out_map)\n\t\treturn -ENOMEM;\n\n\t/* Store the raw class and permission values */\n\tj = 0;\n\twhile (map[j].name) {\n\t\tstruct security_class_mapping *p_in = map + (j++);\n\t\tstruct selinux_mapping *p_out = out_map + j;\n\n\t\t/* An empty class string skips ahead */\n\t\tif (!strcmp(p_in->name, \"\")) {\n\t\t\tp_out->num_perms = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp_out->value = string_to_security_class(pol, p_in->name);\n\t\tif (!p_out->value) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"SELinux:  Class %s not defined in policy.\\n\",\n\t\t\t       p_in->name);\n\t\t\tif (pol->reject_unknown)\n\t\t\t\tgoto err;\n\t\t\tp_out->num_perms = 0;\n\t\t\tprint_unknown_handle = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tk = 0;\n\t\twhile (p_in->perms[k]) {\n\t\t\t/* An empty permission string skips ahead */\n\t\t\tif (!*p_in->perms[k]) {\n\t\t\t\tk++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp_out->perms[k] = string_to_av_perm(pol, p_out->value,\n\t\t\t\t\t\t\t    p_in->perms[k]);\n\t\t\tif (!p_out->perms[k]) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"SELinux:  Permission %s in class %s not defined in policy.\\n\",\n\t\t\t\t       p_in->perms[k], p_in->name);\n\t\t\t\tif (pol->reject_unknown)\n\t\t\t\t\tgoto err;\n\t\t\t\tprint_unknown_handle = true;\n\t\t\t}\n\n\t\t\tk++;\n\t\t}\n\t\tp_out->num_perms = k;\n\t}\n\n\tif (print_unknown_handle)\n\t\tprintk(KERN_INFO \"SELinux: the above unknown classes and permissions will be %s\\n\",\n\t\t       pol->allow_unknown ? \"allowed\" : \"denied\");\n\n\t*out_map_p = out_map;\n\t*out_map_size = i;\n\treturn 0;\nerr:\n\tkfree(out_map);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nstatic int selinux_set_mapping(struct policydb *pol,\n\t\t\t       struct security_class_mapping *map,\n\t\t\t       struct selinux_mapping **out_map_p,\n\t\t\t       u16 *out_map_size)\n{\n\tstruct selinux_mapping *out_map = NULL;\n\tsize_t size = sizeof(struct selinux_mapping);\n\tu16 i, j;\n\tunsigned k;\n\tbool print_unknown_handle = false;\n\n\t/* Find number of classes in the input mapping */\n\tif (!map)\n\t\treturn -EINVAL;\n\ti = 0;\n\twhile (map[i].name)\n\t\ti++;\n\n\t/* Allocate space for the class records, plus one for class zero */\n\tout_map = kcalloc(++i, size, GFP_ATOMIC);\n\tif (!out_map)\n\t\treturn -ENOMEM;\n\n\t/* Store the raw class and permission values */\n\tj = 0;\n\twhile (map[j].name) {\n\t\tstruct security_class_mapping *p_in = map + (j++);\n\t\tstruct selinux_mapping *p_out = out_map + j;\n\n\t\t/* An empty class string skips ahead */\n\t\tif (!strcmp(p_in->name, \"\")) {\n\t\t\tp_out->num_perms = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp_out->value = string_to_security_class(pol, p_in->name);\n\t\tif (!p_out->value) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"SELinux:  Class %s not defined in policy.\\n\",\n\t\t\t       p_in->name);\n\t\t\tif (pol->reject_unknown)\n\t\t\t\tgoto err;\n\t\t\tp_out->num_perms = 0;\n\t\t\tprint_unknown_handle = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tk = 0;\n\t\twhile (p_in->perms[k]) {\n\t\t\t/* An empty permission string skips ahead */\n\t\t\tif (!*p_in->perms[k]) {\n\t\t\t\tk++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp_out->perms[k] = string_to_av_perm(pol, p_out->value,\n\t\t\t\t\t\t\t    p_in->perms[k]);\n\t\t\tif (!p_out->perms[k]) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"SELinux:  Permission %s in class %s not defined in policy.\\n\",\n\t\t\t\t       p_in->perms[k], p_in->name);\n\t\t\t\tif (pol->reject_unknown)\n\t\t\t\t\tgoto err;\n\t\t\t\tprint_unknown_handle = true;\n\t\t\t}\n\n\t\t\tk++;\n\t\t}\n\t\tp_out->num_perms = k;\n\t}\n\n\tif (print_unknown_handle)\n\t\tprintk(KERN_INFO \"SELinux: the above unknown classes and permissions will be %s\\n\",\n\t\t       pol->allow_unknown ? \"allowed\" : \"denied\");\n\n\t*out_map_p = out_map;\n\t*out_map_size = i;\n\treturn 0;\nerr:\n\tkfree(out_map);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  unable to load the initial SIDs\\n\""
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policydb_load_isids",
          "args": [
            "newpolicydb",
            "&newsidtab"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_load_isids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "893-923",
          "snippet": "int policydb_load_isids(struct policydb *p, struct sidtab *s)\n{\n\tstruct ocontext *head, *c;\n\tint rc;\n\n\trc = sidtab_init(s);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  out of memory on SID table init\\n\");\n\t\tgoto out;\n\t}\n\n\thead = p->ocontexts[OCON_ISID];\n\tfor (c = head; c; c = c->next) {\n\t\trc = -EINVAL;\n\t\tif (!c->context[0].user) {\n\t\t\tprintk(KERN_ERR \"SELinux:  SID %s was never defined.\\n\",\n\t\t\t\tc->u.name);\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = sidtab_insert(s, c->sid[0], &c->context[0]);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux:  unable to load initial SID %s.\\n\",\n\t\t\t\tc->u.name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_load_isids(struct policydb *p, struct sidtab *s)\n{\n\tstruct ocontext *head, *c;\n\tint rc;\n\n\trc = sidtab_init(s);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  out of memory on SID table init\\n\");\n\t\tgoto out;\n\t}\n\n\thead = p->ocontexts[OCON_ISID];\n\tfor (c = head; c; c = c->next) {\n\t\trc = -EINVAL;\n\t\tif (!c->context[0].user) {\n\t\t\tprintk(KERN_ERR \"SELinux:  SID %s was never defined.\\n\",\n\t\t\t\tc->u.name);\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = sidtab_insert(s, c->sid[0], &c->context[0]);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux:  unable to load initial SID %s.\\n\",\n\t\t\t\tc->u.name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"SELinux: Enabling MLS support...\\n\""
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"SELinux: Disabling MLS support...\\n\""
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policydb_read",
          "args": [
            "newpolicydb",
            "fp"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "2276-2560",
          "snippet": "int policydb_read(struct policydb *p, void *fp)\n{\n\tstruct role_allow *ra, *lra;\n\tstruct role_trans *tr, *ltr;\n\tint i, j, rc;\n\t__le32 buf[4];\n\tu32 len, nprim, nel;\n\n\tchar *policydb_str;\n\tstruct policydb_compat_info *info;\n\n\trc = policydb_init(p);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Read the magic number and string length. */\n\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tif (le32_to_cpu(buf[0]) != POLICYDB_MAGIC) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb magic number 0x%x does \"\n\t\t       \"not match expected magic number 0x%x\\n\",\n\t\t       le32_to_cpu(buf[0]), POLICYDB_MAGIC);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tlen = le32_to_cpu(buf[1]);\n\tif (len != strlen(POLICYDB_STRING)) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb string length %d does not \"\n\t\t       \"match expected length %zu\\n\",\n\t\t       len, strlen(POLICYDB_STRING));\n\t\tgoto bad;\n\t}\n\n\trc = -ENOMEM;\n\tpolicydb_str = kmalloc(len + 1, GFP_KERNEL);\n\tif (!policydb_str) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to allocate memory for policydb \"\n\t\t       \"string of length %d\\n\", len);\n\t\tgoto bad;\n\t}\n\n\trc = next_entry(policydb_str, fp, len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  truncated policydb string identifier\\n\");\n\t\tkfree(policydb_str);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tpolicydb_str[len] = '\\0';\n\tif (strcmp(policydb_str, POLICYDB_STRING)) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb string %s does not match \"\n\t\t       \"my string %s\\n\", policydb_str, POLICYDB_STRING);\n\t\tkfree(policydb_str);\n\t\tgoto bad;\n\t}\n\t/* Done with policydb_str. */\n\tkfree(policydb_str);\n\tpolicydb_str = NULL;\n\n\t/* Read the version and table sizes. */\n\trc = next_entry(buf, fp, sizeof(u32)*4);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tp->policyvers = le32_to_cpu(buf[0]);\n\tif (p->policyvers < POLICYDB_VERSION_MIN ||\n\t    p->policyvers > POLICYDB_VERSION_MAX) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb version %d does not match \"\n\t\t       \"my version range %d-%d\\n\",\n\t\t       le32_to_cpu(buf[0]), POLICYDB_VERSION_MIN, POLICYDB_VERSION_MAX);\n\t\tgoto bad;\n\t}\n\n\tif ((le32_to_cpu(buf[1]) & POLICYDB_CONFIG_MLS)) {\n\t\tp->mls_enabled = 1;\n\n\t\trc = -EINVAL;\n\t\tif (p->policyvers < POLICYDB_VERSION_MLS) {\n\t\t\tprintk(KERN_ERR \"SELinux: security policydb version %d \"\n\t\t\t\t\"(MLS) not backwards compatible\\n\",\n\t\t\t\tp->policyvers);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tp->reject_unknown = !!(le32_to_cpu(buf[1]) & REJECT_UNKNOWN);\n\tp->allow_unknown = !!(le32_to_cpu(buf[1]) & ALLOW_UNKNOWN);\n\n\tif (p->policyvers >= POLICYDB_VERSION_POLCAP) {\n\t\trc = ebitmap_read(&p->policycaps, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_PERMISSIVE) {\n\t\trc = ebitmap_read(&p->permissive_map, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tinfo = policydb_lookup_compat(p->policyvers);\n\tif (!info) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to find policy compat info \"\n\t\t       \"for version %d\\n\", p->policyvers);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tif (le32_to_cpu(buf[2]) != info->sym_num ||\n\t\tle32_to_cpu(buf[3]) != info->ocon_num) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb table sizes (%d,%d) do \"\n\t\t       \"not match mine (%d,%d)\\n\", le32_to_cpu(buf[2]),\n\t\t\tle32_to_cpu(buf[3]),\n\t\t       info->sym_num, info->ocon_num);\n\t\tgoto bad;\n\t}\n\n\tfor (i = 0; i < info->sym_num; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\tnprim = le32_to_cpu(buf[0]);\n\t\tnel = le32_to_cpu(buf[1]);\n\t\tfor (j = 0; j < nel; j++) {\n\t\t\trc = read_f[i](p, p->symtab[i].table, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t}\n\n\t\tp->symtab[i].nprim = nprim;\n\t}\n\n\trc = -EINVAL;\n\tp->process_class = string_to_security_class(p, \"process\");\n\tif (!p->process_class)\n\t\tgoto bad;\n\n\trc = avtab_read(&p->te_avtab, fp, p);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOOL) {\n\t\trc = cond_read_list(p, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto bad;\n\tnel = le32_to_cpu(buf[0]);\n\tltr = NULL;\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\ttr = kzalloc(sizeof(*tr), GFP_KERNEL);\n\t\tif (!tr)\n\t\t\tgoto bad;\n\t\tif (ltr)\n\t\t\tltr->next = tr;\n\t\telse\n\t\t\tp->role_tr = tr;\n\t\trc = next_entry(buf, fp, sizeof(u32)*3);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trc = -EINVAL;\n\t\ttr->role = le32_to_cpu(buf[0]);\n\t\ttr->type = le32_to_cpu(buf[1]);\n\t\ttr->new_role = le32_to_cpu(buf[2]);\n\t\tif (p->policyvers >= POLICYDB_VERSION_ROLETRANS) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t\ttr->tclass = le32_to_cpu(buf[0]);\n\t\t} else\n\t\t\ttr->tclass = p->process_class;\n\n\t\trc = -EINVAL;\n\t\tif (!policydb_role_isvalid(p, tr->role) ||\n\t\t    !policydb_type_isvalid(p, tr->type) ||\n\t\t    !policydb_class_isvalid(p, tr->tclass) ||\n\t\t    !policydb_role_isvalid(p, tr->new_role))\n\t\t\tgoto bad;\n\t\tltr = tr;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto bad;\n\tnel = le32_to_cpu(buf[0]);\n\tlra = NULL;\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\tra = kzalloc(sizeof(*ra), GFP_KERNEL);\n\t\tif (!ra)\n\t\t\tgoto bad;\n\t\tif (lra)\n\t\t\tlra->next = ra;\n\t\telse\n\t\t\tp->role_allow = ra;\n\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trc = -EINVAL;\n\t\tra->role = le32_to_cpu(buf[0]);\n\t\tra->new_role = le32_to_cpu(buf[1]);\n\t\tif (!policydb_role_isvalid(p, ra->role) ||\n\t\t    !policydb_role_isvalid(p, ra->new_role))\n\t\t\tgoto bad;\n\t\tlra = ra;\n\t}\n\n\trc = filename_trans_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = policydb_index(p);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tp->process_trans_perms = string_to_av_perm(p, p->process_class, \"transition\");\n\tp->process_trans_perms |= string_to_av_perm(p, p->process_class, \"dyntransition\");\n\tif (!p->process_trans_perms)\n\t\tgoto bad;\n\n\trc = ocontext_read(p, info, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = genfs_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = range_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -ENOMEM;\n\tp->type_attr_map_array = flex_array_alloc(sizeof(struct ebitmap),\n\t\t\t\t\t\t  p->p_types.nprim,\n\t\t\t\t\t\t  GFP_KERNEL | __GFP_ZERO);\n\tif (!p->type_attr_map_array)\n\t\tgoto bad;\n\n\t/* preallocate so we don't have to worry about the put ever failing */\n\trc = flex_array_prealloc(p->type_attr_map_array, 0, p->p_types.nprim,\n\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\tif (rc)\n\t\tgoto bad;\n\n\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\tstruct ebitmap *e = flex_array_get(p->type_attr_map_array, i);\n\n\t\tBUG_ON(!e);\n\t\tebitmap_init(e);\n\t\tif (p->policyvers >= POLICYDB_VERSION_AVTAB) {\n\t\t\trc = ebitmap_read(e, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t}\n\t\t/* add the type itself as the degenerate case */\n\t\trc = ebitmap_set_bit(e, i, 1);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = policydb_bounds_sanity_check(p);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tpolicydb_destroy(p);\n\tgoto out;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*read_f[SYM_NUM]) (struct policydb *p, struct hashtab *h, void *fp) =\n{\n\tcommon_read,\n\tclass_read,\n\trole_read,\n\ttype_read,\n\tuser_read,\n\tcond_read_bool,\n\tsens_read,\n\tcat_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int (*read_f[SYM_NUM]) (struct policydb *p, struct hashtab *h, void *fp) =\n{\n\tcommon_read,\n\tclass_read,\n\trole_read,\n\ttype_read,\n\tuser_read,\n\tcond_read_bool,\n\tsens_read,\n\tcat_read,\n};\n\nint policydb_read(struct policydb *p, void *fp)\n{\n\tstruct role_allow *ra, *lra;\n\tstruct role_trans *tr, *ltr;\n\tint i, j, rc;\n\t__le32 buf[4];\n\tu32 len, nprim, nel;\n\n\tchar *policydb_str;\n\tstruct policydb_compat_info *info;\n\n\trc = policydb_init(p);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Read the magic number and string length. */\n\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tif (le32_to_cpu(buf[0]) != POLICYDB_MAGIC) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb magic number 0x%x does \"\n\t\t       \"not match expected magic number 0x%x\\n\",\n\t\t       le32_to_cpu(buf[0]), POLICYDB_MAGIC);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tlen = le32_to_cpu(buf[1]);\n\tif (len != strlen(POLICYDB_STRING)) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb string length %d does not \"\n\t\t       \"match expected length %zu\\n\",\n\t\t       len, strlen(POLICYDB_STRING));\n\t\tgoto bad;\n\t}\n\n\trc = -ENOMEM;\n\tpolicydb_str = kmalloc(len + 1, GFP_KERNEL);\n\tif (!policydb_str) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to allocate memory for policydb \"\n\t\t       \"string of length %d\\n\", len);\n\t\tgoto bad;\n\t}\n\n\trc = next_entry(policydb_str, fp, len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  truncated policydb string identifier\\n\");\n\t\tkfree(policydb_str);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tpolicydb_str[len] = '\\0';\n\tif (strcmp(policydb_str, POLICYDB_STRING)) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb string %s does not match \"\n\t\t       \"my string %s\\n\", policydb_str, POLICYDB_STRING);\n\t\tkfree(policydb_str);\n\t\tgoto bad;\n\t}\n\t/* Done with policydb_str. */\n\tkfree(policydb_str);\n\tpolicydb_str = NULL;\n\n\t/* Read the version and table sizes. */\n\trc = next_entry(buf, fp, sizeof(u32)*4);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tp->policyvers = le32_to_cpu(buf[0]);\n\tif (p->policyvers < POLICYDB_VERSION_MIN ||\n\t    p->policyvers > POLICYDB_VERSION_MAX) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb version %d does not match \"\n\t\t       \"my version range %d-%d\\n\",\n\t\t       le32_to_cpu(buf[0]), POLICYDB_VERSION_MIN, POLICYDB_VERSION_MAX);\n\t\tgoto bad;\n\t}\n\n\tif ((le32_to_cpu(buf[1]) & POLICYDB_CONFIG_MLS)) {\n\t\tp->mls_enabled = 1;\n\n\t\trc = -EINVAL;\n\t\tif (p->policyvers < POLICYDB_VERSION_MLS) {\n\t\t\tprintk(KERN_ERR \"SELinux: security policydb version %d \"\n\t\t\t\t\"(MLS) not backwards compatible\\n\",\n\t\t\t\tp->policyvers);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tp->reject_unknown = !!(le32_to_cpu(buf[1]) & REJECT_UNKNOWN);\n\tp->allow_unknown = !!(le32_to_cpu(buf[1]) & ALLOW_UNKNOWN);\n\n\tif (p->policyvers >= POLICYDB_VERSION_POLCAP) {\n\t\trc = ebitmap_read(&p->policycaps, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_PERMISSIVE) {\n\t\trc = ebitmap_read(&p->permissive_map, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tinfo = policydb_lookup_compat(p->policyvers);\n\tif (!info) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to find policy compat info \"\n\t\t       \"for version %d\\n\", p->policyvers);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tif (le32_to_cpu(buf[2]) != info->sym_num ||\n\t\tle32_to_cpu(buf[3]) != info->ocon_num) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb table sizes (%d,%d) do \"\n\t\t       \"not match mine (%d,%d)\\n\", le32_to_cpu(buf[2]),\n\t\t\tle32_to_cpu(buf[3]),\n\t\t       info->sym_num, info->ocon_num);\n\t\tgoto bad;\n\t}\n\n\tfor (i = 0; i < info->sym_num; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\tnprim = le32_to_cpu(buf[0]);\n\t\tnel = le32_to_cpu(buf[1]);\n\t\tfor (j = 0; j < nel; j++) {\n\t\t\trc = read_f[i](p, p->symtab[i].table, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t}\n\n\t\tp->symtab[i].nprim = nprim;\n\t}\n\n\trc = -EINVAL;\n\tp->process_class = string_to_security_class(p, \"process\");\n\tif (!p->process_class)\n\t\tgoto bad;\n\n\trc = avtab_read(&p->te_avtab, fp, p);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOOL) {\n\t\trc = cond_read_list(p, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto bad;\n\tnel = le32_to_cpu(buf[0]);\n\tltr = NULL;\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\ttr = kzalloc(sizeof(*tr), GFP_KERNEL);\n\t\tif (!tr)\n\t\t\tgoto bad;\n\t\tif (ltr)\n\t\t\tltr->next = tr;\n\t\telse\n\t\t\tp->role_tr = tr;\n\t\trc = next_entry(buf, fp, sizeof(u32)*3);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trc = -EINVAL;\n\t\ttr->role = le32_to_cpu(buf[0]);\n\t\ttr->type = le32_to_cpu(buf[1]);\n\t\ttr->new_role = le32_to_cpu(buf[2]);\n\t\tif (p->policyvers >= POLICYDB_VERSION_ROLETRANS) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t\ttr->tclass = le32_to_cpu(buf[0]);\n\t\t} else\n\t\t\ttr->tclass = p->process_class;\n\n\t\trc = -EINVAL;\n\t\tif (!policydb_role_isvalid(p, tr->role) ||\n\t\t    !policydb_type_isvalid(p, tr->type) ||\n\t\t    !policydb_class_isvalid(p, tr->tclass) ||\n\t\t    !policydb_role_isvalid(p, tr->new_role))\n\t\t\tgoto bad;\n\t\tltr = tr;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto bad;\n\tnel = le32_to_cpu(buf[0]);\n\tlra = NULL;\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\tra = kzalloc(sizeof(*ra), GFP_KERNEL);\n\t\tif (!ra)\n\t\t\tgoto bad;\n\t\tif (lra)\n\t\t\tlra->next = ra;\n\t\telse\n\t\t\tp->role_allow = ra;\n\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trc = -EINVAL;\n\t\tra->role = le32_to_cpu(buf[0]);\n\t\tra->new_role = le32_to_cpu(buf[1]);\n\t\tif (!policydb_role_isvalid(p, ra->role) ||\n\t\t    !policydb_role_isvalid(p, ra->new_role))\n\t\t\tgoto bad;\n\t\tlra = ra;\n\t}\n\n\trc = filename_trans_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = policydb_index(p);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tp->process_trans_perms = string_to_av_perm(p, p->process_class, \"transition\");\n\tp->process_trans_perms |= string_to_av_perm(p, p->process_class, \"dyntransition\");\n\tif (!p->process_trans_perms)\n\t\tgoto bad;\n\n\trc = ocontext_read(p, info, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = genfs_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = range_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -ENOMEM;\n\tp->type_attr_map_array = flex_array_alloc(sizeof(struct ebitmap),\n\t\t\t\t\t\t  p->p_types.nprim,\n\t\t\t\t\t\t  GFP_KERNEL | __GFP_ZERO);\n\tif (!p->type_attr_map_array)\n\t\tgoto bad;\n\n\t/* preallocate so we don't have to worry about the put ever failing */\n\trc = flex_array_prealloc(p->type_attr_map_array, 0, p->p_types.nprim,\n\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\tif (rc)\n\t\tgoto bad;\n\n\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\tstruct ebitmap *e = flex_array_get(p->type_attr_map_array, i);\n\n\t\tBUG_ON(!e);\n\t\tebitmap_init(e);\n\t\tif (p->policyvers >= POLICYDB_VERSION_AVTAB) {\n\t\t\trc = ebitmap_read(e, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t}\n\t\t/* add the type itself as the degenerate case */\n\t\trc = ebitmap_set_bit(e, i, 1);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = policydb_bounds_sanity_check(p);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tpolicydb_destroy(p);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_hash_eval",
          "args": [
            "&sidtab",
            "\"sids\""
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_hash_eval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "234-259",
          "snippet": "void sidtab_hash_eval(struct sidtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tstruct sidtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = h->htable[i];\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"%s:  %d entries and %d/%d buckets used, longest \"\n\t       \"chain length %d\\n\", tag, h->nel, slots_used, SIDTAB_SIZE,\n\t       max_chain_len);\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid sidtab_hash_eval(struct sidtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tstruct sidtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < SIDTAB_SIZE; i++) {\n\t\tcur = h->htable[i];\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"%s:  %d entries and %d/%d buckets used, longest \"\n\t       \"chain length %d\\n\", tag, h->nel, slots_used, SIDTAB_SIZE,\n\t       max_chain_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_complete_init",
          "args": [],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_complete_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/hooks.c",
          "lines": "6675-6682",
          "snippet": "void selinux_complete_init(void)\n{\n\tprintk(KERN_DEBUG \"SELinux:  Completing initialization.\\n\");\n\n\t/* Set up any superblocks initialized prior to the policy load. */\n\tprintk(KERN_DEBUG \"SELinux:  Setting up existing superblocks.\\n\");\n\titerate_supers(delayed_superblock_init, NULL);\n}",
          "includes": [
            "#include \"avc_ss.h\"",
            "#include \"audit.h\"",
            "#include \"netlabel.h\"",
            "#include \"xfrm.h\"",
            "#include \"ibpkey.h\"",
            "#include \"netport.h\"",
            "#include \"netnode.h\"",
            "#include \"netif.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/bpf.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/export.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syslog.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/mutex.h>",
            "#include <linux/selinux.h>",
            "#include <linux/string.h>",
            "#include <linux/audit.h>",
            "#include <linux/personality.h>",
            "#include <linux/hugetlb.h>",
            "#include <net/ipv6.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/parser.h>",
            "#include <net/af_unix.h>\t/* for Unix socket types */",
            "#include <linux/un.h>\t\t/* for Unix socket types */",
            "#include <linux/quota.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <net/netlink.h>",
            "#include <linux/netdevice.h>\t/* for network interface checks */",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <net/netlabel.h>",
            "#include <net/net_namespace.h>",
            "#include <net/inet_connection_sock.h>",
            "#include <net/tcp.h>\t\t/* struct or_callable used in sock_rcv_skb */",
            "#include <net/ip.h>\t\t/* for local_port_range[] */",
            "#include <net/icmp.h>",
            "#include <linux/tty.h>",
            "#include <linux/netfilter_ipv6.h>",
            "#include <linux/netfilter_ipv4.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swap.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/unistd.h>",
            "#include <linux/capability.h>",
            "#include <linux/xattr.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kd.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"avc_ss.h\"\n#include \"audit.h\"\n#include \"netlabel.h\"\n#include \"xfrm.h\"\n#include \"ibpkey.h\"\n#include \"netport.h\"\n#include \"netnode.h\"\n#include \"netif.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/bpf.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/export.h>\n#include <linux/user_namespace.h>\n#include <linux/syslog.h>\n#include <linux/posix-timers.h>\n#include <linux/mutex.h>\n#include <linux/selinux.h>\n#include <linux/string.h>\n#include <linux/audit.h>\n#include <linux/personality.h>\n#include <linux/hugetlb.h>\n#include <net/ipv6.h>\n#include <linux/nfs_mount.h>\n#include <linux/parser.h>\n#include <net/af_unix.h>\t/* for Unix socket types */\n#include <linux/un.h>\t\t/* for Unix socket types */\n#include <linux/quota.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <net/netlink.h>\n#include <linux/netdevice.h>\t/* for network interface checks */\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <net/netlabel.h>\n#include <net/net_namespace.h>\n#include <net/inet_connection_sock.h>\n#include <net/tcp.h>\t\t/* struct or_callable used in sock_rcv_skb */\n#include <net/ip.h>\t\t/* for local_port_range[] */\n#include <net/icmp.h>\n#include <linux/tty.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/swap.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/unistd.h>\n#include <linux/capability.h>\n#include <linux/xattr.h>\n#include <linux/lsm_hooks.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/errno.h>\n#include <linux/tracehook.h>\n#include <linux/kernel.h>\n#include <linux/kd.h>\n#include <linux/init.h>\n\nvoid selinux_complete_init(void)\n{\n\tprintk(KERN_DEBUG \"SELinux:  Completing initialization.\\n\");\n\n\t/* Set up any superblocks initialized prior to the policy load. */\n\tprintk(KERN_DEBUG \"SELinux:  Setting up existing superblocks.\\n\");\n\titerate_supers(delayed_superblock_init, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_cache_destroy",
          "args": [],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_cache_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "179-182",
          "snippet": "void hashtab_cache_destroy(void)\n{\n\t\tkmem_cache_destroy(hashtab_node_cachep);\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nvoid hashtab_cache_destroy(void)\n{\n\t\tkmem_cache_destroy(hashtab_node_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_cache_destroy",
          "args": [],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_cache_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "533-536",
          "snippet": "void ebitmap_cache_destroy(void)\n{\n\tkmem_cache_destroy(ebitmap_node_cachep);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_cache_destroy(void)\n{\n\tkmem_cache_destroy(ebitmap_node_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avtab_cache_destroy",
          "args": [],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_cache_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "668-672",
          "snippet": "void avtab_cache_destroy(void)\n{\n\tkmem_cache_destroy(avtab_node_cachep);\n\tkmem_cache_destroy(avtab_xperms_cachep);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avtab_node_cachep;",
            "static struct kmem_cache *avtab_xperms_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *avtab_node_cachep;\nstatic struct kmem_cache *avtab_xperms_cachep;\n\nvoid avtab_cache_destroy(void)\n{\n\tkmem_cache_destroy(avtab_node_cachep);\n\tkmem_cache_destroy(avtab_xperms_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_cache_init",
          "args": [],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "172-177",
          "snippet": "void hashtab_cache_init(void)\n{\n\t\thashtab_node_cachep = kmem_cache_create(\"hashtab_node\",\n\t\t\tsizeof(struct hashtab_node),\n\t\t\t0, SLAB_PANIC, NULL);\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nvoid hashtab_cache_init(void)\n{\n\t\thashtab_node_cachep = kmem_cache_create(\"hashtab_node\",\n\t\t\tsizeof(struct hashtab_node),\n\t\t\t0, SLAB_PANIC, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_cache_init",
          "args": [],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "526-531",
          "snippet": "void ebitmap_cache_init(void)\n{\n\tebitmap_node_cachep = kmem_cache_create(\"ebitmap_node\",\n\t\t\t\t\t\t\tsizeof(struct ebitmap_node),\n\t\t\t\t\t\t\t0, SLAB_PANIC, NULL);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_cache_init(void)\n{\n\tebitmap_node_cachep = kmem_cache_create(\"ebitmap_node\",\n\t\t\t\t\t\t\tsizeof(struct ebitmap_node),\n\t\t\t\t\t\t\t0, SLAB_PANIC, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avtab_cache_init",
          "args": [],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "658-666",
          "snippet": "void avtab_cache_init(void)\n{\n\tavtab_node_cachep = kmem_cache_create(\"avtab_node\",\n\t\t\t\t\t      sizeof(struct avtab_node),\n\t\t\t\t\t      0, SLAB_PANIC, NULL);\n\tavtab_xperms_cachep = kmem_cache_create(\"avtab_extended_perms\",\n\t\t\t\t\t\tsizeof(struct avtab_extended_perms),\n\t\t\t\t\t\t0, SLAB_PANIC, NULL);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avtab_node_cachep;",
            "static struct kmem_cache *avtab_xperms_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *avtab_node_cachep;\nstatic struct kmem_cache *avtab_xperms_cachep;\n\nvoid avtab_cache_init(void)\n{\n\tavtab_node_cachep = kmem_cache_create(\"avtab_node\",\n\t\t\t\t\t      sizeof(struct avtab_node),\n\t\t\t\t\t      0, SLAB_PANIC, NULL);\n\tavtab_xperms_cachep = kmem_cache_create(\"avtab_extended_perms\",\n\t\t\t\t\t\tsizeof(struct avtab_extended_perms),\n\t\t\t\t\t\t0, SLAB_PANIC, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "2 * sizeof(*oldpolicydb)",
            "GFP_KERNEL"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\nstatic u32 latest_granting;\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nint security_load_policy(void *data, size_t len)\n{\n\tstruct policydb *oldpolicydb, *newpolicydb;\n\tstruct sidtab oldsidtab, newsidtab;\n\tstruct selinux_mapping *oldmap, *map = NULL;\n\tstruct convert_context_args args;\n\tu32 seqno;\n\tu16 map_size;\n\tint rc = 0;\n\tstruct policy_file file = { data, len }, *fp = &file;\n\n\toldpolicydb = kzalloc(2 * sizeof(*oldpolicydb), GFP_KERNEL);\n\tif (!oldpolicydb) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnewpolicydb = oldpolicydb + 1;\n\n\tif (!ss_initialized) {\n\t\tavtab_cache_init();\n\t\tebitmap_cache_init();\n\t\thashtab_cache_init();\n\t\trc = policydb_read(&policydb, fp);\n\t\tif (rc) {\n\t\t\tavtab_cache_destroy();\n\t\t\tebitmap_cache_destroy();\n\t\t\thashtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\tpolicydb.len = len;\n\t\trc = selinux_set_mapping(&policydb, secclass_map,\n\t\t\t\t\t &current_mapping,\n\t\t\t\t\t &current_mapping_size);\n\t\tif (rc) {\n\t\t\tpolicydb_destroy(&policydb);\n\t\t\tavtab_cache_destroy();\n\t\t\tebitmap_cache_destroy();\n\t\t\thashtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = policydb_load_isids(&policydb, &sidtab);\n\t\tif (rc) {\n\t\t\tpolicydb_destroy(&policydb);\n\t\t\tavtab_cache_destroy();\n\t\t\tebitmap_cache_destroy();\n\t\t\thashtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\tsecurity_load_policycaps();\n\t\tss_initialized = 1;\n\t\tseqno = ++latest_granting;\n\t\tselinux_complete_init();\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_netlbl_cache_invalidate();\n\t\tselinux_xfrm_notify_policyload();\n\t\tgoto out;\n\t}\n\n#if 0\n\tsidtab_hash_eval(&sidtab, \"sids\");\n#endif\n\n\trc = policydb_read(newpolicydb, fp);\n\tif (rc)\n\t\tgoto out;\n\n\tnewpolicydb->len = len;\n\t/* If switching between different policy types, log MLS status */\n\tif (policydb.mls_enabled && !newpolicydb->mls_enabled)\n\t\tprintk(KERN_INFO \"SELinux: Disabling MLS support...\\n\");\n\telse if (!policydb.mls_enabled && newpolicydb->mls_enabled)\n\t\tprintk(KERN_INFO \"SELinux: Enabling MLS support...\\n\");\n\n\trc = policydb_load_isids(newpolicydb, &newsidtab);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to load the initial SIDs\\n\");\n\t\tpolicydb_destroy(newpolicydb);\n\t\tgoto out;\n\t}\n\n\trc = selinux_set_mapping(newpolicydb, secclass_map, &map, &map_size);\n\tif (rc)\n\t\tgoto err;\n\n\trc = security_preserve_bools(newpolicydb);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to preserve booleans\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Clone the SID table. */\n\tsidtab_shutdown(&sidtab);\n\n\trc = sidtab_map(&sidtab, clone_sid, &newsidtab);\n\tif (rc)\n\t\tgoto err;\n\n\t/*\n\t * Convert the internal representations of contexts\n\t * in the new SID table.\n\t */\n\targs.oldp = &policydb;\n\targs.newp = newpolicydb;\n\trc = sidtab_map(&newsidtab, convert_context, &args);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to convert the internal\"\n\t\t\t\" representation of contexts in the new SID\"\n\t\t\t\" table\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Save the old policydb and SID table to free later. */\n\tmemcpy(oldpolicydb, &policydb, sizeof(policydb));\n\tsidtab_set(&oldsidtab, &sidtab);\n\n\t/* Install the new policydb and SID table. */\n\twrite_lock_irq(&policy_rwlock);\n\tmemcpy(&policydb, newpolicydb, sizeof(policydb));\n\tsidtab_set(&sidtab, &newsidtab);\n\tsecurity_load_policycaps();\n\toldmap = current_mapping;\n\tcurrent_mapping = map;\n\tcurrent_mapping_size = map_size;\n\tseqno = ++latest_granting;\n\twrite_unlock_irq(&policy_rwlock);\n\n\t/* Free the old policydb and SID table. */\n\tpolicydb_destroy(oldpolicydb);\n\tsidtab_destroy(&oldsidtab);\n\tkfree(oldmap);\n\n\tavc_ss_reset(seqno);\n\tselnl_notify_policyload(seqno);\n\tselinux_status_update_policyload(seqno);\n\tselinux_netlbl_cache_invalidate();\n\tselinux_xfrm_notify_policyload();\n\n\trc = 0;\n\tgoto out;\n\nerr:\n\tkfree(map);\n\tsidtab_destroy(&newsidtab);\n\tpolicydb_destroy(newpolicydb);\n\nout:\n\tkfree(oldpolicydb);\n\treturn rc;\n}"
  },
  {
    "function_name": "security_load_policycaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1998-2028",
    "snippet": "static void security_load_policycaps(void)\n{\n\tunsigned int i;\n\tstruct ebitmap_node *node;\n\n\tselinux_policycap_netpeer = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_NETPEER);\n\tselinux_policycap_openperm = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_OPENPERM);\n\tselinux_policycap_extsockclass = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t  POLICYDB_CAPABILITY_EXTSOCKCLASS);\n\tselinux_policycap_alwaysnetwork = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_ALWAYSNETWORK);\n\tselinux_policycap_cgroupseclabel =\n\t\tebitmap_get_bit(&policydb.policycaps,\n\t\t\t\tPOLICYDB_CAPABILITY_CGROUPSECLABEL);\n\tselinux_policycap_nnp_nosuid_transition =\n\t\tebitmap_get_bit(&policydb.policycaps,\n\t\t\t\tPOLICYDB_CAPABILITY_NNP_NOSUID_TRANSITION);\n\n\tfor (i = 0; i < ARRAY_SIZE(selinux_policycap_names); i++)\n\t\tpr_info(\"SELinux:  policy capability %s=%d\\n\",\n\t\t\tselinux_policycap_names[i],\n\t\t\tebitmap_get_bit(&policydb.policycaps, i));\n\n\tebitmap_for_each_positive_bit(&policydb.policycaps, node, i) {\n\t\tif (i >= ARRAY_SIZE(selinux_policycap_names))\n\t\t\tpr_info(\"SELinux:  unknown policy capability %u\\n\",\n\t\t\t\ti);\n\t}\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *selinux_policycap_names[__POLICYDB_CAPABILITY_MAX] = {\n\t\"network_peer_controls\",\n\t\"open_perms\",\n\t\"extended_socket_class\",\n\t\"always_check_network\",\n\t\"cgroup_seclabel\",\n\t\"nnp_nosuid_transition\"\n};",
      "int selinux_policycap_netpeer;",
      "int selinux_policycap_openperm;",
      "int selinux_policycap_extsockclass;",
      "int selinux_policycap_alwaysnetwork;",
      "int selinux_policycap_cgroupseclabel;",
      "int selinux_policycap_nnp_nosuid_transition;",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"SELinux:  unknown policy capability %u\\n\"",
            "i"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "selinux_policycap_names"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "&policydb.policycaps",
            "node",
            "i"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"SELinux:  policy capability %s=%d\\n\"",
            "selinux_policycap_names[i]",
            "ebitmap_get_bit(&policydb.policycaps, i)"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_get_bit",
          "args": [
            "&policydb.policycaps",
            "i"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_get_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "242-257",
          "snippet": "int ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "selinux_policycap_names"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nchar *selinux_policycap_names[__POLICYDB_CAPABILITY_MAX] = {\n\t\"network_peer_controls\",\n\t\"open_perms\",\n\t\"extended_socket_class\",\n\t\"always_check_network\",\n\t\"cgroup_seclabel\",\n\t\"nnp_nosuid_transition\"\n};\nint selinux_policycap_netpeer;\nint selinux_policycap_openperm;\nint selinux_policycap_extsockclass;\nint selinux_policycap_alwaysnetwork;\nint selinux_policycap_cgroupseclabel;\nint selinux_policycap_nnp_nosuid_transition;\nstruct policydb policydb;\n\nstatic void security_load_policycaps(void)\n{\n\tunsigned int i;\n\tstruct ebitmap_node *node;\n\n\tselinux_policycap_netpeer = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_NETPEER);\n\tselinux_policycap_openperm = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_OPENPERM);\n\tselinux_policycap_extsockclass = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t  POLICYDB_CAPABILITY_EXTSOCKCLASS);\n\tselinux_policycap_alwaysnetwork = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_ALWAYSNETWORK);\n\tselinux_policycap_cgroupseclabel =\n\t\tebitmap_get_bit(&policydb.policycaps,\n\t\t\t\tPOLICYDB_CAPABILITY_CGROUPSECLABEL);\n\tselinux_policycap_nnp_nosuid_transition =\n\t\tebitmap_get_bit(&policydb.policycaps,\n\t\t\t\tPOLICYDB_CAPABILITY_NNP_NOSUID_TRANSITION);\n\n\tfor (i = 0; i < ARRAY_SIZE(selinux_policycap_names); i++)\n\t\tpr_info(\"SELinux:  policy capability %s=%d\\n\",\n\t\t\tselinux_policycap_names[i],\n\t\t\tebitmap_get_bit(&policydb.policycaps, i));\n\n\tebitmap_for_each_positive_bit(&policydb.policycaps, node, i) {\n\t\tif (i >= ARRAY_SIZE(selinux_policycap_names))\n\t\t\tpr_info(\"SELinux:  unknown policy capability %u\\n\",\n\t\t\t\ti);\n\t}\n}"
  },
  {
    "function_name": "convert_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1858-1996",
    "snippet": "static int convert_context(u32 key,\n\t\t\t   struct context *c,\n\t\t\t   void *p)\n{\n\tstruct convert_context_args *args;\n\tstruct context oldc;\n\tstruct ocontext *oc;\n\tstruct mls_range *range;\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *s;\n\tu32 len;\n\tint rc = 0;\n\n\tif (key <= SECINITSID_NUM)\n\t\tgoto out;\n\n\targs = p;\n\n\tif (c->str) {\n\t\tstruct context ctx;\n\n\t\trc = -ENOMEM;\n\t\ts = kstrdup(c->str, GFP_KERNEL);\n\t\tif (!s)\n\t\t\tgoto out;\n\n\t\trc = string_to_context_struct(args->newp, NULL, s,\n\t\t\t\t\t      c->len, &ctx, SECSID_NULL);\n\t\tkfree(s);\n\t\tif (!rc) {\n\t\t\tprintk(KERN_INFO \"SELinux:  Context %s became valid (mapped).\\n\",\n\t\t\t       c->str);\n\t\t\t/* Replace string with mapped representation. */\n\t\t\tkfree(c->str);\n\t\t\tmemcpy(c, &ctx, sizeof(*c));\n\t\t\tgoto out;\n\t\t} else if (rc == -EINVAL) {\n\t\t\t/* Retain string representation for later mapping. */\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* Other error condition, e.g. ENOMEM. */\n\t\t\tprintk(KERN_ERR \"SELinux:   Unable to map context %s, rc = %d.\\n\",\n\t\t\t       c->str, -rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = context_cpy(&oldc, c);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Convert the user. */\n\trc = -EINVAL;\n\tusrdatum = hashtab_search(args->newp->p_users.table,\n\t\t\t\t  sym_name(args->oldp, SYM_USERS, c->user - 1));\n\tif (!usrdatum)\n\t\tgoto bad;\n\tc->user = usrdatum->value;\n\n\t/* Convert the role. */\n\trc = -EINVAL;\n\trole = hashtab_search(args->newp->p_roles.table,\n\t\t\t      sym_name(args->oldp, SYM_ROLES, c->role - 1));\n\tif (!role)\n\t\tgoto bad;\n\tc->role = role->value;\n\n\t/* Convert the type. */\n\trc = -EINVAL;\n\ttypdatum = hashtab_search(args->newp->p_types.table,\n\t\t\t\t  sym_name(args->oldp, SYM_TYPES, c->type - 1));\n\tif (!typdatum)\n\t\tgoto bad;\n\tc->type = typdatum->value;\n\n\t/* Convert the MLS fields if dealing with MLS policies */\n\tif (args->oldp->mls_enabled && args->newp->mls_enabled) {\n\t\trc = mls_convert_context(args->oldp, args->newp, c);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t} else if (args->oldp->mls_enabled && !args->newp->mls_enabled) {\n\t\t/*\n\t\t * Switching between MLS and non-MLS policy:\n\t\t * free any storage used by the MLS fields in the\n\t\t * context for all existing entries in the sidtab.\n\t\t */\n\t\tmls_context_destroy(c);\n\t} else if (!args->oldp->mls_enabled && args->newp->mls_enabled) {\n\t\t/*\n\t\t * Switching between non-MLS and MLS policy:\n\t\t * ensure that the MLS fields of the context for all\n\t\t * existing entries in the sidtab are filled in with a\n\t\t * suitable default value, likely taken from one of the\n\t\t * initial SIDs.\n\t\t */\n\t\toc = args->newp->ocontexts[OCON_ISID];\n\t\twhile (oc && oc->sid[0] != SECINITSID_UNLABELED)\n\t\t\toc = oc->next;\n\t\trc = -EINVAL;\n\t\tif (!oc) {\n\t\t\tprintk(KERN_ERR \"SELinux:  unable to look up\"\n\t\t\t\t\" the initial SIDs list\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\trange = &oc->context[0].range;\n\t\trc = mls_range_set(c, range);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(args->newp, c)) {\n\t\trc = convert_context_handle_invalid_context(&oldc);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\tcontext_destroy(&oldc);\n\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\t/* Map old representation to string and save it. */\n\trc = context_struct_to_string(&oldc, &s, &len);\n\tif (rc)\n\t\treturn rc;\n\tcontext_destroy(&oldc);\n\tcontext_destroy(c);\n\tc->str = s;\n\tc->len = len;\n\tprintk(KERN_INFO \"SELinux:  Context %s became invalid (unmapped).\\n\",\n\t       c->str);\n\trc = 0;\n\tgoto out;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sidtab sidtab;",
      "static int security_preserve_bools(struct policydb *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"SELinux:  Context %s became invalid (unmapped).\\n\"",
            "c->str"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_destroy",
          "args": [
            "c"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "context_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "142-149",
          "snippet": "static inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_struct_to_string",
          "args": [
            "&oldc",
            "&s",
            "&len"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "context_struct_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1192-1238",
          "snippet": "static int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_context_handle_invalid_context",
          "args": [
            "&oldc"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "convert_context_handle_invalid_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1831-1844",
          "snippet": "static inline int convert_context_handle_invalid_context(struct context *context)\n{\n\tchar *s;\n\tu32 len;\n\n\tif (selinux_enforcing)\n\t\treturn -EINVAL;\n\n\tif (!context_struct_to_string(context, &s, &len)) {\n\t\tprintk(KERN_WARNING \"SELinux:  Context %s would be invalid if enforcing\\n\", s);\n\t\tkfree(s);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int convert_context_handle_invalid_context(struct context *context)\n{\n\tchar *s;\n\tu32 len;\n\n\tif (selinux_enforcing)\n\t\treturn -EINVAL;\n\n\tif (!context_struct_to_string(context, &s, &len)) {\n\t\tprintk(KERN_WARNING \"SELinux:  Context %s would be invalid if enforcing\\n\", s);\n\t\tkfree(s);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "policydb_context_isvalid",
          "args": [
            "args->newp",
            "c"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_context_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "950-989",
          "snippet": "int policydb_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct role_datum *role;\n\tstruct user_datum *usrdatum;\n\n\tif (!c->role || c->role > p->p_roles.nprim)\n\t\treturn 0;\n\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\n\tif (!c->type || c->type > p->p_types.nprim)\n\t\treturn 0;\n\n\tif (c->role != OBJECT_R_VAL) {\n\t\t/*\n\t\t * Role must be authorized for the type.\n\t\t */\n\t\trole = p->role_val_to_struct[c->role - 1];\n\t\tif (!role || !ebitmap_get_bit(&role->types, c->type - 1))\n\t\t\t/* role may not be associated with type */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * User must be authorized for the role.\n\t\t */\n\t\tusrdatum = p->user_val_to_struct[c->user - 1];\n\t\tif (!usrdatum)\n\t\t\treturn 0;\n\n\t\tif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\n\t\t\t/* user may not be associated with role */\n\t\t\treturn 0;\n\t}\n\n\tif (!mls_context_isvalid(p, c))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct role_datum *role;\n\tstruct user_datum *usrdatum;\n\n\tif (!c->role || c->role > p->p_roles.nprim)\n\t\treturn 0;\n\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\n\tif (!c->type || c->type > p->p_types.nprim)\n\t\treturn 0;\n\n\tif (c->role != OBJECT_R_VAL) {\n\t\t/*\n\t\t * Role must be authorized for the type.\n\t\t */\n\t\trole = p->role_val_to_struct[c->role - 1];\n\t\tif (!role || !ebitmap_get_bit(&role->types, c->type - 1))\n\t\t\t/* role may not be associated with type */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * User must be authorized for the role.\n\t\t */\n\t\tusrdatum = p->user_val_to_struct[c->user - 1];\n\t\tif (!usrdatum)\n\t\t\treturn 0;\n\n\t\tif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\n\t\t\t/* user may not be associated with role */\n\t\t\treturn 0;\n\t}\n\n\tif (!mls_context_isvalid(p, c))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_range_set",
          "args": [
            "c",
            "range"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "mls_range_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "403-418",
          "snippet": "int mls_range_set(struct context *context,\n\t\t\t\tstruct mls_range *range)\n{\n\tint l, rc = 0;\n\n\t/* Copy the MLS range into the  context */\n\tfor (l = 0; l < 2; l++) {\n\t\tcontext->range.level[l].sens = range->level[l].sens;\n\t\trc = ebitmap_cpy(&context->range.level[l].cat,\n\t\t\t\t &range->level[l].cat);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_range_set(struct context *context,\n\t\t\t\tstruct mls_range *range)\n{\n\tint l, rc = 0;\n\n\t/* Copy the MLS range into the  context */\n\tfor (l = 0; l < 2; l++) {\n\t\tcontext->range.level[l].sens = range->level[l].sens;\n\t\trc = ebitmap_cpy(&context->range.level[l].cat,\n\t\t\t\t &range->level[l].cat);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  unable to look up\"\n\t\t\t\t\" the initial SIDs list\\n\""
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mls_context_destroy",
          "args": [
            "c"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "mls_context_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "106-111",
          "snippet": "static inline void mls_context_destroy(struct context *c)\n{\n\tebitmap_destroy(&c->range.level[0].cat);\n\tebitmap_destroy(&c->range.level[1].cat);\n\tmls_context_init(c);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void mls_context_destroy(struct context *c)\n{\n\tebitmap_destroy(&c->range.level[0].cat);\n\tebitmap_destroy(&c->range.level[1].cat);\n\tmls_context_init(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_convert_context",
          "args": [
            "args->oldp",
            "args->newp",
            "c"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "mls_convert_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "463-504",
          "snippet": "int mls_convert_context(struct policydb *oldp,\n\t\t\tstruct policydb *newp,\n\t\t\tstruct context *c)\n{\n\tstruct level_datum *levdatum;\n\tstruct cat_datum *catdatum;\n\tstruct ebitmap bitmap;\n\tstruct ebitmap_node *node;\n\tint l, i;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tfor (l = 0; l < 2; l++) {\n\t\tlevdatum = hashtab_search(newp->p_levels.table,\n\t\t\t\t\t  sym_name(oldp, SYM_LEVELS,\n\t\t\t\t\t\t   c->range.level[l].sens - 1));\n\n\t\tif (!levdatum)\n\t\t\treturn -EINVAL;\n\t\tc->range.level[l].sens = levdatum->level->sens;\n\n\t\tebitmap_init(&bitmap);\n\t\tebitmap_for_each_positive_bit(&c->range.level[l].cat, node, i) {\n\t\t\tint rc;\n\n\t\t\tcatdatum = hashtab_search(newp->p_cats.table,\n\t\t\t\t\t\t  sym_name(oldp, SYM_CATS, i));\n\t\t\tif (!catdatum)\n\t\t\t\treturn -EINVAL;\n\t\t\trc = ebitmap_set_bit(&bitmap, catdatum->value - 1, 1);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tcond_resched();\n\t\t}\n\t\tebitmap_destroy(&c->range.level[l].cat);\n\t\tc->range.level[l].cat = bitmap;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_convert_context(struct policydb *oldp,\n\t\t\tstruct policydb *newp,\n\t\t\tstruct context *c)\n{\n\tstruct level_datum *levdatum;\n\tstruct cat_datum *catdatum;\n\tstruct ebitmap bitmap;\n\tstruct ebitmap_node *node;\n\tint l, i;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tfor (l = 0; l < 2; l++) {\n\t\tlevdatum = hashtab_search(newp->p_levels.table,\n\t\t\t\t\t  sym_name(oldp, SYM_LEVELS,\n\t\t\t\t\t\t   c->range.level[l].sens - 1));\n\n\t\tif (!levdatum)\n\t\t\treturn -EINVAL;\n\t\tc->range.level[l].sens = levdatum->level->sens;\n\n\t\tebitmap_init(&bitmap);\n\t\tebitmap_for_each_positive_bit(&c->range.level[l].cat, node, i) {\n\t\t\tint rc;\n\n\t\t\tcatdatum = hashtab_search(newp->p_cats.table,\n\t\t\t\t\t\t  sym_name(oldp, SYM_CATS, i));\n\t\t\tif (!catdatum)\n\t\t\t\treturn -EINVAL;\n\t\t\trc = ebitmap_set_bit(&bitmap, catdatum->value - 1, 1);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tcond_resched();\n\t\t}\n\t\tebitmap_destroy(&c->range.level[l].cat);\n\t\tc->range.level[l].cat = bitmap;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "args->newp->p_types.table",
            "sym_name(args->oldp, SYM_TYPES, c->type - 1)"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "args->oldp",
            "SYM_TYPES",
            "c->type - 1"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_cpy",
          "args": [
            "&oldc",
            "c"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "context_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "118-140",
          "snippet": "static inline int context_cpy(struct context *dst, struct context *src)\n{\n\tint rc;\n\n\tdst->user = src->user;\n\tdst->role = src->role;\n\tdst->type = src->type;\n\tif (src->str) {\n\t\tdst->str = kstrdup(src->str, GFP_ATOMIC);\n\t\tif (!dst->str)\n\t\t\treturn -ENOMEM;\n\t\tdst->len = src->len;\n\t} else {\n\t\tdst->str = NULL;\n\t\tdst->len = 0;\n\t}\n\trc = mls_context_cpy(dst, src);\n\tif (rc) {\n\t\tkfree(dst->str);\n\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline int context_cpy(struct context *dst, struct context *src)\n{\n\tint rc;\n\n\tdst->user = src->user;\n\tdst->role = src->role;\n\tdst->type = src->type;\n\tif (src->str) {\n\t\tdst->str = kstrdup(src->str, GFP_ATOMIC);\n\t\tif (!dst->str)\n\t\t\treturn -ENOMEM;\n\t\tdst->len = src->len;\n\t} else {\n\t\tdst->str = NULL;\n\t\tdst->len = 0;\n\t}\n\trc = mls_context_cpy(dst, src);\n\tif (rc) {\n\t\tkfree(dst->str);\n\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:   Unable to map context %s, rc = %d.\\n\"",
            "c->str",
            "-rc"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "c",
            "&ctx",
            "sizeof(*c)"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "c->str"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_to_context_struct",
          "args": [
            "args->newp",
            "NULL",
            "s",
            "c->len",
            "&ctx",
            "SECSID_NULL"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "string_to_context_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1322-1402",
          "snippet": "static int string_to_context_struct(struct policydb *pol,\n\t\t\t\t    struct sidtab *sidtabp,\n\t\t\t\t    char *scontext,\n\t\t\t\t    u32 scontext_len,\n\t\t\t\t    struct context *ctx,\n\t\t\t\t    u32 def_sid)\n{\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *scontextp, *p, oldc;\n\tint rc = 0;\n\n\tcontext_init(ctx);\n\n\t/* Parse the security context. */\n\n\trc = -EINVAL;\n\tscontextp = (char *) scontext;\n\n\t/* Extract the user. */\n\tp = scontextp;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\tusrdatum = hashtab_search(pol->p_users.table, scontextp);\n\tif (!usrdatum)\n\t\tgoto out;\n\n\tctx->user = usrdatum->value;\n\n\t/* Extract role. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\trole = hashtab_search(pol->p_roles.table, scontextp);\n\tif (!role)\n\t\tgoto out;\n\tctx->role = role->value;\n\n\t/* Extract type. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\toldc = *p;\n\t*p++ = 0;\n\n\ttypdatum = hashtab_search(pol->p_types.table, scontextp);\n\tif (!typdatum || typdatum->attribute)\n\t\tgoto out;\n\n\tctx->type = typdatum->value;\n\n\trc = mls_context_to_sid(pol, oldc, &p, ctx, sidtabp, def_sid);\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif ((p - scontext) < scontext_len)\n\t\tgoto out;\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(pol, ctx))\n\t\tgoto out;\n\trc = 0;\nout:\n\tif (rc)\n\t\tcontext_destroy(ctx);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);",
            "static int security_preserve_bools(struct policydb *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\nstatic int security_preserve_bools(struct policydb *p);\n\nstatic int string_to_context_struct(struct policydb *pol,\n\t\t\t\t    struct sidtab *sidtabp,\n\t\t\t\t    char *scontext,\n\t\t\t\t    u32 scontext_len,\n\t\t\t\t    struct context *ctx,\n\t\t\t\t    u32 def_sid)\n{\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *scontextp, *p, oldc;\n\tint rc = 0;\n\n\tcontext_init(ctx);\n\n\t/* Parse the security context. */\n\n\trc = -EINVAL;\n\tscontextp = (char *) scontext;\n\n\t/* Extract the user. */\n\tp = scontextp;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\tusrdatum = hashtab_search(pol->p_users.table, scontextp);\n\tif (!usrdatum)\n\t\tgoto out;\n\n\tctx->user = usrdatum->value;\n\n\t/* Extract role. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\trole = hashtab_search(pol->p_roles.table, scontextp);\n\tif (!role)\n\t\tgoto out;\n\tctx->role = role->value;\n\n\t/* Extract type. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\toldc = *p;\n\t*p++ = 0;\n\n\ttypdatum = hashtab_search(pol->p_types.table, scontextp);\n\tif (!typdatum || typdatum->attribute)\n\t\tgoto out;\n\n\tctx->type = typdatum->value;\n\n\trc = mls_context_to_sid(pol, oldc, &p, ctx, sidtabp, def_sid);\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif ((p - scontext) < scontext_len)\n\t\tgoto out;\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(pol, ctx))\n\t\tgoto out;\n\trc = 0;\nout:\n\tif (rc)\n\t\tcontext_destroy(ctx);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "c->str",
            "GFP_KERNEL"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct sidtab sidtab;\nstatic int security_preserve_bools(struct policydb *p);\n\nstatic int convert_context(u32 key,\n\t\t\t   struct context *c,\n\t\t\t   void *p)\n{\n\tstruct convert_context_args *args;\n\tstruct context oldc;\n\tstruct ocontext *oc;\n\tstruct mls_range *range;\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *s;\n\tu32 len;\n\tint rc = 0;\n\n\tif (key <= SECINITSID_NUM)\n\t\tgoto out;\n\n\targs = p;\n\n\tif (c->str) {\n\t\tstruct context ctx;\n\n\t\trc = -ENOMEM;\n\t\ts = kstrdup(c->str, GFP_KERNEL);\n\t\tif (!s)\n\t\t\tgoto out;\n\n\t\trc = string_to_context_struct(args->newp, NULL, s,\n\t\t\t\t\t      c->len, &ctx, SECSID_NULL);\n\t\tkfree(s);\n\t\tif (!rc) {\n\t\t\tprintk(KERN_INFO \"SELinux:  Context %s became valid (mapped).\\n\",\n\t\t\t       c->str);\n\t\t\t/* Replace string with mapped representation. */\n\t\t\tkfree(c->str);\n\t\t\tmemcpy(c, &ctx, sizeof(*c));\n\t\t\tgoto out;\n\t\t} else if (rc == -EINVAL) {\n\t\t\t/* Retain string representation for later mapping. */\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* Other error condition, e.g. ENOMEM. */\n\t\t\tprintk(KERN_ERR \"SELinux:   Unable to map context %s, rc = %d.\\n\",\n\t\t\t       c->str, -rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = context_cpy(&oldc, c);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Convert the user. */\n\trc = -EINVAL;\n\tusrdatum = hashtab_search(args->newp->p_users.table,\n\t\t\t\t  sym_name(args->oldp, SYM_USERS, c->user - 1));\n\tif (!usrdatum)\n\t\tgoto bad;\n\tc->user = usrdatum->value;\n\n\t/* Convert the role. */\n\trc = -EINVAL;\n\trole = hashtab_search(args->newp->p_roles.table,\n\t\t\t      sym_name(args->oldp, SYM_ROLES, c->role - 1));\n\tif (!role)\n\t\tgoto bad;\n\tc->role = role->value;\n\n\t/* Convert the type. */\n\trc = -EINVAL;\n\ttypdatum = hashtab_search(args->newp->p_types.table,\n\t\t\t\t  sym_name(args->oldp, SYM_TYPES, c->type - 1));\n\tif (!typdatum)\n\t\tgoto bad;\n\tc->type = typdatum->value;\n\n\t/* Convert the MLS fields if dealing with MLS policies */\n\tif (args->oldp->mls_enabled && args->newp->mls_enabled) {\n\t\trc = mls_convert_context(args->oldp, args->newp, c);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t} else if (args->oldp->mls_enabled && !args->newp->mls_enabled) {\n\t\t/*\n\t\t * Switching between MLS and non-MLS policy:\n\t\t * free any storage used by the MLS fields in the\n\t\t * context for all existing entries in the sidtab.\n\t\t */\n\t\tmls_context_destroy(c);\n\t} else if (!args->oldp->mls_enabled && args->newp->mls_enabled) {\n\t\t/*\n\t\t * Switching between non-MLS and MLS policy:\n\t\t * ensure that the MLS fields of the context for all\n\t\t * existing entries in the sidtab are filled in with a\n\t\t * suitable default value, likely taken from one of the\n\t\t * initial SIDs.\n\t\t */\n\t\toc = args->newp->ocontexts[OCON_ISID];\n\t\twhile (oc && oc->sid[0] != SECINITSID_UNLABELED)\n\t\t\toc = oc->next;\n\t\trc = -EINVAL;\n\t\tif (!oc) {\n\t\t\tprintk(KERN_ERR \"SELinux:  unable to look up\"\n\t\t\t\t\" the initial SIDs list\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\trange = &oc->context[0].range;\n\t\trc = mls_range_set(c, range);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(args->newp, c)) {\n\t\trc = convert_context_handle_invalid_context(&oldc);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\tcontext_destroy(&oldc);\n\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\t/* Map old representation to string and save it. */\n\trc = context_struct_to_string(&oldc, &s, &len);\n\tif (rc)\n\t\treturn rc;\n\tcontext_destroy(&oldc);\n\tcontext_destroy(c);\n\tc->str = s;\n\tc->len = len;\n\tprintk(KERN_INFO \"SELinux:  Context %s became invalid (unmapped).\\n\",\n\t       c->str);\n\trc = 0;\n\tgoto out;\n}"
  },
  {
    "function_name": "convert_context_handle_invalid_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1831-1844",
    "snippet": "static inline int convert_context_handle_invalid_context(struct context *context)\n{\n\tchar *s;\n\tu32 len;\n\n\tif (selinux_enforcing)\n\t\treturn -EINVAL;\n\n\tif (!context_struct_to_string(context, &s, &len)) {\n\t\tprintk(KERN_WARNING \"SELinux:  Context %s would be invalid if enforcing\\n\", s);\n\t\tkfree(s);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"SELinux:  Context %s would be invalid if enforcing\\n\"",
            "s"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_struct_to_string",
          "args": [
            "context",
            "&s",
            "&len"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "context_struct_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1192-1238",
          "snippet": "static int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int convert_context_handle_invalid_context(struct context *context)\n{\n\tchar *s;\n\tu32 len;\n\n\tif (selinux_enforcing)\n\t\treturn -EINVAL;\n\n\tif (!context_struct_to_string(context, &s, &len)) {\n\t\tprintk(KERN_WARNING \"SELinux:  Context %s would be invalid if enforcing\\n\", s);\n\t\tkfree(s);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "clone_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1819-1829",
    "snippet": "static int clone_sid(u32 sid,\n\t\t     struct context *context,\n\t\t     void *arg)\n{\n\tstruct sidtab *s = arg;\n\n\tif (sid > SECINITSID_NUM)\n\t\treturn sidtab_insert(s, sid, context);\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sidtab sidtab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sidtab_insert",
          "args": [
            "s",
            "sid",
            "context"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "34-77",
          "snippet": "int sidtab_insert(struct sidtab *s, u32 sid, struct context *context)\n{\n\tint hvalue;\n\tstruct sidtab_node *prev, *cur, *newnode;\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\thvalue = SIDTAB_HASH(sid);\n\tprev = NULL;\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && sid == cur->sid)\n\t\treturn -EEXIST;\n\n\tnewnode = kmalloc(sizeof(*newnode), GFP_ATOMIC);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\n\tnewnode->sid = sid;\n\tif (context_cpy(&newnode->context, context)) {\n\t\tkfree(newnode);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\twmb();\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = s->htable[hvalue];\n\t\twmb();\n\t\ts->htable[hvalue] = newnode;\n\t}\n\n\ts->nel++;\n\tif (sid >= s->next_sid)\n\t\ts->next_sid = sid + 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_insert(struct sidtab *s, u32 sid, struct context *context)\n{\n\tint hvalue;\n\tstruct sidtab_node *prev, *cur, *newnode;\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\thvalue = SIDTAB_HASH(sid);\n\tprev = NULL;\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && sid == cur->sid)\n\t\treturn -EEXIST;\n\n\tnewnode = kmalloc(sizeof(*newnode), GFP_ATOMIC);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\n\tnewnode->sid = sid;\n\tif (context_cpy(&newnode->context, context)) {\n\t\tkfree(newnode);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\twmb();\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = s->htable[hvalue];\n\t\twmb();\n\t\ts->htable[hvalue] = newnode;\n\t}\n\n\ts->nel++;\n\tif (sid >= s->next_sid)\n\t\ts->next_sid = sid + 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct sidtab sidtab;\n\nstatic int clone_sid(u32 sid,\n\t\t     struct context *context,\n\t\t     void *arg)\n{\n\tstruct sidtab *s = arg;\n\n\tif (sid > SECINITSID_NUM)\n\t\treturn sidtab_insert(s, sid, context);\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "security_change_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1809-1816",
    "snippet": "int security_change_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_CHANGE, NULL,\n\t\t\t\t    out_sid, false);\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_compute_sid",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "AVTAB_CHANGE",
            "NULL",
            "out_sid",
            "false"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "security_compute_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1575-1745",
          "snippet": "static int security_compute_sid(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu32 specified,\n\t\t\t\tconst char *objname,\n\t\t\t\tu32 *out_sid,\n\t\t\t\tbool kern)\n{\n\tstruct class_datum *cladatum = NULL;\n\tstruct context *scontext = NULL, *tcontext = NULL, newcontext;\n\tstruct role_trans *roletr = NULL;\n\tstruct avtab_key avkey;\n\tstruct avtab_datum *avdatum;\n\tstruct avtab_node *node;\n\tu16 tclass;\n\tint rc = 0;\n\tbool sock;\n\n\tif (!ss_initialized) {\n\t\tswitch (orig_tclass) {\n\t\tcase SECCLASS_PROCESS: /* kernel value */\n\t\t\t*out_sid = ssid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out_sid = tsid;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcontext);\n\n\tread_lock(&policy_rwlock);\n\n\tif (kern) {\n\t\ttclass = unmap_class(orig_tclass);\n\t\tsock = security_is_socket_class(orig_tclass);\n\t} else {\n\t\ttclass = orig_tclass;\n\t\tsock = security_is_socket_class(map_class(tclass));\n\t}\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (tclass && tclass <= policydb.p_classes.nprim)\n\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\n\t/* Set the user identity. */\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\tcase AVTAB_CHANGE:\n\t\tif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\n\t\t\tnewcontext.user = tcontext->user;\n\t\t} else {\n\t\t\t/* notice this gets both DEFAULT_SOURCE and unset */\n\t\t\t/* Use the process user identity. */\n\t\t\tnewcontext.user = scontext->user;\n\t\t}\n\t\tbreak;\n\tcase AVTAB_MEMBER:\n\t\t/* Use the related object owner. */\n\t\tnewcontext.user = tcontext->user;\n\t\tbreak;\n\t}\n\n\t/* Set the role to default values. */\n\tif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\n\t\tnewcontext.role = scontext->role;\n\t} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\n\t\tnewcontext.role = tcontext->role;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\tnewcontext.role = scontext->role;\n\t\telse\n\t\t\tnewcontext.role = OBJECT_R_VAL;\n\t}\n\n\t/* Set the type to default values. */\n\tif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\n\t\tnewcontext.type = scontext->type;\n\t} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\n\t\tnewcontext.type = tcontext->type;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true)) {\n\t\t\t/* Use the type of process. */\n\t\t\tnewcontext.type = scontext->type;\n\t\t} else {\n\t\t\t/* Use the type of the related object. */\n\t\t\tnewcontext.type = tcontext->type;\n\t\t}\n\t}\n\n\t/* Look for a type transition/member/change rule. */\n\tavkey.source_type = scontext->type;\n\tavkey.target_type = tcontext->type;\n\tavkey.target_class = tclass;\n\tavkey.specified = specified;\n\tavdatum = avtab_search(&policydb.te_avtab, &avkey);\n\n\t/* If no permanent rule, also check for enabled conditional rules */\n\tif (!avdatum) {\n\t\tnode = avtab_search_node(&policydb.te_cond_avtab, &avkey);\n\t\tfor (; node; node = avtab_search_node_next(node, specified)) {\n\t\t\tif (node->key.specified & AVTAB_ENABLED) {\n\t\t\t\tavdatum = &node->datum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avdatum) {\n\t\t/* Use the type from the type transition/member/change rule. */\n\t\tnewcontext.type = avdatum->u.data;\n\t}\n\n\t/* if we have a objname this is a file trans check so check those rules */\n\tif (objname)\n\t\tfilename_compute_type(&policydb, &newcontext, scontext->type,\n\t\t\t\t      tcontext->type, tclass, objname);\n\n\t/* Check for class-specific changes. */\n\tif (specified & AVTAB_TRANSITION) {\n\t\t/* Look for a role transition rule. */\n\t\tfor (roletr = policydb.role_tr; roletr; roletr = roletr->next) {\n\t\t\tif ((roletr->role == scontext->role) &&\n\t\t\t    (roletr->type == tcontext->type) &&\n\t\t\t    (roletr->tclass == tclass)) {\n\t\t\t\t/* Use the role transition rule. */\n\t\t\t\tnewcontext.role = roletr->new_role;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the MLS attributes.\n\t   This is done last because it may allocate memory. */\n\trc = mls_compute_sid(scontext, tcontext, tclass, specified,\n\t\t\t     &newcontext, sock);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the context. */\n\tif (!policydb_context_isvalid(&policydb, &newcontext)) {\n\t\trc = compute_sid_handle_invalid_context(scontext,\n\t\t\t\t\t\t\ttcontext,\n\t\t\t\t\t\t\ttclass,\n\t\t\t\t\t\t\t&newcontext);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\t/* Obtain the sid for the context. */\n\trc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcontext);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nstatic int security_compute_sid(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu32 specified,\n\t\t\t\tconst char *objname,\n\t\t\t\tu32 *out_sid,\n\t\t\t\tbool kern)\n{\n\tstruct class_datum *cladatum = NULL;\n\tstruct context *scontext = NULL, *tcontext = NULL, newcontext;\n\tstruct role_trans *roletr = NULL;\n\tstruct avtab_key avkey;\n\tstruct avtab_datum *avdatum;\n\tstruct avtab_node *node;\n\tu16 tclass;\n\tint rc = 0;\n\tbool sock;\n\n\tif (!ss_initialized) {\n\t\tswitch (orig_tclass) {\n\t\tcase SECCLASS_PROCESS: /* kernel value */\n\t\t\t*out_sid = ssid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out_sid = tsid;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcontext);\n\n\tread_lock(&policy_rwlock);\n\n\tif (kern) {\n\t\ttclass = unmap_class(orig_tclass);\n\t\tsock = security_is_socket_class(orig_tclass);\n\t} else {\n\t\ttclass = orig_tclass;\n\t\tsock = security_is_socket_class(map_class(tclass));\n\t}\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (tclass && tclass <= policydb.p_classes.nprim)\n\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\n\t/* Set the user identity. */\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\tcase AVTAB_CHANGE:\n\t\tif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\n\t\t\tnewcontext.user = tcontext->user;\n\t\t} else {\n\t\t\t/* notice this gets both DEFAULT_SOURCE and unset */\n\t\t\t/* Use the process user identity. */\n\t\t\tnewcontext.user = scontext->user;\n\t\t}\n\t\tbreak;\n\tcase AVTAB_MEMBER:\n\t\t/* Use the related object owner. */\n\t\tnewcontext.user = tcontext->user;\n\t\tbreak;\n\t}\n\n\t/* Set the role to default values. */\n\tif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\n\t\tnewcontext.role = scontext->role;\n\t} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\n\t\tnewcontext.role = tcontext->role;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\tnewcontext.role = scontext->role;\n\t\telse\n\t\t\tnewcontext.role = OBJECT_R_VAL;\n\t}\n\n\t/* Set the type to default values. */\n\tif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\n\t\tnewcontext.type = scontext->type;\n\t} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\n\t\tnewcontext.type = tcontext->type;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true)) {\n\t\t\t/* Use the type of process. */\n\t\t\tnewcontext.type = scontext->type;\n\t\t} else {\n\t\t\t/* Use the type of the related object. */\n\t\t\tnewcontext.type = tcontext->type;\n\t\t}\n\t}\n\n\t/* Look for a type transition/member/change rule. */\n\tavkey.source_type = scontext->type;\n\tavkey.target_type = tcontext->type;\n\tavkey.target_class = tclass;\n\tavkey.specified = specified;\n\tavdatum = avtab_search(&policydb.te_avtab, &avkey);\n\n\t/* If no permanent rule, also check for enabled conditional rules */\n\tif (!avdatum) {\n\t\tnode = avtab_search_node(&policydb.te_cond_avtab, &avkey);\n\t\tfor (; node; node = avtab_search_node_next(node, specified)) {\n\t\t\tif (node->key.specified & AVTAB_ENABLED) {\n\t\t\t\tavdatum = &node->datum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avdatum) {\n\t\t/* Use the type from the type transition/member/change rule. */\n\t\tnewcontext.type = avdatum->u.data;\n\t}\n\n\t/* if we have a objname this is a file trans check so check those rules */\n\tif (objname)\n\t\tfilename_compute_type(&policydb, &newcontext, scontext->type,\n\t\t\t\t      tcontext->type, tclass, objname);\n\n\t/* Check for class-specific changes. */\n\tif (specified & AVTAB_TRANSITION) {\n\t\t/* Look for a role transition rule. */\n\t\tfor (roletr = policydb.role_tr; roletr; roletr = roletr->next) {\n\t\t\tif ((roletr->role == scontext->role) &&\n\t\t\t    (roletr->type == tcontext->type) &&\n\t\t\t    (roletr->tclass == tclass)) {\n\t\t\t\t/* Use the role transition rule. */\n\t\t\t\tnewcontext.role = roletr->new_role;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the MLS attributes.\n\t   This is done last because it may allocate memory. */\n\trc = mls_compute_sid(scontext, tcontext, tclass, specified,\n\t\t\t     &newcontext, sock);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the context. */\n\tif (!policydb_context_isvalid(&policydb, &newcontext)) {\n\t\trc = compute_sid_handle_invalid_context(scontext,\n\t\t\t\t\t\t\ttcontext,\n\t\t\t\t\t\t\ttclass,\n\t\t\t\t\t\t\t&newcontext);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\t/* Obtain the sid for the context. */\n\trc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcontext);\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_change_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_CHANGE, NULL,\n\t\t\t\t    out_sid, false);\n}"
  },
  {
    "function_name": "security_member_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1787-1794",
    "snippet": "int security_member_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_MEMBER, NULL,\n\t\t\t\t    out_sid, false);\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_compute_sid",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "AVTAB_MEMBER",
            "NULL",
            "out_sid",
            "false"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "security_compute_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1575-1745",
          "snippet": "static int security_compute_sid(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu32 specified,\n\t\t\t\tconst char *objname,\n\t\t\t\tu32 *out_sid,\n\t\t\t\tbool kern)\n{\n\tstruct class_datum *cladatum = NULL;\n\tstruct context *scontext = NULL, *tcontext = NULL, newcontext;\n\tstruct role_trans *roletr = NULL;\n\tstruct avtab_key avkey;\n\tstruct avtab_datum *avdatum;\n\tstruct avtab_node *node;\n\tu16 tclass;\n\tint rc = 0;\n\tbool sock;\n\n\tif (!ss_initialized) {\n\t\tswitch (orig_tclass) {\n\t\tcase SECCLASS_PROCESS: /* kernel value */\n\t\t\t*out_sid = ssid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out_sid = tsid;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcontext);\n\n\tread_lock(&policy_rwlock);\n\n\tif (kern) {\n\t\ttclass = unmap_class(orig_tclass);\n\t\tsock = security_is_socket_class(orig_tclass);\n\t} else {\n\t\ttclass = orig_tclass;\n\t\tsock = security_is_socket_class(map_class(tclass));\n\t}\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (tclass && tclass <= policydb.p_classes.nprim)\n\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\n\t/* Set the user identity. */\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\tcase AVTAB_CHANGE:\n\t\tif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\n\t\t\tnewcontext.user = tcontext->user;\n\t\t} else {\n\t\t\t/* notice this gets both DEFAULT_SOURCE and unset */\n\t\t\t/* Use the process user identity. */\n\t\t\tnewcontext.user = scontext->user;\n\t\t}\n\t\tbreak;\n\tcase AVTAB_MEMBER:\n\t\t/* Use the related object owner. */\n\t\tnewcontext.user = tcontext->user;\n\t\tbreak;\n\t}\n\n\t/* Set the role to default values. */\n\tif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\n\t\tnewcontext.role = scontext->role;\n\t} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\n\t\tnewcontext.role = tcontext->role;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\tnewcontext.role = scontext->role;\n\t\telse\n\t\t\tnewcontext.role = OBJECT_R_VAL;\n\t}\n\n\t/* Set the type to default values. */\n\tif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\n\t\tnewcontext.type = scontext->type;\n\t} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\n\t\tnewcontext.type = tcontext->type;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true)) {\n\t\t\t/* Use the type of process. */\n\t\t\tnewcontext.type = scontext->type;\n\t\t} else {\n\t\t\t/* Use the type of the related object. */\n\t\t\tnewcontext.type = tcontext->type;\n\t\t}\n\t}\n\n\t/* Look for a type transition/member/change rule. */\n\tavkey.source_type = scontext->type;\n\tavkey.target_type = tcontext->type;\n\tavkey.target_class = tclass;\n\tavkey.specified = specified;\n\tavdatum = avtab_search(&policydb.te_avtab, &avkey);\n\n\t/* If no permanent rule, also check for enabled conditional rules */\n\tif (!avdatum) {\n\t\tnode = avtab_search_node(&policydb.te_cond_avtab, &avkey);\n\t\tfor (; node; node = avtab_search_node_next(node, specified)) {\n\t\t\tif (node->key.specified & AVTAB_ENABLED) {\n\t\t\t\tavdatum = &node->datum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avdatum) {\n\t\t/* Use the type from the type transition/member/change rule. */\n\t\tnewcontext.type = avdatum->u.data;\n\t}\n\n\t/* if we have a objname this is a file trans check so check those rules */\n\tif (objname)\n\t\tfilename_compute_type(&policydb, &newcontext, scontext->type,\n\t\t\t\t      tcontext->type, tclass, objname);\n\n\t/* Check for class-specific changes. */\n\tif (specified & AVTAB_TRANSITION) {\n\t\t/* Look for a role transition rule. */\n\t\tfor (roletr = policydb.role_tr; roletr; roletr = roletr->next) {\n\t\t\tif ((roletr->role == scontext->role) &&\n\t\t\t    (roletr->type == tcontext->type) &&\n\t\t\t    (roletr->tclass == tclass)) {\n\t\t\t\t/* Use the role transition rule. */\n\t\t\t\tnewcontext.role = roletr->new_role;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the MLS attributes.\n\t   This is done last because it may allocate memory. */\n\trc = mls_compute_sid(scontext, tcontext, tclass, specified,\n\t\t\t     &newcontext, sock);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the context. */\n\tif (!policydb_context_isvalid(&policydb, &newcontext)) {\n\t\trc = compute_sid_handle_invalid_context(scontext,\n\t\t\t\t\t\t\ttcontext,\n\t\t\t\t\t\t\ttclass,\n\t\t\t\t\t\t\t&newcontext);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\t/* Obtain the sid for the context. */\n\trc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcontext);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nstatic int security_compute_sid(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu32 specified,\n\t\t\t\tconst char *objname,\n\t\t\t\tu32 *out_sid,\n\t\t\t\tbool kern)\n{\n\tstruct class_datum *cladatum = NULL;\n\tstruct context *scontext = NULL, *tcontext = NULL, newcontext;\n\tstruct role_trans *roletr = NULL;\n\tstruct avtab_key avkey;\n\tstruct avtab_datum *avdatum;\n\tstruct avtab_node *node;\n\tu16 tclass;\n\tint rc = 0;\n\tbool sock;\n\n\tif (!ss_initialized) {\n\t\tswitch (orig_tclass) {\n\t\tcase SECCLASS_PROCESS: /* kernel value */\n\t\t\t*out_sid = ssid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out_sid = tsid;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcontext);\n\n\tread_lock(&policy_rwlock);\n\n\tif (kern) {\n\t\ttclass = unmap_class(orig_tclass);\n\t\tsock = security_is_socket_class(orig_tclass);\n\t} else {\n\t\ttclass = orig_tclass;\n\t\tsock = security_is_socket_class(map_class(tclass));\n\t}\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (tclass && tclass <= policydb.p_classes.nprim)\n\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\n\t/* Set the user identity. */\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\tcase AVTAB_CHANGE:\n\t\tif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\n\t\t\tnewcontext.user = tcontext->user;\n\t\t} else {\n\t\t\t/* notice this gets both DEFAULT_SOURCE and unset */\n\t\t\t/* Use the process user identity. */\n\t\t\tnewcontext.user = scontext->user;\n\t\t}\n\t\tbreak;\n\tcase AVTAB_MEMBER:\n\t\t/* Use the related object owner. */\n\t\tnewcontext.user = tcontext->user;\n\t\tbreak;\n\t}\n\n\t/* Set the role to default values. */\n\tif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\n\t\tnewcontext.role = scontext->role;\n\t} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\n\t\tnewcontext.role = tcontext->role;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\tnewcontext.role = scontext->role;\n\t\telse\n\t\t\tnewcontext.role = OBJECT_R_VAL;\n\t}\n\n\t/* Set the type to default values. */\n\tif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\n\t\tnewcontext.type = scontext->type;\n\t} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\n\t\tnewcontext.type = tcontext->type;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true)) {\n\t\t\t/* Use the type of process. */\n\t\t\tnewcontext.type = scontext->type;\n\t\t} else {\n\t\t\t/* Use the type of the related object. */\n\t\t\tnewcontext.type = tcontext->type;\n\t\t}\n\t}\n\n\t/* Look for a type transition/member/change rule. */\n\tavkey.source_type = scontext->type;\n\tavkey.target_type = tcontext->type;\n\tavkey.target_class = tclass;\n\tavkey.specified = specified;\n\tavdatum = avtab_search(&policydb.te_avtab, &avkey);\n\n\t/* If no permanent rule, also check for enabled conditional rules */\n\tif (!avdatum) {\n\t\tnode = avtab_search_node(&policydb.te_cond_avtab, &avkey);\n\t\tfor (; node; node = avtab_search_node_next(node, specified)) {\n\t\t\tif (node->key.specified & AVTAB_ENABLED) {\n\t\t\t\tavdatum = &node->datum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avdatum) {\n\t\t/* Use the type from the type transition/member/change rule. */\n\t\tnewcontext.type = avdatum->u.data;\n\t}\n\n\t/* if we have a objname this is a file trans check so check those rules */\n\tif (objname)\n\t\tfilename_compute_type(&policydb, &newcontext, scontext->type,\n\t\t\t\t      tcontext->type, tclass, objname);\n\n\t/* Check for class-specific changes. */\n\tif (specified & AVTAB_TRANSITION) {\n\t\t/* Look for a role transition rule. */\n\t\tfor (roletr = policydb.role_tr; roletr; roletr = roletr->next) {\n\t\t\tif ((roletr->role == scontext->role) &&\n\t\t\t    (roletr->type == tcontext->type) &&\n\t\t\t    (roletr->tclass == tclass)) {\n\t\t\t\t/* Use the role transition rule. */\n\t\t\t\tnewcontext.role = roletr->new_role;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the MLS attributes.\n\t   This is done last because it may allocate memory. */\n\trc = mls_compute_sid(scontext, tcontext, tclass, specified,\n\t\t\t     &newcontext, sock);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the context. */\n\tif (!policydb_context_isvalid(&policydb, &newcontext)) {\n\t\trc = compute_sid_handle_invalid_context(scontext,\n\t\t\t\t\t\t\ttcontext,\n\t\t\t\t\t\t\ttclass,\n\t\t\t\t\t\t\t&newcontext);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\t/* Obtain the sid for the context. */\n\trc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcontext);\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_member_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_MEMBER, NULL,\n\t\t\t\t    out_sid, false);\n}"
  },
  {
    "function_name": "security_transition_sid_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1767-1772",
    "snippet": "int security_transition_sid_user(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\t const char *objname, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\n\t\t\t\t    objname, out_sid, false);\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_compute_sid",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "AVTAB_TRANSITION",
            "objname",
            "out_sid",
            "false"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "security_compute_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1575-1745",
          "snippet": "static int security_compute_sid(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu32 specified,\n\t\t\t\tconst char *objname,\n\t\t\t\tu32 *out_sid,\n\t\t\t\tbool kern)\n{\n\tstruct class_datum *cladatum = NULL;\n\tstruct context *scontext = NULL, *tcontext = NULL, newcontext;\n\tstruct role_trans *roletr = NULL;\n\tstruct avtab_key avkey;\n\tstruct avtab_datum *avdatum;\n\tstruct avtab_node *node;\n\tu16 tclass;\n\tint rc = 0;\n\tbool sock;\n\n\tif (!ss_initialized) {\n\t\tswitch (orig_tclass) {\n\t\tcase SECCLASS_PROCESS: /* kernel value */\n\t\t\t*out_sid = ssid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out_sid = tsid;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcontext);\n\n\tread_lock(&policy_rwlock);\n\n\tif (kern) {\n\t\ttclass = unmap_class(orig_tclass);\n\t\tsock = security_is_socket_class(orig_tclass);\n\t} else {\n\t\ttclass = orig_tclass;\n\t\tsock = security_is_socket_class(map_class(tclass));\n\t}\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (tclass && tclass <= policydb.p_classes.nprim)\n\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\n\t/* Set the user identity. */\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\tcase AVTAB_CHANGE:\n\t\tif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\n\t\t\tnewcontext.user = tcontext->user;\n\t\t} else {\n\t\t\t/* notice this gets both DEFAULT_SOURCE and unset */\n\t\t\t/* Use the process user identity. */\n\t\t\tnewcontext.user = scontext->user;\n\t\t}\n\t\tbreak;\n\tcase AVTAB_MEMBER:\n\t\t/* Use the related object owner. */\n\t\tnewcontext.user = tcontext->user;\n\t\tbreak;\n\t}\n\n\t/* Set the role to default values. */\n\tif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\n\t\tnewcontext.role = scontext->role;\n\t} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\n\t\tnewcontext.role = tcontext->role;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\tnewcontext.role = scontext->role;\n\t\telse\n\t\t\tnewcontext.role = OBJECT_R_VAL;\n\t}\n\n\t/* Set the type to default values. */\n\tif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\n\t\tnewcontext.type = scontext->type;\n\t} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\n\t\tnewcontext.type = tcontext->type;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true)) {\n\t\t\t/* Use the type of process. */\n\t\t\tnewcontext.type = scontext->type;\n\t\t} else {\n\t\t\t/* Use the type of the related object. */\n\t\t\tnewcontext.type = tcontext->type;\n\t\t}\n\t}\n\n\t/* Look for a type transition/member/change rule. */\n\tavkey.source_type = scontext->type;\n\tavkey.target_type = tcontext->type;\n\tavkey.target_class = tclass;\n\tavkey.specified = specified;\n\tavdatum = avtab_search(&policydb.te_avtab, &avkey);\n\n\t/* If no permanent rule, also check for enabled conditional rules */\n\tif (!avdatum) {\n\t\tnode = avtab_search_node(&policydb.te_cond_avtab, &avkey);\n\t\tfor (; node; node = avtab_search_node_next(node, specified)) {\n\t\t\tif (node->key.specified & AVTAB_ENABLED) {\n\t\t\t\tavdatum = &node->datum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avdatum) {\n\t\t/* Use the type from the type transition/member/change rule. */\n\t\tnewcontext.type = avdatum->u.data;\n\t}\n\n\t/* if we have a objname this is a file trans check so check those rules */\n\tif (objname)\n\t\tfilename_compute_type(&policydb, &newcontext, scontext->type,\n\t\t\t\t      tcontext->type, tclass, objname);\n\n\t/* Check for class-specific changes. */\n\tif (specified & AVTAB_TRANSITION) {\n\t\t/* Look for a role transition rule. */\n\t\tfor (roletr = policydb.role_tr; roletr; roletr = roletr->next) {\n\t\t\tif ((roletr->role == scontext->role) &&\n\t\t\t    (roletr->type == tcontext->type) &&\n\t\t\t    (roletr->tclass == tclass)) {\n\t\t\t\t/* Use the role transition rule. */\n\t\t\t\tnewcontext.role = roletr->new_role;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the MLS attributes.\n\t   This is done last because it may allocate memory. */\n\trc = mls_compute_sid(scontext, tcontext, tclass, specified,\n\t\t\t     &newcontext, sock);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the context. */\n\tif (!policydb_context_isvalid(&policydb, &newcontext)) {\n\t\trc = compute_sid_handle_invalid_context(scontext,\n\t\t\t\t\t\t\ttcontext,\n\t\t\t\t\t\t\ttclass,\n\t\t\t\t\t\t\t&newcontext);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\t/* Obtain the sid for the context. */\n\trc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcontext);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nstatic int security_compute_sid(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu32 specified,\n\t\t\t\tconst char *objname,\n\t\t\t\tu32 *out_sid,\n\t\t\t\tbool kern)\n{\n\tstruct class_datum *cladatum = NULL;\n\tstruct context *scontext = NULL, *tcontext = NULL, newcontext;\n\tstruct role_trans *roletr = NULL;\n\tstruct avtab_key avkey;\n\tstruct avtab_datum *avdatum;\n\tstruct avtab_node *node;\n\tu16 tclass;\n\tint rc = 0;\n\tbool sock;\n\n\tif (!ss_initialized) {\n\t\tswitch (orig_tclass) {\n\t\tcase SECCLASS_PROCESS: /* kernel value */\n\t\t\t*out_sid = ssid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out_sid = tsid;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcontext);\n\n\tread_lock(&policy_rwlock);\n\n\tif (kern) {\n\t\ttclass = unmap_class(orig_tclass);\n\t\tsock = security_is_socket_class(orig_tclass);\n\t} else {\n\t\ttclass = orig_tclass;\n\t\tsock = security_is_socket_class(map_class(tclass));\n\t}\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (tclass && tclass <= policydb.p_classes.nprim)\n\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\n\t/* Set the user identity. */\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\tcase AVTAB_CHANGE:\n\t\tif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\n\t\t\tnewcontext.user = tcontext->user;\n\t\t} else {\n\t\t\t/* notice this gets both DEFAULT_SOURCE and unset */\n\t\t\t/* Use the process user identity. */\n\t\t\tnewcontext.user = scontext->user;\n\t\t}\n\t\tbreak;\n\tcase AVTAB_MEMBER:\n\t\t/* Use the related object owner. */\n\t\tnewcontext.user = tcontext->user;\n\t\tbreak;\n\t}\n\n\t/* Set the role to default values. */\n\tif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\n\t\tnewcontext.role = scontext->role;\n\t} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\n\t\tnewcontext.role = tcontext->role;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\tnewcontext.role = scontext->role;\n\t\telse\n\t\t\tnewcontext.role = OBJECT_R_VAL;\n\t}\n\n\t/* Set the type to default values. */\n\tif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\n\t\tnewcontext.type = scontext->type;\n\t} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\n\t\tnewcontext.type = tcontext->type;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true)) {\n\t\t\t/* Use the type of process. */\n\t\t\tnewcontext.type = scontext->type;\n\t\t} else {\n\t\t\t/* Use the type of the related object. */\n\t\t\tnewcontext.type = tcontext->type;\n\t\t}\n\t}\n\n\t/* Look for a type transition/member/change rule. */\n\tavkey.source_type = scontext->type;\n\tavkey.target_type = tcontext->type;\n\tavkey.target_class = tclass;\n\tavkey.specified = specified;\n\tavdatum = avtab_search(&policydb.te_avtab, &avkey);\n\n\t/* If no permanent rule, also check for enabled conditional rules */\n\tif (!avdatum) {\n\t\tnode = avtab_search_node(&policydb.te_cond_avtab, &avkey);\n\t\tfor (; node; node = avtab_search_node_next(node, specified)) {\n\t\t\tif (node->key.specified & AVTAB_ENABLED) {\n\t\t\t\tavdatum = &node->datum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avdatum) {\n\t\t/* Use the type from the type transition/member/change rule. */\n\t\tnewcontext.type = avdatum->u.data;\n\t}\n\n\t/* if we have a objname this is a file trans check so check those rules */\n\tif (objname)\n\t\tfilename_compute_type(&policydb, &newcontext, scontext->type,\n\t\t\t\t      tcontext->type, tclass, objname);\n\n\t/* Check for class-specific changes. */\n\tif (specified & AVTAB_TRANSITION) {\n\t\t/* Look for a role transition rule. */\n\t\tfor (roletr = policydb.role_tr; roletr; roletr = roletr->next) {\n\t\t\tif ((roletr->role == scontext->role) &&\n\t\t\t    (roletr->type == tcontext->type) &&\n\t\t\t    (roletr->tclass == tclass)) {\n\t\t\t\t/* Use the role transition rule. */\n\t\t\t\tnewcontext.role = roletr->new_role;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the MLS attributes.\n\t   This is done last because it may allocate memory. */\n\trc = mls_compute_sid(scontext, tcontext, tclass, specified,\n\t\t\t     &newcontext, sock);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the context. */\n\tif (!policydb_context_isvalid(&policydb, &newcontext)) {\n\t\trc = compute_sid_handle_invalid_context(scontext,\n\t\t\t\t\t\t\ttcontext,\n\t\t\t\t\t\t\ttclass,\n\t\t\t\t\t\t\t&newcontext);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\t/* Obtain the sid for the context. */\n\trc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcontext);\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_transition_sid_user(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\t const char *objname, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\n\t\t\t\t    objname, out_sid, false);\n}"
  },
  {
    "function_name": "security_transition_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1760-1765",
    "snippet": "int security_transition_sid(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t    const struct qstr *qstr, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\n\t\t\t\t    qstr ? qstr->name : NULL, out_sid, true);\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_compute_sid",
          "args": [
            "ssid",
            "tsid",
            "tclass",
            "AVTAB_TRANSITION",
            "qstr ? qstr->name : NULL",
            "out_sid",
            "true"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "security_compute_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1575-1745",
          "snippet": "static int security_compute_sid(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu32 specified,\n\t\t\t\tconst char *objname,\n\t\t\t\tu32 *out_sid,\n\t\t\t\tbool kern)\n{\n\tstruct class_datum *cladatum = NULL;\n\tstruct context *scontext = NULL, *tcontext = NULL, newcontext;\n\tstruct role_trans *roletr = NULL;\n\tstruct avtab_key avkey;\n\tstruct avtab_datum *avdatum;\n\tstruct avtab_node *node;\n\tu16 tclass;\n\tint rc = 0;\n\tbool sock;\n\n\tif (!ss_initialized) {\n\t\tswitch (orig_tclass) {\n\t\tcase SECCLASS_PROCESS: /* kernel value */\n\t\t\t*out_sid = ssid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out_sid = tsid;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcontext);\n\n\tread_lock(&policy_rwlock);\n\n\tif (kern) {\n\t\ttclass = unmap_class(orig_tclass);\n\t\tsock = security_is_socket_class(orig_tclass);\n\t} else {\n\t\ttclass = orig_tclass;\n\t\tsock = security_is_socket_class(map_class(tclass));\n\t}\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (tclass && tclass <= policydb.p_classes.nprim)\n\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\n\t/* Set the user identity. */\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\tcase AVTAB_CHANGE:\n\t\tif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\n\t\t\tnewcontext.user = tcontext->user;\n\t\t} else {\n\t\t\t/* notice this gets both DEFAULT_SOURCE and unset */\n\t\t\t/* Use the process user identity. */\n\t\t\tnewcontext.user = scontext->user;\n\t\t}\n\t\tbreak;\n\tcase AVTAB_MEMBER:\n\t\t/* Use the related object owner. */\n\t\tnewcontext.user = tcontext->user;\n\t\tbreak;\n\t}\n\n\t/* Set the role to default values. */\n\tif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\n\t\tnewcontext.role = scontext->role;\n\t} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\n\t\tnewcontext.role = tcontext->role;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\tnewcontext.role = scontext->role;\n\t\telse\n\t\t\tnewcontext.role = OBJECT_R_VAL;\n\t}\n\n\t/* Set the type to default values. */\n\tif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\n\t\tnewcontext.type = scontext->type;\n\t} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\n\t\tnewcontext.type = tcontext->type;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true)) {\n\t\t\t/* Use the type of process. */\n\t\t\tnewcontext.type = scontext->type;\n\t\t} else {\n\t\t\t/* Use the type of the related object. */\n\t\t\tnewcontext.type = tcontext->type;\n\t\t}\n\t}\n\n\t/* Look for a type transition/member/change rule. */\n\tavkey.source_type = scontext->type;\n\tavkey.target_type = tcontext->type;\n\tavkey.target_class = tclass;\n\tavkey.specified = specified;\n\tavdatum = avtab_search(&policydb.te_avtab, &avkey);\n\n\t/* If no permanent rule, also check for enabled conditional rules */\n\tif (!avdatum) {\n\t\tnode = avtab_search_node(&policydb.te_cond_avtab, &avkey);\n\t\tfor (; node; node = avtab_search_node_next(node, specified)) {\n\t\t\tif (node->key.specified & AVTAB_ENABLED) {\n\t\t\t\tavdatum = &node->datum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avdatum) {\n\t\t/* Use the type from the type transition/member/change rule. */\n\t\tnewcontext.type = avdatum->u.data;\n\t}\n\n\t/* if we have a objname this is a file trans check so check those rules */\n\tif (objname)\n\t\tfilename_compute_type(&policydb, &newcontext, scontext->type,\n\t\t\t\t      tcontext->type, tclass, objname);\n\n\t/* Check for class-specific changes. */\n\tif (specified & AVTAB_TRANSITION) {\n\t\t/* Look for a role transition rule. */\n\t\tfor (roletr = policydb.role_tr; roletr; roletr = roletr->next) {\n\t\t\tif ((roletr->role == scontext->role) &&\n\t\t\t    (roletr->type == tcontext->type) &&\n\t\t\t    (roletr->tclass == tclass)) {\n\t\t\t\t/* Use the role transition rule. */\n\t\t\t\tnewcontext.role = roletr->new_role;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the MLS attributes.\n\t   This is done last because it may allocate memory. */\n\trc = mls_compute_sid(scontext, tcontext, tclass, specified,\n\t\t\t     &newcontext, sock);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the context. */\n\tif (!policydb_context_isvalid(&policydb, &newcontext)) {\n\t\trc = compute_sid_handle_invalid_context(scontext,\n\t\t\t\t\t\t\ttcontext,\n\t\t\t\t\t\t\ttclass,\n\t\t\t\t\t\t\t&newcontext);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\t/* Obtain the sid for the context. */\n\trc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcontext);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nstatic int security_compute_sid(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu32 specified,\n\t\t\t\tconst char *objname,\n\t\t\t\tu32 *out_sid,\n\t\t\t\tbool kern)\n{\n\tstruct class_datum *cladatum = NULL;\n\tstruct context *scontext = NULL, *tcontext = NULL, newcontext;\n\tstruct role_trans *roletr = NULL;\n\tstruct avtab_key avkey;\n\tstruct avtab_datum *avdatum;\n\tstruct avtab_node *node;\n\tu16 tclass;\n\tint rc = 0;\n\tbool sock;\n\n\tif (!ss_initialized) {\n\t\tswitch (orig_tclass) {\n\t\tcase SECCLASS_PROCESS: /* kernel value */\n\t\t\t*out_sid = ssid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out_sid = tsid;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcontext);\n\n\tread_lock(&policy_rwlock);\n\n\tif (kern) {\n\t\ttclass = unmap_class(orig_tclass);\n\t\tsock = security_is_socket_class(orig_tclass);\n\t} else {\n\t\ttclass = orig_tclass;\n\t\tsock = security_is_socket_class(map_class(tclass));\n\t}\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (tclass && tclass <= policydb.p_classes.nprim)\n\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\n\t/* Set the user identity. */\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\tcase AVTAB_CHANGE:\n\t\tif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\n\t\t\tnewcontext.user = tcontext->user;\n\t\t} else {\n\t\t\t/* notice this gets both DEFAULT_SOURCE and unset */\n\t\t\t/* Use the process user identity. */\n\t\t\tnewcontext.user = scontext->user;\n\t\t}\n\t\tbreak;\n\tcase AVTAB_MEMBER:\n\t\t/* Use the related object owner. */\n\t\tnewcontext.user = tcontext->user;\n\t\tbreak;\n\t}\n\n\t/* Set the role to default values. */\n\tif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\n\t\tnewcontext.role = scontext->role;\n\t} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\n\t\tnewcontext.role = tcontext->role;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\tnewcontext.role = scontext->role;\n\t\telse\n\t\t\tnewcontext.role = OBJECT_R_VAL;\n\t}\n\n\t/* Set the type to default values. */\n\tif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\n\t\tnewcontext.type = scontext->type;\n\t} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\n\t\tnewcontext.type = tcontext->type;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true)) {\n\t\t\t/* Use the type of process. */\n\t\t\tnewcontext.type = scontext->type;\n\t\t} else {\n\t\t\t/* Use the type of the related object. */\n\t\t\tnewcontext.type = tcontext->type;\n\t\t}\n\t}\n\n\t/* Look for a type transition/member/change rule. */\n\tavkey.source_type = scontext->type;\n\tavkey.target_type = tcontext->type;\n\tavkey.target_class = tclass;\n\tavkey.specified = specified;\n\tavdatum = avtab_search(&policydb.te_avtab, &avkey);\n\n\t/* If no permanent rule, also check for enabled conditional rules */\n\tif (!avdatum) {\n\t\tnode = avtab_search_node(&policydb.te_cond_avtab, &avkey);\n\t\tfor (; node; node = avtab_search_node_next(node, specified)) {\n\t\t\tif (node->key.specified & AVTAB_ENABLED) {\n\t\t\t\tavdatum = &node->datum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avdatum) {\n\t\t/* Use the type from the type transition/member/change rule. */\n\t\tnewcontext.type = avdatum->u.data;\n\t}\n\n\t/* if we have a objname this is a file trans check so check those rules */\n\tif (objname)\n\t\tfilename_compute_type(&policydb, &newcontext, scontext->type,\n\t\t\t\t      tcontext->type, tclass, objname);\n\n\t/* Check for class-specific changes. */\n\tif (specified & AVTAB_TRANSITION) {\n\t\t/* Look for a role transition rule. */\n\t\tfor (roletr = policydb.role_tr; roletr; roletr = roletr->next) {\n\t\t\tif ((roletr->role == scontext->role) &&\n\t\t\t    (roletr->type == tcontext->type) &&\n\t\t\t    (roletr->tclass == tclass)) {\n\t\t\t\t/* Use the role transition rule. */\n\t\t\t\tnewcontext.role = roletr->new_role;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the MLS attributes.\n\t   This is done last because it may allocate memory. */\n\trc = mls_compute_sid(scontext, tcontext, tclass, specified,\n\t\t\t     &newcontext, sock);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the context. */\n\tif (!policydb_context_isvalid(&policydb, &newcontext)) {\n\t\trc = compute_sid_handle_invalid_context(scontext,\n\t\t\t\t\t\t\ttcontext,\n\t\t\t\t\t\t\ttclass,\n\t\t\t\t\t\t\t&newcontext);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\t/* Obtain the sid for the context. */\n\trc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcontext);\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_transition_sid(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t    const struct qstr *qstr, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\n\t\t\t\t    qstr ? qstr->name : NULL, out_sid, true);\n}"
  },
  {
    "function_name": "security_compute_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1575-1745",
    "snippet": "static int security_compute_sid(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu32 specified,\n\t\t\t\tconst char *objname,\n\t\t\t\tu32 *out_sid,\n\t\t\t\tbool kern)\n{\n\tstruct class_datum *cladatum = NULL;\n\tstruct context *scontext = NULL, *tcontext = NULL, newcontext;\n\tstruct role_trans *roletr = NULL;\n\tstruct avtab_key avkey;\n\tstruct avtab_datum *avdatum;\n\tstruct avtab_node *node;\n\tu16 tclass;\n\tint rc = 0;\n\tbool sock;\n\n\tif (!ss_initialized) {\n\t\tswitch (orig_tclass) {\n\t\tcase SECCLASS_PROCESS: /* kernel value */\n\t\t\t*out_sid = ssid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out_sid = tsid;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcontext);\n\n\tread_lock(&policy_rwlock);\n\n\tif (kern) {\n\t\ttclass = unmap_class(orig_tclass);\n\t\tsock = security_is_socket_class(orig_tclass);\n\t} else {\n\t\ttclass = orig_tclass;\n\t\tsock = security_is_socket_class(map_class(tclass));\n\t}\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (tclass && tclass <= policydb.p_classes.nprim)\n\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\n\t/* Set the user identity. */\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\tcase AVTAB_CHANGE:\n\t\tif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\n\t\t\tnewcontext.user = tcontext->user;\n\t\t} else {\n\t\t\t/* notice this gets both DEFAULT_SOURCE and unset */\n\t\t\t/* Use the process user identity. */\n\t\t\tnewcontext.user = scontext->user;\n\t\t}\n\t\tbreak;\n\tcase AVTAB_MEMBER:\n\t\t/* Use the related object owner. */\n\t\tnewcontext.user = tcontext->user;\n\t\tbreak;\n\t}\n\n\t/* Set the role to default values. */\n\tif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\n\t\tnewcontext.role = scontext->role;\n\t} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\n\t\tnewcontext.role = tcontext->role;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\tnewcontext.role = scontext->role;\n\t\telse\n\t\t\tnewcontext.role = OBJECT_R_VAL;\n\t}\n\n\t/* Set the type to default values. */\n\tif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\n\t\tnewcontext.type = scontext->type;\n\t} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\n\t\tnewcontext.type = tcontext->type;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true)) {\n\t\t\t/* Use the type of process. */\n\t\t\tnewcontext.type = scontext->type;\n\t\t} else {\n\t\t\t/* Use the type of the related object. */\n\t\t\tnewcontext.type = tcontext->type;\n\t\t}\n\t}\n\n\t/* Look for a type transition/member/change rule. */\n\tavkey.source_type = scontext->type;\n\tavkey.target_type = tcontext->type;\n\tavkey.target_class = tclass;\n\tavkey.specified = specified;\n\tavdatum = avtab_search(&policydb.te_avtab, &avkey);\n\n\t/* If no permanent rule, also check for enabled conditional rules */\n\tif (!avdatum) {\n\t\tnode = avtab_search_node(&policydb.te_cond_avtab, &avkey);\n\t\tfor (; node; node = avtab_search_node_next(node, specified)) {\n\t\t\tif (node->key.specified & AVTAB_ENABLED) {\n\t\t\t\tavdatum = &node->datum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avdatum) {\n\t\t/* Use the type from the type transition/member/change rule. */\n\t\tnewcontext.type = avdatum->u.data;\n\t}\n\n\t/* if we have a objname this is a file trans check so check those rules */\n\tif (objname)\n\t\tfilename_compute_type(&policydb, &newcontext, scontext->type,\n\t\t\t\t      tcontext->type, tclass, objname);\n\n\t/* Check for class-specific changes. */\n\tif (specified & AVTAB_TRANSITION) {\n\t\t/* Look for a role transition rule. */\n\t\tfor (roletr = policydb.role_tr; roletr; roletr = roletr->next) {\n\t\t\tif ((roletr->role == scontext->role) &&\n\t\t\t    (roletr->type == tcontext->type) &&\n\t\t\t    (roletr->tclass == tclass)) {\n\t\t\t\t/* Use the role transition rule. */\n\t\t\t\tnewcontext.role = roletr->new_role;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the MLS attributes.\n\t   This is done last because it may allocate memory. */\n\trc = mls_compute_sid(scontext, tcontext, tclass, specified,\n\t\t\t     &newcontext, sock);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the context. */\n\tif (!policydb_context_isvalid(&policydb, &newcontext)) {\n\t\trc = compute_sid_handle_invalid_context(scontext,\n\t\t\t\t\t\t\ttcontext,\n\t\t\t\t\t\t\ttclass,\n\t\t\t\t\t\t\t&newcontext);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\t/* Obtain the sid for the context. */\n\trc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcontext);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;",
      "int ss_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_destroy",
          "args": [
            "&newcontext"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "context_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "142-149",
          "snippet": "static inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_context_to_sid",
          "args": [
            "&sidtab",
            "&newcontext",
            "out_sid"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "191-232",
          "snippet": "int sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compute_sid_handle_invalid_context",
          "args": [
            "scontext",
            "tcontext",
            "tclass",
            "&newcontext"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "compute_sid_handle_invalid_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1520-1548",
          "snippet": "static int compute_sid_handle_invalid_context(\n\tstruct context *scontext,\n\tstruct context *tcontext,\n\tu16 tclass,\n\tstruct context *newcontext)\n{\n\tchar *s = NULL, *t = NULL, *n = NULL;\n\tu32 slen, tlen, nlen;\n\n\tif (context_struct_to_string(scontext, &s, &slen))\n\t\tgoto out;\n\tif (context_struct_to_string(tcontext, &t, &tlen))\n\t\tgoto out;\n\tif (context_struct_to_string(newcontext, &n, &nlen))\n\t\tgoto out;\n\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t  \"op=security_compute_sid invalid_context=%s\"\n\t\t  \" scontext=%s\"\n\t\t  \" tcontext=%s\"\n\t\t  \" tclass=%s\",\n\t\t  n, s, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\nout:\n\tkfree(s);\n\tkfree(t);\n\tkfree(n);\n\tif (!selinux_enforcing)\n\t\treturn 0;\n\treturn -EACCES;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nstatic int compute_sid_handle_invalid_context(\n\tstruct context *scontext,\n\tstruct context *tcontext,\n\tu16 tclass,\n\tstruct context *newcontext)\n{\n\tchar *s = NULL, *t = NULL, *n = NULL;\n\tu32 slen, tlen, nlen;\n\n\tif (context_struct_to_string(scontext, &s, &slen))\n\t\tgoto out;\n\tif (context_struct_to_string(tcontext, &t, &tlen))\n\t\tgoto out;\n\tif (context_struct_to_string(newcontext, &n, &nlen))\n\t\tgoto out;\n\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t  \"op=security_compute_sid invalid_context=%s\"\n\t\t  \" scontext=%s\"\n\t\t  \" tcontext=%s\"\n\t\t  \" tclass=%s\",\n\t\t  n, s, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\nout:\n\tkfree(s);\n\tkfree(t);\n\tkfree(n);\n\tif (!selinux_enforcing)\n\t\treturn 0;\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "policydb_context_isvalid",
          "args": [
            "&policydb",
            "&newcontext"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_context_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "950-989",
          "snippet": "int policydb_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct role_datum *role;\n\tstruct user_datum *usrdatum;\n\n\tif (!c->role || c->role > p->p_roles.nprim)\n\t\treturn 0;\n\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\n\tif (!c->type || c->type > p->p_types.nprim)\n\t\treturn 0;\n\n\tif (c->role != OBJECT_R_VAL) {\n\t\t/*\n\t\t * Role must be authorized for the type.\n\t\t */\n\t\trole = p->role_val_to_struct[c->role - 1];\n\t\tif (!role || !ebitmap_get_bit(&role->types, c->type - 1))\n\t\t\t/* role may not be associated with type */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * User must be authorized for the role.\n\t\t */\n\t\tusrdatum = p->user_val_to_struct[c->user - 1];\n\t\tif (!usrdatum)\n\t\t\treturn 0;\n\n\t\tif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\n\t\t\t/* user may not be associated with role */\n\t\t\treturn 0;\n\t}\n\n\tif (!mls_context_isvalid(p, c))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct role_datum *role;\n\tstruct user_datum *usrdatum;\n\n\tif (!c->role || c->role > p->p_roles.nprim)\n\t\treturn 0;\n\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\n\tif (!c->type || c->type > p->p_types.nprim)\n\t\treturn 0;\n\n\tif (c->role != OBJECT_R_VAL) {\n\t\t/*\n\t\t * Role must be authorized for the type.\n\t\t */\n\t\trole = p->role_val_to_struct[c->role - 1];\n\t\tif (!role || !ebitmap_get_bit(&role->types, c->type - 1))\n\t\t\t/* role may not be associated with type */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * User must be authorized for the role.\n\t\t */\n\t\tusrdatum = p->user_val_to_struct[c->user - 1];\n\t\tif (!usrdatum)\n\t\t\treturn 0;\n\n\t\tif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\n\t\t\t/* user may not be associated with role */\n\t\t\treturn 0;\n\t}\n\n\tif (!mls_context_isvalid(p, c))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_compute_sid",
          "args": [
            "scontext",
            "tcontext",
            "tclass",
            "specified",
            "&newcontext",
            "sock"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "mls_compute_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "506-567",
          "snippet": "int mls_compute_sid(struct context *scontext,\n\t\t    struct context *tcontext,\n\t\t    u16 tclass,\n\t\t    u32 specified,\n\t\t    struct context *newcontext,\n\t\t    bool sock)\n{\n\tstruct range_trans rtr;\n\tstruct mls_range *r;\n\tstruct class_datum *cladatum;\n\tint default_range = 0;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\t\t/* Look for a range transition rule. */\n\t\trtr.source_type = scontext->type;\n\t\trtr.target_type = tcontext->type;\n\t\trtr.target_class = tclass;\n\t\tr = hashtab_search(policydb.range_tr, &rtr);\n\t\tif (r)\n\t\t\treturn mls_range_set(newcontext, r);\n\n\t\tif (tclass && tclass <= policydb.p_classes.nprim) {\n\t\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\t\t\tif (cladatum)\n\t\t\t\tdefault_range = cladatum->default_range;\n\t\t}\n\n\t\tswitch (default_range) {\n\t\tcase DEFAULT_SOURCE_LOW:\n\t\t\treturn mls_context_cpy_low(newcontext, scontext);\n\t\tcase DEFAULT_SOURCE_HIGH:\n\t\t\treturn mls_context_cpy_high(newcontext, scontext);\n\t\tcase DEFAULT_SOURCE_LOW_HIGH:\n\t\t\treturn mls_context_cpy(newcontext, scontext);\n\t\tcase DEFAULT_TARGET_LOW:\n\t\t\treturn mls_context_cpy_low(newcontext, tcontext);\n\t\tcase DEFAULT_TARGET_HIGH:\n\t\t\treturn mls_context_cpy_high(newcontext, tcontext);\n\t\tcase DEFAULT_TARGET_LOW_HIGH:\n\t\t\treturn mls_context_cpy(newcontext, tcontext);\n\t\t}\n\n\t\t/* Fallthrough */\n\tcase AVTAB_CHANGE:\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\t/* Use the process MLS attributes. */\n\t\t\treturn mls_context_cpy(newcontext, scontext);\n\t\telse\n\t\t\t/* Use the process effective MLS attributes. */\n\t\t\treturn mls_context_cpy_low(newcontext, scontext);\n\tcase AVTAB_MEMBER:\n\t\t/* Use the process effective MLS attributes. */\n\t\treturn mls_context_cpy_low(newcontext, scontext);\n\n\t/* fall through */\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_compute_sid(struct context *scontext,\n\t\t    struct context *tcontext,\n\t\t    u16 tclass,\n\t\t    u32 specified,\n\t\t    struct context *newcontext,\n\t\t    bool sock)\n{\n\tstruct range_trans rtr;\n\tstruct mls_range *r;\n\tstruct class_datum *cladatum;\n\tint default_range = 0;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\t\t/* Look for a range transition rule. */\n\t\trtr.source_type = scontext->type;\n\t\trtr.target_type = tcontext->type;\n\t\trtr.target_class = tclass;\n\t\tr = hashtab_search(policydb.range_tr, &rtr);\n\t\tif (r)\n\t\t\treturn mls_range_set(newcontext, r);\n\n\t\tif (tclass && tclass <= policydb.p_classes.nprim) {\n\t\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\t\t\tif (cladatum)\n\t\t\t\tdefault_range = cladatum->default_range;\n\t\t}\n\n\t\tswitch (default_range) {\n\t\tcase DEFAULT_SOURCE_LOW:\n\t\t\treturn mls_context_cpy_low(newcontext, scontext);\n\t\tcase DEFAULT_SOURCE_HIGH:\n\t\t\treturn mls_context_cpy_high(newcontext, scontext);\n\t\tcase DEFAULT_SOURCE_LOW_HIGH:\n\t\t\treturn mls_context_cpy(newcontext, scontext);\n\t\tcase DEFAULT_TARGET_LOW:\n\t\t\treturn mls_context_cpy_low(newcontext, tcontext);\n\t\tcase DEFAULT_TARGET_HIGH:\n\t\t\treturn mls_context_cpy_high(newcontext, tcontext);\n\t\tcase DEFAULT_TARGET_LOW_HIGH:\n\t\t\treturn mls_context_cpy(newcontext, tcontext);\n\t\t}\n\n\t\t/* Fallthrough */\n\tcase AVTAB_CHANGE:\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\t/* Use the process MLS attributes. */\n\t\t\treturn mls_context_cpy(newcontext, scontext);\n\t\telse\n\t\t\t/* Use the process effective MLS attributes. */\n\t\t\treturn mls_context_cpy_low(newcontext, scontext);\n\tcase AVTAB_MEMBER:\n\t\t/* Use the process effective MLS attributes. */\n\t\treturn mls_context_cpy_low(newcontext, scontext);\n\n\t/* fall through */\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filename_compute_type",
          "args": [
            "&policydb",
            "&newcontext",
            "scontext->type",
            "tcontext->type",
            "tclass",
            "objname"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "filename_compute_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1550-1573",
          "snippet": "static void filename_compute_type(struct policydb *p, struct context *newcontext,\n\t\t\t\t  u32 stype, u32 ttype, u16 tclass,\n\t\t\t\t  const char *objname)\n{\n\tstruct filename_trans ft;\n\tstruct filename_trans_datum *otype;\n\n\t/*\n\t * Most filename trans rules are going to live in specific directories\n\t * like /dev or /var/run.  This bitmap will quickly skip rule searches\n\t * if the ttype does not contain any rules.\n\t */\n\tif (!ebitmap_get_bit(&p->filename_trans_ttypes, ttype))\n\t\treturn;\n\n\tft.stype = stype;\n\tft.ttype = ttype;\n\tft.tclass = tclass;\n\tft.name = objname;\n\n\totype = hashtab_search(p->filename_trans, &ft);\n\tif (otype)\n\t\tnewcontext->type = otype->otype;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;",
            "static int security_preserve_bools(struct policydb *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic int security_preserve_bools(struct policydb *p);\n\nstatic void filename_compute_type(struct policydb *p, struct context *newcontext,\n\t\t\t\t  u32 stype, u32 ttype, u16 tclass,\n\t\t\t\t  const char *objname)\n{\n\tstruct filename_trans ft;\n\tstruct filename_trans_datum *otype;\n\n\t/*\n\t * Most filename trans rules are going to live in specific directories\n\t * like /dev or /var/run.  This bitmap will quickly skip rule searches\n\t * if the ttype does not contain any rules.\n\t */\n\tif (!ebitmap_get_bit(&p->filename_trans_ttypes, ttype))\n\t\treturn;\n\n\tft.stype = stype;\n\tft.ttype = ttype;\n\tft.tclass = tclass;\n\tft.name = objname;\n\n\totype = hashtab_search(p->filename_trans, &ft);\n\tif (otype)\n\t\tnewcontext->type = otype->otype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avtab_search_node_next",
          "args": [
            "node",
            "specified"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_search_node_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "250-277",
          "snippet": "struct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "tsid"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "&sidtab",
            "tsid"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "ssid"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_is_socket_class",
          "args": [
            "map_class(tclass)"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_class",
          "args": [
            "tclass"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "map_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "220-230",
          "snippet": "static u16 map_class(u16 pol_value)\n{\n\tu16 i;\n\n\tfor (i = 1; i < current_mapping_size; i++) {\n\t\tif (current_mapping[i].value == pol_value)\n\t\t\treturn i;\n\t}\n\n\treturn SECCLASS_NULL;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct selinux_mapping *current_mapping;",
            "static u16 current_mapping_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nstatic u16 map_class(u16 pol_value)\n{\n\tu16 i;\n\n\tfor (i = 1; i < current_mapping_size; i++) {\n\t\tif (current_mapping[i].value == pol_value)\n\t\t\treturn i;\n\t}\n\n\treturn SECCLASS_NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_is_socket_class",
          "args": [
            "orig_tclass"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_class",
          "args": [
            "orig_tclass"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "209-215",
          "snippet": "static u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct selinux_mapping *current_mapping;",
            "static u16 current_mapping_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nstatic u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_init",
          "args": [
            "&newcontext"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "context_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "113-116",
          "snippet": "static inline void context_init(struct context *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_init(struct context *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nstatic int security_compute_sid(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu32 specified,\n\t\t\t\tconst char *objname,\n\t\t\t\tu32 *out_sid,\n\t\t\t\tbool kern)\n{\n\tstruct class_datum *cladatum = NULL;\n\tstruct context *scontext = NULL, *tcontext = NULL, newcontext;\n\tstruct role_trans *roletr = NULL;\n\tstruct avtab_key avkey;\n\tstruct avtab_datum *avdatum;\n\tstruct avtab_node *node;\n\tu16 tclass;\n\tint rc = 0;\n\tbool sock;\n\n\tif (!ss_initialized) {\n\t\tswitch (orig_tclass) {\n\t\tcase SECCLASS_PROCESS: /* kernel value */\n\t\t\t*out_sid = ssid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out_sid = tsid;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcontext);\n\n\tread_lock(&policy_rwlock);\n\n\tif (kern) {\n\t\ttclass = unmap_class(orig_tclass);\n\t\tsock = security_is_socket_class(orig_tclass);\n\t} else {\n\t\ttclass = orig_tclass;\n\t\tsock = security_is_socket_class(map_class(tclass));\n\t}\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (tclass && tclass <= policydb.p_classes.nprim)\n\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\n\t/* Set the user identity. */\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\tcase AVTAB_CHANGE:\n\t\tif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\n\t\t\tnewcontext.user = tcontext->user;\n\t\t} else {\n\t\t\t/* notice this gets both DEFAULT_SOURCE and unset */\n\t\t\t/* Use the process user identity. */\n\t\t\tnewcontext.user = scontext->user;\n\t\t}\n\t\tbreak;\n\tcase AVTAB_MEMBER:\n\t\t/* Use the related object owner. */\n\t\tnewcontext.user = tcontext->user;\n\t\tbreak;\n\t}\n\n\t/* Set the role to default values. */\n\tif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\n\t\tnewcontext.role = scontext->role;\n\t} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\n\t\tnewcontext.role = tcontext->role;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\tnewcontext.role = scontext->role;\n\t\telse\n\t\t\tnewcontext.role = OBJECT_R_VAL;\n\t}\n\n\t/* Set the type to default values. */\n\tif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\n\t\tnewcontext.type = scontext->type;\n\t} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\n\t\tnewcontext.type = tcontext->type;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true)) {\n\t\t\t/* Use the type of process. */\n\t\t\tnewcontext.type = scontext->type;\n\t\t} else {\n\t\t\t/* Use the type of the related object. */\n\t\t\tnewcontext.type = tcontext->type;\n\t\t}\n\t}\n\n\t/* Look for a type transition/member/change rule. */\n\tavkey.source_type = scontext->type;\n\tavkey.target_type = tcontext->type;\n\tavkey.target_class = tclass;\n\tavkey.specified = specified;\n\tavdatum = avtab_search(&policydb.te_avtab, &avkey);\n\n\t/* If no permanent rule, also check for enabled conditional rules */\n\tif (!avdatum) {\n\t\tnode = avtab_search_node(&policydb.te_cond_avtab, &avkey);\n\t\tfor (; node; node = avtab_search_node_next(node, specified)) {\n\t\t\tif (node->key.specified & AVTAB_ENABLED) {\n\t\t\t\tavdatum = &node->datum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avdatum) {\n\t\t/* Use the type from the type transition/member/change rule. */\n\t\tnewcontext.type = avdatum->u.data;\n\t}\n\n\t/* if we have a objname this is a file trans check so check those rules */\n\tif (objname)\n\t\tfilename_compute_type(&policydb, &newcontext, scontext->type,\n\t\t\t\t      tcontext->type, tclass, objname);\n\n\t/* Check for class-specific changes. */\n\tif (specified & AVTAB_TRANSITION) {\n\t\t/* Look for a role transition rule. */\n\t\tfor (roletr = policydb.role_tr; roletr; roletr = roletr->next) {\n\t\t\tif ((roletr->role == scontext->role) &&\n\t\t\t    (roletr->type == tcontext->type) &&\n\t\t\t    (roletr->tclass == tclass)) {\n\t\t\t\t/* Use the role transition rule. */\n\t\t\t\tnewcontext.role = roletr->new_role;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the MLS attributes.\n\t   This is done last because it may allocate memory. */\n\trc = mls_compute_sid(scontext, tcontext, tclass, specified,\n\t\t\t     &newcontext, sock);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the context. */\n\tif (!policydb_context_isvalid(&policydb, &newcontext)) {\n\t\trc = compute_sid_handle_invalid_context(scontext,\n\t\t\t\t\t\t\ttcontext,\n\t\t\t\t\t\t\ttclass,\n\t\t\t\t\t\t\t&newcontext);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\t/* Obtain the sid for the context. */\n\trc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcontext);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "filename_compute_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1550-1573",
    "snippet": "static void filename_compute_type(struct policydb *p, struct context *newcontext,\n\t\t\t\t  u32 stype, u32 ttype, u16 tclass,\n\t\t\t\t  const char *objname)\n{\n\tstruct filename_trans ft;\n\tstruct filename_trans_datum *otype;\n\n\t/*\n\t * Most filename trans rules are going to live in specific directories\n\t * like /dev or /var/run.  This bitmap will quickly skip rule searches\n\t * if the ttype does not contain any rules.\n\t */\n\tif (!ebitmap_get_bit(&p->filename_trans_ttypes, ttype))\n\t\treturn;\n\n\tft.stype = stype;\n\tft.ttype = ttype;\n\tft.tclass = tclass;\n\tft.name = objname;\n\n\totype = hashtab_search(p->filename_trans, &ft);\n\tif (otype)\n\t\tnewcontext->type = otype->otype;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct policydb policydb;",
      "static int security_preserve_bools(struct policydb *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "p->filename_trans",
            "&ft"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_get_bit",
          "args": [
            "&p->filename_trans_ttypes",
            "ttype"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_get_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "242-257",
          "snippet": "int ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic int security_preserve_bools(struct policydb *p);\n\nstatic void filename_compute_type(struct policydb *p, struct context *newcontext,\n\t\t\t\t  u32 stype, u32 ttype, u16 tclass,\n\t\t\t\t  const char *objname)\n{\n\tstruct filename_trans ft;\n\tstruct filename_trans_datum *otype;\n\n\t/*\n\t * Most filename trans rules are going to live in specific directories\n\t * like /dev or /var/run.  This bitmap will quickly skip rule searches\n\t * if the ttype does not contain any rules.\n\t */\n\tif (!ebitmap_get_bit(&p->filename_trans_ttypes, ttype))\n\t\treturn;\n\n\tft.stype = stype;\n\tft.ttype = ttype;\n\tft.tclass = tclass;\n\tft.name = objname;\n\n\totype = hashtab_search(p->filename_trans, &ft);\n\tif (otype)\n\t\tnewcontext->type = otype->otype;\n}"
  },
  {
    "function_name": "compute_sid_handle_invalid_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1520-1548",
    "snippet": "static int compute_sid_handle_invalid_context(\n\tstruct context *scontext,\n\tstruct context *tcontext,\n\tu16 tclass,\n\tstruct context *newcontext)\n{\n\tchar *s = NULL, *t = NULL, *n = NULL;\n\tu32 slen, tlen, nlen;\n\n\tif (context_struct_to_string(scontext, &s, &slen))\n\t\tgoto out;\n\tif (context_struct_to_string(tcontext, &t, &tlen))\n\t\tgoto out;\n\tif (context_struct_to_string(newcontext, &n, &nlen))\n\t\tgoto out;\n\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t  \"op=security_compute_sid invalid_context=%s\"\n\t\t  \" scontext=%s\"\n\t\t  \" tcontext=%s\"\n\t\t  \" tclass=%s\",\n\t\t  n, s, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\nout:\n\tkfree(s);\n\tkfree(t);\n\tkfree(n);\n\tif (!selinux_enforcing)\n\t\treturn 0;\n\treturn -EACCES;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "n"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "t"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "current->audit_context",
            "GFP_ATOMIC",
            "AUDIT_SELINUX_ERR",
            "\"op=security_compute_sid invalid_context=%s\"\n\t\t  \" scontext=%s\"\n\t\t  \" tcontext=%s\"\n\t\t  \" tclass=%s\"",
            "n",
            "s",
            "t",
            "sym_name(&policydb, SYM_CLASSES, tclass-1)"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "&policydb",
            "SYM_CLASSES",
            "tclass-1"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_struct_to_string",
          "args": [
            "newcontext",
            "&n",
            "&nlen"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "context_struct_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1192-1238",
          "snippet": "static int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nstatic int compute_sid_handle_invalid_context(\n\tstruct context *scontext,\n\tstruct context *tcontext,\n\tu16 tclass,\n\tstruct context *newcontext)\n{\n\tchar *s = NULL, *t = NULL, *n = NULL;\n\tu32 slen, tlen, nlen;\n\n\tif (context_struct_to_string(scontext, &s, &slen))\n\t\tgoto out;\n\tif (context_struct_to_string(tcontext, &t, &tlen))\n\t\tgoto out;\n\tif (context_struct_to_string(newcontext, &n, &nlen))\n\t\tgoto out;\n\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t  \"op=security_compute_sid invalid_context=%s\"\n\t\t  \" scontext=%s\"\n\t\t  \" tcontext=%s\"\n\t\t  \" tclass=%s\",\n\t\t  n, s, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\nout:\n\tkfree(s);\n\tkfree(t);\n\tkfree(n);\n\tif (!selinux_enforcing)\n\t\treturn 0;\n\treturn -EACCES;\n}"
  },
  {
    "function_name": "security_context_to_sid_force",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1513-1518",
    "snippet": "int security_context_to_sid_force(const char *scontext, u32 scontext_len,\n\t\t\t\t  u32 *sid)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, GFP_KERNEL, 1);\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_context_to_sid_core",
          "args": [
            "scontext",
            "scontext_len",
            "sid",
            "SECSID_NULL",
            "GFP_KERNEL",
            "1"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "security_context_to_sid_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1404-1462",
          "snippet": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\n\t/* An empty security context is never valid. */\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\n\tif (!ss_initialized) {\n\t\tint i;\n\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\n\t/* An empty security context is never valid. */\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\n\tif (!ss_initialized) {\n\t\tint i;\n\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_context_to_sid_force(const char *scontext, u32 scontext_len,\n\t\t\t\t  u32 *sid)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, GFP_KERNEL, 1);\n}"
  },
  {
    "function_name": "security_context_to_sid_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1506-1511",
    "snippet": "int security_context_to_sid_default(const char *scontext, u32 scontext_len,\n\t\t\t\t    u32 *sid, u32 def_sid, gfp_t gfp_flags)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, def_sid, gfp_flags, 1);\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_context_to_sid_core",
          "args": [
            "scontext",
            "scontext_len",
            "sid",
            "def_sid",
            "gfp_flags",
            "1"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "security_context_to_sid_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1404-1462",
          "snippet": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\n\t/* An empty security context is never valid. */\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\n\tif (!ss_initialized) {\n\t\tint i;\n\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\n\t/* An empty security context is never valid. */\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\n\tif (!ss_initialized) {\n\t\tint i;\n\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_context_to_sid_default(const char *scontext, u32 scontext_len,\n\t\t\t\t    u32 *sid, u32 def_sid, gfp_t gfp_flags)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, def_sid, gfp_flags, 1);\n}"
  },
  {
    "function_name": "security_context_str_to_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1483-1486",
    "snippet": "int security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_context_to_sid",
          "args": [
            "scontext",
            "strlen(scontext)",
            "sid",
            "gfp"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "security_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1476-1481",
          "snippet": "int security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid,\n\t\t\t    gfp_t gfp)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, gfp, 0);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid,\n\t\t\t    gfp_t gfp)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, gfp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "scontext"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_context_str_to_sid(const char *scontext, u32 *sid, gfp_t gfp)\n{\n\treturn security_context_to_sid(scontext, strlen(scontext), sid, gfp);\n}"
  },
  {
    "function_name": "security_context_to_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1476-1481",
    "snippet": "int security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid,\n\t\t\t    gfp_t gfp)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, gfp, 0);\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_context_to_sid_core",
          "args": [
            "scontext",
            "scontext_len",
            "sid",
            "SECSID_NULL",
            "gfp",
            "0"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "security_context_to_sid_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1404-1462",
          "snippet": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\n\t/* An empty security context is never valid. */\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\n\tif (!ss_initialized) {\n\t\tint i;\n\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\n\t/* An empty security context is never valid. */\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\n\tif (!ss_initialized) {\n\t\tint i;\n\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid,\n\t\t\t    gfp_t gfp)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, gfp, 0);\n}"
  },
  {
    "function_name": "security_context_to_sid_core",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1404-1462",
    "snippet": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\n\t/* An empty security context is never valid. */\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\n\tif (!ss_initialized) {\n\t\tint i;\n\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;",
      "int ss_initialized;",
      "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "str"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "scontext2"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_destroy",
          "args": [
            "&context"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "context_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "142-149",
          "snippet": "static inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_context_to_sid",
          "args": [
            "&sidtab",
            "&context",
            "sid"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "191-232",
          "snippet": "int sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_context_to_sid(struct sidtab *s,\n\t\t\t  struct context *context,\n\t\t\t  u32 *out_sid)\n{\n\tu32 sid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\t*out_sid = SECSID_NULL;\n\n\tsid  = sidtab_search_cache(s, context);\n\tif (!sid)\n\t\tsid = sidtab_search_context(s, context);\n\tif (!sid) {\n\t\tspin_lock_irqsave(&s->lock, flags);\n\t\t/* Rescan now that we hold the lock. */\n\t\tsid = sidtab_search_context(s, context);\n\t\tif (sid)\n\t\t\tgoto unlock_out;\n\t\t/* No SID exists for the context.  Allocate a new one. */\n\t\tif (s->next_sid == UINT_MAX || s->shutdown) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tsid = s->next_sid++;\n\t\tif (context->len)\n\t\t\tprintk(KERN_INFO\n\t\t       \"SELinux:  Context %s is not valid (left unmapped).\\n\",\n\t\t\t       context->str);\n\t\tret = sidtab_insert(s, sid, context);\n\t\tif (ret)\n\t\t\ts->next_sid--;\nunlock_out:\n\t\tspin_unlock_irqrestore(&s->lock, flags);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t*out_sid = sid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_to_context_struct",
          "args": [
            "&policydb",
            "&sidtab",
            "scontext2",
            "scontext_len",
            "&context",
            "def_sid"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "string_to_context_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1322-1402",
          "snippet": "static int string_to_context_struct(struct policydb *pol,\n\t\t\t\t    struct sidtab *sidtabp,\n\t\t\t\t    char *scontext,\n\t\t\t\t    u32 scontext_len,\n\t\t\t\t    struct context *ctx,\n\t\t\t\t    u32 def_sid)\n{\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *scontextp, *p, oldc;\n\tint rc = 0;\n\n\tcontext_init(ctx);\n\n\t/* Parse the security context. */\n\n\trc = -EINVAL;\n\tscontextp = (char *) scontext;\n\n\t/* Extract the user. */\n\tp = scontextp;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\tusrdatum = hashtab_search(pol->p_users.table, scontextp);\n\tif (!usrdatum)\n\t\tgoto out;\n\n\tctx->user = usrdatum->value;\n\n\t/* Extract role. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\trole = hashtab_search(pol->p_roles.table, scontextp);\n\tif (!role)\n\t\tgoto out;\n\tctx->role = role->value;\n\n\t/* Extract type. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\toldc = *p;\n\t*p++ = 0;\n\n\ttypdatum = hashtab_search(pol->p_types.table, scontextp);\n\tif (!typdatum || typdatum->attribute)\n\t\tgoto out;\n\n\tctx->type = typdatum->value;\n\n\trc = mls_context_to_sid(pol, oldc, &p, ctx, sidtabp, def_sid);\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif ((p - scontext) < scontext_len)\n\t\tgoto out;\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(pol, ctx))\n\t\tgoto out;\n\trc = 0;\nout:\n\tif (rc)\n\t\tcontext_destroy(ctx);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);",
            "static int security_preserve_bools(struct policydb *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\nstatic int security_preserve_bools(struct policydb *p);\n\nstatic int string_to_context_struct(struct policydb *pol,\n\t\t\t\t    struct sidtab *sidtabp,\n\t\t\t\t    char *scontext,\n\t\t\t\t    u32 scontext_len,\n\t\t\t\t    struct context *ctx,\n\t\t\t\t    u32 def_sid)\n{\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *scontextp, *p, oldc;\n\tint rc = 0;\n\n\tcontext_init(ctx);\n\n\t/* Parse the security context. */\n\n\trc = -EINVAL;\n\tscontextp = (char *) scontext;\n\n\t/* Extract the user. */\n\tp = scontextp;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\tusrdatum = hashtab_search(pol->p_users.table, scontextp);\n\tif (!usrdatum)\n\t\tgoto out;\n\n\tctx->user = usrdatum->value;\n\n\t/* Extract role. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\trole = hashtab_search(pol->p_roles.table, scontextp);\n\tif (!role)\n\t\tgoto out;\n\tctx->role = role->value;\n\n\t/* Extract type. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\toldc = *p;\n\t*p++ = 0;\n\n\ttypdatum = hashtab_search(pol->p_types.table, scontextp);\n\tif (!typdatum || typdatum->attribute)\n\t\tgoto out;\n\n\tctx->type = typdatum->value;\n\n\trc = mls_context_to_sid(pol, oldc, &p, ctx, sidtabp, def_sid);\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif ((p - scontext) < scontext_len)\n\t\tgoto out;\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(pol, ctx))\n\t\tgoto out;\n\trc = 0;\nout:\n\tif (rc)\n\t\tcontext_destroy(ctx);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "scontext2",
            "gfp_flags"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "scontext2",
            "scontext",
            "scontext_len"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "scontext_len + 1",
            "gfp_flags"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "initial_sid_to_string[i]",
            "scontext"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\n\t/* An empty security context is never valid. */\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\n\tif (!ss_initialized) {\n\t\tint i;\n\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}"
  },
  {
    "function_name": "string_to_context_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1322-1402",
    "snippet": "static int string_to_context_struct(struct policydb *pol,\n\t\t\t\t    struct sidtab *sidtabp,\n\t\t\t\t    char *scontext,\n\t\t\t\t    u32 scontext_len,\n\t\t\t\t    struct context *ctx,\n\t\t\t\t    u32 def_sid)\n{\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *scontextp, *p, oldc;\n\tint rc = 0;\n\n\tcontext_init(ctx);\n\n\t/* Parse the security context. */\n\n\trc = -EINVAL;\n\tscontextp = (char *) scontext;\n\n\t/* Extract the user. */\n\tp = scontextp;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\tusrdatum = hashtab_search(pol->p_users.table, scontextp);\n\tif (!usrdatum)\n\t\tgoto out;\n\n\tctx->user = usrdatum->value;\n\n\t/* Extract role. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\trole = hashtab_search(pol->p_roles.table, scontextp);\n\tif (!role)\n\t\tgoto out;\n\tctx->role = role->value;\n\n\t/* Extract type. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\toldc = *p;\n\t*p++ = 0;\n\n\ttypdatum = hashtab_search(pol->p_types.table, scontextp);\n\tif (!typdatum || typdatum->attribute)\n\t\tgoto out;\n\n\tctx->type = typdatum->value;\n\n\trc = mls_context_to_sid(pol, oldc, &p, ctx, sidtabp, def_sid);\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif ((p - scontext) < scontext_len)\n\t\tgoto out;\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(pol, ctx))\n\t\tgoto out;\n\trc = 0;\nout:\n\tif (rc)\n\t\tcontext_destroy(ctx);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sidtab sidtab;",
      "struct policydb policydb;",
      "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);",
      "static int security_preserve_bools(struct policydb *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_destroy",
          "args": [
            "ctx"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "context_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "142-149",
          "snippet": "static inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policydb_context_isvalid",
          "args": [
            "pol",
            "ctx"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_context_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "950-989",
          "snippet": "int policydb_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct role_datum *role;\n\tstruct user_datum *usrdatum;\n\n\tif (!c->role || c->role > p->p_roles.nprim)\n\t\treturn 0;\n\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\n\tif (!c->type || c->type > p->p_types.nprim)\n\t\treturn 0;\n\n\tif (c->role != OBJECT_R_VAL) {\n\t\t/*\n\t\t * Role must be authorized for the type.\n\t\t */\n\t\trole = p->role_val_to_struct[c->role - 1];\n\t\tif (!role || !ebitmap_get_bit(&role->types, c->type - 1))\n\t\t\t/* role may not be associated with type */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * User must be authorized for the role.\n\t\t */\n\t\tusrdatum = p->user_val_to_struct[c->user - 1];\n\t\tif (!usrdatum)\n\t\t\treturn 0;\n\n\t\tif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\n\t\t\t/* user may not be associated with role */\n\t\t\treturn 0;\n\t}\n\n\tif (!mls_context_isvalid(p, c))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct role_datum *role;\n\tstruct user_datum *usrdatum;\n\n\tif (!c->role || c->role > p->p_roles.nprim)\n\t\treturn 0;\n\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\n\tif (!c->type || c->type > p->p_types.nprim)\n\t\treturn 0;\n\n\tif (c->role != OBJECT_R_VAL) {\n\t\t/*\n\t\t * Role must be authorized for the type.\n\t\t */\n\t\trole = p->role_val_to_struct[c->role - 1];\n\t\tif (!role || !ebitmap_get_bit(&role->types, c->type - 1))\n\t\t\t/* role may not be associated with type */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * User must be authorized for the role.\n\t\t */\n\t\tusrdatum = p->user_val_to_struct[c->user - 1];\n\t\tif (!usrdatum)\n\t\t\treturn 0;\n\n\t\tif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\n\t\t\t/* user may not be associated with role */\n\t\t\treturn 0;\n\t}\n\n\tif (!mls_context_isvalid(p, c))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_context_to_sid",
          "args": [
            "pol",
            "oldc",
            "&p",
            "ctx",
            "sidtabp",
            "def_sid"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "mls_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "235-370",
          "snippet": "int mls_context_to_sid(struct policydb *pol,\n\t\t       char oldc,\n\t\t       char **scontext,\n\t\t       struct context *context,\n\t\t       struct sidtab *s,\n\t\t       u32 def_sid)\n{\n\n\tchar delim;\n\tchar *scontextp, *p, *rngptr;\n\tstruct level_datum *levdatum;\n\tstruct cat_datum *catdatum, *rngdatum;\n\tint l, rc = -EINVAL;\n\n\tif (!pol->mls_enabled) {\n\t\tif (def_sid != SECSID_NULL && oldc)\n\t\t\t*scontext += strlen(*scontext) + 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * No MLS component to the security context, try and map to\n\t * default if provided.\n\t */\n\tif (!oldc) {\n\t\tstruct context *defcon;\n\n\t\tif (def_sid == SECSID_NULL)\n\t\t\tgoto out;\n\n\t\tdefcon = sidtab_search(s, def_sid);\n\t\tif (!defcon)\n\t\t\tgoto out;\n\n\t\trc = mls_context_cpy(context, defcon);\n\t\tgoto out;\n\t}\n\n\t/* Extract low sensitivity. */\n\tscontextp = p = *scontext;\n\twhile (*p && *p != ':' && *p != '-')\n\t\tp++;\n\n\tdelim = *p;\n\tif (delim != '\\0')\n\t\t*p++ = '\\0';\n\n\tfor (l = 0; l < 2; l++) {\n\t\tlevdatum = hashtab_search(pol->p_levels.table, scontextp);\n\t\tif (!levdatum) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcontext->range.level[l].sens = levdatum->level->sens;\n\n\t\tif (delim == ':') {\n\t\t\t/* Extract category set. */\n\t\t\twhile (1) {\n\t\t\t\tscontextp = p;\n\t\t\t\twhile (*p && *p != ',' && *p != '-')\n\t\t\t\t\tp++;\n\t\t\t\tdelim = *p;\n\t\t\t\tif (delim != '\\0')\n\t\t\t\t\t*p++ = '\\0';\n\n\t\t\t\t/* Separate into range if exists */\n\t\t\t\trngptr = strchr(scontextp, '.');\n\t\t\t\tif (rngptr != NULL) {\n\t\t\t\t\t/* Remove '.' */\n\t\t\t\t\t*rngptr++ = '\\0';\n\t\t\t\t}\n\n\t\t\t\tcatdatum = hashtab_search(pol->p_cats.table,\n\t\t\t\t\t\t\t  scontextp);\n\t\t\t\tif (!catdatum) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat,\n\t\t\t\t\t\t     catdatum->value - 1, 1);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/* If range, set all categories in range */\n\t\t\t\tif (rngptr) {\n\t\t\t\t\tint i;\n\n\t\t\t\t\trngdatum = hashtab_search(pol->p_cats.table, rngptr);\n\t\t\t\t\tif (!rngdatum) {\n\t\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (catdatum->value >= rngdatum->value) {\n\t\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = catdatum->value; i < rngdatum->value; i++) {\n\t\t\t\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat, i, 1);\n\t\t\t\t\t\tif (rc)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (delim != ',')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (delim == '-') {\n\t\t\t/* Extract high sensitivity. */\n\t\t\tscontextp = p;\n\t\t\twhile (*p && *p != ':')\n\t\t\t\tp++;\n\n\t\t\tdelim = *p;\n\t\t\tif (delim != '\\0')\n\t\t\t\t*p++ = '\\0';\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (l == 0) {\n\t\tcontext->range.level[1].sens = context->range.level[0].sens;\n\t\trc = ebitmap_cpy(&context->range.level[1].cat,\n\t\t\t\t &context->range.level[0].cat);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\t*scontext = ++p;\n\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_context_to_sid(struct policydb *pol,\n\t\t       char oldc,\n\t\t       char **scontext,\n\t\t       struct context *context,\n\t\t       struct sidtab *s,\n\t\t       u32 def_sid)\n{\n\n\tchar delim;\n\tchar *scontextp, *p, *rngptr;\n\tstruct level_datum *levdatum;\n\tstruct cat_datum *catdatum, *rngdatum;\n\tint l, rc = -EINVAL;\n\n\tif (!pol->mls_enabled) {\n\t\tif (def_sid != SECSID_NULL && oldc)\n\t\t\t*scontext += strlen(*scontext) + 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * No MLS component to the security context, try and map to\n\t * default if provided.\n\t */\n\tif (!oldc) {\n\t\tstruct context *defcon;\n\n\t\tif (def_sid == SECSID_NULL)\n\t\t\tgoto out;\n\n\t\tdefcon = sidtab_search(s, def_sid);\n\t\tif (!defcon)\n\t\t\tgoto out;\n\n\t\trc = mls_context_cpy(context, defcon);\n\t\tgoto out;\n\t}\n\n\t/* Extract low sensitivity. */\n\tscontextp = p = *scontext;\n\twhile (*p && *p != ':' && *p != '-')\n\t\tp++;\n\n\tdelim = *p;\n\tif (delim != '\\0')\n\t\t*p++ = '\\0';\n\n\tfor (l = 0; l < 2; l++) {\n\t\tlevdatum = hashtab_search(pol->p_levels.table, scontextp);\n\t\tif (!levdatum) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcontext->range.level[l].sens = levdatum->level->sens;\n\n\t\tif (delim == ':') {\n\t\t\t/* Extract category set. */\n\t\t\twhile (1) {\n\t\t\t\tscontextp = p;\n\t\t\t\twhile (*p && *p != ',' && *p != '-')\n\t\t\t\t\tp++;\n\t\t\t\tdelim = *p;\n\t\t\t\tif (delim != '\\0')\n\t\t\t\t\t*p++ = '\\0';\n\n\t\t\t\t/* Separate into range if exists */\n\t\t\t\trngptr = strchr(scontextp, '.');\n\t\t\t\tif (rngptr != NULL) {\n\t\t\t\t\t/* Remove '.' */\n\t\t\t\t\t*rngptr++ = '\\0';\n\t\t\t\t}\n\n\t\t\t\tcatdatum = hashtab_search(pol->p_cats.table,\n\t\t\t\t\t\t\t  scontextp);\n\t\t\t\tif (!catdatum) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat,\n\t\t\t\t\t\t     catdatum->value - 1, 1);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/* If range, set all categories in range */\n\t\t\t\tif (rngptr) {\n\t\t\t\t\tint i;\n\n\t\t\t\t\trngdatum = hashtab_search(pol->p_cats.table, rngptr);\n\t\t\t\t\tif (!rngdatum) {\n\t\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (catdatum->value >= rngdatum->value) {\n\t\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = catdatum->value; i < rngdatum->value; i++) {\n\t\t\t\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat, i, 1);\n\t\t\t\t\t\tif (rc)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (delim != ',')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (delim == '-') {\n\t\t\t/* Extract high sensitivity. */\n\t\t\tscontextp = p;\n\t\t\twhile (*p && *p != ':')\n\t\t\t\tp++;\n\n\t\t\tdelim = *p;\n\t\t\tif (delim != '\\0')\n\t\t\t\t*p++ = '\\0';\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (l == 0) {\n\t\tcontext->range.level[1].sens = context->range.level[0].sens;\n\t\trc = ebitmap_cpy(&context->range.level[1].cat,\n\t\t\t\t &context->range.level[0].cat);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\t*scontext = ++p;\n\trc = 0;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "pol->p_types.table",
            "scontextp"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_init",
          "args": [
            "ctx"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "context_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "113-116",
          "snippet": "static inline void context_init(struct context *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_init(struct context *c)\n{\n\tmemset(c, 0, sizeof(*c));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\nstatic int security_preserve_bools(struct policydb *p);\n\nstatic int string_to_context_struct(struct policydb *pol,\n\t\t\t\t    struct sidtab *sidtabp,\n\t\t\t\t    char *scontext,\n\t\t\t\t    u32 scontext_len,\n\t\t\t\t    struct context *ctx,\n\t\t\t\t    u32 def_sid)\n{\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *scontextp, *p, oldc;\n\tint rc = 0;\n\n\tcontext_init(ctx);\n\n\t/* Parse the security context. */\n\n\trc = -EINVAL;\n\tscontextp = (char *) scontext;\n\n\t/* Extract the user. */\n\tp = scontextp;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\tusrdatum = hashtab_search(pol->p_users.table, scontextp);\n\tif (!usrdatum)\n\t\tgoto out;\n\n\tctx->user = usrdatum->value;\n\n\t/* Extract role. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\trole = hashtab_search(pol->p_roles.table, scontextp);\n\tif (!role)\n\t\tgoto out;\n\tctx->role = role->value;\n\n\t/* Extract type. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\toldc = *p;\n\t*p++ = 0;\n\n\ttypdatum = hashtab_search(pol->p_types.table, scontextp);\n\tif (!typdatum || typdatum->attribute)\n\t\tgoto out;\n\n\tctx->type = typdatum->value;\n\n\trc = mls_context_to_sid(pol, oldc, &p, ctx, sidtabp, def_sid);\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif ((p - scontext) < scontext_len)\n\t\tgoto out;\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(pol, ctx))\n\t\tgoto out;\n\trc = 0;\nout:\n\tif (rc)\n\t\tcontext_destroy(ctx);\n\treturn rc;\n}"
  },
  {
    "function_name": "security_sid_to_context_force",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1314-1317",
    "snippet": "int security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_sid_to_context_core",
          "args": [
            "sid",
            "scontext",
            "scontext_len",
            "1"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "security_sid_to_context_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1249-1297",
          "snippet": "static int security_sid_to_context_core(u32 sid, char **scontext,\n\t\t\t\t\tu32 *scontext_len, int force)\n{\n\tstruct context *context;\n\tint rc = 0;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len  = 0;\n\n\tif (!ss_initialized) {\n\t\tif (sid <= SECINITSID_NUM) {\n\t\t\tchar *scontextp;\n\n\t\t\t*scontext_len = strlen(initial_sid_to_string[sid]) + 1;\n\t\t\tif (!scontext)\n\t\t\t\tgoto out;\n\t\t\tscontextp = kmemdup(initial_sid_to_string[sid],\n\t\t\t\t\t    *scontext_len, GFP_ATOMIC);\n\t\t\tif (!scontextp) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*scontext = scontextp;\n\t\t\tgoto out;\n\t\t}\n\t\tprintk(KERN_ERR \"SELinux: %s:  called before initial \"\n\t\t       \"load_policy on unknown SID %d\\n\", __func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\tif (force)\n\t\tcontext = sidtab_search_force(&sidtab, sid);\n\telse\n\t\tcontext = sidtab_search(&sidtab, sid);\n\tif (!context) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\trc = context_struct_to_string(context, scontext, scontext_len);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\treturn rc;\n\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "int ss_initialized;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nint ss_initialized;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int security_sid_to_context_core(u32 sid, char **scontext,\n\t\t\t\t\tu32 *scontext_len, int force)\n{\n\tstruct context *context;\n\tint rc = 0;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len  = 0;\n\n\tif (!ss_initialized) {\n\t\tif (sid <= SECINITSID_NUM) {\n\t\t\tchar *scontextp;\n\n\t\t\t*scontext_len = strlen(initial_sid_to_string[sid]) + 1;\n\t\t\tif (!scontext)\n\t\t\t\tgoto out;\n\t\t\tscontextp = kmemdup(initial_sid_to_string[sid],\n\t\t\t\t\t    *scontext_len, GFP_ATOMIC);\n\t\t\tif (!scontextp) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*scontext = scontextp;\n\t\t\tgoto out;\n\t\t}\n\t\tprintk(KERN_ERR \"SELinux: %s:  called before initial \"\n\t\t       \"load_policy on unknown SID %d\\n\", __func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\tif (force)\n\t\tcontext = sidtab_search_force(&sidtab, sid);\n\telse\n\t\tcontext = sidtab_search(&sidtab, sid);\n\tif (!context) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\trc = context_struct_to_string(context, scontext, scontext_len);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\treturn rc;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}"
  },
  {
    "function_name": "security_sid_to_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1309-1312",
    "snippet": "int security_sid_to_context(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 0);\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_sid_to_context_core",
          "args": [
            "sid",
            "scontext",
            "scontext_len",
            "0"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "security_sid_to_context_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1249-1297",
          "snippet": "static int security_sid_to_context_core(u32 sid, char **scontext,\n\t\t\t\t\tu32 *scontext_len, int force)\n{\n\tstruct context *context;\n\tint rc = 0;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len  = 0;\n\n\tif (!ss_initialized) {\n\t\tif (sid <= SECINITSID_NUM) {\n\t\t\tchar *scontextp;\n\n\t\t\t*scontext_len = strlen(initial_sid_to_string[sid]) + 1;\n\t\t\tif (!scontext)\n\t\t\t\tgoto out;\n\t\t\tscontextp = kmemdup(initial_sid_to_string[sid],\n\t\t\t\t\t    *scontext_len, GFP_ATOMIC);\n\t\t\tif (!scontextp) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*scontext = scontextp;\n\t\t\tgoto out;\n\t\t}\n\t\tprintk(KERN_ERR \"SELinux: %s:  called before initial \"\n\t\t       \"load_policy on unknown SID %d\\n\", __func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\tif (force)\n\t\tcontext = sidtab_search_force(&sidtab, sid);\n\telse\n\t\tcontext = sidtab_search(&sidtab, sid);\n\tif (!context) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\trc = context_struct_to_string(context, scontext, scontext_len);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\treturn rc;\n\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "int ss_initialized;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nint ss_initialized;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int security_sid_to_context_core(u32 sid, char **scontext,\n\t\t\t\t\tu32 *scontext_len, int force)\n{\n\tstruct context *context;\n\tint rc = 0;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len  = 0;\n\n\tif (!ss_initialized) {\n\t\tif (sid <= SECINITSID_NUM) {\n\t\t\tchar *scontextp;\n\n\t\t\t*scontext_len = strlen(initial_sid_to_string[sid]) + 1;\n\t\t\tif (!scontext)\n\t\t\t\tgoto out;\n\t\t\tscontextp = kmemdup(initial_sid_to_string[sid],\n\t\t\t\t\t    *scontext_len, GFP_ATOMIC);\n\t\t\tif (!scontextp) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*scontext = scontextp;\n\t\t\tgoto out;\n\t\t}\n\t\tprintk(KERN_ERR \"SELinux: %s:  called before initial \"\n\t\t       \"load_policy on unknown SID %d\\n\", __func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\tif (force)\n\t\tcontext = sidtab_search_force(&sidtab, sid);\n\telse\n\t\tcontext = sidtab_search(&sidtab, sid);\n\tif (!context) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\trc = context_struct_to_string(context, scontext, scontext_len);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\treturn rc;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_sid_to_context(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 0);\n}"
  },
  {
    "function_name": "security_sid_to_context_core",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1249-1297",
    "snippet": "static int security_sid_to_context_core(u32 sid, char **scontext,\n\t\t\t\t\tu32 *scontext_len, int force)\n{\n\tstruct context *context;\n\tint rc = 0;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len  = 0;\n\n\tif (!ss_initialized) {\n\t\tif (sid <= SECINITSID_NUM) {\n\t\t\tchar *scontextp;\n\n\t\t\t*scontext_len = strlen(initial_sid_to_string[sid]) + 1;\n\t\t\tif (!scontext)\n\t\t\t\tgoto out;\n\t\t\tscontextp = kmemdup(initial_sid_to_string[sid],\n\t\t\t\t\t    *scontext_len, GFP_ATOMIC);\n\t\t\tif (!scontextp) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*scontext = scontextp;\n\t\t\tgoto out;\n\t\t}\n\t\tprintk(KERN_ERR \"SELinux: %s:  called before initial \"\n\t\t       \"load_policy on unknown SID %d\\n\", __func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\tif (force)\n\t\tcontext = sidtab_search_force(&sidtab, sid);\n\telse\n\t\tcontext = sidtab_search(&sidtab, sid);\n\tif (!context) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\trc = context_struct_to_string(context, scontext, scontext_len);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\treturn rc;\n\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "int ss_initialized;",
      "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_struct_to_string",
          "args": [
            "context",
            "scontext",
            "scontext_len"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "context_struct_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1192-1238",
          "snippet": "static int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "sid"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "&sidtab",
            "sid"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_search_force",
          "args": [
            "&sidtab",
            "sid"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "114-117",
          "snippet": "struct context *sidtab_search_force(struct sidtab *s, u32 sid)\n{\n\treturn sidtab_search_core(s, sid, 1);\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct context *sidtab_search_force(struct sidtab *s, u32 sid)\n{\n\treturn sidtab_search_core(s, sid, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  called before initial \"\n\t\t       \"load_policy on unknown SID %d\\n\"",
            "__func__",
            "sid"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "initial_sid_to_string[sid]",
            "*scontext_len",
            "GFP_ATOMIC"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "initial_sid_to_string[sid]"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nint ss_initialized;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int security_sid_to_context_core(u32 sid, char **scontext,\n\t\t\t\t\tu32 *scontext_len, int force)\n{\n\tstruct context *context;\n\tint rc = 0;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len  = 0;\n\n\tif (!ss_initialized) {\n\t\tif (sid <= SECINITSID_NUM) {\n\t\t\tchar *scontextp;\n\n\t\t\t*scontext_len = strlen(initial_sid_to_string[sid]) + 1;\n\t\t\tif (!scontext)\n\t\t\t\tgoto out;\n\t\t\tscontextp = kmemdup(initial_sid_to_string[sid],\n\t\t\t\t\t    *scontext_len, GFP_ATOMIC);\n\t\t\tif (!scontextp) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*scontext = scontextp;\n\t\t\tgoto out;\n\t\t}\n\t\tprintk(KERN_ERR \"SELinux: %s:  called before initial \"\n\t\t       \"load_policy on unknown SID %d\\n\", __func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\tif (force)\n\t\tcontext = sidtab_search_force(&sidtab, sid);\n\telse\n\t\tcontext = sidtab_search(&sidtab, sid);\n\tif (!context) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\trc = context_struct_to_string(context, scontext, scontext_len);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\treturn rc;\n\n}"
  },
  {
    "function_name": "security_get_initial_sid_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1242-1247",
    "snippet": "const char *security_get_initial_sid_context(u32 sid)\n{\n\tif (unlikely(sid > SECINITSID_NUM))\n\t\treturn NULL;\n\treturn initial_sid_to_string[sid];\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sid > SECINITSID_NUM"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nconst char *security_get_initial_sid_context(u32 sid)\n{\n\tif (unlikely(sid > SECINITSID_NUM))\n\t\treturn NULL;\n\treturn initial_sid_to_string[sid];\n}"
  },
  {
    "function_name": "context_struct_to_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1192-1238",
    "snippet": "static int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct policydb policydb;",
      "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mls_sid_to_context",
          "args": [
            "context",
            "&scontextp"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "mls_sid_to_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "89-159",
          "snippet": "void mls_sid_to_context(struct context *context,\n\t\t\tchar **scontext)\n{\n\tchar *scontextp, *nm;\n\tint i, l, head, prev;\n\tstruct ebitmap *e;\n\tstruct ebitmap_node *node;\n\n\tif (!policydb.mls_enabled)\n\t\treturn;\n\n\tscontextp = *scontext;\n\n\t*scontextp = ':';\n\tscontextp++;\n\n\tfor (l = 0; l < 2; l++) {\n\t\tstrcpy(scontextp, sym_name(&policydb, SYM_LEVELS,\n\t\t\t\t\t   context->range.level[l].sens - 1));\n\t\tscontextp += strlen(scontextp);\n\n\t\t/* categories */\n\t\thead = -2;\n\t\tprev = -2;\n\t\te = &context->range.level[l].cat;\n\t\tebitmap_for_each_positive_bit(e, node, i) {\n\t\t\tif (i - prev > 1) {\n\t\t\t\t/* one or more negative bits are skipped */\n\t\t\t\tif (prev != head) {\n\t\t\t\t\tif (prev - head > 1)\n\t\t\t\t\t\t*scontextp++ = '.';\n\t\t\t\t\telse\n\t\t\t\t\t\t*scontextp++ = ',';\n\t\t\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\t\t\tstrcpy(scontextp, nm);\n\t\t\t\t\tscontextp += strlen(nm);\n\t\t\t\t}\n\t\t\t\tif (prev < 0)\n\t\t\t\t\t*scontextp++ = ':';\n\t\t\t\telse\n\t\t\t\t\t*scontextp++ = ',';\n\t\t\t\tnm = sym_name(&policydb, SYM_CATS, i);\n\t\t\t\tstrcpy(scontextp, nm);\n\t\t\t\tscontextp += strlen(nm);\n\t\t\t\thead = i;\n\t\t\t}\n\t\t\tprev = i;\n\t\t}\n\n\t\tif (prev != head) {\n\t\t\tif (prev - head > 1)\n\t\t\t\t*scontextp++ = '.';\n\t\t\telse\n\t\t\t\t*scontextp++ = ',';\n\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\tstrcpy(scontextp, nm);\n\t\t\tscontextp += strlen(nm);\n\t\t}\n\n\t\tif (l == 0) {\n\t\t\tif (mls_level_eq(&context->range.level[0],\n\t\t\t\t\t &context->range.level[1]))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\t*scontextp++ = '-';\n\t\t}\n\t}\n\n\t*scontext = scontextp;\n\treturn;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid mls_sid_to_context(struct context *context,\n\t\t\tchar **scontext)\n{\n\tchar *scontextp, *nm;\n\tint i, l, head, prev;\n\tstruct ebitmap *e;\n\tstruct ebitmap_node *node;\n\n\tif (!policydb.mls_enabled)\n\t\treturn;\n\n\tscontextp = *scontext;\n\n\t*scontextp = ':';\n\tscontextp++;\n\n\tfor (l = 0; l < 2; l++) {\n\t\tstrcpy(scontextp, sym_name(&policydb, SYM_LEVELS,\n\t\t\t\t\t   context->range.level[l].sens - 1));\n\t\tscontextp += strlen(scontextp);\n\n\t\t/* categories */\n\t\thead = -2;\n\t\tprev = -2;\n\t\te = &context->range.level[l].cat;\n\t\tebitmap_for_each_positive_bit(e, node, i) {\n\t\t\tif (i - prev > 1) {\n\t\t\t\t/* one or more negative bits are skipped */\n\t\t\t\tif (prev != head) {\n\t\t\t\t\tif (prev - head > 1)\n\t\t\t\t\t\t*scontextp++ = '.';\n\t\t\t\t\telse\n\t\t\t\t\t\t*scontextp++ = ',';\n\t\t\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\t\t\tstrcpy(scontextp, nm);\n\t\t\t\t\tscontextp += strlen(nm);\n\t\t\t\t}\n\t\t\t\tif (prev < 0)\n\t\t\t\t\t*scontextp++ = ':';\n\t\t\t\telse\n\t\t\t\t\t*scontextp++ = ',';\n\t\t\t\tnm = sym_name(&policydb, SYM_CATS, i);\n\t\t\t\tstrcpy(scontextp, nm);\n\t\t\t\tscontextp += strlen(nm);\n\t\t\t\thead = i;\n\t\t\t}\n\t\t\tprev = i;\n\t\t}\n\n\t\tif (prev != head) {\n\t\t\tif (prev - head > 1)\n\t\t\t\t*scontextp++ = '.';\n\t\t\telse\n\t\t\t\t*scontextp++ = ',';\n\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\tstrcpy(scontextp, nm);\n\t\t\tscontextp += strlen(nm);\n\t\t}\n\n\t\tif (l == 0) {\n\t\t\tif (mls_level_eq(&context->range.level[0],\n\t\t\t\t\t &context->range.level[1]))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\t*scontextp++ = '-';\n\t\t}\n\t}\n\n\t*scontext = scontextp;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "scontextp",
            "\"%s:%s:%s\"",
            "sym_name(&policydb, SYM_USERS, context->user - 1)",
            "sym_name(&policydb, SYM_ROLES, context->role - 1)",
            "sym_name(&policydb, SYM_TYPES, context->type - 1)"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "&policydb",
            "SYM_TYPES",
            "context->type - 1"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "*scontext_len",
            "GFP_ATOMIC"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mls_compute_context_len",
          "args": [
            "context"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "mls_compute_context_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "36-82",
          "snippet": "int mls_compute_context_len(struct context *context)\n{\n\tint i, l, len, head, prev;\n\tchar *nm;\n\tstruct ebitmap *e;\n\tstruct ebitmap_node *node;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tlen = 1; /* for the beginning \":\" */\n\tfor (l = 0; l < 2; l++) {\n\t\tint index_sens = context->range.level[l].sens;\n\t\tlen += strlen(sym_name(&policydb, SYM_LEVELS, index_sens - 1));\n\n\t\t/* categories */\n\t\thead = -2;\n\t\tprev = -2;\n\t\te = &context->range.level[l].cat;\n\t\tebitmap_for_each_positive_bit(e, node, i) {\n\t\t\tif (i - prev > 1) {\n\t\t\t\t/* one or more negative bits are skipped */\n\t\t\t\tif (head != prev) {\n\t\t\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\t\t\tlen += strlen(nm) + 1;\n\t\t\t\t}\n\t\t\t\tnm = sym_name(&policydb, SYM_CATS, i);\n\t\t\t\tlen += strlen(nm) + 1;\n\t\t\t\thead = i;\n\t\t\t}\n\t\t\tprev = i;\n\t\t}\n\t\tif (prev != head) {\n\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\tlen += strlen(nm) + 1;\n\t\t}\n\t\tif (l == 0) {\n\t\t\tif (mls_level_eq(&context->range.level[0],\n\t\t\t\t\t &context->range.level[1]))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tlen++;\n\t\t}\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_compute_context_len(struct context *context)\n{\n\tint i, l, len, head, prev;\n\tchar *nm;\n\tstruct ebitmap *e;\n\tstruct ebitmap_node *node;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tlen = 1; /* for the beginning \":\" */\n\tfor (l = 0; l < 2; l++) {\n\t\tint index_sens = context->range.level[l].sens;\n\t\tlen += strlen(sym_name(&policydb, SYM_LEVELS, index_sens - 1));\n\n\t\t/* categories */\n\t\thead = -2;\n\t\tprev = -2;\n\t\te = &context->range.level[l].cat;\n\t\tebitmap_for_each_positive_bit(e, node, i) {\n\t\t\tif (i - prev > 1) {\n\t\t\t\t/* one or more negative bits are skipped */\n\t\t\t\tif (head != prev) {\n\t\t\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\t\t\tlen += strlen(nm) + 1;\n\t\t\t\t}\n\t\t\t\tnm = sym_name(&policydb, SYM_CATS, i);\n\t\t\t\tlen += strlen(nm) + 1;\n\t\t\t\thead = i;\n\t\t\t}\n\t\t\tprev = i;\n\t\t}\n\t\tif (prev != head) {\n\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\tlen += strlen(nm) + 1;\n\t\t}\n\t\tif (l == 0) {\n\t\t\tif (mls_level_eq(&context->range.level[0],\n\t\t\t\t\t &context->range.level[1]))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tlen++;\n\t\t}\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sym_name(&policydb, SYM_TYPES, context->type - 1)"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sym_name(&policydb, SYM_ROLES, context->role - 1)"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sym_name(&policydb, SYM_USERS, context->user - 1)"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "context->str",
            "GFP_ATOMIC"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "security_compute_av_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1140-1183",
    "snippet": "void security_compute_av_user(u32 ssid,\n\t\t\t      u32 tsid,\n\t\t\t      u16 tclass,\n\t\t\t      struct av_decision *avd)\n{\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\tread_lock(&policy_rwlock);\n\tavd_init(avd);\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t/* permissive domain? */\n\tif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(!tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\n\tcontext_struct_compute_av(scontext, tcontext, tclass, avd, NULL);\n out:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;",
      "int ss_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_struct_compute_av",
          "args": [
            "scontext",
            "tcontext",
            "tclass",
            "avd",
            "NULL"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "context_struct_compute_av",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "635-738",
          "snippet": "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms)\n{\n\tstruct constraint_node *constraint;\n\tstruct role_allow *ra;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct class_datum *tclass_datum;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tif (xperms) {\n\t\tmemset(&xperms->drivers, 0, sizeof(xperms->drivers));\n\t\txperms->len = 0;\n\t}\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"SELinux:  Invalid class %hu\\n\", tclass);\n\t\treturn;\n\t}\n\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\t/*\n\t * If a specific type enforcement rule was defined for\n\t * this permission check, then use it.\n\t */\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_AV | AVTAB_XPERMS;\n\tsattr = flex_array_get(policydb.type_attr_map_array, scontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array, tcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified)) {\n\t\t\t\tif (node->key.specified == AVTAB_ALLOWED)\n\t\t\t\t\tavd->allowed |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITALLOW)\n\t\t\t\t\tavd->auditallow |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITDENY)\n\t\t\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\t\t\telse if (xperms && (node->key.specified & AVTAB_XPERMS))\n\t\t\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t\t\t}\n\n\t\t\t/* Check conditional av table for additional permissions */\n\t\t\tcond_compute_av(&policydb.te_cond_avtab, &avkey,\n\t\t\t\t\tavd, xperms);\n\n\t\t}\n\t}\n\n\t/*\n\t * Remove any permissions prohibited by a constraint (this includes\n\t * the MLS policy).\n\t */\n\tconstraint = tclass_datum->constraints;\n\twhile (constraint) {\n\t\tif ((constraint->permissions & (avd->allowed)) &&\n\t\t    !constraint_expr_eval(scontext, tcontext, NULL,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tavd->allowed &= ~(constraint->permissions);\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\n\t/*\n\t * If checking process transition permission and the\n\t * role is changing, then check the (current_role, new_role)\n\t * pair.\n\t */\n\tif (tclass == policydb.process_class &&\n\t    (avd->allowed & policydb.process_trans_perms) &&\n\t    scontext->role != tcontext->role) {\n\t\tfor (ra = policydb.role_allow; ra; ra = ra->next) {\n\t\t\tif (scontext->role == ra->role &&\n\t\t\t    tcontext->role == ra->new_role)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!ra)\n\t\t\tavd->allowed &= ~policydb.process_trans_perms;\n\t}\n\n\t/*\n\t * If the given source and target types have boundary\n\t * constraint, lazy checks have to mask any violated\n\t * permission and notice it to userspace via audit.\n\t */\n\ttype_attribute_bounds_av(scontext, tcontext,\n\t\t\t\t tclass, avd);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;",
            "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);\n\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms)\n{\n\tstruct constraint_node *constraint;\n\tstruct role_allow *ra;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct class_datum *tclass_datum;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tif (xperms) {\n\t\tmemset(&xperms->drivers, 0, sizeof(xperms->drivers));\n\t\txperms->len = 0;\n\t}\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"SELinux:  Invalid class %hu\\n\", tclass);\n\t\treturn;\n\t}\n\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\t/*\n\t * If a specific type enforcement rule was defined for\n\t * this permission check, then use it.\n\t */\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_AV | AVTAB_XPERMS;\n\tsattr = flex_array_get(policydb.type_attr_map_array, scontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array, tcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified)) {\n\t\t\t\tif (node->key.specified == AVTAB_ALLOWED)\n\t\t\t\t\tavd->allowed |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITALLOW)\n\t\t\t\t\tavd->auditallow |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITDENY)\n\t\t\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\t\t\telse if (xperms && (node->key.specified & AVTAB_XPERMS))\n\t\t\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t\t\t}\n\n\t\t\t/* Check conditional av table for additional permissions */\n\t\t\tcond_compute_av(&policydb.te_cond_avtab, &avkey,\n\t\t\t\t\tavd, xperms);\n\n\t\t}\n\t}\n\n\t/*\n\t * Remove any permissions prohibited by a constraint (this includes\n\t * the MLS policy).\n\t */\n\tconstraint = tclass_datum->constraints;\n\twhile (constraint) {\n\t\tif ((constraint->permissions & (avd->allowed)) &&\n\t\t    !constraint_expr_eval(scontext, tcontext, NULL,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tavd->allowed &= ~(constraint->permissions);\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\n\t/*\n\t * If checking process transition permission and the\n\t * role is changing, then check the (current_role, new_role)\n\t * pair.\n\t */\n\tif (tclass == policydb.process_class &&\n\t    (avd->allowed & policydb.process_trans_perms) &&\n\t    scontext->role != tcontext->role) {\n\t\tfor (ra = policydb.role_allow; ra; ra = ra->next) {\n\t\t\tif (scontext->role == ra->role &&\n\t\t\t    tcontext->role == ra->new_role)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!ra)\n\t\t\tavd->allowed &= ~policydb.process_trans_perms;\n\t}\n\n\t/*\n\t * If the given source and target types have boundary\n\t * constraint, lazy checks have to mask any violated\n\t * permission and notice it to userspace via audit.\n\t */\n\ttype_attribute_bounds_av(scontext, tcontext,\n\t\t\t\t tclass, avd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tclass"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "tsid"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "&sidtab",
            "tsid"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_get_bit",
          "args": [
            "&policydb.permissive_map",
            "scontext->type"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_get_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "242-257",
          "snippet": "int ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "ssid"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avd_init",
          "args": [
            "avd"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "avd_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "937-944",
          "snippet": "static void avd_init(struct av_decision *avd)\n{\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tavd->seqno = latest_granting;\n\tavd->flags = 0;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 latest_granting;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic u32 latest_granting;\n\nstatic void avd_init(struct av_decision *avd)\n{\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tavd->seqno = latest_granting;\n\tavd->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nvoid security_compute_av_user(u32 ssid,\n\t\t\t      u32 tsid,\n\t\t\t      u16 tclass,\n\t\t\t      struct av_decision *avd)\n{\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\tread_lock(&policy_rwlock);\n\tavd_init(avd);\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t/* permissive domain? */\n\tif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(!tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\n\tcontext_struct_compute_av(scontext, tcontext, tclass, avd, NULL);\n out:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}"
  },
  {
    "function_name": "security_compute_av",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1091-1138",
    "snippet": "void security_compute_av(u32 ssid,\n\t\t\t u32 tsid,\n\t\t\t u16 orig_tclass,\n\t\t\t struct av_decision *avd,\n\t\t\t struct extended_perms *xperms)\n{\n\tu16 tclass;\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\tread_lock(&policy_rwlock);\n\tavd_init(avd);\n\txperms->len = 0;\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t/* permissive domain? */\n\tif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\ttclass = unmap_class(orig_tclass);\n\tif (unlikely(orig_tclass && !tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\tcontext_struct_compute_av(scontext, tcontext, tclass, avd, xperms);\n\tmap_decision(orig_tclass, avd, policydb.allow_unknown);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;",
      "int ss_initialized;",
      "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_decision",
          "args": [
            "orig_tclass",
            "avd",
            "policydb.allow_unknown"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "map_decision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "232-267",
          "snippet": "static void map_decision(u16 tclass, struct av_decision *avd,\n\t\t\t int allow_unknown)\n{\n\tif (tclass < current_mapping_size) {\n\t\tunsigned i, n = current_mapping[tclass].num_perms;\n\t\tu32 result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->allowed & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t\tif (allow_unknown && !current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t}\n\t\tavd->allowed = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++)\n\t\t\tif (avd->auditallow & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\tavd->auditallow = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->auditdeny & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t\tif (!allow_unknown && !current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t}\n\t\t/*\n\t\t * In case the kernel has a bug and requests a permission\n\t\t * between num_perms and the maximum permission number, we\n\t\t * should audit that denial\n\t\t */\n\t\tfor (; i < (sizeof(u32)*8); i++)\n\t\t\tresult |= 1<<i;\n\t\tavd->auditdeny = result;\n\t}\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct selinux_mapping *current_mapping;",
            "static u16 current_mapping_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nstatic void map_decision(u16 tclass, struct av_decision *avd,\n\t\t\t int allow_unknown)\n{\n\tif (tclass < current_mapping_size) {\n\t\tunsigned i, n = current_mapping[tclass].num_perms;\n\t\tu32 result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->allowed & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t\tif (allow_unknown && !current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t}\n\t\tavd->allowed = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++)\n\t\t\tif (avd->auditallow & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\tavd->auditallow = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->auditdeny & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t\tif (!allow_unknown && !current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t}\n\t\t/*\n\t\t * In case the kernel has a bug and requests a permission\n\t\t * between num_perms and the maximum permission number, we\n\t\t * should audit that denial\n\t\t */\n\t\tfor (; i < (sizeof(u32)*8); i++)\n\t\t\tresult |= 1<<i;\n\t\tavd->auditdeny = result;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_struct_compute_av",
          "args": [
            "scontext",
            "tcontext",
            "tclass",
            "avd",
            "xperms"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "context_struct_compute_av",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "635-738",
          "snippet": "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms)\n{\n\tstruct constraint_node *constraint;\n\tstruct role_allow *ra;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct class_datum *tclass_datum;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tif (xperms) {\n\t\tmemset(&xperms->drivers, 0, sizeof(xperms->drivers));\n\t\txperms->len = 0;\n\t}\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"SELinux:  Invalid class %hu\\n\", tclass);\n\t\treturn;\n\t}\n\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\t/*\n\t * If a specific type enforcement rule was defined for\n\t * this permission check, then use it.\n\t */\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_AV | AVTAB_XPERMS;\n\tsattr = flex_array_get(policydb.type_attr_map_array, scontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array, tcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified)) {\n\t\t\t\tif (node->key.specified == AVTAB_ALLOWED)\n\t\t\t\t\tavd->allowed |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITALLOW)\n\t\t\t\t\tavd->auditallow |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITDENY)\n\t\t\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\t\t\telse if (xperms && (node->key.specified & AVTAB_XPERMS))\n\t\t\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t\t\t}\n\n\t\t\t/* Check conditional av table for additional permissions */\n\t\t\tcond_compute_av(&policydb.te_cond_avtab, &avkey,\n\t\t\t\t\tavd, xperms);\n\n\t\t}\n\t}\n\n\t/*\n\t * Remove any permissions prohibited by a constraint (this includes\n\t * the MLS policy).\n\t */\n\tconstraint = tclass_datum->constraints;\n\twhile (constraint) {\n\t\tif ((constraint->permissions & (avd->allowed)) &&\n\t\t    !constraint_expr_eval(scontext, tcontext, NULL,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tavd->allowed &= ~(constraint->permissions);\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\n\t/*\n\t * If checking process transition permission and the\n\t * role is changing, then check the (current_role, new_role)\n\t * pair.\n\t */\n\tif (tclass == policydb.process_class &&\n\t    (avd->allowed & policydb.process_trans_perms) &&\n\t    scontext->role != tcontext->role) {\n\t\tfor (ra = policydb.role_allow; ra; ra = ra->next) {\n\t\t\tif (scontext->role == ra->role &&\n\t\t\t    tcontext->role == ra->new_role)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!ra)\n\t\t\tavd->allowed &= ~policydb.process_trans_perms;\n\t}\n\n\t/*\n\t * If the given source and target types have boundary\n\t * constraint, lazy checks have to mask any violated\n\t * permission and notice it to userspace via audit.\n\t */\n\ttype_attribute_bounds_av(scontext, tcontext,\n\t\t\t\t tclass, avd);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;",
            "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);\n\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms)\n{\n\tstruct constraint_node *constraint;\n\tstruct role_allow *ra;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct class_datum *tclass_datum;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tif (xperms) {\n\t\tmemset(&xperms->drivers, 0, sizeof(xperms->drivers));\n\t\txperms->len = 0;\n\t}\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"SELinux:  Invalid class %hu\\n\", tclass);\n\t\treturn;\n\t}\n\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\t/*\n\t * If a specific type enforcement rule was defined for\n\t * this permission check, then use it.\n\t */\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_AV | AVTAB_XPERMS;\n\tsattr = flex_array_get(policydb.type_attr_map_array, scontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array, tcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified)) {\n\t\t\t\tif (node->key.specified == AVTAB_ALLOWED)\n\t\t\t\t\tavd->allowed |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITALLOW)\n\t\t\t\t\tavd->auditallow |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITDENY)\n\t\t\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\t\t\telse if (xperms && (node->key.specified & AVTAB_XPERMS))\n\t\t\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t\t\t}\n\n\t\t\t/* Check conditional av table for additional permissions */\n\t\t\tcond_compute_av(&policydb.te_cond_avtab, &avkey,\n\t\t\t\t\tavd, xperms);\n\n\t\t}\n\t}\n\n\t/*\n\t * Remove any permissions prohibited by a constraint (this includes\n\t * the MLS policy).\n\t */\n\tconstraint = tclass_datum->constraints;\n\twhile (constraint) {\n\t\tif ((constraint->permissions & (avd->allowed)) &&\n\t\t    !constraint_expr_eval(scontext, tcontext, NULL,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tavd->allowed &= ~(constraint->permissions);\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\n\t/*\n\t * If checking process transition permission and the\n\t * role is changing, then check the (current_role, new_role)\n\t * pair.\n\t */\n\tif (tclass == policydb.process_class &&\n\t    (avd->allowed & policydb.process_trans_perms) &&\n\t    scontext->role != tcontext->role) {\n\t\tfor (ra = policydb.role_allow; ra; ra = ra->next) {\n\t\t\tif (scontext->role == ra->role &&\n\t\t\t    tcontext->role == ra->new_role)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!ra)\n\t\t\tavd->allowed &= ~policydb.process_trans_perms;\n\t}\n\n\t/*\n\t * If the given source and target types have boundary\n\t * constraint, lazy checks have to mask any violated\n\t * permission and notice it to userspace via audit.\n\t */\n\ttype_attribute_bounds_av(scontext, tcontext,\n\t\t\t\t tclass, avd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "orig_tclass && !tclass"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_class",
          "args": [
            "orig_tclass"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "209-215",
          "snippet": "static u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct selinux_mapping *current_mapping;",
            "static u16 current_mapping_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nstatic u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "tsid"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "&sidtab",
            "tsid"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_get_bit",
          "args": [
            "&policydb.permissive_map",
            "scontext->type"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_get_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "242-257",
          "snippet": "int ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "ssid"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avd_init",
          "args": [
            "avd"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "avd_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "937-944",
          "snippet": "static void avd_init(struct av_decision *avd)\n{\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tavd->seqno = latest_granting;\n\tavd->flags = 0;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 latest_granting;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic u32 latest_granting;\n\nstatic void avd_init(struct av_decision *avd)\n{\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tavd->seqno = latest_granting;\n\tavd->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);\n\nvoid security_compute_av(u32 ssid,\n\t\t\t u32 tsid,\n\t\t\t u16 orig_tclass,\n\t\t\t struct av_decision *avd,\n\t\t\t struct extended_perms *xperms)\n{\n\tu16 tclass;\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\tread_lock(&policy_rwlock);\n\tavd_init(avd);\n\txperms->len = 0;\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t/* permissive domain? */\n\tif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\ttclass = unmap_class(orig_tclass);\n\tif (unlikely(orig_tclass && !tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\tcontext_struct_compute_av(scontext, tcontext, tclass, avd, xperms);\n\tmap_decision(orig_tclass, avd, policydb.allow_unknown);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}"
  },
  {
    "function_name": "security_compute_xperms_decision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "1000-1078",
    "snippet": "void security_compute_xperms_decision(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu8 driver,\n\t\t\t\tstruct extended_perms_decision *xpermd)\n{\n\tu16 tclass;\n\tstruct context *scontext, *tcontext;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\txpermd->driver = driver;\n\txpermd->used = 0;\n\tmemset(xpermd->allowed->p, 0, sizeof(xpermd->allowed->p));\n\tmemset(xpermd->auditallow->p, 0, sizeof(xpermd->auditallow->p));\n\tmemset(xpermd->dontaudit->p, 0, sizeof(xpermd->dontaudit->p));\n\n\tread_lock(&policy_rwlock);\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\ttclass = unmap_class(orig_tclass);\n\tif (unlikely(orig_tclass && !tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tpr_warn_ratelimited(\"SELinux:  Invalid class %hu\\n\", tclass);\n\t\tgoto out;\n\t}\n\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_XPERMS;\n\tsattr = flex_array_get(policydb.type_attr_map_array,\n\t\t\t\tscontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array,\n\t\t\t\ttcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified))\n\t\t\t\tservices_compute_xperms_decision(xpermd, node);\n\n\t\t\tcond_compute_xperms(&policydb.te_cond_avtab,\n\t\t\t\t\t\t&avkey, xpermd);\n\t\t}\n\t}\nout:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tmemset(xpermd->allowed->p, 0xff, sizeof(xpermd->allowed->p));\n\tgoto out;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;",
      "int ss_initialized;",
      "static int security_preserve_bools(struct policydb *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xpermd->allowed->p",
            "0xff",
            "sizeof(xpermd->allowed->p)"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_compute_xperms",
          "args": [
            "&policydb.te_cond_avtab",
            "&avkey",
            "xpermd"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "cond_compute_xperms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "619-634",
          "snippet": "void cond_compute_xperms(struct avtab *ctab, struct avtab_key *key,\n\t\tstruct extended_perms_decision *xpermd)\n{\n\tstruct avtab_node *node;\n\n\tif (!ctab || !key || !xpermd)\n\t\treturn;\n\n\tfor (node = avtab_search_node(ctab, key); node;\n\t\t\tnode = avtab_search_node_next(node, key->specified)) {\n\t\tif (node->key.specified & AVTAB_ENABLED)\n\t\t\tservices_compute_xperms_decision(xpermd, node);\n\t}\n\treturn;\n\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nvoid cond_compute_xperms(struct avtab *ctab, struct avtab_key *key,\n\t\tstruct extended_perms_decision *xpermd)\n{\n\tstruct avtab_node *node;\n\n\tif (!ctab || !key || !xpermd)\n\t\treturn;\n\n\tfor (node = avtab_search_node(ctab, key); node;\n\t\t\tnode = avtab_search_node_next(node, key->specified)) {\n\t\tif (node->key.specified & AVTAB_ENABLED)\n\t\t\tservices_compute_xperms_decision(xpermd, node);\n\t}\n\treturn;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "services_compute_xperms_decision",
          "args": [
            "xpermd",
            "node"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "services_compute_xperms_decision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "946-998",
          "snippet": "void services_compute_xperms_decision(struct extended_perms_decision *xpermd,\n\t\t\t\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\tif (xpermd->driver != node->datum.u.xperms->driver)\n\t\t\treturn;\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\tif (!security_xperm_test(node->datum.u.xperms->perms.p,\n\t\t\t\t\txpermd->driver))\n\t\t\treturn;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (node->key.specified == AVTAB_XPERMS_ALLOWED) {\n\t\txpermd->used |= XPERMS_ALLOWED;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->allowed->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->allowed->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->allowed->p); i++)\n\t\t\t\txpermd->allowed->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_AUDITALLOW) {\n\t\txpermd->used |= XPERMS_AUDITALLOW;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->auditallow->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->auditallow->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->auditallow->p); i++)\n\t\t\t\txpermd->auditallow->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_DONTAUDIT) {\n\t\txpermd->used |= XPERMS_DONTAUDIT;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->dontaudit->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->dontaudit->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->dontaudit->p); i++)\n\t\t\t\txpermd->dontaudit->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else {\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);",
            "static int security_preserve_bools(struct policydb *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);\nstatic int security_preserve_bools(struct policydb *p);\n\nvoid services_compute_xperms_decision(struct extended_perms_decision *xpermd,\n\t\t\t\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\tif (xpermd->driver != node->datum.u.xperms->driver)\n\t\t\treturn;\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\tif (!security_xperm_test(node->datum.u.xperms->perms.p,\n\t\t\t\t\txpermd->driver))\n\t\t\treturn;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (node->key.specified == AVTAB_XPERMS_ALLOWED) {\n\t\txpermd->used |= XPERMS_ALLOWED;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->allowed->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->allowed->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->allowed->p); i++)\n\t\t\t\txpermd->allowed->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_AUDITALLOW) {\n\t\txpermd->used |= XPERMS_AUDITALLOW;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->auditallow->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->auditallow->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->auditallow->p); i++)\n\t\t\t\txpermd->auditallow->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_DONTAUDIT) {\n\t\txpermd->used |= XPERMS_DONTAUDIT;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->dontaudit->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->dontaudit->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->dontaudit->p); i++)\n\t\t\t\txpermd->dontaudit->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else {\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "avtab_search_node_next",
          "args": [
            "node",
            "avkey.specified"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_search_node_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "250-277",
          "snippet": "struct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "tattr",
            "tnode",
            "j"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "sattr",
            "snode",
            "i"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tattr"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get",
          "args": [
            "policydb.type_attr_map_array",
            "tcontext->type - 1"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!sattr"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get",
          "args": [
            "policydb.type_attr_map_array",
            "scontext->type - 1"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"SELinux:  Invalid class %hu\\n\"",
            "tclass"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tclass || tclass > policydb.p_classes.nprim"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "orig_tclass && !tclass"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_class",
          "args": [
            "orig_tclass"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "209-215",
          "snippet": "static u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct selinux_mapping *current_mapping;",
            "static u16 current_mapping_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nstatic u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "tsid"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "&sidtab",
            "tsid"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "ssid"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xpermd->dontaudit->p",
            "0",
            "sizeof(xpermd->dontaudit->p)"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xpermd->auditallow->p",
            "0",
            "sizeof(xpermd->auditallow->p)"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xpermd->allowed->p",
            "0",
            "sizeof(xpermd->allowed->p)"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\nstatic int security_preserve_bools(struct policydb *p);\n\nvoid security_compute_xperms_decision(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu8 driver,\n\t\t\t\tstruct extended_perms_decision *xpermd)\n{\n\tu16 tclass;\n\tstruct context *scontext, *tcontext;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\txpermd->driver = driver;\n\txpermd->used = 0;\n\tmemset(xpermd->allowed->p, 0, sizeof(xpermd->allowed->p));\n\tmemset(xpermd->auditallow->p, 0, sizeof(xpermd->auditallow->p));\n\tmemset(xpermd->dontaudit->p, 0, sizeof(xpermd->dontaudit->p));\n\n\tread_lock(&policy_rwlock);\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\ttclass = unmap_class(orig_tclass);\n\tif (unlikely(orig_tclass && !tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tpr_warn_ratelimited(\"SELinux:  Invalid class %hu\\n\", tclass);\n\t\tgoto out;\n\t}\n\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_XPERMS;\n\tsattr = flex_array_get(policydb.type_attr_map_array,\n\t\t\t\tscontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array,\n\t\t\t\ttcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified))\n\t\t\t\tservices_compute_xperms_decision(xpermd, node);\n\n\t\t\tcond_compute_xperms(&policydb.te_cond_avtab,\n\t\t\t\t\t\t&avkey, xpermd);\n\t\t}\n\t}\nout:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tmemset(xpermd->allowed->p, 0xff, sizeof(xpermd->allowed->p));\n\tgoto out;\n}"
  },
  {
    "function_name": "services_compute_xperms_decision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "946-998",
    "snippet": "void services_compute_xperms_decision(struct extended_perms_decision *xpermd,\n\t\t\t\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\tif (xpermd->driver != node->datum.u.xperms->driver)\n\t\t\treturn;\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\tif (!security_xperm_test(node->datum.u.xperms->perms.p,\n\t\t\t\t\txpermd->driver))\n\t\t\treturn;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (node->key.specified == AVTAB_XPERMS_ALLOWED) {\n\t\txpermd->used |= XPERMS_ALLOWED;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->allowed->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->allowed->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->allowed->p); i++)\n\t\t\t\txpermd->allowed->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_AUDITALLOW) {\n\t\txpermd->used |= XPERMS_AUDITALLOW;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->auditallow->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->auditallow->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->auditallow->p); i++)\n\t\t\t\txpermd->auditallow->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_DONTAUDIT) {\n\t\txpermd->used |= XPERMS_DONTAUDIT;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->dontaudit->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->dontaudit->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->dontaudit->p); i++)\n\t\t\t\txpermd->dontaudit->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else {\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);",
      "static int security_preserve_bools(struct policydb *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "xpermd->dontaudit->p"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xpermd->dontaudit->p",
            "0xff",
            "sizeof(xpermd->dontaudit->p)"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "xpermd->auditallow->p"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xpermd->auditallow->p",
            "0xff",
            "sizeof(xpermd->auditallow->p)"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "xpermd->allowed->p"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xpermd->allowed->p",
            "0xff",
            "sizeof(xpermd->allowed->p)"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_xperm_test",
          "args": [
            "node->datum.u.xperms->perms.p",
            "xpermd->driver"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);\nstatic int security_preserve_bools(struct policydb *p);\n\nvoid services_compute_xperms_decision(struct extended_perms_decision *xpermd,\n\t\t\t\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\tif (xpermd->driver != node->datum.u.xperms->driver)\n\t\t\treturn;\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\tif (!security_xperm_test(node->datum.u.xperms->perms.p,\n\t\t\t\t\txpermd->driver))\n\t\t\treturn;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (node->key.specified == AVTAB_XPERMS_ALLOWED) {\n\t\txpermd->used |= XPERMS_ALLOWED;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->allowed->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->allowed->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->allowed->p); i++)\n\t\t\t\txpermd->allowed->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_AUDITALLOW) {\n\t\txpermd->used |= XPERMS_AUDITALLOW;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->auditallow->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->auditallow->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->auditallow->p); i++)\n\t\t\t\txpermd->auditallow->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else if (node->key.specified == AVTAB_XPERMS_DONTAUDIT) {\n\t\txpermd->used |= XPERMS_DONTAUDIT;\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t\tmemset(xpermd->dontaudit->p, 0xff,\n\t\t\t\t\tsizeof(xpermd->dontaudit->p));\n\t\t}\n\t\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(xpermd->dontaudit->p); i++)\n\t\t\t\txpermd->dontaudit->p[i] |=\n\t\t\t\t\tnode->datum.u.xperms->perms.p[i];\n\t\t}\n\t} else {\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "avd_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "937-944",
    "snippet": "static void avd_init(struct av_decision *avd)\n{\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tavd->seqno = latest_granting;\n\tavd->flags = 0;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 latest_granting;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic u32 latest_granting;\n\nstatic void avd_init(struct av_decision *avd)\n{\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tavd->seqno = latest_granting;\n\tavd->flags = 0;\n}"
  },
  {
    "function_name": "security_bounded_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "863-935",
    "snippet": "int security_bounded_transition(u32 old_sid, u32 new_sid)\n{\n\tstruct context *old_context, *new_context;\n\tstruct type_datum *type;\n\tint index;\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\told_context = sidtab_search(&sidtab, old_sid);\n\tif (!old_context) {\n\t\tprintk(KERN_ERR \"SELinux: %s: unrecognized SID %u\\n\",\n\t\t       __func__, old_sid);\n\t\tgoto out;\n\t}\n\n\trc = -EINVAL;\n\tnew_context = sidtab_search(&sidtab, new_sid);\n\tif (!new_context) {\n\t\tprintk(KERN_ERR \"SELinux: %s: unrecognized SID %u\\n\",\n\t\t       __func__, new_sid);\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\t/* type/domain unchanged */\n\tif (old_context->type == new_context->type)\n\t\tgoto out;\n\n\tindex = new_context->type;\n\twhile (true) {\n\t\ttype = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t\t  index - 1);\n\t\tBUG_ON(!type);\n\n\t\t/* not bounded anymore */\n\t\trc = -EPERM;\n\t\tif (!type->bounds)\n\t\t\tbreak;\n\n\t\t/* @newsid is bounded by @oldsid */\n\t\trc = 0;\n\t\tif (type->bounds == old_context->type)\n\t\t\tbreak;\n\n\t\tindex = type->bounds;\n\t}\n\n\tif (rc) {\n\t\tchar *old_name = NULL;\n\t\tchar *new_name = NULL;\n\t\tu32 length;\n\n\t\tif (!context_struct_to_string(old_context,\n\t\t\t\t\t      &old_name, &length) &&\n\t\t    !context_struct_to_string(new_context,\n\t\t\t\t\t      &new_name, &length)) {\n\t\t\taudit_log(current->audit_context,\n\t\t\t\t  GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t\t  \"op=security_bounded_transition \"\n\t\t\t\t  \"seresult=denied \"\n\t\t\t\t  \"oldcontext=%s newcontext=%s\",\n\t\t\t\t  old_name, new_name);\n\t\t}\n\t\tkfree(new_name);\n\t\tkfree(old_name);\n\t}\nout:\n\tread_unlock(&policy_rwlock);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "old_name"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_name"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "current->audit_context",
            "GFP_ATOMIC",
            "AUDIT_SELINUX_ERR",
            "\"op=security_bounded_transition \"\n\t\t\t\t  \"seresult=denied \"\n\t\t\t\t  \"oldcontext=%s newcontext=%s\"",
            "old_name",
            "new_name"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_struct_to_string",
          "args": [
            "new_context",
            "&new_name",
            "&length"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "context_struct_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1192-1238",
          "snippet": "static int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!type"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get_ptr",
          "args": [
            "policydb.type_val_to_struct_array",
            "index - 1"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s: unrecognized SID %u\\n\"",
            "__func__",
            "new_sid"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "&sidtab",
            "new_sid"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s: unrecognized SID %u\\n\"",
            "__func__",
            "old_sid"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\n\nint security_bounded_transition(u32 old_sid, u32 new_sid)\n{\n\tstruct context *old_context, *new_context;\n\tstruct type_datum *type;\n\tint index;\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\told_context = sidtab_search(&sidtab, old_sid);\n\tif (!old_context) {\n\t\tprintk(KERN_ERR \"SELinux: %s: unrecognized SID %u\\n\",\n\t\t       __func__, old_sid);\n\t\tgoto out;\n\t}\n\n\trc = -EINVAL;\n\tnew_context = sidtab_search(&sidtab, new_sid);\n\tif (!new_context) {\n\t\tprintk(KERN_ERR \"SELinux: %s: unrecognized SID %u\\n\",\n\t\t       __func__, new_sid);\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\t/* type/domain unchanged */\n\tif (old_context->type == new_context->type)\n\t\tgoto out;\n\n\tindex = new_context->type;\n\twhile (true) {\n\t\ttype = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t\t  index - 1);\n\t\tBUG_ON(!type);\n\n\t\t/* not bounded anymore */\n\t\trc = -EPERM;\n\t\tif (!type->bounds)\n\t\t\tbreak;\n\n\t\t/* @newsid is bounded by @oldsid */\n\t\trc = 0;\n\t\tif (type->bounds == old_context->type)\n\t\t\tbreak;\n\n\t\tindex = type->bounds;\n\t}\n\n\tif (rc) {\n\t\tchar *old_name = NULL;\n\t\tchar *new_name = NULL;\n\t\tu32 length;\n\n\t\tif (!context_struct_to_string(old_context,\n\t\t\t\t\t      &old_name, &length) &&\n\t\t    !context_struct_to_string(new_context,\n\t\t\t\t\t      &new_name, &length)) {\n\t\t\taudit_log(current->audit_context,\n\t\t\t\t  GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t\t  \"op=security_bounded_transition \"\n\t\t\t\t  \"seresult=denied \"\n\t\t\t\t  \"oldcontext=%s newcontext=%s\",\n\t\t\t\t  old_name, new_name);\n\t\t}\n\t\tkfree(new_name);\n\t\tkfree(old_name);\n\t}\nout:\n\tread_unlock(&policy_rwlock);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "security_validate_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "847-852",
    "snippet": "int security_validate_transition(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t u16 orig_tclass)\n{\n\treturn security_compute_validatetrans(oldsid, newsid, tasksid,\n\t\t\t\t\t\torig_tclass, false);\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_compute_validatetrans",
          "args": [
            "oldsid",
            "newsid",
            "tasksid",
            "orig_tclass",
            "false"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "security_compute_validatetrans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "768-838",
          "snippet": "static int security_compute_validatetrans(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t\t  u16 orig_tclass, bool user)\n{\n\tstruct context *ocontext;\n\tstruct context *ncontext;\n\tstruct context *tcontext;\n\tstruct class_datum *tclass_datum;\n\tstruct constraint_node *constraint;\n\tu16 tclass;\n\tint rc = 0;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\tif (!user)\n\t\ttclass = unmap_class(orig_tclass);\n\telse\n\t\ttclass = orig_tclass;\n\n\tif (!tclass || tclass > policydb.p_classes.nprim) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\tocontext = sidtab_search(&sidtab, oldsid);\n\tif (!ocontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, oldsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tncontext = sidtab_search(&sidtab, newsid);\n\tif (!ncontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, newsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttcontext = sidtab_search(&sidtab, tasksid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, tasksid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tconstraint = tclass_datum->validatetrans;\n\twhile (constraint) {\n\t\tif (!constraint_expr_eval(ocontext, ncontext, tcontext,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tif (user)\n\t\t\t\trc = -EPERM;\n\t\t\telse\n\t\t\t\trc = security_validtrans_handle_fail(ocontext,\n\t\t\t\t\t\t\t\t     ncontext,\n\t\t\t\t\t\t\t\t     tcontext,\n\t\t\t\t\t\t\t\t     tclass);\n\t\t\tgoto out;\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nstatic int security_compute_validatetrans(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t\t  u16 orig_tclass, bool user)\n{\n\tstruct context *ocontext;\n\tstruct context *ncontext;\n\tstruct context *tcontext;\n\tstruct class_datum *tclass_datum;\n\tstruct constraint_node *constraint;\n\tu16 tclass;\n\tint rc = 0;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\tif (!user)\n\t\ttclass = unmap_class(orig_tclass);\n\telse\n\t\ttclass = orig_tclass;\n\n\tif (!tclass || tclass > policydb.p_classes.nprim) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\tocontext = sidtab_search(&sidtab, oldsid);\n\tif (!ocontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, oldsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tncontext = sidtab_search(&sidtab, newsid);\n\tif (!ncontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, newsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttcontext = sidtab_search(&sidtab, tasksid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, tasksid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tconstraint = tclass_datum->validatetrans;\n\twhile (constraint) {\n\t\tif (!constraint_expr_eval(ocontext, ncontext, tcontext,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tif (user)\n\t\t\t\trc = -EPERM;\n\t\t\telse\n\t\t\t\trc = security_validtrans_handle_fail(ocontext,\n\t\t\t\t\t\t\t\t     ncontext,\n\t\t\t\t\t\t\t\t     tcontext,\n\t\t\t\t\t\t\t\t     tclass);\n\t\t\tgoto out;\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_validate_transition(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t u16 orig_tclass)\n{\n\treturn security_compute_validatetrans(oldsid, newsid, tasksid,\n\t\t\t\t\t\torig_tclass, false);\n}"
  },
  {
    "function_name": "security_validate_transition_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "840-845",
    "snippet": "int security_validate_transition_user(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t\tu16 tclass)\n{\n\treturn security_compute_validatetrans(oldsid, newsid, tasksid,\n\t\t\t\t\t\ttclass, true);\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_compute_validatetrans",
          "args": [
            "oldsid",
            "newsid",
            "tasksid",
            "tclass",
            "true"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "security_compute_validatetrans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "768-838",
          "snippet": "static int security_compute_validatetrans(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t\t  u16 orig_tclass, bool user)\n{\n\tstruct context *ocontext;\n\tstruct context *ncontext;\n\tstruct context *tcontext;\n\tstruct class_datum *tclass_datum;\n\tstruct constraint_node *constraint;\n\tu16 tclass;\n\tint rc = 0;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\tif (!user)\n\t\ttclass = unmap_class(orig_tclass);\n\telse\n\t\ttclass = orig_tclass;\n\n\tif (!tclass || tclass > policydb.p_classes.nprim) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\tocontext = sidtab_search(&sidtab, oldsid);\n\tif (!ocontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, oldsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tncontext = sidtab_search(&sidtab, newsid);\n\tif (!ncontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, newsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttcontext = sidtab_search(&sidtab, tasksid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, tasksid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tconstraint = tclass_datum->validatetrans;\n\twhile (constraint) {\n\t\tif (!constraint_expr_eval(ocontext, ncontext, tcontext,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tif (user)\n\t\t\t\trc = -EPERM;\n\t\t\telse\n\t\t\t\trc = security_validtrans_handle_fail(ocontext,\n\t\t\t\t\t\t\t\t     ncontext,\n\t\t\t\t\t\t\t\t     tcontext,\n\t\t\t\t\t\t\t\t     tclass);\n\t\t\tgoto out;\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nstatic int security_compute_validatetrans(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t\t  u16 orig_tclass, bool user)\n{\n\tstruct context *ocontext;\n\tstruct context *ncontext;\n\tstruct context *tcontext;\n\tstruct class_datum *tclass_datum;\n\tstruct constraint_node *constraint;\n\tu16 tclass;\n\tint rc = 0;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\tif (!user)\n\t\ttclass = unmap_class(orig_tclass);\n\telse\n\t\ttclass = orig_tclass;\n\n\tif (!tclass || tclass > policydb.p_classes.nprim) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\tocontext = sidtab_search(&sidtab, oldsid);\n\tif (!ocontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, oldsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tncontext = sidtab_search(&sidtab, newsid);\n\tif (!ncontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, newsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttcontext = sidtab_search(&sidtab, tasksid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, tasksid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tconstraint = tclass_datum->validatetrans;\n\twhile (constraint) {\n\t\tif (!constraint_expr_eval(ocontext, ncontext, tcontext,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tif (user)\n\t\t\t\trc = -EPERM;\n\t\t\telse\n\t\t\t\trc = security_validtrans_handle_fail(ocontext,\n\t\t\t\t\t\t\t\t     ncontext,\n\t\t\t\t\t\t\t\t     tcontext,\n\t\t\t\t\t\t\t\t     tclass);\n\t\t\tgoto out;\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint security_validate_transition_user(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t\tu16 tclass)\n{\n\treturn security_compute_validatetrans(oldsid, newsid, tasksid,\n\t\t\t\t\t\ttclass, true);\n}"
  },
  {
    "function_name": "security_compute_validatetrans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "768-838",
    "snippet": "static int security_compute_validatetrans(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t\t  u16 orig_tclass, bool user)\n{\n\tstruct context *ocontext;\n\tstruct context *ncontext;\n\tstruct context *tcontext;\n\tstruct class_datum *tclass_datum;\n\tstruct constraint_node *constraint;\n\tu16 tclass;\n\tint rc = 0;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\tif (!user)\n\t\ttclass = unmap_class(orig_tclass);\n\telse\n\t\ttclass = orig_tclass;\n\n\tif (!tclass || tclass > policydb.p_classes.nprim) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\tocontext = sidtab_search(&sidtab, oldsid);\n\tif (!ocontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, oldsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tncontext = sidtab_search(&sidtab, newsid);\n\tif (!ncontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, newsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttcontext = sidtab_search(&sidtab, tasksid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, tasksid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tconstraint = tclass_datum->validatetrans;\n\twhile (constraint) {\n\t\tif (!constraint_expr_eval(ocontext, ncontext, tcontext,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tif (user)\n\t\t\t\trc = -EPERM;\n\t\t\telse\n\t\t\t\trc = security_validtrans_handle_fail(ocontext,\n\t\t\t\t\t\t\t\t     ncontext,\n\t\t\t\t\t\t\t\t     tcontext,\n\t\t\t\t\t\t\t\t     tclass);\n\t\t\tgoto out;\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(policy_rwlock);",
      "static struct sidtab sidtab;",
      "struct policydb policydb;",
      "int ss_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_validtrans_handle_fail",
          "args": [
            "ocontext",
            "ncontext",
            "tcontext",
            "tclass"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "security_validtrans_handle_fail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "740-766",
          "snippet": "static int security_validtrans_handle_fail(struct context *ocontext,\n\t\t\t\t\t   struct context *ncontext,\n\t\t\t\t\t   struct context *tcontext,\n\t\t\t\t\t   u16 tclass)\n{\n\tchar *o = NULL, *n = NULL, *t = NULL;\n\tu32 olen, nlen, tlen;\n\n\tif (context_struct_to_string(ocontext, &o, &olen))\n\t\tgoto out;\n\tif (context_struct_to_string(ncontext, &n, &nlen))\n\t\tgoto out;\n\tif (context_struct_to_string(tcontext, &t, &tlen))\n\t\tgoto out;\n\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t  \"op=security_validate_transition seresult=denied\"\n\t\t  \" oldcontext=%s newcontext=%s taskcontext=%s tclass=%s\",\n\t\t  o, n, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\nout:\n\tkfree(o);\n\tkfree(n);\n\tkfree(t);\n\n\tif (!selinux_enforcing)\n\t\treturn 0;\n\treturn -EPERM;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nstatic int security_validtrans_handle_fail(struct context *ocontext,\n\t\t\t\t\t   struct context *ncontext,\n\t\t\t\t\t   struct context *tcontext,\n\t\t\t\t\t   u16 tclass)\n{\n\tchar *o = NULL, *n = NULL, *t = NULL;\n\tu32 olen, nlen, tlen;\n\n\tif (context_struct_to_string(ocontext, &o, &olen))\n\t\tgoto out;\n\tif (context_struct_to_string(ncontext, &n, &nlen))\n\t\tgoto out;\n\tif (context_struct_to_string(tcontext, &t, &tlen))\n\t\tgoto out;\n\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t  \"op=security_validate_transition seresult=denied\"\n\t\t  \" oldcontext=%s newcontext=%s taskcontext=%s tclass=%s\",\n\t\t  o, n, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\nout:\n\tkfree(o);\n\tkfree(n);\n\tkfree(t);\n\n\tif (!selinux_enforcing)\n\t\treturn 0;\n\treturn -EPERM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "constraint_expr_eval",
          "args": [
            "ocontext",
            "ncontext",
            "tcontext",
            "constraint->expr"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "constraint_expr_eval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "285-457",
          "snippet": "static int constraint_expr_eval(struct context *scontext,\n\t\t\t\tstruct context *tcontext,\n\t\t\t\tstruct context *xcontext,\n\t\t\t\tstruct constraint_expr *cexpr)\n{\n\tu32 val1, val2;\n\tstruct context *c;\n\tstruct role_datum *r1, *r2;\n\tstruct mls_level *l1, *l2;\n\tstruct constraint_expr *e;\n\tint s[CEXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tfor (e = cexpr; e; e = e->next) {\n\t\tswitch (e->expr_type) {\n\t\tcase CEXPR_NOT:\n\t\t\tBUG_ON(sp < 0);\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase CEXPR_AND:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_OR:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_ATTR:\n\t\t\tif (sp == (CEXPR_MAXDEPTH - 1))\n\t\t\t\treturn 0;\n\t\t\tswitch (e->attr) {\n\t\t\tcase CEXPR_USER:\n\t\t\t\tval1 = scontext->user;\n\t\t\t\tval2 = tcontext->user;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_TYPE:\n\t\t\t\tval1 = scontext->type;\n\t\t\t\tval2 = tcontext->type;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ROLE:\n\t\t\t\tval1 = scontext->role;\n\t\t\t\tval2 = tcontext->role;\n\t\t\t\tr1 = policydb.role_val_to_struct[val1 - 1];\n\t\t\t\tr2 = policydb.role_val_to_struct[val2 - 1];\n\t\t\t\tswitch (e->op) {\n\t\t\t\tcase CEXPR_DOM:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t  val2 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_DOMBY:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t  val1 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_INCOMP:\n\t\t\t\t\ts[++sp] = (!ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t    val2 - 1) &&\n\t\t\t\t\t\t   !ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t    val1 - 1));\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_L1L2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1L2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1H2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H1:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(scontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L2H2:\n\t\t\t\tl1 = &(tcontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\nmls_ops:\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOM:\n\t\t\t\ts[++sp] = mls_level_dom(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOMBY:\n\t\t\t\ts[++sp] = mls_level_dom(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_INCOMP:\n\t\t\t\ts[++sp] = mls_level_incomp(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = (val1 == val2);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = (val1 != val2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CEXPR_NAMES:\n\t\t\tif (sp == (CEXPR_MAXDEPTH-1))\n\t\t\t\treturn 0;\n\t\t\tc = scontext;\n\t\t\tif (e->attr & CEXPR_TARGET)\n\t\t\t\tc = tcontext;\n\t\t\telse if (e->attr & CEXPR_XTARGET) {\n\t\t\t\tc = xcontext;\n\t\t\t\tif (!c) {\n\t\t\t\t\tBUG();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e->attr & CEXPR_USER)\n\t\t\t\tval1 = c->user;\n\t\t\telse if (e->attr & CEXPR_ROLE)\n\t\t\t\tval1 = c->role;\n\t\t\telse if (e->attr & CEXPR_TYPE)\n\t\t\t\tval1 = c->type;\n\t\t\telse {\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tBUG_ON(sp != 0);\n\treturn s[0];\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nstatic int constraint_expr_eval(struct context *scontext,\n\t\t\t\tstruct context *tcontext,\n\t\t\t\tstruct context *xcontext,\n\t\t\t\tstruct constraint_expr *cexpr)\n{\n\tu32 val1, val2;\n\tstruct context *c;\n\tstruct role_datum *r1, *r2;\n\tstruct mls_level *l1, *l2;\n\tstruct constraint_expr *e;\n\tint s[CEXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tfor (e = cexpr; e; e = e->next) {\n\t\tswitch (e->expr_type) {\n\t\tcase CEXPR_NOT:\n\t\t\tBUG_ON(sp < 0);\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase CEXPR_AND:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_OR:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_ATTR:\n\t\t\tif (sp == (CEXPR_MAXDEPTH - 1))\n\t\t\t\treturn 0;\n\t\t\tswitch (e->attr) {\n\t\t\tcase CEXPR_USER:\n\t\t\t\tval1 = scontext->user;\n\t\t\t\tval2 = tcontext->user;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_TYPE:\n\t\t\t\tval1 = scontext->type;\n\t\t\t\tval2 = tcontext->type;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ROLE:\n\t\t\t\tval1 = scontext->role;\n\t\t\t\tval2 = tcontext->role;\n\t\t\t\tr1 = policydb.role_val_to_struct[val1 - 1];\n\t\t\t\tr2 = policydb.role_val_to_struct[val2 - 1];\n\t\t\t\tswitch (e->op) {\n\t\t\t\tcase CEXPR_DOM:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t  val2 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_DOMBY:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t  val1 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_INCOMP:\n\t\t\t\t\ts[++sp] = (!ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t    val2 - 1) &&\n\t\t\t\t\t\t   !ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t    val1 - 1));\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_L1L2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1L2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1H2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H1:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(scontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L2H2:\n\t\t\t\tl1 = &(tcontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\nmls_ops:\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOM:\n\t\t\t\ts[++sp] = mls_level_dom(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOMBY:\n\t\t\t\ts[++sp] = mls_level_dom(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_INCOMP:\n\t\t\t\ts[++sp] = mls_level_incomp(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = (val1 == val2);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = (val1 != val2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CEXPR_NAMES:\n\t\t\tif (sp == (CEXPR_MAXDEPTH-1))\n\t\t\t\treturn 0;\n\t\t\tc = scontext;\n\t\t\tif (e->attr & CEXPR_TARGET)\n\t\t\t\tc = tcontext;\n\t\t\telse if (e->attr & CEXPR_XTARGET) {\n\t\t\t\tc = xcontext;\n\t\t\t\tif (!c) {\n\t\t\t\t\tBUG();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e->attr & CEXPR_USER)\n\t\t\t\tval1 = c->user;\n\t\t\telse if (e->attr & CEXPR_ROLE)\n\t\t\t\tval1 = c->role;\n\t\t\telse if (e->attr & CEXPR_TYPE)\n\t\t\t\tval1 = c->type;\n\t\t\telse {\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tBUG_ON(sp != 0);\n\treturn s[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "tasksid"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "&sidtab",
            "tasksid"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "newsid"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\"",
            "__func__",
            "oldsid"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_class",
          "args": [
            "orig_tclass"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "209-215",
          "snippet": "static u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct selinux_mapping *current_mapping;",
            "static u16 current_mapping_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nstatic u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&policy_rwlock"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nstatic int security_compute_validatetrans(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t\t  u16 orig_tclass, bool user)\n{\n\tstruct context *ocontext;\n\tstruct context *ncontext;\n\tstruct context *tcontext;\n\tstruct class_datum *tclass_datum;\n\tstruct constraint_node *constraint;\n\tu16 tclass;\n\tint rc = 0;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\tif (!user)\n\t\ttclass = unmap_class(orig_tclass);\n\telse\n\t\ttclass = orig_tclass;\n\n\tif (!tclass || tclass > policydb.p_classes.nprim) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\tocontext = sidtab_search(&sidtab, oldsid);\n\tif (!ocontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, oldsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tncontext = sidtab_search(&sidtab, newsid);\n\tif (!ncontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, newsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttcontext = sidtab_search(&sidtab, tasksid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, tasksid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tconstraint = tclass_datum->validatetrans;\n\twhile (constraint) {\n\t\tif (!constraint_expr_eval(ocontext, ncontext, tcontext,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tif (user)\n\t\t\t\trc = -EPERM;\n\t\t\telse\n\t\t\t\trc = security_validtrans_handle_fail(ocontext,\n\t\t\t\t\t\t\t\t     ncontext,\n\t\t\t\t\t\t\t\t     tcontext,\n\t\t\t\t\t\t\t\t     tclass);\n\t\t\tgoto out;\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
  },
  {
    "function_name": "security_validtrans_handle_fail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "740-766",
    "snippet": "static int security_validtrans_handle_fail(struct context *ocontext,\n\t\t\t\t\t   struct context *ncontext,\n\t\t\t\t\t   struct context *tcontext,\n\t\t\t\t\t   u16 tclass)\n{\n\tchar *o = NULL, *n = NULL, *t = NULL;\n\tu32 olen, nlen, tlen;\n\n\tif (context_struct_to_string(ocontext, &o, &olen))\n\t\tgoto out;\n\tif (context_struct_to_string(ncontext, &n, &nlen))\n\t\tgoto out;\n\tif (context_struct_to_string(tcontext, &t, &tlen))\n\t\tgoto out;\n\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t  \"op=security_validate_transition seresult=denied\"\n\t\t  \" oldcontext=%s newcontext=%s taskcontext=%s tclass=%s\",\n\t\t  o, n, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\nout:\n\tkfree(o);\n\tkfree(n);\n\tkfree(t);\n\n\tif (!selinux_enforcing)\n\t\treturn 0;\n\treturn -EPERM;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "t"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "n"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "o"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "current->audit_context",
            "GFP_ATOMIC",
            "AUDIT_SELINUX_ERR",
            "\"op=security_validate_transition seresult=denied\"\n\t\t  \" oldcontext=%s newcontext=%s taskcontext=%s tclass=%s\"",
            "o",
            "n",
            "t",
            "sym_name(&policydb, SYM_CLASSES, tclass-1)"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "&policydb",
            "SYM_CLASSES",
            "tclass-1"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context_struct_to_string",
          "args": [
            "tcontext",
            "&t",
            "&tlen"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "context_struct_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1192-1238",
          "snippet": "static int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nstatic int security_validtrans_handle_fail(struct context *ocontext,\n\t\t\t\t\t   struct context *ncontext,\n\t\t\t\t\t   struct context *tcontext,\n\t\t\t\t\t   u16 tclass)\n{\n\tchar *o = NULL, *n = NULL, *t = NULL;\n\tu32 olen, nlen, tlen;\n\n\tif (context_struct_to_string(ocontext, &o, &olen))\n\t\tgoto out;\n\tif (context_struct_to_string(ncontext, &n, &nlen))\n\t\tgoto out;\n\tif (context_struct_to_string(tcontext, &t, &tlen))\n\t\tgoto out;\n\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t  \"op=security_validate_transition seresult=denied\"\n\t\t  \" oldcontext=%s newcontext=%s taskcontext=%s tclass=%s\",\n\t\t  o, n, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\nout:\n\tkfree(o);\n\tkfree(n);\n\tkfree(t);\n\n\tif (!selinux_enforcing)\n\t\treturn 0;\n\treturn -EPERM;\n}"
  },
  {
    "function_name": "context_struct_compute_av",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "635-738",
    "snippet": "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms)\n{\n\tstruct constraint_node *constraint;\n\tstruct role_allow *ra;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct class_datum *tclass_datum;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tif (xperms) {\n\t\tmemset(&xperms->drivers, 0, sizeof(xperms->drivers));\n\t\txperms->len = 0;\n\t}\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"SELinux:  Invalid class %hu\\n\", tclass);\n\t\treturn;\n\t}\n\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\t/*\n\t * If a specific type enforcement rule was defined for\n\t * this permission check, then use it.\n\t */\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_AV | AVTAB_XPERMS;\n\tsattr = flex_array_get(policydb.type_attr_map_array, scontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array, tcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified)) {\n\t\t\t\tif (node->key.specified == AVTAB_ALLOWED)\n\t\t\t\t\tavd->allowed |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITALLOW)\n\t\t\t\t\tavd->auditallow |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITDENY)\n\t\t\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\t\t\telse if (xperms && (node->key.specified & AVTAB_XPERMS))\n\t\t\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t\t\t}\n\n\t\t\t/* Check conditional av table for additional permissions */\n\t\t\tcond_compute_av(&policydb.te_cond_avtab, &avkey,\n\t\t\t\t\tavd, xperms);\n\n\t\t}\n\t}\n\n\t/*\n\t * Remove any permissions prohibited by a constraint (this includes\n\t * the MLS policy).\n\t */\n\tconstraint = tclass_datum->constraints;\n\twhile (constraint) {\n\t\tif ((constraint->permissions & (avd->allowed)) &&\n\t\t    !constraint_expr_eval(scontext, tcontext, NULL,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tavd->allowed &= ~(constraint->permissions);\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\n\t/*\n\t * If checking process transition permission and the\n\t * role is changing, then check the (current_role, new_role)\n\t * pair.\n\t */\n\tif (tclass == policydb.process_class &&\n\t    (avd->allowed & policydb.process_trans_perms) &&\n\t    scontext->role != tcontext->role) {\n\t\tfor (ra = policydb.role_allow; ra; ra = ra->next) {\n\t\t\tif (scontext->role == ra->role &&\n\t\t\t    tcontext->role == ra->new_role)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!ra)\n\t\t\tavd->allowed &= ~policydb.process_trans_perms;\n\t}\n\n\t/*\n\t * If the given source and target types have boundary\n\t * constraint, lazy checks have to mask any violated\n\t * permission and notice it to userspace via audit.\n\t */\n\ttype_attribute_bounds_av(scontext, tcontext,\n\t\t\t\t tclass, avd);\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct policydb policydb;",
      "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "type_attribute_bounds_av",
          "args": [
            "scontext",
            "tcontext",
            "tclass",
            "avd"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "type_attribute_bounds_av",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "553-604",
          "snippet": "static void type_attribute_bounds_av(struct context *scontext,\n\t\t\t\t     struct context *tcontext,\n\t\t\t\t     u16 tclass,\n\t\t\t\t     struct av_decision *avd)\n{\n\tstruct context lo_scontext;\n\tstruct context lo_tcontext, *tcontextp = tcontext;\n\tstruct av_decision lo_avd;\n\tstruct type_datum *source;\n\tstruct type_datum *target;\n\tu32 masked = 0;\n\n\tsource = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t    scontext->type - 1);\n\tBUG_ON(!source);\n\n\tif (!source->bounds)\n\t\treturn;\n\n\ttarget = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t    tcontext->type - 1);\n\tBUG_ON(!target);\n\n\tmemset(&lo_avd, 0, sizeof(lo_avd));\n\n\tmemcpy(&lo_scontext, scontext, sizeof(lo_scontext));\n\tlo_scontext.type = source->bounds;\n\n\tif (target->bounds) {\n\t\tmemcpy(&lo_tcontext, tcontext, sizeof(lo_tcontext));\n\t\tlo_tcontext.type = target->bounds;\n\t\ttcontextp = &lo_tcontext;\n\t}\n\n\tcontext_struct_compute_av(&lo_scontext,\n\t\t\t\t  tcontextp,\n\t\t\t\t  tclass,\n\t\t\t\t  &lo_avd,\n\t\t\t\t  NULL);\n\n\tmasked = ~lo_avd.allowed & avd->allowed;\n\n\tif (likely(!masked))\n\t\treturn;\t\t/* no masked permission */\n\n\t/* mask violated permissions */\n\tavd->allowed &= ~masked;\n\n\t/* audit masked permissions */\n\tsecurity_dump_masked_av(scontext, tcontext,\n\t\t\t\ttclass, masked, \"bounds\");\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nstatic void type_attribute_bounds_av(struct context *scontext,\n\t\t\t\t     struct context *tcontext,\n\t\t\t\t     u16 tclass,\n\t\t\t\t     struct av_decision *avd)\n{\n\tstruct context lo_scontext;\n\tstruct context lo_tcontext, *tcontextp = tcontext;\n\tstruct av_decision lo_avd;\n\tstruct type_datum *source;\n\tstruct type_datum *target;\n\tu32 masked = 0;\n\n\tsource = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t    scontext->type - 1);\n\tBUG_ON(!source);\n\n\tif (!source->bounds)\n\t\treturn;\n\n\ttarget = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t    tcontext->type - 1);\n\tBUG_ON(!target);\n\n\tmemset(&lo_avd, 0, sizeof(lo_avd));\n\n\tmemcpy(&lo_scontext, scontext, sizeof(lo_scontext));\n\tlo_scontext.type = source->bounds;\n\n\tif (target->bounds) {\n\t\tmemcpy(&lo_tcontext, tcontext, sizeof(lo_tcontext));\n\t\tlo_tcontext.type = target->bounds;\n\t\ttcontextp = &lo_tcontext;\n\t}\n\n\tcontext_struct_compute_av(&lo_scontext,\n\t\t\t\t  tcontextp,\n\t\t\t\t  tclass,\n\t\t\t\t  &lo_avd,\n\t\t\t\t  NULL);\n\n\tmasked = ~lo_avd.allowed & avd->allowed;\n\n\tif (likely(!masked))\n\t\treturn;\t\t/* no masked permission */\n\n\t/* mask violated permissions */\n\tavd->allowed &= ~masked;\n\n\t/* audit masked permissions */\n\tsecurity_dump_masked_av(scontext, tcontext,\n\t\t\t\ttclass, masked, \"bounds\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "constraint_expr_eval",
          "args": [
            "scontext",
            "tcontext",
            "NULL",
            "constraint->expr"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "constraint_expr_eval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "285-457",
          "snippet": "static int constraint_expr_eval(struct context *scontext,\n\t\t\t\tstruct context *tcontext,\n\t\t\t\tstruct context *xcontext,\n\t\t\t\tstruct constraint_expr *cexpr)\n{\n\tu32 val1, val2;\n\tstruct context *c;\n\tstruct role_datum *r1, *r2;\n\tstruct mls_level *l1, *l2;\n\tstruct constraint_expr *e;\n\tint s[CEXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tfor (e = cexpr; e; e = e->next) {\n\t\tswitch (e->expr_type) {\n\t\tcase CEXPR_NOT:\n\t\t\tBUG_ON(sp < 0);\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase CEXPR_AND:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_OR:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_ATTR:\n\t\t\tif (sp == (CEXPR_MAXDEPTH - 1))\n\t\t\t\treturn 0;\n\t\t\tswitch (e->attr) {\n\t\t\tcase CEXPR_USER:\n\t\t\t\tval1 = scontext->user;\n\t\t\t\tval2 = tcontext->user;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_TYPE:\n\t\t\t\tval1 = scontext->type;\n\t\t\t\tval2 = tcontext->type;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ROLE:\n\t\t\t\tval1 = scontext->role;\n\t\t\t\tval2 = tcontext->role;\n\t\t\t\tr1 = policydb.role_val_to_struct[val1 - 1];\n\t\t\t\tr2 = policydb.role_val_to_struct[val2 - 1];\n\t\t\t\tswitch (e->op) {\n\t\t\t\tcase CEXPR_DOM:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t  val2 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_DOMBY:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t  val1 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_INCOMP:\n\t\t\t\t\ts[++sp] = (!ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t    val2 - 1) &&\n\t\t\t\t\t\t   !ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t    val1 - 1));\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_L1L2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1L2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1H2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H1:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(scontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L2H2:\n\t\t\t\tl1 = &(tcontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\nmls_ops:\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOM:\n\t\t\t\ts[++sp] = mls_level_dom(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOMBY:\n\t\t\t\ts[++sp] = mls_level_dom(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_INCOMP:\n\t\t\t\ts[++sp] = mls_level_incomp(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = (val1 == val2);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = (val1 != val2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CEXPR_NAMES:\n\t\t\tif (sp == (CEXPR_MAXDEPTH-1))\n\t\t\t\treturn 0;\n\t\t\tc = scontext;\n\t\t\tif (e->attr & CEXPR_TARGET)\n\t\t\t\tc = tcontext;\n\t\t\telse if (e->attr & CEXPR_XTARGET) {\n\t\t\t\tc = xcontext;\n\t\t\t\tif (!c) {\n\t\t\t\t\tBUG();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e->attr & CEXPR_USER)\n\t\t\t\tval1 = c->user;\n\t\t\telse if (e->attr & CEXPR_ROLE)\n\t\t\t\tval1 = c->role;\n\t\t\telse if (e->attr & CEXPR_TYPE)\n\t\t\t\tval1 = c->type;\n\t\t\telse {\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tBUG_ON(sp != 0);\n\treturn s[0];\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nstatic int constraint_expr_eval(struct context *scontext,\n\t\t\t\tstruct context *tcontext,\n\t\t\t\tstruct context *xcontext,\n\t\t\t\tstruct constraint_expr *cexpr)\n{\n\tu32 val1, val2;\n\tstruct context *c;\n\tstruct role_datum *r1, *r2;\n\tstruct mls_level *l1, *l2;\n\tstruct constraint_expr *e;\n\tint s[CEXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tfor (e = cexpr; e; e = e->next) {\n\t\tswitch (e->expr_type) {\n\t\tcase CEXPR_NOT:\n\t\t\tBUG_ON(sp < 0);\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase CEXPR_AND:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_OR:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_ATTR:\n\t\t\tif (sp == (CEXPR_MAXDEPTH - 1))\n\t\t\t\treturn 0;\n\t\t\tswitch (e->attr) {\n\t\t\tcase CEXPR_USER:\n\t\t\t\tval1 = scontext->user;\n\t\t\t\tval2 = tcontext->user;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_TYPE:\n\t\t\t\tval1 = scontext->type;\n\t\t\t\tval2 = tcontext->type;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ROLE:\n\t\t\t\tval1 = scontext->role;\n\t\t\t\tval2 = tcontext->role;\n\t\t\t\tr1 = policydb.role_val_to_struct[val1 - 1];\n\t\t\t\tr2 = policydb.role_val_to_struct[val2 - 1];\n\t\t\t\tswitch (e->op) {\n\t\t\t\tcase CEXPR_DOM:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t  val2 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_DOMBY:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t  val1 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_INCOMP:\n\t\t\t\t\ts[++sp] = (!ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t    val2 - 1) &&\n\t\t\t\t\t\t   !ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t    val1 - 1));\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_L1L2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1L2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1H2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H1:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(scontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L2H2:\n\t\t\t\tl1 = &(tcontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\nmls_ops:\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOM:\n\t\t\t\ts[++sp] = mls_level_dom(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOMBY:\n\t\t\t\ts[++sp] = mls_level_dom(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_INCOMP:\n\t\t\t\ts[++sp] = mls_level_incomp(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = (val1 == val2);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = (val1 != val2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CEXPR_NAMES:\n\t\t\tif (sp == (CEXPR_MAXDEPTH-1))\n\t\t\t\treturn 0;\n\t\t\tc = scontext;\n\t\t\tif (e->attr & CEXPR_TARGET)\n\t\t\t\tc = tcontext;\n\t\t\telse if (e->attr & CEXPR_XTARGET) {\n\t\t\t\tc = xcontext;\n\t\t\t\tif (!c) {\n\t\t\t\t\tBUG();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e->attr & CEXPR_USER)\n\t\t\t\tval1 = c->user;\n\t\t\telse if (e->attr & CEXPR_ROLE)\n\t\t\t\tval1 = c->role;\n\t\t\telse if (e->attr & CEXPR_TYPE)\n\t\t\t\tval1 = c->type;\n\t\t\telse {\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tBUG_ON(sp != 0);\n\treturn s[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_compute_av",
          "args": [
            "&policydb.te_cond_avtab",
            "&avkey",
            "avd",
            "xperms"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "cond_compute_av",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "638-666",
          "snippet": "void cond_compute_av(struct avtab *ctab, struct avtab_key *key,\n\t\tstruct av_decision *avd, struct extended_perms *xperms)\n{\n\tstruct avtab_node *node;\n\n\tif (!ctab || !key || !avd)\n\t\treturn;\n\n\tfor (node = avtab_search_node(ctab, key); node;\n\t\t\t\tnode = avtab_search_node_next(node, key->specified)) {\n\t\tif ((u16)(AVTAB_ALLOWED|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_ALLOWED|AVTAB_ENABLED)))\n\t\t\tavd->allowed |= node->datum.u.data;\n\t\tif ((u16)(AVTAB_AUDITDENY|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_AUDITDENY|AVTAB_ENABLED)))\n\t\t\t/* Since a '0' in an auditdeny mask represents a\n\t\t\t * permission we do NOT want to audit (dontaudit), we use\n\t\t\t * the '&' operand to ensure that all '0's in the mask\n\t\t\t * are retained (much unlike the allow and auditallow cases).\n\t\t\t */\n\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\tif ((u16)(AVTAB_AUDITALLOW|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_AUDITALLOW|AVTAB_ENABLED)))\n\t\t\tavd->auditallow |= node->datum.u.data;\n\t\tif (xperms && (node->key.specified & AVTAB_ENABLED) &&\n\t\t\t\t(node->key.specified & AVTAB_XPERMS))\n\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t}\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nvoid cond_compute_av(struct avtab *ctab, struct avtab_key *key,\n\t\tstruct av_decision *avd, struct extended_perms *xperms)\n{\n\tstruct avtab_node *node;\n\n\tif (!ctab || !key || !avd)\n\t\treturn;\n\n\tfor (node = avtab_search_node(ctab, key); node;\n\t\t\t\tnode = avtab_search_node_next(node, key->specified)) {\n\t\tif ((u16)(AVTAB_ALLOWED|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_ALLOWED|AVTAB_ENABLED)))\n\t\t\tavd->allowed |= node->datum.u.data;\n\t\tif ((u16)(AVTAB_AUDITDENY|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_AUDITDENY|AVTAB_ENABLED)))\n\t\t\t/* Since a '0' in an auditdeny mask represents a\n\t\t\t * permission we do NOT want to audit (dontaudit), we use\n\t\t\t * the '&' operand to ensure that all '0's in the mask\n\t\t\t * are retained (much unlike the allow and auditallow cases).\n\t\t\t */\n\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\tif ((u16)(AVTAB_AUDITALLOW|AVTAB_ENABLED) ==\n\t\t    (node->key.specified & (AVTAB_AUDITALLOW|AVTAB_ENABLED)))\n\t\t\tavd->auditallow |= node->datum.u.data;\n\t\tif (xperms && (node->key.specified & AVTAB_ENABLED) &&\n\t\t\t\t(node->key.specified & AVTAB_XPERMS))\n\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "services_compute_xperms_drivers",
          "args": [
            "xperms",
            "node"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "services_compute_xperms_drivers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "610-629",
          "snippet": "void services_compute_xperms_drivers(\n\t\tstruct extended_perms *xperms,\n\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t/* if one or more driver has all permissions allowed */\n\t\tfor (i = 0; i < ARRAY_SIZE(xperms->drivers.p); i++)\n\t\t\txperms->drivers.p[i] |= node->datum.u.xperms->perms.p[i];\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t/* if allowing permissions within a driver */\n\t\tsecurity_xperm_set(xperms->drivers.p,\n\t\t\t\t\tnode->datum.u.xperms->driver);\n\t}\n\n\t/* If no ioctl commands are allowed, ignore auditallow and auditdeny */\n\tif (node->key.specified & AVTAB_XPERMS_ALLOWED)\n\t\txperms->len = 1;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);",
            "static int security_preserve_bools(struct policydb *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);\nstatic int security_preserve_bools(struct policydb *p);\n\nvoid services_compute_xperms_drivers(\n\t\tstruct extended_perms *xperms,\n\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t/* if one or more driver has all permissions allowed */\n\t\tfor (i = 0; i < ARRAY_SIZE(xperms->drivers.p); i++)\n\t\t\txperms->drivers.p[i] |= node->datum.u.xperms->perms.p[i];\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t/* if allowing permissions within a driver */\n\t\tsecurity_xperm_set(xperms->drivers.p,\n\t\t\t\t\tnode->datum.u.xperms->driver);\n\t}\n\n\t/* If no ioctl commands are allowed, ignore auditallow and auditdeny */\n\tif (node->key.specified & AVTAB_XPERMS_ALLOWED)\n\t\txperms->len = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avtab_search_node_next",
          "args": [
            "node",
            "avkey.specified"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_search_node_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "250-277",
          "snippet": "struct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "tattr",
            "tnode",
            "j"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "sattr",
            "snode",
            "i"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tattr"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get",
          "args": [
            "policydb.type_attr_map_array",
            "tcontext->type - 1"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!sattr"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get",
          "args": [
            "policydb.type_attr_map_array",
            "scontext->type - 1"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"SELinux:  Invalid class %hu\\n\"",
            "tclass"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tclass || tclass > policydb.p_classes.nprim"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&xperms->drivers",
            "0",
            "sizeof(xperms->drivers)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);\n\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms)\n{\n\tstruct constraint_node *constraint;\n\tstruct role_allow *ra;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct class_datum *tclass_datum;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tif (xperms) {\n\t\tmemset(&xperms->drivers, 0, sizeof(xperms->drivers));\n\t\txperms->len = 0;\n\t}\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"SELinux:  Invalid class %hu\\n\", tclass);\n\t\treturn;\n\t}\n\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\t/*\n\t * If a specific type enforcement rule was defined for\n\t * this permission check, then use it.\n\t */\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_AV | AVTAB_XPERMS;\n\tsattr = flex_array_get(policydb.type_attr_map_array, scontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array, tcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified)) {\n\t\t\t\tif (node->key.specified == AVTAB_ALLOWED)\n\t\t\t\t\tavd->allowed |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITALLOW)\n\t\t\t\t\tavd->auditallow |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITDENY)\n\t\t\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\t\t\telse if (xperms && (node->key.specified & AVTAB_XPERMS))\n\t\t\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t\t\t}\n\n\t\t\t/* Check conditional av table for additional permissions */\n\t\t\tcond_compute_av(&policydb.te_cond_avtab, &avkey,\n\t\t\t\t\tavd, xperms);\n\n\t\t}\n\t}\n\n\t/*\n\t * Remove any permissions prohibited by a constraint (this includes\n\t * the MLS policy).\n\t */\n\tconstraint = tclass_datum->constraints;\n\twhile (constraint) {\n\t\tif ((constraint->permissions & (avd->allowed)) &&\n\t\t    !constraint_expr_eval(scontext, tcontext, NULL,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tavd->allowed &= ~(constraint->permissions);\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\n\t/*\n\t * If checking process transition permission and the\n\t * role is changing, then check the (current_role, new_role)\n\t * pair.\n\t */\n\tif (tclass == policydb.process_class &&\n\t    (avd->allowed & policydb.process_trans_perms) &&\n\t    scontext->role != tcontext->role) {\n\t\tfor (ra = policydb.role_allow; ra; ra = ra->next) {\n\t\t\tif (scontext->role == ra->role &&\n\t\t\t    tcontext->role == ra->new_role)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!ra)\n\t\t\tavd->allowed &= ~policydb.process_trans_perms;\n\t}\n\n\t/*\n\t * If the given source and target types have boundary\n\t * constraint, lazy checks have to mask any violated\n\t * permission and notice it to userspace via audit.\n\t */\n\ttype_attribute_bounds_av(scontext, tcontext,\n\t\t\t\t tclass, avd);\n}"
  },
  {
    "function_name": "services_compute_xperms_drivers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "610-629",
    "snippet": "void services_compute_xperms_drivers(\n\t\tstruct extended_perms *xperms,\n\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t/* if one or more driver has all permissions allowed */\n\t\tfor (i = 0; i < ARRAY_SIZE(xperms->drivers.p); i++)\n\t\t\txperms->drivers.p[i] |= node->datum.u.xperms->perms.p[i];\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t/* if allowing permissions within a driver */\n\t\tsecurity_xperm_set(xperms->drivers.p,\n\t\t\t\t\tnode->datum.u.xperms->driver);\n\t}\n\n\t/* If no ioctl commands are allowed, ignore auditallow and auditdeny */\n\tif (node->key.specified & AVTAB_XPERMS_ALLOWED)\n\t\txperms->len = 1;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);",
      "static int security_preserve_bools(struct policydb *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_xperm_set",
          "args": [
            "xperms->drivers.p",
            "node->datum.u.xperms->driver"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "xperms->drivers.p"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);\nstatic int security_preserve_bools(struct policydb *p);\n\nvoid services_compute_xperms_drivers(\n\t\tstruct extended_perms *xperms,\n\t\tstruct avtab_node *node)\n{\n\tunsigned int i;\n\n\tif (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLDRIVER) {\n\t\t/* if one or more driver has all permissions allowed */\n\t\tfor (i = 0; i < ARRAY_SIZE(xperms->drivers.p); i++)\n\t\t\txperms->drivers.p[i] |= node->datum.u.xperms->perms.p[i];\n\t} else if (node->datum.u.xperms->specified == AVTAB_XPERMS_IOCTLFUNCTION) {\n\t\t/* if allowing permissions within a driver */\n\t\tsecurity_xperm_set(xperms->drivers.p,\n\t\t\t\t\tnode->datum.u.xperms->driver);\n\t}\n\n\t/* If no ioctl commands are allowed, ignore auditallow and auditdeny */\n\tif (node->key.specified & AVTAB_XPERMS_ALLOWED)\n\t\txperms->len = 1;\n}"
  },
  {
    "function_name": "type_attribute_bounds_av",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "553-604",
    "snippet": "static void type_attribute_bounds_av(struct context *scontext,\n\t\t\t\t     struct context *tcontext,\n\t\t\t\t     u16 tclass,\n\t\t\t\t     struct av_decision *avd)\n{\n\tstruct context lo_scontext;\n\tstruct context lo_tcontext, *tcontextp = tcontext;\n\tstruct av_decision lo_avd;\n\tstruct type_datum *source;\n\tstruct type_datum *target;\n\tu32 masked = 0;\n\n\tsource = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t    scontext->type - 1);\n\tBUG_ON(!source);\n\n\tif (!source->bounds)\n\t\treturn;\n\n\ttarget = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t    tcontext->type - 1);\n\tBUG_ON(!target);\n\n\tmemset(&lo_avd, 0, sizeof(lo_avd));\n\n\tmemcpy(&lo_scontext, scontext, sizeof(lo_scontext));\n\tlo_scontext.type = source->bounds;\n\n\tif (target->bounds) {\n\t\tmemcpy(&lo_tcontext, tcontext, sizeof(lo_tcontext));\n\t\tlo_tcontext.type = target->bounds;\n\t\ttcontextp = &lo_tcontext;\n\t}\n\n\tcontext_struct_compute_av(&lo_scontext,\n\t\t\t\t  tcontextp,\n\t\t\t\t  tclass,\n\t\t\t\t  &lo_avd,\n\t\t\t\t  NULL);\n\n\tmasked = ~lo_avd.allowed & avd->allowed;\n\n\tif (likely(!masked))\n\t\treturn;\t\t/* no masked permission */\n\n\t/* mask violated permissions */\n\tavd->allowed &= ~masked;\n\n\t/* audit masked permissions */\n\tsecurity_dump_masked_av(scontext, tcontext,\n\t\t\t\ttclass, masked, \"bounds\");\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_dump_masked_av",
          "args": [
            "scontext",
            "tcontext",
            "tclass",
            "masked",
            "\"bounds\""
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "security_dump_masked_av",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "475-547",
          "snippet": "static void security_dump_masked_av(struct context *scontext,\n\t\t\t\t    struct context *tcontext,\n\t\t\t\t    u16 tclass,\n\t\t\t\t    u32 permissions,\n\t\t\t\t    const char *reason)\n{\n\tstruct common_datum *common_dat;\n\tstruct class_datum *tclass_dat;\n\tstruct audit_buffer *ab;\n\tchar *tclass_name;\n\tchar *scontext_name = NULL;\n\tchar *tcontext_name = NULL;\n\tchar *permission_names[32];\n\tint index;\n\tu32 length;\n\tbool need_comma = false;\n\n\tif (!permissions)\n\t\treturn;\n\n\ttclass_name = sym_name(&policydb, SYM_CLASSES, tclass - 1);\n\ttclass_dat = policydb.class_val_to_struct[tclass - 1];\n\tcommon_dat = tclass_dat->comdatum;\n\n\t/* init permission_names */\n\tif (common_dat &&\n\t    hashtab_map(common_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\tif (hashtab_map(tclass_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\t/* get scontext/tcontext in text form */\n\tif (context_struct_to_string(scontext,\n\t\t\t\t     &scontext_name, &length) < 0)\n\t\tgoto out;\n\n\tif (context_struct_to_string(tcontext,\n\t\t\t\t     &tcontext_name, &length) < 0)\n\t\tgoto out;\n\n\t/* audit a message */\n\tab = audit_log_start(current->audit_context,\n\t\t\t     GFP_ATOMIC, AUDIT_SELINUX_ERR);\n\tif (!ab)\n\t\tgoto out;\n\n\taudit_log_format(ab, \"op=security_compute_av reason=%s \"\n\t\t\t \"scontext=%s tcontext=%s tclass=%s perms=\",\n\t\t\t reason, scontext_name, tcontext_name, tclass_name);\n\n\tfor (index = 0; index < 32; index++) {\n\t\tu32 mask = (1 << index);\n\n\t\tif ((mask & permissions) == 0)\n\t\t\tcontinue;\n\n\t\taudit_log_format(ab, \"%s%s\",\n\t\t\t\t need_comma ? \",\" : \"\",\n\t\t\t\t permission_names[index]\n\t\t\t\t ? permission_names[index] : \"????\");\n\t\tneed_comma = true;\n\t}\n\taudit_log_end(ab);\nout:\n\t/* release scontext/tcontext */\n\tkfree(tcontext_name);\n\tkfree(scontext_name);\n\n\treturn;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nstatic void security_dump_masked_av(struct context *scontext,\n\t\t\t\t    struct context *tcontext,\n\t\t\t\t    u16 tclass,\n\t\t\t\t    u32 permissions,\n\t\t\t\t    const char *reason)\n{\n\tstruct common_datum *common_dat;\n\tstruct class_datum *tclass_dat;\n\tstruct audit_buffer *ab;\n\tchar *tclass_name;\n\tchar *scontext_name = NULL;\n\tchar *tcontext_name = NULL;\n\tchar *permission_names[32];\n\tint index;\n\tu32 length;\n\tbool need_comma = false;\n\n\tif (!permissions)\n\t\treturn;\n\n\ttclass_name = sym_name(&policydb, SYM_CLASSES, tclass - 1);\n\ttclass_dat = policydb.class_val_to_struct[tclass - 1];\n\tcommon_dat = tclass_dat->comdatum;\n\n\t/* init permission_names */\n\tif (common_dat &&\n\t    hashtab_map(common_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\tif (hashtab_map(tclass_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\t/* get scontext/tcontext in text form */\n\tif (context_struct_to_string(scontext,\n\t\t\t\t     &scontext_name, &length) < 0)\n\t\tgoto out;\n\n\tif (context_struct_to_string(tcontext,\n\t\t\t\t     &tcontext_name, &length) < 0)\n\t\tgoto out;\n\n\t/* audit a message */\n\tab = audit_log_start(current->audit_context,\n\t\t\t     GFP_ATOMIC, AUDIT_SELINUX_ERR);\n\tif (!ab)\n\t\tgoto out;\n\n\taudit_log_format(ab, \"op=security_compute_av reason=%s \"\n\t\t\t \"scontext=%s tcontext=%s tclass=%s perms=\",\n\t\t\t reason, scontext_name, tcontext_name, tclass_name);\n\n\tfor (index = 0; index < 32; index++) {\n\t\tu32 mask = (1 << index);\n\n\t\tif ((mask & permissions) == 0)\n\t\t\tcontinue;\n\n\t\taudit_log_format(ab, \"%s%s\",\n\t\t\t\t need_comma ? \",\" : \"\",\n\t\t\t\t permission_names[index]\n\t\t\t\t ? permission_names[index] : \"????\");\n\t\tneed_comma = true;\n\t}\n\taudit_log_end(ab);\nout:\n\t/* release scontext/tcontext */\n\tkfree(tcontext_name);\n\tkfree(scontext_name);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!masked"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_struct_compute_av",
          "args": [
            "&lo_scontext",
            "tcontextp",
            "tclass",
            "&lo_avd",
            "NULL"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "context_struct_compute_av",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "635-738",
          "snippet": "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms)\n{\n\tstruct constraint_node *constraint;\n\tstruct role_allow *ra;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct class_datum *tclass_datum;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tif (xperms) {\n\t\tmemset(&xperms->drivers, 0, sizeof(xperms->drivers));\n\t\txperms->len = 0;\n\t}\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"SELinux:  Invalid class %hu\\n\", tclass);\n\t\treturn;\n\t}\n\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\t/*\n\t * If a specific type enforcement rule was defined for\n\t * this permission check, then use it.\n\t */\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_AV | AVTAB_XPERMS;\n\tsattr = flex_array_get(policydb.type_attr_map_array, scontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array, tcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified)) {\n\t\t\t\tif (node->key.specified == AVTAB_ALLOWED)\n\t\t\t\t\tavd->allowed |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITALLOW)\n\t\t\t\t\tavd->auditallow |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITDENY)\n\t\t\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\t\t\telse if (xperms && (node->key.specified & AVTAB_XPERMS))\n\t\t\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t\t\t}\n\n\t\t\t/* Check conditional av table for additional permissions */\n\t\t\tcond_compute_av(&policydb.te_cond_avtab, &avkey,\n\t\t\t\t\tavd, xperms);\n\n\t\t}\n\t}\n\n\t/*\n\t * Remove any permissions prohibited by a constraint (this includes\n\t * the MLS policy).\n\t */\n\tconstraint = tclass_datum->constraints;\n\twhile (constraint) {\n\t\tif ((constraint->permissions & (avd->allowed)) &&\n\t\t    !constraint_expr_eval(scontext, tcontext, NULL,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tavd->allowed &= ~(constraint->permissions);\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\n\t/*\n\t * If checking process transition permission and the\n\t * role is changing, then check the (current_role, new_role)\n\t * pair.\n\t */\n\tif (tclass == policydb.process_class &&\n\t    (avd->allowed & policydb.process_trans_perms) &&\n\t    scontext->role != tcontext->role) {\n\t\tfor (ra = policydb.role_allow; ra; ra = ra->next) {\n\t\t\tif (scontext->role == ra->role &&\n\t\t\t    tcontext->role == ra->new_role)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!ra)\n\t\t\tavd->allowed &= ~policydb.process_trans_perms;\n\t}\n\n\t/*\n\t * If the given source and target types have boundary\n\t * constraint, lazy checks have to mask any violated\n\t * permission and notice it to userspace via audit.\n\t */\n\ttype_attribute_bounds_av(scontext, tcontext,\n\t\t\t\t tclass, avd);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;",
            "static void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms);\n\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t\tstruct context *tcontext,\n\t\t\t\t\tu16 tclass,\n\t\t\t\t\tstruct av_decision *avd,\n\t\t\t\t\tstruct extended_perms *xperms)\n{\n\tstruct constraint_node *constraint;\n\tstruct role_allow *ra;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct class_datum *tclass_datum;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tif (xperms) {\n\t\tmemset(&xperms->drivers, 0, sizeof(xperms->drivers));\n\t\txperms->len = 0;\n\t}\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"SELinux:  Invalid class %hu\\n\", tclass);\n\t\treturn;\n\t}\n\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\t/*\n\t * If a specific type enforcement rule was defined for\n\t * this permission check, then use it.\n\t */\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_AV | AVTAB_XPERMS;\n\tsattr = flex_array_get(policydb.type_attr_map_array, scontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array, tcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified)) {\n\t\t\t\tif (node->key.specified == AVTAB_ALLOWED)\n\t\t\t\t\tavd->allowed |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITALLOW)\n\t\t\t\t\tavd->auditallow |= node->datum.u.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITDENY)\n\t\t\t\t\tavd->auditdeny &= node->datum.u.data;\n\t\t\t\telse if (xperms && (node->key.specified & AVTAB_XPERMS))\n\t\t\t\t\tservices_compute_xperms_drivers(xperms, node);\n\t\t\t}\n\n\t\t\t/* Check conditional av table for additional permissions */\n\t\t\tcond_compute_av(&policydb.te_cond_avtab, &avkey,\n\t\t\t\t\tavd, xperms);\n\n\t\t}\n\t}\n\n\t/*\n\t * Remove any permissions prohibited by a constraint (this includes\n\t * the MLS policy).\n\t */\n\tconstraint = tclass_datum->constraints;\n\twhile (constraint) {\n\t\tif ((constraint->permissions & (avd->allowed)) &&\n\t\t    !constraint_expr_eval(scontext, tcontext, NULL,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tavd->allowed &= ~(constraint->permissions);\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\n\t/*\n\t * If checking process transition permission and the\n\t * role is changing, then check the (current_role, new_role)\n\t * pair.\n\t */\n\tif (tclass == policydb.process_class &&\n\t    (avd->allowed & policydb.process_trans_perms) &&\n\t    scontext->role != tcontext->role) {\n\t\tfor (ra = policydb.role_allow; ra; ra = ra->next) {\n\t\t\tif (scontext->role == ra->role &&\n\t\t\t    tcontext->role == ra->new_role)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!ra)\n\t\t\tavd->allowed &= ~policydb.process_trans_perms;\n\t}\n\n\t/*\n\t * If the given source and target types have boundary\n\t * constraint, lazy checks have to mask any violated\n\t * permission and notice it to userspace via audit.\n\t */\n\ttype_attribute_bounds_av(scontext, tcontext,\n\t\t\t\t tclass, avd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lo_tcontext",
            "tcontext",
            "sizeof(lo_tcontext)"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lo_scontext",
            "scontext",
            "sizeof(lo_scontext)"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lo_avd",
            "0",
            "sizeof(lo_avd)"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!target"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get_ptr",
          "args": [
            "policydb.type_val_to_struct_array",
            "tcontext->type - 1"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!source"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get_ptr",
          "args": [
            "policydb.type_val_to_struct_array",
            "scontext->type - 1"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nstatic void type_attribute_bounds_av(struct context *scontext,\n\t\t\t\t     struct context *tcontext,\n\t\t\t\t     u16 tclass,\n\t\t\t\t     struct av_decision *avd)\n{\n\tstruct context lo_scontext;\n\tstruct context lo_tcontext, *tcontextp = tcontext;\n\tstruct av_decision lo_avd;\n\tstruct type_datum *source;\n\tstruct type_datum *target;\n\tu32 masked = 0;\n\n\tsource = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t    scontext->type - 1);\n\tBUG_ON(!source);\n\n\tif (!source->bounds)\n\t\treturn;\n\n\ttarget = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t    tcontext->type - 1);\n\tBUG_ON(!target);\n\n\tmemset(&lo_avd, 0, sizeof(lo_avd));\n\n\tmemcpy(&lo_scontext, scontext, sizeof(lo_scontext));\n\tlo_scontext.type = source->bounds;\n\n\tif (target->bounds) {\n\t\tmemcpy(&lo_tcontext, tcontext, sizeof(lo_tcontext));\n\t\tlo_tcontext.type = target->bounds;\n\t\ttcontextp = &lo_tcontext;\n\t}\n\n\tcontext_struct_compute_av(&lo_scontext,\n\t\t\t\t  tcontextp,\n\t\t\t\t  tclass,\n\t\t\t\t  &lo_avd,\n\t\t\t\t  NULL);\n\n\tmasked = ~lo_avd.allowed & avd->allowed;\n\n\tif (likely(!masked))\n\t\treturn;\t\t/* no masked permission */\n\n\t/* mask violated permissions */\n\tavd->allowed &= ~masked;\n\n\t/* audit masked permissions */\n\tsecurity_dump_masked_av(scontext, tcontext,\n\t\t\t\ttclass, masked, \"bounds\");\n}"
  },
  {
    "function_name": "security_dump_masked_av",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "475-547",
    "snippet": "static void security_dump_masked_av(struct context *scontext,\n\t\t\t\t    struct context *tcontext,\n\t\t\t\t    u16 tclass,\n\t\t\t\t    u32 permissions,\n\t\t\t\t    const char *reason)\n{\n\tstruct common_datum *common_dat;\n\tstruct class_datum *tclass_dat;\n\tstruct audit_buffer *ab;\n\tchar *tclass_name;\n\tchar *scontext_name = NULL;\n\tchar *tcontext_name = NULL;\n\tchar *permission_names[32];\n\tint index;\n\tu32 length;\n\tbool need_comma = false;\n\n\tif (!permissions)\n\t\treturn;\n\n\ttclass_name = sym_name(&policydb, SYM_CLASSES, tclass - 1);\n\ttclass_dat = policydb.class_val_to_struct[tclass - 1];\n\tcommon_dat = tclass_dat->comdatum;\n\n\t/* init permission_names */\n\tif (common_dat &&\n\t    hashtab_map(common_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\tif (hashtab_map(tclass_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\t/* get scontext/tcontext in text form */\n\tif (context_struct_to_string(scontext,\n\t\t\t\t     &scontext_name, &length) < 0)\n\t\tgoto out;\n\n\tif (context_struct_to_string(tcontext,\n\t\t\t\t     &tcontext_name, &length) < 0)\n\t\tgoto out;\n\n\t/* audit a message */\n\tab = audit_log_start(current->audit_context,\n\t\t\t     GFP_ATOMIC, AUDIT_SELINUX_ERR);\n\tif (!ab)\n\t\tgoto out;\n\n\taudit_log_format(ab, \"op=security_compute_av reason=%s \"\n\t\t\t \"scontext=%s tcontext=%s tclass=%s perms=\",\n\t\t\t reason, scontext_name, tcontext_name, tclass_name);\n\n\tfor (index = 0; index < 32; index++) {\n\t\tu32 mask = (1 << index);\n\n\t\tif ((mask & permissions) == 0)\n\t\t\tcontinue;\n\n\t\taudit_log_format(ab, \"%s%s\",\n\t\t\t\t need_comma ? \",\" : \"\",\n\t\t\t\t permission_names[index]\n\t\t\t\t ? permission_names[index] : \"????\");\n\t\tneed_comma = true;\n\t}\n\taudit_log_end(ab);\nout:\n\t/* release scontext/tcontext */\n\tkfree(tcontext_name);\n\tkfree(scontext_name);\n\n\treturn;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "scontext_name"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tcontext_name"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"%s%s\"",
            "need_comma ? \",\" : \"\"",
            "permission_names[index]\n\t\t\t\t ? permission_names[index] : \"????\""
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"op=security_compute_av reason=%s \"\n\t\t\t \"scontext=%s tcontext=%s tclass=%s perms=\"",
            "reason",
            "scontext_name",
            "tcontext_name",
            "tclass_name"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "current->audit_context",
            "GFP_ATOMIC",
            "AUDIT_SELINUX_ERR"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_struct_to_string",
          "args": [
            "tcontext",
            "&tcontext_name",
            "&length"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "context_struct_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1192-1238",
          "snippet": "static int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;",
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tscontextp += sprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_map",
          "args": [
            "tclass_dat->permissions.table",
            "dump_masked_av_helper",
            "permission_names"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "123-144",
          "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "&policydb",
            "SYM_CLASSES",
            "tclass - 1"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nstatic void security_dump_masked_av(struct context *scontext,\n\t\t\t\t    struct context *tcontext,\n\t\t\t\t    u16 tclass,\n\t\t\t\t    u32 permissions,\n\t\t\t\t    const char *reason)\n{\n\tstruct common_datum *common_dat;\n\tstruct class_datum *tclass_dat;\n\tstruct audit_buffer *ab;\n\tchar *tclass_name;\n\tchar *scontext_name = NULL;\n\tchar *tcontext_name = NULL;\n\tchar *permission_names[32];\n\tint index;\n\tu32 length;\n\tbool need_comma = false;\n\n\tif (!permissions)\n\t\treturn;\n\n\ttclass_name = sym_name(&policydb, SYM_CLASSES, tclass - 1);\n\ttclass_dat = policydb.class_val_to_struct[tclass - 1];\n\tcommon_dat = tclass_dat->comdatum;\n\n\t/* init permission_names */\n\tif (common_dat &&\n\t    hashtab_map(common_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\tif (hashtab_map(tclass_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\t/* get scontext/tcontext in text form */\n\tif (context_struct_to_string(scontext,\n\t\t\t\t     &scontext_name, &length) < 0)\n\t\tgoto out;\n\n\tif (context_struct_to_string(tcontext,\n\t\t\t\t     &tcontext_name, &length) < 0)\n\t\tgoto out;\n\n\t/* audit a message */\n\tab = audit_log_start(current->audit_context,\n\t\t\t     GFP_ATOMIC, AUDIT_SELINUX_ERR);\n\tif (!ab)\n\t\tgoto out;\n\n\taudit_log_format(ab, \"op=security_compute_av reason=%s \"\n\t\t\t \"scontext=%s tcontext=%s tclass=%s perms=\",\n\t\t\t reason, scontext_name, tcontext_name, tclass_name);\n\n\tfor (index = 0; index < 32; index++) {\n\t\tu32 mask = (1 << index);\n\n\t\tif ((mask & permissions) == 0)\n\t\t\tcontinue;\n\n\t\taudit_log_format(ab, \"%s%s\",\n\t\t\t\t need_comma ? \",\" : \"\",\n\t\t\t\t permission_names[index]\n\t\t\t\t ? permission_names[index] : \"????\");\n\t\tneed_comma = true;\n\t}\n\taudit_log_end(ab);\nout:\n\t/* release scontext/tcontext */\n\tkfree(tcontext_name);\n\tkfree(scontext_name);\n\n\treturn;\n}"
  },
  {
    "function_name": "dump_masked_av_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "463-473",
    "snippet": "static int dump_masked_av_helper(void *k, void *d, void *args)\n{\n\tstruct perm_datum *pdatum = d;\n\tchar **permission_names = args;\n\n\tBUG_ON(pdatum->value < 1 || pdatum->value > 32);\n\n\tpermission_names[pdatum->value - 1] = (char *)k;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pdatum->value < 1 || pdatum->value > 32"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int dump_masked_av_helper(void *k, void *d, void *args)\n{\n\tstruct perm_datum *pdatum = d;\n\tchar **permission_names = args;\n\n\tBUG_ON(pdatum->value < 1 || pdatum->value > 32);\n\n\tpermission_names[pdatum->value - 1] = (char *)k;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "constraint_expr_eval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "285-457",
    "snippet": "static int constraint_expr_eval(struct context *scontext,\n\t\t\t\tstruct context *tcontext,\n\t\t\t\tstruct context *xcontext,\n\t\t\t\tstruct constraint_expr *cexpr)\n{\n\tu32 val1, val2;\n\tstruct context *c;\n\tstruct role_datum *r1, *r2;\n\tstruct mls_level *l1, *l2;\n\tstruct constraint_expr *e;\n\tint s[CEXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tfor (e = cexpr; e; e = e->next) {\n\t\tswitch (e->expr_type) {\n\t\tcase CEXPR_NOT:\n\t\t\tBUG_ON(sp < 0);\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase CEXPR_AND:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_OR:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_ATTR:\n\t\t\tif (sp == (CEXPR_MAXDEPTH - 1))\n\t\t\t\treturn 0;\n\t\t\tswitch (e->attr) {\n\t\t\tcase CEXPR_USER:\n\t\t\t\tval1 = scontext->user;\n\t\t\t\tval2 = tcontext->user;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_TYPE:\n\t\t\t\tval1 = scontext->type;\n\t\t\t\tval2 = tcontext->type;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ROLE:\n\t\t\t\tval1 = scontext->role;\n\t\t\t\tval2 = tcontext->role;\n\t\t\t\tr1 = policydb.role_val_to_struct[val1 - 1];\n\t\t\t\tr2 = policydb.role_val_to_struct[val2 - 1];\n\t\t\t\tswitch (e->op) {\n\t\t\t\tcase CEXPR_DOM:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t  val2 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_DOMBY:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t  val1 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_INCOMP:\n\t\t\t\t\ts[++sp] = (!ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t    val2 - 1) &&\n\t\t\t\t\t\t   !ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t    val1 - 1));\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_L1L2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1L2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1H2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H1:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(scontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L2H2:\n\t\t\t\tl1 = &(tcontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\nmls_ops:\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOM:\n\t\t\t\ts[++sp] = mls_level_dom(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOMBY:\n\t\t\t\ts[++sp] = mls_level_dom(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_INCOMP:\n\t\t\t\ts[++sp] = mls_level_incomp(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = (val1 == val2);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = (val1 != val2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CEXPR_NAMES:\n\t\t\tif (sp == (CEXPR_MAXDEPTH-1))\n\t\t\t\treturn 0;\n\t\t\tc = scontext;\n\t\t\tif (e->attr & CEXPR_TARGET)\n\t\t\t\tc = tcontext;\n\t\t\telse if (e->attr & CEXPR_XTARGET) {\n\t\t\t\tc = xcontext;\n\t\t\t\tif (!c) {\n\t\t\t\t\tBUG();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e->attr & CEXPR_USER)\n\t\t\t\tval1 = c->user;\n\t\t\telse if (e->attr & CEXPR_ROLE)\n\t\t\t\tval1 = c->role;\n\t\t\telse if (e->attr & CEXPR_TYPE)\n\t\t\t\tval1 = c->type;\n\t\t\telse {\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tBUG_ON(sp != 0);\n\treturn s[0];\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sp != 0"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_get_bit",
          "args": [
            "&e->names",
            "val1 - 1"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_get_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "242-257",
          "snippet": "int ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mls_level_incomp",
          "args": [
            "l2",
            "l1"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mls_level_dom",
          "args": [
            "l2",
            "l1"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "mls_level_dom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls_types.h",
          "lines": "36-40",
          "snippet": "static inline int mls_level_dom(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens >= l2->sens) &&\n\t\tebitmap_contains(&l1->cat, &l2->cat, 0));\n}",
          "includes": [
            "#include \"ebitmap.h\"",
            "#include \"security.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebitmap.h\"\n#include \"security.h\"\n\nstatic inline int mls_level_dom(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens >= l2->sens) &&\n\t\tebitmap_contains(&l1->cat, &l2->cat, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_level_eq",
          "args": [
            "l1",
            "l2"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "mls_level_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls_types.h",
          "lines": "30-34",
          "snippet": "static inline int mls_level_eq(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens == l2->sens) &&\n\t\tebitmap_cmp(&l1->cat, &l2->cat));\n}",
          "includes": [
            "#include \"ebitmap.h\"",
            "#include \"security.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebitmap.h\"\n#include \"security.h\"\n\nstatic inline int mls_level_eq(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens == l2->sens) &&\n\t\tebitmap_cmp(&l1->cat, &l2->cat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sp < 1"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sp < 1"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sp < 0"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nstatic int constraint_expr_eval(struct context *scontext,\n\t\t\t\tstruct context *tcontext,\n\t\t\t\tstruct context *xcontext,\n\t\t\t\tstruct constraint_expr *cexpr)\n{\n\tu32 val1, val2;\n\tstruct context *c;\n\tstruct role_datum *r1, *r2;\n\tstruct mls_level *l1, *l2;\n\tstruct constraint_expr *e;\n\tint s[CEXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tfor (e = cexpr; e; e = e->next) {\n\t\tswitch (e->expr_type) {\n\t\tcase CEXPR_NOT:\n\t\t\tBUG_ON(sp < 0);\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase CEXPR_AND:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_OR:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_ATTR:\n\t\t\tif (sp == (CEXPR_MAXDEPTH - 1))\n\t\t\t\treturn 0;\n\t\t\tswitch (e->attr) {\n\t\t\tcase CEXPR_USER:\n\t\t\t\tval1 = scontext->user;\n\t\t\t\tval2 = tcontext->user;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_TYPE:\n\t\t\t\tval1 = scontext->type;\n\t\t\t\tval2 = tcontext->type;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ROLE:\n\t\t\t\tval1 = scontext->role;\n\t\t\t\tval2 = tcontext->role;\n\t\t\t\tr1 = policydb.role_val_to_struct[val1 - 1];\n\t\t\t\tr2 = policydb.role_val_to_struct[val2 - 1];\n\t\t\t\tswitch (e->op) {\n\t\t\t\tcase CEXPR_DOM:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t  val2 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_DOMBY:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t  val1 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_INCOMP:\n\t\t\t\t\ts[++sp] = (!ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t    val2 - 1) &&\n\t\t\t\t\t\t   !ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t    val1 - 1));\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_L1L2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1L2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1H2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H1:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(scontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L2H2:\n\t\t\t\tl1 = &(tcontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\nmls_ops:\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOM:\n\t\t\t\ts[++sp] = mls_level_dom(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOMBY:\n\t\t\t\ts[++sp] = mls_level_dom(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_INCOMP:\n\t\t\t\ts[++sp] = mls_level_incomp(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = (val1 == val2);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = (val1 != val2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CEXPR_NAMES:\n\t\t\tif (sp == (CEXPR_MAXDEPTH-1))\n\t\t\t\treturn 0;\n\t\t\tc = scontext;\n\t\t\tif (e->attr & CEXPR_TARGET)\n\t\t\t\tc = tcontext;\n\t\t\telse if (e->attr & CEXPR_XTARGET) {\n\t\t\t\tc = xcontext;\n\t\t\t\tif (!c) {\n\t\t\t\t\tBUG();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e->attr & CEXPR_USER)\n\t\t\t\tval1 = c->user;\n\t\t\telse if (e->attr & CEXPR_ROLE)\n\t\t\t\tval1 = c->role;\n\t\t\telse if (e->attr & CEXPR_TYPE)\n\t\t\t\tval1 = c->type;\n\t\t\telse {\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tBUG_ON(sp != 0);\n\treturn s[0];\n}"
  },
  {
    "function_name": "security_mls_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "269-272",
    "snippet": "int security_mls_enabled(void)\n{\n\treturn policydb.mls_enabled;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct policydb policydb;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nint security_mls_enabled(void)\n{\n\treturn policydb.mls_enabled;\n}"
  },
  {
    "function_name": "map_decision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "232-267",
    "snippet": "static void map_decision(u16 tclass, struct av_decision *avd,\n\t\t\t int allow_unknown)\n{\n\tif (tclass < current_mapping_size) {\n\t\tunsigned i, n = current_mapping[tclass].num_perms;\n\t\tu32 result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->allowed & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t\tif (allow_unknown && !current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t}\n\t\tavd->allowed = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++)\n\t\t\tif (avd->auditallow & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\tavd->auditallow = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->auditdeny & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t\tif (!allow_unknown && !current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t}\n\t\t/*\n\t\t * In case the kernel has a bug and requests a permission\n\t\t * between num_perms and the maximum permission number, we\n\t\t * should audit that denial\n\t\t */\n\t\tfor (; i < (sizeof(u32)*8); i++)\n\t\t\tresult |= 1<<i;\n\t\tavd->auditdeny = result;\n\t}\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct selinux_mapping *current_mapping;",
      "static u16 current_mapping_size;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nstatic void map_decision(u16 tclass, struct av_decision *avd,\n\t\t\t int allow_unknown)\n{\n\tif (tclass < current_mapping_size) {\n\t\tunsigned i, n = current_mapping[tclass].num_perms;\n\t\tu32 result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->allowed & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t\tif (allow_unknown && !current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t}\n\t\tavd->allowed = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++)\n\t\t\tif (avd->auditallow & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\tavd->auditallow = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->auditdeny & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t\tif (!allow_unknown && !current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t}\n\t\t/*\n\t\t * In case the kernel has a bug and requests a permission\n\t\t * between num_perms and the maximum permission number, we\n\t\t * should audit that denial\n\t\t */\n\t\tfor (; i < (sizeof(u32)*8); i++)\n\t\t\tresult |= 1<<i;\n\t\tavd->auditdeny = result;\n\t}\n}"
  },
  {
    "function_name": "map_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "220-230",
    "snippet": "static u16 map_class(u16 pol_value)\n{\n\tu16 i;\n\n\tfor (i = 1; i < current_mapping_size; i++) {\n\t\tif (current_mapping[i].value == pol_value)\n\t\t\treturn i;\n\t}\n\n\treturn SECCLASS_NULL;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct selinux_mapping *current_mapping;",
      "static u16 current_mapping_size;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nstatic u16 map_class(u16 pol_value)\n{\n\tu16 i;\n\n\tfor (i = 1; i < current_mapping_size; i++) {\n\t\tif (current_mapping[i].value == pol_value)\n\t\t\treturn i;\n\t}\n\n\treturn SECCLASS_NULL;\n}"
  },
  {
    "function_name": "unmap_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "209-215",
    "snippet": "static u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct selinux_mapping *current_mapping;",
      "static u16 current_mapping_size;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nstatic u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}"
  },
  {
    "function_name": "selinux_set_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
    "lines": "123-203",
    "snippet": "static int selinux_set_mapping(struct policydb *pol,\n\t\t\t       struct security_class_mapping *map,\n\t\t\t       struct selinux_mapping **out_map_p,\n\t\t\t       u16 *out_map_size)\n{\n\tstruct selinux_mapping *out_map = NULL;\n\tsize_t size = sizeof(struct selinux_mapping);\n\tu16 i, j;\n\tunsigned k;\n\tbool print_unknown_handle = false;\n\n\t/* Find number of classes in the input mapping */\n\tif (!map)\n\t\treturn -EINVAL;\n\ti = 0;\n\twhile (map[i].name)\n\t\ti++;\n\n\t/* Allocate space for the class records, plus one for class zero */\n\tout_map = kcalloc(++i, size, GFP_ATOMIC);\n\tif (!out_map)\n\t\treturn -ENOMEM;\n\n\t/* Store the raw class and permission values */\n\tj = 0;\n\twhile (map[j].name) {\n\t\tstruct security_class_mapping *p_in = map + (j++);\n\t\tstruct selinux_mapping *p_out = out_map + j;\n\n\t\t/* An empty class string skips ahead */\n\t\tif (!strcmp(p_in->name, \"\")) {\n\t\t\tp_out->num_perms = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp_out->value = string_to_security_class(pol, p_in->name);\n\t\tif (!p_out->value) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"SELinux:  Class %s not defined in policy.\\n\",\n\t\t\t       p_in->name);\n\t\t\tif (pol->reject_unknown)\n\t\t\t\tgoto err;\n\t\t\tp_out->num_perms = 0;\n\t\t\tprint_unknown_handle = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tk = 0;\n\t\twhile (p_in->perms[k]) {\n\t\t\t/* An empty permission string skips ahead */\n\t\t\tif (!*p_in->perms[k]) {\n\t\t\t\tk++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp_out->perms[k] = string_to_av_perm(pol, p_out->value,\n\t\t\t\t\t\t\t    p_in->perms[k]);\n\t\t\tif (!p_out->perms[k]) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"SELinux:  Permission %s in class %s not defined in policy.\\n\",\n\t\t\t\t       p_in->perms[k], p_in->name);\n\t\t\t\tif (pol->reject_unknown)\n\t\t\t\t\tgoto err;\n\t\t\t\tprint_unknown_handle = true;\n\t\t\t}\n\n\t\t\tk++;\n\t\t}\n\t\tp_out->num_perms = k;\n\t}\n\n\tif (print_unknown_handle)\n\t\tprintk(KERN_INFO \"SELinux: the above unknown classes and permissions will be %s\\n\",\n\t\t       pol->allow_unknown ? \"allowed\" : \"denied\");\n\n\t*out_map_p = out_map;\n\t*out_map_size = i;\n\treturn 0;\nerr:\n\tkfree(out_map);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"initial_sid_to_string.h\"",
      "#include \"audit.h\"",
      "#include \"ebitmap.h\"",
      "#include \"xfrm.h\"",
      "#include \"netlabel.h\"",
      "#include \"objsec.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"services.h\"",
      "#include \"sidtab.h\"",
      "#include \"policydb.h\"",
      "#include \"context.h\"",
      "#include \"security.h\"",
      "#include \"avc_ss.h\"",
      "#include \"avc.h\"",
      "#include \"flask.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/selinux.h>",
      "#include <linux/mutex.h>",
      "#include <linux/audit.h>",
      "#include <linux/sched.h>",
      "#include <linux/in.h>",
      "#include <linux/errno.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct policydb policydb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "out_map"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"SELinux: the above unknown classes and permissions will be %s\\n\"",
            "pol->allow_unknown ? \"allowed\" : \"denied\""
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \"SELinux:  Permission %s in class %s not defined in policy.\\n\"",
            "p_in->perms[k]",
            "p_in->name"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_to_av_perm",
          "args": [
            "pol",
            "p_out->value",
            "p_in->perms[k]"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "string_to_av_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1815-1836",
          "snippet": "u32 string_to_av_perm(struct policydb *p, u16 tclass, const char *name)\n{\n\tstruct class_datum *cladatum;\n\tstruct perm_datum *perdatum = NULL;\n\tstruct common_datum *comdatum;\n\n\tif (!tclass || tclass > p->p_classes.nprim)\n\t\treturn 0;\n\n\tcladatum = p->class_val_to_struct[tclass-1];\n\tcomdatum = cladatum->comdatum;\n\tif (comdatum)\n\t\tperdatum = hashtab_search(comdatum->permissions.table,\n\t\t\t\t\t  name);\n\tif (!perdatum)\n\t\tperdatum = hashtab_search(cladatum->permissions.table,\n\t\t\t\t\t  name);\n\tif (!perdatum)\n\t\treturn 0;\n\n\treturn 1U << (perdatum->value-1);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nu32 string_to_av_perm(struct policydb *p, u16 tclass, const char *name)\n{\n\tstruct class_datum *cladatum;\n\tstruct perm_datum *perdatum = NULL;\n\tstruct common_datum *comdatum;\n\n\tif (!tclass || tclass > p->p_classes.nprim)\n\t\treturn 0;\n\n\tcladatum = p->class_val_to_struct[tclass-1];\n\tcomdatum = cladatum->comdatum;\n\tif (comdatum)\n\t\tperdatum = hashtab_search(comdatum->permissions.table,\n\t\t\t\t\t  name);\n\tif (!perdatum)\n\t\tperdatum = hashtab_search(cladatum->permissions.table,\n\t\t\t\t\t  name);\n\tif (!perdatum)\n\t\treturn 0;\n\n\treturn 1U << (perdatum->value-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_to_security_class",
          "args": [
            "pol",
            "p_in->name"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "string_to_security_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1804-1813",
          "snippet": "u16 string_to_security_class(struct policydb *p, const char *name)\n{\n\tstruct class_datum *cladatum;\n\n\tcladatum = hashtab_search(p->p_classes.table, name);\n\tif (!cladatum)\n\t\treturn 0;\n\n\treturn cladatum->value;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nu16 string_to_security_class(struct policydb *p, const char *name)\n{\n\tstruct class_datum *cladatum;\n\n\tcladatum = hashtab_search(p->p_classes.table, name);\n\tif (!cladatum)\n\t\treturn 0;\n\n\treturn cladatum->value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p_in->name",
            "\"\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "++i",
            "size",
            "GFP_ATOMIC"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nstatic int selinux_set_mapping(struct policydb *pol,\n\t\t\t       struct security_class_mapping *map,\n\t\t\t       struct selinux_mapping **out_map_p,\n\t\t\t       u16 *out_map_size)\n{\n\tstruct selinux_mapping *out_map = NULL;\n\tsize_t size = sizeof(struct selinux_mapping);\n\tu16 i, j;\n\tunsigned k;\n\tbool print_unknown_handle = false;\n\n\t/* Find number of classes in the input mapping */\n\tif (!map)\n\t\treturn -EINVAL;\n\ti = 0;\n\twhile (map[i].name)\n\t\ti++;\n\n\t/* Allocate space for the class records, plus one for class zero */\n\tout_map = kcalloc(++i, size, GFP_ATOMIC);\n\tif (!out_map)\n\t\treturn -ENOMEM;\n\n\t/* Store the raw class and permission values */\n\tj = 0;\n\twhile (map[j].name) {\n\t\tstruct security_class_mapping *p_in = map + (j++);\n\t\tstruct selinux_mapping *p_out = out_map + j;\n\n\t\t/* An empty class string skips ahead */\n\t\tif (!strcmp(p_in->name, \"\")) {\n\t\t\tp_out->num_perms = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp_out->value = string_to_security_class(pol, p_in->name);\n\t\tif (!p_out->value) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"SELinux:  Class %s not defined in policy.\\n\",\n\t\t\t       p_in->name);\n\t\t\tif (pol->reject_unknown)\n\t\t\t\tgoto err;\n\t\t\tp_out->num_perms = 0;\n\t\t\tprint_unknown_handle = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tk = 0;\n\t\twhile (p_in->perms[k]) {\n\t\t\t/* An empty permission string skips ahead */\n\t\t\tif (!*p_in->perms[k]) {\n\t\t\t\tk++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp_out->perms[k] = string_to_av_perm(pol, p_out->value,\n\t\t\t\t\t\t\t    p_in->perms[k]);\n\t\t\tif (!p_out->perms[k]) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"SELinux:  Permission %s in class %s not defined in policy.\\n\",\n\t\t\t\t       p_in->perms[k], p_in->name);\n\t\t\t\tif (pol->reject_unknown)\n\t\t\t\t\tgoto err;\n\t\t\t\tprint_unknown_handle = true;\n\t\t\t}\n\n\t\t\tk++;\n\t\t}\n\t\tp_out->num_perms = k;\n\t}\n\n\tif (print_unknown_handle)\n\t\tprintk(KERN_INFO \"SELinux: the above unknown classes and permissions will be %s\\n\",\n\t\t       pol->allow_unknown ? \"allowed\" : \"denied\");\n\n\t*out_map_p = out_map;\n\t*out_map_size = i;\n\treturn 0;\nerr:\n\tkfree(out_map);\n\treturn -EINVAL;\n}"
  }
]