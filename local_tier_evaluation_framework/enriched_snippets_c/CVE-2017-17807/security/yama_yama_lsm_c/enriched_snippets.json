[
  {
    "function_name": "yama_add_hooks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "485-490",
    "snippet": "void __init yama_add_hooks(void)\n{\n\tpr_info(\"Yama: becoming mindful.\\n\");\n\tsecurity_add_hooks(yama_hooks, ARRAY_SIZE(yama_hooks), \"yama\");\n\tyama_init_sysctl();\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct security_hook_list yama_hooks[] __lsm_ro_after_init = {\n\tLSM_HOOK_INIT(ptrace_access_check, yama_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, yama_ptrace_traceme),\n\tLSM_HOOK_INIT(task_prctl, yama_task_prctl),\n\tLSM_HOOK_INIT(task_free, yama_task_free),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "yama_init_sysctl",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "yama_init_sysctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
          "lines": "482-482",
          "snippet": "static inline void yama_init_sysctl(void) { }",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/task_work.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic inline void yama_init_sysctl(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "security_add_hooks",
          "args": [
            "yama_hooks",
            "ARRAY_SIZE(yama_hooks)",
            "\"yama\""
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "security_add_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "159-170",
          "snippet": "void __init security_add_hooks(struct security_hook_list *hooks, int count,\n\t\t\t\tchar *lsm)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\thooks[i].lsm = lsm;\n\t\tlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n\t}\n\tif (lsm_append(lsm, &lsm_names) < 0)\n\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *lsm_names;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nchar *lsm_names;\n\nvoid __init security_add_hooks(struct security_hook_list *hooks, int count,\n\t\t\t\tchar *lsm)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\thooks[i].lsm = lsm;\n\t\tlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n\t}\n\tif (lsm_append(lsm, &lsm_names) < 0)\n\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "yama_hooks"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Yama: becoming mindful.\\n\""
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic struct security_hook_list yama_hooks[] __lsm_ro_after_init = {\n\tLSM_HOOK_INIT(ptrace_access_check, yama_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, yama_ptrace_traceme),\n\tLSM_HOOK_INIT(task_prctl, yama_task_prctl),\n\tLSM_HOOK_INIT(task_free, yama_task_free),\n};\n\nvoid __init yama_add_hooks(void)\n{\n\tpr_info(\"Yama: becoming mindful.\\n\");\n\tsecurity_add_hooks(yama_hooks, ARRAY_SIZE(yama_hooks), \"yama\");\n\tyama_init_sysctl();\n}"
  },
  {
    "function_name": "yama_init_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "482-482",
    "snippet": "static inline void yama_init_sysctl(void) { }",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic inline void yama_init_sysctl(void) { }"
  },
  {
    "function_name": "yama_init_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "476-480",
    "snippet": "static void __init yama_init_sysctl(void)\n{\n\tif (!register_sysctl_paths(yama_sysctl_path, yama_sysctl_table))\n\t\tpanic(\"Yama: sysctl registration failed.\\n\");\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Yama: sysctl registration failed.\\n\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_sysctl_paths",
          "args": [
            "yama_sysctl_path",
            "yama_sysctl_table"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic void __init yama_init_sysctl(void)\n{\n\tif (!register_sysctl_paths(yama_sysctl_path, yama_sysctl_table))\n\t\tpanic(\"Yama: sysctl registration failed.\\n\");\n}"
  },
  {
    "function_name": "yama_dointvec_minmax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "439-453",
    "snippet": "static int yama_dointvec_minmax(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table table_copy;\n\n\tif (write && !capable(CAP_SYS_PTRACE))\n\t\treturn -EPERM;\n\n\t/* Lock the max value if it ever gets set. */\n\ttable_copy = *table;\n\tif (*(int *)table_copy.data == *(int *)table_copy.extra2)\n\t\ttable_copy.extra1 = table_copy.extra2;\n\n\treturn proc_dointvec_minmax(&table_copy, write, buffer, lenp, ppos);\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "&table_copy",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_PTRACE"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic int yama_dointvec_minmax(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table table_copy;\n\n\tif (write && !capable(CAP_SYS_PTRACE))\n\t\treturn -EPERM;\n\n\t/* Lock the max value if it ever gets set. */\n\ttable_copy = *table;\n\tif (*(int *)table_copy.data == *(int *)table_copy.extra2)\n\t\ttable_copy.extra1 = table_copy.extra2;\n\n\treturn proc_dointvec_minmax(&table_copy, write, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "yama_ptrace_traceme",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "407-429",
    "snippet": "int yama_ptrace_traceme(struct task_struct *parent)\n{\n\tint rc = 0;\n\n\t/* Only disallow PTRACE_TRACEME on more aggressive settings. */\n\tswitch (ptrace_scope) {\n\tcase YAMA_SCOPE_CAPABILITY:\n\t\tif (!has_ns_capability(parent, current_user_ns(), CAP_SYS_PTRACE))\n\t\t\trc = -EPERM;\n\t\tbreak;\n\tcase YAMA_SCOPE_NO_ATTACH:\n\t\trc = -EPERM;\n\t\tbreak;\n\t}\n\n\tif (rc) {\n\t\ttask_lock(current);\n\t\treport_access(\"traceme\", current, parent);\n\t\ttask_unlock(current);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [
      "#define YAMA_SCOPE_NO_ATTACH\t3",
      "#define YAMA_SCOPE_CAPABILITY\t2"
    ],
    "globals_used": [
      "static int ptrace_scope = YAMA_SCOPE_RELATIONAL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "current"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_access",
          "args": [
            "\"traceme\"",
            "current",
            "parent"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "report_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
          "lines": "78-113",
          "snippet": "static void report_access(const char *access, struct task_struct *target,\n\t\t\t\tstruct task_struct *agent)\n{\n\tstruct access_report_info *info;\n\tchar agent_comm[sizeof(agent->comm)];\n\n\tassert_spin_locked(&target->alloc_lock); /* for target->comm */\n\n\tif (current->flags & PF_KTHREAD) {\n\t\t/* I don't think kthreads call task_work_run() before exiting.\n\t\t * Imagine angry ranting about procfs here.\n\t\t */\n\t\tpr_notice_ratelimited(\n\t\t    \"ptrace %s of \\\"%s\\\"[%d] was attempted by \\\"%s\\\"[%d]\\n\",\n\t\t    access, target->comm, target->pid,\n\t\t    get_task_comm(agent_comm, agent), agent->pid);\n\t\treturn;\n\t}\n\n\tinfo = kmalloc(sizeof(*info), GFP_ATOMIC);\n\tif (!info)\n\t\treturn;\n\tinit_task_work(&info->work, __report_access);\n\tget_task_struct(target);\n\tget_task_struct(agent);\n\tinfo->access = access;\n\tinfo->target = target;\n\tinfo->agent = agent;\n\tif (task_work_add(current, &info->work, true) == 0)\n\t\treturn; /* success */\n\n\tWARN(1, \"report_access called from exiting task\");\n\tput_task_struct(target);\n\tput_task_struct(agent);\n\tkfree(info);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/task_work.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void yama_relation_cleanup(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic void yama_relation_cleanup(struct work_struct *work);\n\nstatic void report_access(const char *access, struct task_struct *target,\n\t\t\t\tstruct task_struct *agent)\n{\n\tstruct access_report_info *info;\n\tchar agent_comm[sizeof(agent->comm)];\n\n\tassert_spin_locked(&target->alloc_lock); /* for target->comm */\n\n\tif (current->flags & PF_KTHREAD) {\n\t\t/* I don't think kthreads call task_work_run() before exiting.\n\t\t * Imagine angry ranting about procfs here.\n\t\t */\n\t\tpr_notice_ratelimited(\n\t\t    \"ptrace %s of \\\"%s\\\"[%d] was attempted by \\\"%s\\\"[%d]\\n\",\n\t\t    access, target->comm, target->pid,\n\t\t    get_task_comm(agent_comm, agent), agent->pid);\n\t\treturn;\n\t}\n\n\tinfo = kmalloc(sizeof(*info), GFP_ATOMIC);\n\tif (!info)\n\t\treturn;\n\tinit_task_work(&info->work, __report_access);\n\tget_task_struct(target);\n\tget_task_struct(agent);\n\tinfo->access = access;\n\tinfo->target = target;\n\tinfo->agent = agent;\n\tif (task_work_add(current, &info->work, true) == 0)\n\t\treturn; /* success */\n\n\tWARN(1, \"report_access called from exiting task\");\n\tput_task_struct(target);\n\tput_task_struct(agent);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "current"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_ns_capability",
          "args": [
            "parent",
            "current_user_ns()",
            "CAP_SYS_PTRACE"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\n#define YAMA_SCOPE_NO_ATTACH\t3\n#define YAMA_SCOPE_CAPABILITY\t2\n\nstatic int ptrace_scope = YAMA_SCOPE_RELATIONAL;\n\nint yama_ptrace_traceme(struct task_struct *parent)\n{\n\tint rc = 0;\n\n\t/* Only disallow PTRACE_TRACEME on more aggressive settings. */\n\tswitch (ptrace_scope) {\n\tcase YAMA_SCOPE_CAPABILITY:\n\t\tif (!has_ns_capability(parent, current_user_ns(), CAP_SYS_PTRACE))\n\t\t\trc = -EPERM;\n\t\tbreak;\n\tcase YAMA_SCOPE_NO_ATTACH:\n\t\trc = -EPERM;\n\t\tbreak;\n\t}\n\n\tif (rc) {\n\t\ttask_lock(current);\n\t\treport_access(\"traceme\", current, parent);\n\t\ttask_unlock(current);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "yama_ptrace_access_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "363-399",
    "snippet": "static int yama_ptrace_access_check(struct task_struct *child,\n\t\t\t\t    unsigned int mode)\n{\n\tint rc = 0;\n\n\t/* require ptrace target be a child of ptracer on attach */\n\tif (mode & PTRACE_MODE_ATTACH) {\n\t\tswitch (ptrace_scope) {\n\t\tcase YAMA_SCOPE_DISABLED:\n\t\t\t/* No additional restrictions. */\n\t\t\tbreak;\n\t\tcase YAMA_SCOPE_RELATIONAL:\n\t\t\trcu_read_lock();\n\t\t\tif (!task_is_descendant(current, child) &&\n\t\t\t    !ptracer_exception_found(current, child) &&\n\t\t\t    !ns_capable(__task_cred(child)->user_ns, CAP_SYS_PTRACE))\n\t\t\t\trc = -EPERM;\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase YAMA_SCOPE_CAPABILITY:\n\t\t\trcu_read_lock();\n\t\t\tif (!ns_capable(__task_cred(child)->user_ns, CAP_SYS_PTRACE))\n\t\t\t\trc = -EPERM;\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase YAMA_SCOPE_NO_ATTACH:\n\t\tdefault:\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rc && (mode & PTRACE_MODE_NOAUDIT) == 0)\n\t\treport_access(\"attach\", child, current);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [
      "#define YAMA_SCOPE_NO_ATTACH\t3",
      "#define YAMA_SCOPE_CAPABILITY\t2",
      "#define YAMA_SCOPE_RELATIONAL\t1",
      "#define YAMA_SCOPE_DISABLED\t0"
    ],
    "globals_used": [
      "static int ptrace_scope = YAMA_SCOPE_RELATIONAL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "report_access",
          "args": [
            "\"attach\"",
            "child",
            "current"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "report_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
          "lines": "78-113",
          "snippet": "static void report_access(const char *access, struct task_struct *target,\n\t\t\t\tstruct task_struct *agent)\n{\n\tstruct access_report_info *info;\n\tchar agent_comm[sizeof(agent->comm)];\n\n\tassert_spin_locked(&target->alloc_lock); /* for target->comm */\n\n\tif (current->flags & PF_KTHREAD) {\n\t\t/* I don't think kthreads call task_work_run() before exiting.\n\t\t * Imagine angry ranting about procfs here.\n\t\t */\n\t\tpr_notice_ratelimited(\n\t\t    \"ptrace %s of \\\"%s\\\"[%d] was attempted by \\\"%s\\\"[%d]\\n\",\n\t\t    access, target->comm, target->pid,\n\t\t    get_task_comm(agent_comm, agent), agent->pid);\n\t\treturn;\n\t}\n\n\tinfo = kmalloc(sizeof(*info), GFP_ATOMIC);\n\tif (!info)\n\t\treturn;\n\tinit_task_work(&info->work, __report_access);\n\tget_task_struct(target);\n\tget_task_struct(agent);\n\tinfo->access = access;\n\tinfo->target = target;\n\tinfo->agent = agent;\n\tif (task_work_add(current, &info->work, true) == 0)\n\t\treturn; /* success */\n\n\tWARN(1, \"report_access called from exiting task\");\n\tput_task_struct(target);\n\tput_task_struct(agent);\n\tkfree(info);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/task_work.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void yama_relation_cleanup(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic void yama_relation_cleanup(struct work_struct *work);\n\nstatic void report_access(const char *access, struct task_struct *target,\n\t\t\t\tstruct task_struct *agent)\n{\n\tstruct access_report_info *info;\n\tchar agent_comm[sizeof(agent->comm)];\n\n\tassert_spin_locked(&target->alloc_lock); /* for target->comm */\n\n\tif (current->flags & PF_KTHREAD) {\n\t\t/* I don't think kthreads call task_work_run() before exiting.\n\t\t * Imagine angry ranting about procfs here.\n\t\t */\n\t\tpr_notice_ratelimited(\n\t\t    \"ptrace %s of \\\"%s\\\"[%d] was attempted by \\\"%s\\\"[%d]\\n\",\n\t\t    access, target->comm, target->pid,\n\t\t    get_task_comm(agent_comm, agent), agent->pid);\n\t\treturn;\n\t}\n\n\tinfo = kmalloc(sizeof(*info), GFP_ATOMIC);\n\tif (!info)\n\t\treturn;\n\tinit_task_work(&info->work, __report_access);\n\tget_task_struct(target);\n\tget_task_struct(agent);\n\tinfo->access = access;\n\tinfo->target = target;\n\tinfo->agent = agent;\n\tif (task_work_add(current, &info->work, true) == 0)\n\t\treturn; /* success */\n\n\tWARN(1, \"report_access called from exiting task\");\n\tput_task_struct(target);\n\tput_task_struct(agent);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "__task_cred(child)->user_ns",
            "CAP_SYS_PTRACE"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "child"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "__task_cred(child)->user_ns",
            "CAP_SYS_PTRACE"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "child"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptracer_exception_found",
          "args": [
            "current",
            "child"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "ptracer_exception_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
          "lines": "314-354",
          "snippet": "static int ptracer_exception_found(struct task_struct *tracer,\n\t\t\t\t   struct task_struct *tracee)\n{\n\tint rc = 0;\n\tstruct ptrace_relation *relation;\n\tstruct task_struct *parent = NULL;\n\tbool found = false;\n\n\trcu_read_lock();\n\n\t/*\n\t * If there's already an active tracing relationship, then make an\n\t * exception for the sake of other accesses, like process_vm_rw().\n\t */\n\tparent = ptrace_parent(tracee);\n\tif (parent != NULL && same_thread_group(parent, tracer)) {\n\t\trc = 1;\n\t\tgoto unlock;\n\t}\n\n\t/* Look for a PR_SET_PTRACER relationship. */\n\tif (!thread_group_leader(tracee))\n\t\ttracee = rcu_dereference(tracee->group_leader);\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee) {\n\t\t\tparent = relation->tracer;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found && (parent == NULL || task_is_descendant(parent, tracer)))\n\t\trc = 1;\n\nunlock:\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/task_work.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ptracer_relations);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic LIST_HEAD(ptracer_relations);\n\nstatic int ptracer_exception_found(struct task_struct *tracer,\n\t\t\t\t   struct task_struct *tracee)\n{\n\tint rc = 0;\n\tstruct ptrace_relation *relation;\n\tstruct task_struct *parent = NULL;\n\tbool found = false;\n\n\trcu_read_lock();\n\n\t/*\n\t * If there's already an active tracing relationship, then make an\n\t * exception for the sake of other accesses, like process_vm_rw().\n\t */\n\tparent = ptrace_parent(tracee);\n\tif (parent != NULL && same_thread_group(parent, tracer)) {\n\t\trc = 1;\n\t\tgoto unlock;\n\t}\n\n\t/* Look for a PR_SET_PTRACER relationship. */\n\tif (!thread_group_leader(tracee))\n\t\ttracee = rcu_dereference(tracee->group_leader);\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee) {\n\t\t\tparent = relation->tracer;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found && (parent == NULL || task_is_descendant(parent, tracer)))\n\t\trc = 1;\n\nunlock:\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_is_descendant",
          "args": [
            "current",
            "child"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "task_is_descendant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
          "lines": "281-305",
          "snippet": "static int task_is_descendant(struct task_struct *parent,\n\t\t\t      struct task_struct *child)\n{\n\tint rc = 0;\n\tstruct task_struct *walker = child;\n\n\tif (!parent || !child)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tif (!thread_group_leader(parent))\n\t\tparent = rcu_dereference(parent->group_leader);\n\twhile (walker->pid > 0) {\n\t\tif (!thread_group_leader(walker))\n\t\t\twalker = rcu_dereference(walker->group_leader);\n\t\tif (walker == parent) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t\twalker = rcu_dereference(walker->real_parent);\n\t}\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/task_work.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic int task_is_descendant(struct task_struct *parent,\n\t\t\t      struct task_struct *child)\n{\n\tint rc = 0;\n\tstruct task_struct *walker = child;\n\n\tif (!parent || !child)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tif (!thread_group_leader(parent))\n\t\tparent = rcu_dereference(parent->group_leader);\n\twhile (walker->pid > 0) {\n\t\tif (!thread_group_leader(walker))\n\t\t\twalker = rcu_dereference(walker->group_leader);\n\t\tif (walker == parent) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t\twalker = rcu_dereference(walker->real_parent);\n\t}\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\n#define YAMA_SCOPE_NO_ATTACH\t3\n#define YAMA_SCOPE_CAPABILITY\t2\n#define YAMA_SCOPE_RELATIONAL\t1\n#define YAMA_SCOPE_DISABLED\t0\n\nstatic int ptrace_scope = YAMA_SCOPE_RELATIONAL;\n\nstatic int yama_ptrace_access_check(struct task_struct *child,\n\t\t\t\t    unsigned int mode)\n{\n\tint rc = 0;\n\n\t/* require ptrace target be a child of ptracer on attach */\n\tif (mode & PTRACE_MODE_ATTACH) {\n\t\tswitch (ptrace_scope) {\n\t\tcase YAMA_SCOPE_DISABLED:\n\t\t\t/* No additional restrictions. */\n\t\t\tbreak;\n\t\tcase YAMA_SCOPE_RELATIONAL:\n\t\t\trcu_read_lock();\n\t\t\tif (!task_is_descendant(current, child) &&\n\t\t\t    !ptracer_exception_found(current, child) &&\n\t\t\t    !ns_capable(__task_cred(child)->user_ns, CAP_SYS_PTRACE))\n\t\t\t\trc = -EPERM;\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase YAMA_SCOPE_CAPABILITY:\n\t\t\trcu_read_lock();\n\t\t\tif (!ns_capable(__task_cred(child)->user_ns, CAP_SYS_PTRACE))\n\t\t\t\trc = -EPERM;\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\tcase YAMA_SCOPE_NO_ATTACH:\n\t\tdefault:\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rc && (mode & PTRACE_MODE_NOAUDIT) == 0)\n\t\treport_access(\"attach\", child, current);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ptracer_exception_found",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "314-354",
    "snippet": "static int ptracer_exception_found(struct task_struct *tracer,\n\t\t\t\t   struct task_struct *tracee)\n{\n\tint rc = 0;\n\tstruct ptrace_relation *relation;\n\tstruct task_struct *parent = NULL;\n\tbool found = false;\n\n\trcu_read_lock();\n\n\t/*\n\t * If there's already an active tracing relationship, then make an\n\t * exception for the sake of other accesses, like process_vm_rw().\n\t */\n\tparent = ptrace_parent(tracee);\n\tif (parent != NULL && same_thread_group(parent, tracer)) {\n\t\trc = 1;\n\t\tgoto unlock;\n\t}\n\n\t/* Look for a PR_SET_PTRACER relationship. */\n\tif (!thread_group_leader(tracee))\n\t\ttracee = rcu_dereference(tracee->group_leader);\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee) {\n\t\t\tparent = relation->tracer;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found && (parent == NULL || task_is_descendant(parent, tracer)))\n\t\trc = 1;\n\nunlock:\n\trcu_read_unlock();\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ptracer_relations);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_is_descendant",
          "args": [
            "parent",
            "tracer"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "task_is_descendant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
          "lines": "281-305",
          "snippet": "static int task_is_descendant(struct task_struct *parent,\n\t\t\t      struct task_struct *child)\n{\n\tint rc = 0;\n\tstruct task_struct *walker = child;\n\n\tif (!parent || !child)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tif (!thread_group_leader(parent))\n\t\tparent = rcu_dereference(parent->group_leader);\n\twhile (walker->pid > 0) {\n\t\tif (!thread_group_leader(walker))\n\t\t\twalker = rcu_dereference(walker->group_leader);\n\t\tif (walker == parent) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t\twalker = rcu_dereference(walker->real_parent);\n\t}\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/task_work.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic int task_is_descendant(struct task_struct *parent,\n\t\t\t      struct task_struct *child)\n{\n\tint rc = 0;\n\tstruct task_struct *walker = child;\n\n\tif (!parent || !child)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tif (!thread_group_leader(parent))\n\t\tparent = rcu_dereference(parent->group_leader);\n\twhile (walker->pid > 0) {\n\t\tif (!thread_group_leader(walker))\n\t\t\twalker = rcu_dereference(walker->group_leader);\n\t\tif (walker == parent) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t\twalker = rcu_dereference(walker->real_parent);\n\t}\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "relation",
            "&ptracer_relations",
            "node"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "tracee->group_leader"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tracee"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "parent",
            "tracer"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_parent",
          "args": [
            "tracee"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic LIST_HEAD(ptracer_relations);\n\nstatic int ptracer_exception_found(struct task_struct *tracer,\n\t\t\t\t   struct task_struct *tracee)\n{\n\tint rc = 0;\n\tstruct ptrace_relation *relation;\n\tstruct task_struct *parent = NULL;\n\tbool found = false;\n\n\trcu_read_lock();\n\n\t/*\n\t * If there's already an active tracing relationship, then make an\n\t * exception for the sake of other accesses, like process_vm_rw().\n\t */\n\tparent = ptrace_parent(tracee);\n\tif (parent != NULL && same_thread_group(parent, tracer)) {\n\t\trc = 1;\n\t\tgoto unlock;\n\t}\n\n\t/* Look for a PR_SET_PTRACER relationship. */\n\tif (!thread_group_leader(tracee))\n\t\ttracee = rcu_dereference(tracee->group_leader);\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee) {\n\t\t\tparent = relation->tracer;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found && (parent == NULL || task_is_descendant(parent, tracer)))\n\t\trc = 1;\n\nunlock:\n\trcu_read_unlock();\n\n\treturn rc;\n}"
  },
  {
    "function_name": "task_is_descendant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "281-305",
    "snippet": "static int task_is_descendant(struct task_struct *parent,\n\t\t\t      struct task_struct *child)\n{\n\tint rc = 0;\n\tstruct task_struct *walker = child;\n\n\tif (!parent || !child)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tif (!thread_group_leader(parent))\n\t\tparent = rcu_dereference(parent->group_leader);\n\twhile (walker->pid > 0) {\n\t\tif (!thread_group_leader(walker))\n\t\t\twalker = rcu_dereference(walker->group_leader);\n\t\tif (walker == parent) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t\twalker = rcu_dereference(walker->real_parent);\n\t}\n\trcu_read_unlock();\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "walker->real_parent"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "walker->group_leader"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "walker"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "parent->group_leader"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "parent"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic int task_is_descendant(struct task_struct *parent,\n\t\t\t      struct task_struct *child)\n{\n\tint rc = 0;\n\tstruct task_struct *walker = child;\n\n\tif (!parent || !child)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tif (!thread_group_leader(parent))\n\t\tparent = rcu_dereference(parent->group_leader);\n\twhile (walker->pid > 0) {\n\t\tif (!thread_group_leader(walker))\n\t\t\twalker = rcu_dereference(walker->group_leader);\n\t\tif (walker == parent) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t\twalker = rcu_dereference(walker->real_parent);\n\t}\n\trcu_read_unlock();\n\n\treturn rc;\n}"
  },
  {
    "function_name": "yama_task_prctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "225-272",
    "snippet": "int yama_task_prctl(int option, unsigned long arg2, unsigned long arg3,\n\t\t\t   unsigned long arg4, unsigned long arg5)\n{\n\tint rc = -ENOSYS;\n\tstruct task_struct *myself = current;\n\n\tswitch (option) {\n\tcase PR_SET_PTRACER:\n\t\t/* Since a thread can call prctl(), find the group leader\n\t\t * before calling _add() or _del() on it, since we want\n\t\t * process-level granularity of control. The tracer group\n\t\t * leader checking is handled later when walking the ancestry\n\t\t * at the time of PTRACE_ATTACH check.\n\t\t */\n\t\trcu_read_lock();\n\t\tif (!thread_group_leader(myself))\n\t\t\tmyself = rcu_dereference(myself->group_leader);\n\t\tget_task_struct(myself);\n\t\trcu_read_unlock();\n\n\t\tif (arg2 == 0) {\n\t\t\tyama_ptracer_del(NULL, myself);\n\t\t\trc = 0;\n\t\t} else if (arg2 == PR_SET_PTRACER_ANY || (int)arg2 == -1) {\n\t\t\trc = yama_ptracer_add(NULL, myself);\n\t\t} else {\n\t\t\tstruct task_struct *tracer;\n\n\t\t\trcu_read_lock();\n\t\t\ttracer = find_task_by_vpid(arg2);\n\t\t\tif (tracer)\n\t\t\t\tget_task_struct(tracer);\n\t\t\telse\n\t\t\t\trc = -EINVAL;\n\t\t\trcu_read_unlock();\n\n\t\t\tif (tracer) {\n\t\t\t\trc = yama_ptracer_add(tracer, myself);\n\t\t\t\tput_task_struct(tracer);\n\t\t\t}\n\t\t}\n\n\t\tput_task_struct(myself);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "myself"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "tracer"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yama_ptracer_add",
          "args": [
            "tracer",
            "myself"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "yama_ptracer_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
          "lines": "145-176",
          "snippet": "static int yama_ptracer_add(struct task_struct *tracer,\n\t\t\t    struct task_struct *tracee)\n{\n\tstruct ptrace_relation *relation, *added;\n\n\tadded = kmalloc(sizeof(*added), GFP_KERNEL);\n\tif (!added)\n\t\treturn -ENOMEM;\n\n\tadded->tracee = tracee;\n\tadded->tracer = tracer;\n\tadded->invalid = false;\n\n\tspin_lock(&ptracer_relations_lock);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee) {\n\t\t\tlist_replace_rcu(&relation->node, &added->node);\n\t\t\tkfree_rcu(relation, rcu);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add_rcu(&added->node, &ptracer_relations);\n\nout:\n\trcu_read_unlock();\n\tspin_unlock(&ptracer_relations_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/task_work.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ptracer_relations);",
            "static DEFINE_SPINLOCK(ptracer_relations_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic LIST_HEAD(ptracer_relations);\nstatic DEFINE_SPINLOCK(ptracer_relations_lock);\n\nstatic int yama_ptracer_add(struct task_struct *tracer,\n\t\t\t    struct task_struct *tracee)\n{\n\tstruct ptrace_relation *relation, *added;\n\n\tadded = kmalloc(sizeof(*added), GFP_KERNEL);\n\tif (!added)\n\t\treturn -ENOMEM;\n\n\tadded->tracee = tracee;\n\tadded->tracer = tracer;\n\tadded->invalid = false;\n\n\tspin_lock(&ptracer_relations_lock);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee) {\n\t\t\tlist_replace_rcu(&relation->node, &added->node);\n\t\t\tkfree_rcu(relation, rcu);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add_rcu(&added->node, &ptracer_relations);\n\nout:\n\trcu_read_unlock();\n\tspin_unlock(&ptracer_relations_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "tracer"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "arg2"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yama_ptracer_del",
          "args": [
            "NULL",
            "myself"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "yama_ptracer_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
          "lines": "183-203",
          "snippet": "static void yama_ptracer_del(struct task_struct *tracer,\n\t\t\t     struct task_struct *tracee)\n{\n\tstruct ptrace_relation *relation;\n\tbool marked = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee ||\n\t\t    (tracer && relation->tracer == tracer)) {\n\t\t\trelation->invalid = true;\n\t\t\tmarked = true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (marked)\n\t\tschedule_work(&yama_relation_work);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/task_work.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ptracer_relations);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic LIST_HEAD(ptracer_relations);\n\nstatic void yama_ptracer_del(struct task_struct *tracer,\n\t\t\t     struct task_struct *tracee)\n{\n\tstruct ptrace_relation *relation;\n\tbool marked = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee ||\n\t\t    (tracer && relation->tracer == tracer)) {\n\t\t\trelation->invalid = true;\n\t\t\tmarked = true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (marked)\n\t\tschedule_work(&yama_relation_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "myself"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "myself->group_leader"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "myself"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nint yama_task_prctl(int option, unsigned long arg2, unsigned long arg3,\n\t\t\t   unsigned long arg4, unsigned long arg5)\n{\n\tint rc = -ENOSYS;\n\tstruct task_struct *myself = current;\n\n\tswitch (option) {\n\tcase PR_SET_PTRACER:\n\t\t/* Since a thread can call prctl(), find the group leader\n\t\t * before calling _add() or _del() on it, since we want\n\t\t * process-level granularity of control. The tracer group\n\t\t * leader checking is handled later when walking the ancestry\n\t\t * at the time of PTRACE_ATTACH check.\n\t\t */\n\t\trcu_read_lock();\n\t\tif (!thread_group_leader(myself))\n\t\t\tmyself = rcu_dereference(myself->group_leader);\n\t\tget_task_struct(myself);\n\t\trcu_read_unlock();\n\n\t\tif (arg2 == 0) {\n\t\t\tyama_ptracer_del(NULL, myself);\n\t\t\trc = 0;\n\t\t} else if (arg2 == PR_SET_PTRACER_ANY || (int)arg2 == -1) {\n\t\t\trc = yama_ptracer_add(NULL, myself);\n\t\t} else {\n\t\t\tstruct task_struct *tracer;\n\n\t\t\trcu_read_lock();\n\t\t\ttracer = find_task_by_vpid(arg2);\n\t\t\tif (tracer)\n\t\t\t\tget_task_struct(tracer);\n\t\t\telse\n\t\t\t\trc = -EINVAL;\n\t\t\trcu_read_unlock();\n\n\t\t\tif (tracer) {\n\t\t\t\trc = yama_ptracer_add(tracer, myself);\n\t\t\t\tput_task_struct(tracer);\n\t\t\t}\n\t\t}\n\n\t\tput_task_struct(myself);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "yama_task_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "209-212",
    "snippet": "void yama_task_free(struct task_struct *task)\n{\n\tyama_ptracer_del(task, task);\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "yama_ptracer_del",
          "args": [
            "task",
            "task"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "yama_ptracer_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
          "lines": "183-203",
          "snippet": "static void yama_ptracer_del(struct task_struct *tracer,\n\t\t\t     struct task_struct *tracee)\n{\n\tstruct ptrace_relation *relation;\n\tbool marked = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee ||\n\t\t    (tracer && relation->tracer == tracer)) {\n\t\t\trelation->invalid = true;\n\t\t\tmarked = true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (marked)\n\t\tschedule_work(&yama_relation_work);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/task_work.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ptracer_relations);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic LIST_HEAD(ptracer_relations);\n\nstatic void yama_ptracer_del(struct task_struct *tracer,\n\t\t\t     struct task_struct *tracee)\n{\n\tstruct ptrace_relation *relation;\n\tbool marked = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee ||\n\t\t    (tracer && relation->tracer == tracer)) {\n\t\t\trelation->invalid = true;\n\t\t\tmarked = true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (marked)\n\t\tschedule_work(&yama_relation_work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nvoid yama_task_free(struct task_struct *task)\n{\n\tyama_ptracer_del(task, task);\n}"
  },
  {
    "function_name": "yama_ptracer_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "183-203",
    "snippet": "static void yama_ptracer_del(struct task_struct *tracer,\n\t\t\t     struct task_struct *tracee)\n{\n\tstruct ptrace_relation *relation;\n\tbool marked = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee ||\n\t\t    (tracer && relation->tracer == tracer)) {\n\t\t\trelation->invalid = true;\n\t\t\tmarked = true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (marked)\n\t\tschedule_work(&yama_relation_work);\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ptracer_relations);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&yama_relation_work"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "relation",
            "&ptracer_relations",
            "node"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic LIST_HEAD(ptracer_relations);\n\nstatic void yama_ptracer_del(struct task_struct *tracer,\n\t\t\t     struct task_struct *tracee)\n{\n\tstruct ptrace_relation *relation;\n\tbool marked = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee ||\n\t\t    (tracer && relation->tracer == tracer)) {\n\t\t\trelation->invalid = true;\n\t\t\tmarked = true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (marked)\n\t\tschedule_work(&yama_relation_work);\n}"
  },
  {
    "function_name": "yama_ptracer_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "145-176",
    "snippet": "static int yama_ptracer_add(struct task_struct *tracer,\n\t\t\t    struct task_struct *tracee)\n{\n\tstruct ptrace_relation *relation, *added;\n\n\tadded = kmalloc(sizeof(*added), GFP_KERNEL);\n\tif (!added)\n\t\treturn -ENOMEM;\n\n\tadded->tracee = tracee;\n\tadded->tracer = tracer;\n\tadded->invalid = false;\n\n\tspin_lock(&ptracer_relations_lock);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee) {\n\t\t\tlist_replace_rcu(&relation->node, &added->node);\n\t\t\tkfree_rcu(relation, rcu);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add_rcu(&added->node, &ptracer_relations);\n\nout:\n\trcu_read_unlock();\n\tspin_unlock(&ptracer_relations_lock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ptracer_relations);",
      "static DEFINE_SPINLOCK(ptracer_relations_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ptracer_relations_lock"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&added->node",
            "&ptracer_relations"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "relation",
            "rcu"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_rcu",
          "args": [
            "&relation->node",
            "&added->node"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "relation",
            "&ptracer_relations",
            "node"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ptracer_relations_lock"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*added)",
            "GFP_KERNEL"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic LIST_HEAD(ptracer_relations);\nstatic DEFINE_SPINLOCK(ptracer_relations_lock);\n\nstatic int yama_ptracer_add(struct task_struct *tracer,\n\t\t\t    struct task_struct *tracee)\n{\n\tstruct ptrace_relation *relation, *added;\n\n\tadded = kmalloc(sizeof(*added), GFP_KERNEL);\n\tif (!added)\n\t\treturn -ENOMEM;\n\n\tadded->tracee = tracee;\n\tadded->tracer = tracer;\n\tadded->invalid = false;\n\n\tspin_lock(&ptracer_relations_lock);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid)\n\t\t\tcontinue;\n\t\tif (relation->tracee == tracee) {\n\t\t\tlist_replace_rcu(&relation->node, &added->node);\n\t\t\tkfree_rcu(relation, rcu);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add_rcu(&added->node, &ptracer_relations);\n\nout:\n\trcu_read_unlock();\n\tspin_unlock(&ptracer_relations_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "yama_relation_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "119-133",
    "snippet": "static void yama_relation_cleanup(struct work_struct *work)\n{\n\tstruct ptrace_relation *relation;\n\n\tspin_lock(&ptracer_relations_lock);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid) {\n\t\t\tlist_del_rcu(&relation->node);\n\t\t\tkfree_rcu(relation, rcu);\n\t\t}\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&ptracer_relations_lock);\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ptracer_relations);",
      "static DEFINE_SPINLOCK(ptracer_relations_lock);",
      "static void yama_relation_cleanup(struct work_struct *work);",
      "static DECLARE_WORK(yama_relation_work, yama_relation_cleanup);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ptracer_relations_lock"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "relation",
            "rcu"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&relation->node"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "relation",
            "&ptracer_relations",
            "node"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ptracer_relations_lock"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic LIST_HEAD(ptracer_relations);\nstatic DEFINE_SPINLOCK(ptracer_relations_lock);\nstatic void yama_relation_cleanup(struct work_struct *work);\nstatic DECLARE_WORK(yama_relation_work, yama_relation_cleanup);\n\nstatic void yama_relation_cleanup(struct work_struct *work)\n{\n\tstruct ptrace_relation *relation;\n\n\tspin_lock(&ptracer_relations_lock);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(relation, &ptracer_relations, node) {\n\t\tif (relation->invalid) {\n\t\t\tlist_del_rcu(&relation->node);\n\t\t\tkfree_rcu(relation, rcu);\n\t\t}\n\t}\n\trcu_read_unlock();\n\tspin_unlock(&ptracer_relations_lock);\n}"
  },
  {
    "function_name": "report_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "78-113",
    "snippet": "static void report_access(const char *access, struct task_struct *target,\n\t\t\t\tstruct task_struct *agent)\n{\n\tstruct access_report_info *info;\n\tchar agent_comm[sizeof(agent->comm)];\n\n\tassert_spin_locked(&target->alloc_lock); /* for target->comm */\n\n\tif (current->flags & PF_KTHREAD) {\n\t\t/* I don't think kthreads call task_work_run() before exiting.\n\t\t * Imagine angry ranting about procfs here.\n\t\t */\n\t\tpr_notice_ratelimited(\n\t\t    \"ptrace %s of \\\"%s\\\"[%d] was attempted by \\\"%s\\\"[%d]\\n\",\n\t\t    access, target->comm, target->pid,\n\t\t    get_task_comm(agent_comm, agent), agent->pid);\n\t\treturn;\n\t}\n\n\tinfo = kmalloc(sizeof(*info), GFP_ATOMIC);\n\tif (!info)\n\t\treturn;\n\tinit_task_work(&info->work, __report_access);\n\tget_task_struct(target);\n\tget_task_struct(agent);\n\tinfo->access = access;\n\tinfo->target = target;\n\tinfo->agent = agent;\n\tif (task_work_add(current, &info->work, true) == 0)\n\t\treturn; /* success */\n\n\tWARN(1, \"report_access called from exiting task\");\n\tput_task_struct(target);\n\tput_task_struct(agent);\n\tkfree(info);\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void yama_relation_cleanup(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "agent"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "target"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"report_access called from exiting task\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_work_add",
          "args": [
            "current",
            "&info->work",
            "true"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "agent"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "target"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_task_work",
          "args": [
            "&info->work",
            "__report_access"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*info)",
            "GFP_ATOMIC"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice_ratelimited",
          "args": [
            "\"ptrace %s of \\\"%s\\\"[%d] was attempted by \\\"%s\\\"[%d]\\n\"",
            "access",
            "target->comm",
            "target->pid",
            "get_task_comm(agent_comm, agent)",
            "agent->pid"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_comm",
          "args": [
            "agent_comm",
            "agent"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&target->alloc_lock"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic void yama_relation_cleanup(struct work_struct *work);\n\nstatic void report_access(const char *access, struct task_struct *target,\n\t\t\t\tstruct task_struct *agent)\n{\n\tstruct access_report_info *info;\n\tchar agent_comm[sizeof(agent->comm)];\n\n\tassert_spin_locked(&target->alloc_lock); /* for target->comm */\n\n\tif (current->flags & PF_KTHREAD) {\n\t\t/* I don't think kthreads call task_work_run() before exiting.\n\t\t * Imagine angry ranting about procfs here.\n\t\t */\n\t\tpr_notice_ratelimited(\n\t\t    \"ptrace %s of \\\"%s\\\"[%d] was attempted by \\\"%s\\\"[%d]\\n\",\n\t\t    access, target->comm, target->pid,\n\t\t    get_task_comm(agent_comm, agent), agent->pid);\n\t\treturn;\n\t}\n\n\tinfo = kmalloc(sizeof(*info), GFP_ATOMIC);\n\tif (!info)\n\t\treturn;\n\tinit_task_work(&info->work, __report_access);\n\tget_task_struct(target);\n\tget_task_struct(agent);\n\tinfo->access = access;\n\tinfo->target = target;\n\tinfo->agent = agent;\n\tif (task_work_add(current, &info->work, true) == 0)\n\t\treturn; /* success */\n\n\tWARN(1, \"report_access called from exiting task\");\n\tput_task_struct(target);\n\tput_task_struct(agent);\n\tkfree(info);\n}"
  },
  {
    "function_name": "__report_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/yama/yama_lsm.c",
    "lines": "55-75",
    "snippet": "static void __report_access(struct callback_head *work)\n{\n\tstruct access_report_info *info =\n\t\tcontainer_of(work, struct access_report_info, work);\n\tchar *target_cmd, *agent_cmd;\n\n\ttarget_cmd = kstrdup_quotable_cmdline(info->target, GFP_KERNEL);\n\tagent_cmd = kstrdup_quotable_cmdline(info->agent, GFP_KERNEL);\n\n\tpr_notice_ratelimited(\n\t\t\"ptrace %s of \\\"%s\\\"[%d] was attempted by \\\"%s\\\"[%d]\\n\",\n\t\tinfo->access, target_cmd, info->target->pid, agent_cmd,\n\t\tinfo->agent->pid);\n\n\tkfree(agent_cmd);\n\tkfree(target_cmd);\n\n\tput_task_struct(info->agent);\n\tput_task_struct(info->target);\n\tkfree(info);\n}",
    "includes": [
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/task_work.h>",
      "#include <linux/string_helpers.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/prctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void yama_relation_cleanup(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "info->target"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "info->agent"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "target_cmd"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "agent_cmd"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice_ratelimited",
          "args": [
            "\"ptrace %s of \\\"%s\\\"[%d] was attempted by \\\"%s\\\"[%d]\\n\"",
            "info->access",
            "target_cmd",
            "info->target->pid",
            "agent_cmd",
            "info->agent->pid"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup_quotable_cmdline",
          "args": [
            "info->agent",
            "GFP_KERNEL"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup_quotable_cmdline",
          "args": [
            "info->target",
            "GFP_KERNEL"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structaccess_report_info",
            "work"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/task_work.h>\n#include <linux/string_helpers.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/prctl.h>\n#include <linux/ptrace.h>\n#include <linux/sysctl.h>\n#include <linux/lsm_hooks.h>\n\nstatic void yama_relation_cleanup(struct work_struct *work);\n\nstatic void __report_access(struct callback_head *work)\n{\n\tstruct access_report_info *info =\n\t\tcontainer_of(work, struct access_report_info, work);\n\tchar *target_cmd, *agent_cmd;\n\n\ttarget_cmd = kstrdup_quotable_cmdline(info->target, GFP_KERNEL);\n\tagent_cmd = kstrdup_quotable_cmdline(info->agent, GFP_KERNEL);\n\n\tpr_notice_ratelimited(\n\t\t\"ptrace %s of \\\"%s\\\"[%d] was attempted by \\\"%s\\\"[%d]\\n\",\n\t\tinfo->access, target_cmd, info->target->pid, agent_cmd,\n\t\tinfo->agent->pid);\n\n\tkfree(agent_cmd);\n\tkfree(target_cmd);\n\n\tput_task_struct(info->agent);\n\tput_task_struct(info->target);\n\tkfree(info);\n}"
  }
]