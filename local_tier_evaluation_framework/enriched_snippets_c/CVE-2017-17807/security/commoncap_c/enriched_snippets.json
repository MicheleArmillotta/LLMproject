[
  {
    "function_name": "capability_add_hooks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "1366-1370",
    "snippet": "void __init capability_add_hooks(void)\n{\n\tsecurity_add_hooks(capability_hooks, ARRAY_SIZE(capability_hooks),\n\t\t\t\t\"capability\");\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_add_hooks",
          "args": [
            "capability_hooks",
            "ARRAY_SIZE(capability_hooks)",
            "\"capability\""
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "security_add_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "159-170",
          "snippet": "void __init security_add_hooks(struct security_hook_list *hooks, int count,\n\t\t\t\tchar *lsm)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\thooks[i].lsm = lsm;\n\t\tlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n\t}\n\tif (lsm_append(lsm, &lsm_names) < 0)\n\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *lsm_names;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nchar *lsm_names;\n\nvoid __init security_add_hooks(struct security_hook_list *hooks, int count,\n\t\t\t\tchar *lsm)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\thooks[i].lsm = lsm;\n\t\tlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n\t}\n\tif (lsm_append(lsm, &lsm_names) < 0)\n\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "capability_hooks"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nvoid __init capability_add_hooks(void)\n{\n\tsecurity_add_hooks(capability_hooks, ARRAY_SIZE(capability_hooks),\n\t\t\t\t\"capability\");\n}"
  },
  {
    "function_name": "cap_mmap_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "1337-1341",
    "snippet": "int cap_mmap_file(struct file *file, unsigned long reqprot,\n\t\t  unsigned long prot, unsigned long flags)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_mmap_file(struct file *file, unsigned long reqprot,\n\t\t  unsigned long prot, unsigned long flags)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "cap_mmap_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "1323-1335",
    "snippet": "int cap_mmap_addr(unsigned long addr)\n{\n\tint ret = 0;\n\n\tif (addr < dac_mmap_min_addr) {\n\t\tret = cap_capable(current_cred(), &init_user_ns, CAP_SYS_RAWIO,\n\t\t\t\t  SECURITY_CAP_AUDIT);\n\t\t/* set PF_SUPERPRIV if it turns out we allow the low mmap */\n\t\tif (ret == 0)\n\t\t\tcurrent->flags |= PF_SUPERPRIV;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap_capable",
          "args": [
            "current_cred()",
            "&init_user_ns",
            "CAP_SYS_RAWIO",
            "SECURITY_CAP_AUDIT"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "cap_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "71-107",
          "snippet": "int cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, int audit)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t/* See if cred has the capability in the target user namespace\n\t * by examining the target user namespace and all of the target\n\t * user namespace's parents.\n\t */\n\tfor (;;) {\n\t\t/* Do we have the necessary capabilities? */\n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t/*\n\t\t * If we're already at a lower level than we're looking for,\n\t\t * we're done searching.\n\t\t */\n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t/* \n\t\t * The owner of the user namespace in the parent of the\n\t\t * user namespace has all caps.\n\t\t */\n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If you have a capability in a parent user ns, then you have\n\t\t * it over all children user namespaces as well.\n\t\t */\n\t\tns = ns->parent;\n\t}\n\n\t/* We never get here */\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, int audit)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t/* See if cred has the capability in the target user namespace\n\t * by examining the target user namespace and all of the target\n\t * user namespace's parents.\n\t */\n\tfor (;;) {\n\t\t/* Do we have the necessary capabilities? */\n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t/*\n\t\t * If we're already at a lower level than we're looking for,\n\t\t * we're done searching.\n\t\t */\n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t/* \n\t\t * The owner of the user namespace in the parent of the\n\t\t * user namespace has all caps.\n\t\t */\n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If you have a capability in a parent user ns, then you have\n\t\t * it over all children user namespaces as well.\n\t\t */\n\t\tns = ns->parent;\n\t}\n\n\t/* We never get here */\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_mmap_addr(unsigned long addr)\n{\n\tint ret = 0;\n\n\tif (addr < dac_mmap_min_addr) {\n\t\tret = cap_capable(current_cred(), &init_user_ns, CAP_SYS_RAWIO,\n\t\t\t\t  SECURITY_CAP_AUDIT);\n\t\t/* set PF_SUPERPRIV if it turns out we allow the low mmap */\n\t\tif (ret == 0)\n\t\t\tcurrent->flags |= PF_SUPERPRIV;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "cap_vm_enough_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "1304-1312",
    "snippet": "int cap_vm_enough_memory(struct mm_struct *mm, long pages)\n{\n\tint cap_sys_admin = 0;\n\n\tif (cap_capable(current_cred(), &init_user_ns, CAP_SYS_ADMIN,\n\t\t\tSECURITY_CAP_NOAUDIT) == 0)\n\t\tcap_sys_admin = 1;\n\treturn cap_sys_admin;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap_capable",
          "args": [
            "current_cred()",
            "&init_user_ns",
            "CAP_SYS_ADMIN",
            "SECURITY_CAP_NOAUDIT"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "cap_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "71-107",
          "snippet": "int cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, int audit)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t/* See if cred has the capability in the target user namespace\n\t * by examining the target user namespace and all of the target\n\t * user namespace's parents.\n\t */\n\tfor (;;) {\n\t\t/* Do we have the necessary capabilities? */\n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t/*\n\t\t * If we're already at a lower level than we're looking for,\n\t\t * we're done searching.\n\t\t */\n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t/* \n\t\t * The owner of the user namespace in the parent of the\n\t\t * user namespace has all caps.\n\t\t */\n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If you have a capability in a parent user ns, then you have\n\t\t * it over all children user namespaces as well.\n\t\t */\n\t\tns = ns->parent;\n\t}\n\n\t/* We never get here */\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, int audit)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t/* See if cred has the capability in the target user namespace\n\t * by examining the target user namespace and all of the target\n\t * user namespace's parents.\n\t */\n\tfor (;;) {\n\t\t/* Do we have the necessary capabilities? */\n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t/*\n\t\t * If we're already at a lower level than we're looking for,\n\t\t * we're done searching.\n\t\t */\n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t/* \n\t\t * The owner of the user namespace in the parent of the\n\t\t * user namespace has all caps.\n\t\t */\n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If you have a capability in a parent user ns, then you have\n\t\t * it over all children user namespaces as well.\n\t\t */\n\t\tns = ns->parent;\n\t}\n\n\t/* We never get here */\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_vm_enough_memory(struct mm_struct *mm, long pages)\n{\n\tint cap_sys_admin = 0;\n\n\tif (cap_capable(current_cred(), &init_user_ns, CAP_SYS_ADMIN,\n\t\t\tSECURITY_CAP_NOAUDIT) == 0)\n\t\tcap_sys_admin = 1;\n\treturn cap_sys_admin;\n}"
  },
  {
    "function_name": "cap_task_prctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "1172-1294",
    "snippet": "int cap_task_prctl(int option, unsigned long arg2, unsigned long arg3,\n\t\t   unsigned long arg4, unsigned long arg5)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new;\n\n\tswitch (option) {\n\tcase PR_CAPBSET_READ:\n\t\tif (!cap_valid(arg2))\n\t\t\treturn -EINVAL;\n\t\treturn !!cap_raised(old->cap_bset, arg2);\n\n\tcase PR_CAPBSET_DROP:\n\t\treturn cap_prctl_drop(arg2);\n\n\t/*\n\t * The next four prctl's remain to assist with transitioning a\n\t * system from legacy UID=0 based privilege (when filesystem\n\t * capabilities are not in use) to a system using filesystem\n\t * capabilities only - as the POSIX.1e draft intended.\n\t *\n\t * Note:\n\t *\n\t *  PR_SET_SECUREBITS =\n\t *      issecure_mask(SECURE_KEEP_CAPS_LOCKED)\n\t *    | issecure_mask(SECURE_NOROOT)\n\t *    | issecure_mask(SECURE_NOROOT_LOCKED)\n\t *    | issecure_mask(SECURE_NO_SETUID_FIXUP)\n\t *    | issecure_mask(SECURE_NO_SETUID_FIXUP_LOCKED)\n\t *\n\t * will ensure that the current process and all of its\n\t * children will be locked into a pure\n\t * capability-based-privilege environment.\n\t */\n\tcase PR_SET_SECUREBITS:\n\t\tif ((((old->securebits & SECURE_ALL_LOCKS) >> 1)\n\t\t     & (old->securebits ^ arg2))\t\t\t/*[1]*/\n\t\t    || ((old->securebits & SECURE_ALL_LOCKS & ~arg2))\t/*[2]*/\n\t\t    || (arg2 & ~(SECURE_ALL_LOCKS | SECURE_ALL_BITS))\t/*[3]*/\n\t\t    || (cap_capable(current_cred(),\n\t\t\t\t    current_cred()->user_ns, CAP_SETPCAP,\n\t\t\t\t    SECURITY_CAP_AUDIT) != 0)\t\t/*[4]*/\n\t\t\t/*\n\t\t\t * [1] no changing of bits that are locked\n\t\t\t * [2] no unlocking of locks\n\t\t\t * [3] no setting of unsupported bits\n\t\t\t * [4] doing anything requires privilege (go read about\n\t\t\t *     the \"sendmail capabilities bug\")\n\t\t\t */\n\t\t    )\n\t\t\t/* cannot change a locked bit */\n\t\t\treturn -EPERM;\n\n\t\tnew = prepare_creds();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tnew->securebits = arg2;\n\t\treturn commit_creds(new);\n\n\tcase PR_GET_SECUREBITS:\n\t\treturn old->securebits;\n\n\tcase PR_GET_KEEPCAPS:\n\t\treturn !!issecure(SECURE_KEEP_CAPS);\n\n\tcase PR_SET_KEEPCAPS:\n\t\tif (arg2 > 1) /* Note, we rely on arg2 being unsigned here */\n\t\t\treturn -EINVAL;\n\t\tif (issecure(SECURE_KEEP_CAPS_LOCKED))\n\t\t\treturn -EPERM;\n\n\t\tnew = prepare_creds();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tif (arg2)\n\t\t\tnew->securebits |= issecure_mask(SECURE_KEEP_CAPS);\n\t\telse\n\t\t\tnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\n\t\treturn commit_creds(new);\n\n\tcase PR_CAP_AMBIENT:\n\t\tif (arg2 == PR_CAP_AMBIENT_CLEAR_ALL) {\n\t\t\tif (arg3 | arg4 | arg5)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnew = prepare_creds();\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\t\t\tcap_clear(new->cap_ambient);\n\t\t\treturn commit_creds(new);\n\t\t}\n\n\t\tif (((!cap_valid(arg3)) | arg4 | arg5))\n\t\t\treturn -EINVAL;\n\n\t\tif (arg2 == PR_CAP_AMBIENT_IS_SET) {\n\t\t\treturn !!cap_raised(current_cred()->cap_ambient, arg3);\n\t\t} else if (arg2 != PR_CAP_AMBIENT_RAISE &&\n\t\t\t   arg2 != PR_CAP_AMBIENT_LOWER) {\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (arg2 == PR_CAP_AMBIENT_RAISE &&\n\t\t\t    (!cap_raised(current_cred()->cap_permitted, arg3) ||\n\t\t\t     !cap_raised(current_cred()->cap_inheritable,\n\t\t\t\t\t arg3) ||\n\t\t\t     issecure(SECURE_NO_CAP_AMBIENT_RAISE)))\n\t\t\t\treturn -EPERM;\n\n\t\t\tnew = prepare_creds();\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (arg2 == PR_CAP_AMBIENT_RAISE)\n\t\t\t\tcap_raise(new->cap_ambient, arg3);\n\t\t\telse\n\t\t\t\tcap_lower(new->cap_ambient, arg3);\n\t\t\treturn commit_creds(new);\n\t\t}\n\n\tdefault:\n\t\t/* No functionality available - continue with default */\n\t\treturn -ENOSYS;\n\t}\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_lower",
          "args": [
            "new->cap_ambient",
            "arg3"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise",
          "args": [
            "new->cap_ambient",
            "arg3"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "issecure",
          "args": [
            "SECURE_NO_CAP_AMBIENT_RAISE"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raised",
          "args": [
            "current_cred()->cap_inheritable",
            "arg3"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raised",
          "args": [
            "current_cred()->cap_permitted",
            "arg3"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raised",
          "args": [
            "current_cred()->cap_ambient",
            "arg3"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_valid",
          "args": [
            "arg3"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_clear",
          "args": [
            "new->cap_ambient"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "issecure_mask",
          "args": [
            "SECURE_KEEP_CAPS"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "issecure_mask",
          "args": [
            "SECURE_KEEP_CAPS"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "issecure",
          "args": [
            "SECURE_KEEP_CAPS_LOCKED"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "issecure",
          "args": [
            "SECURE_KEEP_CAPS"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_capable",
          "args": [
            "current_cred()",
            "current_cred()->user_ns",
            "CAP_SETPCAP",
            "SECURITY_CAP_AUDIT"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "cap_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "71-107",
          "snippet": "int cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, int audit)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t/* See if cred has the capability in the target user namespace\n\t * by examining the target user namespace and all of the target\n\t * user namespace's parents.\n\t */\n\tfor (;;) {\n\t\t/* Do we have the necessary capabilities? */\n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t/*\n\t\t * If we're already at a lower level than we're looking for,\n\t\t * we're done searching.\n\t\t */\n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t/* \n\t\t * The owner of the user namespace in the parent of the\n\t\t * user namespace has all caps.\n\t\t */\n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If you have a capability in a parent user ns, then you have\n\t\t * it over all children user namespaces as well.\n\t\t */\n\t\tns = ns->parent;\n\t}\n\n\t/* We never get here */\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, int audit)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t/* See if cred has the capability in the target user namespace\n\t * by examining the target user namespace and all of the target\n\t * user namespace's parents.\n\t */\n\tfor (;;) {\n\t\t/* Do we have the necessary capabilities? */\n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t/*\n\t\t * If we're already at a lower level than we're looking for,\n\t\t * we're done searching.\n\t\t */\n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t/* \n\t\t * The owner of the user namespace in the parent of the\n\t\t * user namespace has all caps.\n\t\t */\n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If you have a capability in a parent user ns, then you have\n\t\t * it over all children user namespaces as well.\n\t\t */\n\t\tns = ns->parent;\n\t}\n\n\t/* We never get here */\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_prctl_drop",
          "args": [
            "arg2"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "cap_prctl_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "1144-1158",
          "snippet": "static int cap_prctl_drop(unsigned long cap)\n{\n\tstruct cred *new;\n\n\tif (!ns_capable(current_user_ns(), CAP_SETPCAP))\n\t\treturn -EPERM;\n\tif (!cap_valid(cap))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tcap_lower(new->cap_bset, cap);\n\treturn commit_creds(new);\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic int cap_prctl_drop(unsigned long cap)\n{\n\tstruct cred *new;\n\n\tif (!ns_capable(current_user_ns(), CAP_SETPCAP))\n\t\treturn -EPERM;\n\tif (!cap_valid(cap))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tcap_lower(new->cap_bset, cap);\n\treturn commit_creds(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_raised",
          "args": [
            "old->cap_bset",
            "arg2"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_valid",
          "args": [
            "arg2"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_task_prctl(int option, unsigned long arg2, unsigned long arg3,\n\t\t   unsigned long arg4, unsigned long arg5)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new;\n\n\tswitch (option) {\n\tcase PR_CAPBSET_READ:\n\t\tif (!cap_valid(arg2))\n\t\t\treturn -EINVAL;\n\t\treturn !!cap_raised(old->cap_bset, arg2);\n\n\tcase PR_CAPBSET_DROP:\n\t\treturn cap_prctl_drop(arg2);\n\n\t/*\n\t * The next four prctl's remain to assist with transitioning a\n\t * system from legacy UID=0 based privilege (when filesystem\n\t * capabilities are not in use) to a system using filesystem\n\t * capabilities only - as the POSIX.1e draft intended.\n\t *\n\t * Note:\n\t *\n\t *  PR_SET_SECUREBITS =\n\t *      issecure_mask(SECURE_KEEP_CAPS_LOCKED)\n\t *    | issecure_mask(SECURE_NOROOT)\n\t *    | issecure_mask(SECURE_NOROOT_LOCKED)\n\t *    | issecure_mask(SECURE_NO_SETUID_FIXUP)\n\t *    | issecure_mask(SECURE_NO_SETUID_FIXUP_LOCKED)\n\t *\n\t * will ensure that the current process and all of its\n\t * children will be locked into a pure\n\t * capability-based-privilege environment.\n\t */\n\tcase PR_SET_SECUREBITS:\n\t\tif ((((old->securebits & SECURE_ALL_LOCKS) >> 1)\n\t\t     & (old->securebits ^ arg2))\t\t\t/*[1]*/\n\t\t    || ((old->securebits & SECURE_ALL_LOCKS & ~arg2))\t/*[2]*/\n\t\t    || (arg2 & ~(SECURE_ALL_LOCKS | SECURE_ALL_BITS))\t/*[3]*/\n\t\t    || (cap_capable(current_cred(),\n\t\t\t\t    current_cred()->user_ns, CAP_SETPCAP,\n\t\t\t\t    SECURITY_CAP_AUDIT) != 0)\t\t/*[4]*/\n\t\t\t/*\n\t\t\t * [1] no changing of bits that are locked\n\t\t\t * [2] no unlocking of locks\n\t\t\t * [3] no setting of unsupported bits\n\t\t\t * [4] doing anything requires privilege (go read about\n\t\t\t *     the \"sendmail capabilities bug\")\n\t\t\t */\n\t\t    )\n\t\t\t/* cannot change a locked bit */\n\t\t\treturn -EPERM;\n\n\t\tnew = prepare_creds();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tnew->securebits = arg2;\n\t\treturn commit_creds(new);\n\n\tcase PR_GET_SECUREBITS:\n\t\treturn old->securebits;\n\n\tcase PR_GET_KEEPCAPS:\n\t\treturn !!issecure(SECURE_KEEP_CAPS);\n\n\tcase PR_SET_KEEPCAPS:\n\t\tif (arg2 > 1) /* Note, we rely on arg2 being unsigned here */\n\t\t\treturn -EINVAL;\n\t\tif (issecure(SECURE_KEEP_CAPS_LOCKED))\n\t\t\treturn -EPERM;\n\n\t\tnew = prepare_creds();\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tif (arg2)\n\t\t\tnew->securebits |= issecure_mask(SECURE_KEEP_CAPS);\n\t\telse\n\t\t\tnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\n\t\treturn commit_creds(new);\n\n\tcase PR_CAP_AMBIENT:\n\t\tif (arg2 == PR_CAP_AMBIENT_CLEAR_ALL) {\n\t\t\tif (arg3 | arg4 | arg5)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnew = prepare_creds();\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\t\t\tcap_clear(new->cap_ambient);\n\t\t\treturn commit_creds(new);\n\t\t}\n\n\t\tif (((!cap_valid(arg3)) | arg4 | arg5))\n\t\t\treturn -EINVAL;\n\n\t\tif (arg2 == PR_CAP_AMBIENT_IS_SET) {\n\t\t\treturn !!cap_raised(current_cred()->cap_ambient, arg3);\n\t\t} else if (arg2 != PR_CAP_AMBIENT_RAISE &&\n\t\t\t   arg2 != PR_CAP_AMBIENT_LOWER) {\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (arg2 == PR_CAP_AMBIENT_RAISE &&\n\t\t\t    (!cap_raised(current_cred()->cap_permitted, arg3) ||\n\t\t\t     !cap_raised(current_cred()->cap_inheritable,\n\t\t\t\t\t arg3) ||\n\t\t\t     issecure(SECURE_NO_CAP_AMBIENT_RAISE)))\n\t\t\t\treturn -EPERM;\n\n\t\t\tnew = prepare_creds();\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (arg2 == PR_CAP_AMBIENT_RAISE)\n\t\t\t\tcap_raise(new->cap_ambient, arg3);\n\t\t\telse\n\t\t\t\tcap_lower(new->cap_ambient, arg3);\n\t\t\treturn commit_creds(new);\n\t\t}\n\n\tdefault:\n\t\t/* No functionality available - continue with default */\n\t\treturn -ENOSYS;\n\t}\n}"
  },
  {
    "function_name": "cap_prctl_drop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "1144-1158",
    "snippet": "static int cap_prctl_drop(unsigned long cap)\n{\n\tstruct cred *new;\n\n\tif (!ns_capable(current_user_ns(), CAP_SETPCAP))\n\t\treturn -EPERM;\n\tif (!cap_valid(cap))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tcap_lower(new->cap_bset, cap);\n\treturn commit_creds(new);\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_lower",
          "args": [
            "new->cap_bset",
            "cap"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_valid",
          "args": [
            "cap"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "current_user_ns()",
            "CAP_SETPCAP"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic int cap_prctl_drop(unsigned long cap)\n{\n\tstruct cred *new;\n\n\tif (!ns_capable(current_user_ns(), CAP_SETPCAP))\n\t\treturn -EPERM;\n\tif (!cap_valid(cap))\n\t\treturn -EINVAL;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tcap_lower(new->cap_bset, cap);\n\treturn commit_creds(new);\n}"
  },
  {
    "function_name": "cap_task_setnice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "1135-1138",
    "snippet": "int cap_task_setnice(struct task_struct *p, int nice)\n{\n\treturn cap_safe_nice(p);\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap_safe_nice",
          "args": [
            "p"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "cap_safe_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "1088-1100",
          "snippet": "static int cap_safe_nice(struct task_struct *p)\n{\n\tint is_subset, ret = 0;\n\n\trcu_read_lock();\n\tis_subset = cap_issubset(__task_cred(p)->cap_permitted,\n\t\t\t\t current_cred()->cap_permitted);\n\tif (!is_subset && !ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE))\n\t\tret = -EPERM;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic int cap_safe_nice(struct task_struct *p)\n{\n\tint is_subset, ret = 0;\n\n\trcu_read_lock();\n\tis_subset = cap_issubset(__task_cred(p)->cap_permitted,\n\t\t\t\t current_cred()->cap_permitted);\n\tif (!is_subset && !ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE))\n\t\tret = -EPERM;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_task_setnice(struct task_struct *p, int nice)\n{\n\treturn cap_safe_nice(p);\n}"
  },
  {
    "function_name": "cap_task_setioprio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "1122-1125",
    "snippet": "int cap_task_setioprio(struct task_struct *p, int ioprio)\n{\n\treturn cap_safe_nice(p);\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap_safe_nice",
          "args": [
            "p"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "cap_safe_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "1088-1100",
          "snippet": "static int cap_safe_nice(struct task_struct *p)\n{\n\tint is_subset, ret = 0;\n\n\trcu_read_lock();\n\tis_subset = cap_issubset(__task_cred(p)->cap_permitted,\n\t\t\t\t current_cred()->cap_permitted);\n\tif (!is_subset && !ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE))\n\t\tret = -EPERM;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic int cap_safe_nice(struct task_struct *p)\n{\n\tint is_subset, ret = 0;\n\n\trcu_read_lock();\n\tis_subset = cap_issubset(__task_cred(p)->cap_permitted,\n\t\t\t\t current_cred()->cap_permitted);\n\tif (!is_subset && !ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE))\n\t\tret = -EPERM;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_task_setioprio(struct task_struct *p, int ioprio)\n{\n\treturn cap_safe_nice(p);\n}"
  },
  {
    "function_name": "cap_task_setscheduler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "1109-1112",
    "snippet": "int cap_task_setscheduler(struct task_struct *p)\n{\n\treturn cap_safe_nice(p);\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap_safe_nice",
          "args": [
            "p"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "cap_safe_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "1088-1100",
          "snippet": "static int cap_safe_nice(struct task_struct *p)\n{\n\tint is_subset, ret = 0;\n\n\trcu_read_lock();\n\tis_subset = cap_issubset(__task_cred(p)->cap_permitted,\n\t\t\t\t current_cred()->cap_permitted);\n\tif (!is_subset && !ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE))\n\t\tret = -EPERM;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic int cap_safe_nice(struct task_struct *p)\n{\n\tint is_subset, ret = 0;\n\n\trcu_read_lock();\n\tis_subset = cap_issubset(__task_cred(p)->cap_permitted,\n\t\t\t\t current_cred()->cap_permitted);\n\tif (!is_subset && !ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE))\n\t\tret = -EPERM;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_task_setscheduler(struct task_struct *p)\n{\n\treturn cap_safe_nice(p);\n}"
  },
  {
    "function_name": "cap_safe_nice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "1088-1100",
    "snippet": "static int cap_safe_nice(struct task_struct *p)\n{\n\tint is_subset, ret = 0;\n\n\trcu_read_lock();\n\tis_subset = cap_issubset(__task_cred(p)->cap_permitted,\n\t\t\t\t current_cred()->cap_permitted);\n\tif (!is_subset && !ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE))\n\t\tret = -EPERM;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "__task_cred(p)->user_ns",
            "CAP_SYS_NICE"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "p"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_issubset",
          "args": [
            "__task_cred(p)->cap_permitted",
            "current_cred()->cap_permitted"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "p"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic int cap_safe_nice(struct task_struct *p)\n{\n\tint is_subset, ret = 0;\n\n\trcu_read_lock();\n\tis_subset = cap_issubset(__task_cred(p)->cap_permitted,\n\t\t\t\t current_cred()->cap_permitted);\n\tif (!is_subset && !ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE))\n\t\tret = -EPERM;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cap_task_fix_setuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "1039-1076",
    "snippet": "int cap_task_fix_setuid(struct cred *new, const struct cred *old, int flags)\n{\n\tswitch (flags) {\n\tcase LSM_SETID_RE:\n\tcase LSM_SETID_ID:\n\tcase LSM_SETID_RES:\n\t\t/* juggle the capabilities to follow [RES]UID changes unless\n\t\t * otherwise suppressed */\n\t\tif (!issecure(SECURE_NO_SETUID_FIXUP))\n\t\t\tcap_emulate_setxuid(new, old);\n\t\tbreak;\n\n\tcase LSM_SETID_FS:\n\t\t/* juggle the capabilties to follow FSUID changes, unless\n\t\t * otherwise suppressed\n\t\t *\n\t\t * FIXME - is fsuser used for all CAP_FS_MASK capabilities?\n\t\t *          if not, we might be a bit too harsh here.\n\t\t */\n\t\tif (!issecure(SECURE_NO_SETUID_FIXUP)) {\n\t\t\tkuid_t root_uid = make_kuid(old->user_ns, 0);\n\t\t\tif (uid_eq(old->fsuid, root_uid) && !uid_eq(new->fsuid, root_uid))\n\t\t\t\tnew->cap_effective =\n\t\t\t\t\tcap_drop_fs_set(new->cap_effective);\n\n\t\t\tif (!uid_eq(old->fsuid, root_uid) && uid_eq(new->fsuid, root_uid))\n\t\t\t\tnew->cap_effective =\n\t\t\t\t\tcap_raise_fs_set(new->cap_effective,\n\t\t\t\t\t\t\t new->cap_permitted);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap_raise_fs_set",
          "args": [
            "new->cap_effective",
            "new->cap_permitted"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->fsuid",
            "root_uid"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "old->fsuid",
            "root_uid"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_drop_fs_set",
          "args": [
            "new->cap_effective"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->fsuid",
            "root_uid"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "old->fsuid",
            "root_uid"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "old->user_ns",
            "0"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "issecure",
          "args": [
            "SECURE_NO_SETUID_FIXUP"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_emulate_setxuid",
          "args": [
            "new",
            "old"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "cap_emulate_setxuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "1002-1028",
          "snippet": "static inline void cap_emulate_setxuid(struct cred *new, const struct cred *old)\n{\n\tkuid_t root_uid = make_kuid(old->user_ns, 0);\n\n\tif ((uid_eq(old->uid, root_uid) ||\n\t     uid_eq(old->euid, root_uid) ||\n\t     uid_eq(old->suid, root_uid)) &&\n\t    (!uid_eq(new->uid, root_uid) &&\n\t     !uid_eq(new->euid, root_uid) &&\n\t     !uid_eq(new->suid, root_uid))) {\n\t\tif (!issecure(SECURE_KEEP_CAPS)) {\n\t\t\tcap_clear(new->cap_permitted);\n\t\t\tcap_clear(new->cap_effective);\n\t\t}\n\n\t\t/*\n\t\t * Pre-ambient programs expect setresuid to nonroot followed\n\t\t * by exec to drop capabilities.  We should make sure that\n\t\t * this remains the case.\n\t\t */\n\t\tcap_clear(new->cap_ambient);\n\t}\n\tif (uid_eq(old->euid, root_uid) && !uid_eq(new->euid, root_uid))\n\t\tcap_clear(new->cap_effective);\n\tif (!uid_eq(old->euid, root_uid) && uid_eq(new->euid, root_uid))\n\t\tnew->cap_effective = new->cap_permitted;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline void cap_emulate_setxuid(struct cred *new, const struct cred *old)\n{\n\tkuid_t root_uid = make_kuid(old->user_ns, 0);\n\n\tif ((uid_eq(old->uid, root_uid) ||\n\t     uid_eq(old->euid, root_uid) ||\n\t     uid_eq(old->suid, root_uid)) &&\n\t    (!uid_eq(new->uid, root_uid) &&\n\t     !uid_eq(new->euid, root_uid) &&\n\t     !uid_eq(new->suid, root_uid))) {\n\t\tif (!issecure(SECURE_KEEP_CAPS)) {\n\t\t\tcap_clear(new->cap_permitted);\n\t\t\tcap_clear(new->cap_effective);\n\t\t}\n\n\t\t/*\n\t\t * Pre-ambient programs expect setresuid to nonroot followed\n\t\t * by exec to drop capabilities.  We should make sure that\n\t\t * this remains the case.\n\t\t */\n\t\tcap_clear(new->cap_ambient);\n\t}\n\tif (uid_eq(old->euid, root_uid) && !uid_eq(new->euid, root_uid))\n\t\tcap_clear(new->cap_effective);\n\tif (!uid_eq(old->euid, root_uid) && uid_eq(new->euid, root_uid))\n\t\tnew->cap_effective = new->cap_permitted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "issecure",
          "args": [
            "SECURE_NO_SETUID_FIXUP"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_task_fix_setuid(struct cred *new, const struct cred *old, int flags)\n{\n\tswitch (flags) {\n\tcase LSM_SETID_RE:\n\tcase LSM_SETID_ID:\n\tcase LSM_SETID_RES:\n\t\t/* juggle the capabilities to follow [RES]UID changes unless\n\t\t * otherwise suppressed */\n\t\tif (!issecure(SECURE_NO_SETUID_FIXUP))\n\t\t\tcap_emulate_setxuid(new, old);\n\t\tbreak;\n\n\tcase LSM_SETID_FS:\n\t\t/* juggle the capabilties to follow FSUID changes, unless\n\t\t * otherwise suppressed\n\t\t *\n\t\t * FIXME - is fsuser used for all CAP_FS_MASK capabilities?\n\t\t *          if not, we might be a bit too harsh here.\n\t\t */\n\t\tif (!issecure(SECURE_NO_SETUID_FIXUP)) {\n\t\t\tkuid_t root_uid = make_kuid(old->user_ns, 0);\n\t\t\tif (uid_eq(old->fsuid, root_uid) && !uid_eq(new->fsuid, root_uid))\n\t\t\t\tnew->cap_effective =\n\t\t\t\t\tcap_drop_fs_set(new->cap_effective);\n\n\t\t\tif (!uid_eq(old->fsuid, root_uid) && uid_eq(new->fsuid, root_uid))\n\t\t\t\tnew->cap_effective =\n\t\t\t\t\tcap_raise_fs_set(new->cap_effective,\n\t\t\t\t\t\t\t new->cap_permitted);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cap_emulate_setxuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "1002-1028",
    "snippet": "static inline void cap_emulate_setxuid(struct cred *new, const struct cred *old)\n{\n\tkuid_t root_uid = make_kuid(old->user_ns, 0);\n\n\tif ((uid_eq(old->uid, root_uid) ||\n\t     uid_eq(old->euid, root_uid) ||\n\t     uid_eq(old->suid, root_uid)) &&\n\t    (!uid_eq(new->uid, root_uid) &&\n\t     !uid_eq(new->euid, root_uid) &&\n\t     !uid_eq(new->suid, root_uid))) {\n\t\tif (!issecure(SECURE_KEEP_CAPS)) {\n\t\t\tcap_clear(new->cap_permitted);\n\t\t\tcap_clear(new->cap_effective);\n\t\t}\n\n\t\t/*\n\t\t * Pre-ambient programs expect setresuid to nonroot followed\n\t\t * by exec to drop capabilities.  We should make sure that\n\t\t * this remains the case.\n\t\t */\n\t\tcap_clear(new->cap_ambient);\n\t}\n\tif (uid_eq(old->euid, root_uid) && !uid_eq(new->euid, root_uid))\n\t\tcap_clear(new->cap_effective);\n\tif (!uid_eq(old->euid, root_uid) && uid_eq(new->euid, root_uid))\n\t\tnew->cap_effective = new->cap_permitted;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->euid",
            "root_uid"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "old->euid",
            "root_uid"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_clear",
          "args": [
            "new->cap_effective"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->euid",
            "root_uid"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "old->euid",
            "root_uid"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_clear",
          "args": [
            "new->cap_ambient"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_clear",
          "args": [
            "new->cap_effective"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_clear",
          "args": [
            "new->cap_permitted"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "issecure",
          "args": [
            "SECURE_KEEP_CAPS"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->suid",
            "root_uid"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->euid",
            "root_uid"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->uid",
            "root_uid"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "old->suid",
            "root_uid"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "old->euid",
            "root_uid"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "old->uid",
            "root_uid"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "old->user_ns",
            "0"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline void cap_emulate_setxuid(struct cred *new, const struct cred *old)\n{\n\tkuid_t root_uid = make_kuid(old->user_ns, 0);\n\n\tif ((uid_eq(old->uid, root_uid) ||\n\t     uid_eq(old->euid, root_uid) ||\n\t     uid_eq(old->suid, root_uid)) &&\n\t    (!uid_eq(new->uid, root_uid) &&\n\t     !uid_eq(new->euid, root_uid) &&\n\t     !uid_eq(new->suid, root_uid))) {\n\t\tif (!issecure(SECURE_KEEP_CAPS)) {\n\t\t\tcap_clear(new->cap_permitted);\n\t\t\tcap_clear(new->cap_effective);\n\t\t}\n\n\t\t/*\n\t\t * Pre-ambient programs expect setresuid to nonroot followed\n\t\t * by exec to drop capabilities.  We should make sure that\n\t\t * this remains the case.\n\t\t */\n\t\tcap_clear(new->cap_ambient);\n\t}\n\tif (uid_eq(old->euid, root_uid) && !uid_eq(new->euid, root_uid))\n\t\tcap_clear(new->cap_effective);\n\tif (!uid_eq(old->euid, root_uid) && uid_eq(new->euid, root_uid))\n\t\tnew->cap_effective = new->cap_permitted;\n}"
  },
  {
    "function_name": "cap_inode_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "951-971",
    "snippet": "int cap_inode_removexattr(struct dentry *dentry, const char *name)\n{\n\t/* Ignore non-security xattrs */\n\tif (strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tsizeof(XATTR_SECURITY_PREFIX) - 1) != 0)\n\t\treturn 0;\n\n\tif (strcmp(name, XATTR_NAME_CAPS) == 0) {\n\t\t/* security.capability gets namespaced */\n\t\tstruct inode *inode = d_backing_inode(dentry);\n\t\tif (!inode)\n\t\t\treturn -EINVAL;\n\t\tif (!capable_wrt_inode_uidgid(inode, CAP_SETFCAP))\n\t\t\treturn -EPERM;\n\t\treturn 0;\n\t}\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable_wrt_inode_uidgid",
          "args": [
            "inode",
            "CAP_SETFCAP"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_CAPS"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "sizeof(XATTR_SECURITY_PREFIX) - 1"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_inode_removexattr(struct dentry *dentry, const char *name)\n{\n\t/* Ignore non-security xattrs */\n\tif (strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tsizeof(XATTR_SECURITY_PREFIX) - 1) != 0)\n\t\treturn 0;\n\n\tif (strcmp(name, XATTR_NAME_CAPS) == 0) {\n\t\t/* security.capability gets namespaced */\n\t\tstruct inode *inode = d_backing_inode(dentry);\n\t\tif (!inode)\n\t\t\treturn -EINVAL;\n\t\tif (!capable_wrt_inode_uidgid(inode, CAP_SETFCAP))\n\t\t\treturn -EPERM;\n\t\treturn 0;\n\t}\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}"
  },
  {
    "function_name": "cap_inode_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "920-938",
    "snippet": "int cap_inode_setxattr(struct dentry *dentry, const char *name,\n\t\t       const void *value, size_t size, int flags)\n{\n\t/* Ignore non-security xattrs */\n\tif (strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tsizeof(XATTR_SECURITY_PREFIX) - 1) != 0)\n\t\treturn 0;\n\n\t/*\n\t * For XATTR_NAME_CAPS the check will be done in\n\t * cap_convert_nscap(), called by setxattr()\n\t */\n\tif (strcmp(name, XATTR_NAME_CAPS) == 0)\n\t\treturn 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_CAPS"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "sizeof(XATTR_SECURITY_PREFIX) - 1"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_inode_setxattr(struct dentry *dentry, const char *name,\n\t\t       const void *value, size_t size, int flags)\n{\n\t/* Ignore non-security xattrs */\n\tif (strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tsizeof(XATTR_SECURITY_PREFIX) - 1) != 0)\n\t\treturn 0;\n\n\t/*\n\t * For XATTR_NAME_CAPS the check will be done in\n\t * cap_convert_nscap(), called by setxattr()\n\t */\n\tif (strcmp(name, XATTR_NAME_CAPS) == 0)\n\t\treturn 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}"
  },
  {
    "function_name": "cap_bprm_set_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "816-904",
    "snippet": "int cap_bprm_set_creds(struct linux_binprm *bprm)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\tbool effective = false, has_fcap = false, is_setid;\n\tint ret;\n\tkuid_t root_uid;\n\n\tif (WARN_ON(!cap_ambient_invariant_ok(old)))\n\t\treturn -EPERM;\n\n\tret = get_file_caps(bprm, &effective, &has_fcap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\troot_uid = make_kuid(new->user_ns, 0);\n\n\thandle_privileged_root(bprm, has_fcap, &effective, root_uid);\n\n\t/* if we have fs caps, clear dangerous personality flags */\n\tif (__cap_gained(permitted, new, old))\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\n\t/* Don't let someone trace a set[ug]id/setpcap binary with the revised\n\t * credentials unless they have the appropriate permit.\n\t *\n\t * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.\n\t */\n\tis_setid = __is_setuid(new, old) || __is_setgid(new, old);\n\n\tif ((is_setid || __cap_gained(permitted, new, old)) &&\n\t    ((bprm->unsafe & ~LSM_UNSAFE_PTRACE) ||\n\t     !ptracer_capable(current, new->user_ns))) {\n\t\t/* downgrade; they get no more than they had, and maybe less */\n\t\tif (!ns_capable(new->user_ns, CAP_SETUID) ||\n\t\t    (bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS)) {\n\t\t\tnew->euid = new->uid;\n\t\t\tnew->egid = new->gid;\n\t\t}\n\t\tnew->cap_permitted = cap_intersect(new->cap_permitted,\n\t\t\t\t\t\t   old->cap_permitted);\n\t}\n\n\tnew->suid = new->fsuid = new->euid;\n\tnew->sgid = new->fsgid = new->egid;\n\n\t/* File caps or setid cancels ambient. */\n\tif (has_fcap || is_setid)\n\t\tcap_clear(new->cap_ambient);\n\n\t/*\n\t * Now that we've computed pA', update pP' to give:\n\t *   pP' = (X & fP) | (pI & fI) | pA'\n\t */\n\tnew->cap_permitted = cap_combine(new->cap_permitted, new->cap_ambient);\n\n\t/*\n\t * Set pE' = (fE ? pP' : pA').  Because pA' is zero if fE is set,\n\t * this is the same as pE' = (fE ? pP' : 0) | pA'.\n\t */\n\tif (effective)\n\t\tnew->cap_effective = new->cap_permitted;\n\telse\n\t\tnew->cap_effective = new->cap_ambient;\n\n\tif (WARN_ON(!cap_ambient_invariant_ok(new)))\n\t\treturn -EPERM;\n\n\tif (nonroot_raised_pE(new, old, root_uid, has_fcap)) {\n\t\tret = audit_log_bprm_fcaps(bprm, new, old);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\n\n\tif (WARN_ON(!cap_ambient_invariant_ok(new)))\n\t\treturn -EPERM;\n\n\t/* Check for privilege-elevated exec. */\n\tbprm->cap_elevated = 0;\n\tif (is_setid ||\n\t    (!__is_real(root_uid, new) &&\n\t     (effective ||\n\t      __cap_grew(permitted, ambient, new))))\n\t\tbprm->cap_elevated = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cap_grew",
          "args": [
            "permitted",
            "ambient",
            "new"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__is_real",
          "args": [
            "root_uid",
            "new"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "__is_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "701-702",
          "snippet": "static inline bool __is_real(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->uid, uid); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_real(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->uid, uid); }"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!cap_ambient_invariant_ok(new)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_ambient_invariant_ok",
          "args": [
            "new"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "issecure_mask",
          "args": [
            "SECURE_KEEP_CAPS"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_bprm_fcaps",
          "args": [
            "bprm",
            "new",
            "old"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nonroot_raised_pE",
          "args": [
            "new",
            "old",
            "root_uid",
            "has_fcap"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "nonroot_raised_pE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "786-806",
          "snippet": "static inline bool nonroot_raised_pE(struct cred *new, const struct cred *old,\n\t\t\t\t     kuid_t root, bool has_fcap)\n{\n\tbool ret = false;\n\n\tif ((__cap_grew(effective, ambient, new) &&\n\t     !(__cap_full(effective, new) &&\n\t       (__is_eff(root, new) || __is_real(root, new)) &&\n\t       root_privileged())) ||\n\t    (root_privileged() &&\n\t     __is_suid(root, new) &&\n\t     !__cap_full(effective, new)) ||\n\t    (!__is_setuid(new, old) &&\n\t     ((has_fcap &&\n\t       __cap_gained(permitted, new, old)) ||\n\t      __cap_gained(ambient, new, old))))\n\n\t\tret = true;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool nonroot_raised_pE(struct cred *new, const struct cred *old,\n\t\t\t\t     kuid_t root, bool has_fcap)\n{\n\tbool ret = false;\n\n\tif ((__cap_grew(effective, ambient, new) &&\n\t     !(__cap_full(effective, new) &&\n\t       (__is_eff(root, new) || __is_real(root, new)) &&\n\t       root_privileged())) ||\n\t    (root_privileged() &&\n\t     __is_suid(root, new) &&\n\t     !__cap_full(effective, new)) ||\n\t    (!__is_setuid(new, old) &&\n\t     ((has_fcap &&\n\t       __cap_gained(permitted, new, old)) ||\n\t      __cap_gained(ambient, new, old))))\n\n\t\tret = true;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!cap_ambient_invariant_ok(new)"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_ambient_invariant_ok",
          "args": [
            "new"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_combine",
          "args": [
            "new->cap_permitted",
            "new->cap_ambient"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_clear",
          "args": [
            "new->cap_ambient"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_intersect",
          "args": [
            "new->cap_permitted",
            "old->cap_permitted"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "new->user_ns",
            "CAP_SETUID"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptracer_capable",
          "args": [
            "current",
            "new->user_ns"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cap_gained",
          "args": [
            "permitted",
            "new",
            "old"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__is_setgid",
          "args": [
            "new",
            "old"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "__is_setgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "766-767",
          "snippet": "static inline bool __is_setgid(struct cred *new, const struct cred *old)\n{ return !gid_eq(new->egid, old->gid); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_setgid(struct cred *new, const struct cred *old)\n{ return !gid_eq(new->egid, old->gid); }"
        }
      },
      {
        "call_info": {
          "callee": "__is_setuid",
          "args": [
            "new",
            "old"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "__is_setuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "763-764",
          "snippet": "static inline bool __is_setuid(struct cred *new, const struct cred *old)\n{ return !uid_eq(new->euid, old->uid); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_setuid(struct cred *new, const struct cred *old)\n{ return !uid_eq(new->euid, old->uid); }"
        }
      },
      {
        "call_info": {
          "callee": "__cap_gained",
          "args": [
            "permitted",
            "new",
            "old"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_privileged_root",
          "args": [
            "bprm",
            "has_fcap",
            "&effective",
            "root_uid"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "handle_privileged_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "722-754",
          "snippet": "static void handle_privileged_root(struct linux_binprm *bprm, bool has_fcap,\n\t\t\t\t   bool *effective, kuid_t root_uid)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\n\tif (!root_privileged())\n\t\treturn;\n\t/*\n\t * If the legacy file capability is set, then don't set privs\n\t * for a setuid root binary run by a non-root user.  Do set it\n\t * for a root user just to cause least surprise to an admin.\n\t */\n\tif (has_fcap && __is_suid(root_uid, new)) {\n\t\twarn_setuid_and_fcaps_mixed(bprm->filename);\n\t\treturn;\n\t}\n\t/*\n\t * To support inheritance of root-permissions and suid-root\n\t * executables under compatibility mode, we override the\n\t * capability sets for the file.\n\t */\n\tif (__is_eff(root_uid, new) || __is_real(root_uid, new)) {\n\t\t/* pP' = (cap_bset & ~0) | (pI & ~0) */\n\t\tnew->cap_permitted = cap_combine(old->cap_bset,\n\t\t\t\t\t\t old->cap_inheritable);\n\t}\n\t/*\n\t * If only the real uid is 0, we do not set the effective bit.\n\t */\n\tif (__is_eff(root_uid, new))\n\t\t*effective = true;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic void handle_privileged_root(struct linux_binprm *bprm, bool has_fcap,\n\t\t\t\t   bool *effective, kuid_t root_uid)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\n\tif (!root_privileged())\n\t\treturn;\n\t/*\n\t * If the legacy file capability is set, then don't set privs\n\t * for a setuid root binary run by a non-root user.  Do set it\n\t * for a root user just to cause least surprise to an admin.\n\t */\n\tif (has_fcap && __is_suid(root_uid, new)) {\n\t\twarn_setuid_and_fcaps_mixed(bprm->filename);\n\t\treturn;\n\t}\n\t/*\n\t * To support inheritance of root-permissions and suid-root\n\t * executables under compatibility mode, we override the\n\t * capability sets for the file.\n\t */\n\tif (__is_eff(root_uid, new) || __is_real(root_uid, new)) {\n\t\t/* pP' = (cap_bset & ~0) | (pI & ~0) */\n\t\tnew->cap_permitted = cap_combine(old->cap_bset,\n\t\t\t\t\t\t old->cap_inheritable);\n\t}\n\t/*\n\t * If only the real uid is 0, we do not set the effective bit.\n\t */\n\tif (__is_eff(root_uid, new))\n\t\t*effective = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "new->user_ns",
            "0"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file_caps",
          "args": [
            "bprm",
            "&effective",
            "&has_fcap"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "get_file_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "656-697",
          "snippet": "static int get_file_caps(struct linux_binprm *bprm, bool *effective, bool *has_fcap)\n{\n\tint rc = 0;\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tcap_clear(bprm->cred->cap_permitted);\n\n\tif (!file_caps_enabled)\n\t\treturn 0;\n\n\tif (!mnt_may_suid(bprm->file->f_path.mnt))\n\t\treturn 0;\n\n\t/*\n\t * This check is redundant with mnt_may_suid() but is kept to make\n\t * explicit that capability bits are limited to s_user_ns and its\n\t * descendants.\n\t */\n\tif (!current_in_userns(bprm->file->f_path.mnt->mnt_sb->s_user_ns))\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(bprm->file->f_path.dentry, &vcaps);\n\tif (rc < 0) {\n\t\tif (rc == -EINVAL)\n\t\t\tprintk(KERN_NOTICE \"Invalid argument reading file caps for %s\\n\",\n\t\t\t\t\tbprm->filename);\n\t\telse if (rc == -ENODATA)\n\t\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = bprm_caps_from_vfs_caps(&vcaps, bprm, effective, has_fcap);\n\tif (rc == -EINVAL)\n\t\tprintk(KERN_NOTICE \"%s: cap_from_disk returned %d for %s\\n\",\n\t\t       __func__, rc, bprm->filename);\n\nout:\n\tif (rc)\n\t\tcap_clear(bprm->cred->cap_permitted);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic int get_file_caps(struct linux_binprm *bprm, bool *effective, bool *has_fcap)\n{\n\tint rc = 0;\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tcap_clear(bprm->cred->cap_permitted);\n\n\tif (!file_caps_enabled)\n\t\treturn 0;\n\n\tif (!mnt_may_suid(bprm->file->f_path.mnt))\n\t\treturn 0;\n\n\t/*\n\t * This check is redundant with mnt_may_suid() but is kept to make\n\t * explicit that capability bits are limited to s_user_ns and its\n\t * descendants.\n\t */\n\tif (!current_in_userns(bprm->file->f_path.mnt->mnt_sb->s_user_ns))\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(bprm->file->f_path.dentry, &vcaps);\n\tif (rc < 0) {\n\t\tif (rc == -EINVAL)\n\t\t\tprintk(KERN_NOTICE \"Invalid argument reading file caps for %s\\n\",\n\t\t\t\t\tbprm->filename);\n\t\telse if (rc == -ENODATA)\n\t\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = bprm_caps_from_vfs_caps(&vcaps, bprm, effective, has_fcap);\n\tif (rc == -EINVAL)\n\t\tprintk(KERN_NOTICE \"%s: cap_from_disk returned %d for %s\\n\",\n\t\t       __func__, rc, bprm->filename);\n\nout:\n\tif (rc)\n\t\tcap_clear(bprm->cred->cap_permitted);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!cap_ambient_invariant_ok(old)"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_ambient_invariant_ok",
          "args": [
            "old"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_bprm_set_creds(struct linux_binprm *bprm)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\tbool effective = false, has_fcap = false, is_setid;\n\tint ret;\n\tkuid_t root_uid;\n\n\tif (WARN_ON(!cap_ambient_invariant_ok(old)))\n\t\treturn -EPERM;\n\n\tret = get_file_caps(bprm, &effective, &has_fcap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\troot_uid = make_kuid(new->user_ns, 0);\n\n\thandle_privileged_root(bprm, has_fcap, &effective, root_uid);\n\n\t/* if we have fs caps, clear dangerous personality flags */\n\tif (__cap_gained(permitted, new, old))\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\n\t/* Don't let someone trace a set[ug]id/setpcap binary with the revised\n\t * credentials unless they have the appropriate permit.\n\t *\n\t * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.\n\t */\n\tis_setid = __is_setuid(new, old) || __is_setgid(new, old);\n\n\tif ((is_setid || __cap_gained(permitted, new, old)) &&\n\t    ((bprm->unsafe & ~LSM_UNSAFE_PTRACE) ||\n\t     !ptracer_capable(current, new->user_ns))) {\n\t\t/* downgrade; they get no more than they had, and maybe less */\n\t\tif (!ns_capable(new->user_ns, CAP_SETUID) ||\n\t\t    (bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS)) {\n\t\t\tnew->euid = new->uid;\n\t\t\tnew->egid = new->gid;\n\t\t}\n\t\tnew->cap_permitted = cap_intersect(new->cap_permitted,\n\t\t\t\t\t\t   old->cap_permitted);\n\t}\n\n\tnew->suid = new->fsuid = new->euid;\n\tnew->sgid = new->fsgid = new->egid;\n\n\t/* File caps or setid cancels ambient. */\n\tif (has_fcap || is_setid)\n\t\tcap_clear(new->cap_ambient);\n\n\t/*\n\t * Now that we've computed pA', update pP' to give:\n\t *   pP' = (X & fP) | (pI & fI) | pA'\n\t */\n\tnew->cap_permitted = cap_combine(new->cap_permitted, new->cap_ambient);\n\n\t/*\n\t * Set pE' = (fE ? pP' : pA').  Because pA' is zero if fE is set,\n\t * this is the same as pE' = (fE ? pP' : 0) | pA'.\n\t */\n\tif (effective)\n\t\tnew->cap_effective = new->cap_permitted;\n\telse\n\t\tnew->cap_effective = new->cap_ambient;\n\n\tif (WARN_ON(!cap_ambient_invariant_ok(new)))\n\t\treturn -EPERM;\n\n\tif (nonroot_raised_pE(new, old, root_uid, has_fcap)) {\n\t\tret = audit_log_bprm_fcaps(bprm, new, old);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\n\n\tif (WARN_ON(!cap_ambient_invariant_ok(new)))\n\t\treturn -EPERM;\n\n\t/* Check for privilege-elevated exec. */\n\tbprm->cap_elevated = 0;\n\tif (is_setid ||\n\t    (!__is_real(root_uid, new) &&\n\t     (effective ||\n\t      __cap_grew(permitted, ambient, new))))\n\t\tbprm->cap_elevated = 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nonroot_raised_pE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "786-806",
    "snippet": "static inline bool nonroot_raised_pE(struct cred *new, const struct cred *old,\n\t\t\t\t     kuid_t root, bool has_fcap)\n{\n\tbool ret = false;\n\n\tif ((__cap_grew(effective, ambient, new) &&\n\t     !(__cap_full(effective, new) &&\n\t       (__is_eff(root, new) || __is_real(root, new)) &&\n\t       root_privileged())) ||\n\t    (root_privileged() &&\n\t     __is_suid(root, new) &&\n\t     !__cap_full(effective, new)) ||\n\t    (!__is_setuid(new, old) &&\n\t     ((has_fcap &&\n\t       __cap_gained(permitted, new, old)) ||\n\t      __cap_gained(ambient, new, old))))\n\n\t\tret = true;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cap_gained",
          "args": [
            "ambient",
            "new",
            "old"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cap_gained",
          "args": [
            "permitted",
            "new",
            "old"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__is_setuid",
          "args": [
            "new",
            "old"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "__is_setuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "763-764",
          "snippet": "static inline bool __is_setuid(struct cred *new, const struct cred *old)\n{ return !uid_eq(new->euid, old->uid); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_setuid(struct cred *new, const struct cred *old)\n{ return !uid_eq(new->euid, old->uid); }"
        }
      },
      {
        "call_info": {
          "callee": "__cap_full",
          "args": [
            "effective",
            "new"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__is_suid",
          "args": [
            "root",
            "new"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "__is_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "707-708",
          "snippet": "static inline bool __is_suid(kuid_t uid, struct cred *cred)\n{ return !__is_real(uid, cred) && __is_eff(uid, cred); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_suid(kuid_t uid, struct cred *cred)\n{ return !__is_real(uid, cred) && __is_eff(uid, cred); }"
        }
      },
      {
        "call_info": {
          "callee": "root_privileged",
          "args": [],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "root_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "699-699",
          "snippet": "static inline bool root_privileged(void) { return !issecure(SECURE_NOROOT); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool root_privileged(void) { return !issecure(SECURE_NOROOT); }"
        }
      },
      {
        "call_info": {
          "callee": "__is_real",
          "args": [
            "root",
            "new"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "__is_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "701-702",
          "snippet": "static inline bool __is_real(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->uid, uid); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_real(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->uid, uid); }"
        }
      },
      {
        "call_info": {
          "callee": "__is_eff",
          "args": [
            "root",
            "new"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "__is_eff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "704-705",
          "snippet": "static inline bool __is_eff(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->euid, uid); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_eff(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->euid, uid); }"
        }
      },
      {
        "call_info": {
          "callee": "__cap_full",
          "args": [
            "effective",
            "new"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cap_grew",
          "args": [
            "effective",
            "ambient",
            "new"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool nonroot_raised_pE(struct cred *new, const struct cred *old,\n\t\t\t\t     kuid_t root, bool has_fcap)\n{\n\tbool ret = false;\n\n\tif ((__cap_grew(effective, ambient, new) &&\n\t     !(__cap_full(effective, new) &&\n\t       (__is_eff(root, new) || __is_real(root, new)) &&\n\t       root_privileged())) ||\n\t    (root_privileged() &&\n\t     __is_suid(root, new) &&\n\t     !__cap_full(effective, new)) ||\n\t    (!__is_setuid(new, old) &&\n\t     ((has_fcap &&\n\t       __cap_gained(permitted, new, old)) ||\n\t      __cap_gained(ambient, new, old))))\n\n\t\tret = true;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__is_setgid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "766-767",
    "snippet": "static inline bool __is_setgid(struct cred *new, const struct cred *old)\n{ return !gid_eq(new->egid, old->gid); }",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "new->egid",
            "old->gid"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_setgid(struct cred *new, const struct cred *old)\n{ return !gid_eq(new->egid, old->gid); }"
  },
  {
    "function_name": "__is_setuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "763-764",
    "snippet": "static inline bool __is_setuid(struct cred *new, const struct cred *old)\n{ return !uid_eq(new->euid, old->uid); }",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->euid",
            "old->uid"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_setuid(struct cred *new, const struct cred *old)\n{ return !uid_eq(new->euid, old->uid); }"
  },
  {
    "function_name": "handle_privileged_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "722-754",
    "snippet": "static void handle_privileged_root(struct linux_binprm *bprm, bool has_fcap,\n\t\t\t\t   bool *effective, kuid_t root_uid)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\n\tif (!root_privileged())\n\t\treturn;\n\t/*\n\t * If the legacy file capability is set, then don't set privs\n\t * for a setuid root binary run by a non-root user.  Do set it\n\t * for a root user just to cause least surprise to an admin.\n\t */\n\tif (has_fcap && __is_suid(root_uid, new)) {\n\t\twarn_setuid_and_fcaps_mixed(bprm->filename);\n\t\treturn;\n\t}\n\t/*\n\t * To support inheritance of root-permissions and suid-root\n\t * executables under compatibility mode, we override the\n\t * capability sets for the file.\n\t */\n\tif (__is_eff(root_uid, new) || __is_real(root_uid, new)) {\n\t\t/* pP' = (cap_bset & ~0) | (pI & ~0) */\n\t\tnew->cap_permitted = cap_combine(old->cap_bset,\n\t\t\t\t\t\t old->cap_inheritable);\n\t}\n\t/*\n\t * If only the real uid is 0, we do not set the effective bit.\n\t */\n\tif (__is_eff(root_uid, new))\n\t\t*effective = true;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__is_eff",
          "args": [
            "root_uid",
            "new"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "__is_eff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "704-705",
          "snippet": "static inline bool __is_eff(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->euid, uid); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_eff(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->euid, uid); }"
        }
      },
      {
        "call_info": {
          "callee": "cap_combine",
          "args": [
            "old->cap_bset",
            "old->cap_inheritable"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__is_real",
          "args": [
            "root_uid",
            "new"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "__is_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "701-702",
          "snippet": "static inline bool __is_real(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->uid, uid); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_real(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->uid, uid); }"
        }
      },
      {
        "call_info": {
          "callee": "warn_setuid_and_fcaps_mixed",
          "args": [
            "bprm->filename"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "warn_setuid_and_fcaps_mixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "45-54",
          "snippet": "static void warn_setuid_and_fcaps_mixed(const char *fname)\n{\n\tstatic int warned;\n\tif (!warned) {\n\t\tprintk(KERN_INFO \"warning: `%s' has both setuid-root and\"\n\t\t\t\" effective capabilities. Therefore not raising all\"\n\t\t\t\" capabilities.\\n\", fname);\n\t\twarned = 1;\n\t}\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic void warn_setuid_and_fcaps_mixed(const char *fname)\n{\n\tstatic int warned;\n\tif (!warned) {\n\t\tprintk(KERN_INFO \"warning: `%s' has both setuid-root and\"\n\t\t\t\" effective capabilities. Therefore not raising all\"\n\t\t\t\" capabilities.\\n\", fname);\n\t\twarned = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__is_suid",
          "args": [
            "root_uid",
            "new"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "__is_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "707-708",
          "snippet": "static inline bool __is_suid(kuid_t uid, struct cred *cred)\n{ return !__is_real(uid, cred) && __is_eff(uid, cred); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_suid(kuid_t uid, struct cred *cred)\n{ return !__is_real(uid, cred) && __is_eff(uid, cred); }"
        }
      },
      {
        "call_info": {
          "callee": "root_privileged",
          "args": [],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "root_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "699-699",
          "snippet": "static inline bool root_privileged(void) { return !issecure(SECURE_NOROOT); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool root_privileged(void) { return !issecure(SECURE_NOROOT); }"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic void handle_privileged_root(struct linux_binprm *bprm, bool has_fcap,\n\t\t\t\t   bool *effective, kuid_t root_uid)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\n\tif (!root_privileged())\n\t\treturn;\n\t/*\n\t * If the legacy file capability is set, then don't set privs\n\t * for a setuid root binary run by a non-root user.  Do set it\n\t * for a root user just to cause least surprise to an admin.\n\t */\n\tif (has_fcap && __is_suid(root_uid, new)) {\n\t\twarn_setuid_and_fcaps_mixed(bprm->filename);\n\t\treturn;\n\t}\n\t/*\n\t * To support inheritance of root-permissions and suid-root\n\t * executables under compatibility mode, we override the\n\t * capability sets for the file.\n\t */\n\tif (__is_eff(root_uid, new) || __is_real(root_uid, new)) {\n\t\t/* pP' = (cap_bset & ~0) | (pI & ~0) */\n\t\tnew->cap_permitted = cap_combine(old->cap_bset,\n\t\t\t\t\t\t old->cap_inheritable);\n\t}\n\t/*\n\t * If only the real uid is 0, we do not set the effective bit.\n\t */\n\tif (__is_eff(root_uid, new))\n\t\t*effective = true;\n}"
  },
  {
    "function_name": "__is_suid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "707-708",
    "snippet": "static inline bool __is_suid(kuid_t uid, struct cred *cred)\n{ return !__is_real(uid, cred) && __is_eff(uid, cred); }",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__is_eff",
          "args": [
            "uid",
            "cred"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "__is_eff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "704-705",
          "snippet": "static inline bool __is_eff(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->euid, uid); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_eff(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->euid, uid); }"
        }
      },
      {
        "call_info": {
          "callee": "__is_real",
          "args": [
            "uid",
            "cred"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "__is_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "701-702",
          "snippet": "static inline bool __is_real(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->uid, uid); }",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_real(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->uid, uid); }"
        }
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_suid(kuid_t uid, struct cred *cred)\n{ return !__is_real(uid, cred) && __is_eff(uid, cred); }"
  },
  {
    "function_name": "__is_eff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "704-705",
    "snippet": "static inline bool __is_eff(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->euid, uid); }",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->euid",
            "uid"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_eff(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->euid, uid); }"
  },
  {
    "function_name": "__is_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "701-702",
    "snippet": "static inline bool __is_real(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->uid, uid); }",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->uid",
            "uid"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool __is_real(kuid_t uid, struct cred *cred)\n{ return uid_eq(cred->uid, uid); }"
  },
  {
    "function_name": "root_privileged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "699-699",
    "snippet": "static inline bool root_privileged(void) { return !issecure(SECURE_NOROOT); }",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "issecure",
          "args": [
            "SECURE_NOROOT"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline bool root_privileged(void) { return !issecure(SECURE_NOROOT); }"
  },
  {
    "function_name": "get_file_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "656-697",
    "snippet": "static int get_file_caps(struct linux_binprm *bprm, bool *effective, bool *has_fcap)\n{\n\tint rc = 0;\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tcap_clear(bprm->cred->cap_permitted);\n\n\tif (!file_caps_enabled)\n\t\treturn 0;\n\n\tif (!mnt_may_suid(bprm->file->f_path.mnt))\n\t\treturn 0;\n\n\t/*\n\t * This check is redundant with mnt_may_suid() but is kept to make\n\t * explicit that capability bits are limited to s_user_ns and its\n\t * descendants.\n\t */\n\tif (!current_in_userns(bprm->file->f_path.mnt->mnt_sb->s_user_ns))\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(bprm->file->f_path.dentry, &vcaps);\n\tif (rc < 0) {\n\t\tif (rc == -EINVAL)\n\t\t\tprintk(KERN_NOTICE \"Invalid argument reading file caps for %s\\n\",\n\t\t\t\t\tbprm->filename);\n\t\telse if (rc == -ENODATA)\n\t\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = bprm_caps_from_vfs_caps(&vcaps, bprm, effective, has_fcap);\n\tif (rc == -EINVAL)\n\t\tprintk(KERN_NOTICE \"%s: cap_from_disk returned %d for %s\\n\",\n\t\t       __func__, rc, bprm->filename);\n\nout:\n\tif (rc)\n\t\tcap_clear(bprm->cred->cap_permitted);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap_clear",
          "args": [
            "bprm->cred->cap_permitted"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"%s: cap_from_disk returned %d for %s\\n\"",
            "__func__",
            "rc",
            "bprm->filename"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_xprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1764-1785",
          "snippet": "void aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bprm_caps_from_vfs_caps",
          "args": [
            "&vcaps",
            "bprm",
            "effective",
            "has_fcap"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "bprm_caps_from_vfs_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "536-574",
          "snippet": "static inline int bprm_caps_from_vfs_caps(struct cpu_vfs_cap_data *caps,\n\t\t\t\t\t  struct linux_binprm *bprm,\n\t\t\t\t\t  bool *effective,\n\t\t\t\t\t  bool *has_fcap)\n{\n\tstruct cred *new = bprm->cred;\n\tunsigned i;\n\tint ret = 0;\n\n\tif (caps->magic_etc & VFS_CAP_FLAGS_EFFECTIVE)\n\t\t*effective = true;\n\n\tif (caps->magic_etc & VFS_CAP_REVISION_MASK)\n\t\t*has_fcap = true;\n\n\tCAP_FOR_EACH_U32(i) {\n\t\t__u32 permitted = caps->permitted.cap[i];\n\t\t__u32 inheritable = caps->inheritable.cap[i];\n\n\t\t/*\n\t\t * pP' = (X & fP) | (pI & fI)\n\t\t * The addition of pA' is handled later.\n\t\t */\n\t\tnew->cap_permitted.cap[i] =\n\t\t\t(new->cap_bset.cap[i] & permitted) |\n\t\t\t(new->cap_inheritable.cap[i] & inheritable);\n\n\t\tif (permitted & ~new->cap_permitted.cap[i])\n\t\t\t/* insufficient to execute correctly */\n\t\t\tret = -EPERM;\n\t}\n\n\t/*\n\t * For legacy apps, with no internal support for recognizing they\n\t * do not have enough capabilities, we return an error if they are\n\t * missing some \"forced\" (aka file-permitted) capabilities.\n\t */\n\treturn *effective ? ret : 0;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline int bprm_caps_from_vfs_caps(struct cpu_vfs_cap_data *caps,\n\t\t\t\t\t  struct linux_binprm *bprm,\n\t\t\t\t\t  bool *effective,\n\t\t\t\t\t  bool *has_fcap)\n{\n\tstruct cred *new = bprm->cred;\n\tunsigned i;\n\tint ret = 0;\n\n\tif (caps->magic_etc & VFS_CAP_FLAGS_EFFECTIVE)\n\t\t*effective = true;\n\n\tif (caps->magic_etc & VFS_CAP_REVISION_MASK)\n\t\t*has_fcap = true;\n\n\tCAP_FOR_EACH_U32(i) {\n\t\t__u32 permitted = caps->permitted.cap[i];\n\t\t__u32 inheritable = caps->inheritable.cap[i];\n\n\t\t/*\n\t\t * pP' = (X & fP) | (pI & fI)\n\t\t * The addition of pA' is handled later.\n\t\t */\n\t\tnew->cap_permitted.cap[i] =\n\t\t\t(new->cap_bset.cap[i] & permitted) |\n\t\t\t(new->cap_inheritable.cap[i] & inheritable);\n\n\t\tif (permitted & ~new->cap_permitted.cap[i])\n\t\t\t/* insufficient to execute correctly */\n\t\t\tret = -EPERM;\n\t}\n\n\t/*\n\t * For legacy apps, with no internal support for recognizing they\n\t * do not have enough capabilities, we return an error if they are\n\t * missing some \"forced\" (aka file-permitted) capabilities.\n\t */\n\treturn *effective ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"Invalid argument reading file caps for %s\\n\"",
            "bprm->filename"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vfs_caps_from_disk",
          "args": [
            "bprm->file->f_path.dentry",
            "&vcaps"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "get_vfs_caps_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "579-649",
          "snippet": "int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\t__u32 magic_etc;\n\tunsigned tocopy, i;\n\tint size;\n\tstruct vfs_ns_cap_data data, *nscaps = &data;\n\tstruct vfs_cap_data *caps = (struct vfs_cap_data *) &data;\n\tkuid_t rootkuid;\n\tstruct user_namespace *fs_ns;\n\n\tmemset(cpu_caps, 0, sizeof(struct cpu_vfs_cap_data));\n\n\tif (!inode)\n\t\treturn -ENODATA;\n\n\tfs_ns = inode->i_sb->s_user_ns;\n\tsize = __vfs_getxattr((struct dentry *)dentry, inode,\n\t\t\t      XATTR_NAME_CAPS, &data, XATTR_CAPS_SZ);\n\tif (size == -ENODATA || size == -EOPNOTSUPP)\n\t\t/* no data, that's ok */\n\t\treturn -ENODATA;\n\n\tif (size < 0)\n\t\treturn size;\n\n\tif (size < sizeof(magic_etc))\n\t\treturn -EINVAL;\n\n\tcpu_caps->magic_etc = magic_etc = le32_to_cpu(caps->magic_etc);\n\n\trootkuid = make_kuid(fs_ns, 0);\n\tswitch (magic_etc & VFS_CAP_REVISION_MASK) {\n\tcase VFS_CAP_REVISION_1:\n\t\tif (size != XATTR_CAPS_SZ_1)\n\t\t\treturn -EINVAL;\n\t\ttocopy = VFS_CAP_U32_1;\n\t\tbreak;\n\tcase VFS_CAP_REVISION_2:\n\t\tif (size != XATTR_CAPS_SZ_2)\n\t\t\treturn -EINVAL;\n\t\ttocopy = VFS_CAP_U32_2;\n\t\tbreak;\n\tcase VFS_CAP_REVISION_3:\n\t\tif (size != XATTR_CAPS_SZ_3)\n\t\t\treturn -EINVAL;\n\t\ttocopy = VFS_CAP_U32_3;\n\t\trootkuid = make_kuid(fs_ns, le32_to_cpu(nscaps->rootid));\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t/* Limit the caps to the mounter of the filesystem\n\t * or the more limited uid specified in the xattr.\n\t */\n\tif (!rootid_owns_currentns(rootkuid))\n\t\treturn -ENODATA;\n\n\tCAP_FOR_EACH_U32(i) {\n\t\tif (i >= tocopy)\n\t\t\tbreak;\n\t\tcpu_caps->permitted.cap[i] = le32_to_cpu(caps->data[i].permitted);\n\t\tcpu_caps->inheritable.cap[i] = le32_to_cpu(caps->data[i].inheritable);\n\t}\n\n\tcpu_caps->permitted.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\tcpu_caps->inheritable.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\t__u32 magic_etc;\n\tunsigned tocopy, i;\n\tint size;\n\tstruct vfs_ns_cap_data data, *nscaps = &data;\n\tstruct vfs_cap_data *caps = (struct vfs_cap_data *) &data;\n\tkuid_t rootkuid;\n\tstruct user_namespace *fs_ns;\n\n\tmemset(cpu_caps, 0, sizeof(struct cpu_vfs_cap_data));\n\n\tif (!inode)\n\t\treturn -ENODATA;\n\n\tfs_ns = inode->i_sb->s_user_ns;\n\tsize = __vfs_getxattr((struct dentry *)dentry, inode,\n\t\t\t      XATTR_NAME_CAPS, &data, XATTR_CAPS_SZ);\n\tif (size == -ENODATA || size == -EOPNOTSUPP)\n\t\t/* no data, that's ok */\n\t\treturn -ENODATA;\n\n\tif (size < 0)\n\t\treturn size;\n\n\tif (size < sizeof(magic_etc))\n\t\treturn -EINVAL;\n\n\tcpu_caps->magic_etc = magic_etc = le32_to_cpu(caps->magic_etc);\n\n\trootkuid = make_kuid(fs_ns, 0);\n\tswitch (magic_etc & VFS_CAP_REVISION_MASK) {\n\tcase VFS_CAP_REVISION_1:\n\t\tif (size != XATTR_CAPS_SZ_1)\n\t\t\treturn -EINVAL;\n\t\ttocopy = VFS_CAP_U32_1;\n\t\tbreak;\n\tcase VFS_CAP_REVISION_2:\n\t\tif (size != XATTR_CAPS_SZ_2)\n\t\t\treturn -EINVAL;\n\t\ttocopy = VFS_CAP_U32_2;\n\t\tbreak;\n\tcase VFS_CAP_REVISION_3:\n\t\tif (size != XATTR_CAPS_SZ_3)\n\t\t\treturn -EINVAL;\n\t\ttocopy = VFS_CAP_U32_3;\n\t\trootkuid = make_kuid(fs_ns, le32_to_cpu(nscaps->rootid));\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t/* Limit the caps to the mounter of the filesystem\n\t * or the more limited uid specified in the xattr.\n\t */\n\tif (!rootid_owns_currentns(rootkuid))\n\t\treturn -ENODATA;\n\n\tCAP_FOR_EACH_U32(i) {\n\t\tif (i >= tocopy)\n\t\t\tbreak;\n\t\tcpu_caps->permitted.cap[i] = le32_to_cpu(caps->data[i].permitted);\n\t\tcpu_caps->inheritable.cap[i] = le32_to_cpu(caps->data[i].inheritable);\n\t}\n\n\tcpu_caps->permitted.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\tcpu_caps->inheritable.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_in_userns",
          "args": [
            "bprm->file->f_path.mnt->mnt_sb->s_user_ns"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_may_suid",
          "args": [
            "bprm->file->f_path.mnt"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_clear",
          "args": [
            "bprm->cred->cap_permitted"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic int get_file_caps(struct linux_binprm *bprm, bool *effective, bool *has_fcap)\n{\n\tint rc = 0;\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tcap_clear(bprm->cred->cap_permitted);\n\n\tif (!file_caps_enabled)\n\t\treturn 0;\n\n\tif (!mnt_may_suid(bprm->file->f_path.mnt))\n\t\treturn 0;\n\n\t/*\n\t * This check is redundant with mnt_may_suid() but is kept to make\n\t * explicit that capability bits are limited to s_user_ns and its\n\t * descendants.\n\t */\n\tif (!current_in_userns(bprm->file->f_path.mnt->mnt_sb->s_user_ns))\n\t\treturn 0;\n\n\trc = get_vfs_caps_from_disk(bprm->file->f_path.dentry, &vcaps);\n\tif (rc < 0) {\n\t\tif (rc == -EINVAL)\n\t\t\tprintk(KERN_NOTICE \"Invalid argument reading file caps for %s\\n\",\n\t\t\t\t\tbprm->filename);\n\t\telse if (rc == -ENODATA)\n\t\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = bprm_caps_from_vfs_caps(&vcaps, bprm, effective, has_fcap);\n\tif (rc == -EINVAL)\n\t\tprintk(KERN_NOTICE \"%s: cap_from_disk returned %d for %s\\n\",\n\t\t       __func__, rc, bprm->filename);\n\nout:\n\tif (rc)\n\t\tcap_clear(bprm->cred->cap_permitted);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "get_vfs_caps_from_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "579-649",
    "snippet": "int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\t__u32 magic_etc;\n\tunsigned tocopy, i;\n\tint size;\n\tstruct vfs_ns_cap_data data, *nscaps = &data;\n\tstruct vfs_cap_data *caps = (struct vfs_cap_data *) &data;\n\tkuid_t rootkuid;\n\tstruct user_namespace *fs_ns;\n\n\tmemset(cpu_caps, 0, sizeof(struct cpu_vfs_cap_data));\n\n\tif (!inode)\n\t\treturn -ENODATA;\n\n\tfs_ns = inode->i_sb->s_user_ns;\n\tsize = __vfs_getxattr((struct dentry *)dentry, inode,\n\t\t\t      XATTR_NAME_CAPS, &data, XATTR_CAPS_SZ);\n\tif (size == -ENODATA || size == -EOPNOTSUPP)\n\t\t/* no data, that's ok */\n\t\treturn -ENODATA;\n\n\tif (size < 0)\n\t\treturn size;\n\n\tif (size < sizeof(magic_etc))\n\t\treturn -EINVAL;\n\n\tcpu_caps->magic_etc = magic_etc = le32_to_cpu(caps->magic_etc);\n\n\trootkuid = make_kuid(fs_ns, 0);\n\tswitch (magic_etc & VFS_CAP_REVISION_MASK) {\n\tcase VFS_CAP_REVISION_1:\n\t\tif (size != XATTR_CAPS_SZ_1)\n\t\t\treturn -EINVAL;\n\t\ttocopy = VFS_CAP_U32_1;\n\t\tbreak;\n\tcase VFS_CAP_REVISION_2:\n\t\tif (size != XATTR_CAPS_SZ_2)\n\t\t\treturn -EINVAL;\n\t\ttocopy = VFS_CAP_U32_2;\n\t\tbreak;\n\tcase VFS_CAP_REVISION_3:\n\t\tif (size != XATTR_CAPS_SZ_3)\n\t\t\treturn -EINVAL;\n\t\ttocopy = VFS_CAP_U32_3;\n\t\trootkuid = make_kuid(fs_ns, le32_to_cpu(nscaps->rootid));\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t/* Limit the caps to the mounter of the filesystem\n\t * or the more limited uid specified in the xattr.\n\t */\n\tif (!rootid_owns_currentns(rootkuid))\n\t\treturn -ENODATA;\n\n\tCAP_FOR_EACH_U32(i) {\n\t\tif (i >= tocopy)\n\t\t\tbreak;\n\t\tcpu_caps->permitted.cap[i] = le32_to_cpu(caps->data[i].permitted);\n\t\tcpu_caps->inheritable.cap[i] = le32_to_cpu(caps->data[i].inheritable);\n\t}\n\n\tcpu_caps->permitted.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\tcpu_caps->inheritable.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "caps->data[i].inheritable"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "caps->data[i].permitted"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rootid_owns_currentns",
          "args": [
            "rootkuid"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "rootid_owns_currentns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "329-344",
          "snippet": "static bool rootid_owns_currentns(kuid_t kroot)\n{\n\tstruct user_namespace *ns;\n\n\tif (!uid_valid(kroot))\n\t\treturn false;\n\n\tfor (ns = current_user_ns(); ; ns = ns->parent) {\n\t\tif (from_kuid(ns, kroot) == 0)\n\t\t\treturn true;\n\t\tif (ns == &init_user_ns)\n\t\t\tbreak;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic bool rootid_owns_currentns(kuid_t kroot)\n{\n\tstruct user_namespace *ns;\n\n\tif (!uid_valid(kroot))\n\t\treturn false;\n\n\tfor (ns = current_user_ns(); ; ns = ns->parent) {\n\t\tif (from_kuid(ns, kroot) == 0)\n\t\t\treturn true;\n\t\tif (ns == &init_user_ns)\n\t\t\tbreak;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "fs_ns",
            "le32_to_cpu(nscaps->rootid)"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "nscaps->rootid"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "fs_ns",
            "0"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "caps->magic_etc"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vfs_getxattr",
          "args": [
            "(struct dentry *)dentry",
            "inode",
            "XATTR_NAME_CAPS",
            "&data",
            "XATTR_CAPS_SZ"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cpu_caps",
            "0",
            "sizeof(struct cpu_vfs_cap_data)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\t__u32 magic_etc;\n\tunsigned tocopy, i;\n\tint size;\n\tstruct vfs_ns_cap_data data, *nscaps = &data;\n\tstruct vfs_cap_data *caps = (struct vfs_cap_data *) &data;\n\tkuid_t rootkuid;\n\tstruct user_namespace *fs_ns;\n\n\tmemset(cpu_caps, 0, sizeof(struct cpu_vfs_cap_data));\n\n\tif (!inode)\n\t\treturn -ENODATA;\n\n\tfs_ns = inode->i_sb->s_user_ns;\n\tsize = __vfs_getxattr((struct dentry *)dentry, inode,\n\t\t\t      XATTR_NAME_CAPS, &data, XATTR_CAPS_SZ);\n\tif (size == -ENODATA || size == -EOPNOTSUPP)\n\t\t/* no data, that's ok */\n\t\treturn -ENODATA;\n\n\tif (size < 0)\n\t\treturn size;\n\n\tif (size < sizeof(magic_etc))\n\t\treturn -EINVAL;\n\n\tcpu_caps->magic_etc = magic_etc = le32_to_cpu(caps->magic_etc);\n\n\trootkuid = make_kuid(fs_ns, 0);\n\tswitch (magic_etc & VFS_CAP_REVISION_MASK) {\n\tcase VFS_CAP_REVISION_1:\n\t\tif (size != XATTR_CAPS_SZ_1)\n\t\t\treturn -EINVAL;\n\t\ttocopy = VFS_CAP_U32_1;\n\t\tbreak;\n\tcase VFS_CAP_REVISION_2:\n\t\tif (size != XATTR_CAPS_SZ_2)\n\t\t\treturn -EINVAL;\n\t\ttocopy = VFS_CAP_U32_2;\n\t\tbreak;\n\tcase VFS_CAP_REVISION_3:\n\t\tif (size != XATTR_CAPS_SZ_3)\n\t\t\treturn -EINVAL;\n\t\ttocopy = VFS_CAP_U32_3;\n\t\trootkuid = make_kuid(fs_ns, le32_to_cpu(nscaps->rootid));\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t/* Limit the caps to the mounter of the filesystem\n\t * or the more limited uid specified in the xattr.\n\t */\n\tif (!rootid_owns_currentns(rootkuid))\n\t\treturn -ENODATA;\n\n\tCAP_FOR_EACH_U32(i) {\n\t\tif (i >= tocopy)\n\t\t\tbreak;\n\t\tcpu_caps->permitted.cap[i] = le32_to_cpu(caps->data[i].permitted);\n\t\tcpu_caps->inheritable.cap[i] = le32_to_cpu(caps->data[i].inheritable);\n\t}\n\n\tcpu_caps->permitted.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\tcpu_caps->inheritable.cap[CAP_LAST_U32] &= CAP_LAST_U32_VALID_MASK;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bprm_caps_from_vfs_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "536-574",
    "snippet": "static inline int bprm_caps_from_vfs_caps(struct cpu_vfs_cap_data *caps,\n\t\t\t\t\t  struct linux_binprm *bprm,\n\t\t\t\t\t  bool *effective,\n\t\t\t\t\t  bool *has_fcap)\n{\n\tstruct cred *new = bprm->cred;\n\tunsigned i;\n\tint ret = 0;\n\n\tif (caps->magic_etc & VFS_CAP_FLAGS_EFFECTIVE)\n\t\t*effective = true;\n\n\tif (caps->magic_etc & VFS_CAP_REVISION_MASK)\n\t\t*has_fcap = true;\n\n\tCAP_FOR_EACH_U32(i) {\n\t\t__u32 permitted = caps->permitted.cap[i];\n\t\t__u32 inheritable = caps->inheritable.cap[i];\n\n\t\t/*\n\t\t * pP' = (X & fP) | (pI & fI)\n\t\t * The addition of pA' is handled later.\n\t\t */\n\t\tnew->cap_permitted.cap[i] =\n\t\t\t(new->cap_bset.cap[i] & permitted) |\n\t\t\t(new->cap_inheritable.cap[i] & inheritable);\n\n\t\tif (permitted & ~new->cap_permitted.cap[i])\n\t\t\t/* insufficient to execute correctly */\n\t\t\tret = -EPERM;\n\t}\n\n\t/*\n\t * For legacy apps, with no internal support for recognizing they\n\t * do not have enough capabilities, we return an error if they are\n\t * missing some \"forced\" (aka file-permitted) capabilities.\n\t */\n\treturn *effective ? ret : 0;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline int bprm_caps_from_vfs_caps(struct cpu_vfs_cap_data *caps,\n\t\t\t\t\t  struct linux_binprm *bprm,\n\t\t\t\t\t  bool *effective,\n\t\t\t\t\t  bool *has_fcap)\n{\n\tstruct cred *new = bprm->cred;\n\tunsigned i;\n\tint ret = 0;\n\n\tif (caps->magic_etc & VFS_CAP_FLAGS_EFFECTIVE)\n\t\t*effective = true;\n\n\tif (caps->magic_etc & VFS_CAP_REVISION_MASK)\n\t\t*has_fcap = true;\n\n\tCAP_FOR_EACH_U32(i) {\n\t\t__u32 permitted = caps->permitted.cap[i];\n\t\t__u32 inheritable = caps->inheritable.cap[i];\n\n\t\t/*\n\t\t * pP' = (X & fP) | (pI & fI)\n\t\t * The addition of pA' is handled later.\n\t\t */\n\t\tnew->cap_permitted.cap[i] =\n\t\t\t(new->cap_bset.cap[i] & permitted) |\n\t\t\t(new->cap_inheritable.cap[i] & inheritable);\n\n\t\tif (permitted & ~new->cap_permitted.cap[i])\n\t\t\t/* insufficient to execute correctly */\n\t\t\tret = -EPERM;\n\t}\n\n\t/*\n\t * For legacy apps, with no internal support for recognizing they\n\t * do not have enough capabilities, we return an error if they are\n\t * missing some \"forced\" (aka file-permitted) capabilities.\n\t */\n\treturn *effective ? ret : 0;\n}"
  },
  {
    "function_name": "cap_convert_nscap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "484-530",
    "snippet": "int cap_convert_nscap(struct dentry *dentry, void **ivalue, size_t size)\n{\n\tstruct vfs_ns_cap_data *nscap;\n\tuid_t nsrootid;\n\tconst struct vfs_cap_data *cap = *ivalue;\n\t__u32 magic, nsmagic;\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct user_namespace *task_ns = current_user_ns(),\n\t\t*fs_ns = inode->i_sb->s_user_ns;\n\tkuid_t rootid;\n\tsize_t newsize;\n\n\tif (!*ivalue)\n\t\treturn -EINVAL;\n\tif (!validheader(size, cap->magic_etc))\n\t\treturn -EINVAL;\n\tif (!capable_wrt_inode_uidgid(inode, CAP_SETFCAP))\n\t\treturn -EPERM;\n\tif (size == XATTR_CAPS_SZ_2)\n\t\tif (ns_capable(inode->i_sb->s_user_ns, CAP_SETFCAP))\n\t\t\t/* user is privileged, just write the v2 */\n\t\t\treturn size;\n\n\trootid = rootid_from_xattr(*ivalue, size, task_ns);\n\tif (!uid_valid(rootid))\n\t\treturn -EINVAL;\n\n\tnsrootid = from_kuid(fs_ns, rootid);\n\tif (nsrootid == -1)\n\t\treturn -EINVAL;\n\n\tnewsize = sizeof(struct vfs_ns_cap_data);\n\tnscap = kmalloc(newsize, GFP_ATOMIC);\n\tif (!nscap)\n\t\treturn -ENOMEM;\n\tnscap->rootid = cpu_to_le32(nsrootid);\n\tnsmagic = VFS_CAP_REVISION_3;\n\tmagic = le32_to_cpu(cap->magic_etc);\n\tif (magic & VFS_CAP_FLAGS_EFFECTIVE)\n\t\tnsmagic |= VFS_CAP_FLAGS_EFFECTIVE;\n\tnscap->magic_etc = cpu_to_le32(nsmagic);\n\tmemcpy(&nscap->data, &cap->data, sizeof(__le32) * 2 * VFS_CAP_U32);\n\n\tkvfree(*ivalue);\n\t*ivalue = nscap;\n\treturn newsize;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "*ivalue"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&nscap->data",
            "&cap->data",
            "sizeof(__le32) * 2 * VFS_CAP_U32"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "nsmagic"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "cap->magic_etc"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "nsrootid"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "newsize",
            "GFP_ATOMIC"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "fs_ns",
            "rootid"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "rootid"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rootid_from_xattr",
          "args": [
            "*ivalue",
            "size",
            "task_ns"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "rootid_from_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "461-471",
          "snippet": "static kuid_t rootid_from_xattr(const void *value, size_t size,\n\t\t\t\tstruct user_namespace *task_ns)\n{\n\tconst struct vfs_ns_cap_data *nscap = value;\n\tuid_t rootid = 0;\n\n\tif (size == XATTR_CAPS_SZ_3)\n\t\trootid = le32_to_cpu(nscap->rootid);\n\n\treturn make_kuid(task_ns, rootid);\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic kuid_t rootid_from_xattr(const void *value, size_t size,\n\t\t\t\tstruct user_namespace *task_ns)\n{\n\tconst struct vfs_ns_cap_data *nscap = value;\n\tuid_t rootid = 0;\n\n\tif (size == XATTR_CAPS_SZ_3)\n\t\trootid = le32_to_cpu(nscap->rootid);\n\n\treturn make_kuid(task_ns, rootid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "inode->i_sb->s_user_ns",
            "CAP_SETFCAP"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable_wrt_inode_uidgid",
          "args": [
            "inode",
            "CAP_SETFCAP"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validheader",
          "args": [
            "size",
            "cap->magic_etc"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "validheader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "473-476",
          "snippet": "static bool validheader(size_t size, __le32 magic)\n{\n\treturn is_v2header(size, magic) || is_v3header(size, magic);\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic bool validheader(size_t size, __le32 magic)\n{\n\treturn is_v2header(size, magic) || is_v3header(size, magic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_convert_nscap(struct dentry *dentry, void **ivalue, size_t size)\n{\n\tstruct vfs_ns_cap_data *nscap;\n\tuid_t nsrootid;\n\tconst struct vfs_cap_data *cap = *ivalue;\n\t__u32 magic, nsmagic;\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct user_namespace *task_ns = current_user_ns(),\n\t\t*fs_ns = inode->i_sb->s_user_ns;\n\tkuid_t rootid;\n\tsize_t newsize;\n\n\tif (!*ivalue)\n\t\treturn -EINVAL;\n\tif (!validheader(size, cap->magic_etc))\n\t\treturn -EINVAL;\n\tif (!capable_wrt_inode_uidgid(inode, CAP_SETFCAP))\n\t\treturn -EPERM;\n\tif (size == XATTR_CAPS_SZ_2)\n\t\tif (ns_capable(inode->i_sb->s_user_ns, CAP_SETFCAP))\n\t\t\t/* user is privileged, just write the v2 */\n\t\t\treturn size;\n\n\trootid = rootid_from_xattr(*ivalue, size, task_ns);\n\tif (!uid_valid(rootid))\n\t\treturn -EINVAL;\n\n\tnsrootid = from_kuid(fs_ns, rootid);\n\tif (nsrootid == -1)\n\t\treturn -EINVAL;\n\n\tnewsize = sizeof(struct vfs_ns_cap_data);\n\tnscap = kmalloc(newsize, GFP_ATOMIC);\n\tif (!nscap)\n\t\treturn -ENOMEM;\n\tnscap->rootid = cpu_to_le32(nsrootid);\n\tnsmagic = VFS_CAP_REVISION_3;\n\tmagic = le32_to_cpu(cap->magic_etc);\n\tif (magic & VFS_CAP_FLAGS_EFFECTIVE)\n\t\tnsmagic |= VFS_CAP_FLAGS_EFFECTIVE;\n\tnscap->magic_etc = cpu_to_le32(nsmagic);\n\tmemcpy(&nscap->data, &cap->data, sizeof(__le32) * 2 * VFS_CAP_U32);\n\n\tkvfree(*ivalue);\n\t*ivalue = nscap;\n\treturn newsize;\n}"
  },
  {
    "function_name": "validheader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "473-476",
    "snippet": "static bool validheader(size_t size, __le32 magic)\n{\n\treturn is_v2header(size, magic) || is_v3header(size, magic);\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_v3header",
          "args": [
            "size",
            "magic"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "is_v3header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "359-366",
          "snippet": "static bool is_v3header(size_t size, __le32 magic)\n{\n\t__u32 m = le32_to_cpu(magic);\n\n\tif (size != XATTR_CAPS_SZ_3)\n\t\treturn false;\n\treturn sansflags(m) == VFS_CAP_REVISION_3;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic bool is_v3header(size_t size, __le32 magic)\n{\n\t__u32 m = le32_to_cpu(magic);\n\n\tif (size != XATTR_CAPS_SZ_3)\n\t\treturn false;\n\treturn sansflags(m) == VFS_CAP_REVISION_3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_v2header",
          "args": [
            "size",
            "magic"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "is_v2header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "351-357",
          "snippet": "static bool is_v2header(size_t size, __le32 magic)\n{\n\t__u32 m = le32_to_cpu(magic);\n\tif (size != XATTR_CAPS_SZ_2)\n\t\treturn false;\n\treturn sansflags(m) == VFS_CAP_REVISION_2;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic bool is_v2header(size_t size, __le32 magic)\n{\n\t__u32 m = le32_to_cpu(magic);\n\tif (size != XATTR_CAPS_SZ_2)\n\t\treturn false;\n\treturn sansflags(m) == VFS_CAP_REVISION_2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic bool validheader(size_t size, __le32 magic)\n{\n\treturn is_v2header(size, magic) || is_v3header(size, magic);\n}"
  },
  {
    "function_name": "rootid_from_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "461-471",
    "snippet": "static kuid_t rootid_from_xattr(const void *value, size_t size,\n\t\t\t\tstruct user_namespace *task_ns)\n{\n\tconst struct vfs_ns_cap_data *nscap = value;\n\tuid_t rootid = 0;\n\n\tif (size == XATTR_CAPS_SZ_3)\n\t\trootid = le32_to_cpu(nscap->rootid);\n\n\treturn make_kuid(task_ns, rootid);\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "task_ns",
            "rootid"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "nscap->rootid"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic kuid_t rootid_from_xattr(const void *value, size_t size,\n\t\t\t\tstruct user_namespace *task_ns)\n{\n\tconst struct vfs_ns_cap_data *nscap = value;\n\tuid_t rootid = 0;\n\n\tif (size == XATTR_CAPS_SZ_3)\n\t\trootid = le32_to_cpu(nscap->rootid);\n\n\treturn make_kuid(task_ns, rootid);\n}"
  },
  {
    "function_name": "cap_inode_getsecurity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "379-459",
    "snippet": "int cap_inode_getsecurity(struct inode *inode, const char *name, void **buffer,\n\t\t\t  bool alloc)\n{\n\tint size, ret;\n\tkuid_t kroot;\n\tuid_t root, mappedroot;\n\tchar *tmpbuf = NULL;\n\tstruct vfs_cap_data *cap;\n\tstruct vfs_ns_cap_data *nscap;\n\tstruct dentry *dentry;\n\tstruct user_namespace *fs_ns;\n\n\tif (strcmp(name, \"capability\") != 0)\n\t\treturn -EOPNOTSUPP;\n\n\tdentry = d_find_alias(inode);\n\tif (!dentry)\n\t\treturn -EINVAL;\n\n\tsize = sizeof(struct vfs_ns_cap_data);\n\tret = (int) vfs_getxattr_alloc(dentry, XATTR_NAME_CAPS,\n\t\t\t\t &tmpbuf, size, GFP_NOFS);\n\tdput(dentry);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfs_ns = inode->i_sb->s_user_ns;\n\tcap = (struct vfs_cap_data *) tmpbuf;\n\tif (is_v2header((size_t) ret, cap->magic_etc)) {\n\t\t/* If this is sizeof(vfs_cap_data) then we're ok with the\n\t\t * on-disk value, so return that.  */\n\t\tif (alloc)\n\t\t\t*buffer = tmpbuf;\n\t\telse\n\t\t\tkfree(tmpbuf);\n\t\treturn ret;\n\t} else if (!is_v3header((size_t) ret, cap->magic_etc)) {\n\t\tkfree(tmpbuf);\n\t\treturn -EINVAL;\n\t}\n\n\tnscap = (struct vfs_ns_cap_data *) tmpbuf;\n\troot = le32_to_cpu(nscap->rootid);\n\tkroot = make_kuid(fs_ns, root);\n\n\t/* If the root kuid maps to a valid uid in current ns, then return\n\t * this as a nscap. */\n\tmappedroot = from_kuid(current_user_ns(), kroot);\n\tif (mappedroot != (uid_t)-1 && mappedroot != (uid_t)0) {\n\t\tif (alloc) {\n\t\t\t*buffer = tmpbuf;\n\t\t\tnscap->rootid = cpu_to_le32(mappedroot);\n\t\t} else\n\t\t\tkfree(tmpbuf);\n\t\treturn size;\n\t}\n\n\tif (!rootid_owns_currentns(kroot)) {\n\t\tkfree(tmpbuf);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* This comes from a parent namespace.  Return as a v2 capability */\n\tsize = sizeof(struct vfs_cap_data);\n\tif (alloc) {\n\t\t*buffer = kmalloc(size, GFP_ATOMIC);\n\t\tif (*buffer) {\n\t\t\tstruct vfs_cap_data *cap = *buffer;\n\t\t\t__le32 nsmagic, magic;\n\t\t\tmagic = VFS_CAP_REVISION_2;\n\t\t\tnsmagic = le32_to_cpu(nscap->magic_etc);\n\t\t\tif (nsmagic & VFS_CAP_FLAGS_EFFECTIVE)\n\t\t\t\tmagic |= VFS_CAP_FLAGS_EFFECTIVE;\n\t\t\tmemcpy(&cap->data, &nscap->data, sizeof(__le32) * 2 * VFS_CAP_U32);\n\t\t\tcap->magic_etc = cpu_to_le32(magic);\n\t\t}\n\t}\n\tkfree(tmpbuf);\n\treturn size;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmpbuf"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "magic"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&cap->data",
            "&nscap->data",
            "sizeof(__le32) * 2 * VFS_CAP_U32"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "nscap->magic_etc"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_ATOMIC"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmpbuf"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rootid_owns_currentns",
          "args": [
            "kroot"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "rootid_owns_currentns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "329-344",
          "snippet": "static bool rootid_owns_currentns(kuid_t kroot)\n{\n\tstruct user_namespace *ns;\n\n\tif (!uid_valid(kroot))\n\t\treturn false;\n\n\tfor (ns = current_user_ns(); ; ns = ns->parent) {\n\t\tif (from_kuid(ns, kroot) == 0)\n\t\t\treturn true;\n\t\tif (ns == &init_user_ns)\n\t\t\tbreak;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic bool rootid_owns_currentns(kuid_t kroot)\n{\n\tstruct user_namespace *ns;\n\n\tif (!uid_valid(kroot))\n\t\treturn false;\n\n\tfor (ns = current_user_ns(); ; ns = ns->parent) {\n\t\tif (from_kuid(ns, kroot) == 0)\n\t\t\treturn true;\n\t\tif (ns == &init_user_ns)\n\t\t\tbreak;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmpbuf"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "mappedroot"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "current_user_ns()",
            "kroot"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "fs_ns",
            "root"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "nscap->rootid"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmpbuf"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_v3header",
          "args": [
            "(size_t) ret",
            "cap->magic_etc"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "is_v3header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "359-366",
          "snippet": "static bool is_v3header(size_t size, __le32 magic)\n{\n\t__u32 m = le32_to_cpu(magic);\n\n\tif (size != XATTR_CAPS_SZ_3)\n\t\treturn false;\n\treturn sansflags(m) == VFS_CAP_REVISION_3;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic bool is_v3header(size_t size, __le32 magic)\n{\n\t__u32 m = le32_to_cpu(magic);\n\n\tif (size != XATTR_CAPS_SZ_3)\n\t\treturn false;\n\treturn sansflags(m) == VFS_CAP_REVISION_3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmpbuf"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_v2header",
          "args": [
            "(size_t) ret",
            "cap->magic_etc"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "is_v2header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "351-357",
          "snippet": "static bool is_v2header(size_t size, __le32 magic)\n{\n\t__u32 m = le32_to_cpu(magic);\n\tif (size != XATTR_CAPS_SZ_2)\n\t\treturn false;\n\treturn sansflags(m) == VFS_CAP_REVISION_2;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic bool is_v2header(size_t size, __le32 magic)\n{\n\t__u32 m = le32_to_cpu(magic);\n\tif (size != XATTR_CAPS_SZ_2)\n\t\treturn false;\n\treturn sansflags(m) == VFS_CAP_REVISION_2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_getxattr_alloc",
          "args": [
            "dentry",
            "XATTR_NAME_CAPS",
            "&tmpbuf",
            "size",
            "GFP_NOFS"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "inode"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"capability\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_inode_getsecurity(struct inode *inode, const char *name, void **buffer,\n\t\t\t  bool alloc)\n{\n\tint size, ret;\n\tkuid_t kroot;\n\tuid_t root, mappedroot;\n\tchar *tmpbuf = NULL;\n\tstruct vfs_cap_data *cap;\n\tstruct vfs_ns_cap_data *nscap;\n\tstruct dentry *dentry;\n\tstruct user_namespace *fs_ns;\n\n\tif (strcmp(name, \"capability\") != 0)\n\t\treturn -EOPNOTSUPP;\n\n\tdentry = d_find_alias(inode);\n\tif (!dentry)\n\t\treturn -EINVAL;\n\n\tsize = sizeof(struct vfs_ns_cap_data);\n\tret = (int) vfs_getxattr_alloc(dentry, XATTR_NAME_CAPS,\n\t\t\t\t &tmpbuf, size, GFP_NOFS);\n\tdput(dentry);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfs_ns = inode->i_sb->s_user_ns;\n\tcap = (struct vfs_cap_data *) tmpbuf;\n\tif (is_v2header((size_t) ret, cap->magic_etc)) {\n\t\t/* If this is sizeof(vfs_cap_data) then we're ok with the\n\t\t * on-disk value, so return that.  */\n\t\tif (alloc)\n\t\t\t*buffer = tmpbuf;\n\t\telse\n\t\t\tkfree(tmpbuf);\n\t\treturn ret;\n\t} else if (!is_v3header((size_t) ret, cap->magic_etc)) {\n\t\tkfree(tmpbuf);\n\t\treturn -EINVAL;\n\t}\n\n\tnscap = (struct vfs_ns_cap_data *) tmpbuf;\n\troot = le32_to_cpu(nscap->rootid);\n\tkroot = make_kuid(fs_ns, root);\n\n\t/* If the root kuid maps to a valid uid in current ns, then return\n\t * this as a nscap. */\n\tmappedroot = from_kuid(current_user_ns(), kroot);\n\tif (mappedroot != (uid_t)-1 && mappedroot != (uid_t)0) {\n\t\tif (alloc) {\n\t\t\t*buffer = tmpbuf;\n\t\t\tnscap->rootid = cpu_to_le32(mappedroot);\n\t\t} else\n\t\t\tkfree(tmpbuf);\n\t\treturn size;\n\t}\n\n\tif (!rootid_owns_currentns(kroot)) {\n\t\tkfree(tmpbuf);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* This comes from a parent namespace.  Return as a v2 capability */\n\tsize = sizeof(struct vfs_cap_data);\n\tif (alloc) {\n\t\t*buffer = kmalloc(size, GFP_ATOMIC);\n\t\tif (*buffer) {\n\t\t\tstruct vfs_cap_data *cap = *buffer;\n\t\t\t__le32 nsmagic, magic;\n\t\t\tmagic = VFS_CAP_REVISION_2;\n\t\t\tnsmagic = le32_to_cpu(nscap->magic_etc);\n\t\t\tif (nsmagic & VFS_CAP_FLAGS_EFFECTIVE)\n\t\t\t\tmagic |= VFS_CAP_FLAGS_EFFECTIVE;\n\t\t\tmemcpy(&cap->data, &nscap->data, sizeof(__le32) * 2 * VFS_CAP_U32);\n\t\t\tcap->magic_etc = cpu_to_le32(magic);\n\t\t}\n\t}\n\tkfree(tmpbuf);\n\treturn size;\n}"
  },
  {
    "function_name": "is_v3header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "359-366",
    "snippet": "static bool is_v3header(size_t size, __le32 magic)\n{\n\t__u32 m = le32_to_cpu(magic);\n\n\tif (size != XATTR_CAPS_SZ_3)\n\t\treturn false;\n\treturn sansflags(m) == VFS_CAP_REVISION_3;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sansflags",
          "args": [
            "m"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "sansflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "346-349",
          "snippet": "static __u32 sansflags(__u32 m)\n{\n\treturn m & ~VFS_CAP_FLAGS_EFFECTIVE;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic __u32 sansflags(__u32 m)\n{\n\treturn m & ~VFS_CAP_FLAGS_EFFECTIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "magic"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic bool is_v3header(size_t size, __le32 magic)\n{\n\t__u32 m = le32_to_cpu(magic);\n\n\tif (size != XATTR_CAPS_SZ_3)\n\t\treturn false;\n\treturn sansflags(m) == VFS_CAP_REVISION_3;\n}"
  },
  {
    "function_name": "is_v2header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "351-357",
    "snippet": "static bool is_v2header(size_t size, __le32 magic)\n{\n\t__u32 m = le32_to_cpu(magic);\n\tif (size != XATTR_CAPS_SZ_2)\n\t\treturn false;\n\treturn sansflags(m) == VFS_CAP_REVISION_2;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sansflags",
          "args": [
            "m"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "sansflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "346-349",
          "snippet": "static __u32 sansflags(__u32 m)\n{\n\treturn m & ~VFS_CAP_FLAGS_EFFECTIVE;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic __u32 sansflags(__u32 m)\n{\n\treturn m & ~VFS_CAP_FLAGS_EFFECTIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "magic"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic bool is_v2header(size_t size, __le32 magic)\n{\n\t__u32 m = le32_to_cpu(magic);\n\tif (size != XATTR_CAPS_SZ_2)\n\t\treturn false;\n\treturn sansflags(m) == VFS_CAP_REVISION_2;\n}"
  },
  {
    "function_name": "sansflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "346-349",
    "snippet": "static __u32 sansflags(__u32 m)\n{\n\treturn m & ~VFS_CAP_FLAGS_EFFECTIVE;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic __u32 sansflags(__u32 m)\n{\n\treturn m & ~VFS_CAP_FLAGS_EFFECTIVE;\n}"
  },
  {
    "function_name": "rootid_owns_currentns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "329-344",
    "snippet": "static bool rootid_owns_currentns(kuid_t kroot)\n{\n\tstruct user_namespace *ns;\n\n\tif (!uid_valid(kroot))\n\t\treturn false;\n\n\tfor (ns = current_user_ns(); ; ns = ns->parent) {\n\t\tif (from_kuid(ns, kroot) == 0)\n\t\t\treturn true;\n\t\tif (ns == &init_user_ns)\n\t\t\tbreak;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "ns",
            "kroot"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "kroot"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic bool rootid_owns_currentns(kuid_t kroot)\n{\n\tstruct user_namespace *ns;\n\n\tif (!uid_valid(kroot))\n\t\treturn false;\n\n\tfor (ns = current_user_ns(); ; ns = ns->parent) {\n\t\tif (from_kuid(ns, kroot) == 0)\n\t\t\treturn true;\n\t\tif (ns == &init_user_ns)\n\t\t\tbreak;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "cap_inode_killpriv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "319-327",
    "snippet": "int cap_inode_killpriv(struct dentry *dentry)\n{\n\tint error;\n\n\terror = __vfs_removexattr(dentry, XATTR_NAME_CAPS);\n\tif (error == -EOPNOTSUPP)\n\t\terror = 0;\n\treturn error;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vfs_removexattr",
          "args": [
            "dentry",
            "XATTR_NAME_CAPS"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_inode_killpriv(struct dentry *dentry)\n{\n\tint error;\n\n\terror = __vfs_removexattr(dentry, XATTR_NAME_CAPS);\n\tif (error == -EOPNOTSUPP)\n\t\terror = 0;\n\treturn error;\n}"
  },
  {
    "function_name": "cap_inode_need_killpriv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "302-309",
    "snippet": "int cap_inode_need_killpriv(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tint error;\n\n\terror = __vfs_getxattr(dentry, inode, XATTR_NAME_CAPS, NULL, 0);\n\treturn error > 0;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vfs_getxattr",
          "args": [
            "dentry",
            "inode",
            "XATTR_NAME_CAPS",
            "NULL",
            "0"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_inode_need_killpriv(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tint error;\n\n\terror = __vfs_getxattr(dentry, inode, XATTR_NAME_CAPS, NULL, 0);\n\treturn error > 0;\n}"
  },
  {
    "function_name": "cap_capset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "248-289",
    "snippet": "int cap_capset(struct cred *new,\n\t       const struct cred *old,\n\t       const kernel_cap_t *effective,\n\t       const kernel_cap_t *inheritable,\n\t       const kernel_cap_t *permitted)\n{\n\tif (cap_inh_is_capped() &&\n\t    !cap_issubset(*inheritable,\n\t\t\t  cap_combine(old->cap_inheritable,\n\t\t\t\t      old->cap_permitted)))\n\t\t/* incapable of using this inheritable set */\n\t\treturn -EPERM;\n\n\tif (!cap_issubset(*inheritable,\n\t\t\t  cap_combine(old->cap_inheritable,\n\t\t\t\t      old->cap_bset)))\n\t\t/* no new pI capabilities outside bounding set */\n\t\treturn -EPERM;\n\n\t/* verify restrictions on target's new Permitted set */\n\tif (!cap_issubset(*permitted, old->cap_permitted))\n\t\treturn -EPERM;\n\n\t/* verify the _new_Effective_ is a subset of the _new_Permitted_ */\n\tif (!cap_issubset(*effective, *permitted))\n\t\treturn -EPERM;\n\n\tnew->cap_effective   = *effective;\n\tnew->cap_inheritable = *inheritable;\n\tnew->cap_permitted   = *permitted;\n\n\t/*\n\t * Mask off ambient bits that are no longer both permitted and\n\t * inheritable.\n\t */\n\tnew->cap_ambient = cap_intersect(new->cap_ambient,\n\t\t\t\t\t cap_intersect(*permitted,\n\t\t\t\t\t\t       *inheritable));\n\tif (WARN_ON(!cap_ambient_invariant_ok(new)))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!cap_ambient_invariant_ok(new)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_ambient_invariant_ok",
          "args": [
            "new"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_intersect",
          "args": [
            "new->cap_ambient",
            "cap_intersect(*permitted,\n\t\t\t\t\t\t       *inheritable)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_intersect",
          "args": [
            "*permitted",
            "*inheritable"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_issubset",
          "args": [
            "*effective",
            "*permitted"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_issubset",
          "args": [
            "*permitted",
            "old->cap_permitted"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_issubset",
          "args": [
            "*inheritable",
            "cap_combine(old->cap_inheritable,\n\t\t\t\t      old->cap_bset)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_combine",
          "args": [
            "old->cap_inheritable",
            "old->cap_bset"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_issubset",
          "args": [
            "*inheritable",
            "cap_combine(old->cap_inheritable,\n\t\t\t\t      old->cap_permitted)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_combine",
          "args": [
            "old->cap_inheritable",
            "old->cap_permitted"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_inh_is_capped",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "cap_inh_is_capped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "224-234",
          "snippet": "static inline int cap_inh_is_capped(void)\n{\n\n\t/* they are so limited unless the current task has the CAP_SETPCAP\n\t * capability\n\t */\n\tif (cap_capable(current_cred(), current_cred()->user_ns,\n\t\t\tCAP_SETPCAP, SECURITY_CAP_AUDIT) == 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline int cap_inh_is_capped(void)\n{\n\n\t/* they are so limited unless the current task has the CAP_SETPCAP\n\t * capability\n\t */\n\tif (cap_capable(current_cred(), current_cred()->user_ns,\n\t\t\tCAP_SETPCAP, SECURITY_CAP_AUDIT) == 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_capset(struct cred *new,\n\t       const struct cred *old,\n\t       const kernel_cap_t *effective,\n\t       const kernel_cap_t *inheritable,\n\t       const kernel_cap_t *permitted)\n{\n\tif (cap_inh_is_capped() &&\n\t    !cap_issubset(*inheritable,\n\t\t\t  cap_combine(old->cap_inheritable,\n\t\t\t\t      old->cap_permitted)))\n\t\t/* incapable of using this inheritable set */\n\t\treturn -EPERM;\n\n\tif (!cap_issubset(*inheritable,\n\t\t\t  cap_combine(old->cap_inheritable,\n\t\t\t\t      old->cap_bset)))\n\t\t/* no new pI capabilities outside bounding set */\n\t\treturn -EPERM;\n\n\t/* verify restrictions on target's new Permitted set */\n\tif (!cap_issubset(*permitted, old->cap_permitted))\n\t\treturn -EPERM;\n\n\t/* verify the _new_Effective_ is a subset of the _new_Permitted_ */\n\tif (!cap_issubset(*effective, *permitted))\n\t\treturn -EPERM;\n\n\tnew->cap_effective   = *effective;\n\tnew->cap_inheritable = *inheritable;\n\tnew->cap_permitted   = *permitted;\n\n\t/*\n\t * Mask off ambient bits that are no longer both permitted and\n\t * inheritable.\n\t */\n\tnew->cap_ambient = cap_intersect(new->cap_ambient,\n\t\t\t\t\t cap_intersect(*permitted,\n\t\t\t\t\t\t       *inheritable));\n\tif (WARN_ON(!cap_ambient_invariant_ok(new)))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "cap_inh_is_capped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "224-234",
    "snippet": "static inline int cap_inh_is_capped(void)\n{\n\n\t/* they are so limited unless the current task has the CAP_SETPCAP\n\t * capability\n\t */\n\tif (cap_capable(current_cred(), current_cred()->user_ns,\n\t\t\tCAP_SETPCAP, SECURITY_CAP_AUDIT) == 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap_capable",
          "args": [
            "current_cred()",
            "current_cred()->user_ns",
            "CAP_SETPCAP",
            "SECURITY_CAP_AUDIT"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "cap_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "71-107",
          "snippet": "int cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, int audit)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t/* See if cred has the capability in the target user namespace\n\t * by examining the target user namespace and all of the target\n\t * user namespace's parents.\n\t */\n\tfor (;;) {\n\t\t/* Do we have the necessary capabilities? */\n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t/*\n\t\t * If we're already at a lower level than we're looking for,\n\t\t * we're done searching.\n\t\t */\n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t/* \n\t\t * The owner of the user namespace in the parent of the\n\t\t * user namespace has all caps.\n\t\t */\n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If you have a capability in a parent user ns, then you have\n\t\t * it over all children user namespaces as well.\n\t\t */\n\t\tns = ns->parent;\n\t}\n\n\t/* We never get here */\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, int audit)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t/* See if cred has the capability in the target user namespace\n\t * by examining the target user namespace and all of the target\n\t * user namespace's parents.\n\t */\n\tfor (;;) {\n\t\t/* Do we have the necessary capabilities? */\n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t/*\n\t\t * If we're already at a lower level than we're looking for,\n\t\t * we're done searching.\n\t\t */\n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t/* \n\t\t * The owner of the user namespace in the parent of the\n\t\t * user namespace has all caps.\n\t\t */\n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If you have a capability in a parent user ns, then you have\n\t\t * it over all children user namespaces as well.\n\t\t */\n\t\tns = ns->parent;\n\t}\n\n\t/* We never get here */\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic inline int cap_inh_is_capped(void)\n{\n\n\t/* they are so limited unless the current task has the CAP_SETPCAP\n\t * capability\n\t */\n\tif (cap_capable(current_cred(), current_cred()->user_ns,\n\t\t\tCAP_SETPCAP, SECURITY_CAP_AUDIT) == 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "cap_capget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "205-218",
    "snippet": "int cap_capget(struct task_struct *target, kernel_cap_t *effective,\n\t       kernel_cap_t *inheritable, kernel_cap_t *permitted)\n{\n\tconst struct cred *cred;\n\n\t/* Derived from kernel/capability.c:sys_capget. */\n\trcu_read_lock();\n\tcred = __task_cred(target);\n\t*effective   = cred->cap_effective;\n\t*inheritable = cred->cap_inheritable;\n\t*permitted   = cred->cap_permitted;\n\trcu_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "target"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_capget(struct task_struct *target, kernel_cap_t *effective,\n\t       kernel_cap_t *inheritable, kernel_cap_t *permitted)\n{\n\tconst struct cred *cred;\n\n\t/* Derived from kernel/capability.c:sys_capget. */\n\trcu_read_lock();\n\tcred = __task_cred(target);\n\t*effective   = cred->cap_effective;\n\t*inheritable = cred->cap_inheritable;\n\t*permitted   = cred->cap_permitted;\n\trcu_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "cap_ptrace_traceme",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "176-193",
    "snippet": "int cap_ptrace_traceme(struct task_struct *parent)\n{\n\tint ret = 0;\n\tconst struct cred *cred, *child_cred;\n\n\trcu_read_lock();\n\tcred = __task_cred(parent);\n\tchild_cred = current_cred();\n\tif (cred->user_ns == child_cred->user_ns &&\n\t    cap_issubset(child_cred->cap_permitted, cred->cap_permitted))\n\t\tgoto out;\n\tif (has_ns_capability(parent, child_cred->user_ns, CAP_SYS_PTRACE))\n\t\tgoto out;\n\tret = -EPERM;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_ns_capability",
          "args": [
            "parent",
            "child_cred->user_ns",
            "CAP_SYS_PTRACE"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_issubset",
          "args": [
            "child_cred->cap_permitted",
            "cred->cap_permitted"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "parent"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_ptrace_traceme(struct task_struct *parent)\n{\n\tint ret = 0;\n\tconst struct cred *cred, *child_cred;\n\n\trcu_read_lock();\n\tcred = __task_cred(parent);\n\tchild_cred = current_cred();\n\tif (cred->user_ns == child_cred->user_ns &&\n\t    cap_issubset(child_cred->cap_permitted, cred->cap_permitted))\n\t\tgoto out;\n\tif (has_ns_capability(parent, child_cred->user_ns, CAP_SYS_PTRACE))\n\t\tgoto out;\n\tret = -EPERM;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "cap_ptrace_access_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "139-161",
    "snippet": "int cap_ptrace_access_check(struct task_struct *child, unsigned int mode)\n{\n\tint ret = 0;\n\tconst struct cred *cred, *child_cred;\n\tconst kernel_cap_t *caller_caps;\n\n\trcu_read_lock();\n\tcred = current_cred();\n\tchild_cred = __task_cred(child);\n\tif (mode & PTRACE_MODE_FSCREDS)\n\t\tcaller_caps = &cred->cap_effective;\n\telse\n\t\tcaller_caps = &cred->cap_permitted;\n\tif (cred->user_ns == child_cred->user_ns &&\n\t    cap_issubset(child_cred->cap_permitted, *caller_caps))\n\t\tgoto out;\n\tif (ns_capable(child_cred->user_ns, CAP_SYS_PTRACE))\n\t\tgoto out;\n\tret = -EPERM;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "child_cred->user_ns",
            "CAP_SYS_PTRACE"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_issubset",
          "args": [
            "child_cred->cap_permitted",
            "*caller_caps"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "child"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_ptrace_access_check(struct task_struct *child, unsigned int mode)\n{\n\tint ret = 0;\n\tconst struct cred *cred, *child_cred;\n\tconst kernel_cap_t *caller_caps;\n\n\trcu_read_lock();\n\tcred = current_cred();\n\tchild_cred = __task_cred(child);\n\tif (mode & PTRACE_MODE_FSCREDS)\n\t\tcaller_caps = &cred->cap_effective;\n\telse\n\t\tcaller_caps = &cred->cap_permitted;\n\tif (cred->user_ns == child_cred->user_ns &&\n\t    cap_issubset(child_cred->cap_permitted, *caller_caps))\n\t\tgoto out;\n\tif (ns_capable(child_cred->user_ns, CAP_SYS_PTRACE))\n\t\tgoto out;\n\tret = -EPERM;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "cap_settime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "117-122",
    "snippet": "int cap_settime(const struct timespec64 *ts, const struct timezone *tz)\n{\n\tif (!capable(CAP_SYS_TIME))\n\t\treturn -EPERM;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_TIME"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_settime(const struct timespec64 *ts, const struct timezone *tz)\n{\n\tif (!capable(CAP_SYS_TIME))\n\t\treturn -EPERM;\n\treturn 0;\n}"
  },
  {
    "function_name": "cap_capable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "71-107",
    "snippet": "int cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, int audit)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t/* See if cred has the capability in the target user namespace\n\t * by examining the target user namespace and all of the target\n\t * user namespace's parents.\n\t */\n\tfor (;;) {\n\t\t/* Do we have the necessary capabilities? */\n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t/*\n\t\t * If we're already at a lower level than we're looking for,\n\t\t * we're done searching.\n\t\t */\n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t/* \n\t\t * The owner of the user namespace in the parent of the\n\t\t * user namespace has all caps.\n\t\t */\n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If you have a capability in a parent user ns, then you have\n\t\t * it over all children user namespaces as well.\n\t\t */\n\t\tns = ns->parent;\n\t}\n\n\t/* We never get here */\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "ns->owner",
            "cred->euid"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raised",
          "args": [
            "cred->cap_effective",
            "cap"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, int audit)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t/* See if cred has the capability in the target user namespace\n\t * by examining the target user namespace and all of the target\n\t * user namespace's parents.\n\t */\n\tfor (;;) {\n\t\t/* Do we have the necessary capabilities? */\n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t/*\n\t\t * If we're already at a lower level than we're looking for,\n\t\t * we're done searching.\n\t\t */\n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t/* \n\t\t * The owner of the user namespace in the parent of the\n\t\t * user namespace has all caps.\n\t\t */\n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If you have a capability in a parent user ns, then you have\n\t\t * it over all children user namespaces as well.\n\t\t */\n\t\tns = ns->parent;\n\t}\n\n\t/* We never get here */\n}"
  },
  {
    "function_name": "warn_setuid_and_fcaps_mixed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
    "lines": "45-54",
    "snippet": "static void warn_setuid_and_fcaps_mixed(const char *fname)\n{\n\tstatic int warned;\n\tif (!warned) {\n\t\tprintk(KERN_INFO \"warning: `%s' has both setuid-root and\"\n\t\t\t\" effective capabilities. Therefore not raising all\"\n\t\t\t\" capabilities.\\n\", fname);\n\t\twarned = 1;\n\t}\n}",
    "includes": [
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/securebits.h>",
      "#include <linux/prctl.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/xattr.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/netlink.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/file.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/audit.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"warning: `%s' has both setuid-root and\"\n\t\t\t\" effective capabilities. Therefore not raising all\"\n\t\t\t\" capabilities.\\n\"",
            "fname"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic void warn_setuid_and_fcaps_mixed(const char *fname)\n{\n\tstatic int warned;\n\tif (!warned) {\n\t\tprintk(KERN_INFO \"warning: `%s' has both setuid-root and\"\n\t\t\t\" effective capabilities. Therefore not raising all\"\n\t\t\t\" capabilities.\\n\", fname);\n\t\twarned = 1;\n\t}\n}"
  }
]