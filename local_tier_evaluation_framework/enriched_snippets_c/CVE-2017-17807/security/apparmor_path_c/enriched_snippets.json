[
  {
    "function_name": "aa_path_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
    "lines": "201-221",
    "snippet": "int aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/path.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/magic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_namespace_path",
          "args": [
            "path",
            "buffer",
            "&str",
            "flags",
            "disconnected"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "d_namespace_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
          "lines": "92-179",
          "snippet": "static int d_namespace_path(const struct path *path, char *buf, char **name,\n\t\t\t    int flags, const char *disconnected)\n{\n\tchar *res;\n\tint error = 0;\n\tint connected = 1;\n\tint isdir = (flags & PATH_IS_DIR) ? 1 : 0;\n\tint buflen = aa_g_path_max - isdir;\n\n\tif (path->mnt->mnt_flags & MNT_INTERNAL) {\n\t\t/* it's not mounted anywhere */\n\t\tres = dentry_path(path->dentry, buf, buflen);\n\t\t*name = res;\n\t\tif (IS_ERR(res)) {\n\t\t\t*name = buf;\n\t\t\treturn PTR_ERR(res);\n\t\t}\n\t\tif (path->dentry->d_sb->s_magic == PROC_SUPER_MAGIC &&\n\t\t    strncmp(*name, \"/sys/\", 5) == 0) {\n\t\t\t/* TODO: convert over to using a per namespace\n\t\t\t * control instead of hard coded /proc\n\t\t\t */\n\t\t\terror = prepend(name, *name - buf, \"/proc\", 5);\n\t\t\tgoto out;\n\t\t} else\n\t\t\terror = disconnect(path, buf, name, flags,\n\t\t\t\t\t   disconnected);\n\t\tgoto out;\n\t}\n\n\t/* resolve paths relative to chroot?*/\n\tif (flags & PATH_CHROOT_REL) {\n\t\tstruct path root;\n\t\tget_fs_root(current->fs, &root);\n\t\tres = __d_path(path, &root, buf, buflen);\n\t\tpath_put(&root);\n\t} else {\n\t\tres = d_absolute_path(path, buf, buflen);\n\t\tif (!our_mnt(path->mnt))\n\t\t\tconnected = 0;\n\t}\n\n\t/* handle error conditions - and still allow a partial path to\n\t * be returned.\n\t */\n\tif (!res || IS_ERR(res)) {\n\t\tif (PTR_ERR(res) == -ENAMETOOLONG) {\n\t\t\terror = -ENAMETOOLONG;\n\t\t\t*name = buf;\n\t\t\tgoto out;\n\t\t}\n\t\tconnected = 0;\n\t\tres = dentry_path_raw(path->dentry, buf, buflen);\n\t\tif (IS_ERR(res)) {\n\t\t\terror = PTR_ERR(res);\n\t\t\t*name = buf;\n\t\t\tgoto out;\n\t\t};\n\t} else if (!our_mnt(path->mnt))\n\t\tconnected = 0;\n\n\t*name = res;\n\n\tif (!connected)\n\t\terror = disconnect(path, buf, name, flags, disconnected);\n\n\t/* Handle two cases:\n\t * 1. A deleted dentry && profile is not allowing mediation of deleted\n\t * 2. On some filesystems, newly allocated dentries appear to the\n\t *    security_path hooks as a deleted dentry except without an inode\n\t *    allocated.\n\t */\n\tif (d_unlinked(path->dentry) && d_is_positive(path->dentry) &&\n\t    !(flags & (PATH_MEDIATE_DELETED | PATH_DELEGATE_DELETED))) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t}\n\nout:\n\t/*\n\t * Append \"/\" to the pathname.  The root directory is a special\n\t * case; it already ends in slash.\n\t */\n\tif (!error && isdir && ((*name)[1] != '\\0' || (*name)[0] != '/'))\n\t\tstrcpy(&buf[aa_g_path_max - 2], \"/\");\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/path.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\nstatic int d_namespace_path(const struct path *path, char *buf, char **name,\n\t\t\t    int flags, const char *disconnected)\n{\n\tchar *res;\n\tint error = 0;\n\tint connected = 1;\n\tint isdir = (flags & PATH_IS_DIR) ? 1 : 0;\n\tint buflen = aa_g_path_max - isdir;\n\n\tif (path->mnt->mnt_flags & MNT_INTERNAL) {\n\t\t/* it's not mounted anywhere */\n\t\tres = dentry_path(path->dentry, buf, buflen);\n\t\t*name = res;\n\t\tif (IS_ERR(res)) {\n\t\t\t*name = buf;\n\t\t\treturn PTR_ERR(res);\n\t\t}\n\t\tif (path->dentry->d_sb->s_magic == PROC_SUPER_MAGIC &&\n\t\t    strncmp(*name, \"/sys/\", 5) == 0) {\n\t\t\t/* TODO: convert over to using a per namespace\n\t\t\t * control instead of hard coded /proc\n\t\t\t */\n\t\t\terror = prepend(name, *name - buf, \"/proc\", 5);\n\t\t\tgoto out;\n\t\t} else\n\t\t\terror = disconnect(path, buf, name, flags,\n\t\t\t\t\t   disconnected);\n\t\tgoto out;\n\t}\n\n\t/* resolve paths relative to chroot?*/\n\tif (flags & PATH_CHROOT_REL) {\n\t\tstruct path root;\n\t\tget_fs_root(current->fs, &root);\n\t\tres = __d_path(path, &root, buf, buflen);\n\t\tpath_put(&root);\n\t} else {\n\t\tres = d_absolute_path(path, buf, buflen);\n\t\tif (!our_mnt(path->mnt))\n\t\t\tconnected = 0;\n\t}\n\n\t/* handle error conditions - and still allow a partial path to\n\t * be returned.\n\t */\n\tif (!res || IS_ERR(res)) {\n\t\tif (PTR_ERR(res) == -ENAMETOOLONG) {\n\t\t\terror = -ENAMETOOLONG;\n\t\t\t*name = buf;\n\t\t\tgoto out;\n\t\t}\n\t\tconnected = 0;\n\t\tres = dentry_path_raw(path->dentry, buf, buflen);\n\t\tif (IS_ERR(res)) {\n\t\t\terror = PTR_ERR(res);\n\t\t\t*name = buf;\n\t\t\tgoto out;\n\t\t};\n\t} else if (!our_mnt(path->mnt))\n\t\tconnected = 0;\n\n\t*name = res;\n\n\tif (!connected)\n\t\terror = disconnect(path, buf, name, flags, disconnected);\n\n\t/* Handle two cases:\n\t * 1. A deleted dentry && profile is not allowing mediation of deleted\n\t * 2. On some filesystems, newly allocated dentries appear to the\n\t *    security_path hooks as a deleted dentry except without an inode\n\t *    allocated.\n\t */\n\tif (d_unlinked(path->dentry) && d_is_positive(path->dentry) &&\n\t    !(flags & (PATH_MEDIATE_DELETED | PATH_DELEGATE_DELETED))) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t}\n\nout:\n\t/*\n\t * Append \"/\" to the pathname.  The root directory is a special\n\t * case; it already ends in slash.\n\t */\n\tif (!error && isdir && ((*name)[1] != '\\0' || (*name)[0] != '/'))\n\t\tstrcpy(&buf[aa_g_path_max - 2], \"/\");\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\nint aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}"
  },
  {
    "function_name": "d_namespace_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
    "lines": "92-179",
    "snippet": "static int d_namespace_path(const struct path *path, char *buf, char **name,\n\t\t\t    int flags, const char *disconnected)\n{\n\tchar *res;\n\tint error = 0;\n\tint connected = 1;\n\tint isdir = (flags & PATH_IS_DIR) ? 1 : 0;\n\tint buflen = aa_g_path_max - isdir;\n\n\tif (path->mnt->mnt_flags & MNT_INTERNAL) {\n\t\t/* it's not mounted anywhere */\n\t\tres = dentry_path(path->dentry, buf, buflen);\n\t\t*name = res;\n\t\tif (IS_ERR(res)) {\n\t\t\t*name = buf;\n\t\t\treturn PTR_ERR(res);\n\t\t}\n\t\tif (path->dentry->d_sb->s_magic == PROC_SUPER_MAGIC &&\n\t\t    strncmp(*name, \"/sys/\", 5) == 0) {\n\t\t\t/* TODO: convert over to using a per namespace\n\t\t\t * control instead of hard coded /proc\n\t\t\t */\n\t\t\terror = prepend(name, *name - buf, \"/proc\", 5);\n\t\t\tgoto out;\n\t\t} else\n\t\t\terror = disconnect(path, buf, name, flags,\n\t\t\t\t\t   disconnected);\n\t\tgoto out;\n\t}\n\n\t/* resolve paths relative to chroot?*/\n\tif (flags & PATH_CHROOT_REL) {\n\t\tstruct path root;\n\t\tget_fs_root(current->fs, &root);\n\t\tres = __d_path(path, &root, buf, buflen);\n\t\tpath_put(&root);\n\t} else {\n\t\tres = d_absolute_path(path, buf, buflen);\n\t\tif (!our_mnt(path->mnt))\n\t\t\tconnected = 0;\n\t}\n\n\t/* handle error conditions - and still allow a partial path to\n\t * be returned.\n\t */\n\tif (!res || IS_ERR(res)) {\n\t\tif (PTR_ERR(res) == -ENAMETOOLONG) {\n\t\t\terror = -ENAMETOOLONG;\n\t\t\t*name = buf;\n\t\t\tgoto out;\n\t\t}\n\t\tconnected = 0;\n\t\tres = dentry_path_raw(path->dentry, buf, buflen);\n\t\tif (IS_ERR(res)) {\n\t\t\terror = PTR_ERR(res);\n\t\t\t*name = buf;\n\t\t\tgoto out;\n\t\t};\n\t} else if (!our_mnt(path->mnt))\n\t\tconnected = 0;\n\n\t*name = res;\n\n\tif (!connected)\n\t\terror = disconnect(path, buf, name, flags, disconnected);\n\n\t/* Handle two cases:\n\t * 1. A deleted dentry && profile is not allowing mediation of deleted\n\t * 2. On some filesystems, newly allocated dentries appear to the\n\t *    security_path hooks as a deleted dentry except without an inode\n\t *    allocated.\n\t */\n\tif (d_unlinked(path->dentry) && d_is_positive(path->dentry) &&\n\t    !(flags & (PATH_MEDIATE_DELETED | PATH_DELEGATE_DELETED))) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t}\n\nout:\n\t/*\n\t * Append \"/\" to the pathname.  The root directory is a special\n\t * case; it already ends in slash.\n\t */\n\tif (!error && isdir && ((*name)[1] != '\\0' || (*name)[0] != '/'))\n\t\tstrcpy(&buf[aa_g_path_max - 2], \"/\");\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/path.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/magic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "&buf[aa_g_path_max - 2]",
            "\"/\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_positive",
          "args": [
            "path->dentry"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unlinked",
          "args": [
            "path->dentry"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disconnect",
          "args": [
            "path",
            "buf",
            "name",
            "flags",
            "disconnected"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
          "lines": "52-76",
          "snippet": "static int disconnect(const struct path *path, char *buf, char **name,\n\t\t      int flags, const char *disconnected)\n{\n\tint error = 0;\n\n\tif (!(flags & PATH_CONNECT_PATH) &&\n\t    !(((flags & CHROOT_NSCONNECT) == CHROOT_NSCONNECT) &&\n\t      our_mnt(path->mnt))) {\n\t\t/* disconnected path, don't return pathname starting\n\t\t * with '/'\n\t\t */\n\t\terror = -EACCES;\n\t\tif (**name == '/')\n\t\t\t*name = *name + 1;\n\t} else {\n\t\tif (**name != '/')\n\t\t\t/* CONNECT_PATH with missing root */\n\t\t\terror = prepend(name, *name - buf, \"/\", 1);\n\t\tif (!error && disconnected)\n\t\t\terror = prepend(name, *name - buf, disconnected,\n\t\t\t\t\tstrlen(disconnected));\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/path.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/magic.h>"
          ],
          "macros_used": [
            "#define CHROOT_NSCONNECT (PATH_CHROOT_REL | PATH_CHROOT_NSCONNECT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\n#define CHROOT_NSCONNECT (PATH_CHROOT_REL | PATH_CHROOT_NSCONNECT)\n\nstatic int disconnect(const struct path *path, char *buf, char **name,\n\t\t      int flags, const char *disconnected)\n{\n\tint error = 0;\n\n\tif (!(flags & PATH_CONNECT_PATH) &&\n\t    !(((flags & CHROOT_NSCONNECT) == CHROOT_NSCONNECT) &&\n\t      our_mnt(path->mnt))) {\n\t\t/* disconnected path, don't return pathname starting\n\t\t * with '/'\n\t\t */\n\t\terror = -EACCES;\n\t\tif (**name == '/')\n\t\t\t*name = *name + 1;\n\t} else {\n\t\tif (**name != '/')\n\t\t\t/* CONNECT_PATH with missing root */\n\t\t\terror = prepend(name, *name - buf, \"/\", 1);\n\t\tif (!error && disconnected)\n\t\t\terror = prepend(name, *name - buf, disconnected,\n\t\t\t\t\tstrlen(disconnected));\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "our_mnt",
          "args": [
            "path->mnt"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "res"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_path_raw",
          "args": [
            "path->dentry",
            "buf",
            "buflen"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "res"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "our_mnt",
          "args": [
            "path->mnt"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_absolute_path",
          "args": [
            "path",
            "buf",
            "buflen"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&root"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_path",
          "args": [
            "path",
            "&root",
            "buf",
            "buflen"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs_root",
          "args": [
            "current->fs",
            "&root"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepend",
          "args": [
            "name",
            "*name - buf",
            "\"/proc\"",
            "5"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "prepend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
          "lines": "29-37",
          "snippet": "static int prepend(char **buffer, int buflen, const char *str, int namelen)\n{\n\tbuflen -= namelen;\n\tif (buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\t*buffer -= namelen;\n\tmemcpy(*buffer, str, namelen);\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/path.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\nstatic int prepend(char **buffer, int buflen, const char *str, int namelen)\n{\n\tbuflen -= namelen;\n\tif (buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\t*buffer -= namelen;\n\tmemcpy(*buffer, str, namelen);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "*name",
            "\"/sys/\"",
            "5"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "res"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_path",
          "args": [
            "path->dentry",
            "buf",
            "buflen"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_dentry_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "122-137",
          "snippet": "static char *tomoyo_get_dentry_path(struct dentry *dentry, char * const buffer,\n\t\t\t\t    const int buflen)\n{\n\tchar *pos = ERR_PTR(-ENOMEM);\n\tif (buflen >= 256) {\n\t\tpos = dentry_path_raw(dentry, buffer, buflen - 1);\n\t\tif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\n\t\t\tstruct inode *inode = d_backing_inode(dentry);\n\t\t\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t\t\tbuffer[buflen - 2] = '/';\n\t\t\t\tbuffer[buflen - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nstatic char *tomoyo_get_dentry_path(struct dentry *dentry, char * const buffer,\n\t\t\t\t    const int buflen)\n{\n\tchar *pos = ERR_PTR(-ENOMEM);\n\tif (buflen >= 256) {\n\t\tpos = dentry_path_raw(dentry, buffer, buflen - 1);\n\t\tif (!IS_ERR(pos) && *pos == '/' && pos[1]) {\n\t\t\tstruct inode *inode = d_backing_inode(dentry);\n\t\t\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t\t\tbuffer[buflen - 2] = '/';\n\t\t\t\tbuffer[buflen - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\treturn pos;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\nstatic int d_namespace_path(const struct path *path, char *buf, char **name,\n\t\t\t    int flags, const char *disconnected)\n{\n\tchar *res;\n\tint error = 0;\n\tint connected = 1;\n\tint isdir = (flags & PATH_IS_DIR) ? 1 : 0;\n\tint buflen = aa_g_path_max - isdir;\n\n\tif (path->mnt->mnt_flags & MNT_INTERNAL) {\n\t\t/* it's not mounted anywhere */\n\t\tres = dentry_path(path->dentry, buf, buflen);\n\t\t*name = res;\n\t\tif (IS_ERR(res)) {\n\t\t\t*name = buf;\n\t\t\treturn PTR_ERR(res);\n\t\t}\n\t\tif (path->dentry->d_sb->s_magic == PROC_SUPER_MAGIC &&\n\t\t    strncmp(*name, \"/sys/\", 5) == 0) {\n\t\t\t/* TODO: convert over to using a per namespace\n\t\t\t * control instead of hard coded /proc\n\t\t\t */\n\t\t\terror = prepend(name, *name - buf, \"/proc\", 5);\n\t\t\tgoto out;\n\t\t} else\n\t\t\terror = disconnect(path, buf, name, flags,\n\t\t\t\t\t   disconnected);\n\t\tgoto out;\n\t}\n\n\t/* resolve paths relative to chroot?*/\n\tif (flags & PATH_CHROOT_REL) {\n\t\tstruct path root;\n\t\tget_fs_root(current->fs, &root);\n\t\tres = __d_path(path, &root, buf, buflen);\n\t\tpath_put(&root);\n\t} else {\n\t\tres = d_absolute_path(path, buf, buflen);\n\t\tif (!our_mnt(path->mnt))\n\t\t\tconnected = 0;\n\t}\n\n\t/* handle error conditions - and still allow a partial path to\n\t * be returned.\n\t */\n\tif (!res || IS_ERR(res)) {\n\t\tif (PTR_ERR(res) == -ENAMETOOLONG) {\n\t\t\terror = -ENAMETOOLONG;\n\t\t\t*name = buf;\n\t\t\tgoto out;\n\t\t}\n\t\tconnected = 0;\n\t\tres = dentry_path_raw(path->dentry, buf, buflen);\n\t\tif (IS_ERR(res)) {\n\t\t\terror = PTR_ERR(res);\n\t\t\t*name = buf;\n\t\t\tgoto out;\n\t\t};\n\t} else if (!our_mnt(path->mnt))\n\t\tconnected = 0;\n\n\t*name = res;\n\n\tif (!connected)\n\t\terror = disconnect(path, buf, name, flags, disconnected);\n\n\t/* Handle two cases:\n\t * 1. A deleted dentry && profile is not allowing mediation of deleted\n\t * 2. On some filesystems, newly allocated dentries appear to the\n\t *    security_path hooks as a deleted dentry except without an inode\n\t *    allocated.\n\t */\n\tif (d_unlinked(path->dentry) && d_is_positive(path->dentry) &&\n\t    !(flags & (PATH_MEDIATE_DELETED | PATH_DELEGATE_DELETED))) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t}\n\nout:\n\t/*\n\t * Append \"/\" to the pathname.  The root directory is a special\n\t * case; it already ends in slash.\n\t */\n\tif (!error && isdir && ((*name)[1] != '\\0' || (*name)[0] != '/'))\n\t\tstrcpy(&buf[aa_g_path_max - 2], \"/\");\n\n\treturn error;\n}"
  },
  {
    "function_name": "disconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
    "lines": "52-76",
    "snippet": "static int disconnect(const struct path *path, char *buf, char **name,\n\t\t      int flags, const char *disconnected)\n{\n\tint error = 0;\n\n\tif (!(flags & PATH_CONNECT_PATH) &&\n\t    !(((flags & CHROOT_NSCONNECT) == CHROOT_NSCONNECT) &&\n\t      our_mnt(path->mnt))) {\n\t\t/* disconnected path, don't return pathname starting\n\t\t * with '/'\n\t\t */\n\t\terror = -EACCES;\n\t\tif (**name == '/')\n\t\t\t*name = *name + 1;\n\t} else {\n\t\tif (**name != '/')\n\t\t\t/* CONNECT_PATH with missing root */\n\t\t\terror = prepend(name, *name - buf, \"/\", 1);\n\t\tif (!error && disconnected)\n\t\t\terror = prepend(name, *name - buf, disconnected,\n\t\t\t\t\tstrlen(disconnected));\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/path.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/magic.h>"
    ],
    "macros_used": [
      "#define CHROOT_NSCONNECT (PATH_CHROOT_REL | PATH_CHROOT_NSCONNECT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prepend",
          "args": [
            "name",
            "*name - buf",
            "disconnected",
            "strlen(disconnected)"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "prepend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
          "lines": "29-37",
          "snippet": "static int prepend(char **buffer, int buflen, const char *str, int namelen)\n{\n\tbuflen -= namelen;\n\tif (buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\t*buffer -= namelen;\n\tmemcpy(*buffer, str, namelen);\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/path.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\nstatic int prepend(char **buffer, int buflen, const char *str, int namelen)\n{\n\tbuflen -= namelen;\n\tif (buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\t*buffer -= namelen;\n\tmemcpy(*buffer, str, namelen);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "disconnected"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "our_mnt",
          "args": [
            "path->mnt"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\n#define CHROOT_NSCONNECT (PATH_CHROOT_REL | PATH_CHROOT_NSCONNECT)\n\nstatic int disconnect(const struct path *path, char *buf, char **name,\n\t\t      int flags, const char *disconnected)\n{\n\tint error = 0;\n\n\tif (!(flags & PATH_CONNECT_PATH) &&\n\t    !(((flags & CHROOT_NSCONNECT) == CHROOT_NSCONNECT) &&\n\t      our_mnt(path->mnt))) {\n\t\t/* disconnected path, don't return pathname starting\n\t\t * with '/'\n\t\t */\n\t\terror = -EACCES;\n\t\tif (**name == '/')\n\t\t\t*name = *name + 1;\n\t} else {\n\t\tif (**name != '/')\n\t\t\t/* CONNECT_PATH with missing root */\n\t\t\terror = prepend(name, *name - buf, \"/\", 1);\n\t\tif (!error && disconnected)\n\t\t\terror = prepend(name, *name - buf, disconnected,\n\t\t\t\t\tstrlen(disconnected));\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "prepend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
    "lines": "29-37",
    "snippet": "static int prepend(char **buffer, int buflen, const char *str, int namelen)\n{\n\tbuflen -= namelen;\n\tif (buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\t*buffer -= namelen;\n\tmemcpy(*buffer, str, namelen);\n\treturn 0;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/fs_struct.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/path.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/magic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*buffer",
            "str",
            "namelen"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\nstatic int prepend(char **buffer, int buflen, const char *str, int namelen)\n{\n\tbuflen -= namelen;\n\tif (buflen < 0)\n\t\treturn -ENAMETOOLONG;\n\t*buffer -= namelen;\n\tmemcpy(*buffer, str, namelen);\n\treturn 0;\n}"
  }
]