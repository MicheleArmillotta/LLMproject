[
  {
    "function_name": "tomoyo_condition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "745-1095",
    "snippet": "bool tomoyo_condition(struct tomoyo_request_info *r,\n\t\t      const struct tomoyo_condition *cond)\n{\n\tu32 i;\n\tunsigned long min_v[2] = { 0, 0 };\n\tunsigned long max_v[2] = { 0, 0 };\n\tconst struct tomoyo_condition_element *condp;\n\tconst struct tomoyo_number_union *numbers_p;\n\tconst struct tomoyo_name_union *names_p;\n\tconst struct tomoyo_argv *argv;\n\tconst struct tomoyo_envp *envp;\n\tstruct tomoyo_obj_info *obj;\n\tu16 condc;\n\tu16 argc;\n\tu16 envc;\n\tstruct linux_binprm *bprm = NULL;\n\tif (!cond)\n\t\treturn true;\n\tcondc = cond->condc;\n\targc = cond->argc;\n\tenvc = cond->envc;\n\tobj = r->obj;\n\tif (r->ee)\n\t\tbprm = r->ee->bprm;\n\tif (!bprm && (argc || envc))\n\t\treturn false;\n\tcondp = (struct tomoyo_condition_element *) (cond + 1);\n\tnumbers_p = (const struct tomoyo_number_union *) (condp + condc);\n\tnames_p = (const struct tomoyo_name_union *)\n\t\t(numbers_p + cond->numbers_count);\n\targv = (const struct tomoyo_argv *) (names_p + cond->names_count);\n\tenvp = (const struct tomoyo_envp *) (argv + argc);\n\tfor (i = 0; i < condc; i++) {\n\t\tconst bool match = condp->equals;\n\t\tconst u8 left = condp->left;\n\t\tconst u8 right = condp->right;\n\t\tbool is_bitop[2] = { false, false };\n\t\tu8 j;\n\t\tcondp++;\n\t\t/* Check argv[] and envp[] later. */\n\t\tif (left == TOMOYO_ARGV_ENTRY || left == TOMOYO_ENVP_ENTRY)\n\t\t\tcontinue;\n\t\t/* Check string expressions. */\n\t\tif (right == TOMOYO_NAME_UNION) {\n\t\t\tconst struct tomoyo_name_union *ptr = names_p++;\n\t\t\tswitch (left) {\n\t\t\t\tstruct tomoyo_path_info *symlink;\n\t\t\t\tstruct tomoyo_execve *ee;\n\t\t\t\tstruct file *file;\n\t\t\tcase TOMOYO_SYMLINK_TARGET:\n\t\t\t\tsymlink = obj ? obj->symlink_target : NULL;\n\t\t\t\tif (!symlink ||\n\t\t\t\t    !tomoyo_compare_name_union(symlink, ptr)\n\t\t\t\t    == match)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_REALPATH:\n\t\t\t\tee = r->ee;\n\t\t\t\tfile = ee ? ee->bprm->file : NULL;\n\t\t\t\tif (!tomoyo_scan_exec_realpath(file, ptr,\n\t\t\t\t\t\t\t       match))\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/* Check numeric or bit-op expressions. */\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tconst u8 index = j ? right : left;\n\t\t\tunsigned long value = 0;\n\t\t\tswitch (index) {\n\t\t\tcase TOMOYO_TASK_UID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_uid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_EUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_euid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_SUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_suid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_FSUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_fsuid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_GID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_gid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_EGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_egid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_SGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_sgid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_FSGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_fsgid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_PID:\n\t\t\t\tvalue = tomoyo_sys_getpid();\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_PPID:\n\t\t\t\tvalue = tomoyo_sys_getppid();\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_SOCKET:\n\t\t\t\tvalue = S_IFSOCK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_SYMLINK:\n\t\t\t\tvalue = S_IFLNK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_FILE:\n\t\t\t\tvalue = S_IFREG;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_BLOCK_DEV:\n\t\t\t\tvalue = S_IFBLK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_DIRECTORY:\n\t\t\t\tvalue = S_IFDIR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_CHAR_DEV:\n\t\t\t\tvalue = S_IFCHR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_FIFO:\n\t\t\t\tvalue = S_IFIFO;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_SETUID:\n\t\t\t\tvalue = S_ISUID;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_SETGID:\n\t\t\t\tvalue = S_ISGID;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_STICKY:\n\t\t\t\tvalue = S_ISVTX;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_READ:\n\t\t\t\tvalue = S_IRUSR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_WRITE:\n\t\t\t\tvalue = S_IWUSR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_EXECUTE:\n\t\t\t\tvalue = S_IXUSR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_READ:\n\t\t\t\tvalue = S_IRGRP;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_WRITE:\n\t\t\t\tvalue = S_IWGRP;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_EXECUTE:\n\t\t\t\tvalue = S_IXGRP;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_READ:\n\t\t\t\tvalue = S_IROTH;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_WRITE:\n\t\t\t\tvalue = S_IWOTH;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_EXECUTE:\n\t\t\t\tvalue = S_IXOTH;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_ARGC:\n\t\t\t\tif (!bprm)\n\t\t\t\t\tgoto out;\n\t\t\t\tvalue = bprm->argc;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_ENVC:\n\t\t\t\tif (!bprm)\n\t\t\t\t\tgoto out;\n\t\t\t\tvalue = bprm->envc;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t/* Fetch values later. */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!obj)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (!obj->validate_done) {\n\t\t\t\t\ttomoyo_get_attributes(obj);\n\t\t\t\t\tobj->validate_done = true;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tu8 stat_index;\n\t\t\t\t\tstruct tomoyo_mini_stat *stat;\n\t\t\t\t\tswitch (index) {\n\t\t\t\t\tcase TOMOYO_PATH1_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH1_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH1_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\t\t\t\tstat_index = TOMOYO_PATH1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH2_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\t\t\t\tstat_index = TOMOYO_PATH2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\t\t\t\tstat_index =\n\t\t\t\t\t\t\tTOMOYO_PATH1_PARENT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\t\t\tstat_index =\n\t\t\t\t\t\t\tTOMOYO_PATH2_PARENT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (!obj->stat_valid[stat_index])\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tstat = &obj->stat[stat_index];\n\t\t\t\t\tswitch (index) {\n\t\t\t\t\tcase TOMOYO_PATH1_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_UID:\n\t\t\t\t\t\tvalue = from_kuid(&init_user_ns, stat->uid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_GID:\n\t\t\t\t\t\tvalue = from_kgid(&init_user_ns, stat->gid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_INO:\n\t\t\t\t\t\tvalue = stat->ino;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MAJOR:\n\t\t\t\t\t\tvalue = MAJOR(stat->dev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MINOR:\n\t\t\t\t\t\tvalue = MINOR(stat->dev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH2_TYPE:\n\t\t\t\t\t\tvalue = stat->mode & S_IFMT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MAJOR:\n\t\t\t\t\t\tvalue = MAJOR(stat->rdev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MINOR:\n\t\t\t\t\t\tvalue = MINOR(stat->rdev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\t\t\tvalue = stat->mode & S_IALLUGO;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmax_v[j] = value;\n\t\t\tmin_v[j] = value;\n\t\t\tswitch (index) {\n\t\t\tcase TOMOYO_MODE_SETUID:\n\t\t\tcase TOMOYO_MODE_SETGID:\n\t\t\tcase TOMOYO_MODE_STICKY:\n\t\t\tcase TOMOYO_MODE_OWNER_READ:\n\t\t\tcase TOMOYO_MODE_OWNER_WRITE:\n\t\t\tcase TOMOYO_MODE_OWNER_EXECUTE:\n\t\t\tcase TOMOYO_MODE_GROUP_READ:\n\t\t\tcase TOMOYO_MODE_GROUP_WRITE:\n\t\t\tcase TOMOYO_MODE_GROUP_EXECUTE:\n\t\t\tcase TOMOYO_MODE_OTHERS_READ:\n\t\t\tcase TOMOYO_MODE_OTHERS_WRITE:\n\t\t\tcase TOMOYO_MODE_OTHERS_EXECUTE:\n\t\t\t\tis_bitop[j] = true;\n\t\t\t}\n\t\t}\n\t\tif (left == TOMOYO_NUMBER_UNION) {\n\t\t\t/* Fetch values now. */\n\t\t\tconst struct tomoyo_number_union *ptr = numbers_p++;\n\t\t\tmin_v[0] = ptr->values[0];\n\t\t\tmax_v[0] = ptr->values[1];\n\t\t}\n\t\tif (right == TOMOYO_NUMBER_UNION) {\n\t\t\t/* Fetch values now. */\n\t\t\tconst struct tomoyo_number_union *ptr = numbers_p++;\n\t\t\tif (ptr->group) {\n\t\t\t\tif (tomoyo_number_matches_group(min_v[0],\n\t\t\t\t\t\t\t\tmax_v[0],\n\t\t\t\t\t\t\t\tptr->group)\n\t\t\t\t    == match)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif ((min_v[0] <= ptr->values[1] &&\n\t\t\t\t     max_v[0] >= ptr->values[0]) == match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * Bit operation is valid only when counterpart value\n\t\t * represents permission.\n\t\t */\n\t\tif (is_bitop[0] && is_bitop[1]) {\n\t\t\tgoto out;\n\t\t} else if (is_bitop[0]) {\n\t\t\tswitch (right) {\n\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\tif (!(max_v[0] & max_v[1]) == !match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t} else if (is_bitop[1]) {\n\t\t\tswitch (left) {\n\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\tif (!(max_v[0] & max_v[1]) == !match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t/* Normal value range comparison. */\n\t\tif ((min_v[0] <= max_v[1] && max_v[0] >= min_v[1]) == match)\n\t\t\tcontinue;\nout:\n\t\treturn false;\n\t}\n\t/* Check argv[] and envp[] now. */\n\tif (r->ee && (argc || envc))\n\t\treturn tomoyo_scan_bprm(r->ee, argc, argv, envc, envp);\n\treturn true;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_scan_bprm",
          "args": [
            "r->ee",
            "argc",
            "argv",
            "envc",
            "envp"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_scan_bprm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "101-215",
          "snippet": "static bool tomoyo_scan_bprm(struct tomoyo_execve *ee,\n\t\t\t     const u16 argc, const struct tomoyo_argv *argv,\n\t\t\t     const u16 envc, const struct tomoyo_envp *envp)\n{\n\tstruct linux_binprm *bprm = ee->bprm;\n\tstruct tomoyo_page_dump *dump = &ee->dump;\n\tchar *arg_ptr = ee->tmp;\n\tint arg_len = 0;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tbool result = true;\n\tu8 local_checked[32];\n\tu8 *checked;\n\tif (argc + envc <= sizeof(local_checked)) {\n\t\tchecked = local_checked;\n\t\tmemset(local_checked, 0, sizeof(local_checked));\n\t} else {\n\t\tchecked = kzalloc(argc + envc, GFP_NOFS);\n\t\tif (!checked)\n\t\t\treturn false;\n\t}\n\twhile (argv_count || envp_count) {\n\t\tif (!tomoyo_dump_page(bprm, pos, dump)) {\n\t\t\tresult = false;\n\t\t\tgoto out;\n\t\t}\n\t\tpos += PAGE_SIZE - offset;\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\t/* Read. */\n\t\t\tconst char *kaddr = dump->data;\n\t\t\tconst unsigned char c = kaddr[offset++];\n\t\t\tif (c && arg_len < TOMOYO_EXEC_TMPSIZE - 10) {\n\t\t\t\tif (c == '\\\\') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t\targ_ptr[arg_len++] = c;\n\t\t\t\t} else {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = (c >> 6) + '0';\n\t\t\t\t\targ_ptr[arg_len++] =\n\t\t\t\t\t\t((c >> 3) & 7) + '0';\n\t\t\t\t\targ_ptr[arg_len++] = (c & 7) + '0';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targ_ptr[arg_len] = '\\0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\t/* Check. */\n\t\t\tif (argv_count) {\n\t\t\t\tif (!tomoyo_argv(bprm->argc - argv_count,\n\t\t\t\t\t\t arg_ptr, argc, argv,\n\t\t\t\t\t\t checked)) {\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\targv_count--;\n\t\t\t} else if (envp_count) {\n\t\t\t\tchar *cp = strchr(arg_ptr, '=');\n\t\t\t\tif (cp) {\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t\tif (!tomoyo_envp(arg_ptr, cp + 1,\n\t\t\t\t\t\t\t envc, envp,\n\t\t\t\t\t\t\t checked + argc)) {\n\t\t\t\t\t\tresult = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tenvp_count--;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ_len = 0;\n\t\t}\n\t\toffset = 0;\n\t\tif (!result)\n\t\t\tbreak;\n\t}\nout:\n\tif (result) {\n\t\tint i;\n\t\t/* Check not-yet-checked entries. */\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tif (checked[i])\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Return true only if all unchecked indexes in\n\t\t\t * bprm->argv[] are not matched.\n\t\t\t */\n\t\t\tif (argv[i].is_not)\n\t\t\t\tcontinue;\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < envc; envp++, i++) {\n\t\t\tif (checked[argc + i])\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Return true only if all unchecked environ variables\n\t\t\t * in bprm->envp[] are either undefined or not matched.\n\t\t\t */\n\t\t\tif ((!envp->value && !envp->is_not) ||\n\t\t\t    (envp->value && envp->is_not))\n\t\t\t\tcontinue;\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (checked != local_checked)\n\t\tkfree(checked);\n\treturn result;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_scan_bprm(struct tomoyo_execve *ee,\n\t\t\t     const u16 argc, const struct tomoyo_argv *argv,\n\t\t\t     const u16 envc, const struct tomoyo_envp *envp)\n{\n\tstruct linux_binprm *bprm = ee->bprm;\n\tstruct tomoyo_page_dump *dump = &ee->dump;\n\tchar *arg_ptr = ee->tmp;\n\tint arg_len = 0;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tbool result = true;\n\tu8 local_checked[32];\n\tu8 *checked;\n\tif (argc + envc <= sizeof(local_checked)) {\n\t\tchecked = local_checked;\n\t\tmemset(local_checked, 0, sizeof(local_checked));\n\t} else {\n\t\tchecked = kzalloc(argc + envc, GFP_NOFS);\n\t\tif (!checked)\n\t\t\treturn false;\n\t}\n\twhile (argv_count || envp_count) {\n\t\tif (!tomoyo_dump_page(bprm, pos, dump)) {\n\t\t\tresult = false;\n\t\t\tgoto out;\n\t\t}\n\t\tpos += PAGE_SIZE - offset;\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\t/* Read. */\n\t\t\tconst char *kaddr = dump->data;\n\t\t\tconst unsigned char c = kaddr[offset++];\n\t\t\tif (c && arg_len < TOMOYO_EXEC_TMPSIZE - 10) {\n\t\t\t\tif (c == '\\\\') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t\targ_ptr[arg_len++] = c;\n\t\t\t\t} else {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = (c >> 6) + '0';\n\t\t\t\t\targ_ptr[arg_len++] =\n\t\t\t\t\t\t((c >> 3) & 7) + '0';\n\t\t\t\t\targ_ptr[arg_len++] = (c & 7) + '0';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targ_ptr[arg_len] = '\\0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\t/* Check. */\n\t\t\tif (argv_count) {\n\t\t\t\tif (!tomoyo_argv(bprm->argc - argv_count,\n\t\t\t\t\t\t arg_ptr, argc, argv,\n\t\t\t\t\t\t checked)) {\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\targv_count--;\n\t\t\t} else if (envp_count) {\n\t\t\t\tchar *cp = strchr(arg_ptr, '=');\n\t\t\t\tif (cp) {\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t\tif (!tomoyo_envp(arg_ptr, cp + 1,\n\t\t\t\t\t\t\t envc, envp,\n\t\t\t\t\t\t\t checked + argc)) {\n\t\t\t\t\t\tresult = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tenvp_count--;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ_len = 0;\n\t\t}\n\t\toffset = 0;\n\t\tif (!result)\n\t\t\tbreak;\n\t}\nout:\n\tif (result) {\n\t\tint i;\n\t\t/* Check not-yet-checked entries. */\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tif (checked[i])\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Return true only if all unchecked indexes in\n\t\t\t * bprm->argv[] are not matched.\n\t\t\t */\n\t\t\tif (argv[i].is_not)\n\t\t\t\tcontinue;\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < envc; envp++, i++) {\n\t\t\tif (checked[argc + i])\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Return true only if all unchecked environ variables\n\t\t\t * in bprm->envp[] are either undefined or not matched.\n\t\t\t */\n\t\t\tif ((!envp->value && !envp->is_not) ||\n\t\t\t    (envp->value && envp->is_not))\n\t\t\t\tcontinue;\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (checked != local_checked)\n\t\tkfree(checked);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_number_matches_group",
          "args": [
            "min_v[0]",
            "max_v[0]",
            "ptr->group"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_number_matches_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/group.c",
          "lines": "153-169",
          "snippet": "bool tomoyo_number_matches_group(const unsigned long min,\n\t\t\t\t const unsigned long max,\n\t\t\t\t const struct tomoyo_group *group)\n{\n\tstruct tomoyo_number_group *member;\n\tbool matched = false;\n\tlist_for_each_entry_rcu(member, &group->member_list, head.list) {\n\t\tif (member->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (min > member->number.values[1] ||\n\t\t    max < member->number.values[0])\n\t\t\tcontinue;\n\t\tmatched = true;\n\t\tbreak;\n\t}\n\treturn matched;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_number_matches_group(const unsigned long min,\n\t\t\t\t const unsigned long max,\n\t\t\t\t const struct tomoyo_group *group)\n{\n\tstruct tomoyo_number_group *member;\n\tbool matched = false;\n\tlist_for_each_entry_rcu(member, &group->member_list, head.list) {\n\t\tif (member->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (min > member->number.values[1] ||\n\t\t    max < member->number.values[0])\n\t\t\tcontinue;\n\t\tmatched = true;\n\t\tbreak;\n\t}\n\treturn matched;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "stat->rdev"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "stat->rdev"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "stat->dev"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "stat->dev"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "stat->gid"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "stat->uid"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_attributes",
          "args": [
            "obj"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "694-733",
          "snippet": "void tomoyo_get_attributes(struct tomoyo_obj_info *obj)\n{\n\tu8 i;\n\tstruct dentry *dentry = NULL;\n\n\tfor (i = 0; i < TOMOYO_MAX_PATH_STAT; i++) {\n\t\tstruct inode *inode;\n\t\tswitch (i) {\n\t\tcase TOMOYO_PATH1:\n\t\t\tdentry = obj->path1.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase TOMOYO_PATH2:\n\t\t\tdentry = obj->path2.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tdentry = dget_parent(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tinode = d_backing_inode(dentry);\n\t\tif (inode) {\n\t\t\tstruct tomoyo_mini_stat *stat = &obj->stat[i];\n\t\t\tstat->uid  = inode->i_uid;\n\t\t\tstat->gid  = inode->i_gid;\n\t\t\tstat->ino  = inode->i_ino;\n\t\t\tstat->mode = inode->i_mode;\n\t\t\tstat->dev  = inode->i_sb->s_dev;\n\t\t\tstat->rdev = inode->i_rdev;\n\t\t\tobj->stat_valid[i] = true;\n\t\t}\n\t\tif (i & 1) /* i == TOMOYO_PATH1_PARENT ||\n\t\t\t      i == TOMOYO_PATH2_PARENT */\n\t\t\tdput(dentry);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_get_attributes(struct tomoyo_obj_info *obj)\n{\n\tu8 i;\n\tstruct dentry *dentry = NULL;\n\n\tfor (i = 0; i < TOMOYO_MAX_PATH_STAT; i++) {\n\t\tstruct inode *inode;\n\t\tswitch (i) {\n\t\tcase TOMOYO_PATH1:\n\t\t\tdentry = obj->path1.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase TOMOYO_PATH2:\n\t\t\tdentry = obj->path2.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tdentry = dget_parent(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tinode = d_backing_inode(dentry);\n\t\tif (inode) {\n\t\t\tstruct tomoyo_mini_stat *stat = &obj->stat[i];\n\t\t\tstat->uid  = inode->i_uid;\n\t\t\tstat->gid  = inode->i_gid;\n\t\t\tstat->ino  = inode->i_ino;\n\t\t\tstat->mode = inode->i_mode;\n\t\t\tstat->dev  = inode->i_sb->s_dev;\n\t\t\tstat->rdev = inode->i_rdev;\n\t\t\tobj->stat_valid[i] = true;\n\t\t}\n\t\tif (i & 1) /* i == TOMOYO_PATH1_PARENT ||\n\t\t\t      i == TOMOYO_PATH2_PARENT */\n\t\t\tdput(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_sys_getppid",
          "args": [],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_sys_getppid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1121-1128",
          "snippet": "static inline pid_t tomoyo_sys_getppid(void)\n{\n\tpid_t pid;\n\trcu_read_lock();\n\tpid = task_tgid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\treturn pid;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline pid_t tomoyo_sys_getppid(void)\n{\n\tpid_t pid;\n\trcu_read_lock();\n\tpid = task_tgid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_sys_getpid",
          "args": [],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_sys_getpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1138-1141",
          "snippet": "static inline pid_t tomoyo_sys_getpid(void)\n{\n\treturn task_tgid_vnr(current);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline pid_t tomoyo_sys_getpid(void)\n{\n\treturn task_tgid_vnr(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "current_fsgid()"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "current_sgid()"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_sgid",
          "args": [],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "current_egid()"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_egid",
          "args": [],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "current_gid()"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_gid",
          "args": [],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "current_fsuid()"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "current_suid()"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_suid",
          "args": [],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "current_euid()"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "current_uid()"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_scan_exec_realpath",
          "args": [
            "file",
            "ptr",
            "match"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_scan_exec_realpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "226-241",
          "snippet": "static bool tomoyo_scan_exec_realpath(struct file *file,\n\t\t\t\t      const struct tomoyo_name_union *ptr,\n\t\t\t\t      const bool match)\n{\n\tbool result;\n\tstruct tomoyo_path_info exe;\n\tif (!file)\n\t\treturn false;\n\texe.name = tomoyo_realpath_from_path(&file->f_path);\n\tif (!exe.name)\n\t\treturn false;\n\ttomoyo_fill_path_info(&exe);\n\tresult = tomoyo_compare_name_union(&exe, ptr);\n\tkfree(exe.name);\n\treturn result == match;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_scan_exec_realpath(struct file *file,\n\t\t\t\t      const struct tomoyo_name_union *ptr,\n\t\t\t\t      const bool match)\n{\n\tbool result;\n\tstruct tomoyo_path_info exe;\n\tif (!file)\n\t\treturn false;\n\texe.name = tomoyo_realpath_from_path(&file->f_path);\n\tif (!exe.name)\n\t\treturn false;\n\ttomoyo_fill_path_info(&exe);\n\tresult = tomoyo_compare_name_union(&exe, ptr);\n\tkfree(exe.name);\n\treturn result == match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_compare_name_union",
          "args": [
            "symlink",
            "ptr"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_compare_name_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "81-90",
          "snippet": "const struct tomoyo_path_info *\ntomoyo_compare_name_union(const struct tomoyo_path_info *name,\n\t\t\t  const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_path_matches_group(name, ptr->group);\n\tif (tomoyo_path_matches_pattern(name, ptr->filename))\n\t\treturn ptr->filename;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst struct tomoyo_path_info *\ntomoyo_compare_name_union(const struct tomoyo_path_info *name,\n\t\t\t  const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_path_matches_group(name, ptr->group);\n\tif (tomoyo_path_matches_pattern(name, ptr->filename))\n\t\treturn ptr->filename;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nbool tomoyo_condition(struct tomoyo_request_info *r,\n\t\t      const struct tomoyo_condition *cond)\n{\n\tu32 i;\n\tunsigned long min_v[2] = { 0, 0 };\n\tunsigned long max_v[2] = { 0, 0 };\n\tconst struct tomoyo_condition_element *condp;\n\tconst struct tomoyo_number_union *numbers_p;\n\tconst struct tomoyo_name_union *names_p;\n\tconst struct tomoyo_argv *argv;\n\tconst struct tomoyo_envp *envp;\n\tstruct tomoyo_obj_info *obj;\n\tu16 condc;\n\tu16 argc;\n\tu16 envc;\n\tstruct linux_binprm *bprm = NULL;\n\tif (!cond)\n\t\treturn true;\n\tcondc = cond->condc;\n\targc = cond->argc;\n\tenvc = cond->envc;\n\tobj = r->obj;\n\tif (r->ee)\n\t\tbprm = r->ee->bprm;\n\tif (!bprm && (argc || envc))\n\t\treturn false;\n\tcondp = (struct tomoyo_condition_element *) (cond + 1);\n\tnumbers_p = (const struct tomoyo_number_union *) (condp + condc);\n\tnames_p = (const struct tomoyo_name_union *)\n\t\t(numbers_p + cond->numbers_count);\n\targv = (const struct tomoyo_argv *) (names_p + cond->names_count);\n\tenvp = (const struct tomoyo_envp *) (argv + argc);\n\tfor (i = 0; i < condc; i++) {\n\t\tconst bool match = condp->equals;\n\t\tconst u8 left = condp->left;\n\t\tconst u8 right = condp->right;\n\t\tbool is_bitop[2] = { false, false };\n\t\tu8 j;\n\t\tcondp++;\n\t\t/* Check argv[] and envp[] later. */\n\t\tif (left == TOMOYO_ARGV_ENTRY || left == TOMOYO_ENVP_ENTRY)\n\t\t\tcontinue;\n\t\t/* Check string expressions. */\n\t\tif (right == TOMOYO_NAME_UNION) {\n\t\t\tconst struct tomoyo_name_union *ptr = names_p++;\n\t\t\tswitch (left) {\n\t\t\t\tstruct tomoyo_path_info *symlink;\n\t\t\t\tstruct tomoyo_execve *ee;\n\t\t\t\tstruct file *file;\n\t\t\tcase TOMOYO_SYMLINK_TARGET:\n\t\t\t\tsymlink = obj ? obj->symlink_target : NULL;\n\t\t\t\tif (!symlink ||\n\t\t\t\t    !tomoyo_compare_name_union(symlink, ptr)\n\t\t\t\t    == match)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_REALPATH:\n\t\t\t\tee = r->ee;\n\t\t\t\tfile = ee ? ee->bprm->file : NULL;\n\t\t\t\tif (!tomoyo_scan_exec_realpath(file, ptr,\n\t\t\t\t\t\t\t       match))\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/* Check numeric or bit-op expressions. */\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tconst u8 index = j ? right : left;\n\t\t\tunsigned long value = 0;\n\t\t\tswitch (index) {\n\t\t\tcase TOMOYO_TASK_UID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_uid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_EUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_euid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_SUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_suid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_FSUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_fsuid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_GID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_gid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_EGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_egid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_SGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_sgid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_FSGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_fsgid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_PID:\n\t\t\t\tvalue = tomoyo_sys_getpid();\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_PPID:\n\t\t\t\tvalue = tomoyo_sys_getppid();\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_SOCKET:\n\t\t\t\tvalue = S_IFSOCK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_SYMLINK:\n\t\t\t\tvalue = S_IFLNK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_FILE:\n\t\t\t\tvalue = S_IFREG;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_BLOCK_DEV:\n\t\t\t\tvalue = S_IFBLK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_DIRECTORY:\n\t\t\t\tvalue = S_IFDIR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_CHAR_DEV:\n\t\t\t\tvalue = S_IFCHR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_FIFO:\n\t\t\t\tvalue = S_IFIFO;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_SETUID:\n\t\t\t\tvalue = S_ISUID;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_SETGID:\n\t\t\t\tvalue = S_ISGID;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_STICKY:\n\t\t\t\tvalue = S_ISVTX;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_READ:\n\t\t\t\tvalue = S_IRUSR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_WRITE:\n\t\t\t\tvalue = S_IWUSR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_EXECUTE:\n\t\t\t\tvalue = S_IXUSR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_READ:\n\t\t\t\tvalue = S_IRGRP;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_WRITE:\n\t\t\t\tvalue = S_IWGRP;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_EXECUTE:\n\t\t\t\tvalue = S_IXGRP;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_READ:\n\t\t\t\tvalue = S_IROTH;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_WRITE:\n\t\t\t\tvalue = S_IWOTH;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_EXECUTE:\n\t\t\t\tvalue = S_IXOTH;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_ARGC:\n\t\t\t\tif (!bprm)\n\t\t\t\t\tgoto out;\n\t\t\t\tvalue = bprm->argc;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_ENVC:\n\t\t\t\tif (!bprm)\n\t\t\t\t\tgoto out;\n\t\t\t\tvalue = bprm->envc;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t/* Fetch values later. */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!obj)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (!obj->validate_done) {\n\t\t\t\t\ttomoyo_get_attributes(obj);\n\t\t\t\t\tobj->validate_done = true;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tu8 stat_index;\n\t\t\t\t\tstruct tomoyo_mini_stat *stat;\n\t\t\t\t\tswitch (index) {\n\t\t\t\t\tcase TOMOYO_PATH1_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH1_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH1_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\t\t\t\tstat_index = TOMOYO_PATH1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH2_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\t\t\t\tstat_index = TOMOYO_PATH2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\t\t\t\tstat_index =\n\t\t\t\t\t\t\tTOMOYO_PATH1_PARENT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\t\t\tstat_index =\n\t\t\t\t\t\t\tTOMOYO_PATH2_PARENT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (!obj->stat_valid[stat_index])\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tstat = &obj->stat[stat_index];\n\t\t\t\t\tswitch (index) {\n\t\t\t\t\tcase TOMOYO_PATH1_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_UID:\n\t\t\t\t\t\tvalue = from_kuid(&init_user_ns, stat->uid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_GID:\n\t\t\t\t\t\tvalue = from_kgid(&init_user_ns, stat->gid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_INO:\n\t\t\t\t\t\tvalue = stat->ino;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MAJOR:\n\t\t\t\t\t\tvalue = MAJOR(stat->dev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MINOR:\n\t\t\t\t\t\tvalue = MINOR(stat->dev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH2_TYPE:\n\t\t\t\t\t\tvalue = stat->mode & S_IFMT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MAJOR:\n\t\t\t\t\t\tvalue = MAJOR(stat->rdev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MINOR:\n\t\t\t\t\t\tvalue = MINOR(stat->rdev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\t\t\tvalue = stat->mode & S_IALLUGO;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmax_v[j] = value;\n\t\t\tmin_v[j] = value;\n\t\t\tswitch (index) {\n\t\t\tcase TOMOYO_MODE_SETUID:\n\t\t\tcase TOMOYO_MODE_SETGID:\n\t\t\tcase TOMOYO_MODE_STICKY:\n\t\t\tcase TOMOYO_MODE_OWNER_READ:\n\t\t\tcase TOMOYO_MODE_OWNER_WRITE:\n\t\t\tcase TOMOYO_MODE_OWNER_EXECUTE:\n\t\t\tcase TOMOYO_MODE_GROUP_READ:\n\t\t\tcase TOMOYO_MODE_GROUP_WRITE:\n\t\t\tcase TOMOYO_MODE_GROUP_EXECUTE:\n\t\t\tcase TOMOYO_MODE_OTHERS_READ:\n\t\t\tcase TOMOYO_MODE_OTHERS_WRITE:\n\t\t\tcase TOMOYO_MODE_OTHERS_EXECUTE:\n\t\t\t\tis_bitop[j] = true;\n\t\t\t}\n\t\t}\n\t\tif (left == TOMOYO_NUMBER_UNION) {\n\t\t\t/* Fetch values now. */\n\t\t\tconst struct tomoyo_number_union *ptr = numbers_p++;\n\t\t\tmin_v[0] = ptr->values[0];\n\t\t\tmax_v[0] = ptr->values[1];\n\t\t}\n\t\tif (right == TOMOYO_NUMBER_UNION) {\n\t\t\t/* Fetch values now. */\n\t\t\tconst struct tomoyo_number_union *ptr = numbers_p++;\n\t\t\tif (ptr->group) {\n\t\t\t\tif (tomoyo_number_matches_group(min_v[0],\n\t\t\t\t\t\t\t\tmax_v[0],\n\t\t\t\t\t\t\t\tptr->group)\n\t\t\t\t    == match)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif ((min_v[0] <= ptr->values[1] &&\n\t\t\t\t     max_v[0] >= ptr->values[0]) == match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * Bit operation is valid only when counterpart value\n\t\t * represents permission.\n\t\t */\n\t\tif (is_bitop[0] && is_bitop[1]) {\n\t\t\tgoto out;\n\t\t} else if (is_bitop[0]) {\n\t\t\tswitch (right) {\n\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\tif (!(max_v[0] & max_v[1]) == !match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t} else if (is_bitop[1]) {\n\t\t\tswitch (left) {\n\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\tif (!(max_v[0] & max_v[1]) == !match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t/* Normal value range comparison. */\n\t\tif ((min_v[0] <= max_v[1] && max_v[0] >= min_v[1]) == match)\n\t\t\tcontinue;\nout:\n\t\treturn false;\n\t}\n\t/* Check argv[] and envp[] now. */\n\tif (r->ee && (argc || envc))\n\t\treturn tomoyo_scan_bprm(r->ee, argc, argv, envc, envp);\n\treturn true;\n}"
  },
  {
    "function_name": "tomoyo_get_attributes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "694-733",
    "snippet": "void tomoyo_get_attributes(struct tomoyo_obj_info *obj)\n{\n\tu8 i;\n\tstruct dentry *dentry = NULL;\n\n\tfor (i = 0; i < TOMOYO_MAX_PATH_STAT; i++) {\n\t\tstruct inode *inode;\n\t\tswitch (i) {\n\t\tcase TOMOYO_PATH1:\n\t\t\tdentry = obj->path1.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase TOMOYO_PATH2:\n\t\t\tdentry = obj->path2.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tdentry = dget_parent(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tinode = d_backing_inode(dentry);\n\t\tif (inode) {\n\t\t\tstruct tomoyo_mini_stat *stat = &obj->stat[i];\n\t\t\tstat->uid  = inode->i_uid;\n\t\t\tstat->gid  = inode->i_gid;\n\t\t\tstat->ino  = inode->i_ino;\n\t\t\tstat->mode = inode->i_mode;\n\t\t\tstat->dev  = inode->i_sb->s_dev;\n\t\t\tstat->rdev = inode->i_rdev;\n\t\t\tobj->stat_valid[i] = true;\n\t\t}\n\t\tif (i & 1) /* i == TOMOYO_PATH1_PARENT ||\n\t\t\t      i == TOMOYO_PATH2_PARENT */\n\t\t\tdput(dentry);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_get_attributes(struct tomoyo_obj_info *obj)\n{\n\tu8 i;\n\tstruct dentry *dentry = NULL;\n\n\tfor (i = 0; i < TOMOYO_MAX_PATH_STAT; i++) {\n\t\tstruct inode *inode;\n\t\tswitch (i) {\n\t\tcase TOMOYO_PATH1:\n\t\t\tdentry = obj->path1.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase TOMOYO_PATH2:\n\t\t\tdentry = obj->path2.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tdentry = dget_parent(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tinode = d_backing_inode(dentry);\n\t\tif (inode) {\n\t\t\tstruct tomoyo_mini_stat *stat = &obj->stat[i];\n\t\t\tstat->uid  = inode->i_uid;\n\t\t\tstat->gid  = inode->i_gid;\n\t\t\tstat->ino  = inode->i_ino;\n\t\t\tstat->mode = inode->i_mode;\n\t\t\tstat->dev  = inode->i_sb->s_dev;\n\t\t\tstat->rdev = inode->i_rdev;\n\t\t\tobj->stat_valid[i] = true;\n\t\t}\n\t\tif (i & 1) /* i == TOMOYO_PATH1_PARENT ||\n\t\t\t      i == TOMOYO_PATH2_PARENT */\n\t\t\tdput(dentry);\n\t}\n}"
  },
  {
    "function_name": "tomoyo_get_condition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "479-685",
    "snippet": "struct tomoyo_condition *tomoyo_get_condition(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_condition *entry = NULL;\n\tstruct tomoyo_condition_element *condp = NULL;\n\tstruct tomoyo_number_union *numbers_p = NULL;\n\tstruct tomoyo_name_union *names_p = NULL;\n\tstruct tomoyo_argv *argv = NULL;\n\tstruct tomoyo_envp *envp = NULL;\n\tstruct tomoyo_condition e = { };\n\tchar * const start_of_string =\n\t\ttomoyo_get_transit_preference(param, &e);\n\tchar * const end_of_string = start_of_string + strlen(start_of_string);\n\tchar *pos;\nrerun:\n\tpos = start_of_string;\n\twhile (1) {\n\t\tu8 left = -1;\n\t\tu8 right = -1;\n\t\tchar *left_word = pos;\n\t\tchar *cp;\n\t\tchar *right_word;\n\t\tbool is_not;\n\t\tif (!*left_word)\n\t\t\tbreak;\n\t\t/*\n\t\t * Since left-hand condition does not allow use of \"path_group\"\n\t\t * or \"number_group\" and environment variable's names do not\n\t\t * accept '=', it is guaranteed that the original line consists\n\t\t * of one or more repetition of $left$operator$right blocks\n\t\t * where \"$left is free from '=' and ' '\" and \"$operator is\n\t\t * either '=' or '!='\" and \"$right is free from ' '\".\n\t\t * Therefore, we can reconstruct the original line at the end\n\t\t * of dry run even if we overwrite $operator with '\\0'.\n\t\t */\n\t\tcp = strchr(pos, ' ');\n\t\tif (cp) {\n\t\t\t*cp = '\\0'; /* Will restore later. */\n\t\t\tpos = cp + 1;\n\t\t} else {\n\t\t\tpos = \"\";\n\t\t}\n\t\tright_word = strchr(left_word, '=');\n\t\tif (!right_word || right_word == left_word)\n\t\t\tgoto out;\n\t\tis_not = *(right_word - 1) == '!';\n\t\tif (is_not)\n\t\t\t*(right_word++ - 1) = '\\0'; /* Will restore later. */\n\t\telse if (*(right_word + 1) != '=')\n\t\t\t*right_word++ = '\\0'; /* Will restore later. */\n\t\telse\n\t\t\tgoto out;\n\t\tdprintk(KERN_WARNING \"%u: <%s>%s=<%s>\\n\", __LINE__, left_word,\n\t\t\tis_not ? \"!\" : \"\", right_word);\n\t\tif (!strcmp(left_word, \"grant_log\")) {\n\t\t\tif (entry) {\n\t\t\t\tif (is_not ||\n\t\t\t\t    entry->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\t\t\t\tgoto out;\n\t\t\t\telse if (!strcmp(right_word, \"yes\"))\n\t\t\t\t\tentry->grant_log = TOMOYO_GRANTLOG_YES;\n\t\t\t\telse if (!strcmp(right_word, \"no\"))\n\t\t\t\t\tentry->grant_log = TOMOYO_GRANTLOG_NO;\n\t\t\t\telse\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp(left_word, \"exec.argv[\", 10)) {\n\t\t\tif (!argv) {\n\t\t\t\te.argc++;\n\t\t\t\te.condc++;\n\t\t\t} else {\n\t\t\t\te.argc--;\n\t\t\t\te.condc--;\n\t\t\t\tleft = TOMOYO_ARGV_ENTRY;\n\t\t\t\targv->is_not = is_not;\n\t\t\t\tif (!tomoyo_parse_argv(left_word + 10,\n\t\t\t\t\t\t       right_word, argv++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tif (!strncmp(left_word, \"exec.envp[\\\"\", 11)) {\n\t\t\tif (!envp) {\n\t\t\t\te.envc++;\n\t\t\t\te.condc++;\n\t\t\t} else {\n\t\t\t\te.envc--;\n\t\t\t\te.condc--;\n\t\t\t\tleft = TOMOYO_ENVP_ENTRY;\n\t\t\t\tenvp->is_not = is_not;\n\t\t\t\tif (!tomoyo_parse_envp(left_word + 11,\n\t\t\t\t\t\t       right_word, envp++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tleft = tomoyo_condition_type(left_word);\n\t\tdprintk(KERN_WARNING \"%u: <%s> left=%u\\n\", __LINE__, left_word,\n\t\t\tleft);\n\t\tif (left == TOMOYO_MAX_CONDITION_KEYWORD) {\n\t\t\tif (!numbers_p) {\n\t\t\t\te.numbers_count++;\n\t\t\t} else {\n\t\t\t\te.numbers_count--;\n\t\t\t\tleft = TOMOYO_NUMBER_UNION;\n\t\t\t\tparam->data = left_word;\n\t\t\t\tif (*left_word == '@' ||\n\t\t\t\t    !tomoyo_parse_number_union(param,\n\t\t\t\t\t\t\t       numbers_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!condp)\n\t\t\te.condc++;\n\t\telse\n\t\t\te.condc--;\n\t\tif (left == TOMOYO_EXEC_REALPATH ||\n\t\t    left == TOMOYO_SYMLINK_TARGET) {\n\t\t\tif (!names_p) {\n\t\t\t\te.names_count++;\n\t\t\t} else {\n\t\t\t\te.names_count--;\n\t\t\t\tright = TOMOYO_NAME_UNION;\n\t\t\t\tparam->data = right_word;\n\t\t\t\tif (!tomoyo_parse_name_union_quoted(param,\n\t\t\t\t\t\t\t\t    names_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tright = tomoyo_condition_type(right_word);\n\t\tif (right == TOMOYO_MAX_CONDITION_KEYWORD) {\n\t\t\tif (!numbers_p) {\n\t\t\t\te.numbers_count++;\n\t\t\t} else {\n\t\t\t\te.numbers_count--;\n\t\t\t\tright = TOMOYO_NUMBER_UNION;\n\t\t\t\tparam->data = right_word;\n\t\t\t\tif (!tomoyo_parse_number_union(param,\n\t\t\t\t\t\t\t       numbers_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\nstore_value:\n\t\tif (!condp) {\n\t\t\tdprintk(KERN_WARNING \"%u: dry_run left=%u right=%u \"\n\t\t\t\t\"match=%u\\n\", __LINE__, left, right, !is_not);\n\t\t\tcontinue;\n\t\t}\n\t\tcondp->left = left;\n\t\tcondp->right = right;\n\t\tcondp->equals = !is_not;\n\t\tdprintk(KERN_WARNING \"%u: left=%u right=%u match=%u\\n\",\n\t\t\t__LINE__, condp->left, condp->right,\n\t\t\tcondp->equals);\n\t\tcondp++;\n\t}\n\tdprintk(KERN_INFO \"%u: cond=%u numbers=%u names=%u ac=%u ec=%u\\n\",\n\t\t__LINE__, e.condc, e.numbers_count, e.names_count, e.argc,\n\t\te.envc);\n\tif (entry) {\n\t\tBUG_ON(e.names_count | e.numbers_count | e.argc | e.envc |\n\t\t       e.condc);\n\t\treturn tomoyo_commit_condition(entry);\n\t}\n\te.size = sizeof(*entry)\n\t\t+ e.condc * sizeof(struct tomoyo_condition_element)\n\t\t+ e.numbers_count * sizeof(struct tomoyo_number_union)\n\t\t+ e.names_count * sizeof(struct tomoyo_name_union)\n\t\t+ e.argc * sizeof(struct tomoyo_argv)\n\t\t+ e.envc * sizeof(struct tomoyo_envp);\n\tentry = kzalloc(e.size, GFP_NOFS);\n\tif (!entry)\n\t\tgoto out2;\n\t*entry = e;\n\te.transit = NULL;\n\tcondp = (struct tomoyo_condition_element *) (entry + 1);\n\tnumbers_p = (struct tomoyo_number_union *) (condp + e.condc);\n\tnames_p = (struct tomoyo_name_union *) (numbers_p + e.numbers_count);\n\targv = (struct tomoyo_argv *) (names_p + e.names_count);\n\tenvp = (struct tomoyo_envp *) (argv + e.argc);\n\t{\n\t\tbool flag = false;\n\t\tfor (pos = start_of_string; pos < end_of_string; pos++) {\n\t\t\tif (*pos)\n\t\t\t\tcontinue;\n\t\t\tif (flag) /* Restore \" \". */\n\t\t\t\t*pos = ' ';\n\t\t\telse if (*(pos + 1) == '=') /* Restore \"!=\". */\n\t\t\t\t*pos = '!';\n\t\t\telse /* Restore \"=\". */\n\t\t\t\t*pos = '=';\n\t\t\tflag = !flag;\n\t\t}\n\t}\n\tgoto rerun;\nout:\n\tdprintk(KERN_WARNING \"%u: %s failed\\n\", __LINE__, __func__);\n\tif (entry) {\n\t\ttomoyo_del_condition(&entry->head.list);\n\t\tkfree(entry);\n\t}\nout2:\n\ttomoyo_put_name(e.transit);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define dprintk printk"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "e.transit"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_del_condition",
          "args": [
            "&entry->head.list"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_condition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "269-299",
          "snippet": "void tomoyo_del_condition(struct list_head *element)\n{\n\tstruct tomoyo_condition *cond = container_of(element, typeof(*cond),\n\t\t\t\t\t\t     head.list);\n\tconst u16 condc = cond->condc;\n\tconst u16 numbers_count = cond->numbers_count;\n\tconst u16 names_count = cond->names_count;\n\tconst u16 argc = cond->argc;\n\tconst u16 envc = cond->envc;\n\tunsigned int i;\n\tconst struct tomoyo_condition_element *condp\n\t\t= (const struct tomoyo_condition_element *) (cond + 1);\n\tstruct tomoyo_number_union *numbers_p\n\t\t= (struct tomoyo_number_union *) (condp + condc);\n\tstruct tomoyo_name_union *names_p\n\t\t= (struct tomoyo_name_union *) (numbers_p + numbers_count);\n\tconst struct tomoyo_argv *argv\n\t\t= (const struct tomoyo_argv *) (names_p + names_count);\n\tconst struct tomoyo_envp *envp\n\t\t= (const struct tomoyo_envp *) (argv + argc);\n\tfor (i = 0; i < numbers_count; i++)\n\t\ttomoyo_put_number_union(numbers_p++);\n\tfor (i = 0; i < names_count; i++)\n\t\ttomoyo_put_name_union(names_p++);\n\tfor (i = 0; i < argc; argv++, i++)\n\t\ttomoyo_put_name(argv->value);\n\tfor (i = 0; i < envc; envp++, i++) {\n\t\ttomoyo_put_name(envp->name);\n\t\ttomoyo_put_name(envp->value);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nvoid tomoyo_del_condition(struct list_head *element)\n{\n\tstruct tomoyo_condition *cond = container_of(element, typeof(*cond),\n\t\t\t\t\t\t     head.list);\n\tconst u16 condc = cond->condc;\n\tconst u16 numbers_count = cond->numbers_count;\n\tconst u16 names_count = cond->names_count;\n\tconst u16 argc = cond->argc;\n\tconst u16 envc = cond->envc;\n\tunsigned int i;\n\tconst struct tomoyo_condition_element *condp\n\t\t= (const struct tomoyo_condition_element *) (cond + 1);\n\tstruct tomoyo_number_union *numbers_p\n\t\t= (struct tomoyo_number_union *) (condp + condc);\n\tstruct tomoyo_name_union *names_p\n\t\t= (struct tomoyo_name_union *) (numbers_p + numbers_count);\n\tconst struct tomoyo_argv *argv\n\t\t= (const struct tomoyo_argv *) (names_p + names_count);\n\tconst struct tomoyo_envp *envp\n\t\t= (const struct tomoyo_envp *) (argv + argc);\n\tfor (i = 0; i < numbers_count; i++)\n\t\ttomoyo_put_number_union(numbers_p++);\n\tfor (i = 0; i < names_count; i++)\n\t\ttomoyo_put_name_union(names_p++);\n\tfor (i = 0; i < argc; argv++, i++)\n\t\ttomoyo_put_name(argv->value);\n\tfor (i = 0; i < envc; envp++, i++) {\n\t\ttomoyo_put_name(envp->name);\n\t\ttomoyo_put_name(envp->value);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "KERN_WARNING \"%u: %s failed\\n\"",
            "__LINE__",
            "__func__"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "e.size",
            "GFP_NOFS"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_commit_condition",
          "args": [
            "entry"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_commit_condition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "393-430",
          "snippet": "static struct tomoyo_condition *tomoyo_commit_condition\n(struct tomoyo_condition *entry)\n{\n\tstruct tomoyo_condition *ptr;\n\tbool found = false;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock)) {\n\t\tdprintk(KERN_WARNING \"%u: %s failed\\n\", __LINE__, __func__);\n\t\tptr = NULL;\n\t\tfound = true;\n\t\tgoto out;\n\t}\n\tlist_for_each_entry(ptr, &tomoyo_condition_list, head.list) {\n\t\tif (!tomoyo_same_condition(ptr, entry) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\t/* Same entry found. Share this entry. */\n\t\tatomic_inc(&ptr->head.users);\n\t\tfound = true;\n\t\tbreak;\n\t}\n\tif (!found) {\n\t\tif (tomoyo_memory_ok(entry)) {\n\t\t\tatomic_set(&entry->head.users, 1);\n\t\t\tlist_add(&entry->head.list, &tomoyo_condition_list);\n\t\t} else {\n\t\t\tfound = true;\n\t\t\tptr = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\tif (found) {\n\t\ttomoyo_del_condition(&entry->head.list);\n\t\tkfree(entry);\n\t\tentry = ptr;\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define dprintk printk"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\n#define dprintk printk\n\nstatic struct tomoyo_condition *tomoyo_commit_condition\n(struct tomoyo_condition *entry)\n{\n\tstruct tomoyo_condition *ptr;\n\tbool found = false;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock)) {\n\t\tdprintk(KERN_WARNING \"%u: %s failed\\n\", __LINE__, __func__);\n\t\tptr = NULL;\n\t\tfound = true;\n\t\tgoto out;\n\t}\n\tlist_for_each_entry(ptr, &tomoyo_condition_list, head.list) {\n\t\tif (!tomoyo_same_condition(ptr, entry) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\t/* Same entry found. Share this entry. */\n\t\tatomic_inc(&ptr->head.users);\n\t\tfound = true;\n\t\tbreak;\n\t}\n\tif (!found) {\n\t\tif (tomoyo_memory_ok(entry)) {\n\t\t\tatomic_set(&entry->head.users, 1);\n\t\t\tlist_add(&entry->head.list, &tomoyo_condition_list);\n\t\t} else {\n\t\t\tfound = true;\n\t\t\tptr = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\tif (found) {\n\t\ttomoyo_del_condition(&entry->head.list);\n\t\tkfree(entry);\n\t\tentry = ptr;\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "e.names_count | e.numbers_count | e.argc | e.envc |\n\t\t       e.condc"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "KERN_INFO \"%u: cond=%u numbers=%u names=%u ac=%u ec=%u\\n\"",
            "__LINE__",
            "e.condc",
            "e.numbers_count",
            "e.names_count",
            "e.argc",
            "e.envc"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "KERN_WARNING \"%u: left=%u right=%u match=%u\\n\"",
            "__LINE__",
            "condp->left",
            "condp->right",
            "condp->equals"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "KERN_WARNING \"%u: dry_run left=%u right=%u \"\n\t\t\t\t\"match=%u\\n\"",
            "__LINE__",
            "left",
            "right",
            "!is_not"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_parse_number_union",
          "args": [
            "param",
            "numbers_p++"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_parse_number_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "263-294",
          "snippet": "bool tomoyo_parse_number_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_number_union *ptr)\n{\n\tchar *data;\n\tu8 type;\n\tunsigned long v;\n\tmemset(ptr, 0, sizeof(*ptr));\n\tif (param->data[0] == '@') {\n\t\tparam->data++;\n\t\tptr->group = tomoyo_get_group(param, TOMOYO_NUMBER_GROUP);\n\t\treturn ptr->group != NULL;\n\t}\n\tdata = tomoyo_read_token(param);\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID)\n\t\treturn false;\n\tptr->values[0] = v;\n\tptr->value_type[0] = type;\n\tif (!*data) {\n\t\tptr->values[1] = v;\n\t\tptr->value_type[1] = type;\n\t\treturn true;\n\t}\n\tif (*data++ != '-')\n\t\treturn false;\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID || *data || ptr->values[0] > v)\n\t\treturn false;\n\tptr->values[1] = v;\n\tptr->value_type[1] = type;\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_parse_number_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_number_union *ptr)\n{\n\tchar *data;\n\tu8 type;\n\tunsigned long v;\n\tmemset(ptr, 0, sizeof(*ptr));\n\tif (param->data[0] == '@') {\n\t\tparam->data++;\n\t\tptr->group = tomoyo_get_group(param, TOMOYO_NUMBER_GROUP);\n\t\treturn ptr->group != NULL;\n\t}\n\tdata = tomoyo_read_token(param);\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID)\n\t\treturn false;\n\tptr->values[0] = v;\n\tptr->value_type[0] = type;\n\tif (!*data) {\n\t\tptr->values[1] = v;\n\t\tptr->value_type[1] = type;\n\t\treturn true;\n\t}\n\tif (*data++ != '-')\n\t\treturn false;\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID || *data || ptr->values[0] > v)\n\t\treturn false;\n\tptr->values[1] = v;\n\tptr->value_type[1] = type;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_condition_type",
          "args": [
            "right_word"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_condition_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "364-372",
          "snippet": "static u8 tomoyo_condition_type(const char *word)\n{\n\tu8 i;\n\tfor (i = 0; i < TOMOYO_MAX_CONDITION_KEYWORD; i++) {\n\t\tif (!strcmp(word, tomoyo_condition_keyword[i]))\n\t\t\tbreak;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic u8 tomoyo_condition_type(const char *word)\n{\n\tu8 i;\n\tfor (i = 0; i < TOMOYO_MAX_CONDITION_KEYWORD; i++) {\n\t\tif (!strcmp(word, tomoyo_condition_keyword[i]))\n\t\t\tbreak;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_parse_name_union_quoted",
          "args": [
            "param",
            "names_p++"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_parse_name_union_quoted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "269-277",
          "snippet": "static bool tomoyo_parse_name_union_quoted(struct tomoyo_acl_param *param,\n\t\t\t\t\t   struct tomoyo_name_union *ptr)\n{\n\tchar *filename = param->data;\n\tif (*filename == '@')\n\t\treturn tomoyo_parse_name_union(param, ptr);\n\tptr->filename = tomoyo_get_dqword(filename);\n\treturn ptr->filename != NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_parse_name_union_quoted(struct tomoyo_acl_param *param,\n\t\t\t\t\t   struct tomoyo_name_union *ptr)\n{\n\tchar *filename = param->data;\n\tif (*filename == '@')\n\t\treturn tomoyo_parse_name_union(param, ptr);\n\tptr->filename = tomoyo_get_dqword(filename);\n\treturn ptr->filename != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "KERN_WARNING \"%u: <%s> left=%u\\n\"",
            "__LINE__",
            "left_word",
            "left"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_parse_envp",
          "args": [
            "left_word + 11",
            "right_word",
            "envp++"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_parse_envp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "307-335",
          "snippet": "static bool tomoyo_parse_envp(char *left, char *right,\n\t\t\t      struct tomoyo_envp *envp)\n{\n\tconst struct tomoyo_path_info *name;\n\tconst struct tomoyo_path_info *value;\n\tchar *cp = left + strlen(left) - 1;\n\tif (*cp-- != ']' || *cp != '\"')\n\t\tgoto out;\n\t*cp = '\\0';\n\tif (!tomoyo_correct_word(left))\n\t\tgoto out;\n\tname = tomoyo_get_name(left);\n\tif (!name)\n\t\tgoto out;\n\tif (!strcmp(right, \"NULL\")) {\n\t\tvalue = NULL;\n\t} else {\n\t\tvalue = tomoyo_get_dqword(right);\n\t\tif (!value) {\n\t\t\ttomoyo_put_name(name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tenvp->name = name;\n\tenvp->value = value;\n\treturn true;\nout:\n\treturn false;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_parse_envp(char *left, char *right,\n\t\t\t      struct tomoyo_envp *envp)\n{\n\tconst struct tomoyo_path_info *name;\n\tconst struct tomoyo_path_info *value;\n\tchar *cp = left + strlen(left) - 1;\n\tif (*cp-- != ']' || *cp != '\"')\n\t\tgoto out;\n\t*cp = '\\0';\n\tif (!tomoyo_correct_word(left))\n\t\tgoto out;\n\tname = tomoyo_get_name(left);\n\tif (!name)\n\t\tgoto out;\n\tif (!strcmp(right, \"NULL\")) {\n\t\tvalue = NULL;\n\t} else {\n\t\tvalue = tomoyo_get_dqword(right);\n\t\tif (!value) {\n\t\t\ttomoyo_put_name(name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tenvp->name = name;\n\tenvp->value = value;\n\treturn true;\nout:\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "left_word",
            "\"exec.envp[\\\"\"",
            "11"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_parse_argv",
          "args": [
            "left_word + 10",
            "right_word",
            "argv++"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_parse_argv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "288-296",
          "snippet": "static bool tomoyo_parse_argv(char *left, char *right,\n\t\t\t      struct tomoyo_argv *argv)\n{\n\tif (tomoyo_parse_ulong(&argv->index, &left) !=\n\t    TOMOYO_VALUE_TYPE_DECIMAL || *left++ != ']' || *left)\n\t\treturn false;\n\targv->value = tomoyo_get_dqword(right);\n\treturn argv->value != NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_parse_argv(char *left, char *right,\n\t\t\t      struct tomoyo_argv *argv)\n{\n\tif (tomoyo_parse_ulong(&argv->index, &left) !=\n\t    TOMOYO_VALUE_TYPE_DECIMAL || *left++ != ']' || *left)\n\t\treturn false;\n\targv->value = tomoyo_get_dqword(right);\n\treturn argv->value != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "left_word",
            "\"exec.argv[\"",
            "10"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "right_word",
            "\"no\""
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "right_word",
            "\"yes\""
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "left_word",
            "\"grant_log\""
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "KERN_WARNING \"%u: <%s>%s=<%s>\\n\"",
            "__LINE__",
            "left_word",
            "is_not ? \"!\" : \"\"",
            "right_word"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "left_word",
            "'='"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "pos",
            "' '"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "start_of_string"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_transit_preference",
          "args": [
            "param",
            "&e"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_transit_preference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "440-470",
          "snippet": "static char *tomoyo_get_transit_preference(struct tomoyo_acl_param *param,\n\t\t\t\t\t   struct tomoyo_condition *e)\n{\n\tchar * const pos = param->data;\n\tbool flag;\n\tif (*pos == '<') {\n\t\te->transit = tomoyo_get_domainname(param);\n\t\tgoto done;\n\t}\n\t{\n\t\tchar *cp = strchr(pos, ' ');\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\t\tflag = tomoyo_correct_path(pos) || !strcmp(pos, \"keep\") ||\n\t\t\t!strcmp(pos, \"initialize\") || !strcmp(pos, \"reset\") ||\n\t\t\t!strcmp(pos, \"child\") || !strcmp(pos, \"parent\");\n\t\tif (cp)\n\t\t\t*cp = ' ';\n\t}\n\tif (!flag)\n\t\treturn pos;\n\te->transit = tomoyo_get_name(tomoyo_read_token(param));\ndone:\n\tif (e->transit)\n\t\treturn param->data;\n\t/*\n\t * Return a bad read-only condition string that will let\n\t * tomoyo_get_condition() return NULL.\n\t */\n\treturn \"/\";\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic char *tomoyo_get_transit_preference(struct tomoyo_acl_param *param,\n\t\t\t\t\t   struct tomoyo_condition *e)\n{\n\tchar * const pos = param->data;\n\tbool flag;\n\tif (*pos == '<') {\n\t\te->transit = tomoyo_get_domainname(param);\n\t\tgoto done;\n\t}\n\t{\n\t\tchar *cp = strchr(pos, ' ');\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\t\tflag = tomoyo_correct_path(pos) || !strcmp(pos, \"keep\") ||\n\t\t\t!strcmp(pos, \"initialize\") || !strcmp(pos, \"reset\") ||\n\t\t\t!strcmp(pos, \"child\") || !strcmp(pos, \"parent\");\n\t\tif (cp)\n\t\t\t*cp = ' ';\n\t}\n\tif (!flag)\n\t\treturn pos;\n\te->transit = tomoyo_get_name(tomoyo_read_token(param));\ndone:\n\tif (e->transit)\n\t\treturn param->data;\n\t/*\n\t * Return a bad read-only condition string that will let\n\t * tomoyo_get_condition() return NULL.\n\t */\n\treturn \"/\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\n#define dprintk printk\n\nstruct tomoyo_condition *tomoyo_get_condition(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_condition *entry = NULL;\n\tstruct tomoyo_condition_element *condp = NULL;\n\tstruct tomoyo_number_union *numbers_p = NULL;\n\tstruct tomoyo_name_union *names_p = NULL;\n\tstruct tomoyo_argv *argv = NULL;\n\tstruct tomoyo_envp *envp = NULL;\n\tstruct tomoyo_condition e = { };\n\tchar * const start_of_string =\n\t\ttomoyo_get_transit_preference(param, &e);\n\tchar * const end_of_string = start_of_string + strlen(start_of_string);\n\tchar *pos;\nrerun:\n\tpos = start_of_string;\n\twhile (1) {\n\t\tu8 left = -1;\n\t\tu8 right = -1;\n\t\tchar *left_word = pos;\n\t\tchar *cp;\n\t\tchar *right_word;\n\t\tbool is_not;\n\t\tif (!*left_word)\n\t\t\tbreak;\n\t\t/*\n\t\t * Since left-hand condition does not allow use of \"path_group\"\n\t\t * or \"number_group\" and environment variable's names do not\n\t\t * accept '=', it is guaranteed that the original line consists\n\t\t * of one or more repetition of $left$operator$right blocks\n\t\t * where \"$left is free from '=' and ' '\" and \"$operator is\n\t\t * either '=' or '!='\" and \"$right is free from ' '\".\n\t\t * Therefore, we can reconstruct the original line at the end\n\t\t * of dry run even if we overwrite $operator with '\\0'.\n\t\t */\n\t\tcp = strchr(pos, ' ');\n\t\tif (cp) {\n\t\t\t*cp = '\\0'; /* Will restore later. */\n\t\t\tpos = cp + 1;\n\t\t} else {\n\t\t\tpos = \"\";\n\t\t}\n\t\tright_word = strchr(left_word, '=');\n\t\tif (!right_word || right_word == left_word)\n\t\t\tgoto out;\n\t\tis_not = *(right_word - 1) == '!';\n\t\tif (is_not)\n\t\t\t*(right_word++ - 1) = '\\0'; /* Will restore later. */\n\t\telse if (*(right_word + 1) != '=')\n\t\t\t*right_word++ = '\\0'; /* Will restore later. */\n\t\telse\n\t\t\tgoto out;\n\t\tdprintk(KERN_WARNING \"%u: <%s>%s=<%s>\\n\", __LINE__, left_word,\n\t\t\tis_not ? \"!\" : \"\", right_word);\n\t\tif (!strcmp(left_word, \"grant_log\")) {\n\t\t\tif (entry) {\n\t\t\t\tif (is_not ||\n\t\t\t\t    entry->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\t\t\t\tgoto out;\n\t\t\t\telse if (!strcmp(right_word, \"yes\"))\n\t\t\t\t\tentry->grant_log = TOMOYO_GRANTLOG_YES;\n\t\t\t\telse if (!strcmp(right_word, \"no\"))\n\t\t\t\t\tentry->grant_log = TOMOYO_GRANTLOG_NO;\n\t\t\t\telse\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp(left_word, \"exec.argv[\", 10)) {\n\t\t\tif (!argv) {\n\t\t\t\te.argc++;\n\t\t\t\te.condc++;\n\t\t\t} else {\n\t\t\t\te.argc--;\n\t\t\t\te.condc--;\n\t\t\t\tleft = TOMOYO_ARGV_ENTRY;\n\t\t\t\targv->is_not = is_not;\n\t\t\t\tif (!tomoyo_parse_argv(left_word + 10,\n\t\t\t\t\t\t       right_word, argv++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tif (!strncmp(left_word, \"exec.envp[\\\"\", 11)) {\n\t\t\tif (!envp) {\n\t\t\t\te.envc++;\n\t\t\t\te.condc++;\n\t\t\t} else {\n\t\t\t\te.envc--;\n\t\t\t\te.condc--;\n\t\t\t\tleft = TOMOYO_ENVP_ENTRY;\n\t\t\t\tenvp->is_not = is_not;\n\t\t\t\tif (!tomoyo_parse_envp(left_word + 11,\n\t\t\t\t\t\t       right_word, envp++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tleft = tomoyo_condition_type(left_word);\n\t\tdprintk(KERN_WARNING \"%u: <%s> left=%u\\n\", __LINE__, left_word,\n\t\t\tleft);\n\t\tif (left == TOMOYO_MAX_CONDITION_KEYWORD) {\n\t\t\tif (!numbers_p) {\n\t\t\t\te.numbers_count++;\n\t\t\t} else {\n\t\t\t\te.numbers_count--;\n\t\t\t\tleft = TOMOYO_NUMBER_UNION;\n\t\t\t\tparam->data = left_word;\n\t\t\t\tif (*left_word == '@' ||\n\t\t\t\t    !tomoyo_parse_number_union(param,\n\t\t\t\t\t\t\t       numbers_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!condp)\n\t\t\te.condc++;\n\t\telse\n\t\t\te.condc--;\n\t\tif (left == TOMOYO_EXEC_REALPATH ||\n\t\t    left == TOMOYO_SYMLINK_TARGET) {\n\t\t\tif (!names_p) {\n\t\t\t\te.names_count++;\n\t\t\t} else {\n\t\t\t\te.names_count--;\n\t\t\t\tright = TOMOYO_NAME_UNION;\n\t\t\t\tparam->data = right_word;\n\t\t\t\tif (!tomoyo_parse_name_union_quoted(param,\n\t\t\t\t\t\t\t\t    names_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tright = tomoyo_condition_type(right_word);\n\t\tif (right == TOMOYO_MAX_CONDITION_KEYWORD) {\n\t\t\tif (!numbers_p) {\n\t\t\t\te.numbers_count++;\n\t\t\t} else {\n\t\t\t\te.numbers_count--;\n\t\t\t\tright = TOMOYO_NUMBER_UNION;\n\t\t\t\tparam->data = right_word;\n\t\t\t\tif (!tomoyo_parse_number_union(param,\n\t\t\t\t\t\t\t       numbers_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\nstore_value:\n\t\tif (!condp) {\n\t\t\tdprintk(KERN_WARNING \"%u: dry_run left=%u right=%u \"\n\t\t\t\t\"match=%u\\n\", __LINE__, left, right, !is_not);\n\t\t\tcontinue;\n\t\t}\n\t\tcondp->left = left;\n\t\tcondp->right = right;\n\t\tcondp->equals = !is_not;\n\t\tdprintk(KERN_WARNING \"%u: left=%u right=%u match=%u\\n\",\n\t\t\t__LINE__, condp->left, condp->right,\n\t\t\tcondp->equals);\n\t\tcondp++;\n\t}\n\tdprintk(KERN_INFO \"%u: cond=%u numbers=%u names=%u ac=%u ec=%u\\n\",\n\t\t__LINE__, e.condc, e.numbers_count, e.names_count, e.argc,\n\t\te.envc);\n\tif (entry) {\n\t\tBUG_ON(e.names_count | e.numbers_count | e.argc | e.envc |\n\t\t       e.condc);\n\t\treturn tomoyo_commit_condition(entry);\n\t}\n\te.size = sizeof(*entry)\n\t\t+ e.condc * sizeof(struct tomoyo_condition_element)\n\t\t+ e.numbers_count * sizeof(struct tomoyo_number_union)\n\t\t+ e.names_count * sizeof(struct tomoyo_name_union)\n\t\t+ e.argc * sizeof(struct tomoyo_argv)\n\t\t+ e.envc * sizeof(struct tomoyo_envp);\n\tentry = kzalloc(e.size, GFP_NOFS);\n\tif (!entry)\n\t\tgoto out2;\n\t*entry = e;\n\te.transit = NULL;\n\tcondp = (struct tomoyo_condition_element *) (entry + 1);\n\tnumbers_p = (struct tomoyo_number_union *) (condp + e.condc);\n\tnames_p = (struct tomoyo_name_union *) (numbers_p + e.numbers_count);\n\targv = (struct tomoyo_argv *) (names_p + e.names_count);\n\tenvp = (struct tomoyo_envp *) (argv + e.argc);\n\t{\n\t\tbool flag = false;\n\t\tfor (pos = start_of_string; pos < end_of_string; pos++) {\n\t\t\tif (*pos)\n\t\t\t\tcontinue;\n\t\t\tif (flag) /* Restore \" \". */\n\t\t\t\t*pos = ' ';\n\t\t\telse if (*(pos + 1) == '=') /* Restore \"!=\". */\n\t\t\t\t*pos = '!';\n\t\t\telse /* Restore \"=\". */\n\t\t\t\t*pos = '=';\n\t\t\tflag = !flag;\n\t\t}\n\t}\n\tgoto rerun;\nout:\n\tdprintk(KERN_WARNING \"%u: %s failed\\n\", __LINE__, __func__);\n\tif (entry) {\n\t\ttomoyo_del_condition(&entry->head.list);\n\t\tkfree(entry);\n\t}\nout2:\n\ttomoyo_put_name(e.transit);\n\treturn NULL;\n}"
  },
  {
    "function_name": "tomoyo_get_transit_preference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "440-470",
    "snippet": "static char *tomoyo_get_transit_preference(struct tomoyo_acl_param *param,\n\t\t\t\t\t   struct tomoyo_condition *e)\n{\n\tchar * const pos = param->data;\n\tbool flag;\n\tif (*pos == '<') {\n\t\te->transit = tomoyo_get_domainname(param);\n\t\tgoto done;\n\t}\n\t{\n\t\tchar *cp = strchr(pos, ' ');\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\t\tflag = tomoyo_correct_path(pos) || !strcmp(pos, \"keep\") ||\n\t\t\t!strcmp(pos, \"initialize\") || !strcmp(pos, \"reset\") ||\n\t\t\t!strcmp(pos, \"child\") || !strcmp(pos, \"parent\");\n\t\tif (cp)\n\t\t\t*cp = ' ';\n\t}\n\tif (!flag)\n\t\treturn pos;\n\te->transit = tomoyo_get_name(tomoyo_read_token(param));\ndone:\n\tif (e->transit)\n\t\treturn param->data;\n\t/*\n\t * Return a bad read-only condition string that will let\n\t * tomoyo_get_condition() return NULL.\n\t */\n\treturn \"/\";\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_get_name",
          "args": [
            "tomoyo_read_token(param)"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "148-183",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_token",
          "args": [
            "param"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "131-141",
          "snippet": "char *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nchar *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pos",
            "\"parent\""
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pos",
            "\"child\""
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pos",
            "\"reset\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pos",
            "\"initialize\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pos",
            "\"keep\""
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_correct_path",
          "args": [
            "pos"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_correct_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "515-518",
          "snippet": "bool tomoyo_correct_path(const char *filename)\n{\n\treturn *filename == '/' && tomoyo_correct_word(filename);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_correct_path(const char *filename)\n{\n\treturn *filename == '/' && tomoyo_correct_word(filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "pos",
            "' '"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_domainname",
          "args": [
            "param"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_domainname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "150-166",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_domainname\n(struct tomoyo_acl_param *param)\n{\n\tchar *start = param->data;\n\tchar *pos = start;\n\twhile (*pos) {\n\t\tif (*pos++ != ' ' || *pos++ == '/')\n\t\t\tcontinue;\n\t\tpos -= 2;\n\t\t*pos++ = '\\0';\n\t\tbreak;\n\t}\n\tparam->data = pos;\n\tif (tomoyo_correct_domain(start))\n\t\treturn tomoyo_get_name(start);\n\treturn NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nconst struct tomoyo_path_info *tomoyo_get_domainname\n(struct tomoyo_acl_param *param)\n{\n\tchar *start = param->data;\n\tchar *pos = start;\n\twhile (*pos) {\n\t\tif (*pos++ != ' ' || *pos++ == '/')\n\t\t\tcontinue;\n\t\tpos -= 2;\n\t\t*pos++ = '\\0';\n\t\tbreak;\n\t}\n\tparam->data = pos;\n\tif (tomoyo_correct_domain(start))\n\t\treturn tomoyo_get_name(start);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic char *tomoyo_get_transit_preference(struct tomoyo_acl_param *param,\n\t\t\t\t\t   struct tomoyo_condition *e)\n{\n\tchar * const pos = param->data;\n\tbool flag;\n\tif (*pos == '<') {\n\t\te->transit = tomoyo_get_domainname(param);\n\t\tgoto done;\n\t}\n\t{\n\t\tchar *cp = strchr(pos, ' ');\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\t\tflag = tomoyo_correct_path(pos) || !strcmp(pos, \"keep\") ||\n\t\t\t!strcmp(pos, \"initialize\") || !strcmp(pos, \"reset\") ||\n\t\t\t!strcmp(pos, \"child\") || !strcmp(pos, \"parent\");\n\t\tif (cp)\n\t\t\t*cp = ' ';\n\t}\n\tif (!flag)\n\t\treturn pos;\n\te->transit = tomoyo_get_name(tomoyo_read_token(param));\ndone:\n\tif (e->transit)\n\t\treturn param->data;\n\t/*\n\t * Return a bad read-only condition string that will let\n\t * tomoyo_get_condition() return NULL.\n\t */\n\treturn \"/\";\n}"
  },
  {
    "function_name": "tomoyo_commit_condition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "393-430",
    "snippet": "static struct tomoyo_condition *tomoyo_commit_condition\n(struct tomoyo_condition *entry)\n{\n\tstruct tomoyo_condition *ptr;\n\tbool found = false;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock)) {\n\t\tdprintk(KERN_WARNING \"%u: %s failed\\n\", __LINE__, __func__);\n\t\tptr = NULL;\n\t\tfound = true;\n\t\tgoto out;\n\t}\n\tlist_for_each_entry(ptr, &tomoyo_condition_list, head.list) {\n\t\tif (!tomoyo_same_condition(ptr, entry) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\t/* Same entry found. Share this entry. */\n\t\tatomic_inc(&ptr->head.users);\n\t\tfound = true;\n\t\tbreak;\n\t}\n\tif (!found) {\n\t\tif (tomoyo_memory_ok(entry)) {\n\t\t\tatomic_set(&entry->head.users, 1);\n\t\t\tlist_add(&entry->head.list, &tomoyo_condition_list);\n\t\t} else {\n\t\t\tfound = true;\n\t\t\tptr = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\tif (found) {\n\t\ttomoyo_del_condition(&entry->head.list);\n\t\tkfree(entry);\n\t\tentry = ptr;\n\t}\n\treturn entry;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define dprintk printk"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_del_condition",
          "args": [
            "&entry->head.list"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_condition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "269-299",
          "snippet": "void tomoyo_del_condition(struct list_head *element)\n{\n\tstruct tomoyo_condition *cond = container_of(element, typeof(*cond),\n\t\t\t\t\t\t     head.list);\n\tconst u16 condc = cond->condc;\n\tconst u16 numbers_count = cond->numbers_count;\n\tconst u16 names_count = cond->names_count;\n\tconst u16 argc = cond->argc;\n\tconst u16 envc = cond->envc;\n\tunsigned int i;\n\tconst struct tomoyo_condition_element *condp\n\t\t= (const struct tomoyo_condition_element *) (cond + 1);\n\tstruct tomoyo_number_union *numbers_p\n\t\t= (struct tomoyo_number_union *) (condp + condc);\n\tstruct tomoyo_name_union *names_p\n\t\t= (struct tomoyo_name_union *) (numbers_p + numbers_count);\n\tconst struct tomoyo_argv *argv\n\t\t= (const struct tomoyo_argv *) (names_p + names_count);\n\tconst struct tomoyo_envp *envp\n\t\t= (const struct tomoyo_envp *) (argv + argc);\n\tfor (i = 0; i < numbers_count; i++)\n\t\ttomoyo_put_number_union(numbers_p++);\n\tfor (i = 0; i < names_count; i++)\n\t\ttomoyo_put_name_union(names_p++);\n\tfor (i = 0; i < argc; argv++, i++)\n\t\ttomoyo_put_name(argv->value);\n\tfor (i = 0; i < envc; envp++, i++) {\n\t\ttomoyo_put_name(envp->name);\n\t\ttomoyo_put_name(envp->value);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nvoid tomoyo_del_condition(struct list_head *element)\n{\n\tstruct tomoyo_condition *cond = container_of(element, typeof(*cond),\n\t\t\t\t\t\t     head.list);\n\tconst u16 condc = cond->condc;\n\tconst u16 numbers_count = cond->numbers_count;\n\tconst u16 names_count = cond->names_count;\n\tconst u16 argc = cond->argc;\n\tconst u16 envc = cond->envc;\n\tunsigned int i;\n\tconst struct tomoyo_condition_element *condp\n\t\t= (const struct tomoyo_condition_element *) (cond + 1);\n\tstruct tomoyo_number_union *numbers_p\n\t\t= (struct tomoyo_number_union *) (condp + condc);\n\tstruct tomoyo_name_union *names_p\n\t\t= (struct tomoyo_name_union *) (numbers_p + numbers_count);\n\tconst struct tomoyo_argv *argv\n\t\t= (const struct tomoyo_argv *) (names_p + names_count);\n\tconst struct tomoyo_envp *envp\n\t\t= (const struct tomoyo_envp *) (argv + argc);\n\tfor (i = 0; i < numbers_count; i++)\n\t\ttomoyo_put_number_union(numbers_p++);\n\tfor (i = 0; i < names_count; i++)\n\t\ttomoyo_put_name_union(names_p++);\n\tfor (i = 0; i < argc; argv++, i++)\n\t\ttomoyo_put_name(argv->value);\n\tfor (i = 0; i < envc; envp++, i++) {\n\t\ttomoyo_put_name(envp->name);\n\t\ttomoyo_put_name(envp->value);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&entry->head.list",
            "&tomoyo_condition_list"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&entry->head.users",
            "1"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_memory_ok",
          "args": [
            "entry"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_memory_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "47-60",
          "snippet": "bool tomoyo_memory_ok(void *ptr)\n{\n\tif (ptr) {\n\t\tconst size_t s = ksize(ptr);\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] += s;\n\t\tif (!tomoyo_memory_quota[TOMOYO_MEMORY_POLICY] ||\n\t\t    tomoyo_memory_used[TOMOYO_MEMORY_POLICY] <=\n\t\t    tomoyo_memory_quota[TOMOYO_MEMORY_POLICY])\n\t\t\treturn true;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= s;\n\t}\n\ttomoyo_warn_oom(__func__);\n\treturn false;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];",
            "unsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nunsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];\nunsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];\n\nbool tomoyo_memory_ok(void *ptr)\n{\n\tif (ptr) {\n\t\tconst size_t s = ksize(ptr);\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] += s;\n\t\tif (!tomoyo_memory_quota[TOMOYO_MEMORY_POLICY] ||\n\t\t    tomoyo_memory_used[TOMOYO_MEMORY_POLICY] <=\n\t\t    tomoyo_memory_quota[TOMOYO_MEMORY_POLICY])\n\t\t\treturn true;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= s;\n\t}\n\ttomoyo_warn_oom(__func__);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ptr->head.users"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ptr->head.users"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_same_condition",
          "args": [
            "ptr",
            "entry"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_same_condition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "345-354",
          "snippet": "static inline bool tomoyo_same_condition(const struct tomoyo_condition *a,\n\t\t\t\t\t const struct tomoyo_condition *b)\n{\n\treturn a->size == b->size && a->condc == b->condc &&\n\t\ta->numbers_count == b->numbers_count &&\n\t\ta->names_count == b->names_count &&\n\t\ta->argc == b->argc && a->envc == b->envc &&\n\t\ta->grant_log == b->grant_log && a->transit == b->transit &&\n\t\t!memcmp(a + 1, b + 1, a->size - sizeof(*a));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic inline bool tomoyo_same_condition(const struct tomoyo_condition *a,\n\t\t\t\t\t const struct tomoyo_condition *b)\n{\n\treturn a->size == b->size && a->condc == b->condc &&\n\t\ta->numbers_count == b->numbers_count &&\n\t\ta->names_count == b->names_count &&\n\t\ta->argc == b->argc && a->envc == b->envc &&\n\t\ta->grant_log == b->grant_log && a->transit == b->transit &&\n\t\t!memcmp(a + 1, b + 1, a->size - sizeof(*a));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ptr",
            "&tomoyo_condition_list",
            "head.list"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "KERN_WARNING \"%u: %s failed\\n\"",
            "__LINE__",
            "__func__"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\n#define dprintk printk\n\nstatic struct tomoyo_condition *tomoyo_commit_condition\n(struct tomoyo_condition *entry)\n{\n\tstruct tomoyo_condition *ptr;\n\tbool found = false;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock)) {\n\t\tdprintk(KERN_WARNING \"%u: %s failed\\n\", __LINE__, __func__);\n\t\tptr = NULL;\n\t\tfound = true;\n\t\tgoto out;\n\t}\n\tlist_for_each_entry(ptr, &tomoyo_condition_list, head.list) {\n\t\tif (!tomoyo_same_condition(ptr, entry) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\t/* Same entry found. Share this entry. */\n\t\tatomic_inc(&ptr->head.users);\n\t\tfound = true;\n\t\tbreak;\n\t}\n\tif (!found) {\n\t\tif (tomoyo_memory_ok(entry)) {\n\t\t\tatomic_set(&entry->head.users, 1);\n\t\t\tlist_add(&entry->head.list, &tomoyo_condition_list);\n\t\t} else {\n\t\t\tfound = true;\n\t\t\tptr = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\tif (found) {\n\t\ttomoyo_del_condition(&entry->head.list);\n\t\tkfree(entry);\n\t\tentry = ptr;\n\t}\n\treturn entry;\n}"
  },
  {
    "function_name": "tomoyo_condition_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "364-372",
    "snippet": "static u8 tomoyo_condition_type(const char *word)\n{\n\tu8 i;\n\tfor (i = 0; i < TOMOYO_MAX_CONDITION_KEYWORD; i++) {\n\t\tif (!strcmp(word, tomoyo_condition_keyword[i]))\n\t\t\tbreak;\n\t}\n\treturn i;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "word",
            "tomoyo_condition_keyword[i]"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic u8 tomoyo_condition_type(const char *word)\n{\n\tu8 i;\n\tfor (i = 0; i < TOMOYO_MAX_CONDITION_KEYWORD; i++) {\n\t\tif (!strcmp(word, tomoyo_condition_keyword[i]))\n\t\t\tbreak;\n\t}\n\treturn i;\n}"
  },
  {
    "function_name": "tomoyo_same_condition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "345-354",
    "snippet": "static inline bool tomoyo_same_condition(const struct tomoyo_condition *a,\n\t\t\t\t\t const struct tomoyo_condition *b)\n{\n\treturn a->size == b->size && a->condc == b->condc &&\n\t\ta->numbers_count == b->numbers_count &&\n\t\ta->names_count == b->names_count &&\n\t\ta->argc == b->argc && a->envc == b->envc &&\n\t\ta->grant_log == b->grant_log && a->transit == b->transit &&\n\t\t!memcmp(a + 1, b + 1, a->size - sizeof(*a));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a + 1",
            "b + 1",
            "a->size - sizeof(*a)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic inline bool tomoyo_same_condition(const struct tomoyo_condition *a,\n\t\t\t\t\t const struct tomoyo_condition *b)\n{\n\treturn a->size == b->size && a->condc == b->condc &&\n\t\ta->numbers_count == b->numbers_count &&\n\t\ta->names_count == b->names_count &&\n\t\ta->argc == b->argc && a->envc == b->envc &&\n\t\ta->grant_log == b->grant_log && a->transit == b->transit &&\n\t\t!memcmp(a + 1, b + 1, a->size - sizeof(*a));\n}"
  },
  {
    "function_name": "tomoyo_parse_envp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "307-335",
    "snippet": "static bool tomoyo_parse_envp(char *left, char *right,\n\t\t\t      struct tomoyo_envp *envp)\n{\n\tconst struct tomoyo_path_info *name;\n\tconst struct tomoyo_path_info *value;\n\tchar *cp = left + strlen(left) - 1;\n\tif (*cp-- != ']' || *cp != '\"')\n\t\tgoto out;\n\t*cp = '\\0';\n\tif (!tomoyo_correct_word(left))\n\t\tgoto out;\n\tname = tomoyo_get_name(left);\n\tif (!name)\n\t\tgoto out;\n\tif (!strcmp(right, \"NULL\")) {\n\t\tvalue = NULL;\n\t} else {\n\t\tvalue = tomoyo_get_dqword(right);\n\t\tif (!value) {\n\t\t\ttomoyo_put_name(name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tenvp->name = name;\n\tenvp->value = value;\n\treturn true;\nout:\n\treturn false;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "name"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_get_dqword",
          "args": [
            "right"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_dqword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "250-259",
          "snippet": "static const struct tomoyo_path_info *tomoyo_get_dqword(char *start)\n{\n\tchar *cp = start + strlen(start) - 1;\n\tif (cp == start || *start++ != '\"' || *cp != '\"')\n\t\treturn NULL;\n\t*cp = '\\0';\n\tif (*start && !tomoyo_correct_word(start))\n\t\treturn NULL;\n\treturn tomoyo_get_name(start);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const struct tomoyo_path_info *tomoyo_get_dqword(char *start)\n{\n\tchar *cp = start + strlen(start) - 1;\n\tif (cp == start || *start++ != '\"' || *cp != '\"')\n\t\treturn NULL;\n\t*cp = '\\0';\n\tif (*start && !tomoyo_correct_word(start))\n\t\treturn NULL;\n\treturn tomoyo_get_name(start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "right",
            "\"NULL\""
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_name",
          "args": [
            "left"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "148-183",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_correct_word",
          "args": [
            "left"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_correct_word",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "502-505",
          "snippet": "bool tomoyo_correct_word(const char *string)\n{\n\treturn tomoyo_correct_word2(string, strlen(string));\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_correct_word(const char *string)\n{\n\treturn tomoyo_correct_word2(string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "left"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_parse_envp(char *left, char *right,\n\t\t\t      struct tomoyo_envp *envp)\n{\n\tconst struct tomoyo_path_info *name;\n\tconst struct tomoyo_path_info *value;\n\tchar *cp = left + strlen(left) - 1;\n\tif (*cp-- != ']' || *cp != '\"')\n\t\tgoto out;\n\t*cp = '\\0';\n\tif (!tomoyo_correct_word(left))\n\t\tgoto out;\n\tname = tomoyo_get_name(left);\n\tif (!name)\n\t\tgoto out;\n\tif (!strcmp(right, \"NULL\")) {\n\t\tvalue = NULL;\n\t} else {\n\t\tvalue = tomoyo_get_dqword(right);\n\t\tif (!value) {\n\t\t\ttomoyo_put_name(name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tenvp->name = name;\n\tenvp->value = value;\n\treturn true;\nout:\n\treturn false;\n}"
  },
  {
    "function_name": "tomoyo_parse_argv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "288-296",
    "snippet": "static bool tomoyo_parse_argv(char *left, char *right,\n\t\t\t      struct tomoyo_argv *argv)\n{\n\tif (tomoyo_parse_ulong(&argv->index, &left) !=\n\t    TOMOYO_VALUE_TYPE_DECIMAL || *left++ != ']' || *left)\n\t\treturn false;\n\targv->value = tomoyo_get_dqword(right);\n\treturn argv->value != NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_get_dqword",
          "args": [
            "right"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_dqword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "250-259",
          "snippet": "static const struct tomoyo_path_info *tomoyo_get_dqword(char *start)\n{\n\tchar *cp = start + strlen(start) - 1;\n\tif (cp == start || *start++ != '\"' || *cp != '\"')\n\t\treturn NULL;\n\t*cp = '\\0';\n\tif (*start && !tomoyo_correct_word(start))\n\t\treturn NULL;\n\treturn tomoyo_get_name(start);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const struct tomoyo_path_info *tomoyo_get_dqword(char *start)\n{\n\tchar *cp = start + strlen(start) - 1;\n\tif (cp == start || *start++ != '\"' || *cp != '\"')\n\t\treturn NULL;\n\t*cp = '\\0';\n\tif (*start && !tomoyo_correct_word(start))\n\t\treturn NULL;\n\treturn tomoyo_get_name(start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_parse_ulong",
          "args": [
            "&argv->index",
            "&left"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_parse_ulong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "179-206",
          "snippet": "u8 tomoyo_parse_ulong(unsigned long *result, char **str)\n{\n\tconst char *cp = *str;\n\tchar *ep;\n\tint base = 10;\n\tif (*cp == '0') {\n\t\tchar c = *(cp + 1);\n\t\tif (c == 'x' || c == 'X') {\n\t\t\tbase = 16;\n\t\t\tcp += 2;\n\t\t} else if (c >= '0' && c <= '7') {\n\t\t\tbase = 8;\n\t\t\tcp++;\n\t\t}\n\t}\n\t*result = simple_strtoul(cp, &ep, base);\n\tif (cp == ep)\n\t\treturn TOMOYO_VALUE_TYPE_INVALID;\n\t*str = ep;\n\tswitch (base) {\n\tcase 16:\n\t\treturn TOMOYO_VALUE_TYPE_HEXADECIMAL;\n\tcase 8:\n\t\treturn TOMOYO_VALUE_TYPE_OCTAL;\n\tdefault:\n\t\treturn TOMOYO_VALUE_TYPE_DECIMAL;\n\t}\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nu8 tomoyo_parse_ulong(unsigned long *result, char **str)\n{\n\tconst char *cp = *str;\n\tchar *ep;\n\tint base = 10;\n\tif (*cp == '0') {\n\t\tchar c = *(cp + 1);\n\t\tif (c == 'x' || c == 'X') {\n\t\t\tbase = 16;\n\t\t\tcp += 2;\n\t\t} else if (c >= '0' && c <= '7') {\n\t\t\tbase = 8;\n\t\t\tcp++;\n\t\t}\n\t}\n\t*result = simple_strtoul(cp, &ep, base);\n\tif (cp == ep)\n\t\treturn TOMOYO_VALUE_TYPE_INVALID;\n\t*str = ep;\n\tswitch (base) {\n\tcase 16:\n\t\treturn TOMOYO_VALUE_TYPE_HEXADECIMAL;\n\tcase 8:\n\t\treturn TOMOYO_VALUE_TYPE_OCTAL;\n\tdefault:\n\t\treturn TOMOYO_VALUE_TYPE_DECIMAL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_parse_argv(char *left, char *right,\n\t\t\t      struct tomoyo_argv *argv)\n{\n\tif (tomoyo_parse_ulong(&argv->index, &left) !=\n\t    TOMOYO_VALUE_TYPE_DECIMAL || *left++ != ']' || *left)\n\t\treturn false;\n\targv->value = tomoyo_get_dqword(right);\n\treturn argv->value != NULL;\n}"
  },
  {
    "function_name": "tomoyo_parse_name_union_quoted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "269-277",
    "snippet": "static bool tomoyo_parse_name_union_quoted(struct tomoyo_acl_param *param,\n\t\t\t\t\t   struct tomoyo_name_union *ptr)\n{\n\tchar *filename = param->data;\n\tif (*filename == '@')\n\t\treturn tomoyo_parse_name_union(param, ptr);\n\tptr->filename = tomoyo_get_dqword(filename);\n\treturn ptr->filename != NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_get_dqword",
          "args": [
            "filename"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_dqword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "250-259",
          "snippet": "static const struct tomoyo_path_info *tomoyo_get_dqword(char *start)\n{\n\tchar *cp = start + strlen(start) - 1;\n\tif (cp == start || *start++ != '\"' || *cp != '\"')\n\t\treturn NULL;\n\t*cp = '\\0';\n\tif (*start && !tomoyo_correct_word(start))\n\t\treturn NULL;\n\treturn tomoyo_get_name(start);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const struct tomoyo_path_info *tomoyo_get_dqword(char *start)\n{\n\tchar *cp = start + strlen(start) - 1;\n\tif (cp == start || *start++ != '\"' || *cp != '\"')\n\t\treturn NULL;\n\t*cp = '\\0';\n\tif (*start && !tomoyo_correct_word(start))\n\t\treturn NULL;\n\treturn tomoyo_get_name(start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_parse_name_union",
          "args": [
            "param",
            "ptr"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_parse_name_union_quoted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "269-277",
          "snippet": "static bool tomoyo_parse_name_union_quoted(struct tomoyo_acl_param *param,\n\t\t\t\t\t   struct tomoyo_name_union *ptr)\n{\n\tchar *filename = param->data;\n\tif (*filename == '@')\n\t\treturn tomoyo_parse_name_union(param, ptr);\n\tptr->filename = tomoyo_get_dqword(filename);\n\treturn ptr->filename != NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_parse_name_union_quoted(struct tomoyo_acl_param *param,\n\t\t\t\t\t   struct tomoyo_name_union *ptr)\n{\n\tchar *filename = param->data;\n\tif (*filename == '@')\n\t\treturn tomoyo_parse_name_union(param, ptr);\n\tptr->filename = tomoyo_get_dqword(filename);\n\treturn ptr->filename != NULL;\n}"
  },
  {
    "function_name": "tomoyo_get_dqword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "250-259",
    "snippet": "static const struct tomoyo_path_info *tomoyo_get_dqword(char *start)\n{\n\tchar *cp = start + strlen(start) - 1;\n\tif (cp == start || *start++ != '\"' || *cp != '\"')\n\t\treturn NULL;\n\t*cp = '\\0';\n\tif (*start && !tomoyo_correct_word(start))\n\t\treturn NULL;\n\treturn tomoyo_get_name(start);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_get_name",
          "args": [
            "start"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "148-183",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_correct_word",
          "args": [
            "start"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_correct_word",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "502-505",
          "snippet": "bool tomoyo_correct_word(const char *string)\n{\n\treturn tomoyo_correct_word2(string, strlen(string));\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_correct_word(const char *string)\n{\n\treturn tomoyo_correct_word2(string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "start"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const struct tomoyo_path_info *tomoyo_get_dqword(char *start)\n{\n\tchar *cp = start + strlen(start) - 1;\n\tif (cp == start || *start++ != '\"' || *cp != '\"')\n\t\treturn NULL;\n\t*cp = '\\0';\n\tif (*start && !tomoyo_correct_word(start))\n\t\treturn NULL;\n\treturn tomoyo_get_name(start);\n}"
  },
  {
    "function_name": "tomoyo_scan_exec_realpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "226-241",
    "snippet": "static bool tomoyo_scan_exec_realpath(struct file *file,\n\t\t\t\t      const struct tomoyo_name_union *ptr,\n\t\t\t\t      const bool match)\n{\n\tbool result;\n\tstruct tomoyo_path_info exe;\n\tif (!file)\n\t\treturn false;\n\texe.name = tomoyo_realpath_from_path(&file->f_path);\n\tif (!exe.name)\n\t\treturn false;\n\ttomoyo_fill_path_info(&exe);\n\tresult = tomoyo_compare_name_union(&exe, ptr);\n\tkfree(exe.name);\n\treturn result == match;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "exe.name"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_compare_name_union",
          "args": [
            "&exe",
            "ptr"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_compare_name_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "81-90",
          "snippet": "const struct tomoyo_path_info *\ntomoyo_compare_name_union(const struct tomoyo_path_info *name,\n\t\t\t  const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_path_matches_group(name, ptr->group);\n\tif (tomoyo_path_matches_pattern(name, ptr->filename))\n\t\treturn ptr->filename;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst struct tomoyo_path_info *\ntomoyo_compare_name_union(const struct tomoyo_path_info *name,\n\t\t\t  const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_path_matches_group(name, ptr->group);\n\tif (tomoyo_path_matches_pattern(name, ptr->filename))\n\t\treturn ptr->filename;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_fill_path_info",
          "args": [
            "&exe"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_fill_path_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "643-652",
          "snippet": "void tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_realpath_from_path",
          "args": [
            "&file->f_path"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_realpath_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "251-311",
          "snippet": "char *tomoyo_realpath_from_path(const struct path *path)\n{\n\tchar *buf = NULL;\n\tchar *name = NULL;\n\tunsigned int buf_len = PAGE_SIZE / 2;\n\tstruct dentry *dentry = path->dentry;\n\tstruct super_block *sb;\n\tif (!dentry)\n\t\treturn NULL;\n\tsb = dentry->d_sb;\n\twhile (1) {\n\t\tchar *pos;\n\t\tstruct inode *inode;\n\t\tbuf_len <<= 1;\n\t\tkfree(buf);\n\t\tbuf = kmalloc(buf_len, GFP_NOFS);\n\t\tif (!buf)\n\t\t\tbreak;\n\t\t/* To make sure that pos is '\\0' terminated. */\n\t\tbuf[buf_len - 1] = '\\0';\n\t\t/* Get better name for socket. */\n\t\tif (sb->s_magic == SOCKFS_MAGIC) {\n\t\t\tpos = tomoyo_get_socket_name(path, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\t/* For \"pipe:[\\$]\". */\n\t\tif (dentry->d_op && dentry->d_op->d_dname) {\n\t\t\tpos = dentry->d_op->d_dname(dentry, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\tinode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Get local name for filesystems without rename() operation\n\t\t * or dentry without vfsmount.\n\t\t */\n\t\tif (!path->mnt ||\n\t\t    (!inode->i_op->rename))\n\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t    buf_len - 1);\n\t\t/* Get absolute name for the rest. */\n\t\telse {\n\t\t\tpos = tomoyo_get_absolute_path(path, buf, buf_len - 1);\n\t\t\t/*\n\t\t\t * Fall back to local name if absolute name is not\n\t\t\t * available.\n\t\t\t */\n\t\t\tif (pos == ERR_PTR(-EINVAL))\n\t\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t\t    buf_len - 1);\n\t\t}\nencode:\n\t\tif (IS_ERR(pos))\n\t\t\tcontinue;\n\t\tname = tomoyo_encode(pos);\n\t\tbreak;\n\t}\n\tkfree(buf);\n\tif (!name)\n\t\ttomoyo_warn_oom(__func__);\n\treturn name;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nchar *tomoyo_realpath_from_path(const struct path *path)\n{\n\tchar *buf = NULL;\n\tchar *name = NULL;\n\tunsigned int buf_len = PAGE_SIZE / 2;\n\tstruct dentry *dentry = path->dentry;\n\tstruct super_block *sb;\n\tif (!dentry)\n\t\treturn NULL;\n\tsb = dentry->d_sb;\n\twhile (1) {\n\t\tchar *pos;\n\t\tstruct inode *inode;\n\t\tbuf_len <<= 1;\n\t\tkfree(buf);\n\t\tbuf = kmalloc(buf_len, GFP_NOFS);\n\t\tif (!buf)\n\t\t\tbreak;\n\t\t/* To make sure that pos is '\\0' terminated. */\n\t\tbuf[buf_len - 1] = '\\0';\n\t\t/* Get better name for socket. */\n\t\tif (sb->s_magic == SOCKFS_MAGIC) {\n\t\t\tpos = tomoyo_get_socket_name(path, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\t/* For \"pipe:[\\$]\". */\n\t\tif (dentry->d_op && dentry->d_op->d_dname) {\n\t\t\tpos = dentry->d_op->d_dname(dentry, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\tinode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Get local name for filesystems without rename() operation\n\t\t * or dentry without vfsmount.\n\t\t */\n\t\tif (!path->mnt ||\n\t\t    (!inode->i_op->rename))\n\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t    buf_len - 1);\n\t\t/* Get absolute name for the rest. */\n\t\telse {\n\t\t\tpos = tomoyo_get_absolute_path(path, buf, buf_len - 1);\n\t\t\t/*\n\t\t\t * Fall back to local name if absolute name is not\n\t\t\t * available.\n\t\t\t */\n\t\t\tif (pos == ERR_PTR(-EINVAL))\n\t\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t\t    buf_len - 1);\n\t\t}\nencode:\n\t\tif (IS_ERR(pos))\n\t\t\tcontinue;\n\t\tname = tomoyo_encode(pos);\n\t\tbreak;\n\t}\n\tkfree(buf);\n\tif (!name)\n\t\ttomoyo_warn_oom(__func__);\n\treturn name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_scan_exec_realpath(struct file *file,\n\t\t\t\t      const struct tomoyo_name_union *ptr,\n\t\t\t\t      const bool match)\n{\n\tbool result;\n\tstruct tomoyo_path_info exe;\n\tif (!file)\n\t\treturn false;\n\texe.name = tomoyo_realpath_from_path(&file->f_path);\n\tif (!exe.name)\n\t\treturn false;\n\ttomoyo_fill_path_info(&exe);\n\tresult = tomoyo_compare_name_union(&exe, ptr);\n\tkfree(exe.name);\n\treturn result == match;\n}"
  },
  {
    "function_name": "tomoyo_scan_bprm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "101-215",
    "snippet": "static bool tomoyo_scan_bprm(struct tomoyo_execve *ee,\n\t\t\t     const u16 argc, const struct tomoyo_argv *argv,\n\t\t\t     const u16 envc, const struct tomoyo_envp *envp)\n{\n\tstruct linux_binprm *bprm = ee->bprm;\n\tstruct tomoyo_page_dump *dump = &ee->dump;\n\tchar *arg_ptr = ee->tmp;\n\tint arg_len = 0;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tbool result = true;\n\tu8 local_checked[32];\n\tu8 *checked;\n\tif (argc + envc <= sizeof(local_checked)) {\n\t\tchecked = local_checked;\n\t\tmemset(local_checked, 0, sizeof(local_checked));\n\t} else {\n\t\tchecked = kzalloc(argc + envc, GFP_NOFS);\n\t\tif (!checked)\n\t\t\treturn false;\n\t}\n\twhile (argv_count || envp_count) {\n\t\tif (!tomoyo_dump_page(bprm, pos, dump)) {\n\t\t\tresult = false;\n\t\t\tgoto out;\n\t\t}\n\t\tpos += PAGE_SIZE - offset;\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\t/* Read. */\n\t\t\tconst char *kaddr = dump->data;\n\t\t\tconst unsigned char c = kaddr[offset++];\n\t\t\tif (c && arg_len < TOMOYO_EXEC_TMPSIZE - 10) {\n\t\t\t\tif (c == '\\\\') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t\targ_ptr[arg_len++] = c;\n\t\t\t\t} else {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = (c >> 6) + '0';\n\t\t\t\t\targ_ptr[arg_len++] =\n\t\t\t\t\t\t((c >> 3) & 7) + '0';\n\t\t\t\t\targ_ptr[arg_len++] = (c & 7) + '0';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targ_ptr[arg_len] = '\\0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\t/* Check. */\n\t\t\tif (argv_count) {\n\t\t\t\tif (!tomoyo_argv(bprm->argc - argv_count,\n\t\t\t\t\t\t arg_ptr, argc, argv,\n\t\t\t\t\t\t checked)) {\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\targv_count--;\n\t\t\t} else if (envp_count) {\n\t\t\t\tchar *cp = strchr(arg_ptr, '=');\n\t\t\t\tif (cp) {\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t\tif (!tomoyo_envp(arg_ptr, cp + 1,\n\t\t\t\t\t\t\t envc, envp,\n\t\t\t\t\t\t\t checked + argc)) {\n\t\t\t\t\t\tresult = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tenvp_count--;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ_len = 0;\n\t\t}\n\t\toffset = 0;\n\t\tif (!result)\n\t\t\tbreak;\n\t}\nout:\n\tif (result) {\n\t\tint i;\n\t\t/* Check not-yet-checked entries. */\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tif (checked[i])\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Return true only if all unchecked indexes in\n\t\t\t * bprm->argv[] are not matched.\n\t\t\t */\n\t\t\tif (argv[i].is_not)\n\t\t\t\tcontinue;\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < envc; envp++, i++) {\n\t\t\tif (checked[argc + i])\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Return true only if all unchecked environ variables\n\t\t\t * in bprm->envp[] are either undefined or not matched.\n\t\t\t */\n\t\t\tif ((!envp->value && !envp->is_not) ||\n\t\t\t    (envp->value && envp->is_not))\n\t\t\t\tcontinue;\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (checked != local_checked)\n\t\tkfree(checked);\n\treturn result;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "checked"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_envp",
          "args": [
            "arg_ptr",
            "cp + 1",
            "envc",
            "envp",
            "checked + argc"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_envp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "58-88",
          "snippet": "static bool tomoyo_envp(const char *env_name, const char *env_value,\n\t\t\tconst int envc, const struct tomoyo_envp *envp,\n\t\t\tu8 *checked)\n{\n\tint i;\n\tstruct tomoyo_path_info name;\n\tstruct tomoyo_path_info value;\n\tname.name = env_name;\n\ttomoyo_fill_path_info(&name);\n\tvalue.name = env_value;\n\ttomoyo_fill_path_info(&value);\n\tfor (i = 0; i < envc; envp++, checked++, i++) {\n\t\tbool result;\n\t\tif (!tomoyo_path_matches_pattern(&name, envp->name))\n\t\t\tcontinue;\n\t\t*checked = 1;\n\t\tif (envp->value) {\n\t\t\tresult = tomoyo_path_matches_pattern(&value,\n\t\t\t\t\t\t\t     envp->value);\n\t\t\tif (envp->is_not)\n\t\t\t\tresult = !result;\n\t\t} else {\n\t\t\tresult = true;\n\t\t\tif (!envp->is_not)\n\t\t\t\tresult = !result;\n\t\t}\n\t\tif (!result)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_envp(const char *env_name, const char *env_value,\n\t\t\tconst int envc, const struct tomoyo_envp *envp,\n\t\t\tu8 *checked)\n{\n\tint i;\n\tstruct tomoyo_path_info name;\n\tstruct tomoyo_path_info value;\n\tname.name = env_name;\n\ttomoyo_fill_path_info(&name);\n\tvalue.name = env_value;\n\ttomoyo_fill_path_info(&value);\n\tfor (i = 0; i < envc; envp++, checked++, i++) {\n\t\tbool result;\n\t\tif (!tomoyo_path_matches_pattern(&name, envp->name))\n\t\t\tcontinue;\n\t\t*checked = 1;\n\t\tif (envp->value) {\n\t\t\tresult = tomoyo_path_matches_pattern(&value,\n\t\t\t\t\t\t\t     envp->value);\n\t\t\tif (envp->is_not)\n\t\t\t\tresult = !result;\n\t\t} else {\n\t\t\tresult = true;\n\t\t\tif (!envp->is_not)\n\t\t\t\tresult = !result;\n\t\t}\n\t\tif (!result)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg_ptr",
            "'='"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_argv",
          "args": [
            "bprm->argc - argv_count",
            "arg_ptr",
            "argc",
            "argv",
            "checked"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_argv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "25-45",
          "snippet": "static bool tomoyo_argv(const unsigned int index, const char *arg_ptr,\n\t\t\tconst int argc, const struct tomoyo_argv *argv,\n\t\t\tu8 *checked)\n{\n\tint i;\n\tstruct tomoyo_path_info arg;\n\targ.name = arg_ptr;\n\tfor (i = 0; i < argc; argv++, checked++, i++) {\n\t\tbool result;\n\t\tif (index != argv->index)\n\t\t\tcontinue;\n\t\t*checked = 1;\n\t\ttomoyo_fill_path_info(&arg);\n\t\tresult = tomoyo_path_matches_pattern(&arg, argv->value);\n\t\tif (argv->is_not)\n\t\t\tresult = !result;\n\t\tif (!result)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_argv(const unsigned int index, const char *arg_ptr,\n\t\t\tconst int argc, const struct tomoyo_argv *argv,\n\t\t\tu8 *checked)\n{\n\tint i;\n\tstruct tomoyo_path_info arg;\n\targ.name = arg_ptr;\n\tfor (i = 0; i < argc; argv++, checked++, i++) {\n\t\tbool result;\n\t\tif (index != argv->index)\n\t\t\tcontinue;\n\t\t*checked = 1;\n\t\ttomoyo_fill_path_info(&arg);\n\t\tresult = tomoyo_path_matches_pattern(&arg, argv->value);\n\t\tif (argv->is_not)\n\t\t\tresult = !result;\n\t\tif (!result)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_dump_page",
          "args": [
            "bprm",
            "pos",
            "dump"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_dump_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "867-911",
          "snippet": "bool tomoyo_dump_page(struct linux_binprm *bprm, unsigned long pos,\n\t\t      struct tomoyo_page_dump *dump)\n{\n\tstruct page *page;\n\n\t/* dump->data is released by tomoyo_find_next_domain(). */\n\tif (!dump->data) {\n\t\tdump->data = kzalloc(PAGE_SIZE, GFP_NOFS);\n\t\tif (!dump->data)\n\t\t\treturn false;\n\t}\n\t/* Same with get_arg_page(bprm, pos, 0) in fs/exec.c */\n#ifdef CONFIG_MMU\n\t/*\n\t * This is called at execve() time in order to dig around\n\t * in the argv/environment of the new proceess\n\t * (represented by bprm).  'current' is the process doing\n\t * the execve().\n\t */\n\tif (get_user_pages_remote(current, bprm->mm, pos, 1,\n\t\t\t\tFOLL_FORCE, &page, NULL, NULL) <= 0)\n\t\treturn false;\n#else\n\tpage = bprm->page[pos / PAGE_SIZE];\n#endif\n\tif (page != dump->page) {\n\t\tconst unsigned int offset = pos % PAGE_SIZE;\n\t\t/*\n\t\t * Maybe kmap()/kunmap() should be used here.\n\t\t * But remove_arg_zero() uses kmap_atomic()/kunmap_atomic().\n\t\t * So do I.\n\t\t */\n\t\tchar *kaddr = kmap_atomic(page);\n\n\t\tdump->page = page;\n\t\tmemcpy(dump->data + offset, kaddr + offset,\n\t\t       PAGE_SIZE - offset);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Same with put_arg_page(page) in fs/exec.c */\n#ifdef CONFIG_MMU\n\tput_page(page);\n#endif\n\treturn true;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nbool tomoyo_dump_page(struct linux_binprm *bprm, unsigned long pos,\n\t\t      struct tomoyo_page_dump *dump)\n{\n\tstruct page *page;\n\n\t/* dump->data is released by tomoyo_find_next_domain(). */\n\tif (!dump->data) {\n\t\tdump->data = kzalloc(PAGE_SIZE, GFP_NOFS);\n\t\tif (!dump->data)\n\t\t\treturn false;\n\t}\n\t/* Same with get_arg_page(bprm, pos, 0) in fs/exec.c */\n#ifdef CONFIG_MMU\n\t/*\n\t * This is called at execve() time in order to dig around\n\t * in the argv/environment of the new proceess\n\t * (represented by bprm).  'current' is the process doing\n\t * the execve().\n\t */\n\tif (get_user_pages_remote(current, bprm->mm, pos, 1,\n\t\t\t\tFOLL_FORCE, &page, NULL, NULL) <= 0)\n\t\treturn false;\n#else\n\tpage = bprm->page[pos / PAGE_SIZE];\n#endif\n\tif (page != dump->page) {\n\t\tconst unsigned int offset = pos % PAGE_SIZE;\n\t\t/*\n\t\t * Maybe kmap()/kunmap() should be used here.\n\t\t * But remove_arg_zero() uses kmap_atomic()/kunmap_atomic().\n\t\t * So do I.\n\t\t */\n\t\tchar *kaddr = kmap_atomic(page);\n\n\t\tdump->page = page;\n\t\tmemcpy(dump->data + offset, kaddr + offset,\n\t\t       PAGE_SIZE - offset);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Same with put_arg_page(page) in fs/exec.c */\n#ifdef CONFIG_MMU\n\tput_page(page);\n#endif\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "argc + envc",
            "GFP_NOFS"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "local_checked",
            "0",
            "sizeof(local_checked)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_scan_bprm(struct tomoyo_execve *ee,\n\t\t\t     const u16 argc, const struct tomoyo_argv *argv,\n\t\t\t     const u16 envc, const struct tomoyo_envp *envp)\n{\n\tstruct linux_binprm *bprm = ee->bprm;\n\tstruct tomoyo_page_dump *dump = &ee->dump;\n\tchar *arg_ptr = ee->tmp;\n\tint arg_len = 0;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tbool result = true;\n\tu8 local_checked[32];\n\tu8 *checked;\n\tif (argc + envc <= sizeof(local_checked)) {\n\t\tchecked = local_checked;\n\t\tmemset(local_checked, 0, sizeof(local_checked));\n\t} else {\n\t\tchecked = kzalloc(argc + envc, GFP_NOFS);\n\t\tif (!checked)\n\t\t\treturn false;\n\t}\n\twhile (argv_count || envp_count) {\n\t\tif (!tomoyo_dump_page(bprm, pos, dump)) {\n\t\t\tresult = false;\n\t\t\tgoto out;\n\t\t}\n\t\tpos += PAGE_SIZE - offset;\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\t/* Read. */\n\t\t\tconst char *kaddr = dump->data;\n\t\t\tconst unsigned char c = kaddr[offset++];\n\t\t\tif (c && arg_len < TOMOYO_EXEC_TMPSIZE - 10) {\n\t\t\t\tif (c == '\\\\') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t\targ_ptr[arg_len++] = c;\n\t\t\t\t} else {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = (c >> 6) + '0';\n\t\t\t\t\targ_ptr[arg_len++] =\n\t\t\t\t\t\t((c >> 3) & 7) + '0';\n\t\t\t\t\targ_ptr[arg_len++] = (c & 7) + '0';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targ_ptr[arg_len] = '\\0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\t/* Check. */\n\t\t\tif (argv_count) {\n\t\t\t\tif (!tomoyo_argv(bprm->argc - argv_count,\n\t\t\t\t\t\t arg_ptr, argc, argv,\n\t\t\t\t\t\t checked)) {\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\targv_count--;\n\t\t\t} else if (envp_count) {\n\t\t\t\tchar *cp = strchr(arg_ptr, '=');\n\t\t\t\tif (cp) {\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t\tif (!tomoyo_envp(arg_ptr, cp + 1,\n\t\t\t\t\t\t\t envc, envp,\n\t\t\t\t\t\t\t checked + argc)) {\n\t\t\t\t\t\tresult = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tenvp_count--;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ_len = 0;\n\t\t}\n\t\toffset = 0;\n\t\tif (!result)\n\t\t\tbreak;\n\t}\nout:\n\tif (result) {\n\t\tint i;\n\t\t/* Check not-yet-checked entries. */\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tif (checked[i])\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Return true only if all unchecked indexes in\n\t\t\t * bprm->argv[] are not matched.\n\t\t\t */\n\t\t\tif (argv[i].is_not)\n\t\t\t\tcontinue;\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < envc; envp++, i++) {\n\t\t\tif (checked[argc + i])\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Return true only if all unchecked environ variables\n\t\t\t * in bprm->envp[] are either undefined or not matched.\n\t\t\t */\n\t\t\tif ((!envp->value && !envp->is_not) ||\n\t\t\t    (envp->value && envp->is_not))\n\t\t\t\tcontinue;\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (checked != local_checked)\n\t\tkfree(checked);\n\treturn result;\n}"
  },
  {
    "function_name": "tomoyo_envp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "58-88",
    "snippet": "static bool tomoyo_envp(const char *env_name, const char *env_value,\n\t\t\tconst int envc, const struct tomoyo_envp *envp,\n\t\t\tu8 *checked)\n{\n\tint i;\n\tstruct tomoyo_path_info name;\n\tstruct tomoyo_path_info value;\n\tname.name = env_name;\n\ttomoyo_fill_path_info(&name);\n\tvalue.name = env_value;\n\ttomoyo_fill_path_info(&value);\n\tfor (i = 0; i < envc; envp++, checked++, i++) {\n\t\tbool result;\n\t\tif (!tomoyo_path_matches_pattern(&name, envp->name))\n\t\t\tcontinue;\n\t\t*checked = 1;\n\t\tif (envp->value) {\n\t\t\tresult = tomoyo_path_matches_pattern(&value,\n\t\t\t\t\t\t\t     envp->value);\n\t\t\tif (envp->is_not)\n\t\t\t\tresult = !result;\n\t\t} else {\n\t\t\tresult = true;\n\t\t\tif (!envp->is_not)\n\t\t\t\tresult = !result;\n\t\t}\n\t\tif (!result)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_matches_pattern",
          "args": [
            "&value",
            "envp->value"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_matches_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "902-921",
          "snippet": "bool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,\n\t\t\t\t const struct tomoyo_path_info *pattern)\n{\n\tconst char *f = filename->name;\n\tconst char *p = pattern->name;\n\tconst int len = pattern->const_len;\n\n\t/* If @pattern doesn't contain pattern, I can use strcmp(). */\n\tif (!pattern->is_patterned)\n\t\treturn !tomoyo_pathcmp(filename, pattern);\n\t/* Don't compare directory and non-directory. */\n\tif (filename->is_dir != pattern->is_dir)\n\t\treturn false;\n\t/* Compare the initial length without patterns. */\n\tif (strncmp(f, p, len))\n\t\treturn false;\n\tf += len;\n\tp += len;\n\treturn tomoyo_path_matches_pattern2(f, p);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,\n\t\t\t\t const struct tomoyo_path_info *pattern)\n{\n\tconst char *f = filename->name;\n\tconst char *p = pattern->name;\n\tconst int len = pattern->const_len;\n\n\t/* If @pattern doesn't contain pattern, I can use strcmp(). */\n\tif (!pattern->is_patterned)\n\t\treturn !tomoyo_pathcmp(filename, pattern);\n\t/* Don't compare directory and non-directory. */\n\tif (filename->is_dir != pattern->is_dir)\n\t\treturn false;\n\t/* Compare the initial length without patterns. */\n\tif (strncmp(f, p, len))\n\t\treturn false;\n\tf += len;\n\tp += len;\n\treturn tomoyo_path_matches_pattern2(f, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_fill_path_info",
          "args": [
            "&value"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_fill_path_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "643-652",
          "snippet": "void tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_envp(const char *env_name, const char *env_value,\n\t\t\tconst int envc, const struct tomoyo_envp *envp,\n\t\t\tu8 *checked)\n{\n\tint i;\n\tstruct tomoyo_path_info name;\n\tstruct tomoyo_path_info value;\n\tname.name = env_name;\n\ttomoyo_fill_path_info(&name);\n\tvalue.name = env_value;\n\ttomoyo_fill_path_info(&value);\n\tfor (i = 0; i < envc; envp++, checked++, i++) {\n\t\tbool result;\n\t\tif (!tomoyo_path_matches_pattern(&name, envp->name))\n\t\t\tcontinue;\n\t\t*checked = 1;\n\t\tif (envp->value) {\n\t\t\tresult = tomoyo_path_matches_pattern(&value,\n\t\t\t\t\t\t\t     envp->value);\n\t\t\tif (envp->is_not)\n\t\t\t\tresult = !result;\n\t\t} else {\n\t\t\tresult = true;\n\t\t\tif (!envp->is_not)\n\t\t\t\tresult = !result;\n\t\t}\n\t\tif (!result)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "tomoyo_argv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
    "lines": "25-45",
    "snippet": "static bool tomoyo_argv(const unsigned int index, const char *arg_ptr,\n\t\t\tconst int argc, const struct tomoyo_argv *argv,\n\t\t\tu8 *checked)\n{\n\tint i;\n\tstruct tomoyo_path_info arg;\n\targ.name = arg_ptr;\n\tfor (i = 0; i < argc; argv++, checked++, i++) {\n\t\tbool result;\n\t\tif (index != argv->index)\n\t\t\tcontinue;\n\t\t*checked = 1;\n\t\ttomoyo_fill_path_info(&arg);\n\t\tresult = tomoyo_path_matches_pattern(&arg, argv->value);\n\t\tif (argv->is_not)\n\t\t\tresult = !result;\n\t\tif (!result)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_matches_pattern",
          "args": [
            "&arg",
            "argv->value"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_matches_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "902-921",
          "snippet": "bool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,\n\t\t\t\t const struct tomoyo_path_info *pattern)\n{\n\tconst char *f = filename->name;\n\tconst char *p = pattern->name;\n\tconst int len = pattern->const_len;\n\n\t/* If @pattern doesn't contain pattern, I can use strcmp(). */\n\tif (!pattern->is_patterned)\n\t\treturn !tomoyo_pathcmp(filename, pattern);\n\t/* Don't compare directory and non-directory. */\n\tif (filename->is_dir != pattern->is_dir)\n\t\treturn false;\n\t/* Compare the initial length without patterns. */\n\tif (strncmp(f, p, len))\n\t\treturn false;\n\tf += len;\n\tp += len;\n\treturn tomoyo_path_matches_pattern2(f, p);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,\n\t\t\t\t const struct tomoyo_path_info *pattern)\n{\n\tconst char *f = filename->name;\n\tconst char *p = pattern->name;\n\tconst int len = pattern->const_len;\n\n\t/* If @pattern doesn't contain pattern, I can use strcmp(). */\n\tif (!pattern->is_patterned)\n\t\treturn !tomoyo_pathcmp(filename, pattern);\n\t/* Don't compare directory and non-directory. */\n\tif (filename->is_dir != pattern->is_dir)\n\t\treturn false;\n\t/* Compare the initial length without patterns. */\n\tif (strncmp(f, p, len))\n\t\treturn false;\n\tf += len;\n\tp += len;\n\treturn tomoyo_path_matches_pattern2(f, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_fill_path_info",
          "args": [
            "&arg"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_fill_path_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "643-652",
          "snippet": "void tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_argv(const unsigned int index, const char *arg_ptr,\n\t\t\tconst int argc, const struct tomoyo_argv *argv,\n\t\t\tu8 *checked)\n{\n\tint i;\n\tstruct tomoyo_path_info arg;\n\targ.name = arg_ptr;\n\tfor (i = 0; i < argc; argv++, checked++, i++) {\n\t\tbool result;\n\t\tif (index != argv->index)\n\t\t\tcontinue;\n\t\t*checked = 1;\n\t\ttomoyo_fill_path_info(&arg);\n\t\tresult = tomoyo_path_matches_pattern(&arg, argv->value);\n\t\tif (argv->is_not)\n\t\t\tresult = !result;\n\t\tif (!result)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  }
]