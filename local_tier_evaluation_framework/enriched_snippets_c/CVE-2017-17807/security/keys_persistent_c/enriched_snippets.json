[
  {
    "function_name": "keyctl_get_persistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/persistent.c",
    "lines": "131-169",
    "snippet": "long keyctl_get_persistent(uid_t _uid, key_serial_t destid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tkey_ref_t dest_ref;\n\tkuid_t uid;\n\tlong ret;\n\n\t/* -1 indicates the current user */\n\tif (_uid == (uid_t)-1) {\n\t\tuid = current_uid();\n\t} else {\n\t\tuid = make_kuid(ns, _uid);\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\n\t\t/* You can only see your own persistent cache if you're not\n\t\t * sufficiently privileged.\n\t\t */\n\t\tif (!uid_eq(uid, current_uid()) &&\n\t\t    !uid_eq(uid, current_euid()) &&\n\t\t    !ns_capable(ns, CAP_SETUID))\n\t\t\treturn -EPERM;\n\t}\n\n\t/* There must be a destination keyring */\n\tdest_ref = lookup_user_key(destid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(dest_ref))\n\t\treturn PTR_ERR(dest_ref);\n\tif (key_ref_to_ptr(dest_ref)->type != &key_type_keyring) {\n\t\tret = -ENOTDIR;\n\t\tgoto out_put_dest;\n\t}\n\n\tret = key_get_persistent(ns, uid, dest_ref);\n\nout_put_dest:\n\tkey_ref_put(dest_ref);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cred.h>",
      "#include <linux/user_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "dest_ref"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get_persistent",
          "args": [
            "ns",
            "uid",
            "dest_ref"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "key_get_persistent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/persistent.c",
          "lines": "77-125",
          "snippet": "static long key_get_persistent(struct user_namespace *ns, kuid_t uid,\n\t\t\t       key_ref_t dest_ref)\n{\n\tstruct keyring_index_key index_key;\n\tstruct key *persistent;\n\tkey_ref_t reg_ref, persistent_ref;\n\tchar buf[32];\n\tlong ret;\n\n\t/* Look in the register if it exists */\n\tindex_key.type = &key_type_keyring;\n\tindex_key.description = buf;\n\tindex_key.desc_len = sprintf(buf, \"_persistent.%u\", from_kuid(ns, uid));\n\n\tif (ns->persistent_keyring_register) {\n\t\treg_ref = make_key_ref(ns->persistent_keyring_register, true);\n\t\tdown_read(&ns->persistent_keyring_register_sem);\n\t\tpersistent_ref = find_key_to_update(reg_ref, &index_key);\n\t\tup_read(&ns->persistent_keyring_register_sem);\n\n\t\tif (persistent_ref)\n\t\t\tgoto found;\n\t}\n\n\t/* It wasn't in the register, so we'll need to create it.  We might\n\t * also need to create the register.\n\t */\n\tdown_write(&ns->persistent_keyring_register_sem);\n\tpersistent_ref = key_create_persistent(ns, uid, &index_key);\n\tup_write(&ns->persistent_keyring_register_sem);\n\tif (!IS_ERR(persistent_ref))\n\t\tgoto found;\n\n\treturn PTR_ERR(persistent_ref);\n\nfound:\n\tret = key_task_permission(persistent_ref, current_cred(), KEY_NEED_LINK);\n\tif (ret == 0) {\n\t\tpersistent = key_ref_to_ptr(persistent_ref);\n\t\tret = key_link(key_ref_to_ptr(dest_ref), persistent);\n\t\tif (ret == 0) {\n\t\t\tkey_set_timeout(persistent, persistent_keyring_expiry);\n\t\t\tret = persistent->serial;\n\t\t}\n\t}\n\n\tkey_ref_put(persistent_ref);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cred.h>",
            "#include <linux/user_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned persistent_keyring_expiry = 3 * 24 * 3600;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cred.h>\n#include <linux/user_namespace.h>\n\nunsigned persistent_keyring_expiry = 3 * 24 * 3600;\n\nstatic long key_get_persistent(struct user_namespace *ns, kuid_t uid,\n\t\t\t       key_ref_t dest_ref)\n{\n\tstruct keyring_index_key index_key;\n\tstruct key *persistent;\n\tkey_ref_t reg_ref, persistent_ref;\n\tchar buf[32];\n\tlong ret;\n\n\t/* Look in the register if it exists */\n\tindex_key.type = &key_type_keyring;\n\tindex_key.description = buf;\n\tindex_key.desc_len = sprintf(buf, \"_persistent.%u\", from_kuid(ns, uid));\n\n\tif (ns->persistent_keyring_register) {\n\t\treg_ref = make_key_ref(ns->persistent_keyring_register, true);\n\t\tdown_read(&ns->persistent_keyring_register_sem);\n\t\tpersistent_ref = find_key_to_update(reg_ref, &index_key);\n\t\tup_read(&ns->persistent_keyring_register_sem);\n\n\t\tif (persistent_ref)\n\t\t\tgoto found;\n\t}\n\n\t/* It wasn't in the register, so we'll need to create it.  We might\n\t * also need to create the register.\n\t */\n\tdown_write(&ns->persistent_keyring_register_sem);\n\tpersistent_ref = key_create_persistent(ns, uid, &index_key);\n\tup_write(&ns->persistent_keyring_register_sem);\n\tif (!IS_ERR(persistent_ref))\n\t\tgoto found;\n\n\treturn PTR_ERR(persistent_ref);\n\nfound:\n\tret = key_task_permission(persistent_ref, current_cred(), KEY_NEED_LINK);\n\tif (ret == 0) {\n\t\tpersistent = key_ref_to_ptr(persistent_ref);\n\t\tret = key_link(key_ref_to_ptr(dest_ref), persistent);\n\t\tif (ret == 0) {\n\t\t\tkey_set_timeout(persistent, persistent_keyring_expiry);\n\t\t\tret = persistent->serial;\n\t\t}\n\t}\n\n\tkey_ref_put(persistent_ref);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "dest_ref"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dest_ref"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dest_ref"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "destid",
            "KEY_LOOKUP_CREATE",
            "KEY_NEED_WRITE"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "ns",
            "CAP_SETUID"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "uid",
            "current_euid()"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "uid",
            "current_uid()"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "ns",
            "_uid"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cred.h>\n#include <linux/user_namespace.h>\n\nlong keyctl_get_persistent(uid_t _uid, key_serial_t destid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tkey_ref_t dest_ref;\n\tkuid_t uid;\n\tlong ret;\n\n\t/* -1 indicates the current user */\n\tif (_uid == (uid_t)-1) {\n\t\tuid = current_uid();\n\t} else {\n\t\tuid = make_kuid(ns, _uid);\n\t\tif (!uid_valid(uid))\n\t\t\treturn -EINVAL;\n\n\t\t/* You can only see your own persistent cache if you're not\n\t\t * sufficiently privileged.\n\t\t */\n\t\tif (!uid_eq(uid, current_uid()) &&\n\t\t    !uid_eq(uid, current_euid()) &&\n\t\t    !ns_capable(ns, CAP_SETUID))\n\t\t\treturn -EPERM;\n\t}\n\n\t/* There must be a destination keyring */\n\tdest_ref = lookup_user_key(destid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(dest_ref))\n\t\treturn PTR_ERR(dest_ref);\n\tif (key_ref_to_ptr(dest_ref)->type != &key_type_keyring) {\n\t\tret = -ENOTDIR;\n\t\tgoto out_put_dest;\n\t}\n\n\tret = key_get_persistent(ns, uid, dest_ref);\n\nout_put_dest:\n\tkey_ref_put(dest_ref);\n\treturn ret;\n}"
  },
  {
    "function_name": "key_get_persistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/persistent.c",
    "lines": "77-125",
    "snippet": "static long key_get_persistent(struct user_namespace *ns, kuid_t uid,\n\t\t\t       key_ref_t dest_ref)\n{\n\tstruct keyring_index_key index_key;\n\tstruct key *persistent;\n\tkey_ref_t reg_ref, persistent_ref;\n\tchar buf[32];\n\tlong ret;\n\n\t/* Look in the register if it exists */\n\tindex_key.type = &key_type_keyring;\n\tindex_key.description = buf;\n\tindex_key.desc_len = sprintf(buf, \"_persistent.%u\", from_kuid(ns, uid));\n\n\tif (ns->persistent_keyring_register) {\n\t\treg_ref = make_key_ref(ns->persistent_keyring_register, true);\n\t\tdown_read(&ns->persistent_keyring_register_sem);\n\t\tpersistent_ref = find_key_to_update(reg_ref, &index_key);\n\t\tup_read(&ns->persistent_keyring_register_sem);\n\n\t\tif (persistent_ref)\n\t\t\tgoto found;\n\t}\n\n\t/* It wasn't in the register, so we'll need to create it.  We might\n\t * also need to create the register.\n\t */\n\tdown_write(&ns->persistent_keyring_register_sem);\n\tpersistent_ref = key_create_persistent(ns, uid, &index_key);\n\tup_write(&ns->persistent_keyring_register_sem);\n\tif (!IS_ERR(persistent_ref))\n\t\tgoto found;\n\n\treturn PTR_ERR(persistent_ref);\n\nfound:\n\tret = key_task_permission(persistent_ref, current_cred(), KEY_NEED_LINK);\n\tif (ret == 0) {\n\t\tpersistent = key_ref_to_ptr(persistent_ref);\n\t\tret = key_link(key_ref_to_ptr(dest_ref), persistent);\n\t\tif (ret == 0) {\n\t\t\tkey_set_timeout(persistent, persistent_keyring_expiry);\n\t\t\tret = persistent->serial;\n\t\t}\n\t}\n\n\tkey_ref_put(persistent_ref);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cred.h>",
      "#include <linux/user_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned persistent_keyring_expiry = 3 * 24 * 3600;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "persistent_ref"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_set_timeout",
          "args": [
            "persistent",
            "persistent_keyring_expiry"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "key_set_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "709-723",
          "snippet": "void key_set_timeout(struct key *key, unsigned timeout)\n{\n\ttime64_t expiry = 0;\n\n\t/* make the changes with the locks held to prevent races */\n\tdown_write(&key->sem);\n\n\tif (timeout > 0)\n\t\texpiry = ktime_get_real_seconds() + timeout;\n\n\tkey->expiry = expiry;\n\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\tup_write(&key->sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_set_timeout(struct key *key, unsigned timeout)\n{\n\ttime64_t expiry = 0;\n\n\t/* make the changes with the locks held to prevent races */\n\tdown_write(&key->sem);\n\n\tif (timeout > 0)\n\t\texpiry = ktime_get_real_seconds() + timeout;\n\n\tkey->expiry = expiry;\n\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\tup_write(&key->sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_link",
          "args": [
            "key_ref_to_ptr(dest_ref)",
            "persistent"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "key_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "1363-1386",
          "snippet": "int key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\t\tret = __key_link_check_restriction(keyring, key);\n\t\tif (ret == 0)\n\t\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, refcount_read(&keyring->usage));\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nint key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\t\tret = __key_link_check_restriction(keyring, key);\n\t\tif (ret == 0)\n\t\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, refcount_read(&keyring->usage));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "dest_ref"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "persistent_ref"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_task_permission",
          "args": [
            "persistent_ref",
            "current_cred()",
            "KEY_NEED_LINK"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "key_task_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/permission.c",
          "lines": "30-78",
          "snippet": "int key_task_permission(const key_ref_t key_ref, const struct cred *cred,\n\t\t\tunsigned perm)\n{\n\tstruct key *key;\n\tkey_perm_t kperm;\n\tint ret;\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* use the second 8-bits of permissions for keys the caller owns */\n\tif (uid_eq(key->uid, cred->fsuid)) {\n\t\tkperm = key->perm >> 16;\n\t\tgoto use_these_perms;\n\t}\n\n\t/* use the third 8-bits of permissions for keys the caller has a group\n\t * membership in common with */\n\tif (gid_valid(key->gid) && key->perm & KEY_GRP_ALL) {\n\t\tif (gid_eq(key->gid, cred->fsgid)) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\n\t\tret = groups_search(cred->group_info, key->gid);\n\t\tif (ret) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\t}\n\n\t/* otherwise use the least-significant 8-bits */\n\tkperm = key->perm;\n\nuse_these_perms:\n\n\t/* use the top 8-bits of permissions for keys the caller possesses\n\t * - possessor permissions are additive with other permissions\n\t */\n\tif (is_key_possessed(key_ref))\n\t\tkperm |= key->perm >> 24;\n\n\tkperm = kperm & perm & KEY_NEED_ALL;\n\n\tif (kperm != perm)\n\t\treturn -EACCES;\n\n\t/* let LSM be the final arbiter */\n\treturn security_key_permission(key_ref, cred, perm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/security.h>\n#include <linux/module.h>\n\nint key_task_permission(const key_ref_t key_ref, const struct cred *cred,\n\t\t\tunsigned perm)\n{\n\tstruct key *key;\n\tkey_perm_t kperm;\n\tint ret;\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* use the second 8-bits of permissions for keys the caller owns */\n\tif (uid_eq(key->uid, cred->fsuid)) {\n\t\tkperm = key->perm >> 16;\n\t\tgoto use_these_perms;\n\t}\n\n\t/* use the third 8-bits of permissions for keys the caller has a group\n\t * membership in common with */\n\tif (gid_valid(key->gid) && key->perm & KEY_GRP_ALL) {\n\t\tif (gid_eq(key->gid, cred->fsgid)) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\n\t\tret = groups_search(cred->group_info, key->gid);\n\t\tif (ret) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\t}\n\n\t/* otherwise use the least-significant 8-bits */\n\tkperm = key->perm;\n\nuse_these_perms:\n\n\t/* use the top 8-bits of permissions for keys the caller possesses\n\t * - possessor permissions are additive with other permissions\n\t */\n\tif (is_key_possessed(key_ref))\n\t\tkperm |= key->perm >> 24;\n\n\tkperm = kperm & perm & KEY_NEED_ALL;\n\n\tif (kperm != perm)\n\t\treturn -EACCES;\n\n\t/* let LSM be the final arbiter */\n\treturn security_key_permission(key_ref, cred, perm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "persistent_ref"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "persistent_ref"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ns->persistent_keyring_register_sem"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_create_persistent",
          "args": [
            "ns",
            "uid",
            "&index_key"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "key_create_persistent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/persistent.c",
          "lines": "44-71",
          "snippet": "static key_ref_t key_create_persistent(struct user_namespace *ns, kuid_t uid,\n\t\t\t\t       struct keyring_index_key *index_key)\n{\n\tstruct key *persistent;\n\tkey_ref_t reg_ref, persistent_ref;\n\n\tif (!ns->persistent_keyring_register) {\n\t\tlong err = key_create_persistent_register(ns);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t} else {\n\t\treg_ref = make_key_ref(ns->persistent_keyring_register, true);\n\t\tpersistent_ref = find_key_to_update(reg_ref, index_key);\n\t\tif (persistent_ref)\n\t\t\treturn persistent_ref;\n\t}\n\n\tpersistent = keyring_alloc(index_key->description,\n\t\t\t\t   uid, INVALID_GID, current_cred(),\n\t\t\t\t   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA, NULL,\n\t\t\t\t   ns->persistent_keyring_register);\n\tif (IS_ERR(persistent))\n\t\treturn ERR_CAST(persistent);\n\n\treturn make_key_ref(persistent, true);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cred.h>",
            "#include <linux/user_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cred.h>\n#include <linux/user_namespace.h>\n\nstatic key_ref_t key_create_persistent(struct user_namespace *ns, kuid_t uid,\n\t\t\t\t       struct keyring_index_key *index_key)\n{\n\tstruct key *persistent;\n\tkey_ref_t reg_ref, persistent_ref;\n\n\tif (!ns->persistent_keyring_register) {\n\t\tlong err = key_create_persistent_register(ns);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t} else {\n\t\treg_ref = make_key_ref(ns->persistent_keyring_register, true);\n\t\tpersistent_ref = find_key_to_update(reg_ref, index_key);\n\t\tif (persistent_ref)\n\t\t\treturn persistent_ref;\n\t}\n\n\tpersistent = keyring_alloc(index_key->description,\n\t\t\t\t   uid, INVALID_GID, current_cred(),\n\t\t\t\t   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA, NULL,\n\t\t\t\t   ns->persistent_keyring_register);\n\tif (IS_ERR(persistent))\n\t\treturn ERR_CAST(persistent);\n\n\treturn make_key_ref(persistent, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ns->persistent_keyring_register_sem"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ns->persistent_keyring_register_sem"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_key_to_update",
          "args": [
            "reg_ref",
            "&index_key"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "find_key_to_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "1066-1096",
          "snippet": "key_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t     const struct keyring_index_key *index_key)\n{\n\tstruct key *keyring, *key;\n\tconst void *object;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  index_key);\n\n\tif (object)\n\t\tgoto found;\n\n\tkleave(\" = NULL\");\n\treturn NULL;\n\nfound:\n\tkey = keyring_ptr_to_key(object);\n\tif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t  (1 << KEY_FLAG_REVOKED))) {\n\t\tkleave(\" = NULL [x]\");\n\t\treturn NULL;\n\t}\n\t__key_get(key);\n\tkleave(\" = {%d}\", key->serial);\n\treturn make_key_ref(key, is_key_possessed(keyring_ref));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);",
            "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nkey_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t     const struct keyring_index_key *index_key)\n{\n\tstruct key *keyring, *key;\n\tconst void *object;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  index_key);\n\n\tif (object)\n\t\tgoto found;\n\n\tkleave(\" = NULL\");\n\treturn NULL;\n\nfound:\n\tkey = keyring_ptr_to_key(object);\n\tif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t  (1 << KEY_FLAG_REVOKED))) {\n\t\tkleave(\" = NULL [x]\");\n\t\treturn NULL;\n\t}\n\t__key_get(key);\n\tkleave(\" = {%d}\", key->serial);\n\treturn make_key_ref(key, is_key_possessed(keyring_ref));\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ns->persistent_keyring_register_sem"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_key_ref",
          "args": [
            "ns->persistent_keyring_register",
            "true"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"_persistent.%u\"",
            "from_kuid(ns, uid)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "ns",
            "uid"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cred.h>\n#include <linux/user_namespace.h>\n\nunsigned persistent_keyring_expiry = 3 * 24 * 3600;\n\nstatic long key_get_persistent(struct user_namespace *ns, kuid_t uid,\n\t\t\t       key_ref_t dest_ref)\n{\n\tstruct keyring_index_key index_key;\n\tstruct key *persistent;\n\tkey_ref_t reg_ref, persistent_ref;\n\tchar buf[32];\n\tlong ret;\n\n\t/* Look in the register if it exists */\n\tindex_key.type = &key_type_keyring;\n\tindex_key.description = buf;\n\tindex_key.desc_len = sprintf(buf, \"_persistent.%u\", from_kuid(ns, uid));\n\n\tif (ns->persistent_keyring_register) {\n\t\treg_ref = make_key_ref(ns->persistent_keyring_register, true);\n\t\tdown_read(&ns->persistent_keyring_register_sem);\n\t\tpersistent_ref = find_key_to_update(reg_ref, &index_key);\n\t\tup_read(&ns->persistent_keyring_register_sem);\n\n\t\tif (persistent_ref)\n\t\t\tgoto found;\n\t}\n\n\t/* It wasn't in the register, so we'll need to create it.  We might\n\t * also need to create the register.\n\t */\n\tdown_write(&ns->persistent_keyring_register_sem);\n\tpersistent_ref = key_create_persistent(ns, uid, &index_key);\n\tup_write(&ns->persistent_keyring_register_sem);\n\tif (!IS_ERR(persistent_ref))\n\t\tgoto found;\n\n\treturn PTR_ERR(persistent_ref);\n\nfound:\n\tret = key_task_permission(persistent_ref, current_cred(), KEY_NEED_LINK);\n\tif (ret == 0) {\n\t\tpersistent = key_ref_to_ptr(persistent_ref);\n\t\tret = key_link(key_ref_to_ptr(dest_ref), persistent);\n\t\tif (ret == 0) {\n\t\t\tkey_set_timeout(persistent, persistent_keyring_expiry);\n\t\t\tret = persistent->serial;\n\t\t}\n\t}\n\n\tkey_ref_put(persistent_ref);\n\treturn ret;\n}"
  },
  {
    "function_name": "key_create_persistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/persistent.c",
    "lines": "44-71",
    "snippet": "static key_ref_t key_create_persistent(struct user_namespace *ns, kuid_t uid,\n\t\t\t\t       struct keyring_index_key *index_key)\n{\n\tstruct key *persistent;\n\tkey_ref_t reg_ref, persistent_ref;\n\n\tif (!ns->persistent_keyring_register) {\n\t\tlong err = key_create_persistent_register(ns);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t} else {\n\t\treg_ref = make_key_ref(ns->persistent_keyring_register, true);\n\t\tpersistent_ref = find_key_to_update(reg_ref, index_key);\n\t\tif (persistent_ref)\n\t\t\treturn persistent_ref;\n\t}\n\n\tpersistent = keyring_alloc(index_key->description,\n\t\t\t\t   uid, INVALID_GID, current_cred(),\n\t\t\t\t   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA, NULL,\n\t\t\t\t   ns->persistent_keyring_register);\n\tif (IS_ERR(persistent))\n\t\treturn ERR_CAST(persistent);\n\n\treturn make_key_ref(persistent, true);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cred.h>",
      "#include <linux/user_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_key_ref",
          "args": [
            "persistent",
            "true"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "persistent"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "persistent"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_alloc",
          "args": [
            "index_key->description",
            "uid",
            "INVALID_GID",
            "current_cred()",
            "((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ)",
            "KEY_ALLOC_NOT_IN_QUOTA",
            "NULL",
            "ns->persistent_keyring_register"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "494-514",
          "snippet": "struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags,\n\t\t\t  struct key_restriction *restrict_link,\n\t\t\t  struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags, restrict_link);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);",
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nstruct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags,\n\t\t\t  struct key_restriction *restrict_link,\n\t\t\t  struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags, restrict_link);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_key_to_update",
          "args": [
            "reg_ref",
            "index_key"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "find_key_to_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "1066-1096",
          "snippet": "key_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t     const struct keyring_index_key *index_key)\n{\n\tstruct key *keyring, *key;\n\tconst void *object;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  index_key);\n\n\tif (object)\n\t\tgoto found;\n\n\tkleave(\" = NULL\");\n\treturn NULL;\n\nfound:\n\tkey = keyring_ptr_to_key(object);\n\tif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t  (1 << KEY_FLAG_REVOKED))) {\n\t\tkleave(\" = NULL [x]\");\n\t\treturn NULL;\n\t}\n\t__key_get(key);\n\tkleave(\" = {%d}\", key->serial);\n\treturn make_key_ref(key, is_key_possessed(keyring_ref));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);",
            "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nkey_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t     const struct keyring_index_key *index_key)\n{\n\tstruct key *keyring, *key;\n\tconst void *object;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  index_key);\n\n\tif (object)\n\t\tgoto found;\n\n\tkleave(\" = NULL\");\n\treturn NULL;\n\nfound:\n\tkey = keyring_ptr_to_key(object);\n\tif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t  (1 << KEY_FLAG_REVOKED))) {\n\t\tkleave(\" = NULL [x]\");\n\t\treturn NULL;\n\t}\n\t__key_get(key);\n\tkleave(\" = {%d}\", key->serial);\n\treturn make_key_ref(key, is_key_possessed(keyring_ref));\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_key_ref",
          "args": [
            "ns->persistent_keyring_register",
            "true"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_create_persistent_register",
          "args": [
            "ns"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "key_create_persistent_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/persistent.c",
          "lines": "24-37",
          "snippet": "static int key_create_persistent_register(struct user_namespace *ns)\n{\n\tstruct key *reg = keyring_alloc(\".persistent_register\",\n\t\t\t\t\tKUIDT_INIT(0), KGIDT_INIT(0),\n\t\t\t\t\tcurrent_cred(),\n\t\t\t\t\t((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t\t KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tns->persistent_keyring_register = reg;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cred.h>",
            "#include <linux/user_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cred.h>\n#include <linux/user_namespace.h>\n\nstatic int key_create_persistent_register(struct user_namespace *ns)\n{\n\tstruct key *reg = keyring_alloc(\".persistent_register\",\n\t\t\t\t\tKUIDT_INIT(0), KGIDT_INIT(0),\n\t\t\t\t\tcurrent_cred(),\n\t\t\t\t\t((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t\t KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tns->persistent_keyring_register = reg;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cred.h>\n#include <linux/user_namespace.h>\n\nstatic key_ref_t key_create_persistent(struct user_namespace *ns, kuid_t uid,\n\t\t\t\t       struct keyring_index_key *index_key)\n{\n\tstruct key *persistent;\n\tkey_ref_t reg_ref, persistent_ref;\n\n\tif (!ns->persistent_keyring_register) {\n\t\tlong err = key_create_persistent_register(ns);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t} else {\n\t\treg_ref = make_key_ref(ns->persistent_keyring_register, true);\n\t\tpersistent_ref = find_key_to_update(reg_ref, index_key);\n\t\tif (persistent_ref)\n\t\t\treturn persistent_ref;\n\t}\n\n\tpersistent = keyring_alloc(index_key->description,\n\t\t\t\t   uid, INVALID_GID, current_cred(),\n\t\t\t\t   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA, NULL,\n\t\t\t\t   ns->persistent_keyring_register);\n\tif (IS_ERR(persistent))\n\t\treturn ERR_CAST(persistent);\n\n\treturn make_key_ref(persistent, true);\n}"
  },
  {
    "function_name": "key_create_persistent_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/persistent.c",
    "lines": "24-37",
    "snippet": "static int key_create_persistent_register(struct user_namespace *ns)\n{\n\tstruct key *reg = keyring_alloc(\".persistent_register\",\n\t\t\t\t\tKUIDT_INIT(0), KGIDT_INIT(0),\n\t\t\t\t\tcurrent_cred(),\n\t\t\t\t\t((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t\t KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tns->persistent_keyring_register = reg;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cred.h>",
      "#include <linux/user_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "reg"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "reg"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_alloc",
          "args": [
            "\".persistent_register\"",
            "KUIDT_INIT(0)",
            "KGIDT_INIT(0)",
            "current_cred()",
            "((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t\t KEY_USR_VIEW | KEY_USR_READ)",
            "KEY_ALLOC_NOT_IN_QUOTA",
            "NULL",
            "NULL"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "494-514",
          "snippet": "struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags,\n\t\t\t  struct key_restriction *restrict_link,\n\t\t\t  struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags, restrict_link);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);",
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nstruct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags,\n\t\t\t  struct key_restriction *restrict_link,\n\t\t\t  struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags, restrict_link);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KGIDT_INIT",
          "args": [
            "0"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUIDT_INIT",
          "args": [
            "0"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cred.h>\n#include <linux/user_namespace.h>\n\nstatic int key_create_persistent_register(struct user_namespace *ns)\n{\n\tstruct key *reg = keyring_alloc(\".persistent_register\",\n\t\t\t\t\tKUIDT_INIT(0), KGIDT_INIT(0),\n\t\t\t\t\tcurrent_cred(),\n\t\t\t\t\t((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t\t KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tns->persistent_keyring_register = reg;\n\treturn 0;\n}"
  }
]