[
  {
    "function_name": "__aa_labelset_update_subtree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "2108-2122",
    "snippet": "void __aa_labelset_update_subtree(struct aa_ns *ns)\n{\n\tstruct aa_ns *child;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\t__labelset_update(ns);\n\n\tlist_for_each_entry(child, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&child->lock, child->level);\n\t\t__aa_labelset_update_subtree(child);\n\t\tmutex_unlock(&child->lock);\n\t}\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&child->lock"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aa_labelset_update_subtree",
          "args": [
            "child"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_labelset_update_subtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "2108-2122",
          "snippet": "void __aa_labelset_update_subtree(struct aa_ns *ns)\n{\n\tstruct aa_ns *child;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\t__labelset_update(ns);\n\n\tlist_for_each_entry(child, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&child->lock, child->level);\n\t\t__aa_labelset_update_subtree(child);\n\t\tmutex_unlock(&child->lock);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&child->lock",
            "child->level"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&ns->sub_ns",
            "base.list"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__labelset_update",
          "args": [
            "ns"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "__labelset_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "2082-2098",
          "snippet": "static void __labelset_update(struct aa_ns *ns)\n{\n\tstruct aa_label *label;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tdo {\n\t\tlabel = labelset_next_stale(&ns->labels);\n\t\tif (label) {\n\t\t\tstruct aa_label *l = __label_update(label);\n\n\t\t\taa_put_label(l);\n\t\t\taa_put_label(label);\n\t\t}\n\t} while (label);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic void __labelset_update(struct aa_ns *ns)\n{\n\tstruct aa_label *label;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tdo {\n\t\tlabel = labelset_next_stale(&ns->labels);\n\t\tif (label) {\n\t\t\tstruct aa_label *l = __label_update(label);\n\n\t\t\taa_put_label(l);\n\t\t\taa_put_label(label);\n\t\t}\n\t} while (label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!mutex_is_locked(&ns->lock)"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&ns->lock"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ns"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid __aa_labelset_update_subtree(struct aa_ns *ns)\n{\n\tstruct aa_ns *child;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\t__labelset_update(ns);\n\n\tlist_for_each_entry(child, &ns->sub_ns, base.list) {\n\t\tmutex_lock_nested(&child->lock, child->level);\n\t\t__aa_labelset_update_subtree(child);\n\t\tmutex_unlock(&child->lock);\n\t}\n}"
  },
  {
    "function_name": "__labelset_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "2082-2098",
    "snippet": "static void __labelset_update(struct aa_ns *ns)\n{\n\tstruct aa_label *label;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tdo {\n\t\tlabel = labelset_next_stale(&ns->labels);\n\t\tif (label) {\n\t\t\tstruct aa_label *l = __label_update(label);\n\n\t\t\taa_put_label(l);\n\t\t\taa_put_label(label);\n\t\t}\n\t} while (label);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__label_update",
          "args": [
            "label"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "__label_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "2010-2067",
          "snippet": "static struct aa_label *__label_update(struct aa_label *label)\n{\n\tstruct aa_label *new, *tmp;\n\tstruct aa_labelset *ls;\n\tunsigned long flags;\n\tint i, invcount = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!mutex_is_locked(&labels_ns(label)->lock));\n\n\tnew = aa_label_alloc(label->size, label->proxy, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\t/*\n\t * while holding the ns_lock will stop profile replacement, removal,\n\t * and label updates, label merging and removal can be occurring\n\t */\n\tls = labels_set(label);\n\twrite_lock_irqsave(&ls->lock, flags);\n\tfor (i = 0; i < label->size; i++) {\n\t\tAA_BUG(!label->vec[i]);\n\t\tnew->vec[i] = aa_get_newest_profile(label->vec[i]);\n\t\tAA_BUG(!new->vec[i]);\n\t\tAA_BUG(!new->vec[i]->label.proxy);\n\t\tAA_BUG(!new->vec[i]->label.proxy->label);\n\t\tif (new->vec[i]->label.proxy != label->vec[i]->label.proxy)\n\t\t\tinvcount++;\n\t}\n\n\t/* updated stale label by being removed/renamed from labelset */\n\tif (invcount) {\n\t\tnew->size -= aa_vec_unique(&new->vec[0], new->size,\n\t\t\t\t\t   VEC_FLAG_TERMINATE);\n\t\t/* TODO: deal with reference labels */\n\t\tif (new->size == 1) {\n\t\t\ttmp = aa_get_label(&new->vec[0]->label);\n\t\t\tAA_BUG(tmp == label);\n\t\t\tgoto remove;\n\t\t}\n\t\tif (labels_set(label) != labels_set(new)) {\n\t\t\twrite_unlock_irqrestore(&ls->lock, flags);\n\t\t\ttmp = aa_label_insert(labels_set(new), new);\n\t\t\twrite_lock_irqsave(&ls->lock, flags);\n\t\t\tgoto remove;\n\t\t}\n\t} else\n\t\tAA_BUG(labels_ns(label) != labels_ns(new));\n\n\ttmp = __label_insert(labels_set(label), new, true);\nremove:\n\t/* ensure label is removed, and redirected correctly */\n\t__label_remove(label, tmp);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\tlabel_free_or_put_new(tmp, new);\n\n\treturn tmp;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__label_update(struct aa_label *label)\n{\n\tstruct aa_label *new, *tmp;\n\tstruct aa_labelset *ls;\n\tunsigned long flags;\n\tint i, invcount = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!mutex_is_locked(&labels_ns(label)->lock));\n\n\tnew = aa_label_alloc(label->size, label->proxy, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\t/*\n\t * while holding the ns_lock will stop profile replacement, removal,\n\t * and label updates, label merging and removal can be occurring\n\t */\n\tls = labels_set(label);\n\twrite_lock_irqsave(&ls->lock, flags);\n\tfor (i = 0; i < label->size; i++) {\n\t\tAA_BUG(!label->vec[i]);\n\t\tnew->vec[i] = aa_get_newest_profile(label->vec[i]);\n\t\tAA_BUG(!new->vec[i]);\n\t\tAA_BUG(!new->vec[i]->label.proxy);\n\t\tAA_BUG(!new->vec[i]->label.proxy->label);\n\t\tif (new->vec[i]->label.proxy != label->vec[i]->label.proxy)\n\t\t\tinvcount++;\n\t}\n\n\t/* updated stale label by being removed/renamed from labelset */\n\tif (invcount) {\n\t\tnew->size -= aa_vec_unique(&new->vec[0], new->size,\n\t\t\t\t\t   VEC_FLAG_TERMINATE);\n\t\t/* TODO: deal with reference labels */\n\t\tif (new->size == 1) {\n\t\t\ttmp = aa_get_label(&new->vec[0]->label);\n\t\t\tAA_BUG(tmp == label);\n\t\t\tgoto remove;\n\t\t}\n\t\tif (labels_set(label) != labels_set(new)) {\n\t\t\twrite_unlock_irqrestore(&ls->lock, flags);\n\t\t\ttmp = aa_label_insert(labels_set(new), new);\n\t\t\twrite_lock_irqsave(&ls->lock, flags);\n\t\t\tgoto remove;\n\t\t}\n\t} else\n\t\tAA_BUG(labels_ns(label) != labels_ns(new));\n\n\ttmp = __label_insert(labels_set(label), new, true);\nremove:\n\t/* ensure label is removed, and redirected correctly */\n\t__label_remove(label, tmp);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\tlabel_free_or_put_new(tmp, new);\n\n\treturn tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "labelset_next_stale",
          "args": [
            "&ns->labels"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "labelset_next_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1972-1996",
          "snippet": "static struct aa_label *labelset_next_stale(struct aa_labelset *ls)\n{\n\tstruct aa_label *label;\n\tstruct rb_node *node;\n\tunsigned long flags;\n\n\tAA_BUG(!ls);\n\n\tread_lock_irqsave(&ls->lock, flags);\n\n\t__labelset_for_each(ls, node) {\n\t\tlabel = rb_entry(node, struct aa_label, node);\n\t\tif ((label_is_stale(label) ||\n\t\t     vec_is_stale(label->vec, label->size)) &&\n\t\t    __aa_get_label(label))\n\t\t\tgoto out;\n\n\t}\n\tlabel = NULL;\n\nout:\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *labelset_next_stale(struct aa_labelset *ls)\n{\n\tstruct aa_label *label;\n\tstruct rb_node *node;\n\tunsigned long flags;\n\n\tAA_BUG(!ls);\n\n\tread_lock_irqsave(&ls->lock, flags);\n\n\t__labelset_for_each(ls, node) {\n\t\tlabel = rb_entry(node, struct aa_label, node);\n\t\tif ((label_is_stale(label) ||\n\t\t     vec_is_stale(label->vec, label->size)) &&\n\t\t    __aa_get_label(label))\n\t\t\tgoto out;\n\n\t}\n\tlabel = NULL;\n\nout:\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!mutex_is_locked(&ns->lock)"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&ns->lock"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ns"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic void __labelset_update(struct aa_ns *ns)\n{\n\tstruct aa_label *label;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!mutex_is_locked(&ns->lock));\n\n\tdo {\n\t\tlabel = labelset_next_stale(&ns->labels);\n\t\tif (label) {\n\t\t\tstruct aa_label *l = __label_update(label);\n\n\t\t\taa_put_label(l);\n\t\t\taa_put_label(label);\n\t\t}\n\t} while (label);\n}"
  },
  {
    "function_name": "__label_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "2010-2067",
    "snippet": "static struct aa_label *__label_update(struct aa_label *label)\n{\n\tstruct aa_label *new, *tmp;\n\tstruct aa_labelset *ls;\n\tunsigned long flags;\n\tint i, invcount = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!mutex_is_locked(&labels_ns(label)->lock));\n\n\tnew = aa_label_alloc(label->size, label->proxy, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\t/*\n\t * while holding the ns_lock will stop profile replacement, removal,\n\t * and label updates, label merging and removal can be occurring\n\t */\n\tls = labels_set(label);\n\twrite_lock_irqsave(&ls->lock, flags);\n\tfor (i = 0; i < label->size; i++) {\n\t\tAA_BUG(!label->vec[i]);\n\t\tnew->vec[i] = aa_get_newest_profile(label->vec[i]);\n\t\tAA_BUG(!new->vec[i]);\n\t\tAA_BUG(!new->vec[i]->label.proxy);\n\t\tAA_BUG(!new->vec[i]->label.proxy->label);\n\t\tif (new->vec[i]->label.proxy != label->vec[i]->label.proxy)\n\t\t\tinvcount++;\n\t}\n\n\t/* updated stale label by being removed/renamed from labelset */\n\tif (invcount) {\n\t\tnew->size -= aa_vec_unique(&new->vec[0], new->size,\n\t\t\t\t\t   VEC_FLAG_TERMINATE);\n\t\t/* TODO: deal with reference labels */\n\t\tif (new->size == 1) {\n\t\t\ttmp = aa_get_label(&new->vec[0]->label);\n\t\t\tAA_BUG(tmp == label);\n\t\t\tgoto remove;\n\t\t}\n\t\tif (labels_set(label) != labels_set(new)) {\n\t\t\twrite_unlock_irqrestore(&ls->lock, flags);\n\t\t\ttmp = aa_label_insert(labels_set(new), new);\n\t\t\twrite_lock_irqsave(&ls->lock, flags);\n\t\t\tgoto remove;\n\t\t}\n\t} else\n\t\tAA_BUG(labels_ns(label) != labels_ns(new));\n\n\ttmp = __label_insert(labels_set(label), new, true);\nremove:\n\t/* ensure label is removed, and redirected correctly */\n\t__label_remove(label, tmp);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\tlabel_free_or_put_new(tmp, new);\n\n\treturn tmp;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "label_free_or_put_new",
          "args": [
            "tmp",
            "new"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "label_free_or_put_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "396-403",
          "snippet": "static void label_free_or_put_new(struct aa_label *label, struct aa_label *new)\n{\n\tif (label != new)\n\t\t/* need to free directly to break circular ref with proxy */\n\t\taa_label_free(new);\n\telse\n\t\taa_put_label(new);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic void label_free_or_put_new(struct aa_label *label, struct aa_label *new)\n{\n\tif (label != new)\n\t\t/* need to free directly to break circular ref with proxy */\n\t\taa_label_free(new);\n\telse\n\t\taa_put_label(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_remove",
          "args": [
            "label",
            "tmp"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "__label_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "568-589",
          "snippet": "static bool __label_remove(struct aa_label *label, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\n\tif (new)\n\t\t__aa_proxy_redirect(label, new);\n\n\tif (!label_is_stale(label))\n\t\t__label_make_stale(label);\n\n\tif (label->flags & FLAG_IN_TREE) {\n\t\trb_erase(&label->node, &ls->root);\n\t\tlabel->flags &= ~FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic bool __label_remove(struct aa_label *label, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\n\tif (new)\n\t\t__aa_proxy_redirect(label, new);\n\n\tif (!label_is_stale(label))\n\t\t__label_make_stale(label);\n\n\tif (label->flags & FLAG_IN_TREE) {\n\t\trb_erase(&label->node, &ls->root);\n\t\tlabel->flags &= ~FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__label_insert",
          "args": [
            "labels_set(label)",
            "new",
            "true"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "__label_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "640-683",
          "snippet": "static struct aa_label *__label_insert(struct aa_labelset *ls,\n\t\t\t\t       struct aa_label *label, bool replace)\n{\n\tstruct rb_node **new, *parent = NULL;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tAA_BUG(labels_set(label) != ls);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(label->flags & FLAG_IN_TREE);\n\n\t/* Figure out where to put new node */\n\tnew = &ls->root.rb_node;\n\twhile (*new) {\n\t\tstruct aa_label *this = rb_entry(*new, struct aa_label, node);\n\t\tint result = label_cmp(label, this);\n\n\t\tparent = *new;\n\t\tif (result == 0) {\n\t\t\t/* !__aa_get_label means queued for destruction,\n\t\t\t * so replace in place, however the label has\n\t\t\t * died before the replacement so do not share\n\t\t\t * the proxy\n\t\t\t */\n\t\t\tif (!replace && !label_is_stale(this)) {\n\t\t\t\tif (__aa_get_label(this))\n\t\t\t\t\treturn this;\n\t\t\t} else\n\t\t\t\t__proxy_share(this, label);\n\t\t\tAA_BUG(!__label_replace(this, label));\n\t\t\treturn aa_get_label(label);\n\t\t} else if (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse /* (result > 0) */\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&label->node, parent, new);\n\trb_insert_color(&label->node, &ls->root);\n\tlabel->flags |= FLAG_IN_TREE;\n\n\treturn aa_get_label(label);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__label_insert(struct aa_labelset *ls,\n\t\t\t\t       struct aa_label *label, bool replace)\n{\n\tstruct rb_node **new, *parent = NULL;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tAA_BUG(labels_set(label) != ls);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(label->flags & FLAG_IN_TREE);\n\n\t/* Figure out where to put new node */\n\tnew = &ls->root.rb_node;\n\twhile (*new) {\n\t\tstruct aa_label *this = rb_entry(*new, struct aa_label, node);\n\t\tint result = label_cmp(label, this);\n\n\t\tparent = *new;\n\t\tif (result == 0) {\n\t\t\t/* !__aa_get_label means queued for destruction,\n\t\t\t * so replace in place, however the label has\n\t\t\t * died before the replacement so do not share\n\t\t\t * the proxy\n\t\t\t */\n\t\t\tif (!replace && !label_is_stale(this)) {\n\t\t\t\tif (__aa_get_label(this))\n\t\t\t\t\treturn this;\n\t\t\t} else\n\t\t\t\t__proxy_share(this, label);\n\t\t\tAA_BUG(!__label_replace(this, label));\n\t\t\treturn aa_get_label(label);\n\t\t} else if (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse /* (result > 0) */\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&label->node, parent, new);\n\trb_insert_color(&label->node, &ls->root);\n\tlabel->flags |= FLAG_IN_TREE;\n\n\treturn aa_get_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "label"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "labels_ns(label) != labels_ns(new)"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "new"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_insert",
          "args": [
            "labels_set(new)",
            "new"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "903-925",
          "snippet": "struct aa_label *aa_label_insert(struct aa_labelset *ls, struct aa_label *label)\n{\n\tstruct aa_label *l;\n\tunsigned long flags;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\n\t/* check if label exists before taking lock */\n\tif (!label_is_stale(label)) {\n\t\tread_lock_irqsave(&ls->lock, flags);\n\t\tl = __label_find(label);\n\t\tread_unlock_irqrestore(&ls->lock, flags);\n\t\tif (l)\n\t\t\treturn l;\n\t}\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tl = __label_insert(ls, label, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn l;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_insert(struct aa_labelset *ls, struct aa_label *label)\n{\n\tstruct aa_label *l;\n\tunsigned long flags;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\n\t/* check if label exists before taking lock */\n\tif (!label_is_stale(label)) {\n\t\tread_lock_irqsave(&ls->lock, flags);\n\t\tl = __label_find(label);\n\t\tread_unlock_irqrestore(&ls->lock, flags);\n\t\tif (l)\n\t\t\treturn l;\n\t}\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tl = __label_insert(ls, label, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "new"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "new"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "label"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "tmp == label"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "&new->vec[0]->label"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_vec_unique",
          "args": [
            "&new->vec[0]",
            "new->size",
            "VEC_FLAG_TERMINATE"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "aa_vec_unique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "266-313",
          "snippet": "int aa_vec_unique(struct aa_profile **vec, int n, int flags)\n{\n\tint i, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\t/* vecs are usually small and inorder, have a fallback for larger */\n\tif (n > 8) {\n\t\tsort(vec, n, sizeof(struct aa_profile *), sort_cmp, NULL);\n\t\tdups = unique(vec, n);\n\t\tgoto out;\n\t}\n\n\t/* insertion sort + unique in one */\n\tfor (i = 1; i < n; i++) {\n\t\tstruct aa_profile *tmp = vec[i];\n\t\tint pos, j;\n\n\t\tfor (pos = i - 1 - dups; pos >= 0; pos--) {\n\t\t\tint res = profile_cmp(vec[pos], tmp);\n\n\t\t\tif (res == 0) {\n\t\t\t\t/* drop duplicate entry */\n\t\t\t\taa_put_profile(tmp);\n\t\t\t\tdups++;\n\t\t\t\tgoto continue_outer;\n\t\t\t} else if (res < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* pos is at entry < tmp, or index -1. Set to insert pos */\n\t\tpos++;\n\n\t\tfor (j = i - dups; j > pos; j--)\n\t\t\tvec[j] = vec[j - 1];\n\t\tvec[pos] = tmp;\ncontinue_outer:\n\t\t;\n\t}\n\n\tAA_BUG(dups < 0);\n\nout:\n\tif (flags & VEC_FLAG_TERMINATE)\n\t\tvec[n - dups] = NULL;\n\n\treturn dups;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_vec_unique(struct aa_profile **vec, int n, int flags)\n{\n\tint i, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\t/* vecs are usually small and inorder, have a fallback for larger */\n\tif (n > 8) {\n\t\tsort(vec, n, sizeof(struct aa_profile *), sort_cmp, NULL);\n\t\tdups = unique(vec, n);\n\t\tgoto out;\n\t}\n\n\t/* insertion sort + unique in one */\n\tfor (i = 1; i < n; i++) {\n\t\tstruct aa_profile *tmp = vec[i];\n\t\tint pos, j;\n\n\t\tfor (pos = i - 1 - dups; pos >= 0; pos--) {\n\t\t\tint res = profile_cmp(vec[pos], tmp);\n\n\t\t\tif (res == 0) {\n\t\t\t\t/* drop duplicate entry */\n\t\t\t\taa_put_profile(tmp);\n\t\t\t\tdups++;\n\t\t\t\tgoto continue_outer;\n\t\t\t} else if (res < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* pos is at entry < tmp, or index -1. Set to insert pos */\n\t\tpos++;\n\n\t\tfor (j = i - dups; j > pos; j--)\n\t\t\tvec[j] = vec[j - 1];\n\t\tvec[pos] = tmp;\ncontinue_outer:\n\t\t;\n\t}\n\n\tAA_BUG(dups < 0);\n\nout:\n\tif (flags & VEC_FLAG_TERMINATE)\n\t\tvec[n - dups] = NULL;\n\n\treturn dups;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!new->vec[i]->label.proxy->label"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!new->vec[i]->label.proxy"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!new->vec[i]"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_newest_profile",
          "args": [
            "label->vec[i]"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "207-210",
          "snippet": "static inline struct aa_profile *aa_get_newest_profile(struct aa_profile *p)\n{\n\treturn labels_profile(aa_get_newest_label(&p->label));\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline struct aa_profile *aa_get_newest_profile(struct aa_profile *p)\n{\n\treturn labels_profile(aa_get_newest_label(&p->label));\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label->vec[i]"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "label"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_alloc",
          "args": [
            "label->size",
            "label->proxy",
            "GFP_KERNEL"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "431-462",
          "snippet": "struct aa_label *aa_label_alloc(int size, struct aa_proxy *proxy, gfp_t gfp)\n{\n\tstruct aa_label *new;\n\n\tAA_BUG(size < 1);\n\n\t/*  + 1 for null terminator entry on vec */\n\tnew = kzalloc(sizeof(*new) + sizeof(struct aa_profile *) * (size + 1),\n\t\t\tgfp);\n\tAA_DEBUG(\"%s (%p)\\n\", __func__, new);\n\tif (!new)\n\t\tgoto fail;\n\n\tif (!aa_label_init(new, size))\n\t\tgoto fail;\n\n\tif (!proxy) {\n\t\tproxy = aa_alloc_proxy(new, gfp);\n\t\tif (!proxy)\n\t\t\tgoto fail;\n\t} else\n\t\taa_get_proxy(proxy);\n\t/* just set new's proxy, don't redirect proxy here if it was passed in*/\n\tnew->proxy = proxy;\n\n\treturn new;\n\nfail:\n\tkfree(new);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_alloc(int size, struct aa_proxy *proxy, gfp_t gfp)\n{\n\tstruct aa_label *new;\n\n\tAA_BUG(size < 1);\n\n\t/*  + 1 for null terminator entry on vec */\n\tnew = kzalloc(sizeof(*new) + sizeof(struct aa_profile *) * (size + 1),\n\t\t\tgfp);\n\tAA_DEBUG(\"%s (%p)\\n\", __func__, new);\n\tif (!new)\n\t\tgoto fail;\n\n\tif (!aa_label_init(new, size))\n\t\tgoto fail;\n\n\tif (!proxy) {\n\t\tproxy = aa_alloc_proxy(new, gfp);\n\t\tif (!proxy)\n\t\t\tgoto fail;\n\t} else\n\t\taa_get_proxy(proxy);\n\t/* just set new's proxy, don't redirect proxy here if it was passed in*/\n\tnew->proxy = proxy;\n\n\treturn new;\n\nfail:\n\tkfree(new);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!mutex_is_locked(&labels_ns(label)->lock)"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&labels_ns(label)->lock"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__label_update(struct aa_label *label)\n{\n\tstruct aa_label *new, *tmp;\n\tstruct aa_labelset *ls;\n\tunsigned long flags;\n\tint i, invcount = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!mutex_is_locked(&labels_ns(label)->lock));\n\n\tnew = aa_label_alloc(label->size, label->proxy, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\t/*\n\t * while holding the ns_lock will stop profile replacement, removal,\n\t * and label updates, label merging and removal can be occurring\n\t */\n\tls = labels_set(label);\n\twrite_lock_irqsave(&ls->lock, flags);\n\tfor (i = 0; i < label->size; i++) {\n\t\tAA_BUG(!label->vec[i]);\n\t\tnew->vec[i] = aa_get_newest_profile(label->vec[i]);\n\t\tAA_BUG(!new->vec[i]);\n\t\tAA_BUG(!new->vec[i]->label.proxy);\n\t\tAA_BUG(!new->vec[i]->label.proxy->label);\n\t\tif (new->vec[i]->label.proxy != label->vec[i]->label.proxy)\n\t\t\tinvcount++;\n\t}\n\n\t/* updated stale label by being removed/renamed from labelset */\n\tif (invcount) {\n\t\tnew->size -= aa_vec_unique(&new->vec[0], new->size,\n\t\t\t\t\t   VEC_FLAG_TERMINATE);\n\t\t/* TODO: deal with reference labels */\n\t\tif (new->size == 1) {\n\t\t\ttmp = aa_get_label(&new->vec[0]->label);\n\t\t\tAA_BUG(tmp == label);\n\t\t\tgoto remove;\n\t\t}\n\t\tif (labels_set(label) != labels_set(new)) {\n\t\t\twrite_unlock_irqrestore(&ls->lock, flags);\n\t\t\ttmp = aa_label_insert(labels_set(new), new);\n\t\t\twrite_lock_irqsave(&ls->lock, flags);\n\t\t\tgoto remove;\n\t\t}\n\t} else\n\t\tAA_BUG(labels_ns(label) != labels_ns(new));\n\n\ttmp = __label_insert(labels_set(label), new, true);\nremove:\n\t/* ensure label is removed, and redirected correctly */\n\t__label_remove(label, tmp);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\tlabel_free_or_put_new(tmp, new);\n\n\treturn tmp;\n}"
  },
  {
    "function_name": "labelset_next_stale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1972-1996",
    "snippet": "static struct aa_label *labelset_next_stale(struct aa_labelset *ls)\n{\n\tstruct aa_label *label;\n\tstruct rb_node *node;\n\tunsigned long flags;\n\n\tAA_BUG(!ls);\n\n\tread_lock_irqsave(&ls->lock, flags);\n\n\t__labelset_for_each(ls, node) {\n\t\tlabel = rb_entry(node, struct aa_label, node);\n\t\tif ((label_is_stale(label) ||\n\t\t     vec_is_stale(label->vec, label->size)) &&\n\t\t    __aa_get_label(label))\n\t\t\tgoto out;\n\n\t}\n\tlabel = NULL;\n\nout:\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aa_get_label",
          "args": [
            "label"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_get_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "348-354",
          "snippet": "static inline struct aa_label *__aa_get_label(struct aa_label *l)\n{\n\tif (l && kref_get_unless_zero(&l->count))\n\t\treturn l;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *__aa_get_label(struct aa_label *l)\n{\n\tif (l && kref_get_unless_zero(&l->count))\n\t\treturn l;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vec_is_stale",
          "args": [
            "label->vec",
            "label->size"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "vec_is_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "190-202",
          "snippet": "static bool vec_is_stale(struct aa_profile **vec, int n)\n{\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (profile_is_stale(vec[i]))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic bool vec_is_stale(struct aa_profile **vec, int n)\n{\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (profile_is_stale(vec[i]))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_is_stale",
          "args": [
            "label"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structaa_label",
            "node"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__labelset_for_each",
          "args": [
            "ls",
            "node"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ls"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *labelset_next_stale(struct aa_labelset *ls)\n{\n\tstruct aa_label *label;\n\tstruct rb_node *node;\n\tunsigned long flags;\n\n\tAA_BUG(!ls);\n\n\tread_lock_irqsave(&ls->lock, flags);\n\n\t__labelset_for_each(ls, node) {\n\t\tlabel = rb_entry(node, struct aa_label, node);\n\t\tif ((label_is_stale(label) ||\n\t\t     vec_is_stale(label->vec, label->size)) &&\n\t\t    __aa_get_label(label))\n\t\t\tgoto out;\n\n\t}\n\tlabel = NULL;\n\nout:\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}"
  },
  {
    "function_name": "aa_labelset_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1964-1970",
    "snippet": "void aa_labelset_init(struct aa_labelset *ls)\n{\n\tAA_BUG(!ls);\n\n\trwlock_init(&ls->lock);\n\tls->root = RB_ROOT;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&ls->lock"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ls"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_labelset_init(struct aa_labelset *ls)\n{\n\tAA_BUG(!ls);\n\n\trwlock_init(&ls->lock);\n\tls->root = RB_ROOT;\n}"
  },
  {
    "function_name": "aa_labelset_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1941-1959",
    "snippet": "void aa_labelset_destroy(struct aa_labelset *ls)\n{\n\tstruct rb_node *node;\n\tunsigned long flags;\n\n\tAA_BUG(!ls);\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tfor (node = rb_first(&ls->root); node; node = rb_first(&ls->root)) {\n\t\tstruct aa_label *this = rb_entry(node, struct aa_label, node);\n\n\t\tif (labels_ns(this) != root_ns)\n\t\t\t__label_remove(this,\n\t\t\t\t       ns_unconfined(labels_ns(this)->parent));\n\t\telse\n\t\t\t__label_remove(this, NULL);\n\t}\n\twrite_unlock_irqrestore(&ls->lock, flags);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_remove",
          "args": [
            "this",
            "NULL"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "__label_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "568-589",
          "snippet": "static bool __label_remove(struct aa_label *label, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\n\tif (new)\n\t\t__aa_proxy_redirect(label, new);\n\n\tif (!label_is_stale(label))\n\t\t__label_make_stale(label);\n\n\tif (label->flags & FLAG_IN_TREE) {\n\t\trb_erase(&label->node, &ls->root);\n\t\tlabel->flags &= ~FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic bool __label_remove(struct aa_label *label, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\n\tif (new)\n\t\t__aa_proxy_redirect(label, new);\n\n\tif (!label_is_stale(label))\n\t\t__label_make_stale(label);\n\n\tif (label->flags & FLAG_IN_TREE) {\n\t\trb_erase(&label->node, &ls->root);\n\t\tlabel->flags &= ~FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_unconfined",
          "args": [
            "labels_ns(this)->parent"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "this"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "this"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structaa_label",
            "node"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ls->root"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ls->root"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ls"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_labelset_destroy(struct aa_labelset *ls)\n{\n\tstruct rb_node *node;\n\tunsigned long flags;\n\n\tAA_BUG(!ls);\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tfor (node = rb_first(&ls->root); node; node = rb_first(&ls->root)) {\n\t\tstruct aa_label *this = rb_entry(node, struct aa_label, node);\n\n\t\tif (labels_ns(this) != root_ns)\n\t\t\t__label_remove(this,\n\t\t\t\t       ns_unconfined(labels_ns(this)->parent));\n\t\telse\n\t\t\t__label_remove(this, NULL);\n\t}\n\twrite_unlock_irqrestore(&ls->lock, flags);\n}"
  },
  {
    "function_name": "aa_label_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1856-1931",
    "snippet": "struct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack)\n{\n\tDEFINE_VEC(profile, vec);\n\tstruct aa_label *label, *currbase = base;\n\tint i, len, stack = 0, error;\n\tchar *split;\n\n\tAA_BUG(!base);\n\tAA_BUG(!str);\n\n\tstr = skip_spaces(str);\n\tlen = label_count_str_entries(str);\n\tif (*str == '&' || force_stack) {\n\t\t/* stack on top of base */\n\t\tstack = base->size;\n\t\tlen += stack;\n\t\tif (*str == '&')\n\t\t\tstr++;\n\t}\n\tif (*str == '=')\n\t\tbase = &root_ns->unconfined->label;\n\n\terror = vec_setup(profile, vec, len, gfp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tfor (i = 0; i < stack; i++)\n\t\tvec[i] = aa_get_profile(base->vec[i]);\n\n\tfor (split = strstr(str, \"//&\"), i = stack; split && i < len; i++) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, split - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t\t/*\n\t\t * if component specified a new ns it becomes the new base\n\t\t * so that subsequent lookups are relative to it\n\t\t */\n\t\tif (vec[i]->ns != labels_ns(currbase))\n\t\t\tcurrbase = &vec[i]->label;\n\t\tstr = split + 3;\n\t\tsplit = strstr(str, \"//&\");\n\t}\n\t/* last element doesn't have a split */\n\tif (i < len) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, strlen(str));\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t}\n\tif (len == 1)\n\t\t/* no need to free vec as len < LOCAL_VEC_ENTRIES */\n\t\treturn &vec[0]->label;\n\n\tlen -= aa_vec_unique(vec, len, VEC_FLAG_TERMINATE);\n\t/* TODO: deal with reference labels */\n\tif (len == 1) {\n\t\tlabel = aa_get_label(&vec[0]->label);\n\t\tgoto out;\n\t}\n\n\tif (create)\n\t\tlabel = aa_vec_find_or_create_label(vec, len, gfp);\n\telse\n\t\tlabel = vec_find(vec, len);\n\tif (!label)\n\t\tgoto fail;\n\nout:\n\t/* use adjusted len from after vec_unique, not original */\n\tvec_cleanup(profile, vec, len);\n\treturn label;\n\nfail:\n\tlabel = ERR_PTR(-ENOENT);\n\tgoto out;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vec_cleanup",
          "args": [
            "profile",
            "vec",
            "len"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vec_find",
          "args": [
            "vec",
            "len"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "vec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "811-827",
          "snippet": "static struct aa_label *vec_find(struct aa_profile **vec, int n)\n{\n\tstruct aa_labelset *ls;\n\tstruct aa_label *label;\n\tunsigned long flags;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tls = vec_labelset(vec, n);\n\tread_lock_irqsave(&ls->lock, flags);\n\tlabel = __vec_find(vec, n);\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *vec_find(struct aa_profile **vec, int n)\n{\n\tstruct aa_labelset *ls;\n\tstruct aa_label *label;\n\tunsigned long flags;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tls = vec_labelset(vec, n);\n\tread_lock_irqsave(&ls->lock, flags);\n\tlabel = __vec_find(vec, n);\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_vec_find_or_create_label",
          "args": [
            "vec",
            "len",
            "gfp"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "aa_vec_find_or_create_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "864-873",
          "snippet": "struct aa_label *aa_vec_find_or_create_label(struct aa_profile **vec, int len,\n\t\t\t\t\t     gfp_t gfp)\n{\n\tstruct aa_label *label = vec_find(vec, len);\n\n\tif (label)\n\t\treturn label;\n\n\treturn vec_create_and_insert_label(vec, len, gfp);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_vec_find_or_create_label(struct aa_profile **vec, int len,\n\t\t\t\t\t     gfp_t gfp)\n{\n\tstruct aa_label *label = vec_find(vec, len);\n\n\tif (label)\n\t\treturn label;\n\n\treturn vec_create_and_insert_label(vec, len, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "&vec[0]->label"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_vec_unique",
          "args": [
            "vec",
            "len",
            "VEC_FLAG_TERMINATE"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "aa_vec_unique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "266-313",
          "snippet": "int aa_vec_unique(struct aa_profile **vec, int n, int flags)\n{\n\tint i, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\t/* vecs are usually small and inorder, have a fallback for larger */\n\tif (n > 8) {\n\t\tsort(vec, n, sizeof(struct aa_profile *), sort_cmp, NULL);\n\t\tdups = unique(vec, n);\n\t\tgoto out;\n\t}\n\n\t/* insertion sort + unique in one */\n\tfor (i = 1; i < n; i++) {\n\t\tstruct aa_profile *tmp = vec[i];\n\t\tint pos, j;\n\n\t\tfor (pos = i - 1 - dups; pos >= 0; pos--) {\n\t\t\tint res = profile_cmp(vec[pos], tmp);\n\n\t\t\tif (res == 0) {\n\t\t\t\t/* drop duplicate entry */\n\t\t\t\taa_put_profile(tmp);\n\t\t\t\tdups++;\n\t\t\t\tgoto continue_outer;\n\t\t\t} else if (res < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* pos is at entry < tmp, or index -1. Set to insert pos */\n\t\tpos++;\n\n\t\tfor (j = i - dups; j > pos; j--)\n\t\t\tvec[j] = vec[j - 1];\n\t\tvec[pos] = tmp;\ncontinue_outer:\n\t\t;\n\t}\n\n\tAA_BUG(dups < 0);\n\nout:\n\tif (flags & VEC_FLAG_TERMINATE)\n\t\tvec[n - dups] = NULL;\n\n\treturn dups;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_vec_unique(struct aa_profile **vec, int n, int flags)\n{\n\tint i, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\t/* vecs are usually small and inorder, have a fallback for larger */\n\tif (n > 8) {\n\t\tsort(vec, n, sizeof(struct aa_profile *), sort_cmp, NULL);\n\t\tdups = unique(vec, n);\n\t\tgoto out;\n\t}\n\n\t/* insertion sort + unique in one */\n\tfor (i = 1; i < n; i++) {\n\t\tstruct aa_profile *tmp = vec[i];\n\t\tint pos, j;\n\n\t\tfor (pos = i - 1 - dups; pos >= 0; pos--) {\n\t\t\tint res = profile_cmp(vec[pos], tmp);\n\n\t\t\tif (res == 0) {\n\t\t\t\t/* drop duplicate entry */\n\t\t\t\taa_put_profile(tmp);\n\t\t\t\tdups++;\n\t\t\t\tgoto continue_outer;\n\t\t\t} else if (res < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* pos is at entry < tmp, or index -1. Set to insert pos */\n\t\tpos++;\n\n\t\tfor (j = i - dups; j > pos; j--)\n\t\t\tvec[j] = vec[j - 1];\n\t\tvec[pos] = tmp;\ncontinue_outer:\n\t\t;\n\t}\n\n\tAA_BUG(dups < 0);\n\nout:\n\tif (flags & VEC_FLAG_TERMINATE)\n\t\tvec[n - dups] = NULL;\n\n\treturn dups;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fqlookupn_profile",
          "args": [
            "base",
            "currbase",
            "str",
            "strlen(str)"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "fqlookupn_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1833-1843",
          "snippet": "static struct aa_profile *fqlookupn_profile(struct aa_label *base,\n\t\t\t\t\t    struct aa_label *currentbase,\n\t\t\t\t\t    const char *str, size_t n)\n{\n\tconst char *first = skipn_spaces(str, n);\n\n\tif (first && *first == ':')\n\t\treturn aa_fqlookupn_profile(base, str, n);\n\n\treturn aa_fqlookupn_profile(currentbase, str, n);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_profile *fqlookupn_profile(struct aa_label *base,\n\t\t\t\t\t    struct aa_label *currentbase,\n\t\t\t\t\t    const char *str, size_t n)\n{\n\tconst char *first = skipn_spaces(str, n);\n\n\tif (first && *first == ':')\n\t\treturn aa_fqlookupn_profile(base, str, n);\n\n\treturn aa_fqlookupn_profile(currentbase, str, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"//&\""
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "currbase"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"//&\""
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_profile",
          "args": [
            "base->vec[i]"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_profile_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "260-271",
          "snippet": "static inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vec_setup",
          "args": [
            "profile",
            "vec",
            "len",
            "gfp"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_count_str_entries",
          "args": [
            "str"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "label_count_str_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1811-1824",
          "snippet": "static int label_count_str_entries(const char *str)\n{\n\tconst char *split;\n\tint count = 1;\n\n\tAA_BUG(!str);\n\n\tfor (split = strstr(str, \"//&\"); split; split = strstr(str, \"//&\")) {\n\t\tcount++;\n\t\tstr = split + 3;\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int label_count_str_entries(const char *str)\n{\n\tconst char *split;\n\tint count = 1;\n\n\tAA_BUG(!str);\n\n\tfor (split = strstr(str, \"//&\"); split; split = strstr(str, \"//&\")) {\n\t\tcount++;\n\t\tstr = split + 3;\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_spaces",
          "args": [
            "str"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!str"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!base"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_VEC",
          "args": [
            "profile",
            "vec"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_parse(struct aa_label *base, const char *str,\n\t\t\t\tgfp_t gfp, bool create, bool force_stack)\n{\n\tDEFINE_VEC(profile, vec);\n\tstruct aa_label *label, *currbase = base;\n\tint i, len, stack = 0, error;\n\tchar *split;\n\n\tAA_BUG(!base);\n\tAA_BUG(!str);\n\n\tstr = skip_spaces(str);\n\tlen = label_count_str_entries(str);\n\tif (*str == '&' || force_stack) {\n\t\t/* stack on top of base */\n\t\tstack = base->size;\n\t\tlen += stack;\n\t\tif (*str == '&')\n\t\t\tstr++;\n\t}\n\tif (*str == '=')\n\t\tbase = &root_ns->unconfined->label;\n\n\terror = vec_setup(profile, vec, len, gfp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tfor (i = 0; i < stack; i++)\n\t\tvec[i] = aa_get_profile(base->vec[i]);\n\n\tfor (split = strstr(str, \"//&\"), i = stack; split && i < len; i++) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, split - str);\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t\t/*\n\t\t * if component specified a new ns it becomes the new base\n\t\t * so that subsequent lookups are relative to it\n\t\t */\n\t\tif (vec[i]->ns != labels_ns(currbase))\n\t\t\tcurrbase = &vec[i]->label;\n\t\tstr = split + 3;\n\t\tsplit = strstr(str, \"//&\");\n\t}\n\t/* last element doesn't have a split */\n\tif (i < len) {\n\t\tvec[i] = fqlookupn_profile(base, currbase, str, strlen(str));\n\t\tif (!vec[i])\n\t\t\tgoto fail;\n\t}\n\tif (len == 1)\n\t\t/* no need to free vec as len < LOCAL_VEC_ENTRIES */\n\t\treturn &vec[0]->label;\n\n\tlen -= aa_vec_unique(vec, len, VEC_FLAG_TERMINATE);\n\t/* TODO: deal with reference labels */\n\tif (len == 1) {\n\t\tlabel = aa_get_label(&vec[0]->label);\n\t\tgoto out;\n\t}\n\n\tif (create)\n\t\tlabel = aa_vec_find_or_create_label(vec, len, gfp);\n\telse\n\t\tlabel = vec_find(vec, len);\n\tif (!label)\n\t\tgoto fail;\n\nout:\n\t/* use adjusted len from after vec_unique, not original */\n\tvec_cleanup(profile, vec, len);\n\treturn label;\n\nfail:\n\tlabel = ERR_PTR(-ENOENT);\n\tgoto out;\n}"
  },
  {
    "function_name": "fqlookupn_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1833-1843",
    "snippet": "static struct aa_profile *fqlookupn_profile(struct aa_label *base,\n\t\t\t\t\t    struct aa_label *currentbase,\n\t\t\t\t\t    const char *str, size_t n)\n{\n\tconst char *first = skipn_spaces(str, n);\n\n\tif (first && *first == ':')\n\t\treturn aa_fqlookupn_profile(base, str, n);\n\n\treturn aa_fqlookupn_profile(currentbase, str, n);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_fqlookupn_profile",
          "args": [
            "currentbase",
            "str",
            "n"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "aa_fqlookupn_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "454-480",
          "snippet": "struct aa_profile *aa_fqlookupn_profile(struct aa_label *base,\n\t\t\t\t\tconst char *fqname, size_t n)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ns *ns;\n\tconst char *name, *ns_name;\n\tsize_t ns_len;\n\n\tname = aa_splitn_fqname(fqname, n, &ns_name, &ns_len);\n\tif (ns_name) {\n\t\tns = aa_lookupn_ns(labels_ns(base), ns_name, ns_len);\n\t\tif (!ns)\n\t\t\treturn NULL;\n\t} else\n\t\tns = aa_get_ns(labels_ns(base));\n\n\tif (name)\n\t\tprofile = aa_lookupn_profile(ns, name, n - (name - fqname));\n\telse if (ns)\n\t\t/* default profile for ns, currently unconfined */\n\t\tprofile = aa_get_newest_profile(ns->unconfined);\n\telse\n\t\tprofile = NULL;\n\taa_put_ns(ns);\n\n\treturn profile;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct aa_profile *aa_fqlookupn_profile(struct aa_label *base,\n\t\t\t\t\tconst char *fqname, size_t n)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ns *ns;\n\tconst char *name, *ns_name;\n\tsize_t ns_len;\n\n\tname = aa_splitn_fqname(fqname, n, &ns_name, &ns_len);\n\tif (ns_name) {\n\t\tns = aa_lookupn_ns(labels_ns(base), ns_name, ns_len);\n\t\tif (!ns)\n\t\t\treturn NULL;\n\t} else\n\t\tns = aa_get_ns(labels_ns(base));\n\n\tif (name)\n\t\tprofile = aa_lookupn_profile(ns, name, n - (name - fqname));\n\telse if (ns)\n\t\t/* default profile for ns, currently unconfined */\n\t\tprofile = aa_get_newest_profile(ns->unconfined);\n\telse\n\t\tprofile = NULL;\n\taa_put_ns(ns);\n\n\treturn profile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skipn_spaces",
          "args": [
            "str",
            "n"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "skipn_spaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "78-85",
          "snippet": "const char *skipn_spaces(const char *str, size_t n)\n{\n\tfor (; n && isspace(*str); --n)\n\t\t++str;\n\tif (n)\n\t\treturn (char *)str;\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nconst char *skipn_spaces(const char *str, size_t n)\n{\n\tfor (; n && isspace(*str); --n)\n\t\t++str;\n\tif (n)\n\t\treturn (char *)str;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_profile *fqlookupn_profile(struct aa_label *base,\n\t\t\t\t\t    struct aa_label *currentbase,\n\t\t\t\t\t    const char *str, size_t n)\n{\n\tconst char *first = skipn_spaces(str, n);\n\n\tif (first && *first == ':')\n\t\treturn aa_fqlookupn_profile(base, str, n);\n\n\treturn aa_fqlookupn_profile(currentbase, str, n);\n}"
  },
  {
    "function_name": "label_count_str_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1811-1824",
    "snippet": "static int label_count_str_entries(const char *str)\n{\n\tconst char *split;\n\tint count = 1;\n\n\tAA_BUG(!str);\n\n\tfor (split = strstr(str, \"//&\"); split; split = strstr(str, \"//&\")) {\n\t\tcount++;\n\t\tstr = split + 3;\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"//&\""
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"//&\""
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!str"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int label_count_str_entries(const char *str)\n{\n\tconst char *split;\n\tint count = 1;\n\n\tAA_BUG(!str);\n\n\tfor (split = strstr(str, \"//&\"); split; split = strstr(str, \"//&\")) {\n\t\tcount++;\n\t\tstr = split + 3;\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "aa_label_printk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1803-1809",
    "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "ns"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_xprintk",
          "args": [
            "ns",
            "label",
            "FLAG_VIEW_SUBNS",
            "gfp"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_xprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1764-1785",
          "snippet": "void aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_current_ns",
          "args": [],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_current_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "204-214",
          "snippet": "static inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
  },
  {
    "function_name": "aa_label_seq_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1795-1801",
    "snippet": "void aa_label_seq_print(struct seq_file *f, struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_seq_xprint(f, ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "ns"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_seq_xprint",
          "args": [
            "f",
            "ns",
            "label",
            "FLAG_VIEW_SUBNS",
            "gfp"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_seq_xprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1740-1762",
          "snippet": "void aa_label_seq_xprint(struct seq_file *f, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp)\n{\n\tAA_BUG(!f);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tseq_printf(f, \"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tseq_printf(f, \"%s (%s)\", label->hname,\n\t\t\t   label_modename(ns, label, flags));\n\telse\n\t\tseq_printf(f, \"%s\", label->hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_seq_xprint(struct seq_file *f, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp)\n{\n\tAA_BUG(!f);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tseq_printf(f, \"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tseq_printf(f, \"%s (%s)\", label->hname,\n\t\t\t   label_modename(ns, label, flags));\n\telse\n\t\tseq_printf(f, \"%s\", label->hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_current_ns",
          "args": [],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_current_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "204-214",
          "snippet": "static inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_seq_print(struct seq_file *f, struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_seq_xprint(f, ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
  },
  {
    "function_name": "aa_label_audit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1787-1793",
    "snippet": "void aa_label_audit(struct audit_buffer *ab, struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xaudit(ab, ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "ns"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_xaudit",
          "args": [
            "ab",
            "ns",
            "label",
            "FLAG_VIEW_SUBNS",
            "gfp"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_xaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1710-1738",
          "snippet": "void aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp)\n{\n\tconst char *str;\n\tchar *name = NULL;\n\tint len;\n\n\tAA_BUG(!ab);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags) ||\n\t    display_mode(ns, label, flags)) {\n\t\tlen  = aa_label_asxprint(&name, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tstr = name;\n\t} else {\n\t\tstr = (char *) label->hname;\n\t\tlen = strlen(str);\n\t}\n\tif (audit_string_contains_control(str, len))\n\t\taudit_log_n_hex(ab, str, len);\n\telse\n\t\taudit_log_n_string(ab, str, len);\n\n\tkfree(name);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp)\n{\n\tconst char *str;\n\tchar *name = NULL;\n\tint len;\n\n\tAA_BUG(!ab);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags) ||\n\t    display_mode(ns, label, flags)) {\n\t\tlen  = aa_label_asxprint(&name, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tstr = name;\n\t} else {\n\t\tstr = (char *) label->hname;\n\t\tlen = strlen(str);\n\t}\n\tif (audit_string_contains_control(str, len))\n\t\taudit_log_n_hex(ab, str, len);\n\telse\n\t\taudit_log_n_string(ab, str, len);\n\n\tkfree(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_current_ns",
          "args": [],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_current_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "204-214",
          "snippet": "static inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_audit(struct audit_buffer *ab, struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xaudit(ab, ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
  },
  {
    "function_name": "aa_label_xprintk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1764-1785",
    "snippet": "void aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s\"",
            "label->hname"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s (%s)\"",
            "label->hname",
            "label_modename(ns, label, flags)"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_modename",
          "args": [
            "ns",
            "label",
            "flags"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "label_modename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1528-1558",
          "snippet": "static const char *label_modename(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t  int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct label_it i;\n\tint mode = -1, count = 0;\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (profile->mode == APPARMOR_UNCONFINED)\n\t\t\t\t/* special case unconfined so stacks with\n\t\t\t\t * unconfined don't report as mixed. ie.\n\t\t\t\t * profile_foo//&:ns1:unconfined (mixed)\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\tcount++;\n\t\t\tif (mode == -1)\n\t\t\t\tmode = profile->mode;\n\t\t\telse if (mode != profile->mode)\n\t\t\t\treturn \"mixed\";\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\treturn \"-\";\n\tif (mode == -1)\n\t\t/* everything was unconfined */\n\t\tmode = APPARMOR_UNCONFINED;\n\n\treturn aa_profile_mode_names[mode];\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic const char *label_modename(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t  int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct label_it i;\n\tint mode = -1, count = 0;\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (profile->mode == APPARMOR_UNCONFINED)\n\t\t\t\t/* special case unconfined so stacks with\n\t\t\t\t * unconfined don't report as mixed. ie.\n\t\t\t\t * profile_foo//&:ns1:unconfined (mixed)\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\tcount++;\n\t\t\tif (mode == -1)\n\t\t\t\tmode = profile->mode;\n\t\t\telse if (mode != profile->mode)\n\t\t\t\treturn \"mixed\";\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\treturn \"-\";\n\tif (mode == -1)\n\t\t/* everything was unconfined */\n\t\tmode = APPARMOR_UNCONFINED;\n\n\treturn aa_profile_mode_names[mode];\n}"
        }
      },
      {
        "call_info": {
          "callee": "display_mode",
          "args": [
            "ns",
            "label",
            "flags"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "display_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1561-1579",
          "snippet": "static inline bool display_mode(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\tint flags)\n{\n\tif ((flags & FLAG_SHOW_MODE)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tif (aa_ns_visible(ns, profile->ns,\n\t\t\t\t\t  flags & FLAG_VIEW_SUBNS) &&\n\t\t\t    profile != profile->ns->unconfined)\n\t\t\t\treturn true;\n\t\t}\n\t\t/* only ns->unconfined in set of profiles in ns */\n\t\treturn false;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline bool display_mode(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\tint flags)\n{\n\tif ((flags & FLAG_SHOW_MODE)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tif (aa_ns_visible(ns, profile->ns,\n\t\t\t\t\t  flags & FLAG_VIEW_SUBNS) &&\n\t\t\t    profile != profile->ns->unconfined)\n\t\t\t\treturn true;\n\t\t}\n\t\t/* only ns->unconfined in set of profiles in ns */\n\t\treturn false;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "str"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s\"",
            "str"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_DEBUG",
          "args": [
            "\"label print error\""
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_asxprint",
          "args": [
            "&str",
            "ns",
            "label",
            "flags",
            "gfp"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_asxprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1662-1678",
          "snippet": "int aa_label_asxprint(char **strp, struct aa_ns *ns, struct aa_label *label,\n\t\t      int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = kmalloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_label_asxprint(char **strp, struct aa_ns *ns, struct aa_label *label,\n\t\t      int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = kmalloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "use_label_hname",
          "args": [
            "ns",
            "label",
            "flags"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "use_label_hname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1453-1461",
          "snippet": "static inline bool use_label_hname(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t   int flags)\n{\n\tif (label->hname && (!ns || labels_ns(label) == ns) &&\n\t    !(flags & ~FLAG_SHOW_MODE))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline bool use_label_hname(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t   int flags)\n{\n\tif (label->hname && (!ns || labels_ns(label) == ns) &&\n\t    !(flags & ~FLAG_SHOW_MODE))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}"
  },
  {
    "function_name": "aa_label_seq_xprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1740-1762",
    "snippet": "void aa_label_seq_xprint(struct seq_file *f, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp)\n{\n\tAA_BUG(!f);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tseq_printf(f, \"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tseq_printf(f, \"%s (%s)\", label->hname,\n\t\t\t   label_modename(ns, label, flags));\n\telse\n\t\tseq_printf(f, \"%s\", label->hname);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "f",
            "\"%s\"",
            "label->hname"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "f",
            "\"%s (%s)\"",
            "label->hname",
            "label_modename(ns, label, flags)"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_modename",
          "args": [
            "ns",
            "label",
            "flags"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "label_modename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1528-1558",
          "snippet": "static const char *label_modename(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t  int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct label_it i;\n\tint mode = -1, count = 0;\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (profile->mode == APPARMOR_UNCONFINED)\n\t\t\t\t/* special case unconfined so stacks with\n\t\t\t\t * unconfined don't report as mixed. ie.\n\t\t\t\t * profile_foo//&:ns1:unconfined (mixed)\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\tcount++;\n\t\t\tif (mode == -1)\n\t\t\t\tmode = profile->mode;\n\t\t\telse if (mode != profile->mode)\n\t\t\t\treturn \"mixed\";\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\treturn \"-\";\n\tif (mode == -1)\n\t\t/* everything was unconfined */\n\t\tmode = APPARMOR_UNCONFINED;\n\n\treturn aa_profile_mode_names[mode];\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic const char *label_modename(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t  int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct label_it i;\n\tint mode = -1, count = 0;\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (profile->mode == APPARMOR_UNCONFINED)\n\t\t\t\t/* special case unconfined so stacks with\n\t\t\t\t * unconfined don't report as mixed. ie.\n\t\t\t\t * profile_foo//&:ns1:unconfined (mixed)\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\tcount++;\n\t\t\tif (mode == -1)\n\t\t\t\tmode = profile->mode;\n\t\t\telse if (mode != profile->mode)\n\t\t\t\treturn \"mixed\";\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\treturn \"-\";\n\tif (mode == -1)\n\t\t/* everything was unconfined */\n\t\tmode = APPARMOR_UNCONFINED;\n\n\treturn aa_profile_mode_names[mode];\n}"
        }
      },
      {
        "call_info": {
          "callee": "display_mode",
          "args": [
            "ns",
            "label",
            "flags"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "display_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1561-1579",
          "snippet": "static inline bool display_mode(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\tint flags)\n{\n\tif ((flags & FLAG_SHOW_MODE)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tif (aa_ns_visible(ns, profile->ns,\n\t\t\t\t\t  flags & FLAG_VIEW_SUBNS) &&\n\t\t\t    profile != profile->ns->unconfined)\n\t\t\t\treturn true;\n\t\t}\n\t\t/* only ns->unconfined in set of profiles in ns */\n\t\treturn false;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline bool display_mode(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\tint flags)\n{\n\tif ((flags & FLAG_SHOW_MODE)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tif (aa_ns_visible(ns, profile->ns,\n\t\t\t\t\t  flags & FLAG_VIEW_SUBNS) &&\n\t\t\t    profile != profile->ns->unconfined)\n\t\t\t\treturn true;\n\t\t}\n\t\t/* only ns->unconfined in set of profiles in ns */\n\t\treturn false;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "str"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "f",
            "\"%s\"",
            "str"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_DEBUG",
          "args": [
            "\"label print error\""
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_asxprint",
          "args": [
            "&str",
            "ns",
            "label",
            "flags",
            "gfp"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_asxprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1662-1678",
          "snippet": "int aa_label_asxprint(char **strp, struct aa_ns *ns, struct aa_label *label,\n\t\t      int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = kmalloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_label_asxprint(char **strp, struct aa_ns *ns, struct aa_label *label,\n\t\t      int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = kmalloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "use_label_hname",
          "args": [
            "ns",
            "label",
            "flags"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "use_label_hname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1453-1461",
          "snippet": "static inline bool use_label_hname(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t   int flags)\n{\n\tif (label->hname && (!ns || labels_ns(label) == ns) &&\n\t    !(flags & ~FLAG_SHOW_MODE))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline bool use_label_hname(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t   int flags)\n{\n\tif (label->hname && (!ns || labels_ns(label) == ns) &&\n\t    !(flags & ~FLAG_SHOW_MODE))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!f"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_seq_xprint(struct seq_file *f, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp)\n{\n\tAA_BUG(!f);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tseq_printf(f, \"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tseq_printf(f, \"%s (%s)\", label->hname,\n\t\t\t   label_modename(ns, label, flags));\n\telse\n\t\tseq_printf(f, \"%s\", label->hname);\n}"
  },
  {
    "function_name": "aa_label_xaudit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1710-1738",
    "snippet": "void aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp)\n{\n\tconst char *str;\n\tchar *name = NULL;\n\tint len;\n\n\tAA_BUG(!ab);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags) ||\n\t    display_mode(ns, label, flags)) {\n\t\tlen  = aa_label_asxprint(&name, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tstr = name;\n\t} else {\n\t\tstr = (char *) label->hname;\n\t\tlen = strlen(str);\n\t}\n\tif (audit_string_contains_control(str, len))\n\t\taudit_log_n_hex(ab, str, len);\n\telse\n\t\taudit_log_n_string(ab, str, len);\n\n\tkfree(name);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_n_string",
          "args": [
            "ab",
            "str",
            "len"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_n_hex",
          "args": [
            "ab",
            "str",
            "len"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_string_contains_control",
          "args": [
            "str",
            "len"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_DEBUG",
          "args": [
            "\"label print error\""
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_asxprint",
          "args": [
            "&name",
            "ns",
            "label",
            "flags",
            "gfp"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_asxprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1662-1678",
          "snippet": "int aa_label_asxprint(char **strp, struct aa_ns *ns, struct aa_label *label,\n\t\t      int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = kmalloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_label_asxprint(char **strp, struct aa_ns *ns, struct aa_label *label,\n\t\t      int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = kmalloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "display_mode",
          "args": [
            "ns",
            "label",
            "flags"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "display_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1561-1579",
          "snippet": "static inline bool display_mode(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\tint flags)\n{\n\tif ((flags & FLAG_SHOW_MODE)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tif (aa_ns_visible(ns, profile->ns,\n\t\t\t\t\t  flags & FLAG_VIEW_SUBNS) &&\n\t\t\t    profile != profile->ns->unconfined)\n\t\t\t\treturn true;\n\t\t}\n\t\t/* only ns->unconfined in set of profiles in ns */\n\t\treturn false;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline bool display_mode(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\tint flags)\n{\n\tif ((flags & FLAG_SHOW_MODE)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tif (aa_ns_visible(ns, profile->ns,\n\t\t\t\t\t  flags & FLAG_VIEW_SUBNS) &&\n\t\t\t    profile != profile->ns->unconfined)\n\t\t\t\treturn true;\n\t\t}\n\t\t/* only ns->unconfined in set of profiles in ns */\n\t\treturn false;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "use_label_hname",
          "args": [
            "ns",
            "label",
            "flags"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "use_label_hname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1453-1461",
          "snippet": "static inline bool use_label_hname(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t   int flags)\n{\n\tif (label->hname && (!ns || labels_ns(label) == ns) &&\n\t    !(flags & ~FLAG_SHOW_MODE))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline bool use_label_hname(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t   int flags)\n{\n\tif (label->hname && (!ns || labels_ns(label) == ns) &&\n\t    !(flags & ~FLAG_SHOW_MODE))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ab"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp)\n{\n\tconst char *str;\n\tchar *name = NULL;\n\tint len;\n\n\tAA_BUG(!ab);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags) ||\n\t    display_mode(ns, label, flags)) {\n\t\tlen  = aa_label_asxprint(&name, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tstr = name;\n\t} else {\n\t\tstr = (char *) label->hname;\n\t\tlen = strlen(str);\n\t}\n\tif (audit_string_contains_control(str, len))\n\t\taudit_log_n_hex(ab, str, len);\n\telse\n\t\taudit_log_n_string(ab, str, len);\n\n\tkfree(name);\n}"
  },
  {
    "function_name": "aa_label_acntsxprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1691-1707",
    "snippet": "int aa_label_acntsxprint(char __counted **strp, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = aa_str_alloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_label_snxprint",
          "args": [
            "*strp",
            "size + 1",
            "ns",
            "label",
            "flags"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_snxprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1598-1648",
          "snippet": "int aa_label_snxprint(char *str, size_t size, struct aa_ns *ns,\n\t\t      struct aa_label *label, int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ns *prev_ns = NULL;\n\tstruct label_it i;\n\tint count = 0, total = 0;\n\tsize_t len;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!label);\n\n\tif (flags & FLAG_ABS_ROOT) {\n\t\tns = root_ns;\n\t\tlen = snprintf(str, size, \"=\");\n\t\tupdate_for_len(total, len, size, str);\n\t} else if (!ns) {\n\t\tns = labels_ns(label);\n\t}\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (count > 0) {\n\t\t\t\tlen = snprintf(str, size, \"//&\");\n\t\t\t\tupdate_for_len(total, len, size, str);\n\t\t\t}\n\t\t\tlen = aa_profile_snxprint(str, size, ns, profile,\n\t\t\t\t\t\t  flags & FLAG_VIEW_SUBNS,\n\t\t\t\t\t\t  &prev_ns);\n\t\t\tupdate_for_len(total, len, size, str);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count == 0) {\n\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\treturn snprintf(str, size, \"%s\", aa_hidden_ns_name);\n\t}\n\n\t/* count == 1 && ... is for backwards compat where the mode\n\t * is not displayed for 'unconfined' in the current ns\n\t */\n\tif (display_mode(ns, label, flags)) {\n\t\tlen = snprintf(str, size, \" (%s)\",\n\t\t\t       label_modename(ns, label, flags));\n\t\tupdate_for_len(total, len, size, str);\n\t}\n\n\treturn total;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_label_snxprint(char *str, size_t size, struct aa_ns *ns,\n\t\t      struct aa_label *label, int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ns *prev_ns = NULL;\n\tstruct label_it i;\n\tint count = 0, total = 0;\n\tsize_t len;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!label);\n\n\tif (flags & FLAG_ABS_ROOT) {\n\t\tns = root_ns;\n\t\tlen = snprintf(str, size, \"=\");\n\t\tupdate_for_len(total, len, size, str);\n\t} else if (!ns) {\n\t\tns = labels_ns(label);\n\t}\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (count > 0) {\n\t\t\t\tlen = snprintf(str, size, \"//&\");\n\t\t\t\tupdate_for_len(total, len, size, str);\n\t\t\t}\n\t\t\tlen = aa_profile_snxprint(str, size, ns, profile,\n\t\t\t\t\t\t  flags & FLAG_VIEW_SUBNS,\n\t\t\t\t\t\t  &prev_ns);\n\t\t\tupdate_for_len(total, len, size, str);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count == 0) {\n\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\treturn snprintf(str, size, \"%s\", aa_hidden_ns_name);\n\t}\n\n\t/* count == 1 && ... is for backwards compat where the mode\n\t * is not displayed for 'unconfined' in the current ns\n\t */\n\tif (display_mode(ns, label, flags)) {\n\t\tlen = snprintf(str, size, \" (%s)\",\n\t\t\t       label_modename(ns, label, flags));\n\t\tupdate_for_len(total, len, size, str);\n\t}\n\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_str_alloc",
          "args": [
            "size + 1",
            "gfp"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "aa_str_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "137-147",
          "snippet": "__counted char *aa_str_alloc(int size, gfp_t gfp)\n{\n\tstruct counted_str *str;\n\n\tstr = kmalloc(sizeof(struct counted_str) + size, gfp);\n\tif (!str)\n\t\treturn NULL;\n\n\tkref_init(&str->count);\n\treturn str->name;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\n__counted char *aa_str_alloc(int size, gfp_t gfp)\n{\n\tstruct counted_str *str;\n\n\tstr = kmalloc(sizeof(struct counted_str) + size, gfp);\n\tif (!str)\n\t\treturn NULL;\n\n\tkref_init(&str->count);\n\treturn str->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!strp"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_label_acntsxprint(char __counted **strp, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = aa_str_alloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}"
  },
  {
    "function_name": "aa_label_asxprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1662-1678",
    "snippet": "int aa_label_asxprint(char **strp, struct aa_ns *ns, struct aa_label *label,\n\t\t      int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = kmalloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_label_snxprint",
          "args": [
            "*strp",
            "size + 1",
            "ns",
            "label",
            "flags"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_snxprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1598-1648",
          "snippet": "int aa_label_snxprint(char *str, size_t size, struct aa_ns *ns,\n\t\t      struct aa_label *label, int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ns *prev_ns = NULL;\n\tstruct label_it i;\n\tint count = 0, total = 0;\n\tsize_t len;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!label);\n\n\tif (flags & FLAG_ABS_ROOT) {\n\t\tns = root_ns;\n\t\tlen = snprintf(str, size, \"=\");\n\t\tupdate_for_len(total, len, size, str);\n\t} else if (!ns) {\n\t\tns = labels_ns(label);\n\t}\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (count > 0) {\n\t\t\t\tlen = snprintf(str, size, \"//&\");\n\t\t\t\tupdate_for_len(total, len, size, str);\n\t\t\t}\n\t\t\tlen = aa_profile_snxprint(str, size, ns, profile,\n\t\t\t\t\t\t  flags & FLAG_VIEW_SUBNS,\n\t\t\t\t\t\t  &prev_ns);\n\t\t\tupdate_for_len(total, len, size, str);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count == 0) {\n\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\treturn snprintf(str, size, \"%s\", aa_hidden_ns_name);\n\t}\n\n\t/* count == 1 && ... is for backwards compat where the mode\n\t * is not displayed for 'unconfined' in the current ns\n\t */\n\tif (display_mode(ns, label, flags)) {\n\t\tlen = snprintf(str, size, \" (%s)\",\n\t\t\t       label_modename(ns, label, flags));\n\t\tupdate_for_len(total, len, size, str);\n\t}\n\n\treturn total;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_label_snxprint(char *str, size_t size, struct aa_ns *ns,\n\t\t      struct aa_label *label, int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ns *prev_ns = NULL;\n\tstruct label_it i;\n\tint count = 0, total = 0;\n\tsize_t len;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!label);\n\n\tif (flags & FLAG_ABS_ROOT) {\n\t\tns = root_ns;\n\t\tlen = snprintf(str, size, \"=\");\n\t\tupdate_for_len(total, len, size, str);\n\t} else if (!ns) {\n\t\tns = labels_ns(label);\n\t}\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (count > 0) {\n\t\t\t\tlen = snprintf(str, size, \"//&\");\n\t\t\t\tupdate_for_len(total, len, size, str);\n\t\t\t}\n\t\t\tlen = aa_profile_snxprint(str, size, ns, profile,\n\t\t\t\t\t\t  flags & FLAG_VIEW_SUBNS,\n\t\t\t\t\t\t  &prev_ns);\n\t\t\tupdate_for_len(total, len, size, str);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count == 0) {\n\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\treturn snprintf(str, size, \"%s\", aa_hidden_ns_name);\n\t}\n\n\t/* count == 1 && ... is for backwards compat where the mode\n\t * is not displayed for 'unconfined' in the current ns\n\t */\n\tif (display_mode(ns, label, flags)) {\n\t\tlen = snprintf(str, size, \" (%s)\",\n\t\t\t       label_modename(ns, label, flags));\n\t\tupdate_for_len(total, len, size, str);\n\t}\n\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size + 1",
            "gfp"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!strp"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_label_asxprint(char **strp, struct aa_ns *ns, struct aa_label *label,\n\t\t      int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = kmalloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}"
  },
  {
    "function_name": "aa_label_snxprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1598-1648",
    "snippet": "int aa_label_snxprint(char *str, size_t size, struct aa_ns *ns,\n\t\t      struct aa_label *label, int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ns *prev_ns = NULL;\n\tstruct label_it i;\n\tint count = 0, total = 0;\n\tsize_t len;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!label);\n\n\tif (flags & FLAG_ABS_ROOT) {\n\t\tns = root_ns;\n\t\tlen = snprintf(str, size, \"=\");\n\t\tupdate_for_len(total, len, size, str);\n\t} else if (!ns) {\n\t\tns = labels_ns(label);\n\t}\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (count > 0) {\n\t\t\t\tlen = snprintf(str, size, \"//&\");\n\t\t\t\tupdate_for_len(total, len, size, str);\n\t\t\t}\n\t\t\tlen = aa_profile_snxprint(str, size, ns, profile,\n\t\t\t\t\t\t  flags & FLAG_VIEW_SUBNS,\n\t\t\t\t\t\t  &prev_ns);\n\t\t\tupdate_for_len(total, len, size, str);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count == 0) {\n\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\treturn snprintf(str, size, \"%s\", aa_hidden_ns_name);\n\t}\n\n\t/* count == 1 && ... is for backwards compat where the mode\n\t * is not displayed for 'unconfined' in the current ns\n\t */\n\tif (display_mode(ns, label, flags)) {\n\t\tlen = snprintf(str, size, \" (%s)\",\n\t\t\t       label_modename(ns, label, flags));\n\t\tupdate_for_len(total, len, size, str);\n\t}\n\n\treturn total;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_for_len",
          "args": [
            "total",
            "len",
            "size",
            "str"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "size",
            "\" (%s)\"",
            "label_modename(ns, label, flags)"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_modename",
          "args": [
            "ns",
            "label",
            "flags"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "label_modename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1528-1558",
          "snippet": "static const char *label_modename(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t  int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct label_it i;\n\tint mode = -1, count = 0;\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (profile->mode == APPARMOR_UNCONFINED)\n\t\t\t\t/* special case unconfined so stacks with\n\t\t\t\t * unconfined don't report as mixed. ie.\n\t\t\t\t * profile_foo//&:ns1:unconfined (mixed)\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\tcount++;\n\t\t\tif (mode == -1)\n\t\t\t\tmode = profile->mode;\n\t\t\telse if (mode != profile->mode)\n\t\t\t\treturn \"mixed\";\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\treturn \"-\";\n\tif (mode == -1)\n\t\t/* everything was unconfined */\n\t\tmode = APPARMOR_UNCONFINED;\n\n\treturn aa_profile_mode_names[mode];\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic const char *label_modename(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t  int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct label_it i;\n\tint mode = -1, count = 0;\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (profile->mode == APPARMOR_UNCONFINED)\n\t\t\t\t/* special case unconfined so stacks with\n\t\t\t\t * unconfined don't report as mixed. ie.\n\t\t\t\t * profile_foo//&:ns1:unconfined (mixed)\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\tcount++;\n\t\t\tif (mode == -1)\n\t\t\t\tmode = profile->mode;\n\t\t\telse if (mode != profile->mode)\n\t\t\t\treturn \"mixed\";\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\treturn \"-\";\n\tif (mode == -1)\n\t\t/* everything was unconfined */\n\t\tmode = APPARMOR_UNCONFINED;\n\n\treturn aa_profile_mode_names[mode];\n}"
        }
      },
      {
        "call_info": {
          "callee": "display_mode",
          "args": [
            "ns",
            "label",
            "flags"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "display_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1561-1579",
          "snippet": "static inline bool display_mode(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\tint flags)\n{\n\tif ((flags & FLAG_SHOW_MODE)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tif (aa_ns_visible(ns, profile->ns,\n\t\t\t\t\t  flags & FLAG_VIEW_SUBNS) &&\n\t\t\t    profile != profile->ns->unconfined)\n\t\t\t\treturn true;\n\t\t}\n\t\t/* only ns->unconfined in set of profiles in ns */\n\t\treturn false;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline bool display_mode(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\tint flags)\n{\n\tif ((flags & FLAG_SHOW_MODE)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tif (aa_ns_visible(ns, profile->ns,\n\t\t\t\t\t  flags & FLAG_VIEW_SUBNS) &&\n\t\t\t    profile != profile->ns->unconfined)\n\t\t\t\treturn true;\n\t\t}\n\t\t/* only ns->unconfined in set of profiles in ns */\n\t\treturn false;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "size",
            "\"%s\"",
            "aa_hidden_ns_name"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "size",
            "\"%s\"",
            "\"unconfined\""
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_for_len",
          "args": [
            "total",
            "len",
            "size",
            "str"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_profile_snxprint",
          "args": [
            "str",
            "size",
            "ns",
            "profile",
            "flags & FLAG_VIEW_SUBNS",
            "&prev_ns"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "aa_profile_snxprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1487-1526",
          "snippet": "static int aa_profile_snxprint(char *str, size_t size, struct aa_ns *view,\n\t\t\t       struct aa_profile *profile, int flags,\n\t\t\t       struct aa_ns **prev_ns)\n{\n\tconst char *ns_name = NULL;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!profile);\n\n\tif (!view)\n\t\tview = profiles_ns(profile);\n\n\tif (view != profile->ns &&\n\t    (!prev_ns || (*prev_ns != profile->ns))) {\n\t\tif (prev_ns)\n\t\t\t*prev_ns = profile->ns;\n\t\tns_name = aa_ns_name(view, profile->ns,\n\t\t\t\t     flags & FLAG_VIEW_SUBNS);\n\t\tif (ns_name == aa_hidden_ns_name) {\n\t\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\t\treturn snprintf(str, size, \"%s\", ns_name);\n\t\t}\n\t}\n\n\tif ((flags & FLAG_SHOW_MODE) && profile != profile->ns->unconfined) {\n\t\tconst char *modestr = aa_profile_mode_names[profile->mode];\n\n\t\tif (ns_name)\n\t\t\treturn snprintf(str, size, \":%s:%s (%s)\", ns_name,\n\t\t\t\t\tprofile->base.hname, modestr);\n\t\treturn snprintf(str, size, \"%s (%s)\", profile->base.hname,\n\t\t\t\tmodestr);\n\t}\n\n\tif (ns_name)\n\t\treturn snprintf(str, size, \":%s:%s\", ns_name,\n\t\t\t\tprofile->base.hname);\n\treturn snprintf(str, size, \"%s\", profile->base.hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int aa_profile_snxprint(char *str, size_t size, struct aa_ns *view,\n\t\t\t       struct aa_profile *profile, int flags,\n\t\t\t       struct aa_ns **prev_ns)\n{\n\tconst char *ns_name = NULL;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!profile);\n\n\tif (!view)\n\t\tview = profiles_ns(profile);\n\n\tif (view != profile->ns &&\n\t    (!prev_ns || (*prev_ns != profile->ns))) {\n\t\tif (prev_ns)\n\t\t\t*prev_ns = profile->ns;\n\t\tns_name = aa_ns_name(view, profile->ns,\n\t\t\t\t     flags & FLAG_VIEW_SUBNS);\n\t\tif (ns_name == aa_hidden_ns_name) {\n\t\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\t\treturn snprintf(str, size, \"%s\", ns_name);\n\t\t}\n\t}\n\n\tif ((flags & FLAG_SHOW_MODE) && profile != profile->ns->unconfined) {\n\t\tconst char *modestr = aa_profile_mode_names[profile->mode];\n\n\t\tif (ns_name)\n\t\t\treturn snprintf(str, size, \":%s:%s (%s)\", ns_name,\n\t\t\t\t\tprofile->base.hname, modestr);\n\t\treturn snprintf(str, size, \"%s (%s)\", profile->base.hname,\n\t\t\t\tmodestr);\n\t}\n\n\tif (ns_name)\n\t\treturn snprintf(str, size, \":%s:%s\", ns_name,\n\t\t\t\tprofile->base.hname);\n\treturn snprintf(str, size, \"%s\", profile->base.hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_for_len",
          "args": [
            "total",
            "len",
            "size",
            "str"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "size",
            "\"//&\""
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_ns_visible",
          "args": [
            "ns",
            "profile->ns",
            "flags & FLAG_VIEW_SUBNS"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "aa_ns_visible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "41-55",
          "snippet": "bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nbool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_for_each",
          "args": [
            "i",
            "label",
            "profile"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_for_len",
          "args": [
            "total",
            "len",
            "size",
            "str"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "size",
            "\"=\""
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!str && size != 0"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_label_snxprint(char *str, size_t size, struct aa_ns *ns,\n\t\t      struct aa_label *label, int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ns *prev_ns = NULL;\n\tstruct label_it i;\n\tint count = 0, total = 0;\n\tsize_t len;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!label);\n\n\tif (flags & FLAG_ABS_ROOT) {\n\t\tns = root_ns;\n\t\tlen = snprintf(str, size, \"=\");\n\t\tupdate_for_len(total, len, size, str);\n\t} else if (!ns) {\n\t\tns = labels_ns(label);\n\t}\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (count > 0) {\n\t\t\t\tlen = snprintf(str, size, \"//&\");\n\t\t\t\tupdate_for_len(total, len, size, str);\n\t\t\t}\n\t\t\tlen = aa_profile_snxprint(str, size, ns, profile,\n\t\t\t\t\t\t  flags & FLAG_VIEW_SUBNS,\n\t\t\t\t\t\t  &prev_ns);\n\t\t\tupdate_for_len(total, len, size, str);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count == 0) {\n\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\treturn snprintf(str, size, \"%s\", aa_hidden_ns_name);\n\t}\n\n\t/* count == 1 && ... is for backwards compat where the mode\n\t * is not displayed for 'unconfined' in the current ns\n\t */\n\tif (display_mode(ns, label, flags)) {\n\t\tlen = snprintf(str, size, \" (%s)\",\n\t\t\t       label_modename(ns, label, flags));\n\t\tupdate_for_len(total, len, size, str);\n\t}\n\n\treturn total;\n}"
  },
  {
    "function_name": "display_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1561-1579",
    "snippet": "static inline bool display_mode(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\tint flags)\n{\n\tif ((flags & FLAG_SHOW_MODE)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tif (aa_ns_visible(ns, profile->ns,\n\t\t\t\t\t  flags & FLAG_VIEW_SUBNS) &&\n\t\t\t    profile != profile->ns->unconfined)\n\t\t\t\treturn true;\n\t\t}\n\t\t/* only ns->unconfined in set of profiles in ns */\n\t\treturn false;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_ns_visible",
          "args": [
            "ns",
            "profile->ns",
            "flags & FLAG_VIEW_SUBNS"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "aa_ns_visible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "41-55",
          "snippet": "bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nbool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_for_each",
          "args": [
            "i",
            "label",
            "profile"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline bool display_mode(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\tint flags)\n{\n\tif ((flags & FLAG_SHOW_MODE)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\tif (aa_ns_visible(ns, profile->ns,\n\t\t\t\t\t  flags & FLAG_VIEW_SUBNS) &&\n\t\t\t    profile != profile->ns->unconfined)\n\t\t\t\treturn true;\n\t\t}\n\t\t/* only ns->unconfined in set of profiles in ns */\n\t\treturn false;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "label_modename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1528-1558",
    "snippet": "static const char *label_modename(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t  int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct label_it i;\n\tint mode = -1, count = 0;\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (profile->mode == APPARMOR_UNCONFINED)\n\t\t\t\t/* special case unconfined so stacks with\n\t\t\t\t * unconfined don't report as mixed. ie.\n\t\t\t\t * profile_foo//&:ns1:unconfined (mixed)\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\tcount++;\n\t\t\tif (mode == -1)\n\t\t\t\tmode = profile->mode;\n\t\t\telse if (mode != profile->mode)\n\t\t\t\treturn \"mixed\";\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\treturn \"-\";\n\tif (mode == -1)\n\t\t/* everything was unconfined */\n\t\tmode = APPARMOR_UNCONFINED;\n\n\treturn aa_profile_mode_names[mode];\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_ns_visible",
          "args": [
            "ns",
            "profile->ns",
            "flags & FLAG_VIEW_SUBNS"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "aa_ns_visible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "41-55",
          "snippet": "bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nbool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_for_each",
          "args": [
            "i",
            "label",
            "profile"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic const char *label_modename(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t  int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct label_it i;\n\tint mode = -1, count = 0;\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (profile->mode == APPARMOR_UNCONFINED)\n\t\t\t\t/* special case unconfined so stacks with\n\t\t\t\t * unconfined don't report as mixed. ie.\n\t\t\t\t * profile_foo//&:ns1:unconfined (mixed)\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\tcount++;\n\t\t\tif (mode == -1)\n\t\t\t\tmode = profile->mode;\n\t\t\telse if (mode != profile->mode)\n\t\t\t\treturn \"mixed\";\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\treturn \"-\";\n\tif (mode == -1)\n\t\t/* everything was unconfined */\n\t\tmode = APPARMOR_UNCONFINED;\n\n\treturn aa_profile_mode_names[mode];\n}"
  },
  {
    "function_name": "aa_profile_snxprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1487-1526",
    "snippet": "static int aa_profile_snxprint(char *str, size_t size, struct aa_ns *view,\n\t\t\t       struct aa_profile *profile, int flags,\n\t\t\t       struct aa_ns **prev_ns)\n{\n\tconst char *ns_name = NULL;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!profile);\n\n\tif (!view)\n\t\tview = profiles_ns(profile);\n\n\tif (view != profile->ns &&\n\t    (!prev_ns || (*prev_ns != profile->ns))) {\n\t\tif (prev_ns)\n\t\t\t*prev_ns = profile->ns;\n\t\tns_name = aa_ns_name(view, profile->ns,\n\t\t\t\t     flags & FLAG_VIEW_SUBNS);\n\t\tif (ns_name == aa_hidden_ns_name) {\n\t\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\t\treturn snprintf(str, size, \"%s\", ns_name);\n\t\t}\n\t}\n\n\tif ((flags & FLAG_SHOW_MODE) && profile != profile->ns->unconfined) {\n\t\tconst char *modestr = aa_profile_mode_names[profile->mode];\n\n\t\tif (ns_name)\n\t\t\treturn snprintf(str, size, \":%s:%s (%s)\", ns_name,\n\t\t\t\t\tprofile->base.hname, modestr);\n\t\treturn snprintf(str, size, \"%s (%s)\", profile->base.hname,\n\t\t\t\tmodestr);\n\t}\n\n\tif (ns_name)\n\t\treturn snprintf(str, size, \":%s:%s\", ns_name,\n\t\t\t\tprofile->base.hname);\n\treturn snprintf(str, size, \"%s\", profile->base.hname);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "size",
            "\"%s\"",
            "profile->base.hname"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "size",
            "\":%s:%s\"",
            "ns_name",
            "profile->base.hname"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "size",
            "\"%s (%s)\"",
            "profile->base.hname",
            "modestr"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "size",
            "\":%s:%s (%s)\"",
            "ns_name",
            "profile->base.hname",
            "modestr"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "size",
            "\"%s\"",
            "ns_name"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "size",
            "\"%s\"",
            "\"unconfined\""
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_ns_name",
          "args": [
            "view",
            "profile->ns",
            "flags & FLAG_VIEW_SUBNS"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "aa_ns_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "65-82",
          "snippet": "const char *aa_ns_name(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\t/* if view == curr then the namespace name isn't displayed */\n\tif (curr == view)\n\t\treturn \"\";\n\n\tif (aa_ns_visible(curr, view, subns)) {\n\t\t/* at this point if a ns is visible it is in a view ns\n\t\t * thus the curr ns.hname is a prefix of its name.\n\t\t * Only output the virtualized portion of the name\n\t\t * Add + 2 to skip over // separating curr hname prefix\n\t\t * from the visible tail of the views hname\n\t\t */\n\t\treturn view->base.hname + strlen(curr->base.hname) + 2;\n\t}\n\n\treturn aa_hidden_ns_name;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const char *aa_hidden_ns_name = \"---\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nconst char *aa_hidden_ns_name = \"---\";\n\nconst char *aa_ns_name(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\t/* if view == curr then the namespace name isn't displayed */\n\tif (curr == view)\n\t\treturn \"\";\n\n\tif (aa_ns_visible(curr, view, subns)) {\n\t\t/* at this point if a ns is visible it is in a view ns\n\t\t * thus the curr ns.hname is a prefix of its name.\n\t\t * Only output the virtualized portion of the name\n\t\t * Add + 2 to skip over // separating curr hname prefix\n\t\t * from the visible tail of the views hname\n\t\t */\n\t\treturn view->base.hname + strlen(curr->base.hname) + 2;\n\t}\n\n\treturn aa_hidden_ns_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profiles_ns",
          "args": [
            "profile"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!profile"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!str && size != 0"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int aa_profile_snxprint(char *str, size_t size, struct aa_ns *view,\n\t\t\t       struct aa_profile *profile, int flags,\n\t\t\t       struct aa_ns **prev_ns)\n{\n\tconst char *ns_name = NULL;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!profile);\n\n\tif (!view)\n\t\tview = profiles_ns(profile);\n\n\tif (view != profile->ns &&\n\t    (!prev_ns || (*prev_ns != profile->ns))) {\n\t\tif (prev_ns)\n\t\t\t*prev_ns = profile->ns;\n\t\tns_name = aa_ns_name(view, profile->ns,\n\t\t\t\t     flags & FLAG_VIEW_SUBNS);\n\t\tif (ns_name == aa_hidden_ns_name) {\n\t\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\t\treturn snprintf(str, size, \"%s\", ns_name);\n\t\t}\n\t}\n\n\tif ((flags & FLAG_SHOW_MODE) && profile != profile->ns->unconfined) {\n\t\tconst char *modestr = aa_profile_mode_names[profile->mode];\n\n\t\tif (ns_name)\n\t\t\treturn snprintf(str, size, \":%s:%s (%s)\", ns_name,\n\t\t\t\t\tprofile->base.hname, modestr);\n\t\treturn snprintf(str, size, \"%s (%s)\", profile->base.hname,\n\t\t\t\tmodestr);\n\t}\n\n\tif (ns_name)\n\t\treturn snprintf(str, size, \":%s:%s\", ns_name,\n\t\t\t\tprofile->base.hname);\n\treturn snprintf(str, size, \"%s\", profile->base.hname);\n}"
  },
  {
    "function_name": "use_label_hname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1453-1461",
    "snippet": "static inline bool use_label_hname(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t   int flags)\n{\n\tif (label->hname && (!ns || labels_ns(label) == ns) &&\n\t    !(flags & ~FLAG_SHOW_MODE))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline bool use_label_hname(struct aa_ns *ns, struct aa_label *label,\n\t\t\t\t   int flags)\n{\n\tif (label->hname && (!ns || labels_ns(label) == ns) &&\n\t    !(flags & ~FLAG_SHOW_MODE))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "aa_update_label_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1421-1447",
    "snippet": "bool aa_update_label_name(struct aa_ns *ns, struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_labelset *ls;\n\tunsigned long flags;\n\tchar __counted *name;\n\tbool res = false;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!label);\n\n\tif (label->hname || labels_ns(label) != ns)\n\t\treturn res;\n\n\tif (aa_label_acntsxprint(&name, ns, label, FLAGS_NONE, gfp) == -1)\n\t\treturn res;\n\n\tls = labels_set(label);\n\twrite_lock_irqsave(&ls->lock, flags);\n\tif (!label->hname && label->flags & FLAG_IN_TREE) {\n\t\tlabel->hname = name;\n\t\tres = true;\n\t} else\n\t\taa_put_str(name);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn res;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_str",
          "args": [
            "name"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/lib.h",
          "lines": "115-119",
          "snippet": "static inline void aa_put_str(__counted char *str)\n{\n\tif (str)\n\t\tkref_put(&str_to_counted(str)->count, aa_str_kref);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define __counted\t/* atm just a notation */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n\n#define __counted\t/* atm just a notation */\n\nstatic inline void aa_put_str(__counted char *str)\n{\n\tif (str)\n\t\tkref_put(&str_to_counted(str)->count, aa_str_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "label"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_acntsxprint",
          "args": [
            "&name",
            "ns",
            "label",
            "FLAGS_NONE",
            "gfp"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_acntsxprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1691-1707",
          "snippet": "int aa_label_acntsxprint(char __counted **strp, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = aa_str_alloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_label_acntsxprint(char __counted **strp, struct aa_ns *ns,\n\t\t\t struct aa_label *label, int flags, gfp_t gfp)\n{\n\tint size;\n\n\tAA_BUG(!strp);\n\tAA_BUG(!label);\n\n\tsize = aa_label_snxprint(NULL, 0, ns, label, flags);\n\tif (size < 0)\n\t\treturn size;\n\n\t*strp = aa_str_alloc(size + 1, gfp);\n\tif (!*strp)\n\t\treturn -ENOMEM;\n\treturn aa_label_snxprint(*strp, size + 1, ns, label, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ns"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nbool aa_update_label_name(struct aa_ns *ns, struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_labelset *ls;\n\tunsigned long flags;\n\tchar __counted *name;\n\tbool res = false;\n\n\tAA_BUG(!ns);\n\tAA_BUG(!label);\n\n\tif (label->hname || labels_ns(label) != ns)\n\t\treturn res;\n\n\tif (aa_label_acntsxprint(&name, ns, label, FLAGS_NONE, gfp) == -1)\n\t\treturn res;\n\n\tls = labels_set(label);\n\twrite_lock_irqsave(&ls->lock, flags);\n\tif (!label->hname && label->flags & FLAG_IN_TREE) {\n\t\tlabel->hname = name;\n\t\tres = true;\n\t} else\n\t\taa_put_str(name);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn res;\n}"
  },
  {
    "function_name": "aa_label_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1395-1407",
    "snippet": "int aa_label_match(struct aa_profile *profile, struct aa_label *label,\n\t\t   unsigned int state, bool subns, u32 request,\n\t\t   struct aa_perms *perms)\n{\n\tint error = label_compound_match(profile, label, state, subns, request,\n\t\t\t\t\t perms);\n\tif (!error)\n\t\treturn error;\n\n\t*perms = allperms;\n\treturn label_components_match(profile, label, state, subns, request,\n\t\t\t\t      perms);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "label_components_match",
          "args": [
            "profile",
            "label",
            "state",
            "subns",
            "request",
            "perms"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "label_components_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1336-1382",
          "snippet": "static int label_components_match(struct aa_profile *profile,\n\t\t\t\t  struct aa_label *label, unsigned int start,\n\t\t\t\t  bool subns, u32 request,\n\t\t\t\t  struct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct aa_perms tmp;\n\tunsigned int state = 0;\n\n\t/* find first subcomponent to test */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no subcomponents visible - no change in perms */\n\treturn 0;\n\nnext:\n\taa_compute_perms(profile->policy.dfa, state, &tmp);\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum(perms, &tmp);\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\taa_compute_perms(profile->policy.dfa, state, &tmp);\n\t\taa_apply_modes_to_perms(profile, &tmp);\n\t\taa_perms_accum(perms, &tmp);\n\t}\n\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int label_components_match(struct aa_profile *profile,\n\t\t\t\t  struct aa_label *label, unsigned int start,\n\t\t\t\t  bool subns, u32 request,\n\t\t\t\t  struct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct aa_perms tmp;\n\tunsigned int state = 0;\n\n\t/* find first subcomponent to test */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no subcomponents visible - no change in perms */\n\treturn 0;\n\nnext:\n\taa_compute_perms(profile->policy.dfa, state, &tmp);\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum(perms, &tmp);\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\taa_compute_perms(profile->policy.dfa, state, &tmp);\n\t\taa_apply_modes_to_perms(profile, &tmp);\n\t\taa_perms_accum(perms, &tmp);\n\t}\n\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_compound_match",
          "args": [
            "profile",
            "label",
            "state",
            "subns",
            "request",
            "perms"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "label_compound_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1278-1319",
          "snippet": "static int label_compound_match(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *label,\n\t\t\t\tunsigned int state, bool subns, u32 request,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\n\t/* find first subcomponent that is visible */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no component visible */\n\t*perms = allperms;\n\treturn 0;\n\nnext:\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = aa_dfa_match(profile->policy.dfa, state, \"//&\");\n\t\tstate = match_component(profile, tp, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t}\n\taa_compute_perms(profile->policy.dfa, state, perms);\n\taa_apply_modes_to_perms(profile, perms);\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn state;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int label_compound_match(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *label,\n\t\t\t\tunsigned int state, bool subns, u32 request,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\n\t/* find first subcomponent that is visible */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no component visible */\n\t*perms = allperms;\n\treturn 0;\n\nnext:\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = aa_dfa_match(profile->policy.dfa, state, \"//&\");\n\t\tstate = match_component(profile, tp, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t}\n\taa_compute_perms(profile->policy.dfa, state, perms);\n\taa_apply_modes_to_perms(profile, perms);\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_label_match(struct aa_profile *profile, struct aa_label *label,\n\t\t   unsigned int state, bool subns, u32 request,\n\t\t   struct aa_perms *perms)\n{\n\tint error = label_compound_match(profile, label, state, subns, request,\n\t\t\t\t\t perms);\n\tif (!error)\n\t\treturn error;\n\n\t*perms = allperms;\n\treturn label_components_match(profile, label, state, subns, request,\n\t\t\t\t      perms);\n}"
  },
  {
    "function_name": "label_components_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1336-1382",
    "snippet": "static int label_components_match(struct aa_profile *profile,\n\t\t\t\t  struct aa_label *label, unsigned int start,\n\t\t\t\t  bool subns, u32 request,\n\t\t\t\t  struct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct aa_perms tmp;\n\tunsigned int state = 0;\n\n\t/* find first subcomponent to test */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no subcomponents visible - no change in perms */\n\treturn 0;\n\nnext:\n\taa_compute_perms(profile->policy.dfa, state, &tmp);\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum(perms, &tmp);\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\taa_compute_perms(profile->policy.dfa, state, &tmp);\n\t\taa_apply_modes_to_perms(profile, &tmp);\n\t\taa_perms_accum(perms, &tmp);\n\t}\n\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_perms_accum",
          "args": [
            "perms",
            "&tmp"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "aa_perms_accum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "359-371",
          "snippet": "void aa_perms_accum(struct aa_perms *accum, struct aa_perms *addend)\n{\n\taccum->deny |= addend->deny;\n\taccum->allow &= addend->allow & ~accum->deny;\n\taccum->audit |= addend->audit & accum->allow;\n\taccum->quiet &= addend->quiet & ~accum->allow;\n\taccum->kill |= addend->kill & ~accum->allow;\n\taccum->stop |= addend->stop & ~accum->allow;\n\taccum->complain |= addend->complain & ~accum->allow & ~accum->deny;\n\taccum->cond |= addend->cond & ~accum->allow & ~accum->deny;\n\taccum->hide &= addend->hide & ~accum->allow;\n\taccum->prompt |= addend->prompt & ~accum->allow & ~accum->deny;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_perms_accum(struct aa_perms *accum, struct aa_perms *addend)\n{\n\taccum->deny |= addend->deny;\n\taccum->allow &= addend->allow & ~accum->deny;\n\taccum->audit |= addend->audit & accum->allow;\n\taccum->quiet &= addend->quiet & ~accum->allow;\n\taccum->kill |= addend->kill & ~accum->allow;\n\taccum->stop |= addend->stop & ~accum->allow;\n\taccum->complain |= addend->complain & ~accum->allow & ~accum->deny;\n\taccum->cond |= addend->cond & ~accum->allow & ~accum->deny;\n\taccum->hide &= addend->hide & ~accum->allow;\n\taccum->prompt |= addend->prompt & ~accum->allow & ~accum->deny;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_apply_modes_to_perms",
          "args": [
            "profile",
            "&tmp"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "aa_apply_modes_to_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "282-308",
          "snippet": "void aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_compute_perms",
          "args": [
            "profile->policy.dfa",
            "state",
            "&tmp"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "aa_compute_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "317-333",
          "snippet": "void aa_compute_perms(struct aa_dfa *dfa, unsigned int state,\n\t\t      struct aa_perms *perms)\n{\n\t*perms = (struct aa_perms) {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t};\n\n\t/* for v5 perm mapping in the policydb, the other set is used\n\t * to extend the general perm set\n\t */\n\tperms->allow |= map_other(dfa_other_allow(dfa, state));\n\tperms->audit |= map_other(dfa_other_audit(dfa, state));\n\tperms->quiet |= map_other(dfa_other_quiet(dfa, state));\n//\tperms->xindex = dfa_user_xindex(dfa, state);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_compute_perms(struct aa_dfa *dfa, unsigned int state,\n\t\t      struct aa_perms *perms)\n{\n\t*perms = (struct aa_perms) {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t};\n\n\t/* for v5 perm mapping in the policydb, the other set is used\n\t * to extend the general perm set\n\t */\n\tperms->allow |= map_other(dfa_other_allow(dfa, state));\n\tperms->audit |= map_other(dfa_other_audit(dfa, state));\n\tperms->quiet |= map_other(dfa_other_quiet(dfa, state));\n//\tperms->xindex = dfa_user_xindex(dfa, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_component",
          "args": [
            "profile",
            "tp",
            "start"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "match_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1246-1261",
          "snippet": "static inline unsigned int match_component(struct aa_profile *profile,\n\t\t\t\t\t   struct aa_profile *tp,\n\t\t\t\t\t   unsigned int state)\n{\n\tconst char *ns_name;\n\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(profile->policy.dfa, state, tp->base.hname);\n\n\t/* try matching with namespace name and then profile */\n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(profile->policy.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(profile->policy.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(profile->policy.dfa, state, \":\", 1);\n\treturn aa_dfa_match(profile->policy.dfa, state, tp->base.hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline unsigned int match_component(struct aa_profile *profile,\n\t\t\t\t\t   struct aa_profile *tp,\n\t\t\t\t\t   unsigned int state)\n{\n\tconst char *ns_name;\n\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(profile->policy.dfa, state, tp->base.hname);\n\n\t/* try matching with namespace name and then profile */\n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(profile->policy.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(profile->policy.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(profile->policy.dfa, state, \":\", 1);\n\treturn aa_dfa_match(profile->policy.dfa, state, tp->base.hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_ns_visible",
          "args": [
            "profile->ns",
            "tp->ns",
            "subns"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "aa_ns_visible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "41-55",
          "snippet": "bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nbool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_for_each_cont",
          "args": [
            "i",
            "label",
            "tp"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_for_each",
          "args": [
            "i",
            "label",
            "tp"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int label_components_match(struct aa_profile *profile,\n\t\t\t\t  struct aa_label *label, unsigned int start,\n\t\t\t\t  bool subns, u32 request,\n\t\t\t\t  struct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\tstruct aa_perms tmp;\n\tunsigned int state = 0;\n\n\t/* find first subcomponent to test */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no subcomponents visible - no change in perms */\n\treturn 0;\n\nnext:\n\taa_compute_perms(profile->policy.dfa, state, &tmp);\n\taa_apply_modes_to_perms(profile, &tmp);\n\taa_perms_accum(perms, &tmp);\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, start);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\taa_compute_perms(profile->policy.dfa, state, &tmp);\n\t\taa_apply_modes_to_perms(profile, &tmp);\n\t\taa_perms_accum(perms, &tmp);\n\t}\n\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn -EACCES;\n}"
  },
  {
    "function_name": "label_compound_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1278-1319",
    "snippet": "static int label_compound_match(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *label,\n\t\t\t\tunsigned int state, bool subns, u32 request,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\n\t/* find first subcomponent that is visible */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no component visible */\n\t*perms = allperms;\n\treturn 0;\n\nnext:\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = aa_dfa_match(profile->policy.dfa, state, \"//&\");\n\t\tstate = match_component(profile, tp, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t}\n\taa_compute_perms(profile->policy.dfa, state, perms);\n\taa_apply_modes_to_perms(profile, perms);\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn state;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_apply_modes_to_perms",
          "args": [
            "profile",
            "perms"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "aa_apply_modes_to_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "282-308",
          "snippet": "void aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_compute_perms",
          "args": [
            "profile->policy.dfa",
            "state",
            "perms"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "aa_compute_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "317-333",
          "snippet": "void aa_compute_perms(struct aa_dfa *dfa, unsigned int state,\n\t\t      struct aa_perms *perms)\n{\n\t*perms = (struct aa_perms) {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t};\n\n\t/* for v5 perm mapping in the policydb, the other set is used\n\t * to extend the general perm set\n\t */\n\tperms->allow |= map_other(dfa_other_allow(dfa, state));\n\tperms->audit |= map_other(dfa_other_audit(dfa, state));\n\tperms->quiet |= map_other(dfa_other_quiet(dfa, state));\n//\tperms->xindex = dfa_user_xindex(dfa, state);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_compute_perms(struct aa_dfa *dfa, unsigned int state,\n\t\t      struct aa_perms *perms)\n{\n\t*perms = (struct aa_perms) {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t};\n\n\t/* for v5 perm mapping in the policydb, the other set is used\n\t * to extend the general perm set\n\t */\n\tperms->allow |= map_other(dfa_other_allow(dfa, state));\n\tperms->audit |= map_other(dfa_other_audit(dfa, state));\n\tperms->quiet |= map_other(dfa_other_quiet(dfa, state));\n//\tperms->xindex = dfa_user_xindex(dfa, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_component",
          "args": [
            "profile",
            "tp",
            "state"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "match_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1246-1261",
          "snippet": "static inline unsigned int match_component(struct aa_profile *profile,\n\t\t\t\t\t   struct aa_profile *tp,\n\t\t\t\t\t   unsigned int state)\n{\n\tconst char *ns_name;\n\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(profile->policy.dfa, state, tp->base.hname);\n\n\t/* try matching with namespace name and then profile */\n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(profile->policy.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(profile->policy.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(profile->policy.dfa, state, \":\", 1);\n\treturn aa_dfa_match(profile->policy.dfa, state, tp->base.hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline unsigned int match_component(struct aa_profile *profile,\n\t\t\t\t\t   struct aa_profile *tp,\n\t\t\t\t\t   unsigned int state)\n{\n\tconst char *ns_name;\n\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(profile->policy.dfa, state, tp->base.hname);\n\n\t/* try matching with namespace name and then profile */\n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(profile->policy.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(profile->policy.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(profile->policy.dfa, state, \":\", 1);\n\treturn aa_dfa_match(profile->policy.dfa, state, tp->base.hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_match",
          "args": [
            "profile->policy.dfa",
            "state",
            "\"//&\""
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "381-417",
          "snippet": "unsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_ns_visible",
          "args": [
            "profile->ns",
            "tp->ns",
            "subns"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "aa_ns_visible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "41-55",
          "snippet": "bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nbool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_for_each_cont",
          "args": [
            "i",
            "label",
            "tp"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_for_each",
          "args": [
            "i",
            "label",
            "tp"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int label_compound_match(struct aa_profile *profile,\n\t\t\t\tstruct aa_label *label,\n\t\t\t\tunsigned int state, bool subns, u32 request,\n\t\t\t\tstruct aa_perms *perms)\n{\n\tstruct aa_profile *tp;\n\tstruct label_it i;\n\n\t/* find first subcomponent that is visible */\n\tlabel_for_each(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = match_component(profile, tp, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t\tgoto next;\n\t}\n\n\t/* no component visible */\n\t*perms = allperms;\n\treturn 0;\n\nnext:\n\tlabel_for_each_cont(i, label, tp) {\n\t\tif (!aa_ns_visible(profile->ns, tp->ns, subns))\n\t\t\tcontinue;\n\t\tstate = aa_dfa_match(profile->policy.dfa, state, \"//&\");\n\t\tstate = match_component(profile, tp, state);\n\t\tif (!state)\n\t\t\tgoto fail;\n\t}\n\taa_compute_perms(profile->policy.dfa, state, perms);\n\taa_apply_modes_to_perms(profile, perms);\n\tif ((perms->allow & request) != request)\n\t\treturn -EACCES;\n\n\treturn 0;\n\nfail:\n\t*perms = nullperms;\n\treturn state;\n}"
  },
  {
    "function_name": "match_component",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1246-1261",
    "snippet": "static inline unsigned int match_component(struct aa_profile *profile,\n\t\t\t\t\t   struct aa_profile *tp,\n\t\t\t\t\t   unsigned int state)\n{\n\tconst char *ns_name;\n\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(profile->policy.dfa, state, tp->base.hname);\n\n\t/* try matching with namespace name and then profile */\n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(profile->policy.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(profile->policy.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(profile->policy.dfa, state, \":\", 1);\n\treturn aa_dfa_match(profile->policy.dfa, state, tp->base.hname);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_dfa_match",
          "args": [
            "profile->policy.dfa",
            "state",
            "tp->base.hname"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "381-417",
          "snippet": "unsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_match_len",
          "args": [
            "profile->policy.dfa",
            "state",
            "\":\"",
            "1"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_match_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "331-367",
          "snippet": "unsigned int aa_dfa_match_len(struct aa_dfa *dfa, unsigned int start,\n\t\t\t      const char *str, int len)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match_len(struct aa_dfa *dfa, unsigned int start,\n\t\t\t      const char *str, int len)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\tfor (; len; len--) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_ns_name",
          "args": [
            "profile->ns",
            "tp->ns",
            "true"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "aa_ns_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "65-82",
          "snippet": "const char *aa_ns_name(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\t/* if view == curr then the namespace name isn't displayed */\n\tif (curr == view)\n\t\treturn \"\";\n\n\tif (aa_ns_visible(curr, view, subns)) {\n\t\t/* at this point if a ns is visible it is in a view ns\n\t\t * thus the curr ns.hname is a prefix of its name.\n\t\t * Only output the virtualized portion of the name\n\t\t * Add + 2 to skip over // separating curr hname prefix\n\t\t * from the visible tail of the views hname\n\t\t */\n\t\treturn view->base.hname + strlen(curr->base.hname) + 2;\n\t}\n\n\treturn aa_hidden_ns_name;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const char *aa_hidden_ns_name = \"---\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nconst char *aa_hidden_ns_name = \"---\";\n\nconst char *aa_ns_name(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\t/* if view == curr then the namespace name isn't displayed */\n\tif (curr == view)\n\t\treturn \"\";\n\n\tif (aa_ns_visible(curr, view, subns)) {\n\t\t/* at this point if a ns is visible it is in a view ns\n\t\t * thus the curr ns.hname is a prefix of its name.\n\t\t * Only output the virtualized portion of the name\n\t\t * Add + 2 to skip over // separating curr hname prefix\n\t\t * from the visible tail of the views hname\n\t\t */\n\t\treturn view->base.hname + strlen(curr->base.hname) + 2;\n\t}\n\n\treturn aa_hidden_ns_name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline unsigned int match_component(struct aa_profile *profile,\n\t\t\t\t\t   struct aa_profile *tp,\n\t\t\t\t\t   unsigned int state)\n{\n\tconst char *ns_name;\n\n\tif (profile->ns == tp->ns)\n\t\treturn aa_dfa_match(profile->policy.dfa, state, tp->base.hname);\n\n\t/* try matching with namespace name and then profile */\n\tns_name = aa_ns_name(profile->ns, tp->ns, true);\n\tstate = aa_dfa_match_len(profile->policy.dfa, state, \":\", 1);\n\tstate = aa_dfa_match(profile->policy.dfa, state, ns_name);\n\tstate = aa_dfa_match_len(profile->policy.dfa, state, \":\", 1);\n\treturn aa_dfa_match(profile->policy.dfa, state, tp->base.hname);\n}"
  },
  {
    "function_name": "label_is_visible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1235-1239",
    "snippet": "static inline bool label_is_visible(struct aa_profile *profile,\n\t\t\t\t    struct aa_label *label)\n{\n\treturn aa_ns_visible(profile->ns, labels_ns(label), true);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_ns_visible",
          "args": [
            "profile->ns",
            "labels_ns(label)",
            "true"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "aa_ns_visible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "41-55",
          "snippet": "bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nbool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline bool label_is_visible(struct aa_profile *profile,\n\t\t\t\t    struct aa_label *label)\n{\n\treturn aa_ns_visible(profile->ns, labels_ns(label), true);\n}"
  },
  {
    "function_name": "aa_label_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1195-1233",
    "snippet": "struct aa_label *aa_label_merge(struct aa_label *a, struct aa_label *b,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn aa_get_newest_label(a);\n\n\t/* TODO: enable when read side is lockless\n\t * check if label exists before taking locks\n\tif (!label_is_stale(a) && !label_is_stale(b))\n\t\tlabel = aa_label_find_merge(a, b);\n\t*/\n\n\tif (!label) {\n\t\tstruct aa_label *new;\n\n\t\ta = aa_get_newest_label(a);\n\t\tb = aa_get_newest_label(b);\n\n\t\t/* could use label_merge_len(a, b), but requires double\n\t\t * comparison for small savings\n\t\t */\n\t\tnew = aa_label_alloc(a->size + b->size, NULL, gfp);\n\t\tif (!new)\n\t\t\tgoto out;\n\n\t\tlabel = label_merge_insert(new, a, b);\n\t\tlabel_free_or_put_new(label, new);\nout:\n\t\taa_put_label(a);\n\t\taa_put_label(b);\n\t}\n\n\treturn label;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "b"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_free_or_put_new",
          "args": [
            "label",
            "new"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "label_free_or_put_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "396-403",
          "snippet": "static void label_free_or_put_new(struct aa_label *label, struct aa_label *new)\n{\n\tif (label != new)\n\t\t/* need to free directly to break circular ref with proxy */\n\t\taa_label_free(new);\n\telse\n\t\taa_put_label(new);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic void label_free_or_put_new(struct aa_label *label, struct aa_label *new)\n{\n\tif (label != new)\n\t\t/* need to free directly to break circular ref with proxy */\n\t\taa_label_free(new);\n\telse\n\t\taa_put_label(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_merge_insert",
          "args": [
            "new",
            "a",
            "b"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "label_merge_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1024-1086",
          "snippet": "static struct aa_label *label_merge_insert(struct aa_label *new,\n\t\t\t\t\t   struct aa_label *a,\n\t\t\t\t\t   struct aa_label *b)\n{\n\tstruct aa_label *label;\n\tstruct aa_labelset *ls;\n\tstruct aa_profile *next;\n\tstruct label_it i;\n\tunsigned long flags;\n\tint k = 0, invcount = 0;\n\tbool stale = false;\n\n\tAA_BUG(!a);\n\tAA_BUG(a->size < 0);\n\tAA_BUG(!b);\n\tAA_BUG(b->size < 0);\n\tAA_BUG(!new);\n\tAA_BUG(new->size < a->size + b->size);\n\n\tlabel_for_each_in_merge(i, a, b, next) {\n\t\tAA_BUG(!next);\n\t\tif (profile_is_stale(next)) {\n\t\t\tnew->vec[k] = aa_get_newest_profile(next);\n\t\t\tAA_BUG(!new->vec[k]->label.proxy);\n\t\t\tAA_BUG(!new->vec[k]->label.proxy->label);\n\t\t\tif (next->label.proxy != new->vec[k]->label.proxy)\n\t\t\t\tinvcount++;\n\t\t\tk++;\n\t\t\tstale = true;\n\t\t} else\n\t\t\tnew->vec[k++] = aa_get_profile(next);\n\t}\n\t/* set to actual size which is <= allocated len */\n\tnew->size = k;\n\tnew->vec[k] = NULL;\n\n\tif (invcount) {\n\t\tnew->size -= aa_vec_unique(&new->vec[0], new->size,\n\t\t\t\t\t   VEC_FLAG_TERMINATE);\n\t\t/* TODO: deal with reference labels */\n\t\tif (new->size == 1) {\n\t\t\tlabel = aa_get_label(&new->vec[0]->label);\n\t\t\treturn label;\n\t\t}\n\t} else if (!stale) {\n\t\t/*\n\t\t * merge could be same as a || b, note: it is not possible\n\t\t * for new->size == a->size == b->size unless a == b\n\t\t */\n\t\tif (k == a->size)\n\t\t\treturn aa_get_label(a);\n\t\telse if (k == b->size)\n\t\t\treturn aa_get_label(b);\n\t}\n\tif (vec_unconfined(new->vec, new->size))\n\t\tnew->flags |= FLAG_UNCONFINED;\n\tls = labels_set(new);\n\twrite_lock_irqsave(&ls->lock, flags);\n\tlabel = __label_insert(labels_set(new), new, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *label_merge_insert(struct aa_label *new,\n\t\t\t\t\t   struct aa_label *a,\n\t\t\t\t\t   struct aa_label *b)\n{\n\tstruct aa_label *label;\n\tstruct aa_labelset *ls;\n\tstruct aa_profile *next;\n\tstruct label_it i;\n\tunsigned long flags;\n\tint k = 0, invcount = 0;\n\tbool stale = false;\n\n\tAA_BUG(!a);\n\tAA_BUG(a->size < 0);\n\tAA_BUG(!b);\n\tAA_BUG(b->size < 0);\n\tAA_BUG(!new);\n\tAA_BUG(new->size < a->size + b->size);\n\n\tlabel_for_each_in_merge(i, a, b, next) {\n\t\tAA_BUG(!next);\n\t\tif (profile_is_stale(next)) {\n\t\t\tnew->vec[k] = aa_get_newest_profile(next);\n\t\t\tAA_BUG(!new->vec[k]->label.proxy);\n\t\t\tAA_BUG(!new->vec[k]->label.proxy->label);\n\t\t\tif (next->label.proxy != new->vec[k]->label.proxy)\n\t\t\t\tinvcount++;\n\t\t\tk++;\n\t\t\tstale = true;\n\t\t} else\n\t\t\tnew->vec[k++] = aa_get_profile(next);\n\t}\n\t/* set to actual size which is <= allocated len */\n\tnew->size = k;\n\tnew->vec[k] = NULL;\n\n\tif (invcount) {\n\t\tnew->size -= aa_vec_unique(&new->vec[0], new->size,\n\t\t\t\t\t   VEC_FLAG_TERMINATE);\n\t\t/* TODO: deal with reference labels */\n\t\tif (new->size == 1) {\n\t\t\tlabel = aa_get_label(&new->vec[0]->label);\n\t\t\treturn label;\n\t\t}\n\t} else if (!stale) {\n\t\t/*\n\t\t * merge could be same as a || b, note: it is not possible\n\t\t * for new->size == a->size == b->size unless a == b\n\t\t */\n\t\tif (k == a->size)\n\t\t\treturn aa_get_label(a);\n\t\telse if (k == b->size)\n\t\t\treturn aa_get_label(b);\n\t}\n\tif (vec_unconfined(new->vec, new->size))\n\t\tnew->flags |= FLAG_UNCONFINED;\n\tls = labels_set(new);\n\twrite_lock_irqsave(&ls->lock, flags);\n\tlabel = __label_insert(labels_set(new), new, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_alloc",
          "args": [
            "a->size + b->size",
            "NULL",
            "gfp"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "431-462",
          "snippet": "struct aa_label *aa_label_alloc(int size, struct aa_proxy *proxy, gfp_t gfp)\n{\n\tstruct aa_label *new;\n\n\tAA_BUG(size < 1);\n\n\t/*  + 1 for null terminator entry on vec */\n\tnew = kzalloc(sizeof(*new) + sizeof(struct aa_profile *) * (size + 1),\n\t\t\tgfp);\n\tAA_DEBUG(\"%s (%p)\\n\", __func__, new);\n\tif (!new)\n\t\tgoto fail;\n\n\tif (!aa_label_init(new, size))\n\t\tgoto fail;\n\n\tif (!proxy) {\n\t\tproxy = aa_alloc_proxy(new, gfp);\n\t\tif (!proxy)\n\t\t\tgoto fail;\n\t} else\n\t\taa_get_proxy(proxy);\n\t/* just set new's proxy, don't redirect proxy here if it was passed in*/\n\tnew->proxy = proxy;\n\n\treturn new;\n\nfail:\n\tkfree(new);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_alloc(int size, struct aa_proxy *proxy, gfp_t gfp)\n{\n\tstruct aa_label *new;\n\n\tAA_BUG(size < 1);\n\n\t/*  + 1 for null terminator entry on vec */\n\tnew = kzalloc(sizeof(*new) + sizeof(struct aa_profile *) * (size + 1),\n\t\t\tgfp);\n\tAA_DEBUG(\"%s (%p)\\n\", __func__, new);\n\tif (!new)\n\t\tgoto fail;\n\n\tif (!aa_label_init(new, size))\n\t\tgoto fail;\n\n\tif (!proxy) {\n\t\tproxy = aa_alloc_proxy(new, gfp);\n\t\tif (!proxy)\n\t\t\tgoto fail;\n\t} else\n\t\taa_get_proxy(proxy);\n\t/* just set new's proxy, don't redirect proxy here if it was passed in*/\n\tnew->proxy = proxy;\n\n\treturn new;\n\nfail:\n\tkfree(new);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_newest_label",
          "args": [
            "b"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "393-414",
          "snippet": "static inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!b"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!a"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_merge(struct aa_label *a, struct aa_label *b,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn aa_get_newest_label(a);\n\n\t/* TODO: enable when read side is lockless\n\t * check if label exists before taking locks\n\tif (!label_is_stale(a) && !label_is_stale(b))\n\t\tlabel = aa_label_find_merge(a, b);\n\t*/\n\n\tif (!label) {\n\t\tstruct aa_label *new;\n\n\t\ta = aa_get_newest_label(a);\n\t\tb = aa_get_newest_label(b);\n\n\t\t/* could use label_merge_len(a, b), but requires double\n\t\t * comparison for small savings\n\t\t */\n\t\tnew = aa_label_alloc(a->size + b->size, NULL, gfp);\n\t\tif (!new)\n\t\t\tgoto out;\n\n\t\tlabel = label_merge_insert(new, a, b);\n\t\tlabel_free_or_put_new(label, new);\nout:\n\t\taa_put_label(a);\n\t\taa_put_label(b);\n\t}\n\n\treturn label;\n}"
  },
  {
    "function_name": "aa_label_find_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1158-1179",
    "snippet": "struct aa_label *aa_label_find_merge(struct aa_label *a, struct aa_label *b)\n{\n\tstruct aa_labelset *ls;\n\tstruct aa_label *label, *ar = NULL, *br = NULL;\n\tunsigned long flags;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (label_is_stale(a))\n\t\ta = ar = aa_get_newest_label(a);\n\tif (label_is_stale(b))\n\t\tb = br = aa_get_newest_label(b);\n\tls = labelset_of_merge(a, b);\n\tread_lock_irqsave(&ls->lock, flags);\n\tlabel = __label_find_merge(ls, a, b);\n\tread_unlock_irqrestore(&ls->lock, flags);\n\taa_put_label(ar);\n\taa_put_label(br);\n\n\treturn label;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "br"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_find_merge",
          "args": [
            "ls",
            "a",
            "b"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "__label_find_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1117-1145",
          "snippet": "static struct aa_label *__label_find_merge(struct aa_labelset *ls,\n\t\t\t\t\t   struct aa_label *a,\n\t\t\t\t\t   struct aa_label *b)\n{\n\tstruct rb_node *node;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn __label_find(a);\n\n\tnode  = ls->root.rb_node;\n\twhile (node) {\n\t\tstruct aa_label *this = container_of(node, struct aa_label,\n\t\t\t\t\t\t     node);\n\t\tint result = label_merge_cmp(a, b, this);\n\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn __aa_get_label(this);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__label_find_merge(struct aa_labelset *ls,\n\t\t\t\t\t   struct aa_label *a,\n\t\t\t\t\t   struct aa_label *b)\n{\n\tstruct rb_node *node;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn __label_find(a);\n\n\tnode  = ls->root.rb_node;\n\twhile (node) {\n\t\tstruct aa_label *this = container_of(node, struct aa_label,\n\t\t\t\t\t\t     node);\n\t\tint result = label_merge_cmp(a, b, this);\n\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn __aa_get_label(this);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labelset_of_merge",
          "args": [
            "a",
            "b"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "labelset_of_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1095-1104",
          "snippet": "static struct aa_labelset *labelset_of_merge(struct aa_label *a,\n\t\t\t\t\t     struct aa_label *b)\n{\n\tstruct aa_ns *nsa = labels_ns(a);\n\tstruct aa_ns *nsb = labels_ns(b);\n\n\tif (ns_cmp(nsa, nsb) <= 0)\n\t\treturn &nsa->labels;\n\treturn &nsb->labels;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_labelset *labelset_of_merge(struct aa_label *a,\n\t\t\t\t\t     struct aa_label *b)\n{\n\tstruct aa_ns *nsa = labels_ns(a);\n\tstruct aa_ns *nsb = labels_ns(b);\n\n\tif (ns_cmp(nsa, nsb) <= 0)\n\t\treturn &nsa->labels;\n\treturn &nsb->labels;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_newest_label",
          "args": [
            "b"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "393-414",
          "snippet": "static inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_is_stale",
          "args": [
            "b"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_is_stale",
          "args": [
            "a"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!b"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!a"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_find_merge(struct aa_label *a, struct aa_label *b)\n{\n\tstruct aa_labelset *ls;\n\tstruct aa_label *label, *ar = NULL, *br = NULL;\n\tunsigned long flags;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (label_is_stale(a))\n\t\ta = ar = aa_get_newest_label(a);\n\tif (label_is_stale(b))\n\t\tb = br = aa_get_newest_label(b);\n\tls = labelset_of_merge(a, b);\n\tread_lock_irqsave(&ls->lock, flags);\n\tlabel = __label_find_merge(ls, a, b);\n\tread_unlock_irqrestore(&ls->lock, flags);\n\taa_put_label(ar);\n\taa_put_label(br);\n\n\treturn label;\n}"
  },
  {
    "function_name": "__label_find_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1117-1145",
    "snippet": "static struct aa_label *__label_find_merge(struct aa_labelset *ls,\n\t\t\t\t\t   struct aa_label *a,\n\t\t\t\t\t   struct aa_label *b)\n{\n\tstruct rb_node *node;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn __label_find(a);\n\n\tnode  = ls->root.rb_node;\n\twhile (node) {\n\t\tstruct aa_label *this = container_of(node, struct aa_label,\n\t\t\t\t\t\t     node);\n\t\tint result = label_merge_cmp(a, b, this);\n\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn __aa_get_label(this);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__aa_get_label",
          "args": [
            "this"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_get_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "348-354",
          "snippet": "static inline struct aa_label *__aa_get_label(struct aa_label *l)\n{\n\tif (l && kref_get_unless_zero(&l->count))\n\t\treturn l;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *__aa_get_label(struct aa_label *l)\n{\n\tif (l && kref_get_unless_zero(&l->count))\n\t\treturn l;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_merge_cmp",
          "args": [
            "a",
            "b",
            "this"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "label_merge_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "980-1005",
          "snippet": "static int label_merge_cmp(struct aa_label *a, struct aa_label *b,\n\t\t\t   struct aa_label *z)\n{\n\tstruct aa_profile *p = NULL;\n\tstruct label_it i = { };\n\tint k;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!z);\n\n\tfor (k = 0;\n\t     k < z->size && (p = aa_label_next_in_merge(&i, a, b));\n\t     k++) {\n\t\tint res = profile_cmp(p, z->vec[k]);\n\n\t\tif (res != 0)\n\t\t\treturn res;\n\t}\n\n\tif (p)\n\t\treturn 1;\n\telse if (k < z->size)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int label_merge_cmp(struct aa_label *a, struct aa_label *b,\n\t\t\t   struct aa_label *z)\n{\n\tstruct aa_profile *p = NULL;\n\tstruct label_it i = { };\n\tint k;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!z);\n\n\tfor (k = 0;\n\t     k < z->size && (p = aa_label_next_in_merge(&i, a, b));\n\t     k++) {\n\t\tint res = profile_cmp(p, z->vec[k]);\n\n\t\tif (res != 0)\n\t\t\treturn res;\n\t}\n\n\tif (p)\n\t\treturn 1;\n\telse if (k < z->size)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structaa_label",
            "node"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_find",
          "args": [
            "a"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "__label_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "732-737",
          "snippet": "static struct aa_label *__label_find(struct aa_label *label)\n{\n\tAA_BUG(!label);\n\n\treturn __vec_find(label->vec, label->size);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__label_find(struct aa_label *label)\n{\n\tAA_BUG(!label);\n\n\treturn __vec_find(label->vec, label->size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!b"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!a"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ls"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__label_find_merge(struct aa_labelset *ls,\n\t\t\t\t\t   struct aa_label *a,\n\t\t\t\t\t   struct aa_label *b)\n{\n\tstruct rb_node *node;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn __label_find(a);\n\n\tnode  = ls->root.rb_node;\n\twhile (node) {\n\t\tstruct aa_label *this = container_of(node, struct aa_label,\n\t\t\t\t\t\t     node);\n\t\tint result = label_merge_cmp(a, b, this);\n\n\t\tif (result < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result > 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn __aa_get_label(this);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "labelset_of_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1095-1104",
    "snippet": "static struct aa_labelset *labelset_of_merge(struct aa_label *a,\n\t\t\t\t\t     struct aa_label *b)\n{\n\tstruct aa_ns *nsa = labels_ns(a);\n\tstruct aa_ns *nsb = labels_ns(b);\n\n\tif (ns_cmp(nsa, nsb) <= 0)\n\t\treturn &nsa->labels;\n\treturn &nsb->labels;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_cmp",
          "args": [
            "nsa",
            "nsb"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "ns_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "111-128",
          "snippet": "static int ns_cmp(struct aa_ns *a, struct aa_ns *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b)\n\t\treturn 0;\n\n\tres = a->level - b->level;\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int ns_cmp(struct aa_ns *a, struct aa_ns *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b)\n\t\treturn 0;\n\n\tres = a->level - b->level;\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "b"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "a"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_labelset *labelset_of_merge(struct aa_label *a,\n\t\t\t\t\t     struct aa_label *b)\n{\n\tstruct aa_ns *nsa = labels_ns(a);\n\tstruct aa_ns *nsb = labels_ns(b);\n\n\tif (ns_cmp(nsa, nsb) <= 0)\n\t\treturn &nsa->labels;\n\treturn &nsb->labels;\n}"
  },
  {
    "function_name": "label_merge_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "1024-1086",
    "snippet": "static struct aa_label *label_merge_insert(struct aa_label *new,\n\t\t\t\t\t   struct aa_label *a,\n\t\t\t\t\t   struct aa_label *b)\n{\n\tstruct aa_label *label;\n\tstruct aa_labelset *ls;\n\tstruct aa_profile *next;\n\tstruct label_it i;\n\tunsigned long flags;\n\tint k = 0, invcount = 0;\n\tbool stale = false;\n\n\tAA_BUG(!a);\n\tAA_BUG(a->size < 0);\n\tAA_BUG(!b);\n\tAA_BUG(b->size < 0);\n\tAA_BUG(!new);\n\tAA_BUG(new->size < a->size + b->size);\n\n\tlabel_for_each_in_merge(i, a, b, next) {\n\t\tAA_BUG(!next);\n\t\tif (profile_is_stale(next)) {\n\t\t\tnew->vec[k] = aa_get_newest_profile(next);\n\t\t\tAA_BUG(!new->vec[k]->label.proxy);\n\t\t\tAA_BUG(!new->vec[k]->label.proxy->label);\n\t\t\tif (next->label.proxy != new->vec[k]->label.proxy)\n\t\t\t\tinvcount++;\n\t\t\tk++;\n\t\t\tstale = true;\n\t\t} else\n\t\t\tnew->vec[k++] = aa_get_profile(next);\n\t}\n\t/* set to actual size which is <= allocated len */\n\tnew->size = k;\n\tnew->vec[k] = NULL;\n\n\tif (invcount) {\n\t\tnew->size -= aa_vec_unique(&new->vec[0], new->size,\n\t\t\t\t\t   VEC_FLAG_TERMINATE);\n\t\t/* TODO: deal with reference labels */\n\t\tif (new->size == 1) {\n\t\t\tlabel = aa_get_label(&new->vec[0]->label);\n\t\t\treturn label;\n\t\t}\n\t} else if (!stale) {\n\t\t/*\n\t\t * merge could be same as a || b, note: it is not possible\n\t\t * for new->size == a->size == b->size unless a == b\n\t\t */\n\t\tif (k == a->size)\n\t\t\treturn aa_get_label(a);\n\t\telse if (k == b->size)\n\t\t\treturn aa_get_label(b);\n\t}\n\tif (vec_unconfined(new->vec, new->size))\n\t\tnew->flags |= FLAG_UNCONFINED;\n\tls = labels_set(new);\n\twrite_lock_irqsave(&ls->lock, flags);\n\tlabel = __label_insert(labels_set(new), new, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_insert",
          "args": [
            "labels_set(new)",
            "new",
            "false"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "__label_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "640-683",
          "snippet": "static struct aa_label *__label_insert(struct aa_labelset *ls,\n\t\t\t\t       struct aa_label *label, bool replace)\n{\n\tstruct rb_node **new, *parent = NULL;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tAA_BUG(labels_set(label) != ls);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(label->flags & FLAG_IN_TREE);\n\n\t/* Figure out where to put new node */\n\tnew = &ls->root.rb_node;\n\twhile (*new) {\n\t\tstruct aa_label *this = rb_entry(*new, struct aa_label, node);\n\t\tint result = label_cmp(label, this);\n\n\t\tparent = *new;\n\t\tif (result == 0) {\n\t\t\t/* !__aa_get_label means queued for destruction,\n\t\t\t * so replace in place, however the label has\n\t\t\t * died before the replacement so do not share\n\t\t\t * the proxy\n\t\t\t */\n\t\t\tif (!replace && !label_is_stale(this)) {\n\t\t\t\tif (__aa_get_label(this))\n\t\t\t\t\treturn this;\n\t\t\t} else\n\t\t\t\t__proxy_share(this, label);\n\t\t\tAA_BUG(!__label_replace(this, label));\n\t\t\treturn aa_get_label(label);\n\t\t} else if (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse /* (result > 0) */\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&label->node, parent, new);\n\trb_insert_color(&label->node, &ls->root);\n\tlabel->flags |= FLAG_IN_TREE;\n\n\treturn aa_get_label(label);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__label_insert(struct aa_labelset *ls,\n\t\t\t\t       struct aa_label *label, bool replace)\n{\n\tstruct rb_node **new, *parent = NULL;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tAA_BUG(labels_set(label) != ls);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(label->flags & FLAG_IN_TREE);\n\n\t/* Figure out where to put new node */\n\tnew = &ls->root.rb_node;\n\twhile (*new) {\n\t\tstruct aa_label *this = rb_entry(*new, struct aa_label, node);\n\t\tint result = label_cmp(label, this);\n\n\t\tparent = *new;\n\t\tif (result == 0) {\n\t\t\t/* !__aa_get_label means queued for destruction,\n\t\t\t * so replace in place, however the label has\n\t\t\t * died before the replacement so do not share\n\t\t\t * the proxy\n\t\t\t */\n\t\t\tif (!replace && !label_is_stale(this)) {\n\t\t\t\tif (__aa_get_label(this))\n\t\t\t\t\treturn this;\n\t\t\t} else\n\t\t\t\t__proxy_share(this, label);\n\t\t\tAA_BUG(!__label_replace(this, label));\n\t\t\treturn aa_get_label(label);\n\t\t} else if (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse /* (result > 0) */\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&label->node, parent, new);\n\trb_insert_color(&label->node, &ls->root);\n\tlabel->flags |= FLAG_IN_TREE;\n\n\treturn aa_get_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "new"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "new"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vec_unconfined",
          "args": [
            "new->vec",
            "new->size"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "vec_unconfined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "204-216",
          "snippet": "static bool vec_unconfined(struct aa_profile **vec, int n)\n{\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (!profile_unconfined(vec[i]))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic bool vec_unconfined(struct aa_profile **vec, int n)\n{\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (!profile_unconfined(vec[i]))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "b"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_vec_unique",
          "args": [
            "&new->vec[0]",
            "new->size",
            "VEC_FLAG_TERMINATE"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "aa_vec_unique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "266-313",
          "snippet": "int aa_vec_unique(struct aa_profile **vec, int n, int flags)\n{\n\tint i, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\t/* vecs are usually small and inorder, have a fallback for larger */\n\tif (n > 8) {\n\t\tsort(vec, n, sizeof(struct aa_profile *), sort_cmp, NULL);\n\t\tdups = unique(vec, n);\n\t\tgoto out;\n\t}\n\n\t/* insertion sort + unique in one */\n\tfor (i = 1; i < n; i++) {\n\t\tstruct aa_profile *tmp = vec[i];\n\t\tint pos, j;\n\n\t\tfor (pos = i - 1 - dups; pos >= 0; pos--) {\n\t\t\tint res = profile_cmp(vec[pos], tmp);\n\n\t\t\tif (res == 0) {\n\t\t\t\t/* drop duplicate entry */\n\t\t\t\taa_put_profile(tmp);\n\t\t\t\tdups++;\n\t\t\t\tgoto continue_outer;\n\t\t\t} else if (res < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* pos is at entry < tmp, or index -1. Set to insert pos */\n\t\tpos++;\n\n\t\tfor (j = i - dups; j > pos; j--)\n\t\t\tvec[j] = vec[j - 1];\n\t\tvec[pos] = tmp;\ncontinue_outer:\n\t\t;\n\t}\n\n\tAA_BUG(dups < 0);\n\nout:\n\tif (flags & VEC_FLAG_TERMINATE)\n\t\tvec[n - dups] = NULL;\n\n\treturn dups;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_vec_unique(struct aa_profile **vec, int n, int flags)\n{\n\tint i, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\t/* vecs are usually small and inorder, have a fallback for larger */\n\tif (n > 8) {\n\t\tsort(vec, n, sizeof(struct aa_profile *), sort_cmp, NULL);\n\t\tdups = unique(vec, n);\n\t\tgoto out;\n\t}\n\n\t/* insertion sort + unique in one */\n\tfor (i = 1; i < n; i++) {\n\t\tstruct aa_profile *tmp = vec[i];\n\t\tint pos, j;\n\n\t\tfor (pos = i - 1 - dups; pos >= 0; pos--) {\n\t\t\tint res = profile_cmp(vec[pos], tmp);\n\n\t\t\tif (res == 0) {\n\t\t\t\t/* drop duplicate entry */\n\t\t\t\taa_put_profile(tmp);\n\t\t\t\tdups++;\n\t\t\t\tgoto continue_outer;\n\t\t\t} else if (res < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* pos is at entry < tmp, or index -1. Set to insert pos */\n\t\tpos++;\n\n\t\tfor (j = i - dups; j > pos; j--)\n\t\t\tvec[j] = vec[j - 1];\n\t\tvec[pos] = tmp;\ncontinue_outer:\n\t\t;\n\t}\n\n\tAA_BUG(dups < 0);\n\nout:\n\tif (flags & VEC_FLAG_TERMINATE)\n\t\tvec[n - dups] = NULL;\n\n\treturn dups;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_profile",
          "args": [
            "next"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_profile_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "260-271",
          "snippet": "static inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!new->vec[k]->label.proxy->label"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!new->vec[k]->label.proxy"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_newest_profile",
          "args": [
            "next"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "207-210",
          "snippet": "static inline struct aa_profile *aa_get_newest_profile(struct aa_profile *p)\n{\n\treturn labels_profile(aa_get_newest_label(&p->label));\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline struct aa_profile *aa_get_newest_profile(struct aa_profile *p)\n{\n\treturn labels_profile(aa_get_newest_label(&p->label));\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_is_stale",
          "args": [
            "next"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!next"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_for_each_in_merge",
          "args": [
            "i",
            "a",
            "b",
            "next"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "new->size < a->size + b->size"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!new"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "b->size < 0"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!b"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "a->size < 0"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!a"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *label_merge_insert(struct aa_label *new,\n\t\t\t\t\t   struct aa_label *a,\n\t\t\t\t\t   struct aa_label *b)\n{\n\tstruct aa_label *label;\n\tstruct aa_labelset *ls;\n\tstruct aa_profile *next;\n\tstruct label_it i;\n\tunsigned long flags;\n\tint k = 0, invcount = 0;\n\tbool stale = false;\n\n\tAA_BUG(!a);\n\tAA_BUG(a->size < 0);\n\tAA_BUG(!b);\n\tAA_BUG(b->size < 0);\n\tAA_BUG(!new);\n\tAA_BUG(new->size < a->size + b->size);\n\n\tlabel_for_each_in_merge(i, a, b, next) {\n\t\tAA_BUG(!next);\n\t\tif (profile_is_stale(next)) {\n\t\t\tnew->vec[k] = aa_get_newest_profile(next);\n\t\t\tAA_BUG(!new->vec[k]->label.proxy);\n\t\t\tAA_BUG(!new->vec[k]->label.proxy->label);\n\t\t\tif (next->label.proxy != new->vec[k]->label.proxy)\n\t\t\t\tinvcount++;\n\t\t\tk++;\n\t\t\tstale = true;\n\t\t} else\n\t\t\tnew->vec[k++] = aa_get_profile(next);\n\t}\n\t/* set to actual size which is <= allocated len */\n\tnew->size = k;\n\tnew->vec[k] = NULL;\n\n\tif (invcount) {\n\t\tnew->size -= aa_vec_unique(&new->vec[0], new->size,\n\t\t\t\t\t   VEC_FLAG_TERMINATE);\n\t\t/* TODO: deal with reference labels */\n\t\tif (new->size == 1) {\n\t\t\tlabel = aa_get_label(&new->vec[0]->label);\n\t\t\treturn label;\n\t\t}\n\t} else if (!stale) {\n\t\t/*\n\t\t * merge could be same as a || b, note: it is not possible\n\t\t * for new->size == a->size == b->size unless a == b\n\t\t */\n\t\tif (k == a->size)\n\t\t\treturn aa_get_label(a);\n\t\telse if (k == b->size)\n\t\t\treturn aa_get_label(b);\n\t}\n\tif (vec_unconfined(new->vec, new->size))\n\t\tnew->flags |= FLAG_UNCONFINED;\n\tls = labels_set(new);\n\twrite_lock_irqsave(&ls->lock, flags);\n\tlabel = __label_insert(labels_set(new), new, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}"
  },
  {
    "function_name": "label_merge_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "980-1005",
    "snippet": "static int label_merge_cmp(struct aa_label *a, struct aa_label *b,\n\t\t\t   struct aa_label *z)\n{\n\tstruct aa_profile *p = NULL;\n\tstruct label_it i = { };\n\tint k;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!z);\n\n\tfor (k = 0;\n\t     k < z->size && (p = aa_label_next_in_merge(&i, a, b));\n\t     k++) {\n\t\tint res = profile_cmp(p, z->vec[k]);\n\n\t\tif (res != 0)\n\t\t\treturn res;\n\t}\n\n\tif (p)\n\t\treturn 1;\n\telse if (k < z->size)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_cmp",
          "args": [
            "p",
            "z->vec[k]"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "profile_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "139-157",
          "snippet": "static int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_next_in_merge",
          "args": [
            "&i",
            "a",
            "b"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_next_in_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "937-966",
          "snippet": "struct aa_profile *aa_label_next_in_merge(struct label_it *I,\n\t\t\t\t\t  struct aa_label *a,\n\t\t\t\t\t  struct aa_label *b)\n{\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!I);\n\tAA_BUG(I->i < 0);\n\tAA_BUG(I->i > a->size);\n\tAA_BUG(I->j < 0);\n\tAA_BUG(I->j > b->size);\n\n\tif (I->i < a->size) {\n\t\tif (I->j < b->size) {\n\t\t\tint res = profile_cmp(a->vec[I->i], b->vec[I->j]);\n\n\t\t\tif (res > 0)\n\t\t\t\treturn b->vec[(I->j)++];\n\t\t\tif (res == 0)\n\t\t\t\t(I->j)++;\n\t\t}\n\n\t\treturn a->vec[(I->i)++];\n\t}\n\n\tif (I->j < b->size)\n\t\treturn b->vec[(I->j)++];\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_profile *aa_label_next_in_merge(struct label_it *I,\n\t\t\t\t\t  struct aa_label *a,\n\t\t\t\t\t  struct aa_label *b)\n{\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!I);\n\tAA_BUG(I->i < 0);\n\tAA_BUG(I->i > a->size);\n\tAA_BUG(I->j < 0);\n\tAA_BUG(I->j > b->size);\n\n\tif (I->i < a->size) {\n\t\tif (I->j < b->size) {\n\t\t\tint res = profile_cmp(a->vec[I->i], b->vec[I->j]);\n\n\t\t\tif (res > 0)\n\t\t\t\treturn b->vec[(I->j)++];\n\t\t\tif (res == 0)\n\t\t\t\t(I->j)++;\n\t\t}\n\n\t\treturn a->vec[(I->i)++];\n\t}\n\n\tif (I->j < b->size)\n\t\treturn b->vec[(I->j)++];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!z"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!b"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!a"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int label_merge_cmp(struct aa_label *a, struct aa_label *b,\n\t\t\t   struct aa_label *z)\n{\n\tstruct aa_profile *p = NULL;\n\tstruct label_it i = { };\n\tint k;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!z);\n\n\tfor (k = 0;\n\t     k < z->size && (p = aa_label_next_in_merge(&i, a, b));\n\t     k++) {\n\t\tint res = profile_cmp(p, z->vec[k]);\n\n\t\tif (res != 0)\n\t\t\treturn res;\n\t}\n\n\tif (p)\n\t\treturn 1;\n\telse if (k < z->size)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "aa_label_next_in_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "937-966",
    "snippet": "struct aa_profile *aa_label_next_in_merge(struct label_it *I,\n\t\t\t\t\t  struct aa_label *a,\n\t\t\t\t\t  struct aa_label *b)\n{\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!I);\n\tAA_BUG(I->i < 0);\n\tAA_BUG(I->i > a->size);\n\tAA_BUG(I->j < 0);\n\tAA_BUG(I->j > b->size);\n\n\tif (I->i < a->size) {\n\t\tif (I->j < b->size) {\n\t\t\tint res = profile_cmp(a->vec[I->i], b->vec[I->j]);\n\n\t\t\tif (res > 0)\n\t\t\t\treturn b->vec[(I->j)++];\n\t\t\tif (res == 0)\n\t\t\t\t(I->j)++;\n\t\t}\n\n\t\treturn a->vec[(I->i)++];\n\t}\n\n\tif (I->j < b->size)\n\t\treturn b->vec[(I->j)++];\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_cmp",
          "args": [
            "a->vec[I->i]",
            "b->vec[I->j]"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "profile_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "139-157",
          "snippet": "static int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "I->j > b->size"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "I->j < 0"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "I->i > a->size"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "I->i < 0"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!I"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!b"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!a"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_profile *aa_label_next_in_merge(struct label_it *I,\n\t\t\t\t\t  struct aa_label *a,\n\t\t\t\t\t  struct aa_label *b)\n{\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!I);\n\tAA_BUG(I->i < 0);\n\tAA_BUG(I->i > a->size);\n\tAA_BUG(I->j < 0);\n\tAA_BUG(I->j > b->size);\n\n\tif (I->i < a->size) {\n\t\tif (I->j < b->size) {\n\t\t\tint res = profile_cmp(a->vec[I->i], b->vec[I->j]);\n\n\t\t\tif (res > 0)\n\t\t\t\treturn b->vec[(I->j)++];\n\t\t\tif (res == 0)\n\t\t\t\t(I->j)++;\n\t\t}\n\n\t\treturn a->vec[(I->i)++];\n\t}\n\n\tif (I->j < b->size)\n\t\treturn b->vec[(I->j)++];\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "aa_label_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "903-925",
    "snippet": "struct aa_label *aa_label_insert(struct aa_labelset *ls, struct aa_label *label)\n{\n\tstruct aa_label *l;\n\tunsigned long flags;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\n\t/* check if label exists before taking lock */\n\tif (!label_is_stale(label)) {\n\t\tread_lock_irqsave(&ls->lock, flags);\n\t\tl = __label_find(label);\n\t\tread_unlock_irqrestore(&ls->lock, flags);\n\t\tif (l)\n\t\t\treturn l;\n\t}\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tl = __label_insert(ls, label, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn l;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_insert",
          "args": [
            "ls",
            "label",
            "false"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "__label_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "640-683",
          "snippet": "static struct aa_label *__label_insert(struct aa_labelset *ls,\n\t\t\t\t       struct aa_label *label, bool replace)\n{\n\tstruct rb_node **new, *parent = NULL;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tAA_BUG(labels_set(label) != ls);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(label->flags & FLAG_IN_TREE);\n\n\t/* Figure out where to put new node */\n\tnew = &ls->root.rb_node;\n\twhile (*new) {\n\t\tstruct aa_label *this = rb_entry(*new, struct aa_label, node);\n\t\tint result = label_cmp(label, this);\n\n\t\tparent = *new;\n\t\tif (result == 0) {\n\t\t\t/* !__aa_get_label means queued for destruction,\n\t\t\t * so replace in place, however the label has\n\t\t\t * died before the replacement so do not share\n\t\t\t * the proxy\n\t\t\t */\n\t\t\tif (!replace && !label_is_stale(this)) {\n\t\t\t\tif (__aa_get_label(this))\n\t\t\t\t\treturn this;\n\t\t\t} else\n\t\t\t\t__proxy_share(this, label);\n\t\t\tAA_BUG(!__label_replace(this, label));\n\t\t\treturn aa_get_label(label);\n\t\t} else if (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse /* (result > 0) */\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&label->node, parent, new);\n\trb_insert_color(&label->node, &ls->root);\n\tlabel->flags |= FLAG_IN_TREE;\n\n\treturn aa_get_label(label);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__label_insert(struct aa_labelset *ls,\n\t\t\t\t       struct aa_label *label, bool replace)\n{\n\tstruct rb_node **new, *parent = NULL;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tAA_BUG(labels_set(label) != ls);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(label->flags & FLAG_IN_TREE);\n\n\t/* Figure out where to put new node */\n\tnew = &ls->root.rb_node;\n\twhile (*new) {\n\t\tstruct aa_label *this = rb_entry(*new, struct aa_label, node);\n\t\tint result = label_cmp(label, this);\n\n\t\tparent = *new;\n\t\tif (result == 0) {\n\t\t\t/* !__aa_get_label means queued for destruction,\n\t\t\t * so replace in place, however the label has\n\t\t\t * died before the replacement so do not share\n\t\t\t * the proxy\n\t\t\t */\n\t\t\tif (!replace && !label_is_stale(this)) {\n\t\t\t\tif (__aa_get_label(this))\n\t\t\t\t\treturn this;\n\t\t\t} else\n\t\t\t\t__proxy_share(this, label);\n\t\t\tAA_BUG(!__label_replace(this, label));\n\t\t\treturn aa_get_label(label);\n\t\t} else if (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse /* (result > 0) */\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&label->node, parent, new);\n\trb_insert_color(&label->node, &ls->root);\n\tlabel->flags |= FLAG_IN_TREE;\n\n\treturn aa_get_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_find",
          "args": [
            "label"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "__label_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "732-737",
          "snippet": "static struct aa_label *__label_find(struct aa_label *label)\n{\n\tAA_BUG(!label);\n\n\treturn __vec_find(label->vec, label->size);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__label_find(struct aa_label *label)\n{\n\tAA_BUG(!label);\n\n\treturn __vec_find(label->vec, label->size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_is_stale",
          "args": [
            "label"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ls"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_insert(struct aa_labelset *ls, struct aa_label *label)\n{\n\tstruct aa_label *l;\n\tunsigned long flags;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\n\t/* check if label exists before taking lock */\n\tif (!label_is_stale(label)) {\n\t\tread_lock_irqsave(&ls->lock, flags);\n\t\tl = __label_find(label);\n\t\tread_unlock_irqrestore(&ls->lock, flags);\n\t\tif (l)\n\t\t\treturn l;\n\t}\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tl = __label_insert(ls, label, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn l;\n}"
  },
  {
    "function_name": "aa_label_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "885-890",
    "snippet": "struct aa_label *aa_label_find(struct aa_label *label)\n{\n\tAA_BUG(!label);\n\n\treturn vec_find(label->vec, label->size);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vec_find",
          "args": [
            "label->vec",
            "label->size"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "vec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "811-827",
          "snippet": "static struct aa_label *vec_find(struct aa_profile **vec, int n)\n{\n\tstruct aa_labelset *ls;\n\tstruct aa_label *label;\n\tunsigned long flags;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tls = vec_labelset(vec, n);\n\tread_lock_irqsave(&ls->lock, flags);\n\tlabel = __vec_find(vec, n);\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *vec_find(struct aa_profile **vec, int n)\n{\n\tstruct aa_labelset *ls;\n\tstruct aa_label *label;\n\tunsigned long flags;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tls = vec_labelset(vec, n);\n\tread_lock_irqsave(&ls->lock, flags);\n\tlabel = __vec_find(vec, n);\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_find(struct aa_label *label)\n{\n\tAA_BUG(!label);\n\n\treturn vec_find(label->vec, label->size);\n}"
  },
  {
    "function_name": "aa_vec_find_or_create_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "864-873",
    "snippet": "struct aa_label *aa_vec_find_or_create_label(struct aa_profile **vec, int len,\n\t\t\t\t\t     gfp_t gfp)\n{\n\tstruct aa_label *label = vec_find(vec, len);\n\n\tif (label)\n\t\treturn label;\n\n\treturn vec_create_and_insert_label(vec, len, gfp);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vec_create_and_insert_label",
          "args": [
            "vec",
            "len",
            "gfp"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "vec_create_and_insert_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "830-862",
          "snippet": "static struct aa_label *vec_create_and_insert_label(struct aa_profile **vec,\n\t\t\t\t\t\t    int len, gfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\tstruct aa_labelset *ls;\n\tunsigned long flags;\n\tstruct aa_label *new;\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tif (len == 1)\n\t\treturn aa_get_label(&vec[0]->label);\n\n\tls = labels_set(&vec[len - 1]->label);\n\n\t/* TODO: enable when read side is lockless\n\t * check if label exists before taking locks\n\t */\n\tnew = aa_label_alloc(len, NULL, gfp);\n\tif (!new)\n\t\treturn NULL;\n\n\tfor (i = 0; i < len; i++)\n\t\tnew->vec[i] = aa_get_profile(vec[i]);\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tlabel = __label_insert(ls, new, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\tlabel_free_or_put_new(label, new);\n\n\treturn label;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *vec_create_and_insert_label(struct aa_profile **vec,\n\t\t\t\t\t\t    int len, gfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\tstruct aa_labelset *ls;\n\tunsigned long flags;\n\tstruct aa_label *new;\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tif (len == 1)\n\t\treturn aa_get_label(&vec[0]->label);\n\n\tls = labels_set(&vec[len - 1]->label);\n\n\t/* TODO: enable when read side is lockless\n\t * check if label exists before taking locks\n\t */\n\tnew = aa_label_alloc(len, NULL, gfp);\n\tif (!new)\n\t\treturn NULL;\n\n\tfor (i = 0; i < len; i++)\n\t\tnew->vec[i] = aa_get_profile(vec[i]);\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tlabel = __label_insert(ls, new, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\tlabel_free_or_put_new(label, new);\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vec_find",
          "args": [
            "vec",
            "len"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "vec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "811-827",
          "snippet": "static struct aa_label *vec_find(struct aa_profile **vec, int n)\n{\n\tstruct aa_labelset *ls;\n\tstruct aa_label *label;\n\tunsigned long flags;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tls = vec_labelset(vec, n);\n\tread_lock_irqsave(&ls->lock, flags);\n\tlabel = __vec_find(vec, n);\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *vec_find(struct aa_profile **vec, int n)\n{\n\tstruct aa_labelset *ls;\n\tstruct aa_label *label;\n\tunsigned long flags;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tls = vec_labelset(vec, n);\n\tread_lock_irqsave(&ls->lock, flags);\n\tlabel = __vec_find(vec, n);\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_vec_find_or_create_label(struct aa_profile **vec, int len,\n\t\t\t\t\t     gfp_t gfp)\n{\n\tstruct aa_label *label = vec_find(vec, len);\n\n\tif (label)\n\t\treturn label;\n\n\treturn vec_create_and_insert_label(vec, len, gfp);\n}"
  },
  {
    "function_name": "vec_create_and_insert_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "830-862",
    "snippet": "static struct aa_label *vec_create_and_insert_label(struct aa_profile **vec,\n\t\t\t\t\t\t    int len, gfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\tstruct aa_labelset *ls;\n\tunsigned long flags;\n\tstruct aa_label *new;\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tif (len == 1)\n\t\treturn aa_get_label(&vec[0]->label);\n\n\tls = labels_set(&vec[len - 1]->label);\n\n\t/* TODO: enable when read side is lockless\n\t * check if label exists before taking locks\n\t */\n\tnew = aa_label_alloc(len, NULL, gfp);\n\tif (!new)\n\t\treturn NULL;\n\n\tfor (i = 0; i < len; i++)\n\t\tnew->vec[i] = aa_get_profile(vec[i]);\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tlabel = __label_insert(ls, new, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\tlabel_free_or_put_new(label, new);\n\n\treturn label;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "label_free_or_put_new",
          "args": [
            "label",
            "new"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "label_free_or_put_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "396-403",
          "snippet": "static void label_free_or_put_new(struct aa_label *label, struct aa_label *new)\n{\n\tif (label != new)\n\t\t/* need to free directly to break circular ref with proxy */\n\t\taa_label_free(new);\n\telse\n\t\taa_put_label(new);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic void label_free_or_put_new(struct aa_label *label, struct aa_label *new)\n{\n\tif (label != new)\n\t\t/* need to free directly to break circular ref with proxy */\n\t\taa_label_free(new);\n\telse\n\t\taa_put_label(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_insert",
          "args": [
            "ls",
            "new",
            "false"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "__label_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "640-683",
          "snippet": "static struct aa_label *__label_insert(struct aa_labelset *ls,\n\t\t\t\t       struct aa_label *label, bool replace)\n{\n\tstruct rb_node **new, *parent = NULL;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tAA_BUG(labels_set(label) != ls);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(label->flags & FLAG_IN_TREE);\n\n\t/* Figure out where to put new node */\n\tnew = &ls->root.rb_node;\n\twhile (*new) {\n\t\tstruct aa_label *this = rb_entry(*new, struct aa_label, node);\n\t\tint result = label_cmp(label, this);\n\n\t\tparent = *new;\n\t\tif (result == 0) {\n\t\t\t/* !__aa_get_label means queued for destruction,\n\t\t\t * so replace in place, however the label has\n\t\t\t * died before the replacement so do not share\n\t\t\t * the proxy\n\t\t\t */\n\t\t\tif (!replace && !label_is_stale(this)) {\n\t\t\t\tif (__aa_get_label(this))\n\t\t\t\t\treturn this;\n\t\t\t} else\n\t\t\t\t__proxy_share(this, label);\n\t\t\tAA_BUG(!__label_replace(this, label));\n\t\t\treturn aa_get_label(label);\n\t\t} else if (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse /* (result > 0) */\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&label->node, parent, new);\n\trb_insert_color(&label->node, &ls->root);\n\tlabel->flags |= FLAG_IN_TREE;\n\n\treturn aa_get_label(label);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__label_insert(struct aa_labelset *ls,\n\t\t\t\t       struct aa_label *label, bool replace)\n{\n\tstruct rb_node **new, *parent = NULL;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tAA_BUG(labels_set(label) != ls);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(label->flags & FLAG_IN_TREE);\n\n\t/* Figure out where to put new node */\n\tnew = &ls->root.rb_node;\n\twhile (*new) {\n\t\tstruct aa_label *this = rb_entry(*new, struct aa_label, node);\n\t\tint result = label_cmp(label, this);\n\n\t\tparent = *new;\n\t\tif (result == 0) {\n\t\t\t/* !__aa_get_label means queued for destruction,\n\t\t\t * so replace in place, however the label has\n\t\t\t * died before the replacement so do not share\n\t\t\t * the proxy\n\t\t\t */\n\t\t\tif (!replace && !label_is_stale(this)) {\n\t\t\t\tif (__aa_get_label(this))\n\t\t\t\t\treturn this;\n\t\t\t} else\n\t\t\t\t__proxy_share(this, label);\n\t\t\tAA_BUG(!__label_replace(this, label));\n\t\t\treturn aa_get_label(label);\n\t\t} else if (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse /* (result > 0) */\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&label->node, parent, new);\n\trb_insert_color(&label->node, &ls->root);\n\tlabel->flags |= FLAG_IN_TREE;\n\n\treturn aa_get_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_profile",
          "args": [
            "vec[i]"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_profile_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "260-271",
          "snippet": "static inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline struct aa_profile *aa_get_profile_rcu(struct aa_profile __rcu **p)\n{\n\tstruct aa_profile *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*p);\n\t} while (c && !kref_get_unless_zero(&c->label.count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_alloc",
          "args": [
            "len",
            "NULL",
            "gfp"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "431-462",
          "snippet": "struct aa_label *aa_label_alloc(int size, struct aa_proxy *proxy, gfp_t gfp)\n{\n\tstruct aa_label *new;\n\n\tAA_BUG(size < 1);\n\n\t/*  + 1 for null terminator entry on vec */\n\tnew = kzalloc(sizeof(*new) + sizeof(struct aa_profile *) * (size + 1),\n\t\t\tgfp);\n\tAA_DEBUG(\"%s (%p)\\n\", __func__, new);\n\tif (!new)\n\t\tgoto fail;\n\n\tif (!aa_label_init(new, size))\n\t\tgoto fail;\n\n\tif (!proxy) {\n\t\tproxy = aa_alloc_proxy(new, gfp);\n\t\tif (!proxy)\n\t\t\tgoto fail;\n\t} else\n\t\taa_get_proxy(proxy);\n\t/* just set new's proxy, don't redirect proxy here if it was passed in*/\n\tnew->proxy = proxy;\n\n\treturn new;\n\nfail:\n\tkfree(new);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_alloc(int size, struct aa_proxy *proxy, gfp_t gfp)\n{\n\tstruct aa_label *new;\n\n\tAA_BUG(size < 1);\n\n\t/*  + 1 for null terminator entry on vec */\n\tnew = kzalloc(sizeof(*new) + sizeof(struct aa_profile *) * (size + 1),\n\t\t\tgfp);\n\tAA_DEBUG(\"%s (%p)\\n\", __func__, new);\n\tif (!new)\n\t\tgoto fail;\n\n\tif (!aa_label_init(new, size))\n\t\tgoto fail;\n\n\tif (!proxy) {\n\t\tproxy = aa_alloc_proxy(new, gfp);\n\t\tif (!proxy)\n\t\t\tgoto fail;\n\t} else\n\t\taa_get_proxy(proxy);\n\t/* just set new's proxy, don't redirect proxy here if it was passed in*/\n\tnew->proxy = proxy;\n\n\treturn new;\n\nfail:\n\tkfree(new);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "&vec[len - 1]->label"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "&vec[0]->label"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!vec"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *vec_create_and_insert_label(struct aa_profile **vec,\n\t\t\t\t\t\t    int len, gfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\tstruct aa_labelset *ls;\n\tunsigned long flags;\n\tstruct aa_label *new;\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tif (len == 1)\n\t\treturn aa_get_label(&vec[0]->label);\n\n\tls = labels_set(&vec[len - 1]->label);\n\n\t/* TODO: enable when read side is lockless\n\t * check if label exists before taking locks\n\t */\n\tnew = aa_label_alloc(len, NULL, gfp);\n\tif (!new)\n\t\treturn NULL;\n\n\tfor (i = 0; i < len; i++)\n\t\tnew->vec[i] = aa_get_profile(vec[i]);\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tlabel = __label_insert(ls, new, false);\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\tlabel_free_or_put_new(label, new);\n\n\treturn label;\n}"
  },
  {
    "function_name": "vec_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "811-827",
    "snippet": "static struct aa_label *vec_find(struct aa_profile **vec, int n)\n{\n\tstruct aa_labelset *ls;\n\tstruct aa_label *label;\n\tunsigned long flags;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tls = vec_labelset(vec, n);\n\tread_lock_irqsave(&ls->lock, flags);\n\tlabel = __vec_find(vec, n);\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vec_find",
          "args": [
            "vec",
            "n"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "__vec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "697-719",
          "snippet": "static struct aa_label *__vec_find(struct aa_profile **vec, int n)\n{\n\tstruct rb_node *node;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tnode = vec_labelset(vec, n)->root.rb_node;\n\twhile (node) {\n\t\tstruct aa_label *this = rb_entry(node, struct aa_label, node);\n\t\tint result = vec_cmp(this->vec, this->size, vec, n);\n\n\t\tif (result > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn __aa_get_label(this);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__vec_find(struct aa_profile **vec, int n)\n{\n\tstruct rb_node *node;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tnode = vec_labelset(vec, n)->root.rb_node;\n\twhile (node) {\n\t\tstruct aa_label *this = rb_entry(node, struct aa_label, node);\n\t\tint result = vec_cmp(this->vec, this->size, vec, n);\n\n\t\tif (result > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn __aa_get_label(this);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vec_labelset",
          "args": [
            "vec",
            "n"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "n <= 0"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!*vec"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!vec"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *vec_find(struct aa_profile **vec, int n)\n{\n\tstruct aa_labelset *ls;\n\tstruct aa_label *label;\n\tunsigned long flags;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tls = vec_labelset(vec, n);\n\tread_lock_irqsave(&ls->lock, flags);\n\tlabel = __vec_find(vec, n);\n\tread_unlock_irqrestore(&ls->lock, flags);\n\n\treturn label;\n}"
  },
  {
    "function_name": "aa_label_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "770-801",
    "snippet": "bool aa_label_replace(struct aa_label *old, struct aa_label *new)\n{\n\tunsigned long flags;\n\tbool res;\n\n\tif (name_is_shared(old, new) && labels_ns(old) == labels_ns(new)) {\n\t\twrite_lock_irqsave(&labels_set(old)->lock, flags);\n\t\tif (old->proxy != new->proxy)\n\t\t\t__proxy_share(old, new);\n\t\telse\n\t\t\t__aa_proxy_redirect(old, new);\n\t\tres = __label_replace(old, new);\n\t\twrite_unlock_irqrestore(&labels_set(old)->lock, flags);\n\t} else {\n\t\tstruct aa_label *l;\n\t\tstruct aa_labelset *ls = labels_set(old);\n\n\t\twrite_lock_irqsave(&ls->lock, flags);\n\t\tres = __label_remove(old, new);\n\t\tif (labels_ns(old) != labels_ns(new)) {\n\t\t\twrite_unlock_irqrestore(&ls->lock, flags);\n\t\t\tls = labels_set(new);\n\t\t\twrite_lock_irqsave(&ls->lock, flags);\n\t\t}\n\t\tl = __label_insert(ls, new, true);\n\t\tres = (l == new);\n\t\twrite_unlock_irqrestore(&ls->lock, flags);\n\t\taa_put_label(l);\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "l"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_insert",
          "args": [
            "ls",
            "new",
            "true"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "__label_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "640-683",
          "snippet": "static struct aa_label *__label_insert(struct aa_labelset *ls,\n\t\t\t\t       struct aa_label *label, bool replace)\n{\n\tstruct rb_node **new, *parent = NULL;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tAA_BUG(labels_set(label) != ls);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(label->flags & FLAG_IN_TREE);\n\n\t/* Figure out where to put new node */\n\tnew = &ls->root.rb_node;\n\twhile (*new) {\n\t\tstruct aa_label *this = rb_entry(*new, struct aa_label, node);\n\t\tint result = label_cmp(label, this);\n\n\t\tparent = *new;\n\t\tif (result == 0) {\n\t\t\t/* !__aa_get_label means queued for destruction,\n\t\t\t * so replace in place, however the label has\n\t\t\t * died before the replacement so do not share\n\t\t\t * the proxy\n\t\t\t */\n\t\t\tif (!replace && !label_is_stale(this)) {\n\t\t\t\tif (__aa_get_label(this))\n\t\t\t\t\treturn this;\n\t\t\t} else\n\t\t\t\t__proxy_share(this, label);\n\t\t\tAA_BUG(!__label_replace(this, label));\n\t\t\treturn aa_get_label(label);\n\t\t} else if (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse /* (result > 0) */\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&label->node, parent, new);\n\trb_insert_color(&label->node, &ls->root);\n\tlabel->flags |= FLAG_IN_TREE;\n\n\treturn aa_get_label(label);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__label_insert(struct aa_labelset *ls,\n\t\t\t\t       struct aa_label *label, bool replace)\n{\n\tstruct rb_node **new, *parent = NULL;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tAA_BUG(labels_set(label) != ls);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(label->flags & FLAG_IN_TREE);\n\n\t/* Figure out where to put new node */\n\tnew = &ls->root.rb_node;\n\twhile (*new) {\n\t\tstruct aa_label *this = rb_entry(*new, struct aa_label, node);\n\t\tint result = label_cmp(label, this);\n\n\t\tparent = *new;\n\t\tif (result == 0) {\n\t\t\t/* !__aa_get_label means queued for destruction,\n\t\t\t * so replace in place, however the label has\n\t\t\t * died before the replacement so do not share\n\t\t\t * the proxy\n\t\t\t */\n\t\t\tif (!replace && !label_is_stale(this)) {\n\t\t\t\tif (__aa_get_label(this))\n\t\t\t\t\treturn this;\n\t\t\t} else\n\t\t\t\t__proxy_share(this, label);\n\t\t\tAA_BUG(!__label_replace(this, label));\n\t\t\treturn aa_get_label(label);\n\t\t} else if (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse /* (result > 0) */\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&label->node, parent, new);\n\trb_insert_color(&label->node, &ls->root);\n\tlabel->flags |= FLAG_IN_TREE;\n\n\treturn aa_get_label(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "new"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "new"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "old"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_remove",
          "args": [
            "old",
            "new"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "__label_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "568-589",
          "snippet": "static bool __label_remove(struct aa_label *label, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\n\tif (new)\n\t\t__aa_proxy_redirect(label, new);\n\n\tif (!label_is_stale(label))\n\t\t__label_make_stale(label);\n\n\tif (label->flags & FLAG_IN_TREE) {\n\t\trb_erase(&label->node, &ls->root);\n\t\tlabel->flags &= ~FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic bool __label_remove(struct aa_label *label, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\n\tif (new)\n\t\t__aa_proxy_redirect(label, new);\n\n\tif (!label_is_stale(label))\n\t\t__label_make_stale(label);\n\n\tif (label->flags & FLAG_IN_TREE) {\n\t\trb_erase(&label->node, &ls->root);\n\t\tlabel->flags &= ~FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "old"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&labels_set(old)->lock",
            "flags"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "old"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_replace",
          "args": [
            "old",
            "new"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "__label_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "604-625",
          "snippet": "static bool __label_replace(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(old);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!old);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(new->flags & FLAG_IN_TREE);\n\n\tif (!label_is_stale(old))\n\t\t__label_make_stale(old);\n\n\tif (old->flags & FLAG_IN_TREE) {\n\t\trb_replace_node(&old->node, &new->node, &ls->root);\n\t\told->flags &= ~FLAG_IN_TREE;\n\t\tnew->flags |= FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic bool __label_replace(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(old);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!old);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(new->flags & FLAG_IN_TREE);\n\n\tif (!label_is_stale(old))\n\t\t__label_make_stale(old);\n\n\tif (old->flags & FLAG_IN_TREE) {\n\t\trb_replace_node(&old->node, &new->node, &ls->root);\n\t\told->flags &= ~FLAG_IN_TREE;\n\t\tnew->flags |= FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__aa_proxy_redirect",
          "args": [
            "old",
            "new"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_proxy_redirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "77-90",
          "snippet": "void __aa_proxy_redirect(struct aa_label *orig, struct aa_label *new)\n{\n\tstruct aa_label *tmp;\n\n\tAA_BUG(!orig);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&labels_set(orig)->lock);\n\n\ttmp = rcu_dereference_protected(orig->proxy->label,\n\t\t\t\t\t&labels_ns(orig)->lock);\n\trcu_assign_pointer(orig->proxy->label, aa_get_label(new));\n\torig->flags |= FLAG_STALE;\n\taa_put_label(tmp);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid __aa_proxy_redirect(struct aa_label *orig, struct aa_label *new)\n{\n\tstruct aa_label *tmp;\n\n\tAA_BUG(!orig);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&labels_set(orig)->lock);\n\n\ttmp = rcu_dereference_protected(orig->proxy->label,\n\t\t\t\t\t&labels_ns(orig)->lock);\n\trcu_assign_pointer(orig->proxy->label, aa_get_label(new));\n\torig->flags |= FLAG_STALE;\n\taa_put_label(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__proxy_share",
          "args": [
            "old",
            "new"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "__proxy_share",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "92-99",
          "snippet": "static void __proxy_share(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_proxy *proxy = new->proxy;\n\n\tnew->proxy = aa_get_proxy(old->proxy);\n\t__aa_proxy_redirect(old, new);\n\taa_put_proxy(proxy);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic void __proxy_share(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_proxy *proxy = new->proxy;\n\n\tnew->proxy = aa_get_proxy(old->proxy);\n\t__aa_proxy_redirect(old, new);\n\taa_put_proxy(proxy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&labels_set(old)->lock",
            "flags"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "old"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "new"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "old"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_is_shared",
          "args": [
            "old",
            "new"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nbool aa_label_replace(struct aa_label *old, struct aa_label *new)\n{\n\tunsigned long flags;\n\tbool res;\n\n\tif (name_is_shared(old, new) && labels_ns(old) == labels_ns(new)) {\n\t\twrite_lock_irqsave(&labels_set(old)->lock, flags);\n\t\tif (old->proxy != new->proxy)\n\t\t\t__proxy_share(old, new);\n\t\telse\n\t\t\t__aa_proxy_redirect(old, new);\n\t\tres = __label_replace(old, new);\n\t\twrite_unlock_irqrestore(&labels_set(old)->lock, flags);\n\t} else {\n\t\tstruct aa_label *l;\n\t\tstruct aa_labelset *ls = labels_set(old);\n\n\t\twrite_lock_irqsave(&ls->lock, flags);\n\t\tres = __label_remove(old, new);\n\t\tif (labels_ns(old) != labels_ns(new)) {\n\t\t\twrite_unlock_irqrestore(&ls->lock, flags);\n\t\t\tls = labels_set(new);\n\t\t\twrite_lock_irqsave(&ls->lock, flags);\n\t\t}\n\t\tl = __label_insert(ls, new, true);\n\t\tres = (l == new);\n\t\twrite_unlock_irqrestore(&ls->lock, flags);\n\t\taa_put_label(l);\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "aa_label_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "747-760",
    "snippet": "bool aa_label_remove(struct aa_label *label)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\tunsigned long flags;\n\tbool res;\n\n\tAA_BUG(!ls);\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tres = __label_remove(label, ns_unconfined(labels_ns(label)));\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn res;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_remove",
          "args": [
            "label",
            "ns_unconfined(labels_ns(label))"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "__label_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "568-589",
          "snippet": "static bool __label_remove(struct aa_label *label, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\n\tif (new)\n\t\t__aa_proxy_redirect(label, new);\n\n\tif (!label_is_stale(label))\n\t\t__label_make_stale(label);\n\n\tif (label->flags & FLAG_IN_TREE) {\n\t\trb_erase(&label->node, &ls->root);\n\t\tlabel->flags &= ~FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic bool __label_remove(struct aa_label *label, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\n\tif (new)\n\t\t__aa_proxy_redirect(label, new);\n\n\tif (!label_is_stale(label))\n\t\t__label_make_stale(label);\n\n\tif (label->flags & FLAG_IN_TREE) {\n\t\trb_erase(&label->node, &ls->root);\n\t\tlabel->flags &= ~FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_unconfined",
          "args": [
            "labels_ns(label)"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ls->lock",
            "flags"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ls"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "label"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nbool aa_label_remove(struct aa_label *label)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\tunsigned long flags;\n\tbool res;\n\n\tAA_BUG(!ls);\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tres = __label_remove(label, ns_unconfined(labels_ns(label)));\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn res;\n}"
  },
  {
    "function_name": "__label_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "732-737",
    "snippet": "static struct aa_label *__label_find(struct aa_label *label)\n{\n\tAA_BUG(!label);\n\n\treturn __vec_find(label->vec, label->size);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vec_find",
          "args": [
            "label->vec",
            "label->size"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "__vec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "697-719",
          "snippet": "static struct aa_label *__vec_find(struct aa_profile **vec, int n)\n{\n\tstruct rb_node *node;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tnode = vec_labelset(vec, n)->root.rb_node;\n\twhile (node) {\n\t\tstruct aa_label *this = rb_entry(node, struct aa_label, node);\n\t\tint result = vec_cmp(this->vec, this->size, vec, n);\n\n\t\tif (result > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn __aa_get_label(this);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__vec_find(struct aa_profile **vec, int n)\n{\n\tstruct rb_node *node;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tnode = vec_labelset(vec, n)->root.rb_node;\n\twhile (node) {\n\t\tstruct aa_label *this = rb_entry(node, struct aa_label, node);\n\t\tint result = vec_cmp(this->vec, this->size, vec, n);\n\n\t\tif (result > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn __aa_get_label(this);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__label_find(struct aa_label *label)\n{\n\tAA_BUG(!label);\n\n\treturn __vec_find(label->vec, label->size);\n}"
  },
  {
    "function_name": "__vec_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "697-719",
    "snippet": "static struct aa_label *__vec_find(struct aa_profile **vec, int n)\n{\n\tstruct rb_node *node;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tnode = vec_labelset(vec, n)->root.rb_node;\n\twhile (node) {\n\t\tstruct aa_label *this = rb_entry(node, struct aa_label, node);\n\t\tint result = vec_cmp(this->vec, this->size, vec, n);\n\n\t\tif (result > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn __aa_get_label(this);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__aa_get_label",
          "args": [
            "this"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_get_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "348-354",
          "snippet": "static inline struct aa_label *__aa_get_label(struct aa_label *l)\n{\n\tif (l && kref_get_unless_zero(&l->count))\n\t\treturn l;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *__aa_get_label(struct aa_label *l)\n{\n\tif (l && kref_get_unless_zero(&l->count))\n\t\treturn l;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vec_cmp",
          "args": [
            "this->vec",
            "this->size",
            "vec",
            "n"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "vec_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "169-188",
          "snippet": "static int vec_cmp(struct aa_profile **a, int an, struct aa_profile **b, int bn)\n{\n\tint i;\n\n\tAA_BUG(!a);\n\tAA_BUG(!*a);\n\tAA_BUG(!b);\n\tAA_BUG(!*b);\n\tAA_BUG(an <= 0);\n\tAA_BUG(bn <= 0);\n\n\tfor (i = 0; i < an && i < bn; i++) {\n\t\tint res = profile_cmp(a[i], b[i]);\n\n\t\tif (res != 0)\n\t\t\treturn res;\n\t}\n\n\treturn an - bn;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int vec_cmp(struct aa_profile **a, int an, struct aa_profile **b, int bn)\n{\n\tint i;\n\n\tAA_BUG(!a);\n\tAA_BUG(!*a);\n\tAA_BUG(!b);\n\tAA_BUG(!*b);\n\tAA_BUG(an <= 0);\n\tAA_BUG(bn <= 0);\n\n\tfor (i = 0; i < an && i < bn; i++) {\n\t\tint res = profile_cmp(a[i], b[i]);\n\n\t\tif (res != 0)\n\t\t\treturn res;\n\t}\n\n\treturn an - bn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structaa_label",
            "node"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vec_labelset",
          "args": [
            "vec",
            "n"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "n <= 0"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!*vec"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!vec"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__vec_find(struct aa_profile **vec, int n)\n{\n\tstruct rb_node *node;\n\n\tAA_BUG(!vec);\n\tAA_BUG(!*vec);\n\tAA_BUG(n <= 0);\n\n\tnode = vec_labelset(vec, n)->root.rb_node;\n\twhile (node) {\n\t\tstruct aa_label *this = rb_entry(node, struct aa_label, node);\n\t\tint result = vec_cmp(this->vec, this->size, vec, n);\n\n\t\tif (result > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (result < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn __aa_get_label(this);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "__label_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "640-683",
    "snippet": "static struct aa_label *__label_insert(struct aa_labelset *ls,\n\t\t\t\t       struct aa_label *label, bool replace)\n{\n\tstruct rb_node **new, *parent = NULL;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tAA_BUG(labels_set(label) != ls);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(label->flags & FLAG_IN_TREE);\n\n\t/* Figure out where to put new node */\n\tnew = &ls->root.rb_node;\n\twhile (*new) {\n\t\tstruct aa_label *this = rb_entry(*new, struct aa_label, node);\n\t\tint result = label_cmp(label, this);\n\n\t\tparent = *new;\n\t\tif (result == 0) {\n\t\t\t/* !__aa_get_label means queued for destruction,\n\t\t\t * so replace in place, however the label has\n\t\t\t * died before the replacement so do not share\n\t\t\t * the proxy\n\t\t\t */\n\t\t\tif (!replace && !label_is_stale(this)) {\n\t\t\t\tif (__aa_get_label(this))\n\t\t\t\t\treturn this;\n\t\t\t} else\n\t\t\t\t__proxy_share(this, label);\n\t\t\tAA_BUG(!__label_replace(this, label));\n\t\t\treturn aa_get_label(label);\n\t\t} else if (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse /* (result > 0) */\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&label->node, parent, new);\n\trb_insert_color(&label->node, &ls->root);\n\tlabel->flags |= FLAG_IN_TREE;\n\n\treturn aa_get_label(label);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "label"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&label->node",
            "&ls->root"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&label->node",
            "parent",
            "new"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!__label_replace(this, label)"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_replace",
          "args": [
            "this",
            "label"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "__label_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "604-625",
          "snippet": "static bool __label_replace(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(old);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!old);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(new->flags & FLAG_IN_TREE);\n\n\tif (!label_is_stale(old))\n\t\t__label_make_stale(old);\n\n\tif (old->flags & FLAG_IN_TREE) {\n\t\trb_replace_node(&old->node, &new->node, &ls->root);\n\t\told->flags &= ~FLAG_IN_TREE;\n\t\tnew->flags |= FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic bool __label_replace(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(old);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!old);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(new->flags & FLAG_IN_TREE);\n\n\tif (!label_is_stale(old))\n\t\t__label_make_stale(old);\n\n\tif (old->flags & FLAG_IN_TREE) {\n\t\trb_replace_node(&old->node, &new->node, &ls->root);\n\t\told->flags &= ~FLAG_IN_TREE;\n\t\tnew->flags |= FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__proxy_share",
          "args": [
            "this",
            "label"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "__proxy_share",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "92-99",
          "snippet": "static void __proxy_share(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_proxy *proxy = new->proxy;\n\n\tnew->proxy = aa_get_proxy(old->proxy);\n\t__aa_proxy_redirect(old, new);\n\taa_put_proxy(proxy);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic void __proxy_share(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_proxy *proxy = new->proxy;\n\n\tnew->proxy = aa_get_proxy(old->proxy);\n\t__aa_proxy_redirect(old, new);\n\taa_put_proxy(proxy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__aa_get_label",
          "args": [
            "this"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_get_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "348-354",
          "snippet": "static inline struct aa_label *__aa_get_label(struct aa_label *l)\n{\n\tif (l && kref_get_unless_zero(&l->count))\n\t\treturn l;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *__aa_get_label(struct aa_label *l)\n{\n\tif (l && kref_get_unless_zero(&l->count))\n\t\treturn l;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_is_stale",
          "args": [
            "this"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_cmp",
          "args": [
            "label",
            "this"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "label_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "474-482",
          "snippet": "static int label_cmp(struct aa_label *a, struct aa_label *b)\n{\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn 0;\n\n\treturn vec_cmp(a->vec, a->size, b->vec, b->size);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int label_cmp(struct aa_label *a, struct aa_label *b)\n{\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn 0;\n\n\treturn vec_cmp(a->vec, a->size, b->vec, b->size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*new",
            "structaa_label",
            "node"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "label->flags & FLAG_IN_TREE"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held_exclusive",
          "args": [
            "&ls->lock"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "labels_set(label) != ls"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "label"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ls"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic struct aa_label *__label_insert(struct aa_labelset *ls,\n\t\t\t\t       struct aa_label *label, bool replace)\n{\n\tstruct rb_node **new, *parent = NULL;\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tAA_BUG(labels_set(label) != ls);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(label->flags & FLAG_IN_TREE);\n\n\t/* Figure out where to put new node */\n\tnew = &ls->root.rb_node;\n\twhile (*new) {\n\t\tstruct aa_label *this = rb_entry(*new, struct aa_label, node);\n\t\tint result = label_cmp(label, this);\n\n\t\tparent = *new;\n\t\tif (result == 0) {\n\t\t\t/* !__aa_get_label means queued for destruction,\n\t\t\t * so replace in place, however the label has\n\t\t\t * died before the replacement so do not share\n\t\t\t * the proxy\n\t\t\t */\n\t\t\tif (!replace && !label_is_stale(this)) {\n\t\t\t\tif (__aa_get_label(this))\n\t\t\t\t\treturn this;\n\t\t\t} else\n\t\t\t\t__proxy_share(this, label);\n\t\t\tAA_BUG(!__label_replace(this, label));\n\t\t\treturn aa_get_label(label);\n\t\t} else if (result < 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse /* (result > 0) */\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\t/* Add new node and rebalance tree. */\n\trb_link_node(&label->node, parent, new);\n\trb_insert_color(&label->node, &ls->root);\n\tlabel->flags |= FLAG_IN_TREE;\n\n\treturn aa_get_label(label);\n}"
  },
  {
    "function_name": "__label_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "604-625",
    "snippet": "static bool __label_replace(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(old);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!old);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(new->flags & FLAG_IN_TREE);\n\n\tif (!label_is_stale(old))\n\t\t__label_make_stale(old);\n\n\tif (old->flags & FLAG_IN_TREE) {\n\t\trb_replace_node(&old->node, &new->node, &ls->root);\n\t\told->flags &= ~FLAG_IN_TREE;\n\t\tnew->flags |= FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_replace_node",
          "args": [
            "&old->node",
            "&new->node",
            "&ls->root"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_make_stale",
          "args": [
            "old"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_is_stale",
          "args": [
            "old"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "new->flags & FLAG_IN_TREE"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held_exclusive",
          "args": [
            "&ls->lock"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!new"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!old"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ls"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "old"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic bool __label_replace(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(old);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!old);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\tAA_BUG(new->flags & FLAG_IN_TREE);\n\n\tif (!label_is_stale(old))\n\t\t__label_make_stale(old);\n\n\tif (old->flags & FLAG_IN_TREE) {\n\t\trb_replace_node(&old->node, &new->node, &ls->root);\n\t\told->flags &= ~FLAG_IN_TREE;\n\t\tnew->flags |= FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "__label_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "568-589",
    "snippet": "static bool __label_remove(struct aa_label *label, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\n\tif (new)\n\t\t__aa_proxy_redirect(label, new);\n\n\tif (!label_is_stale(label))\n\t\t__label_make_stale(label);\n\n\tif (label->flags & FLAG_IN_TREE) {\n\t\trb_erase(&label->node, &ls->root);\n\t\tlabel->flags &= ~FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&label->node",
            "&ls->root"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__label_make_stale",
          "args": [
            "label"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_is_stale",
          "args": [
            "label"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__aa_proxy_redirect",
          "args": [
            "label",
            "new"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_proxy_redirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "77-90",
          "snippet": "void __aa_proxy_redirect(struct aa_label *orig, struct aa_label *new)\n{\n\tstruct aa_label *tmp;\n\n\tAA_BUG(!orig);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&labels_set(orig)->lock);\n\n\ttmp = rcu_dereference_protected(orig->proxy->label,\n\t\t\t\t\t&labels_ns(orig)->lock);\n\trcu_assign_pointer(orig->proxy->label, aa_get_label(new));\n\torig->flags |= FLAG_STALE;\n\taa_put_label(tmp);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid __aa_proxy_redirect(struct aa_label *orig, struct aa_label *new)\n{\n\tstruct aa_label *tmp;\n\n\tAA_BUG(!orig);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&labels_set(orig)->lock);\n\n\ttmp = rcu_dereference_protected(orig->proxy->label,\n\t\t\t\t\t&labels_ns(orig)->lock);\n\trcu_assign_pointer(orig->proxy->label, aa_get_label(new));\n\torig->flags |= FLAG_STALE;\n\taa_put_label(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held_exclusive",
          "args": [
            "&ls->lock"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!ls"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "label"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic bool __label_remove(struct aa_label *label, struct aa_label *new)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\n\tAA_BUG(!ls);\n\tAA_BUG(!label);\n\tlockdep_assert_held_exclusive(&ls->lock);\n\n\tif (new)\n\t\t__aa_proxy_redirect(label, new);\n\n\tif (!label_is_stale(label))\n\t\t__label_make_stale(label);\n\n\tif (label->flags & FLAG_IN_TREE) {\n\t\trb_erase(&label->node, &ls->root);\n\t\tlabel->flags &= ~FLAG_IN_TREE;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "aa_label_is_subset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "545-556",
    "snippet": "bool aa_label_is_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\treturn __aa_label_next_not_in_set(&i, set, sub) == NULL;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__aa_label_next_not_in_set",
          "args": [
            "&i",
            "set",
            "sub"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_label_next_not_in_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "507-535",
          "snippet": "struct aa_profile *__aa_label_next_not_in_set(struct label_it *I,\n\t\t\t\t\t      struct aa_label *set,\n\t\t\t\t\t      struct aa_label *sub)\n{\n\tAA_BUG(!set);\n\tAA_BUG(!I);\n\tAA_BUG(I->i < 0);\n\tAA_BUG(I->i > set->size);\n\tAA_BUG(!sub);\n\tAA_BUG(I->j < 0);\n\tAA_BUG(I->j > sub->size);\n\n\twhile (I->j < sub->size && I->i < set->size) {\n\t\tint res = profile_cmp(sub->vec[I->j], set->vec[I->i]);\n\n\t\tif (res == 0) {\n\t\t\t(I->j)++;\n\t\t\t(I->i)++;\n\t\t} else if (res > 0)\n\t\t\t(I->i)++;\n\t\telse\n\t\t\treturn sub->vec[(I->j)++];\n\t}\n\n\tif (I->j < sub->size)\n\t\treturn sub->vec[(I->j)++];\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_profile *__aa_label_next_not_in_set(struct label_it *I,\n\t\t\t\t\t      struct aa_label *set,\n\t\t\t\t\t      struct aa_label *sub)\n{\n\tAA_BUG(!set);\n\tAA_BUG(!I);\n\tAA_BUG(I->i < 0);\n\tAA_BUG(I->i > set->size);\n\tAA_BUG(!sub);\n\tAA_BUG(I->j < 0);\n\tAA_BUG(I->j > sub->size);\n\n\twhile (I->j < sub->size && I->i < set->size) {\n\t\tint res = profile_cmp(sub->vec[I->j], set->vec[I->i]);\n\n\t\tif (res == 0) {\n\t\t\t(I->j)++;\n\t\t\t(I->i)++;\n\t\t} else if (res > 0)\n\t\t\t(I->i)++;\n\t\telse\n\t\t\treturn sub->vec[(I->j)++];\n\t}\n\n\tif (I->j < sub->size)\n\t\treturn sub->vec[(I->j)++];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!sub"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!set"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nbool aa_label_is_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\treturn __aa_label_next_not_in_set(&i, set, sub) == NULL;\n}"
  },
  {
    "function_name": "__aa_label_next_not_in_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "507-535",
    "snippet": "struct aa_profile *__aa_label_next_not_in_set(struct label_it *I,\n\t\t\t\t\t      struct aa_label *set,\n\t\t\t\t\t      struct aa_label *sub)\n{\n\tAA_BUG(!set);\n\tAA_BUG(!I);\n\tAA_BUG(I->i < 0);\n\tAA_BUG(I->i > set->size);\n\tAA_BUG(!sub);\n\tAA_BUG(I->j < 0);\n\tAA_BUG(I->j > sub->size);\n\n\twhile (I->j < sub->size && I->i < set->size) {\n\t\tint res = profile_cmp(sub->vec[I->j], set->vec[I->i]);\n\n\t\tif (res == 0) {\n\t\t\t(I->j)++;\n\t\t\t(I->i)++;\n\t\t} else if (res > 0)\n\t\t\t(I->i)++;\n\t\telse\n\t\t\treturn sub->vec[(I->j)++];\n\t}\n\n\tif (I->j < sub->size)\n\t\treturn sub->vec[(I->j)++];\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_cmp",
          "args": [
            "sub->vec[I->j]",
            "set->vec[I->i]"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "profile_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "139-157",
          "snippet": "static int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "I->j > sub->size"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "I->j < 0"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!sub"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "I->i > set->size"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "I->i < 0"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!I"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!set"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_profile *__aa_label_next_not_in_set(struct label_it *I,\n\t\t\t\t\t      struct aa_label *set,\n\t\t\t\t\t      struct aa_label *sub)\n{\n\tAA_BUG(!set);\n\tAA_BUG(!I);\n\tAA_BUG(I->i < 0);\n\tAA_BUG(I->i > set->size);\n\tAA_BUG(!sub);\n\tAA_BUG(I->j < 0);\n\tAA_BUG(I->j > sub->size);\n\n\twhile (I->j < sub->size && I->i < set->size) {\n\t\tint res = profile_cmp(sub->vec[I->j], set->vec[I->i]);\n\n\t\tif (res == 0) {\n\t\t\t(I->j)++;\n\t\t\t(I->i)++;\n\t\t} else if (res > 0)\n\t\t\t(I->i)++;\n\t\telse\n\t\t\treturn sub->vec[(I->j)++];\n\t}\n\n\tif (I->j < sub->size)\n\t\treturn sub->vec[(I->j)++];\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "aa_label_next_confined",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "485-496",
    "snippet": "int aa_label_next_confined(struct aa_label *label, int i)\n{\n\tAA_BUG(!label);\n\tAA_BUG(i < 0);\n\n\tfor (; i < label->size; i++) {\n\t\tif (!profile_unconfined(label->vec[i]))\n\t\t\treturn i;\n\t}\n\n\treturn i;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "label->vec[i]"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "i < 0"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_label_next_confined(struct aa_label *label, int i)\n{\n\tAA_BUG(!label);\n\tAA_BUG(i < 0);\n\n\tfor (; i < label->size; i++) {\n\t\tif (!profile_unconfined(label->vec[i]))\n\t\t\treturn i;\n\t}\n\n\treturn i;\n}"
  },
  {
    "function_name": "label_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "474-482",
    "snippet": "static int label_cmp(struct aa_label *a, struct aa_label *b)\n{\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn 0;\n\n\treturn vec_cmp(a->vec, a->size, b->vec, b->size);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vec_cmp",
          "args": [
            "a->vec",
            "a->size",
            "b->vec",
            "b->size"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "vec_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "169-188",
          "snippet": "static int vec_cmp(struct aa_profile **a, int an, struct aa_profile **b, int bn)\n{\n\tint i;\n\n\tAA_BUG(!a);\n\tAA_BUG(!*a);\n\tAA_BUG(!b);\n\tAA_BUG(!*b);\n\tAA_BUG(an <= 0);\n\tAA_BUG(bn <= 0);\n\n\tfor (i = 0; i < an && i < bn; i++) {\n\t\tint res = profile_cmp(a[i], b[i]);\n\n\t\tif (res != 0)\n\t\t\treturn res;\n\t}\n\n\treturn an - bn;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int vec_cmp(struct aa_profile **a, int an, struct aa_profile **b, int bn)\n{\n\tint i;\n\n\tAA_BUG(!a);\n\tAA_BUG(!*a);\n\tAA_BUG(!b);\n\tAA_BUG(!*b);\n\tAA_BUG(an <= 0);\n\tAA_BUG(bn <= 0);\n\n\tfor (i = 0; i < an && i < bn; i++) {\n\t\tint res = profile_cmp(a[i], b[i]);\n\n\t\tif (res != 0)\n\t\t\treturn res;\n\t}\n\n\treturn an - bn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!b"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int label_cmp(struct aa_label *a, struct aa_label *b)\n{\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn 0;\n\n\treturn vec_cmp(a->vec, a->size, b->vec, b->size);\n}"
  },
  {
    "function_name": "aa_label_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "431-462",
    "snippet": "struct aa_label *aa_label_alloc(int size, struct aa_proxy *proxy, gfp_t gfp)\n{\n\tstruct aa_label *new;\n\n\tAA_BUG(size < 1);\n\n\t/*  + 1 for null terminator entry on vec */\n\tnew = kzalloc(sizeof(*new) + sizeof(struct aa_profile *) * (size + 1),\n\t\t\tgfp);\n\tAA_DEBUG(\"%s (%p)\\n\", __func__, new);\n\tif (!new)\n\t\tgoto fail;\n\n\tif (!aa_label_init(new, size))\n\t\tgoto fail;\n\n\tif (!proxy) {\n\t\tproxy = aa_alloc_proxy(new, gfp);\n\t\tif (!proxy)\n\t\t\tgoto fail;\n\t} else\n\t\taa_get_proxy(proxy);\n\t/* just set new's proxy, don't redirect proxy here if it was passed in*/\n\tnew->proxy = proxy;\n\n\treturn new;\n\nfail:\n\tkfree(new);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_proxy",
          "args": [
            "proxy"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "426-432",
          "snippet": "static inline struct aa_proxy *aa_get_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_get(&(proxy->count));\n\n\treturn proxy;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_proxy *aa_get_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_get(&(proxy->count));\n\n\treturn proxy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_alloc_proxy",
          "args": [
            "new",
            "gfp"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "aa_alloc_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "64-74",
          "snippet": "struct aa_proxy *aa_alloc_proxy(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_proxy *new;\n\n\tnew = kzalloc(sizeof(struct aa_proxy), gfp);\n\tif (new) {\n\t\tkref_init(&new->count);\n\t\trcu_assign_pointer(new->label, aa_get_label(label));\n\t}\n\treturn new;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_proxy *aa_alloc_proxy(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_proxy *new;\n\n\tnew = kzalloc(sizeof(struct aa_proxy), gfp);\n\tif (new) {\n\t\tkref_init(&new->count);\n\t\trcu_assign_pointer(new->label, aa_get_label(label));\n\t}\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_init",
          "args": [
            "new",
            "size"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "405-420",
          "snippet": "bool aa_label_init(struct aa_label *label, int size)\n{\n\tAA_BUG(!label);\n\tAA_BUG(size < 1);\n\n\tlabel->secid = aa_alloc_secid();\n\tif (label->secid == AA_SECID_INVALID)\n\t\treturn false;\n\n\tlabel->size = size;\t\t\t/* doesn't include null */\n\tlabel->vec[size] = NULL;\t\t/* null terminate */\n\tkref_init(&label->count);\n\tRB_CLEAR_NODE(&label->node);\n\n\treturn true;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nbool aa_label_init(struct aa_label *label, int size)\n{\n\tAA_BUG(!label);\n\tAA_BUG(size < 1);\n\n\tlabel->secid = aa_alloc_secid();\n\tif (label->secid == AA_SECID_INVALID)\n\t\treturn false;\n\n\tlabel->size = size;\t\t\t/* doesn't include null */\n\tlabel->vec[size] = NULL;\t\t/* null terminate */\n\tkref_init(&label->count);\n\tRB_CLEAR_NODE(&label->node);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_DEBUG",
          "args": [
            "\"%s (%p)\\n\"",
            "__func__",
            "new"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new) + sizeof(struct aa_profile *) * (size + 1)",
            "gfp"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "size < 1"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_alloc(int size, struct aa_proxy *proxy, gfp_t gfp)\n{\n\tstruct aa_label *new;\n\n\tAA_BUG(size < 1);\n\n\t/*  + 1 for null terminator entry on vec */\n\tnew = kzalloc(sizeof(*new) + sizeof(struct aa_profile *) * (size + 1),\n\t\t\tgfp);\n\tAA_DEBUG(\"%s (%p)\\n\", __func__, new);\n\tif (!new)\n\t\tgoto fail;\n\n\tif (!aa_label_init(new, size))\n\t\tgoto fail;\n\n\tif (!proxy) {\n\t\tproxy = aa_alloc_proxy(new, gfp);\n\t\tif (!proxy)\n\t\t\tgoto fail;\n\t} else\n\t\taa_get_proxy(proxy);\n\t/* just set new's proxy, don't redirect proxy here if it was passed in*/\n\tnew->proxy = proxy;\n\n\treturn new;\n\nfail:\n\tkfree(new);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "aa_label_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "405-420",
    "snippet": "bool aa_label_init(struct aa_label *label, int size)\n{\n\tAA_BUG(!label);\n\tAA_BUG(size < 1);\n\n\tlabel->secid = aa_alloc_secid();\n\tif (label->secid == AA_SECID_INVALID)\n\t\treturn false;\n\n\tlabel->size = size;\t\t\t/* doesn't include null */\n\tlabel->vec[size] = NULL;\t\t/* null terminate */\n\tkref_init(&label->count);\n\tRB_CLEAR_NODE(&label->node);\n\n\treturn true;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&label->node"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&label->count"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_alloc_secid",
          "args": [],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "aa_alloc_secid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/secid.c",
          "lines": "35-46",
          "snippet": "u32 aa_alloc_secid(void)\n{\n\tu32 secid;\n\n\t/*\n\t * TODO FIXME: secid recycling - part of profile mapping table\n\t */\n\tspin_lock(&secid_lock);\n\tsecid = (++global_secid);\n\tspin_unlock(&secid_lock);\n\treturn secid;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 global_secid;",
            "static DEFINE_SPINLOCK(secid_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n\nstatic u32 global_secid;\nstatic DEFINE_SPINLOCK(secid_lock);\n\nu32 aa_alloc_secid(void)\n{\n\tu32 secid;\n\n\t/*\n\t * TODO FIXME: secid recycling - part of profile mapping table\n\t */\n\tspin_lock(&secid_lock);\n\tsecid = (++global_secid);\n\tspin_unlock(&secid_lock);\n\treturn secid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "size < 1"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nbool aa_label_init(struct aa_label *label, int size)\n{\n\tAA_BUG(!label);\n\tAA_BUG(size < 1);\n\n\tlabel->secid = aa_alloc_secid();\n\tif (label->secid == AA_SECID_INVALID)\n\t\treturn false;\n\n\tlabel->size = size;\t\t\t/* doesn't include null */\n\tlabel->vec[size] = NULL;\t\t/* null terminate */\n\tkref_init(&label->count);\n\tRB_CLEAR_NODE(&label->node);\n\n\treturn true;\n}"
  },
  {
    "function_name": "label_free_or_put_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "396-403",
    "snippet": "static void label_free_or_put_new(struct aa_label *label, struct aa_label *new)\n{\n\tif (label != new)\n\t\t/* need to free directly to break circular ref with proxy */\n\t\taa_label_free(new);\n\telse\n\t\taa_put_label(new);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "new"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_free",
          "args": [
            "new"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "348-355",
          "snippet": "void aa_label_free(struct aa_label *label)\n{\n\tif (!label)\n\t\treturn;\n\n\tlabel_destroy(label);\n\tkfree(label);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_free(struct aa_label *label)\n{\n\tif (!label)\n\t\treturn;\n\n\tlabel_destroy(label);\n\tkfree(label);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic void label_free_or_put_new(struct aa_label *label, struct aa_label *new)\n{\n\tif (label != new)\n\t\t/* need to free directly to break circular ref with proxy */\n\t\taa_label_free(new);\n\telse\n\t\taa_put_label(new);\n}"
  },
  {
    "function_name": "aa_label_kref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "376-394",
    "snippet": "void aa_label_kref(struct kref *kref)\n{\n\tstruct aa_label *label = container_of(kref, struct aa_label, count);\n\tstruct aa_ns *ns = labels_ns(label);\n\n\tif (!ns) {\n\t\t/* never live, no rcu callback needed, just using the fn */\n\t\tlabel_free_switch(label);\n\t\treturn;\n\t}\n\t/* TODO: update labels_profile macro so it works here */\n\tAA_BUG(label_isprofile(label) &&\n\t       on_list_rcu(&label->vec[0]->base.profiles));\n\tAA_BUG(label_isprofile(label) &&\n\t       on_list_rcu(&label->vec[0]->base.list));\n\n\t/* TODO: if compound label and not stale add to reclaim cache */\n\tcall_rcu(&label->rcu, label_free_rcu);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&label->rcu",
            "label_free_rcu"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "label_isprofile(label) &&\n\t       on_list_rcu(&label->vec[0]->base.list)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_list_rcu",
          "args": [
            "&label->vec[0]->base.list"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_isprofile",
          "args": [
            "label"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "label_isprofile(label) &&\n\t       on_list_rcu(&label->vec[0]->base.profiles)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_list_rcu",
          "args": [
            "&label->vec[0]->base.profiles"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_isprofile",
          "args": [
            "label"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_free_switch",
          "args": [
            "label"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "label_free_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "357-365",
          "snippet": "static void label_free_switch(struct aa_label *label)\n{\n\tif (label->flags & FLAG_NS_COUNT)\n\t\taa_free_ns(labels_ns(label));\n\telse if (label_isprofile(label))\n\t\taa_free_profile(labels_profile(label));\n\telse\n\t\taa_label_free(label);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic void label_free_switch(struct aa_label *label)\n{\n\tif (label->flags & FLAG_NS_COUNT)\n\t\taa_free_ns(labels_ns(label));\n\telse if (label_isprofile(label))\n\t\taa_free_profile(labels_profile(label));\n\telse\n\t\taa_label_free(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structaa_label",
            "count"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_kref(struct kref *kref)\n{\n\tstruct aa_label *label = container_of(kref, struct aa_label, count);\n\tstruct aa_ns *ns = labels_ns(label);\n\n\tif (!ns) {\n\t\t/* never live, no rcu callback needed, just using the fn */\n\t\tlabel_free_switch(label);\n\t\treturn;\n\t}\n\t/* TODO: update labels_profile macro so it works here */\n\tAA_BUG(label_isprofile(label) &&\n\t       on_list_rcu(&label->vec[0]->base.profiles));\n\tAA_BUG(label_isprofile(label) &&\n\t       on_list_rcu(&label->vec[0]->base.list));\n\n\t/* TODO: if compound label and not stale add to reclaim cache */\n\tcall_rcu(&label->rcu, label_free_rcu);\n}"
  },
  {
    "function_name": "label_free_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "367-374",
    "snippet": "static void label_free_rcu(struct rcu_head *head)\n{\n\tstruct aa_label *label = container_of(head, struct aa_label, rcu);\n\n\tif (label->flags & FLAG_IN_TREE)\n\t\t(void) aa_label_remove(label);\n\tlabel_free_switch(label);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "label_free_switch",
          "args": [
            "label"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "label_free_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "357-365",
          "snippet": "static void label_free_switch(struct aa_label *label)\n{\n\tif (label->flags & FLAG_NS_COUNT)\n\t\taa_free_ns(labels_ns(label));\n\telse if (label_isprofile(label))\n\t\taa_free_profile(labels_profile(label));\n\telse\n\t\taa_label_free(label);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic void label_free_switch(struct aa_label *label)\n{\n\tif (label->flags & FLAG_NS_COUNT)\n\t\taa_free_ns(labels_ns(label));\n\telse if (label_isprofile(label))\n\t\taa_free_profile(labels_profile(label));\n\telse\n\t\taa_label_free(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_remove",
          "args": [
            "label"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "747-760",
          "snippet": "bool aa_label_remove(struct aa_label *label)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\tunsigned long flags;\n\tbool res;\n\n\tAA_BUG(!ls);\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tres = __label_remove(label, ns_unconfined(labels_ns(label)));\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn res;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nbool aa_label_remove(struct aa_label *label)\n{\n\tstruct aa_labelset *ls = labels_set(label);\n\tunsigned long flags;\n\tbool res;\n\n\tAA_BUG(!ls);\n\n\twrite_lock_irqsave(&ls->lock, flags);\n\tres = __label_remove(label, ns_unconfined(labels_ns(label)));\n\twrite_unlock_irqrestore(&ls->lock, flags);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structaa_label",
            "rcu"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic void label_free_rcu(struct rcu_head *head)\n{\n\tstruct aa_label *label = container_of(head, struct aa_label, rcu);\n\n\tif (label->flags & FLAG_IN_TREE)\n\t\t(void) aa_label_remove(label);\n\tlabel_free_switch(label);\n}"
  },
  {
    "function_name": "label_free_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "357-365",
    "snippet": "static void label_free_switch(struct aa_label *label)\n{\n\tif (label->flags & FLAG_NS_COUNT)\n\t\taa_free_ns(labels_ns(label));\n\telse if (label_isprofile(label))\n\t\taa_free_profile(labels_profile(label));\n\telse\n\t\taa_label_free(label);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_label_free",
          "args": [
            "label"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "348-355",
          "snippet": "void aa_label_free(struct aa_label *label)\n{\n\tif (!label)\n\t\treturn;\n\n\tlabel_destroy(label);\n\tkfree(label);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_free(struct aa_label *label)\n{\n\tif (!label)\n\t\treturn;\n\n\tlabel_destroy(label);\n\tkfree(label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_free_profile",
          "args": [
            "labels_profile(label)"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "aa_free_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "210-245",
          "snippet": "void aa_free_profile(struct aa_profile *profile)\n{\n\tstruct rhashtable *rht;\n\n\tAA_DEBUG(\"%s(%p)\\n\", __func__, profile);\n\n\tif (!profile)\n\t\treturn;\n\n\t/* free children profiles */\n\taa_policy_destroy(&profile->base);\n\taa_put_profile(rcu_access_pointer(profile->parent));\n\n\taa_put_ns(profile->ns);\n\tkzfree(profile->rename);\n\n\taa_free_file_rules(&profile->file);\n\taa_free_cap_rules(&profile->caps);\n\taa_free_rlimit_rules(&profile->rlimits);\n\n\tkzfree(profile->dirname);\n\taa_put_dfa(profile->xmatch);\n\taa_put_dfa(profile->policy.dfa);\n\n\tif (profile->data) {\n\t\trht = profile->data;\n\t\tprofile->data = NULL;\n\t\trhashtable_free_and_destroy(rht, aa_free_data, NULL);\n\t\tkzfree(rht);\n\t}\n\n\tkzfree(profile->hash);\n\taa_put_loaddata(profile->rawdata);\n\n\tkzfree(profile);\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid aa_free_profile(struct aa_profile *profile)\n{\n\tstruct rhashtable *rht;\n\n\tAA_DEBUG(\"%s(%p)\\n\", __func__, profile);\n\n\tif (!profile)\n\t\treturn;\n\n\t/* free children profiles */\n\taa_policy_destroy(&profile->base);\n\taa_put_profile(rcu_access_pointer(profile->parent));\n\n\taa_put_ns(profile->ns);\n\tkzfree(profile->rename);\n\n\taa_free_file_rules(&profile->file);\n\taa_free_cap_rules(&profile->caps);\n\taa_free_rlimit_rules(&profile->rlimits);\n\n\tkzfree(profile->dirname);\n\taa_put_dfa(profile->xmatch);\n\taa_put_dfa(profile->policy.dfa);\n\n\tif (profile->data) {\n\t\trht = profile->data;\n\t\tprofile->data = NULL;\n\t\trhashtable_free_and_destroy(rht, aa_free_data, NULL);\n\t\tkzfree(rht);\n\t}\n\n\tkzfree(profile->hash);\n\taa_put_loaddata(profile->rawdata);\n\n\tkzfree(profile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_profile",
          "args": [
            "label"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_isprofile",
          "args": [
            "label"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_free_ns",
          "args": [
            "labels_ns(label)"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "aa_free_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "141-153",
          "snippet": "void aa_free_ns(struct aa_ns *ns)\n{\n\tif (!ns)\n\t\treturn;\n\n\taa_policy_destroy(&ns->base);\n\taa_labelset_destroy(&ns->labels);\n\taa_put_ns(ns->parent);\n\n\tns->unconfined->ns = NULL;\n\taa_free_profile(ns->unconfined);\n\tkzfree(ns);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nvoid aa_free_ns(struct aa_ns *ns)\n{\n\tif (!ns)\n\t\treturn;\n\n\taa_policy_destroy(&ns->base);\n\taa_labelset_destroy(&ns->labels);\n\taa_put_ns(ns->parent);\n\n\tns->unconfined->ns = NULL;\n\taa_free_profile(ns->unconfined);\n\tkzfree(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic void label_free_switch(struct aa_label *label)\n{\n\tif (label->flags & FLAG_NS_COUNT)\n\t\taa_free_ns(labels_ns(label));\n\telse if (label_isprofile(label))\n\t\taa_free_profile(labels_profile(label));\n\telse\n\t\taa_label_free(label);\n}"
  },
  {
    "function_name": "aa_label_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "348-355",
    "snippet": "void aa_label_free(struct aa_label *label)\n{\n\tif (!label)\n\t\treturn;\n\n\tlabel_destroy(label);\n\tkfree(label);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "label"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_destroy",
          "args": [
            "label"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "label_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "316-346",
          "snippet": "static void label_destroy(struct aa_label *label)\n{\n\tstruct aa_label *tmp;\n\n\tAA_BUG(!label);\n\n\tif (!label_isprofile(label)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\taa_put_str(label->hname);\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\taa_put_profile(profile);\n\t\t\tlabel->vec[i.i] = (struct aa_profile *)\n\t\t\t\t\t   (LABEL_POISON + (long) i.i);\n\t\t}\n\t}\n\n\tif (rcu_dereference_protected(label->proxy->label, true) == label)\n\t\trcu_assign_pointer(label->proxy->label, NULL);\n\n\taa_free_secid(label->secid);\n\n\ttmp = rcu_dereference_protected(label->proxy->label, true);\n\tif (tmp == label)\n\t\trcu_assign_pointer(label->proxy->label, NULL);\n\n\taa_put_proxy(label->proxy);\n\tlabel->proxy = (struct aa_proxy *) PROXY_POISON + 1;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [
            "#define LABEL_POISON 100",
            "#define PROXY_POISON 97"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\n#define LABEL_POISON 100\n#define PROXY_POISON 97\n\nstatic void label_destroy(struct aa_label *label)\n{\n\tstruct aa_label *tmp;\n\n\tAA_BUG(!label);\n\n\tif (!label_isprofile(label)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\taa_put_str(label->hname);\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\taa_put_profile(profile);\n\t\t\tlabel->vec[i.i] = (struct aa_profile *)\n\t\t\t\t\t   (LABEL_POISON + (long) i.i);\n\t\t}\n\t}\n\n\tif (rcu_dereference_protected(label->proxy->label, true) == label)\n\t\trcu_assign_pointer(label->proxy->label, NULL);\n\n\taa_free_secid(label->secid);\n\n\ttmp = rcu_dereference_protected(label->proxy->label, true);\n\tif (tmp == label)\n\t\trcu_assign_pointer(label->proxy->label, NULL);\n\n\taa_put_proxy(label->proxy);\n\tlabel->proxy = (struct aa_proxy *) PROXY_POISON + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_free(struct aa_label *label)\n{\n\tif (!label)\n\t\treturn;\n\n\tlabel_destroy(label);\n\tkfree(label);\n}"
  },
  {
    "function_name": "label_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "316-346",
    "snippet": "static void label_destroy(struct aa_label *label)\n{\n\tstruct aa_label *tmp;\n\n\tAA_BUG(!label);\n\n\tif (!label_isprofile(label)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\taa_put_str(label->hname);\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\taa_put_profile(profile);\n\t\t\tlabel->vec[i.i] = (struct aa_profile *)\n\t\t\t\t\t   (LABEL_POISON + (long) i.i);\n\t\t}\n\t}\n\n\tif (rcu_dereference_protected(label->proxy->label, true) == label)\n\t\trcu_assign_pointer(label->proxy->label, NULL);\n\n\taa_free_secid(label->secid);\n\n\ttmp = rcu_dereference_protected(label->proxy->label, true);\n\tif (tmp == label)\n\t\trcu_assign_pointer(label->proxy->label, NULL);\n\n\taa_put_proxy(label->proxy);\n\tlabel->proxy = (struct aa_proxy *) PROXY_POISON + 1;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [
      "#define LABEL_POISON 100",
      "#define PROXY_POISON 97"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_proxy",
          "args": [
            "label->proxy"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "434-438",
          "snippet": "static inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "label->proxy->label",
            "NULL"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "label->proxy->label",
            "true"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_free_secid",
          "args": [
            "label->secid"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "aa_free_secid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/secid.c",
          "lines": "52-55",
          "snippet": "void aa_free_secid(u32 secid)\n{\n\t;\t\t\t/* NOP ATM */\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n\nvoid aa_free_secid(u32 secid)\n{\n\t;\t\t\t/* NOP ATM */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "label->proxy->label",
            "NULL"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "label->proxy->label",
            "true"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_profile",
          "args": [
            "profile"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "277-281",
          "snippet": "static inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_for_each",
          "args": [
            "i",
            "label",
            "profile"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_str",
          "args": [
            "label->hname"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/lib.h",
          "lines": "115-119",
          "snippet": "static inline void aa_put_str(__counted char *str)\n{\n\tif (str)\n\t\tkref_put(&str_to_counted(str)->count, aa_str_kref);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define __counted\t/* atm just a notation */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n\n#define __counted\t/* atm just a notation */\n\nstatic inline void aa_put_str(__counted char *str)\n{\n\tif (str)\n\t\tkref_put(&str_to_counted(str)->count, aa_str_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_isprofile",
          "args": [
            "label"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\n#define LABEL_POISON 100\n#define PROXY_POISON 97\n\nstatic void label_destroy(struct aa_label *label)\n{\n\tstruct aa_label *tmp;\n\n\tAA_BUG(!label);\n\n\tif (!label_isprofile(label)) {\n\t\tstruct aa_profile *profile;\n\t\tstruct label_it i;\n\n\t\taa_put_str(label->hname);\n\n\t\tlabel_for_each(i, label, profile) {\n\t\t\taa_put_profile(profile);\n\t\t\tlabel->vec[i.i] = (struct aa_profile *)\n\t\t\t\t\t   (LABEL_POISON + (long) i.i);\n\t\t}\n\t}\n\n\tif (rcu_dereference_protected(label->proxy->label, true) == label)\n\t\trcu_assign_pointer(label->proxy->label, NULL);\n\n\taa_free_secid(label->secid);\n\n\ttmp = rcu_dereference_protected(label->proxy->label, true);\n\tif (tmp == label)\n\t\trcu_assign_pointer(label->proxy->label, NULL);\n\n\taa_put_proxy(label->proxy);\n\tlabel->proxy = (struct aa_proxy *) PROXY_POISON + 1;\n}"
  },
  {
    "function_name": "aa_vec_unique",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "266-313",
    "snippet": "int aa_vec_unique(struct aa_profile **vec, int n, int flags)\n{\n\tint i, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\t/* vecs are usually small and inorder, have a fallback for larger */\n\tif (n > 8) {\n\t\tsort(vec, n, sizeof(struct aa_profile *), sort_cmp, NULL);\n\t\tdups = unique(vec, n);\n\t\tgoto out;\n\t}\n\n\t/* insertion sort + unique in one */\n\tfor (i = 1; i < n; i++) {\n\t\tstruct aa_profile *tmp = vec[i];\n\t\tint pos, j;\n\n\t\tfor (pos = i - 1 - dups; pos >= 0; pos--) {\n\t\t\tint res = profile_cmp(vec[pos], tmp);\n\n\t\t\tif (res == 0) {\n\t\t\t\t/* drop duplicate entry */\n\t\t\t\taa_put_profile(tmp);\n\t\t\t\tdups++;\n\t\t\t\tgoto continue_outer;\n\t\t\t} else if (res < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* pos is at entry < tmp, or index -1. Set to insert pos */\n\t\tpos++;\n\n\t\tfor (j = i - dups; j > pos; j--)\n\t\t\tvec[j] = vec[j - 1];\n\t\tvec[pos] = tmp;\ncontinue_outer:\n\t\t;\n\t}\n\n\tAA_BUG(dups < 0);\n\nout:\n\tif (flags & VEC_FLAG_TERMINATE)\n\t\tvec[n - dups] = NULL;\n\n\treturn dups;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "dups < 0"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_profile",
          "args": [
            "tmp"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "277-281",
          "snippet": "static inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_cmp",
          "args": [
            "vec[pos]",
            "tmp"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "profile_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "139-157",
          "snippet": "static int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unique",
          "args": [
            "vec",
            "n"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "unique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "228-254",
          "snippet": "static inline int unique(struct aa_profile **vec, int n)\n{\n\tint i, pos, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\tpos = 0;\n\tfor (i = 1; i < n; i++) {\n\t\tint res = profile_cmp(vec[pos], vec[i]);\n\n\t\tAA_BUG(res > 0, \"vec not sorted\");\n\t\tif (res == 0) {\n\t\t\t/* drop duplicate */\n\t\t\taa_put_profile(vec[i]);\n\t\t\tdups++;\n\t\t\tcontinue;\n\t\t}\n\t\tpos++;\n\t\tif (dups)\n\t\t\tvec[pos] = vec[i];\n\t}\n\n\tAA_BUG(dups < 0);\n\n\treturn dups;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline int unique(struct aa_profile **vec, int n)\n{\n\tint i, pos, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\tpos = 0;\n\tfor (i = 1; i < n; i++) {\n\t\tint res = profile_cmp(vec[pos], vec[i]);\n\n\t\tAA_BUG(res > 0, \"vec not sorted\");\n\t\tif (res == 0) {\n\t\t\t/* drop duplicate */\n\t\t\taa_put_profile(vec[i]);\n\t\t\tdups++;\n\t\t\tcontinue;\n\t\t}\n\t\tpos++;\n\t\tif (dups)\n\t\t\tvec[pos] = vec[i];\n\t}\n\n\tAA_BUG(dups < 0);\n\n\treturn dups;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "vec",
            "n",
            "sizeof(struct aa_profile *)",
            "sort_cmp",
            "NULL"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!vec"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "n < 1"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_vec_unique(struct aa_profile **vec, int n, int flags)\n{\n\tint i, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\t/* vecs are usually small and inorder, have a fallback for larger */\n\tif (n > 8) {\n\t\tsort(vec, n, sizeof(struct aa_profile *), sort_cmp, NULL);\n\t\tdups = unique(vec, n);\n\t\tgoto out;\n\t}\n\n\t/* insertion sort + unique in one */\n\tfor (i = 1; i < n; i++) {\n\t\tstruct aa_profile *tmp = vec[i];\n\t\tint pos, j;\n\n\t\tfor (pos = i - 1 - dups; pos >= 0; pos--) {\n\t\t\tint res = profile_cmp(vec[pos], tmp);\n\n\t\t\tif (res == 0) {\n\t\t\t\t/* drop duplicate entry */\n\t\t\t\taa_put_profile(tmp);\n\t\t\t\tdups++;\n\t\t\t\tgoto continue_outer;\n\t\t\t} else if (res < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* pos is at entry < tmp, or index -1. Set to insert pos */\n\t\tpos++;\n\n\t\tfor (j = i - dups; j > pos; j--)\n\t\t\tvec[j] = vec[j - 1];\n\t\tvec[pos] = tmp;\ncontinue_outer:\n\t\t;\n\t}\n\n\tAA_BUG(dups < 0);\n\nout:\n\tif (flags & VEC_FLAG_TERMINATE)\n\t\tvec[n - dups] = NULL;\n\n\treturn dups;\n}"
  },
  {
    "function_name": "unique",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "228-254",
    "snippet": "static inline int unique(struct aa_profile **vec, int n)\n{\n\tint i, pos, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\tpos = 0;\n\tfor (i = 1; i < n; i++) {\n\t\tint res = profile_cmp(vec[pos], vec[i]);\n\n\t\tAA_BUG(res > 0, \"vec not sorted\");\n\t\tif (res == 0) {\n\t\t\t/* drop duplicate */\n\t\t\taa_put_profile(vec[i]);\n\t\t\tdups++;\n\t\t\tcontinue;\n\t\t}\n\t\tpos++;\n\t\tif (dups)\n\t\t\tvec[pos] = vec[i];\n\t}\n\n\tAA_BUG(dups < 0);\n\n\treturn dups;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "dups < 0"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_profile",
          "args": [
            "vec[i]"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "277-281",
          "snippet": "static inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline void aa_put_profile(struct aa_profile *p)\n{\n\tif (p)\n\t\tkref_put(&p->label.count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "res > 0",
            "\"vec not sorted\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_cmp",
          "args": [
            "vec[pos]",
            "vec[i]"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "profile_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "139-157",
          "snippet": "static int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!vec"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "n < 1"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic inline int unique(struct aa_profile **vec, int n)\n{\n\tint i, pos, dups = 0;\n\n\tAA_BUG(n < 1);\n\tAA_BUG(!vec);\n\n\tpos = 0;\n\tfor (i = 1; i < n; i++) {\n\t\tint res = profile_cmp(vec[pos], vec[i]);\n\n\t\tAA_BUG(res > 0, \"vec not sorted\");\n\t\tif (res == 0) {\n\t\t\t/* drop duplicate */\n\t\t\taa_put_profile(vec[i]);\n\t\t\tdups++;\n\t\t\tcontinue;\n\t\t}\n\t\tpos++;\n\t\tif (dups)\n\t\t\tvec[pos] = vec[i];\n\t}\n\n\tAA_BUG(dups < 0);\n\n\treturn dups;\n}"
  },
  {
    "function_name": "sort_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "218-221",
    "snippet": "static int sort_cmp(const void *a, const void *b)\n{\n\treturn profile_cmp(*(struct aa_profile **)a, *(struct aa_profile **)b);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_cmp",
          "args": [
            "*(struct aa_profile **)a",
            "*(struct aa_profile **)b"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "profile_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "139-157",
          "snippet": "static int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int sort_cmp(const void *a, const void *b)\n{\n\treturn profile_cmp(*(struct aa_profile **)a, *(struct aa_profile **)b);\n}"
  },
  {
    "function_name": "vec_unconfined",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "204-216",
    "snippet": "static bool vec_unconfined(struct aa_profile **vec, int n)\n{\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (!profile_unconfined(vec[i]))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "vec[i]"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!vec"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic bool vec_unconfined(struct aa_profile **vec, int n)\n{\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (!profile_unconfined(vec[i]))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "vec_is_stale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "190-202",
    "snippet": "static bool vec_is_stale(struct aa_profile **vec, int n)\n{\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (profile_is_stale(vec[i]))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_is_stale",
          "args": [
            "vec[i]"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!vec"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic bool vec_is_stale(struct aa_profile **vec, int n)\n{\n\tint i;\n\n\tAA_BUG(!vec);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (profile_is_stale(vec[i]))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "vec_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "169-188",
    "snippet": "static int vec_cmp(struct aa_profile **a, int an, struct aa_profile **b, int bn)\n{\n\tint i;\n\n\tAA_BUG(!a);\n\tAA_BUG(!*a);\n\tAA_BUG(!b);\n\tAA_BUG(!*b);\n\tAA_BUG(an <= 0);\n\tAA_BUG(bn <= 0);\n\n\tfor (i = 0; i < an && i < bn; i++) {\n\t\tint res = profile_cmp(a[i], b[i]);\n\n\t\tif (res != 0)\n\t\t\treturn res;\n\t}\n\n\treturn an - bn;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "profile_cmp",
          "args": [
            "a[i]",
            "b[i]"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "profile_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "139-157",
          "snippet": "static int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "bn <= 0"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "an <= 0"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!*b"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!b"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!*a"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!a"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int vec_cmp(struct aa_profile **a, int an, struct aa_profile **b, int bn)\n{\n\tint i;\n\n\tAA_BUG(!a);\n\tAA_BUG(!*a);\n\tAA_BUG(!b);\n\tAA_BUG(!*b);\n\tAA_BUG(an <= 0);\n\tAA_BUG(bn <= 0);\n\n\tfor (i = 0; i < an && i < bn; i++) {\n\t\tint res = profile_cmp(a[i], b[i]);\n\n\t\tif (res != 0)\n\t\t\treturn res;\n\t}\n\n\treturn an - bn;\n}"
  },
  {
    "function_name": "profile_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "139-157",
    "snippet": "static int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->base.hname",
            "b->base.hname"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_cmp",
          "args": [
            "a->ns",
            "b->ns"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "ns_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "111-128",
          "snippet": "static int ns_cmp(struct aa_ns *a, struct aa_ns *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b)\n\t\treturn 0;\n\n\tres = a->level - b->level;\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int ns_cmp(struct aa_ns *a, struct aa_ns *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b)\n\t\treturn 0;\n\n\tres = a->level - b->level;\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!b->base.hname"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!a->base.hname"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!b->ns"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!a->ns"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!b"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!a"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int profile_cmp(struct aa_profile *a, struct aa_profile *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->ns);\n\tAA_BUG(!b->ns);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b || a->base.hname == b->base.hname)\n\t\treturn 0;\n\tres = ns_cmp(a->ns, b->ns);\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}"
  },
  {
    "function_name": "ns_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "111-128",
    "snippet": "static int ns_cmp(struct aa_ns *a, struct aa_ns *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b)\n\t\treturn 0;\n\n\tres = a->level - b->level;\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->base.hname",
            "b->base.hname"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!b->base.hname"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!a->base.hname"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!b"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!a"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic int ns_cmp(struct aa_ns *a, struct aa_ns *b)\n{\n\tint res;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\tAA_BUG(!a->base.hname);\n\tAA_BUG(!b->base.hname);\n\n\tif (a == b)\n\t\treturn 0;\n\n\tres = a->level - b->level;\n\tif (res)\n\t\treturn res;\n\n\treturn strcmp(a->base.hname, b->base.hname);\n}"
  },
  {
    "function_name": "__proxy_share",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "92-99",
    "snippet": "static void __proxy_share(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_proxy *proxy = new->proxy;\n\n\tnew->proxy = aa_get_proxy(old->proxy);\n\t__aa_proxy_redirect(old, new);\n\taa_put_proxy(proxy);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_proxy",
          "args": [
            "proxy"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "434-438",
          "snippet": "static inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_put(&proxy->count, aa_proxy_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__aa_proxy_redirect",
          "args": [
            "old",
            "new"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_proxy_redirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "77-90",
          "snippet": "void __aa_proxy_redirect(struct aa_label *orig, struct aa_label *new)\n{\n\tstruct aa_label *tmp;\n\n\tAA_BUG(!orig);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&labels_set(orig)->lock);\n\n\ttmp = rcu_dereference_protected(orig->proxy->label,\n\t\t\t\t\t&labels_ns(orig)->lock);\n\trcu_assign_pointer(orig->proxy->label, aa_get_label(new));\n\torig->flags |= FLAG_STALE;\n\taa_put_label(tmp);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid __aa_proxy_redirect(struct aa_label *orig, struct aa_label *new)\n{\n\tstruct aa_label *tmp;\n\n\tAA_BUG(!orig);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&labels_set(orig)->lock);\n\n\ttmp = rcu_dereference_protected(orig->proxy->label,\n\t\t\t\t\t&labels_ns(orig)->lock);\n\trcu_assign_pointer(orig->proxy->label, aa_get_label(new));\n\torig->flags |= FLAG_STALE;\n\taa_put_label(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_proxy",
          "args": [
            "old->proxy"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "426-432",
          "snippet": "static inline struct aa_proxy *aa_get_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_get(&(proxy->count));\n\n\treturn proxy;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_proxy *aa_get_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy)\n\t\tkref_get(&(proxy->count));\n\n\treturn proxy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstatic void __proxy_share(struct aa_label *old, struct aa_label *new)\n{\n\tstruct aa_proxy *proxy = new->proxy;\n\n\tnew->proxy = aa_get_proxy(old->proxy);\n\t__aa_proxy_redirect(old, new);\n\taa_put_proxy(proxy);\n}"
  },
  {
    "function_name": "__aa_proxy_redirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "77-90",
    "snippet": "void __aa_proxy_redirect(struct aa_label *orig, struct aa_label *new)\n{\n\tstruct aa_label *tmp;\n\n\tAA_BUG(!orig);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&labels_set(orig)->lock);\n\n\ttmp = rcu_dereference_protected(orig->proxy->label,\n\t\t\t\t\t&labels_ns(orig)->lock);\n\trcu_assign_pointer(orig->proxy->label, aa_get_label(new));\n\torig->flags |= FLAG_STALE;\n\taa_put_label(tmp);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "tmp"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "orig->proxy->label",
            "aa_get_label(new)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "new"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "orig->proxy->label",
            "&labels_ns(orig)->lock"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "orig"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held_exclusive",
          "args": [
            "&labels_set(orig)->lock"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_set",
          "args": [
            "orig"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!new"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!orig"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid __aa_proxy_redirect(struct aa_label *orig, struct aa_label *new)\n{\n\tstruct aa_label *tmp;\n\n\tAA_BUG(!orig);\n\tAA_BUG(!new);\n\tlockdep_assert_held_exclusive(&labels_set(orig)->lock);\n\n\ttmp = rcu_dereference_protected(orig->proxy->label,\n\t\t\t\t\t&labels_ns(orig)->lock);\n\trcu_assign_pointer(orig->proxy->label, aa_get_label(new));\n\torig->flags |= FLAG_STALE;\n\taa_put_label(tmp);\n}"
  },
  {
    "function_name": "aa_alloc_proxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "64-74",
    "snippet": "struct aa_proxy *aa_alloc_proxy(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_proxy *new;\n\n\tnew = kzalloc(sizeof(struct aa_proxy), gfp);\n\tif (new) {\n\t\tkref_init(&new->count);\n\t\trcu_assign_pointer(new->label, aa_get_label(label));\n\t}\n\treturn new;\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "new->label",
            "aa_get_label(label)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_label",
          "args": [
            "label"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_label_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "372-383",
          "snippet": "static inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_label_rcu(struct aa_label __rcu **l)\n{\n\tstruct aa_label *c;\n\n\trcu_read_lock();\n\tdo {\n\t\tc = rcu_dereference(*l);\n\t} while (c && !kref_get_unless_zero(&c->count));\n\trcu_read_unlock();\n\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&new->count"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct aa_proxy)",
            "gfp"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_proxy *aa_alloc_proxy(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_proxy *new;\n\n\tnew = kzalloc(sizeof(struct aa_proxy), gfp);\n\tif (new) {\n\t\tkref_init(&new->count);\n\t\trcu_assign_pointer(new->label, aa_get_label(label));\n\t}\n\treturn new;\n}"
  },
  {
    "function_name": "aa_proxy_kref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "57-62",
    "snippet": "void aa_proxy_kref(struct kref *kref)\n{\n\tstruct aa_proxy *proxy = container_of(kref, struct aa_proxy, count);\n\n\tfree_proxy(proxy);\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_proxy",
          "args": [
            "proxy"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "free_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "46-55",
          "snippet": "static void free_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy) {\n\t\t/* p->label will not updated any more as p is dead */\n\t\taa_put_label(rcu_dereference_protected(proxy->label, true));\n\t\tmemset(proxy, 0, sizeof(*proxy));\n\t\tRCU_INIT_POINTER(proxy->label, (struct aa_label *)PROXY_POISON);\n\t\tkfree(proxy);\n\t}\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [
            "#define PROXY_POISON 97"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\n#define PROXY_POISON 97\n\nstatic void free_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy) {\n\t\t/* p->label will not updated any more as p is dead */\n\t\taa_put_label(rcu_dereference_protected(proxy->label, true));\n\t\tmemset(proxy, 0, sizeof(*proxy));\n\t\tRCU_INIT_POINTER(proxy->label, (struct aa_label *)PROXY_POISON);\n\t\tkfree(proxy);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structaa_proxy",
            "count"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_proxy_kref(struct kref *kref)\n{\n\tstruct aa_proxy *proxy = container_of(kref, struct aa_proxy, count);\n\n\tfree_proxy(proxy);\n}"
  },
  {
    "function_name": "free_proxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
    "lines": "46-55",
    "snippet": "static void free_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy) {\n\t\t/* p->label will not updated any more as p is dead */\n\t\taa_put_label(rcu_dereference_protected(proxy->label, true));\n\t\tmemset(proxy, 0, sizeof(*proxy));\n\t\tRCU_INIT_POINTER(proxy->label, (struct aa_label *)PROXY_POISON);\n\t\tkfree(proxy);\n\t}\n}",
    "includes": [
      "#include \"include/secid.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/label.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/sort.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [
      "#define PROXY_POISON 97"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "proxy"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "proxy->label",
            "(struct aa_label *)PROXY_POISON"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "proxy",
            "0",
            "sizeof(*proxy)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "rcu_dereference_protected(proxy->label, true)"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "proxy->label",
            "true"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\n#define PROXY_POISON 97\n\nstatic void free_proxy(struct aa_proxy *proxy)\n{\n\tif (proxy) {\n\t\t/* p->label will not updated any more as p is dead */\n\t\taa_put_label(rcu_dereference_protected(proxy->label, true));\n\t\tmemset(proxy, 0, sizeof(*proxy));\n\t\tRCU_INIT_POINTER(proxy->label, (struct aa_label *)PROXY_POISON);\n\t\tkfree(proxy);\n\t}\n}"
  }
]