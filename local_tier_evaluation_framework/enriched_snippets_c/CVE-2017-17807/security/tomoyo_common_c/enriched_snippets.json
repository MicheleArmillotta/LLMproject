[
  {
    "function_name": "tomoyo_load_builtin_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2734-2790",
    "snippet": "void __init tomoyo_load_builtin_policy(void)\n{\n\t/*\n\t * This include file is manually created and contains built-in policy\n\t * named \"tomoyo_builtin_profile\", \"tomoyo_builtin_exception_policy\",\n\t * \"tomoyo_builtin_domain_policy\", \"tomoyo_builtin_manager\",\n\t * \"tomoyo_builtin_stat\" in the form of \"static char [] __initdata\".\n\t */\n#include \"builtin-policy.h\"\n\tu8 i;\n\tconst int idx = tomoyo_read_lock();\n\tfor (i = 0; i < 5; i++) {\n\t\tstruct tomoyo_io_buffer head = { };\n\t\tchar *start = \"\";\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tstart = tomoyo_builtin_profile;\n\t\t\thead.type = TOMOYO_PROFILE;\n\t\t\thead.write = tomoyo_write_profile;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstart = tomoyo_builtin_exception_policy;\n\t\t\thead.type = TOMOYO_EXCEPTIONPOLICY;\n\t\t\thead.write = tomoyo_write_exception;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart = tomoyo_builtin_domain_policy;\n\t\t\thead.type = TOMOYO_DOMAINPOLICY;\n\t\t\thead.write = tomoyo_write_domain;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstart = tomoyo_builtin_manager;\n\t\t\thead.type = TOMOYO_MANAGER;\n\t\t\thead.write = tomoyo_write_manager;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tstart = tomoyo_builtin_stat;\n\t\t\thead.type = TOMOYO_STAT;\n\t\t\thead.write = tomoyo_write_stat;\n\t\t\tbreak;\n\t\t}\n\t\twhile (1) {\n\t\t\tchar *end = strchr(start, '\\n');\n\t\t\tif (!end)\n\t\t\t\tbreak;\n\t\t\t*end = '\\0';\n\t\t\ttomoyo_normalize_line(start);\n\t\t\thead.write_buf = start;\n\t\t\ttomoyo_parse_policy(&head, start);\n\t\t\tstart = end + 1;\n\t\t}\n\t}\n\ttomoyo_read_unlock(idx);\n#ifdef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER\n\ttomoyo_check_profile();\n#endif\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_check_profile",
          "args": [],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2699-2727",
          "snippet": "void tomoyo_check_profile(void)\n{\n\tstruct tomoyo_domain_info *domain;\n\tconst int idx = tomoyo_read_lock();\n\ttomoyo_policy_loaded = true;\n\tprintk(KERN_INFO \"TOMOYO: 2.5.0\\n\");\n\tlist_for_each_entry_rcu(domain, &tomoyo_domain_list, list) {\n\t\tconst u8 profile = domain->profile;\n\t\tconst struct tomoyo_policy_namespace *ns = domain->ns;\n\t\tif (ns->profile_version != 20110903)\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Profile version %u is not supported.\\n\",\n\t\t\t       ns->profile_version);\n\t\telse if (!ns->profile_ptr[profile])\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Profile %u (used by '%s') is not defined.\\n\",\n\t\t\t       profile, domain->domainname->name);\n\t\telse\n\t\t\tcontinue;\n\t\tprintk(KERN_ERR\n\t\t       \"Userland tools for TOMOYO 2.5 must be installed and \"\n\t\t       \"policy must be initialized.\\n\");\n\t\tprintk(KERN_ERR \"Please see http://tomoyo.sourceforge.jp/2.5/ \"\n\t\t       \"for more information.\\n\");\n\t\tpanic(\"STOP!\");\n\t}\n\ttomoyo_read_unlock(idx);\n\tprintk(KERN_INFO \"Mandatory Access Control activated.\\n\");\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nvoid tomoyo_check_profile(void)\n{\n\tstruct tomoyo_domain_info *domain;\n\tconst int idx = tomoyo_read_lock();\n\ttomoyo_policy_loaded = true;\n\tprintk(KERN_INFO \"TOMOYO: 2.5.0\\n\");\n\tlist_for_each_entry_rcu(domain, &tomoyo_domain_list, list) {\n\t\tconst u8 profile = domain->profile;\n\t\tconst struct tomoyo_policy_namespace *ns = domain->ns;\n\t\tif (ns->profile_version != 20110903)\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Profile version %u is not supported.\\n\",\n\t\t\t       ns->profile_version);\n\t\telse if (!ns->profile_ptr[profile])\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Profile %u (used by '%s') is not defined.\\n\",\n\t\t\t       profile, domain->domainname->name);\n\t\telse\n\t\t\tcontinue;\n\t\tprintk(KERN_ERR\n\t\t       \"Userland tools for TOMOYO 2.5 must be installed and \"\n\t\t       \"policy must be initialized.\\n\");\n\t\tprintk(KERN_ERR \"Please see http://tomoyo.sourceforge.jp/2.5/ \"\n\t\t       \"for more information.\\n\");\n\t\tpanic(\"STOP!\");\n\t}\n\ttomoyo_read_unlock(idx);\n\tprintk(KERN_INFO \"Mandatory Access Control activated.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_unlock",
          "args": [
            "idx"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_parse_policy",
          "args": [
            "&head",
            "start"
          ],
          "line": 2782
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_parse_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2548-2573",
          "snippet": "static int tomoyo_parse_policy(struct tomoyo_io_buffer *head, char *line)\n{\n\t/* Delete request? */\n\thead->w.is_delete = !strncmp(line, \"delete \", 7);\n\tif (head->w.is_delete)\n\t\tmemmove(line, line + 7, strlen(line + 7) + 1);\n\t/* Selecting namespace to update. */\n\tif (head->type == TOMOYO_EXCEPTIONPOLICY ||\n\t    head->type == TOMOYO_PROFILE) {\n\t\tif (*line == '<') {\n\t\t\tchar *cp = strchr(line, ' ');\n\t\t\tif (cp) {\n\t\t\t\t*cp++ = '\\0';\n\t\t\t\thead->w.ns = tomoyo_assign_namespace(line);\n\t\t\t\tmemmove(line, cp, strlen(cp) + 1);\n\t\t\t} else\n\t\t\t\thead->w.ns = NULL;\n\t\t} else\n\t\t\thead->w.ns = &tomoyo_kernel_namespace;\n\t\t/* Don't allow updating if namespace is invalid. */\n\t\tif (!head->w.ns)\n\t\t\treturn -ENOENT;\n\t}\n\t/* Do the update. */\n\treturn head->write(head);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_parse_policy(struct tomoyo_io_buffer *head, char *line)\n{\n\t/* Delete request? */\n\thead->w.is_delete = !strncmp(line, \"delete \", 7);\n\tif (head->w.is_delete)\n\t\tmemmove(line, line + 7, strlen(line + 7) + 1);\n\t/* Selecting namespace to update. */\n\tif (head->type == TOMOYO_EXCEPTIONPOLICY ||\n\t    head->type == TOMOYO_PROFILE) {\n\t\tif (*line == '<') {\n\t\t\tchar *cp = strchr(line, ' ');\n\t\t\tif (cp) {\n\t\t\t\t*cp++ = '\\0';\n\t\t\t\thead->w.ns = tomoyo_assign_namespace(line);\n\t\t\t\tmemmove(line, cp, strlen(cp) + 1);\n\t\t\t} else\n\t\t\t\thead->w.ns = NULL;\n\t\t} else\n\t\t\thead->w.ns = &tomoyo_kernel_namespace;\n\t\t/* Don't allow updating if namespace is invalid. */\n\t\tif (!head->w.ns)\n\t\t\treturn -ENOENT;\n\t}\n\t/* Do the update. */\n\treturn head->write(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_normalize_line",
          "args": [
            "start"
          ],
          "line": 2780
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_normalize_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "396-414",
          "snippet": "void tomoyo_normalize_line(unsigned char *buffer)\n{\n\tunsigned char *sp = buffer;\n\tunsigned char *dp = buffer;\n\tbool first = true;\n\n\twhile (tomoyo_invalid(*sp))\n\t\tsp++;\n\twhile (*sp) {\n\t\tif (!first)\n\t\t\t*dp++ = ' ';\n\t\tfirst = false;\n\t\twhile (tomoyo_valid(*sp))\n\t\t\t*dp++ = *sp++;\n\t\twhile (tomoyo_invalid(*sp))\n\t\t\tsp++;\n\t}\n\t*dp = '\\0';\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_normalize_line(unsigned char *buffer)\n{\n\tunsigned char *sp = buffer;\n\tunsigned char *dp = buffer;\n\tbool first = true;\n\n\twhile (tomoyo_invalid(*sp))\n\t\tsp++;\n\twhile (*sp) {\n\t\tif (!first)\n\t\t\t*dp++ = ' ';\n\t\tfirst = false;\n\t\twhile (tomoyo_valid(*sp))\n\t\t\t*dp++ = *sp++;\n\t\twhile (tomoyo_invalid(*sp))\n\t\t\tsp++;\n\t}\n\t*dp = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "start",
            "'\\n'"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_read_lock",
          "args": [],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1096-1099",
          "snippet": "static inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nvoid __init tomoyo_load_builtin_policy(void)\n{\n\t/*\n\t * This include file is manually created and contains built-in policy\n\t * named \"tomoyo_builtin_profile\", \"tomoyo_builtin_exception_policy\",\n\t * \"tomoyo_builtin_domain_policy\", \"tomoyo_builtin_manager\",\n\t * \"tomoyo_builtin_stat\" in the form of \"static char [] __initdata\".\n\t */\n#include \"builtin-policy.h\"\n\tu8 i;\n\tconst int idx = tomoyo_read_lock();\n\tfor (i = 0; i < 5; i++) {\n\t\tstruct tomoyo_io_buffer head = { };\n\t\tchar *start = \"\";\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tstart = tomoyo_builtin_profile;\n\t\t\thead.type = TOMOYO_PROFILE;\n\t\t\thead.write = tomoyo_write_profile;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstart = tomoyo_builtin_exception_policy;\n\t\t\thead.type = TOMOYO_EXCEPTIONPOLICY;\n\t\t\thead.write = tomoyo_write_exception;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart = tomoyo_builtin_domain_policy;\n\t\t\thead.type = TOMOYO_DOMAINPOLICY;\n\t\t\thead.write = tomoyo_write_domain;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstart = tomoyo_builtin_manager;\n\t\t\thead.type = TOMOYO_MANAGER;\n\t\t\thead.write = tomoyo_write_manager;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tstart = tomoyo_builtin_stat;\n\t\t\thead.type = TOMOYO_STAT;\n\t\t\thead.write = tomoyo_write_stat;\n\t\t\tbreak;\n\t\t}\n\t\twhile (1) {\n\t\t\tchar *end = strchr(start, '\\n');\n\t\t\tif (!end)\n\t\t\t\tbreak;\n\t\t\t*end = '\\0';\n\t\t\ttomoyo_normalize_line(start);\n\t\t\thead.write_buf = start;\n\t\t\ttomoyo_parse_policy(&head, start);\n\t\t\tstart = end + 1;\n\t\t}\n\t}\n\ttomoyo_read_unlock(idx);\n#ifdef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER\n\ttomoyo_check_profile();\n#endif\n}"
  },
  {
    "function_name": "tomoyo_check_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2699-2727",
    "snippet": "void tomoyo_check_profile(void)\n{\n\tstruct tomoyo_domain_info *domain;\n\tconst int idx = tomoyo_read_lock();\n\ttomoyo_policy_loaded = true;\n\tprintk(KERN_INFO \"TOMOYO: 2.5.0\\n\");\n\tlist_for_each_entry_rcu(domain, &tomoyo_domain_list, list) {\n\t\tconst u8 profile = domain->profile;\n\t\tconst struct tomoyo_policy_namespace *ns = domain->ns;\n\t\tif (ns->profile_version != 20110903)\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Profile version %u is not supported.\\n\",\n\t\t\t       ns->profile_version);\n\t\telse if (!ns->profile_ptr[profile])\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Profile %u (used by '%s') is not defined.\\n\",\n\t\t\t       profile, domain->domainname->name);\n\t\telse\n\t\t\tcontinue;\n\t\tprintk(KERN_ERR\n\t\t       \"Userland tools for TOMOYO 2.5 must be installed and \"\n\t\t       \"policy must be initialized.\\n\");\n\t\tprintk(KERN_ERR \"Please see http://tomoyo.sourceforge.jp/2.5/ \"\n\t\t       \"for more information.\\n\");\n\t\tpanic(\"STOP!\");\n\t}\n\ttomoyo_read_unlock(idx);\n\tprintk(KERN_INFO \"Mandatory Access Control activated.\\n\");\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Mandatory Access Control activated.\\n\""
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_read_unlock",
          "args": [
            "idx"
          ],
          "line": 2725
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"STOP!\""
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Please see http://tomoyo.sourceforge.jp/2.5/ \"\n\t\t       \"for more information.\\n\""
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"Userland tools for TOMOYO 2.5 must be installed and \"\n\t\t       \"policy must be initialized.\\n\""
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t       \"Profile %u (used by '%s') is not defined.\\n\"",
            "profile",
            "domain->domainname->name"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t       \"Profile version %u is not supported.\\n\"",
            "ns->profile_version"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "domain",
            "&tomoyo_domain_list",
            "list"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"TOMOYO: 2.5.0\\n\""
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_read_lock",
          "args": [],
          "line": 2702
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1096-1099",
          "snippet": "static inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nvoid tomoyo_check_profile(void)\n{\n\tstruct tomoyo_domain_info *domain;\n\tconst int idx = tomoyo_read_lock();\n\ttomoyo_policy_loaded = true;\n\tprintk(KERN_INFO \"TOMOYO: 2.5.0\\n\");\n\tlist_for_each_entry_rcu(domain, &tomoyo_domain_list, list) {\n\t\tconst u8 profile = domain->profile;\n\t\tconst struct tomoyo_policy_namespace *ns = domain->ns;\n\t\tif (ns->profile_version != 20110903)\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Profile version %u is not supported.\\n\",\n\t\t\t       ns->profile_version);\n\t\telse if (!ns->profile_ptr[profile])\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Profile %u (used by '%s') is not defined.\\n\",\n\t\t\t       profile, domain->domainname->name);\n\t\telse\n\t\t\tcontinue;\n\t\tprintk(KERN_ERR\n\t\t       \"Userland tools for TOMOYO 2.5 must be installed and \"\n\t\t       \"policy must be initialized.\\n\");\n\t\tprintk(KERN_ERR \"Please see http://tomoyo.sourceforge.jp/2.5/ \"\n\t\t       \"for more information.\\n\");\n\t\tpanic(\"STOP!\");\n\t}\n\ttomoyo_read_unlock(idx);\n\tprintk(KERN_INFO \"Mandatory Access Control activated.\\n\");\n}"
  },
  {
    "function_name": "tomoyo_close_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2684-2694",
    "snippet": "void tomoyo_close_control(struct tomoyo_io_buffer *head)\n{\n\t/*\n\t * If the file is /sys/kernel/security/tomoyo/query , decrement the\n\t * observer counter.\n\t */\n\tif (head->type == TOMOYO_QUERY &&\n\t    atomic_dec_and_test(&tomoyo_query_observers))\n\t\twake_up_all(&tomoyo_answer_wait);\n\ttomoyo_notify_gc(head, false);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_answer_wait);",
      "static atomic_t tomoyo_query_observers = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_notify_gc",
          "args": [
            "head",
            "false"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_notify_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "631-651",
          "snippet": "void tomoyo_notify_gc(struct tomoyo_io_buffer *head, const bool is_register)\n{\n\tbool is_write = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tif (is_register) {\n\t\thead->users = 1;\n\t\tlist_add(&head->list, &tomoyo_io_buffer_list);\n\t} else {\n\t\tis_write = head->write_buf != NULL;\n\t\tif (!--head->users) {\n\t\t\tlist_del(&head->list);\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head->write_buf);\n\t\t\tkfree(head);\n\t\t}\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\tif (is_write)\n\t\tkthread_run(tomoyo_gc_thread, NULL, \"GC for TOMOYO\");\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(tomoyo_io_buffer_list);",
            "static DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic LIST_HEAD(tomoyo_io_buffer_list);\nstatic DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);\n\nvoid tomoyo_notify_gc(struct tomoyo_io_buffer *head, const bool is_register)\n{\n\tbool is_write = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tif (is_register) {\n\t\thead->users = 1;\n\t\tlist_add(&head->list, &tomoyo_io_buffer_list);\n\t} else {\n\t\tis_write = head->write_buf != NULL;\n\t\tif (!--head->users) {\n\t\t\tlist_del(&head->list);\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head->write_buf);\n\t\t\tkfree(head);\n\t\t}\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\tif (is_write)\n\t\tkthread_run(tomoyo_gc_thread, NULL, \"GC for TOMOYO\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&tomoyo_answer_wait"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&tomoyo_query_observers"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_answer_wait);\nstatic atomic_t tomoyo_query_observers = ATOMIC_INIT(0);\n\nvoid tomoyo_close_control(struct tomoyo_io_buffer *head)\n{\n\t/*\n\t * If the file is /sys/kernel/security/tomoyo/query , decrement the\n\t * observer counter.\n\t */\n\tif (head->type == TOMOYO_QUERY &&\n\t    atomic_dec_and_test(&tomoyo_query_observers))\n\t\twake_up_all(&tomoyo_answer_wait);\n\ttomoyo_notify_gc(head, false);\n}"
  },
  {
    "function_name": "tomoyo_write_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2584-2677",
    "snippet": "ssize_t tomoyo_write_control(struct tomoyo_io_buffer *head,\n\t\t\t     const char __user *buffer, const int buffer_len)\n{\n\tint error = buffer_len;\n\tsize_t avail_len = buffer_len;\n\tchar *cp0 = head->write_buf;\n\tint idx;\n\tif (!head->write)\n\t\treturn -ENOSYS;\n\tif (!access_ok(VERIFY_READ, buffer, buffer_len))\n\t\treturn -EFAULT;\n\tif (mutex_lock_interruptible(&head->io_sem))\n\t\treturn -EINTR;\n\thead->read_user_buf_avail = 0;\n\tidx = tomoyo_read_lock();\n\t/* Read a line and dispatch it to the policy handler. */\n\twhile (avail_len > 0) {\n\t\tchar c;\n\t\tif (head->w.avail >= head->writebuf_size - 1) {\n\t\t\tconst int len = head->writebuf_size * 2;\n\t\t\tchar *cp = kzalloc(len, GFP_NOFS);\n\t\t\tif (!cp) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemmove(cp, cp0, head->w.avail);\n\t\t\tkfree(cp0);\n\t\t\thead->write_buf = cp;\n\t\t\tcp0 = cp;\n\t\t\thead->writebuf_size = len;\n\t\t}\n\t\tif (get_user(c, buffer)) {\n\t\t\terror = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer++;\n\t\tavail_len--;\n\t\tcp0[head->w.avail++] = c;\n\t\tif (c != '\\n')\n\t\t\tcontinue;\n\t\tcp0[head->w.avail - 1] = '\\0';\n\t\thead->w.avail = 0;\n\t\ttomoyo_normalize_line(cp0);\n\t\tif (!strcmp(cp0, \"reset\")) {\n\t\t\thead->w.ns = &tomoyo_kernel_namespace;\n\t\t\thead->w.domain = NULL;\n\t\t\tmemset(&head->r, 0, sizeof(head->r));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Don't allow updating policies by non manager programs. */\n\t\tswitch (head->type) {\n\t\tcase TOMOYO_PROCESS_STATUS:\n\t\t\t/* This does not write anything. */\n\t\t\tbreak;\n\t\tcase TOMOYO_DOMAINPOLICY:\n\t\t\tif (tomoyo_select_domain(head, cp0))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t\tif (!strcmp(cp0, \"select transition_only\")) {\n\t\t\t\thead->r.print_transition_related_only = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\tif (!tomoyo_manager()) {\n\t\t\t\terror = -EPERM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tswitch (tomoyo_parse_policy(head, cp0)) {\n\t\tcase -EPERM:\n\t\t\terror = -EPERM;\n\t\t\tgoto out;\n\t\tcase 0:\n\t\t\tswitch (head->type) {\n\t\t\tcase TOMOYO_DOMAINPOLICY:\n\t\t\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t\tcase TOMOYO_STAT:\n\t\t\tcase TOMOYO_PROFILE:\n\t\t\tcase TOMOYO_MANAGER:\n\t\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\ttomoyo_read_unlock(idx);\n\tmutex_unlock(&head->io_sem);\n\treturn error;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&head->io_sem"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_read_unlock",
          "args": [
            "idx"
          ],
          "line": 2674
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_update_stat",
          "args": [
            "TOMOYO_STAT_POLICY_UPDATES"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_update_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2269-2276",
          "snippet": "void tomoyo_update_stat(const u8 index)\n{\n\t/*\n\t * I don't use atomic operations because race condition is not fatal.\n\t */\n\ttomoyo_stat_updated[index]++;\n\ttomoyo_stat_modified[index] = ktime_get_real_seconds();\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int tomoyo_stat_updated[TOMOYO_MAX_POLICY_STAT];",
            "static time64_t tomoyo_stat_modified[TOMOYO_MAX_POLICY_STAT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int tomoyo_stat_updated[TOMOYO_MAX_POLICY_STAT];\nstatic time64_t tomoyo_stat_modified[TOMOYO_MAX_POLICY_STAT];\n\nvoid tomoyo_update_stat(const u8 index)\n{\n\t/*\n\t * I don't use atomic operations because race condition is not fatal.\n\t */\n\ttomoyo_stat_updated[index]++;\n\ttomoyo_stat_modified[index] = ktime_get_real_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_parse_policy",
          "args": [
            "head",
            "cp0"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_parse_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2548-2573",
          "snippet": "static int tomoyo_parse_policy(struct tomoyo_io_buffer *head, char *line)\n{\n\t/* Delete request? */\n\thead->w.is_delete = !strncmp(line, \"delete \", 7);\n\tif (head->w.is_delete)\n\t\tmemmove(line, line + 7, strlen(line + 7) + 1);\n\t/* Selecting namespace to update. */\n\tif (head->type == TOMOYO_EXCEPTIONPOLICY ||\n\t    head->type == TOMOYO_PROFILE) {\n\t\tif (*line == '<') {\n\t\t\tchar *cp = strchr(line, ' ');\n\t\t\tif (cp) {\n\t\t\t\t*cp++ = '\\0';\n\t\t\t\thead->w.ns = tomoyo_assign_namespace(line);\n\t\t\t\tmemmove(line, cp, strlen(cp) + 1);\n\t\t\t} else\n\t\t\t\thead->w.ns = NULL;\n\t\t} else\n\t\t\thead->w.ns = &tomoyo_kernel_namespace;\n\t\t/* Don't allow updating if namespace is invalid. */\n\t\tif (!head->w.ns)\n\t\t\treturn -ENOENT;\n\t}\n\t/* Do the update. */\n\treturn head->write(head);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_parse_policy(struct tomoyo_io_buffer *head, char *line)\n{\n\t/* Delete request? */\n\thead->w.is_delete = !strncmp(line, \"delete \", 7);\n\tif (head->w.is_delete)\n\t\tmemmove(line, line + 7, strlen(line + 7) + 1);\n\t/* Selecting namespace to update. */\n\tif (head->type == TOMOYO_EXCEPTIONPOLICY ||\n\t    head->type == TOMOYO_PROFILE) {\n\t\tif (*line == '<') {\n\t\t\tchar *cp = strchr(line, ' ');\n\t\t\tif (cp) {\n\t\t\t\t*cp++ = '\\0';\n\t\t\t\thead->w.ns = tomoyo_assign_namespace(line);\n\t\t\t\tmemmove(line, cp, strlen(cp) + 1);\n\t\t\t} else\n\t\t\t\thead->w.ns = NULL;\n\t\t} else\n\t\t\thead->w.ns = &tomoyo_kernel_namespace;\n\t\t/* Don't allow updating if namespace is invalid. */\n\t\tif (!head->w.ns)\n\t\t\treturn -ENOENT;\n\t}\n\t/* Do the update. */\n\treturn head->write(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_manager",
          "args": [],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "919-956",
          "snippet": "static bool tomoyo_manager(void)\n{\n\tstruct tomoyo_manager *ptr;\n\tconst char *exe;\n\tconst struct task_struct *task = current;\n\tconst struct tomoyo_path_info *domainname = tomoyo_domain()->domainname;\n\tbool found = false;\n\n\tif (!tomoyo_policy_loaded)\n\t\treturn true;\n\tif (!tomoyo_manage_by_non_root &&\n\t    (!uid_eq(task->cred->uid,  GLOBAL_ROOT_UID) ||\n\t     !uid_eq(task->cred->euid, GLOBAL_ROOT_UID)))\n\t\treturn false;\n\texe = tomoyo_get_exe();\n\tif (!exe)\n\t\treturn false;\n\tlist_for_each_entry_rcu(ptr, &tomoyo_kernel_namespace.\n\t\t\t\tpolicy_list[TOMOYO_ID_MANAGER], head.list) {\n\t\tif (!ptr->head.is_deleted &&\n\t\t    (!tomoyo_pathcmp(domainname, ptr->manager) ||\n\t\t     !strcmp(exe, ptr->manager->name))) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) { /* Reduce error messages. */\n\t\tstatic pid_t last_pid;\n\t\tconst pid_t pid = current->pid;\n\t\tif (last_pid != pid) {\n\t\t\tprintk(KERN_WARNING \"%s ( %s ) is not permitted to \"\n\t\t\t       \"update policies.\\n\", domainname->name, exe);\n\t\t\tlast_pid = pid;\n\t\t}\n\t}\n\tkfree(exe);\n\treturn found;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool tomoyo_manage_by_non_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_manage_by_non_root;\n\nstatic bool tomoyo_manager(void)\n{\n\tstruct tomoyo_manager *ptr;\n\tconst char *exe;\n\tconst struct task_struct *task = current;\n\tconst struct tomoyo_path_info *domainname = tomoyo_domain()->domainname;\n\tbool found = false;\n\n\tif (!tomoyo_policy_loaded)\n\t\treturn true;\n\tif (!tomoyo_manage_by_non_root &&\n\t    (!uid_eq(task->cred->uid,  GLOBAL_ROOT_UID) ||\n\t     !uid_eq(task->cred->euid, GLOBAL_ROOT_UID)))\n\t\treturn false;\n\texe = tomoyo_get_exe();\n\tif (!exe)\n\t\treturn false;\n\tlist_for_each_entry_rcu(ptr, &tomoyo_kernel_namespace.\n\t\t\t\tpolicy_list[TOMOYO_ID_MANAGER], head.list) {\n\t\tif (!ptr->head.is_deleted &&\n\t\t    (!tomoyo_pathcmp(domainname, ptr->manager) ||\n\t\t     !strcmp(exe, ptr->manager->name))) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) { /* Reduce error messages. */\n\t\tstatic pid_t last_pid;\n\t\tconst pid_t pid = current->pid;\n\t\tif (last_pid != pid) {\n\t\t\tprintk(KERN_WARNING \"%s ( %s ) is not permitted to \"\n\t\t\t       \"update policies.\\n\", domainname->name, exe);\n\t\t\tlast_pid = pid;\n\t\t}\n\t}\n\tkfree(exe);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cp0",
            "\"select transition_only\""
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_select_domain",
          "args": [
            "head",
            "cp0"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_select_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "971-1012",
          "snippet": "static bool tomoyo_select_domain(struct tomoyo_io_buffer *head,\n\t\t\t\t const char *data)\n{\n\tunsigned int pid;\n\tstruct tomoyo_domain_info *domain = NULL;\n\tbool global_pid = false;\n\tif (strncmp(data, \"select \", 7))\n\t\treturn false;\n\tdata += 7;\n\tif (sscanf(data, \"pid=%u\", &pid) == 1 ||\n\t    (global_pid = true, sscanf(data, \"global-pid=%u\", &pid) == 1)) {\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tif (global_pid)\n\t\t\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\t\telse\n\t\t\tp = find_task_by_vpid(pid);\n\t\tif (p)\n\t\t\tdomain = tomoyo_real_domain(p);\n\t\trcu_read_unlock();\n\t} else if (!strncmp(data, \"domain=\", 7)) {\n\t\tif (tomoyo_domain_def(data + 7))\n\t\t\tdomain = tomoyo_find_domain(data + 7);\n\t} else if (sscanf(data, \"Q=%u\", &pid) == 1) {\n\t\tdomain = tomoyo_find_domain_by_qid(pid);\n\t} else\n\t\treturn false;\n\thead->w.domain = domain;\n\t/* Accessing read_buf is safe because head->io_sem is held. */\n\tif (!head->read_buf)\n\t\treturn true; /* Do nothing if open(O_WRONLY). */\n\tmemset(&head->r, 0, sizeof(head->r));\n\thead->r.print_this_domain_only = true;\n\tif (domain)\n\t\thead->r.domain = &domain->list;\n\telse\n\t\thead->r.eof = 1;\n\ttomoyo_io_printf(head, \"# select %s\\n\", data);\n\tif (domain && domain->is_deleted)\n\t\ttomoyo_io_printf(head, \"# This is a deleted domain.\\n\");\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_select_domain(struct tomoyo_io_buffer *head,\n\t\t\t\t const char *data)\n{\n\tunsigned int pid;\n\tstruct tomoyo_domain_info *domain = NULL;\n\tbool global_pid = false;\n\tif (strncmp(data, \"select \", 7))\n\t\treturn false;\n\tdata += 7;\n\tif (sscanf(data, \"pid=%u\", &pid) == 1 ||\n\t    (global_pid = true, sscanf(data, \"global-pid=%u\", &pid) == 1)) {\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tif (global_pid)\n\t\t\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\t\telse\n\t\t\tp = find_task_by_vpid(pid);\n\t\tif (p)\n\t\t\tdomain = tomoyo_real_domain(p);\n\t\trcu_read_unlock();\n\t} else if (!strncmp(data, \"domain=\", 7)) {\n\t\tif (tomoyo_domain_def(data + 7))\n\t\t\tdomain = tomoyo_find_domain(data + 7);\n\t} else if (sscanf(data, \"Q=%u\", &pid) == 1) {\n\t\tdomain = tomoyo_find_domain_by_qid(pid);\n\t} else\n\t\treturn false;\n\thead->w.domain = domain;\n\t/* Accessing read_buf is safe because head->io_sem is held. */\n\tif (!head->read_buf)\n\t\treturn true; /* Do nothing if open(O_WRONLY). */\n\tmemset(&head->r, 0, sizeof(head->r));\n\thead->r.print_this_domain_only = true;\n\tif (domain)\n\t\thead->r.domain = &domain->list;\n\telse\n\t\thead->r.eof = 1;\n\ttomoyo_io_printf(head, \"# select %s\\n\", data);\n\tif (domain && domain->is_deleted)\n\t\ttomoyo_io_printf(head, \"# This is a deleted domain.\\n\");\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&head->r",
            "0",
            "sizeof(head->r)"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cp0",
            "\"reset\""
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_normalize_line",
          "args": [
            "cp0"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_normalize_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "396-414",
          "snippet": "void tomoyo_normalize_line(unsigned char *buffer)\n{\n\tunsigned char *sp = buffer;\n\tunsigned char *dp = buffer;\n\tbool first = true;\n\n\twhile (tomoyo_invalid(*sp))\n\t\tsp++;\n\twhile (*sp) {\n\t\tif (!first)\n\t\t\t*dp++ = ' ';\n\t\tfirst = false;\n\t\twhile (tomoyo_valid(*sp))\n\t\t\t*dp++ = *sp++;\n\t\twhile (tomoyo_invalid(*sp))\n\t\t\tsp++;\n\t}\n\t*dp = '\\0';\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_normalize_line(unsigned char *buffer)\n{\n\tunsigned char *sp = buffer;\n\tunsigned char *dp = buffer;\n\tbool first = true;\n\n\twhile (tomoyo_invalid(*sp))\n\t\tsp++;\n\twhile (*sp) {\n\t\tif (!first)\n\t\t\t*dp++ = ' ';\n\t\tfirst = false;\n\t\twhile (tomoyo_valid(*sp))\n\t\t\t*dp++ = *sp++;\n\t\twhile (tomoyo_invalid(*sp))\n\t\t\tsp++;\n\t}\n\t*dp = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "c",
            "buffer"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cp0"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "cp",
            "cp0",
            "head->w.avail"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len",
            "GFP_NOFS"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_read_lock",
          "args": [],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1096-1099",
          "snippet": "static inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&head->io_sem"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "buffer",
            "buffer_len"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nssize_t tomoyo_write_control(struct tomoyo_io_buffer *head,\n\t\t\t     const char __user *buffer, const int buffer_len)\n{\n\tint error = buffer_len;\n\tsize_t avail_len = buffer_len;\n\tchar *cp0 = head->write_buf;\n\tint idx;\n\tif (!head->write)\n\t\treturn -ENOSYS;\n\tif (!access_ok(VERIFY_READ, buffer, buffer_len))\n\t\treturn -EFAULT;\n\tif (mutex_lock_interruptible(&head->io_sem))\n\t\treturn -EINTR;\n\thead->read_user_buf_avail = 0;\n\tidx = tomoyo_read_lock();\n\t/* Read a line and dispatch it to the policy handler. */\n\twhile (avail_len > 0) {\n\t\tchar c;\n\t\tif (head->w.avail >= head->writebuf_size - 1) {\n\t\t\tconst int len = head->writebuf_size * 2;\n\t\t\tchar *cp = kzalloc(len, GFP_NOFS);\n\t\t\tif (!cp) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemmove(cp, cp0, head->w.avail);\n\t\t\tkfree(cp0);\n\t\t\thead->write_buf = cp;\n\t\t\tcp0 = cp;\n\t\t\thead->writebuf_size = len;\n\t\t}\n\t\tif (get_user(c, buffer)) {\n\t\t\terror = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer++;\n\t\tavail_len--;\n\t\tcp0[head->w.avail++] = c;\n\t\tif (c != '\\n')\n\t\t\tcontinue;\n\t\tcp0[head->w.avail - 1] = '\\0';\n\t\thead->w.avail = 0;\n\t\ttomoyo_normalize_line(cp0);\n\t\tif (!strcmp(cp0, \"reset\")) {\n\t\t\thead->w.ns = &tomoyo_kernel_namespace;\n\t\t\thead->w.domain = NULL;\n\t\t\tmemset(&head->r, 0, sizeof(head->r));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Don't allow updating policies by non manager programs. */\n\t\tswitch (head->type) {\n\t\tcase TOMOYO_PROCESS_STATUS:\n\t\t\t/* This does not write anything. */\n\t\t\tbreak;\n\t\tcase TOMOYO_DOMAINPOLICY:\n\t\t\tif (tomoyo_select_domain(head, cp0))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t\tif (!strcmp(cp0, \"select transition_only\")) {\n\t\t\t\thead->r.print_transition_related_only = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\tif (!tomoyo_manager()) {\n\t\t\t\terror = -EPERM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tswitch (tomoyo_parse_policy(head, cp0)) {\n\t\tcase -EPERM:\n\t\t\terror = -EPERM;\n\t\t\tgoto out;\n\t\tcase 0:\n\t\t\tswitch (head->type) {\n\t\t\tcase TOMOYO_DOMAINPOLICY:\n\t\t\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t\tcase TOMOYO_STAT:\n\t\t\tcase TOMOYO_PROFILE:\n\t\t\tcase TOMOYO_MANAGER:\n\t\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\ttomoyo_read_unlock(idx);\n\tmutex_unlock(&head->io_sem);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_parse_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2548-2573",
    "snippet": "static int tomoyo_parse_policy(struct tomoyo_io_buffer *head, char *line)\n{\n\t/* Delete request? */\n\thead->w.is_delete = !strncmp(line, \"delete \", 7);\n\tif (head->w.is_delete)\n\t\tmemmove(line, line + 7, strlen(line + 7) + 1);\n\t/* Selecting namespace to update. */\n\tif (head->type == TOMOYO_EXCEPTIONPOLICY ||\n\t    head->type == TOMOYO_PROFILE) {\n\t\tif (*line == '<') {\n\t\t\tchar *cp = strchr(line, ' ');\n\t\t\tif (cp) {\n\t\t\t\t*cp++ = '\\0';\n\t\t\t\thead->w.ns = tomoyo_assign_namespace(line);\n\t\t\t\tmemmove(line, cp, strlen(cp) + 1);\n\t\t\t} else\n\t\t\t\thead->w.ns = NULL;\n\t\t} else\n\t\t\thead->w.ns = &tomoyo_kernel_namespace;\n\t\t/* Don't allow updating if namespace is invalid. */\n\t\tif (!head->w.ns)\n\t\t\treturn -ENOENT;\n\t}\n\t/* Do the update. */\n\treturn head->write(head);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "head->write",
          "args": [
            "head"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "line",
            "cp",
            "strlen(cp) + 1"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_assign_namespace",
          "args": [
            "line"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_assign_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "448-480",
          "snippet": "struct tomoyo_policy_namespace *tomoyo_assign_namespace(const char *domainname)\n{\n\tstruct tomoyo_policy_namespace *ptr;\n\tstruct tomoyo_policy_namespace *entry;\n\tconst char *cp = domainname;\n\tunsigned int len = 0;\n\twhile (*cp && *cp++ != ' ')\n\t\tlen++;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (ptr)\n\t\treturn ptr;\n\tif (len >= TOMOYO_EXEC_TMPSIZE - 10 || !tomoyo_domain_def(domainname))\n\t\treturn NULL;\n\tentry = kzalloc(sizeof(*entry) + len + 1, GFP_NOFS);\n\tif (!entry)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (!ptr && tomoyo_memory_ok(entry)) {\n\t\tchar *name = (char *) (entry + 1);\n\t\tptr = entry;\n\t\tmemmove(name, domainname, len);\n\t\tname[len] = '\\0';\n\t\tentry->name = name;\n\t\ttomoyo_init_policy_namespace(entry);\n\t\tentry = NULL;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\tkfree(entry);\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstruct tomoyo_policy_namespace *tomoyo_assign_namespace(const char *domainname)\n{\n\tstruct tomoyo_policy_namespace *ptr;\n\tstruct tomoyo_policy_namespace *entry;\n\tconst char *cp = domainname;\n\tunsigned int len = 0;\n\twhile (*cp && *cp++ != ' ')\n\t\tlen++;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (ptr)\n\t\treturn ptr;\n\tif (len >= TOMOYO_EXEC_TMPSIZE - 10 || !tomoyo_domain_def(domainname))\n\t\treturn NULL;\n\tentry = kzalloc(sizeof(*entry) + len + 1, GFP_NOFS);\n\tif (!entry)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (!ptr && tomoyo_memory_ok(entry)) {\n\t\tchar *name = (char *) (entry + 1);\n\t\tptr = entry;\n\t\tmemmove(name, domainname, len);\n\t\tname[len] = '\\0';\n\t\tentry->name = name;\n\t\ttomoyo_init_policy_namespace(entry);\n\t\tentry = NULL;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\tkfree(entry);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "' '"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "line",
            "line + 7",
            "strlen(line + 7) + 1"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line + 7"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "line",
            "\"delete \"",
            "7"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_parse_policy(struct tomoyo_io_buffer *head, char *line)\n{\n\t/* Delete request? */\n\thead->w.is_delete = !strncmp(line, \"delete \", 7);\n\tif (head->w.is_delete)\n\t\tmemmove(line, line + 7, strlen(line + 7) + 1);\n\t/* Selecting namespace to update. */\n\tif (head->type == TOMOYO_EXCEPTIONPOLICY ||\n\t    head->type == TOMOYO_PROFILE) {\n\t\tif (*line == '<') {\n\t\t\tchar *cp = strchr(line, ' ');\n\t\t\tif (cp) {\n\t\t\t\t*cp++ = '\\0';\n\t\t\t\thead->w.ns = tomoyo_assign_namespace(line);\n\t\t\t\tmemmove(line, cp, strlen(cp) + 1);\n\t\t\t} else\n\t\t\t\thead->w.ns = NULL;\n\t\t} else\n\t\t\thead->w.ns = &tomoyo_kernel_namespace;\n\t\t/* Don't allow updating if namespace is invalid. */\n\t\tif (!head->w.ns)\n\t\t\treturn -ENOENT;\n\t}\n\t/* Do the update. */\n\treturn head->write(head);\n}"
  },
  {
    "function_name": "tomoyo_read_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2512-2536",
    "snippet": "ssize_t tomoyo_read_control(struct tomoyo_io_buffer *head, char __user *buffer,\n\t\t\t    const int buffer_len)\n{\n\tint len;\n\tint idx;\n\n\tif (!head->read)\n\t\treturn -ENOSYS;\n\tif (mutex_lock_interruptible(&head->io_sem))\n\t\treturn -EINTR;\n\thead->read_user_buf = buffer;\n\thead->read_user_buf_avail = buffer_len;\n\tidx = tomoyo_read_lock();\n\tif (tomoyo_flush(head))\n\t\t/* Call the policy handler. */\n\t\tdo {\n\t\t\ttomoyo_set_namespace_cursor(head);\n\t\t\thead->read(head);\n\t\t} while (tomoyo_flush(head) &&\n\t\t\t tomoyo_has_more_namespace(head));\n\ttomoyo_read_unlock(idx);\n\tlen = head->read_user_buf - buffer;\n\tmutex_unlock(&head->io_sem);\n\treturn len;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&head->io_sem"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_read_unlock",
          "args": [
            "idx"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_has_more_namespace",
          "args": [
            "head"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_has_more_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2496-2501",
          "snippet": "static inline bool tomoyo_has_more_namespace(struct tomoyo_io_buffer *head)\n{\n\treturn (head->type == TOMOYO_EXCEPTIONPOLICY ||\n\t\thead->type == TOMOYO_PROFILE) && head->r.eof &&\n\t\thead->r.ns->next != &tomoyo_namespace_list;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic inline bool tomoyo_has_more_namespace(struct tomoyo_io_buffer *head)\n{\n\treturn (head->type == TOMOYO_EXCEPTIONPOLICY ||\n\t\thead->type == TOMOYO_PROFILE) && head->r.eof &&\n\t\thead->r.ns->next != &tomoyo_namespace_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_flush",
          "args": [
            "head"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "212-245",
          "snippet": "static bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "head->read",
          "args": [
            "head"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_set_namespace_cursor",
          "args": [
            "head"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_namespace_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2471-2487",
          "snippet": "static inline void tomoyo_set_namespace_cursor(struct tomoyo_io_buffer *head)\n{\n\tstruct list_head *ns;\n\tif (head->type != TOMOYO_EXCEPTIONPOLICY &&\n\t    head->type != TOMOYO_PROFILE)\n\t\treturn;\n\t/*\n\t * If this is the first read, or reading previous namespace finished\n\t * and has more namespaces to read, update the namespace cursor.\n\t */\n\tns = head->r.ns;\n\tif (!ns || (head->r.eof && ns->next != &tomoyo_namespace_list)) {\n\t\t/* Clearing is OK because tomoyo_flush() returned true. */\n\t\tmemset(&head->r, 0, sizeof(head->r));\n\t\thead->r.ns = ns ? ns->next : tomoyo_namespace_list.next;\n\t}\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic inline void tomoyo_set_namespace_cursor(struct tomoyo_io_buffer *head)\n{\n\tstruct list_head *ns;\n\tif (head->type != TOMOYO_EXCEPTIONPOLICY &&\n\t    head->type != TOMOYO_PROFILE)\n\t\treturn;\n\t/*\n\t * If this is the first read, or reading previous namespace finished\n\t * and has more namespaces to read, update the namespace cursor.\n\t */\n\tns = head->r.ns;\n\tif (!ns || (head->r.eof && ns->next != &tomoyo_namespace_list)) {\n\t\t/* Clearing is OK because tomoyo_flush() returned true. */\n\t\tmemset(&head->r, 0, sizeof(head->r));\n\t\thead->r.ns = ns ? ns->next : tomoyo_namespace_list.next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_lock",
          "args": [],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1096-1099",
          "snippet": "static inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&head->io_sem"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nssize_t tomoyo_read_control(struct tomoyo_io_buffer *head, char __user *buffer,\n\t\t\t    const int buffer_len)\n{\n\tint len;\n\tint idx;\n\n\tif (!head->read)\n\t\treturn -ENOSYS;\n\tif (mutex_lock_interruptible(&head->io_sem))\n\t\treturn -EINTR;\n\thead->read_user_buf = buffer;\n\thead->read_user_buf_avail = buffer_len;\n\tidx = tomoyo_read_lock();\n\tif (tomoyo_flush(head))\n\t\t/* Call the policy handler. */\n\t\tdo {\n\t\t\ttomoyo_set_namespace_cursor(head);\n\t\t\thead->read(head);\n\t\t} while (tomoyo_flush(head) &&\n\t\t\t tomoyo_has_more_namespace(head));\n\ttomoyo_read_unlock(idx);\n\tlen = head->read_user_buf - buffer;\n\tmutex_unlock(&head->io_sem);\n\treturn len;\n}"
  },
  {
    "function_name": "tomoyo_has_more_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2496-2501",
    "snippet": "static inline bool tomoyo_has_more_namespace(struct tomoyo_io_buffer *head)\n{\n\treturn (head->type == TOMOYO_EXCEPTIONPOLICY ||\n\t\thead->type == TOMOYO_PROFILE) && head->r.eof &&\n\t\thead->r.ns->next != &tomoyo_namespace_list;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic inline bool tomoyo_has_more_namespace(struct tomoyo_io_buffer *head)\n{\n\treturn (head->type == TOMOYO_EXCEPTIONPOLICY ||\n\t\thead->type == TOMOYO_PROFILE) && head->r.eof &&\n\t\thead->r.ns->next != &tomoyo_namespace_list;\n}"
  },
  {
    "function_name": "tomoyo_set_namespace_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2471-2487",
    "snippet": "static inline void tomoyo_set_namespace_cursor(struct tomoyo_io_buffer *head)\n{\n\tstruct list_head *ns;\n\tif (head->type != TOMOYO_EXCEPTIONPOLICY &&\n\t    head->type != TOMOYO_PROFILE)\n\t\treturn;\n\t/*\n\t * If this is the first read, or reading previous namespace finished\n\t * and has more namespaces to read, update the namespace cursor.\n\t */\n\tns = head->r.ns;\n\tif (!ns || (head->r.eof && ns->next != &tomoyo_namespace_list)) {\n\t\t/* Clearing is OK because tomoyo_flush() returned true. */\n\t\tmemset(&head->r, 0, sizeof(head->r));\n\t\thead->r.ns = ns ? ns->next : tomoyo_namespace_list.next;\n\t}\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&head->r",
            "0",
            "sizeof(head->r)"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic inline void tomoyo_set_namespace_cursor(struct tomoyo_io_buffer *head)\n{\n\tstruct list_head *ns;\n\tif (head->type != TOMOYO_EXCEPTIONPOLICY &&\n\t    head->type != TOMOYO_PROFILE)\n\t\treturn;\n\t/*\n\t * If this is the first read, or reading previous namespace finished\n\t * and has more namespaces to read, update the namespace cursor.\n\t */\n\tns = head->r.ns;\n\tif (!ns || (head->r.eof && ns->next != &tomoyo_namespace_list)) {\n\t\t/* Clearing is OK because tomoyo_flush() returned true. */\n\t\tmemset(&head->r, 0, sizeof(head->r));\n\t\thead->r.ns = ns ? ns->next : tomoyo_namespace_list.next;\n\t}\n}"
  },
  {
    "function_name": "tomoyo_poll_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2456-2462",
    "snippet": "unsigned int tomoyo_poll_control(struct file *file, poll_table *wait)\n{\n\tstruct tomoyo_io_buffer *head = file->private_data;\n\tif (head->poll)\n\t\treturn head->poll(file, wait) | POLLOUT | POLLWRNORM;\n\treturn POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "head->poll",
          "args": [
            "file",
            "wait"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nunsigned int tomoyo_poll_control(struct file *file, poll_table *wait)\n{\n\tstruct tomoyo_io_buffer *head = file->private_data;\n\tif (head->poll)\n\t\treturn head->poll(file, wait) | POLLOUT | POLLWRNORM;\n\treturn POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM;\n}"
  },
  {
    "function_name": "tomoyo_open_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2346-2445",
    "snippet": "int tomoyo_open_control(const u8 type, struct file *file)\n{\n\tstruct tomoyo_io_buffer *head = kzalloc(sizeof(*head), GFP_NOFS);\n\n\tif (!head)\n\t\treturn -ENOMEM;\n\tmutex_init(&head->io_sem);\n\thead->type = type;\n\tswitch (type) {\n\tcase TOMOYO_DOMAINPOLICY:\n\t\t/* /sys/kernel/security/tomoyo/domain_policy */\n\t\thead->write = tomoyo_write_domain;\n\t\thead->read = tomoyo_read_domain;\n\t\tbreak;\n\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t/* /sys/kernel/security/tomoyo/exception_policy */\n\t\thead->write = tomoyo_write_exception;\n\t\thead->read = tomoyo_read_exception;\n\t\tbreak;\n\tcase TOMOYO_AUDIT:\n\t\t/* /sys/kernel/security/tomoyo/audit */\n\t\thead->poll = tomoyo_poll_log;\n\t\thead->read = tomoyo_read_log;\n\t\tbreak;\n\tcase TOMOYO_PROCESS_STATUS:\n\t\t/* /sys/kernel/security/tomoyo/.process_status */\n\t\thead->write = tomoyo_write_pid;\n\t\thead->read = tomoyo_read_pid;\n\t\tbreak;\n\tcase TOMOYO_VERSION:\n\t\t/* /sys/kernel/security/tomoyo/version */\n\t\thead->read = tomoyo_read_version;\n\t\thead->readbuf_size = 128;\n\t\tbreak;\n\tcase TOMOYO_STAT:\n\t\t/* /sys/kernel/security/tomoyo/stat */\n\t\thead->write = tomoyo_write_stat;\n\t\thead->read = tomoyo_read_stat;\n\t\thead->readbuf_size = 1024;\n\t\tbreak;\n\tcase TOMOYO_PROFILE:\n\t\t/* /sys/kernel/security/tomoyo/profile */\n\t\thead->write = tomoyo_write_profile;\n\t\thead->read = tomoyo_read_profile;\n\t\tbreak;\n\tcase TOMOYO_QUERY: /* /sys/kernel/security/tomoyo/query */\n\t\thead->poll = tomoyo_poll_query;\n\t\thead->write = tomoyo_write_answer;\n\t\thead->read = tomoyo_read_query;\n\t\tbreak;\n\tcase TOMOYO_MANAGER:\n\t\t/* /sys/kernel/security/tomoyo/manager */\n\t\thead->write = tomoyo_write_manager;\n\t\thead->read = tomoyo_read_manager;\n\t\tbreak;\n\t}\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\t/*\n\t\t * No need to allocate read_buf since it is not opened\n\t\t * for reading.\n\t\t */\n\t\thead->read = NULL;\n\t\thead->poll = NULL;\n\t} else if (!head->poll) {\n\t\t/* Don't allocate read_buf for poll() access. */\n\t\tif (!head->readbuf_size)\n\t\t\thead->readbuf_size = 4096 * 2;\n\t\thead->read_buf = kzalloc(head->readbuf_size, GFP_NOFS);\n\t\tif (!head->read_buf) {\n\t\t\tkfree(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tif (!(file->f_mode & FMODE_WRITE)) {\n\t\t/*\n\t\t * No need to allocate write_buf since it is not opened\n\t\t * for writing.\n\t\t */\n\t\thead->write = NULL;\n\t} else if (head->write) {\n\t\thead->writebuf_size = 4096 * 2;\n\t\thead->write_buf = kzalloc(head->writebuf_size, GFP_NOFS);\n\t\tif (!head->write_buf) {\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\t/*\n\t * If the file is /sys/kernel/security/tomoyo/query , increment the\n\t * observer counter.\n\t * The obserber counter is used by tomoyo_supervisor() to see if\n\t * there is some process monitoring /sys/kernel/security/tomoyo/query.\n\t */\n\tif (type == TOMOYO_QUERY)\n\t\tatomic_inc(&tomoyo_query_observers);\n\tfile->private_data = head;\n\ttomoyo_notify_gc(head, true);\n\treturn 0;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t tomoyo_query_observers = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_notify_gc",
          "args": [
            "head",
            "true"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_notify_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "631-651",
          "snippet": "void tomoyo_notify_gc(struct tomoyo_io_buffer *head, const bool is_register)\n{\n\tbool is_write = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tif (is_register) {\n\t\thead->users = 1;\n\t\tlist_add(&head->list, &tomoyo_io_buffer_list);\n\t} else {\n\t\tis_write = head->write_buf != NULL;\n\t\tif (!--head->users) {\n\t\t\tlist_del(&head->list);\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head->write_buf);\n\t\t\tkfree(head);\n\t\t}\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\tif (is_write)\n\t\tkthread_run(tomoyo_gc_thread, NULL, \"GC for TOMOYO\");\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(tomoyo_io_buffer_list);",
            "static DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic LIST_HEAD(tomoyo_io_buffer_list);\nstatic DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);\n\nvoid tomoyo_notify_gc(struct tomoyo_io_buffer *head, const bool is_register)\n{\n\tbool is_write = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tif (is_register) {\n\t\thead->users = 1;\n\t\tlist_add(&head->list, &tomoyo_io_buffer_list);\n\t} else {\n\t\tis_write = head->write_buf != NULL;\n\t\tif (!--head->users) {\n\t\t\tlist_del(&head->list);\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head->write_buf);\n\t\t\tkfree(head);\n\t\t}\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\tif (is_write)\n\t\tkthread_run(tomoyo_gc_thread, NULL, \"GC for TOMOYO\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&tomoyo_query_observers"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "head"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "head->read_buf"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "head->writebuf_size",
            "GFP_NOFS"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "head"
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "head->readbuf_size",
            "GFP_NOFS"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&head->io_sem"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*head)",
            "GFP_NOFS"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic atomic_t tomoyo_query_observers = ATOMIC_INIT(0);\n\nint tomoyo_open_control(const u8 type, struct file *file)\n{\n\tstruct tomoyo_io_buffer *head = kzalloc(sizeof(*head), GFP_NOFS);\n\n\tif (!head)\n\t\treturn -ENOMEM;\n\tmutex_init(&head->io_sem);\n\thead->type = type;\n\tswitch (type) {\n\tcase TOMOYO_DOMAINPOLICY:\n\t\t/* /sys/kernel/security/tomoyo/domain_policy */\n\t\thead->write = tomoyo_write_domain;\n\t\thead->read = tomoyo_read_domain;\n\t\tbreak;\n\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t/* /sys/kernel/security/tomoyo/exception_policy */\n\t\thead->write = tomoyo_write_exception;\n\t\thead->read = tomoyo_read_exception;\n\t\tbreak;\n\tcase TOMOYO_AUDIT:\n\t\t/* /sys/kernel/security/tomoyo/audit */\n\t\thead->poll = tomoyo_poll_log;\n\t\thead->read = tomoyo_read_log;\n\t\tbreak;\n\tcase TOMOYO_PROCESS_STATUS:\n\t\t/* /sys/kernel/security/tomoyo/.process_status */\n\t\thead->write = tomoyo_write_pid;\n\t\thead->read = tomoyo_read_pid;\n\t\tbreak;\n\tcase TOMOYO_VERSION:\n\t\t/* /sys/kernel/security/tomoyo/version */\n\t\thead->read = tomoyo_read_version;\n\t\thead->readbuf_size = 128;\n\t\tbreak;\n\tcase TOMOYO_STAT:\n\t\t/* /sys/kernel/security/tomoyo/stat */\n\t\thead->write = tomoyo_write_stat;\n\t\thead->read = tomoyo_read_stat;\n\t\thead->readbuf_size = 1024;\n\t\tbreak;\n\tcase TOMOYO_PROFILE:\n\t\t/* /sys/kernel/security/tomoyo/profile */\n\t\thead->write = tomoyo_write_profile;\n\t\thead->read = tomoyo_read_profile;\n\t\tbreak;\n\tcase TOMOYO_QUERY: /* /sys/kernel/security/tomoyo/query */\n\t\thead->poll = tomoyo_poll_query;\n\t\thead->write = tomoyo_write_answer;\n\t\thead->read = tomoyo_read_query;\n\t\tbreak;\n\tcase TOMOYO_MANAGER:\n\t\t/* /sys/kernel/security/tomoyo/manager */\n\t\thead->write = tomoyo_write_manager;\n\t\thead->read = tomoyo_read_manager;\n\t\tbreak;\n\t}\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\t/*\n\t\t * No need to allocate read_buf since it is not opened\n\t\t * for reading.\n\t\t */\n\t\thead->read = NULL;\n\t\thead->poll = NULL;\n\t} else if (!head->poll) {\n\t\t/* Don't allocate read_buf for poll() access. */\n\t\tif (!head->readbuf_size)\n\t\t\thead->readbuf_size = 4096 * 2;\n\t\thead->read_buf = kzalloc(head->readbuf_size, GFP_NOFS);\n\t\tif (!head->read_buf) {\n\t\t\tkfree(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tif (!(file->f_mode & FMODE_WRITE)) {\n\t\t/*\n\t\t * No need to allocate write_buf since it is not opened\n\t\t * for writing.\n\t\t */\n\t\thead->write = NULL;\n\t} else if (head->write) {\n\t\thead->writebuf_size = 4096 * 2;\n\t\thead->write_buf = kzalloc(head->writebuf_size, GFP_NOFS);\n\t\tif (!head->write_buf) {\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\t/*\n\t * If the file is /sys/kernel/security/tomoyo/query , increment the\n\t * observer counter.\n\t * The obserber counter is used by tomoyo_supervisor() to see if\n\t * there is some process monitoring /sys/kernel/security/tomoyo/query.\n\t */\n\tif (type == TOMOYO_QUERY)\n\t\tatomic_inc(&tomoyo_query_observers);\n\tfile->private_data = head;\n\ttomoyo_notify_gc(head, true);\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_write_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2327-2336",
    "snippet": "static int tomoyo_write_stat(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\tu8 i;\n\tif (tomoyo_str_starts(&data, \"Memory used by \"))\n\t\tfor (i = 0; i < TOMOYO_MAX_MEMORY_STAT; i++)\n\t\t\tif (tomoyo_str_starts(&data, tomoyo_memory_headers[i]))\n\t\t\t\tsscanf(data, \"%u\", &tomoyo_memory_quota[i]);\n\treturn 0;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const tomoyo_memory_headers[TOMOYO_MAX_MEMORY_STAT] = {\n\t[TOMOYO_MEMORY_POLICY] = \"policy:\",\n\t[TOMOYO_MEMORY_AUDIT]  = \"audit log:\",\n\t[TOMOYO_MEMORY_QUERY]  = \"query message:\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "data",
            "\"%u\"",
            "&tomoyo_memory_quota[i]"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_str_starts",
          "args": [
            "&data",
            "tomoyo_memory_headers[i]"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_str_starts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "374-384",
          "snippet": "bool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic const char * const tomoyo_memory_headers[TOMOYO_MAX_MEMORY_STAT] = {\n\t[TOMOYO_MEMORY_POLICY] = \"policy:\",\n\t[TOMOYO_MEMORY_AUDIT]  = \"audit log:\",\n\t[TOMOYO_MEMORY_QUERY]  = \"query message:\",\n};\n\nstatic int tomoyo_write_stat(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\tu8 i;\n\tif (tomoyo_str_starts(&data, \"Memory used by \"))\n\t\tfor (i = 0; i < TOMOYO_MAX_MEMORY_STAT; i++)\n\t\t\tif (tomoyo_str_starts(&data, tomoyo_memory_headers[i]))\n\t\t\t\tsscanf(data, \"%u\", &tomoyo_memory_quota[i]);\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_read_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2285-2318",
    "snippet": "static void tomoyo_read_stat(struct tomoyo_io_buffer *head)\n{\n\tu8 i;\n\tunsigned int total = 0;\n\tif (head->r.eof)\n\t\treturn;\n\tfor (i = 0; i < TOMOYO_MAX_POLICY_STAT; i++) {\n\t\ttomoyo_io_printf(head, \"Policy %-30s %10u\",\n\t\t\t\t tomoyo_policy_headers[i],\n\t\t\t\t tomoyo_stat_updated[i]);\n\t\tif (tomoyo_stat_modified[i]) {\n\t\t\tstruct tomoyo_time stamp;\n\t\t\ttomoyo_convert_time(tomoyo_stat_modified[i], &stamp);\n\t\t\ttomoyo_io_printf(head, \" (Last: %04u/%02u/%02u \"\n\t\t\t\t\t \"%02u:%02u:%02u)\",\n\t\t\t\t\t stamp.year, stamp.month, stamp.day,\n\t\t\t\t\t stamp.hour, stamp.min, stamp.sec);\n\t\t}\n\t\ttomoyo_set_lf(head);\n\t}\n\tfor (i = 0; i < TOMOYO_MAX_MEMORY_STAT; i++) {\n\t\tunsigned int used = tomoyo_memory_used[i];\n\t\ttotal += used;\n\t\ttomoyo_io_printf(head, \"Memory used by %-22s %10u\",\n\t\t\t\t tomoyo_memory_headers[i], used);\n\t\tused = tomoyo_memory_quota[i];\n\t\tif (used)\n\t\t\ttomoyo_io_printf(head, \" (Quota: %10u)\", used);\n\t\ttomoyo_set_lf(head);\n\t}\n\ttomoyo_io_printf(head, \"Total memory used:                    %10u\\n\",\n\t\t\t total);\n\thead->r.eof = true;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const tomoyo_policy_headers[TOMOYO_MAX_POLICY_STAT] = {\n\t[TOMOYO_STAT_POLICY_UPDATES]    = \"update:\",\n\t[TOMOYO_STAT_POLICY_LEARNING]   = \"violation in learning mode:\",\n\t[TOMOYO_STAT_POLICY_PERMISSIVE] = \"violation in permissive mode:\",\n\t[TOMOYO_STAT_POLICY_ENFORCING]  = \"violation in enforcing mode:\",\n};",
      "static const char * const tomoyo_memory_headers[TOMOYO_MAX_MEMORY_STAT] = {\n\t[TOMOYO_MEMORY_POLICY] = \"policy:\",\n\t[TOMOYO_MEMORY_AUDIT]  = \"audit log:\",\n\t[TOMOYO_MEMORY_QUERY]  = \"query message:\",\n};",
      "static unsigned int tomoyo_stat_updated[TOMOYO_MAX_POLICY_STAT];",
      "static time64_t tomoyo_stat_modified[TOMOYO_MAX_POLICY_STAT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_io_printf",
          "args": [
            "head",
            "\"Total memory used:                    %10u\\n\"",
            "total"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_io_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "275-293",
          "snippet": "static void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_lf",
          "args": [
            "head"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_lf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "314-318",
          "snippet": "static bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_convert_time",
          "args": [
            "tomoyo_stat_modified[i]",
            "&stamp"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_convert_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "91-101",
          "snippet": "void tomoyo_convert_time(time64_t time64, struct tomoyo_time *stamp)\n{\n\tstruct tm tm;\n\ttime64_to_tm(time64, 0, &tm);\n\tstamp->sec = tm.tm_sec;\n\tstamp->min = tm.tm_min;\n\tstamp->hour = tm.tm_hour;\n\tstamp->day = tm.tm_mday;\n\tstamp->month = tm.tm_mon + 1;\n\tstamp->year = tm.tm_year + 1900;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_convert_time(time64_t time64, struct tomoyo_time *stamp)\n{\n\tstruct tm tm;\n\ttime64_to_tm(time64, 0, &tm);\n\tstamp->sec = tm.tm_sec;\n\tstamp->min = tm.tm_min;\n\tstamp->hour = tm.tm_hour;\n\tstamp->day = tm.tm_mday;\n\tstamp->month = tm.tm_mon + 1;\n\tstamp->year = tm.tm_year + 1900;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic const char * const tomoyo_policy_headers[TOMOYO_MAX_POLICY_STAT] = {\n\t[TOMOYO_STAT_POLICY_UPDATES]    = \"update:\",\n\t[TOMOYO_STAT_POLICY_LEARNING]   = \"violation in learning mode:\",\n\t[TOMOYO_STAT_POLICY_PERMISSIVE] = \"violation in permissive mode:\",\n\t[TOMOYO_STAT_POLICY_ENFORCING]  = \"violation in enforcing mode:\",\n};\nstatic const char * const tomoyo_memory_headers[TOMOYO_MAX_MEMORY_STAT] = {\n\t[TOMOYO_MEMORY_POLICY] = \"policy:\",\n\t[TOMOYO_MEMORY_AUDIT]  = \"audit log:\",\n\t[TOMOYO_MEMORY_QUERY]  = \"query message:\",\n};\nstatic unsigned int tomoyo_stat_updated[TOMOYO_MAX_POLICY_STAT];\nstatic time64_t tomoyo_stat_modified[TOMOYO_MAX_POLICY_STAT];\n\nstatic void tomoyo_read_stat(struct tomoyo_io_buffer *head)\n{\n\tu8 i;\n\tunsigned int total = 0;\n\tif (head->r.eof)\n\t\treturn;\n\tfor (i = 0; i < TOMOYO_MAX_POLICY_STAT; i++) {\n\t\ttomoyo_io_printf(head, \"Policy %-30s %10u\",\n\t\t\t\t tomoyo_policy_headers[i],\n\t\t\t\t tomoyo_stat_updated[i]);\n\t\tif (tomoyo_stat_modified[i]) {\n\t\t\tstruct tomoyo_time stamp;\n\t\t\ttomoyo_convert_time(tomoyo_stat_modified[i], &stamp);\n\t\t\ttomoyo_io_printf(head, \" (Last: %04u/%02u/%02u \"\n\t\t\t\t\t \"%02u:%02u:%02u)\",\n\t\t\t\t\t stamp.year, stamp.month, stamp.day,\n\t\t\t\t\t stamp.hour, stamp.min, stamp.sec);\n\t\t}\n\t\ttomoyo_set_lf(head);\n\t}\n\tfor (i = 0; i < TOMOYO_MAX_MEMORY_STAT; i++) {\n\t\tunsigned int used = tomoyo_memory_used[i];\n\t\ttotal += used;\n\t\ttomoyo_io_printf(head, \"Memory used by %-22s %10u\",\n\t\t\t\t tomoyo_memory_headers[i], used);\n\t\tused = tomoyo_memory_quota[i];\n\t\tif (used)\n\t\t\ttomoyo_io_printf(head, \" (Quota: %10u)\", used);\n\t\ttomoyo_set_lf(head);\n\t}\n\ttomoyo_io_printf(head, \"Total memory used:                    %10u\\n\",\n\t\t\t total);\n\thead->r.eof = true;\n}"
  },
  {
    "function_name": "tomoyo_update_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2269-2276",
    "snippet": "void tomoyo_update_stat(const u8 index)\n{\n\t/*\n\t * I don't use atomic operations because race condition is not fatal.\n\t */\n\ttomoyo_stat_updated[index]++;\n\ttomoyo_stat_modified[index] = ktime_get_real_seconds();\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int tomoyo_stat_updated[TOMOYO_MAX_POLICY_STAT];",
      "static time64_t tomoyo_stat_modified[TOMOYO_MAX_POLICY_STAT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int tomoyo_stat_updated[TOMOYO_MAX_POLICY_STAT];\nstatic time64_t tomoyo_stat_modified[TOMOYO_MAX_POLICY_STAT];\n\nvoid tomoyo_update_stat(const u8 index)\n{\n\t/*\n\t * I don't use atomic operations because race condition is not fatal.\n\t */\n\ttomoyo_stat_updated[index]++;\n\ttomoyo_stat_modified[index] = ktime_get_real_seconds();\n}"
  },
  {
    "function_name": "tomoyo_read_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2234-2240",
    "snippet": "static void tomoyo_read_version(struct tomoyo_io_buffer *head)\n{\n\tif (!head->r.eof) {\n\t\ttomoyo_io_printf(head, \"2.5.0\");\n\t\thead->r.eof = true;\n\t}\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_io_printf",
          "args": [
            "head",
            "\"2.5.0\""
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_io_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "275-293",
          "snippet": "static void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_read_version(struct tomoyo_io_buffer *head)\n{\n\tif (!head->r.eof) {\n\t\ttomoyo_io_printf(head, \"2.5.0\");\n\t\thead->r.eof = true;\n\t}\n}"
  },
  {
    "function_name": "tomoyo_write_answer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2198-2225",
    "snippet": "static int tomoyo_write_answer(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\tstruct list_head *tmp;\n\tunsigned int serial;\n\tunsigned int answer;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each(tmp, &tomoyo_query_list) {\n\t\tstruct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);\n\t\tptr->timer = 0;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (sscanf(data, \"A%u=%u\", &serial, &answer) != 2)\n\t\treturn -EINVAL;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each(tmp, &tomoyo_query_list) {\n\t\tstruct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);\n\t\tif (ptr->serial != serial)\n\t\t\tcontinue;\n\t\tptr->answer = answer;\n\t\t/* Remove from tomoyo_query_list. */\n\t\tif (ptr->answer)\n\t\t\tlist_del_init(&ptr->list);\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);",
      "static LIST_HEAD(tomoyo_query_list);",
      "static DEFINE_SPINLOCK(tomoyo_query_list_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ptr->list"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "typeof(*ptr)",
            "list"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp",
            "&tomoyo_query_list"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "data",
            "\"A%u=%u\"",
            "&serial",
            "&answer"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "typeof(*ptr)",
            "list"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp",
            "&tomoyo_query_list"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);\nstatic LIST_HEAD(tomoyo_query_list);\nstatic DEFINE_SPINLOCK(tomoyo_query_list_lock);\n\nstatic int tomoyo_write_answer(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\tstruct list_head *tmp;\n\tunsigned int serial;\n\tunsigned int answer;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each(tmp, &tomoyo_query_list) {\n\t\tstruct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);\n\t\tptr->timer = 0;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (sscanf(data, \"A%u=%u\", &serial, &answer) != 2)\n\t\treturn -EINVAL;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each(tmp, &tomoyo_query_list) {\n\t\tstruct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);\n\t\tif (ptr->serial != serial)\n\t\t\tcontinue;\n\t\tptr->answer = answer;\n\t\t/* Remove from tomoyo_query_list. */\n\t\tif (ptr->answer)\n\t\t\tlist_del_init(&ptr->list);\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_read_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2138-2189",
    "snippet": "static void tomoyo_read_query(struct tomoyo_io_buffer *head)\n{\n\tstruct list_head *tmp;\n\tunsigned int pos = 0;\n\tsize_t len = 0;\n\tchar *buf;\n\tif (head->r.w_pos)\n\t\treturn;\n\tif (head->read_buf) {\n\t\tkfree(head->read_buf);\n\t\thead->read_buf = NULL;\n\t}\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each(tmp, &tomoyo_query_list) {\n\t\tstruct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);\n\t\tif (pos++ != head->r.query_index)\n\t\t\tcontinue;\n\t\tlen = ptr->query_len;\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (!len) {\n\t\thead->r.query_index = 0;\n\t\treturn;\n\t}\n\tbuf = kzalloc(len + 32, GFP_NOFS);\n\tif (!buf)\n\t\treturn;\n\tpos = 0;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each(tmp, &tomoyo_query_list) {\n\t\tstruct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);\n\t\tif (pos++ != head->r.query_index)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Some query can be skipped because tomoyo_query_list\n\t\t * can change, but I don't care.\n\t\t */\n\t\tif (len == ptr->query_len)\n\t\t\tsnprintf(buf, len + 31, \"Q%u-%hu\\n%s\", ptr->serial,\n\t\t\t\t ptr->retry, ptr->query);\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (buf[0]) {\n\t\thead->read_buf = buf;\n\t\thead->r.w[head->r.w_pos++] = buf;\n\t\thead->r.query_index++;\n\t} else {\n\t\tkfree(buf);\n\t}\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);",
      "static LIST_HEAD(tomoyo_query_list);",
      "static DEFINE_SPINLOCK(tomoyo_query_list_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "len + 31",
            "\"Q%u-%hu\\n%s\"",
            "ptr->serial",
            "ptr->retry",
            "ptr->query"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "typeof(*ptr)",
            "list"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp",
            "&tomoyo_query_list"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len + 32",
            "GFP_NOFS"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "typeof(*ptr)",
            "list"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp",
            "&tomoyo_query_list"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "head->read_buf"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);\nstatic LIST_HEAD(tomoyo_query_list);\nstatic DEFINE_SPINLOCK(tomoyo_query_list_lock);\n\nstatic void tomoyo_read_query(struct tomoyo_io_buffer *head)\n{\n\tstruct list_head *tmp;\n\tunsigned int pos = 0;\n\tsize_t len = 0;\n\tchar *buf;\n\tif (head->r.w_pos)\n\t\treturn;\n\tif (head->read_buf) {\n\t\tkfree(head->read_buf);\n\t\thead->read_buf = NULL;\n\t}\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each(tmp, &tomoyo_query_list) {\n\t\tstruct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);\n\t\tif (pos++ != head->r.query_index)\n\t\t\tcontinue;\n\t\tlen = ptr->query_len;\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (!len) {\n\t\thead->r.query_index = 0;\n\t\treturn;\n\t}\n\tbuf = kzalloc(len + 32, GFP_NOFS);\n\tif (!buf)\n\t\treturn;\n\tpos = 0;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each(tmp, &tomoyo_query_list) {\n\t\tstruct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);\n\t\tif (pos++ != head->r.query_index)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Some query can be skipped because tomoyo_query_list\n\t\t * can change, but I don't care.\n\t\t */\n\t\tif (len == ptr->query_len)\n\t\t\tsnprintf(buf, len + 31, \"Q%u-%hu\\n%s\", ptr->serial,\n\t\t\t\t ptr->retry, ptr->query);\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (buf[0]) {\n\t\thead->read_buf = buf;\n\t\thead->r.w[head->r.w_pos++] = buf;\n\t\thead->r.query_index++;\n\t} else {\n\t\tkfree(buf);\n\t}\n}"
  },
  {
    "function_name": "tomoyo_poll_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2123-2131",
    "snippet": "static unsigned int tomoyo_poll_query(struct file *file, poll_table *wait)\n{\n\tif (!list_empty(&tomoyo_query_list))\n\t\treturn POLLIN | POLLRDNORM;\n\tpoll_wait(file, &tomoyo_query_wait, wait);\n\tif (!list_empty(&tomoyo_query_list))\n\t\treturn POLLIN | POLLRDNORM;\n\treturn 0;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_query_wait);",
      "static LIST_HEAD(tomoyo_query_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tomoyo_query_list"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&tomoyo_query_wait",
            "wait"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tomoyo_query_list"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_query_wait);\nstatic LIST_HEAD(tomoyo_query_list);\n\nstatic unsigned int tomoyo_poll_query(struct file *file, poll_table *wait)\n{\n\tif (!list_empty(&tomoyo_query_list))\n\t\treturn POLLIN | POLLRDNORM;\n\tpoll_wait(file, &tomoyo_query_wait, wait);\n\tif (!list_empty(&tomoyo_query_list))\n\t\treturn POLLIN | POLLRDNORM;\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_find_domain_by_qid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "2097-2111",
    "snippet": "static struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial)\n{\n\tstruct tomoyo_query *ptr;\n\tstruct tomoyo_domain_info *domain = NULL;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each_entry(ptr, &tomoyo_query_list, list) {\n\t\tif (ptr->serial != serial)\n\t\t\tcontinue;\n\t\tdomain = ptr->domain;\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\treturn domain;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);",
      "static LIST_HEAD(tomoyo_query_list);",
      "static DEFINE_SPINLOCK(tomoyo_query_list_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ptr",
            "&tomoyo_query_list",
            "list"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);\nstatic LIST_HEAD(tomoyo_query_list);\nstatic DEFINE_SPINLOCK(tomoyo_query_list_lock);\n\nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial)\n{\n\tstruct tomoyo_query *ptr;\n\tstruct tomoyo_domain_info *domain = NULL;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each_entry(ptr, &tomoyo_query_list, list) {\n\t\tif (ptr->serial != serial)\n\t\t\tcontinue;\n\t\tdomain = ptr->domain;\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\treturn domain;\n}"
  },
  {
    "function_name": "tomoyo_supervisor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1996-2088",
    "snippet": "int tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint error;\n\tint len;\n\tstatic unsigned int tomoyo_serial;\n\tstruct tomoyo_query entry = { };\n\tbool quota_exceeded = false;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\t/* Write /sys/kernel/security/tomoyo/audit. */\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n\t/* Nothing more to do if granted. */\n\tif (r->granted)\n\t\treturn 0;\n\tif (r->mode)\n\t\ttomoyo_update_stat(r->mode);\n\tswitch (r->mode) {\n\tcase TOMOYO_CONFIG_ENFORCING:\n\t\terror = -EPERM;\n\t\tif (atomic_read(&tomoyo_query_observers))\n\t\t\tbreak;\n\t\tgoto out;\n\tcase TOMOYO_CONFIG_LEARNING:\n\t\terror = 0;\n\t\t/* Check max_learning_entry parameter. */\n\t\tif (tomoyo_domain_quota_is_ok(r))\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* Get message. */\n\tva_start(args, fmt);\n\tentry.query = tomoyo_init_log(r, len, fmt, args);\n\tva_end(args);\n\tif (!entry.query)\n\t\tgoto out;\n\tentry.query_len = strlen(entry.query) + 1;\n\tif (!error) {\n\t\ttomoyo_add_entry(r->domain, entry.query);\n\t\tgoto out;\n\t}\n\tlen = tomoyo_round2(entry.query_len);\n\tentry.domain = r->domain;\n\tspin_lock(&tomoyo_query_list_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_QUERY] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_QUERY] + len\n\t    >= tomoyo_memory_quota[TOMOYO_MEMORY_QUERY]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\tentry.serial = tomoyo_serial++;\n\t\tentry.retry = r->retry;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] += len;\n\t\tlist_add_tail(&entry.list, &tomoyo_query_list);\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (quota_exceeded)\n\t\tgoto out;\n\t/* Give 10 seconds for supervisor's opinion. */\n\twhile (entry.timer < 10) {\n\t\twake_up_all(&tomoyo_query_wait);\n\t\tif (wait_event_interruptible_timeout\n\t\t    (tomoyo_answer_wait, entry.answer ||\n\t\t     !atomic_read(&tomoyo_query_observers), HZ))\n\t\t\tbreak;\n\t\telse\n\t\t\tentry.timer++;\n\t}\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_del(&entry.list);\n\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] -= len;\n\tspin_unlock(&tomoyo_query_list_lock);\n\tswitch (entry.answer) {\n\tcase 3: /* Asked to retry by administrator. */\n\t\terror = TOMOYO_RETRY_REQUEST;\n\t\tr->retry++;\n\t\tbreak;\n\tcase 1:\n\t\t/* Granted by administrator. */\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\t/* Timed out or rejected by administrator. */\n\t\tbreak;\n\t}\nout:\n\tkfree(entry.query);\n\treturn error;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);",
      "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_query_wait);",
      "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_answer_wait);",
      "static LIST_HEAD(tomoyo_query_list);",
      "static DEFINE_SPINLOCK(tomoyo_query_list_lock);",
      "static atomic_t tomoyo_query_observers = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry.query"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry.list"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "tomoyo_answer_wait",
            "entry.answer ||\n\t\t     !atomic_read(&tomoyo_query_observers)",
            "HZ"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tomoyo_query_observers"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&tomoyo_query_wait"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry.list",
            "&tomoyo_query_list"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_query_list_lock"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_round2",
          "args": [
            "entry.query_len"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_round2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1305-1317",
          "snippet": "static inline int tomoyo_round2(size_t size)\n{\n#if PAGE_SIZE == 4096\n\tsize_t bsize = 32;\n#else\n\tsize_t bsize = 64;\n#endif\n\tif (!size)\n\t\treturn 0;\n\twhile (size > bsize)\n\t\tbsize <<= 1;\n\treturn bsize;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline int tomoyo_round2(size_t size)\n{\n#if PAGE_SIZE == 4096\n\tsize_t bsize = 32;\n#else\n\tsize_t bsize = 64;\n#endif\n\tif (!size)\n\t\treturn 0;\n\twhile (size > bsize)\n\t\tbsize <<= 1;\n\treturn bsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_add_entry",
          "args": [
            "r->domain",
            "entry.query"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1937-1983",
          "snippet": "static void tomoyo_add_entry(struct tomoyo_domain_info *domain, char *header)\n{\n\tchar *buffer;\n\tchar *realpath = NULL;\n\tchar *argv0 = NULL;\n\tchar *symlink = NULL;\n\tchar *cp = strchr(header, '\\n');\n\tint len;\n\tif (!cp)\n\t\treturn;\n\tcp = strchr(cp + 1, '\\n');\n\tif (!cp)\n\t\treturn;\n\t*cp++ = '\\0';\n\tlen = strlen(cp) + 1;\n\t/* strstr() will return NULL if ordering is wrong. */\n\tif (*cp == 'f') {\n\t\targv0 = strstr(header, \" argv[]={ \\\"\");\n\t\tif (argv0) {\n\t\t\targv0 += 10;\n\t\t\tlen += tomoyo_truncate(argv0) + 14;\n\t\t}\n\t\trealpath = strstr(header, \" exec={ realpath=\\\"\");\n\t\tif (realpath) {\n\t\t\trealpath += 8;\n\t\t\tlen += tomoyo_truncate(realpath) + 6;\n\t\t}\n\t\tsymlink = strstr(header, \" symlink.target=\\\"\");\n\t\tif (symlink)\n\t\t\tlen += tomoyo_truncate(symlink + 1) + 1;\n\t}\n\tbuffer = kmalloc(len, GFP_NOFS);\n\tif (!buffer)\n\t\treturn;\n\tsnprintf(buffer, len - 1, \"%s\", cp);\n\tif (realpath)\n\t\ttomoyo_addprintf(buffer, len, \" exec.%s\", realpath);\n\tif (argv0)\n\t\ttomoyo_addprintf(buffer, len, \" exec.argv[0]=%s\", argv0);\n\tif (symlink)\n\t\ttomoyo_addprintf(buffer, len, \"%s\", symlink);\n\ttomoyo_normalize_line(buffer);\n\tif (!tomoyo_write_domain2(domain->ns, &domain->acl_info_list, buffer,\n\t\t\t\t  false))\n\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\tkfree(buffer);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_add_entry(struct tomoyo_domain_info *domain, char *header)\n{\n\tchar *buffer;\n\tchar *realpath = NULL;\n\tchar *argv0 = NULL;\n\tchar *symlink = NULL;\n\tchar *cp = strchr(header, '\\n');\n\tint len;\n\tif (!cp)\n\t\treturn;\n\tcp = strchr(cp + 1, '\\n');\n\tif (!cp)\n\t\treturn;\n\t*cp++ = '\\0';\n\tlen = strlen(cp) + 1;\n\t/* strstr() will return NULL if ordering is wrong. */\n\tif (*cp == 'f') {\n\t\targv0 = strstr(header, \" argv[]={ \\\"\");\n\t\tif (argv0) {\n\t\t\targv0 += 10;\n\t\t\tlen += tomoyo_truncate(argv0) + 14;\n\t\t}\n\t\trealpath = strstr(header, \" exec={ realpath=\\\"\");\n\t\tif (realpath) {\n\t\t\trealpath += 8;\n\t\t\tlen += tomoyo_truncate(realpath) + 6;\n\t\t}\n\t\tsymlink = strstr(header, \" symlink.target=\\\"\");\n\t\tif (symlink)\n\t\t\tlen += tomoyo_truncate(symlink + 1) + 1;\n\t}\n\tbuffer = kmalloc(len, GFP_NOFS);\n\tif (!buffer)\n\t\treturn;\n\tsnprintf(buffer, len - 1, \"%s\", cp);\n\tif (realpath)\n\t\ttomoyo_addprintf(buffer, len, \" exec.%s\", realpath);\n\tif (argv0)\n\t\ttomoyo_addprintf(buffer, len, \" exec.argv[0]=%s\", argv0);\n\tif (symlink)\n\t\ttomoyo_addprintf(buffer, len, \"%s\", symlink);\n\ttomoyo_normalize_line(buffer);\n\tif (!tomoyo_write_domain2(domain->ns, &domain->acl_info_list, buffer,\n\t\t\t\t  false))\n\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\tkfree(buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "entry.query"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_init_log",
          "args": [
            "r",
            "len",
            "fmt",
            "args"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_init_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
          "lines": "242-291",
          "snippet": "char *tomoyo_init_log(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t      va_list args)\n{\n\tchar *buf = NULL;\n\tchar *bprm_info = NULL;\n\tconst char *header = NULL;\n\tchar *realpath = NULL;\n\tconst char *symlink = NULL;\n\tint pos;\n\tconst char *domainname = r->domain->domainname->name;\n\theader = tomoyo_print_header(r);\n\tif (!header)\n\t\treturn NULL;\n\t/* +10 is for '\\n' etc. and '\\0'. */\n\tlen += strlen(domainname) + strlen(header) + 10;\n\tif (r->ee) {\n\t\tstruct file *file = r->ee->bprm->file;\n\t\trealpath = tomoyo_realpath_from_path(&file->f_path);\n\t\tbprm_info = tomoyo_print_bprm(r->ee->bprm, &r->ee->dump);\n\t\tif (!realpath || !bprm_info)\n\t\t\tgoto out;\n\t\t/* +80 is for \" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\" */\n\t\tlen += strlen(realpath) + 80 + strlen(bprm_info);\n\t} else if (r->obj && r->obj->symlink_target) {\n\t\tsymlink = r->obj->symlink_target->name;\n\t\t/* +18 is for \" symlink.target=\\\"%s\\\"\" */\n\t\tlen += 18 + strlen(symlink);\n\t}\n\tlen = tomoyo_round2(len);\n\tbuf = kzalloc(len, GFP_NOFS);\n\tif (!buf)\n\t\tgoto out;\n\tlen--;\n\tpos = snprintf(buf, len, \"%s\", header);\n\tif (realpath) {\n\t\tstruct linux_binprm *bprm = r->ee->bprm;\n\t\tpos += snprintf(buf + pos, len - pos,\n\t\t\t\t\" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\",\n\t\t\t\trealpath, bprm->argc, bprm->envc, bprm_info);\n\t} else if (symlink)\n\t\tpos += snprintf(buf + pos, len - pos, \" symlink.target=\\\"%s\\\"\",\n\t\t\t\tsymlink);\n\tpos += snprintf(buf + pos, len - pos, \"\\n%s\\n\", domainname);\n\tvsnprintf(buf + pos, len - pos, fmt, args);\nout:\n\tkfree(realpath);\n\tkfree(bprm_info);\n\tkfree(header);\n\treturn buf;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nchar *tomoyo_init_log(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t      va_list args)\n{\n\tchar *buf = NULL;\n\tchar *bprm_info = NULL;\n\tconst char *header = NULL;\n\tchar *realpath = NULL;\n\tconst char *symlink = NULL;\n\tint pos;\n\tconst char *domainname = r->domain->domainname->name;\n\theader = tomoyo_print_header(r);\n\tif (!header)\n\t\treturn NULL;\n\t/* +10 is for '\\n' etc. and '\\0'. */\n\tlen += strlen(domainname) + strlen(header) + 10;\n\tif (r->ee) {\n\t\tstruct file *file = r->ee->bprm->file;\n\t\trealpath = tomoyo_realpath_from_path(&file->f_path);\n\t\tbprm_info = tomoyo_print_bprm(r->ee->bprm, &r->ee->dump);\n\t\tif (!realpath || !bprm_info)\n\t\t\tgoto out;\n\t\t/* +80 is for \" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\" */\n\t\tlen += strlen(realpath) + 80 + strlen(bprm_info);\n\t} else if (r->obj && r->obj->symlink_target) {\n\t\tsymlink = r->obj->symlink_target->name;\n\t\t/* +18 is for \" symlink.target=\\\"%s\\\"\" */\n\t\tlen += 18 + strlen(symlink);\n\t}\n\tlen = tomoyo_round2(len);\n\tbuf = kzalloc(len, GFP_NOFS);\n\tif (!buf)\n\t\tgoto out;\n\tlen--;\n\tpos = snprintf(buf, len, \"%s\", header);\n\tif (realpath) {\n\t\tstruct linux_binprm *bprm = r->ee->bprm;\n\t\tpos += snprintf(buf + pos, len - pos,\n\t\t\t\t\" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\",\n\t\t\t\trealpath, bprm->argc, bprm->envc, bprm_info);\n\t} else if (symlink)\n\t\tpos += snprintf(buf + pos, len - pos, \" symlink.target=\\\"%s\\\"\",\n\t\t\t\tsymlink);\n\tpos += snprintf(buf + pos, len - pos, \"\\n%s\\n\", domainname);\n\tvsnprintf(buf + pos, len - pos, fmt, args);\nout:\n\tkfree(realpath);\n\tkfree(bprm_info);\n\tkfree(header);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_domain_quota_is_ok",
          "args": [
            "r"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_domain_quota_is_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "1008-1070",
          "snippet": "bool tomoyo_domain_quota_is_ok(struct tomoyo_request_info *r)\n{\n\tunsigned int count = 0;\n\tstruct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\n\tif (r->mode != TOMOYO_CONFIG_LEARNING)\n\t\treturn false;\n\tif (!domain)\n\t\treturn true;\n\tlist_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {\n\t\tu16 perm;\n\t\tu8 i;\n\t\tif (ptr->is_deleted)\n\t\t\tcontinue;\n\t\tswitch (ptr->type) {\n\t\tcase TOMOYO_TYPE_PATH_ACL:\n\t\t\tperm = container_of(ptr, struct tomoyo_path_acl, head)\n\t\t\t\t->perm;\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_PATH2_ACL:\n\t\t\tperm = container_of(ptr, struct tomoyo_path2_acl, head)\n\t\t\t\t->perm;\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_PATH_NUMBER_ACL:\n\t\t\tperm = container_of(ptr, struct tomoyo_path_number_acl,\n\t\t\t\t\t    head)->perm;\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_MKDEV_ACL:\n\t\t\tperm = container_of(ptr, struct tomoyo_mkdev_acl,\n\t\t\t\t\t    head)->perm;\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_INET_ACL:\n\t\t\tperm = container_of(ptr, struct tomoyo_inet_acl,\n\t\t\t\t\t    head)->perm;\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_UNIX_ACL:\n\t\t\tperm = container_of(ptr, struct tomoyo_unix_acl,\n\t\t\t\t\t    head)->perm;\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_MANUAL_TASK_ACL:\n\t\t\tperm = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tperm = 1;\n\t\t}\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tif (perm & (1 << i))\n\t\t\t\tcount++;\n\t}\n\tif (count < tomoyo_profile(domain->ns, domain->profile)->\n\t    pref[TOMOYO_PREF_MAX_LEARNING_ENTRY])\n\t\treturn true;\n\tif (!domain->flags[TOMOYO_DIF_QUOTA_WARNED]) {\n\t\tdomain->flags[TOMOYO_DIF_QUOTA_WARNED] = true;\n\t\t/* r->granted = false; */\n\t\ttomoyo_write_log(r, \"%s\", tomoyo_dif[TOMOYO_DIF_QUOTA_WARNED]);\n\t\tprintk(KERN_WARNING \"WARNING: \"\n\t\t       \"Domain '%s' has too many ACLs to hold. \"\n\t\t       \"Stopped learning mode.\\n\", domain->domainname->name);\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_domain_quota_is_ok(struct tomoyo_request_info *r)\n{\n\tunsigned int count = 0;\n\tstruct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\n\tif (r->mode != TOMOYO_CONFIG_LEARNING)\n\t\treturn false;\n\tif (!domain)\n\t\treturn true;\n\tlist_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {\n\t\tu16 perm;\n\t\tu8 i;\n\t\tif (ptr->is_deleted)\n\t\t\tcontinue;\n\t\tswitch (ptr->type) {\n\t\tcase TOMOYO_TYPE_PATH_ACL:\n\t\t\tperm = container_of(ptr, struct tomoyo_path_acl, head)\n\t\t\t\t->perm;\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_PATH2_ACL:\n\t\t\tperm = container_of(ptr, struct tomoyo_path2_acl, head)\n\t\t\t\t->perm;\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_PATH_NUMBER_ACL:\n\t\t\tperm = container_of(ptr, struct tomoyo_path_number_acl,\n\t\t\t\t\t    head)->perm;\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_MKDEV_ACL:\n\t\t\tperm = container_of(ptr, struct tomoyo_mkdev_acl,\n\t\t\t\t\t    head)->perm;\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_INET_ACL:\n\t\t\tperm = container_of(ptr, struct tomoyo_inet_acl,\n\t\t\t\t\t    head)->perm;\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_UNIX_ACL:\n\t\t\tperm = container_of(ptr, struct tomoyo_unix_acl,\n\t\t\t\t\t    head)->perm;\n\t\t\tbreak;\n\t\tcase TOMOYO_TYPE_MANUAL_TASK_ACL:\n\t\t\tperm = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tperm = 1;\n\t\t}\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tif (perm & (1 << i))\n\t\t\t\tcount++;\n\t}\n\tif (count < tomoyo_profile(domain->ns, domain->profile)->\n\t    pref[TOMOYO_PREF_MAX_LEARNING_ENTRY])\n\t\treturn true;\n\tif (!domain->flags[TOMOYO_DIF_QUOTA_WARNED]) {\n\t\tdomain->flags[TOMOYO_DIF_QUOTA_WARNED] = true;\n\t\t/* r->granted = false; */\n\t\ttomoyo_write_log(r, \"%s\", tomoyo_dif[TOMOYO_DIF_QUOTA_WARNED]);\n\t\tprintk(KERN_WARNING \"WARNING: \"\n\t\t       \"Domain '%s' has too many ACLs to hold. \"\n\t\t       \"Stopped learning mode.\\n\", domain->domainname->name);\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tomoyo_query_observers"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_update_stat",
          "args": [
            "r->mode"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_update_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2269-2276",
          "snippet": "void tomoyo_update_stat(const u8 index)\n{\n\t/*\n\t * I don't use atomic operations because race condition is not fatal.\n\t */\n\ttomoyo_stat_updated[index]++;\n\ttomoyo_stat_modified[index] = ktime_get_real_seconds();\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int tomoyo_stat_updated[TOMOYO_MAX_POLICY_STAT];",
            "static time64_t tomoyo_stat_modified[TOMOYO_MAX_POLICY_STAT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int tomoyo_stat_updated[TOMOYO_MAX_POLICY_STAT];\nstatic time64_t tomoyo_stat_modified[TOMOYO_MAX_POLICY_STAT];\n\nvoid tomoyo_update_stat(const u8 index)\n{\n\t/*\n\t * I don't use atomic operations because race condition is not fatal.\n\t */\n\ttomoyo_stat_updated[index]++;\n\ttomoyo_stat_modified[index] = ktime_get_real_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_write_log2",
          "args": [
            "r",
            "len",
            "fmt",
            "args"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_write_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
          "lines": "359-402",
          "snippet": "void tomoyo_write_log2(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t       va_list args)\n{\n\tchar *buf;\n\tstruct tomoyo_log *entry;\n\tbool quota_exceeded = false;\n\tif (!tomoyo_get_audit(r->domain->ns, r->profile, r->type,\n\t\t\t      r->matched_acl, r->granted))\n\t\tgoto out;\n\tbuf = tomoyo_init_log(r, len, fmt, args);\n\tif (!buf)\n\t\tgoto out;\n\tentry = kzalloc(sizeof(*entry), GFP_NOFS);\n\tif (!entry) {\n\t\tkfree(buf);\n\t\tgoto out;\n\t}\n\tentry->log = buf;\n\tlen = tomoyo_round2(strlen(buf) + 1);\n\t/*\n\t * The entry->size is used for memory quota checks.\n\t * Don't go beyond strlen(entry->log).\n\t */\n\tentry->size = len + tomoyo_round2(sizeof(*entry));\n\tspin_lock(&tomoyo_log_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_AUDIT] + entry->size >=\n\t    tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_AUDIT] += entry->size;\n\t\tlist_add_tail(&entry->list, &tomoyo_log);\n\t\ttomoyo_log_count++;\n\t}\n\tspin_unlock(&tomoyo_log_lock);\n\tif (quota_exceeded) {\n\t\tkfree(buf);\n\t\tkfree(entry);\n\t\tgoto out;\n\t}\n\twake_up(&tomoyo_log_wait);\nout:\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_log_wait);",
            "static LIST_HEAD(tomoyo_log);",
            "static DEFINE_SPINLOCK(tomoyo_log_lock);",
            "static unsigned int tomoyo_log_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_log_wait);\nstatic LIST_HEAD(tomoyo_log);\nstatic DEFINE_SPINLOCK(tomoyo_log_lock);\nstatic unsigned int tomoyo_log_count;\n\nvoid tomoyo_write_log2(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t       va_list args)\n{\n\tchar *buf;\n\tstruct tomoyo_log *entry;\n\tbool quota_exceeded = false;\n\tif (!tomoyo_get_audit(r->domain->ns, r->profile, r->type,\n\t\t\t      r->matched_acl, r->granted))\n\t\tgoto out;\n\tbuf = tomoyo_init_log(r, len, fmt, args);\n\tif (!buf)\n\t\tgoto out;\n\tentry = kzalloc(sizeof(*entry), GFP_NOFS);\n\tif (!entry) {\n\t\tkfree(buf);\n\t\tgoto out;\n\t}\n\tentry->log = buf;\n\tlen = tomoyo_round2(strlen(buf) + 1);\n\t/*\n\t * The entry->size is used for memory quota checks.\n\t * Don't go beyond strlen(entry->log).\n\t */\n\tentry->size = len + tomoyo_round2(sizeof(*entry));\n\tspin_lock(&tomoyo_log_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_AUDIT] + entry->size >=\n\t    tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_AUDIT] += entry->size;\n\t\tlist_add_tail(&entry->list, &tomoyo_log);\n\t\ttomoyo_log_count++;\n\t}\n\tspin_unlock(&tomoyo_log_lock);\n\tif (quota_exceeded) {\n\t\tkfree(buf);\n\t\tkfree(entry);\n\t\tgoto out;\n\t}\n\twake_up(&tomoyo_log_wait);\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "(char *) &len",
            "1",
            "fmt",
            "args"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_query_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_answer_wait);\nstatic LIST_HEAD(tomoyo_query_list);\nstatic DEFINE_SPINLOCK(tomoyo_query_list_lock);\nstatic atomic_t tomoyo_query_observers = ATOMIC_INIT(0);\n\nint tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint error;\n\tint len;\n\tstatic unsigned int tomoyo_serial;\n\tstruct tomoyo_query entry = { };\n\tbool quota_exceeded = false;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\t/* Write /sys/kernel/security/tomoyo/audit. */\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n\t/* Nothing more to do if granted. */\n\tif (r->granted)\n\t\treturn 0;\n\tif (r->mode)\n\t\ttomoyo_update_stat(r->mode);\n\tswitch (r->mode) {\n\tcase TOMOYO_CONFIG_ENFORCING:\n\t\terror = -EPERM;\n\t\tif (atomic_read(&tomoyo_query_observers))\n\t\t\tbreak;\n\t\tgoto out;\n\tcase TOMOYO_CONFIG_LEARNING:\n\t\terror = 0;\n\t\t/* Check max_learning_entry parameter. */\n\t\tif (tomoyo_domain_quota_is_ok(r))\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* Get message. */\n\tva_start(args, fmt);\n\tentry.query = tomoyo_init_log(r, len, fmt, args);\n\tva_end(args);\n\tif (!entry.query)\n\t\tgoto out;\n\tentry.query_len = strlen(entry.query) + 1;\n\tif (!error) {\n\t\ttomoyo_add_entry(r->domain, entry.query);\n\t\tgoto out;\n\t}\n\tlen = tomoyo_round2(entry.query_len);\n\tentry.domain = r->domain;\n\tspin_lock(&tomoyo_query_list_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_QUERY] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_QUERY] + len\n\t    >= tomoyo_memory_quota[TOMOYO_MEMORY_QUERY]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\tentry.serial = tomoyo_serial++;\n\t\tentry.retry = r->retry;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] += len;\n\t\tlist_add_tail(&entry.list, &tomoyo_query_list);\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (quota_exceeded)\n\t\tgoto out;\n\t/* Give 10 seconds for supervisor's opinion. */\n\twhile (entry.timer < 10) {\n\t\twake_up_all(&tomoyo_query_wait);\n\t\tif (wait_event_interruptible_timeout\n\t\t    (tomoyo_answer_wait, entry.answer ||\n\t\t     !atomic_read(&tomoyo_query_observers), HZ))\n\t\t\tbreak;\n\t\telse\n\t\t\tentry.timer++;\n\t}\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_del(&entry.list);\n\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] -= len;\n\tspin_unlock(&tomoyo_query_list_lock);\n\tswitch (entry.answer) {\n\tcase 3: /* Asked to retry by administrator. */\n\t\terror = TOMOYO_RETRY_REQUEST;\n\t\tr->retry++;\n\t\tbreak;\n\tcase 1:\n\t\t/* Granted by administrator. */\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\t/* Timed out or rejected by administrator. */\n\t\tbreak;\n\t}\nout:\n\tkfree(entry.query);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1937-1983",
    "snippet": "static void tomoyo_add_entry(struct tomoyo_domain_info *domain, char *header)\n{\n\tchar *buffer;\n\tchar *realpath = NULL;\n\tchar *argv0 = NULL;\n\tchar *symlink = NULL;\n\tchar *cp = strchr(header, '\\n');\n\tint len;\n\tif (!cp)\n\t\treturn;\n\tcp = strchr(cp + 1, '\\n');\n\tif (!cp)\n\t\treturn;\n\t*cp++ = '\\0';\n\tlen = strlen(cp) + 1;\n\t/* strstr() will return NULL if ordering is wrong. */\n\tif (*cp == 'f') {\n\t\targv0 = strstr(header, \" argv[]={ \\\"\");\n\t\tif (argv0) {\n\t\t\targv0 += 10;\n\t\t\tlen += tomoyo_truncate(argv0) + 14;\n\t\t}\n\t\trealpath = strstr(header, \" exec={ realpath=\\\"\");\n\t\tif (realpath) {\n\t\t\trealpath += 8;\n\t\t\tlen += tomoyo_truncate(realpath) + 6;\n\t\t}\n\t\tsymlink = strstr(header, \" symlink.target=\\\"\");\n\t\tif (symlink)\n\t\t\tlen += tomoyo_truncate(symlink + 1) + 1;\n\t}\n\tbuffer = kmalloc(len, GFP_NOFS);\n\tif (!buffer)\n\t\treturn;\n\tsnprintf(buffer, len - 1, \"%s\", cp);\n\tif (realpath)\n\t\ttomoyo_addprintf(buffer, len, \" exec.%s\", realpath);\n\tif (argv0)\n\t\ttomoyo_addprintf(buffer, len, \" exec.argv[0]=%s\", argv0);\n\tif (symlink)\n\t\ttomoyo_addprintf(buffer, len, \"%s\", symlink);\n\ttomoyo_normalize_line(buffer);\n\tif (!tomoyo_write_domain2(domain->ns, &domain->acl_info_list, buffer,\n\t\t\t\t  false))\n\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\tkfree(buffer);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_update_stat",
          "args": [
            "TOMOYO_STAT_POLICY_UPDATES"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_update_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2269-2276",
          "snippet": "void tomoyo_update_stat(const u8 index)\n{\n\t/*\n\t * I don't use atomic operations because race condition is not fatal.\n\t */\n\ttomoyo_stat_updated[index]++;\n\ttomoyo_stat_modified[index] = ktime_get_real_seconds();\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int tomoyo_stat_updated[TOMOYO_MAX_POLICY_STAT];",
            "static time64_t tomoyo_stat_modified[TOMOYO_MAX_POLICY_STAT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int tomoyo_stat_updated[TOMOYO_MAX_POLICY_STAT];\nstatic time64_t tomoyo_stat_modified[TOMOYO_MAX_POLICY_STAT];\n\nvoid tomoyo_update_stat(const u8 index)\n{\n\t/*\n\t * I don't use atomic operations because race condition is not fatal.\n\t */\n\ttomoyo_stat_updated[index]++;\n\ttomoyo_stat_modified[index] = ktime_get_real_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_write_domain2",
          "args": [
            "domain->ns",
            "&domain->acl_info_list",
            "buffer",
            "false"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_write_domain2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1101-1130",
          "snippet": "static int tomoyo_write_domain2(struct tomoyo_policy_namespace *ns,\n\t\t\t\tstruct list_head *list, char *data,\n\t\t\t\tconst bool is_delete)\n{\n\tstruct tomoyo_acl_param param = {\n\t\t.ns = ns,\n\t\t.list = list,\n\t\t.data = data,\n\t\t.is_delete = is_delete,\n\t};\n\tstatic const struct {\n\t\tconst char *keyword;\n\t\tint (*write) (struct tomoyo_acl_param *);\n\t} tomoyo_callback[5] = {\n\t\t{ \"file \", tomoyo_write_file },\n\t\t{ \"network inet \", tomoyo_write_inet_network },\n\t\t{ \"network unix \", tomoyo_write_unix_network },\n\t\t{ \"misc \", tomoyo_write_misc },\n\t\t{ \"task \", tomoyo_write_task },\n\t};\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tomoyo_callback); i++) {\n\t\tif (!tomoyo_str_starts(&param.data,\n\t\t\t\t       tomoyo_callback[i].keyword))\n\t\t\tcontinue;\n\t\treturn tomoyo_callback[i].write(&param);\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_write_domain2(struct tomoyo_policy_namespace *ns,\n\t\t\t\tstruct list_head *list, char *data,\n\t\t\t\tconst bool is_delete)\n{\n\tstruct tomoyo_acl_param param = {\n\t\t.ns = ns,\n\t\t.list = list,\n\t\t.data = data,\n\t\t.is_delete = is_delete,\n\t};\n\tstatic const struct {\n\t\tconst char *keyword;\n\t\tint (*write) (struct tomoyo_acl_param *);\n\t} tomoyo_callback[5] = {\n\t\t{ \"file \", tomoyo_write_file },\n\t\t{ \"network inet \", tomoyo_write_inet_network },\n\t\t{ \"network unix \", tomoyo_write_unix_network },\n\t\t{ \"misc \", tomoyo_write_misc },\n\t\t{ \"task \", tomoyo_write_task },\n\t};\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tomoyo_callback); i++) {\n\t\tif (!tomoyo_str_starts(&param.data,\n\t\t\t\t       tomoyo_callback[i].keyword))\n\t\t\tcontinue;\n\t\treturn tomoyo_callback[i].write(&param);\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_normalize_line",
          "args": [
            "buffer"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_normalize_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "396-414",
          "snippet": "void tomoyo_normalize_line(unsigned char *buffer)\n{\n\tunsigned char *sp = buffer;\n\tunsigned char *dp = buffer;\n\tbool first = true;\n\n\twhile (tomoyo_invalid(*sp))\n\t\tsp++;\n\twhile (*sp) {\n\t\tif (!first)\n\t\t\t*dp++ = ' ';\n\t\tfirst = false;\n\t\twhile (tomoyo_valid(*sp))\n\t\t\t*dp++ = *sp++;\n\t\twhile (tomoyo_invalid(*sp))\n\t\t\tsp++;\n\t}\n\t*dp = '\\0';\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_normalize_line(unsigned char *buffer)\n{\n\tunsigned char *sp = buffer;\n\tunsigned char *dp = buffer;\n\tbool first = true;\n\n\twhile (tomoyo_invalid(*sp))\n\t\tsp++;\n\twhile (*sp) {\n\t\tif (!first)\n\t\t\t*dp++ = ' ';\n\t\tfirst = false;\n\t\twhile (tomoyo_valid(*sp))\n\t\t\t*dp++ = *sp++;\n\t\twhile (tomoyo_invalid(*sp))\n\t\t\tsp++;\n\t}\n\t*dp = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_addprintf",
          "args": [
            "buffer",
            "len",
            "\"%s\"",
            "symlink"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_addprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "196-203",
          "snippet": "static void tomoyo_addprintf(char *buffer, int len, const char *fmt, ...)\n{\n\tva_list args;\n\tconst int pos = strlen(buffer);\n\tva_start(args, fmt);\n\tvsnprintf(buffer + pos, len - pos - 1, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_addprintf(char *buffer, int len, const char *fmt, ...)\n{\n\tva_list args;\n\tconst int pos = strlen(buffer);\n\tva_start(args, fmt);\n\tvsnprintf(buffer + pos, len - pos - 1, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "len - 1",
            "\"%s\"",
            "cp"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_NOFS"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_truncate",
          "args": [
            "symlink + 1"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1920-1927",
          "snippet": "static int tomoyo_truncate(char *str)\n{\n\tchar *start = str;\n\twhile (*(unsigned char *) str > (unsigned char) ' ')\n\t\tstr++;\n\t*str = '\\0';\n\treturn strlen(start) + 1;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_truncate(char *str)\n{\n\tchar *start = str;\n\twhile (*(unsigned char *) str > (unsigned char) ' ')\n\t\tstr++;\n\t*str = '\\0';\n\treturn strlen(start) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "header",
            "\" symlink.target=\\\"\""
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "header",
            "\" exec={ realpath=\\\"\""
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "header",
            "\" argv[]={ \\\"\""
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp + 1",
            "'\\n'"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "header",
            "'\\n'"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_add_entry(struct tomoyo_domain_info *domain, char *header)\n{\n\tchar *buffer;\n\tchar *realpath = NULL;\n\tchar *argv0 = NULL;\n\tchar *symlink = NULL;\n\tchar *cp = strchr(header, '\\n');\n\tint len;\n\tif (!cp)\n\t\treturn;\n\tcp = strchr(cp + 1, '\\n');\n\tif (!cp)\n\t\treturn;\n\t*cp++ = '\\0';\n\tlen = strlen(cp) + 1;\n\t/* strstr() will return NULL if ordering is wrong. */\n\tif (*cp == 'f') {\n\t\targv0 = strstr(header, \" argv[]={ \\\"\");\n\t\tif (argv0) {\n\t\t\targv0 += 10;\n\t\t\tlen += tomoyo_truncate(argv0) + 14;\n\t\t}\n\t\trealpath = strstr(header, \" exec={ realpath=\\\"\");\n\t\tif (realpath) {\n\t\t\trealpath += 8;\n\t\t\tlen += tomoyo_truncate(realpath) + 6;\n\t\t}\n\t\tsymlink = strstr(header, \" symlink.target=\\\"\");\n\t\tif (symlink)\n\t\t\tlen += tomoyo_truncate(symlink + 1) + 1;\n\t}\n\tbuffer = kmalloc(len, GFP_NOFS);\n\tif (!buffer)\n\t\treturn;\n\tsnprintf(buffer, len - 1, \"%s\", cp);\n\tif (realpath)\n\t\ttomoyo_addprintf(buffer, len, \" exec.%s\", realpath);\n\tif (argv0)\n\t\ttomoyo_addprintf(buffer, len, \" exec.argv[0]=%s\", argv0);\n\tif (symlink)\n\t\ttomoyo_addprintf(buffer, len, \"%s\", symlink);\n\ttomoyo_normalize_line(buffer);\n\tif (!tomoyo_write_domain2(domain->ns, &domain->acl_info_list, buffer,\n\t\t\t\t  false))\n\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\tkfree(buffer);\n}"
  },
  {
    "function_name": "tomoyo_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1920-1927",
    "snippet": "static int tomoyo_truncate(char *str)\n{\n\tchar *start = str;\n\twhile (*(unsigned char *) str > (unsigned char) ' ')\n\t\tstr++;\n\t*str = '\\0';\n\treturn strlen(start) + 1;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "start"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_truncate(char *str)\n{\n\tchar *start = str;\n\twhile (*(unsigned char *) str > (unsigned char) ' ')\n\t\tstr++;\n\t*str = '\\0';\n\treturn strlen(start) + 1;\n}"
  },
  {
    "function_name": "tomoyo_read_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1856-1882",
    "snippet": "static void tomoyo_read_exception(struct tomoyo_io_buffer *head)\n{\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tif (head->r.eof)\n\t\treturn;\n\twhile (head->r.step < TOMOYO_MAX_POLICY &&\n\t       tomoyo_read_policy(head, head->r.step))\n\t\thead->r.step++;\n\tif (head->r.step < TOMOYO_MAX_POLICY)\n\t\treturn;\n\twhile (head->r.step < TOMOYO_MAX_POLICY + TOMOYO_MAX_GROUP &&\n\t       tomoyo_read_group(head, head->r.step - TOMOYO_MAX_POLICY))\n\t\thead->r.step++;\n\tif (head->r.step < TOMOYO_MAX_POLICY + TOMOYO_MAX_GROUP)\n\t\treturn;\n\twhile (head->r.step < TOMOYO_MAX_POLICY + TOMOYO_MAX_GROUP\n\t       + TOMOYO_MAX_ACL_GROUPS) {\n\t\thead->r.acl_group_index = head->r.step - TOMOYO_MAX_POLICY\n\t\t\t- TOMOYO_MAX_GROUP;\n\t\tif (!tomoyo_read_domain2(head, &ns->acl_group\n\t\t\t\t\t [head->r.acl_group_index]))\n\t\t\treturn;\n\t\thead->r.step++;\n\t}\n\thead->r.eof = true;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_read_domain2",
          "args": [
            "head",
            "&ns->acl_group\n\t\t\t\t\t [head->r.acl_group_index]"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_domain2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1559-1570",
          "snippet": "static bool tomoyo_read_domain2(struct tomoyo_io_buffer *head,\n\t\t\t\tstruct list_head *list)\n{\n\tlist_for_each_cookie(head->r.acl, list) {\n\t\tstruct tomoyo_acl_info *ptr =\n\t\t\tlist_entry(head->r.acl, typeof(*ptr), list);\n\t\tif (!tomoyo_print_entry(head, ptr))\n\t\t\treturn false;\n\t}\n\thead->r.acl = NULL;\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_read_domain2(struct tomoyo_io_buffer *head,\n\t\t\t\tstruct list_head *list)\n{\n\tlist_for_each_cookie(head->r.acl, list) {\n\t\tstruct tomoyo_acl_info *ptr =\n\t\t\tlist_entry(head->r.acl, typeof(*ptr), list);\n\t\tif (!tomoyo_print_entry(head, ptr))\n\t\t\treturn false;\n\t}\n\thead->r.acl = NULL;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_group",
          "args": [
            "head",
            "head->r.step - TOMOYO_MAX_POLICY"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1743-1787",
          "snippet": "static bool tomoyo_read_group(struct tomoyo_io_buffer *head, const int idx)\n{\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tstruct list_head *list = &ns->group_list[idx];\n\tlist_for_each_cookie(head->r.group, list) {\n\t\tstruct tomoyo_group *group =\n\t\t\tlist_entry(head->r.group, typeof(*group), head.list);\n\t\tlist_for_each_cookie(head->r.acl, &group->member_list) {\n\t\t\tstruct tomoyo_acl_head *ptr =\n\t\t\t\tlist_entry(head->r.acl, typeof(*ptr), list);\n\t\t\tif (ptr->is_deleted)\n\t\t\t\tcontinue;\n\t\t\tif (!tomoyo_flush(head))\n\t\t\t\treturn false;\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_set_string(head, tomoyo_group_name[idx]);\n\t\t\ttomoyo_set_string(head, group->group_name->name);\n\t\t\tif (idx == TOMOYO_PATH_GROUP) {\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\ttomoyo_set_string(head, container_of\n\t\t\t\t\t       (ptr, struct tomoyo_path_group,\n\t\t\t\t\t\thead)->member_name->name);\n\t\t\t} else if (idx == TOMOYO_NUMBER_GROUP) {\n\t\t\t\ttomoyo_print_number_union(head, &container_of\n\t\t\t\t\t\t\t  (ptr,\n\t\t\t\t\t\t   struct tomoyo_number_group,\n\t\t\t\t\t\t\t   head)->number);\n\t\t\t} else if (idx == TOMOYO_ADDRESS_GROUP) {\n\t\t\t\tchar buffer[128];\n\n\t\t\t\tstruct tomoyo_address_group *member =\n\t\t\t\t\tcontainer_of(ptr, typeof(*member),\n\t\t\t\t\t\t     head);\n\t\t\t\ttomoyo_print_ip(buffer, sizeof(buffer),\n\t\t\t\t\t\t&member->address);\n\t\t\t\ttomoyo_io_printf(head, \" %s\", buffer);\n\t\t\t}\n\t\t\ttomoyo_set_lf(head);\n\t\t}\n\t\thead->r.acl = NULL;\n\t}\n\thead->r.group = NULL;\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *tomoyo_group_name[TOMOYO_MAX_GROUP] = {\n\t[TOMOYO_PATH_GROUP]    = \"path_group \",\n\t[TOMOYO_NUMBER_GROUP]  = \"number_group \",\n\t[TOMOYO_ADDRESS_GROUP] = \"address_group \",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic const char *tomoyo_group_name[TOMOYO_MAX_GROUP] = {\n\t[TOMOYO_PATH_GROUP]    = \"path_group \",\n\t[TOMOYO_NUMBER_GROUP]  = \"number_group \",\n\t[TOMOYO_ADDRESS_GROUP] = \"address_group \",\n};\n\nstatic bool tomoyo_read_group(struct tomoyo_io_buffer *head, const int idx)\n{\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tstruct list_head *list = &ns->group_list[idx];\n\tlist_for_each_cookie(head->r.group, list) {\n\t\tstruct tomoyo_group *group =\n\t\t\tlist_entry(head->r.group, typeof(*group), head.list);\n\t\tlist_for_each_cookie(head->r.acl, &group->member_list) {\n\t\t\tstruct tomoyo_acl_head *ptr =\n\t\t\t\tlist_entry(head->r.acl, typeof(*ptr), list);\n\t\t\tif (ptr->is_deleted)\n\t\t\t\tcontinue;\n\t\t\tif (!tomoyo_flush(head))\n\t\t\t\treturn false;\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_set_string(head, tomoyo_group_name[idx]);\n\t\t\ttomoyo_set_string(head, group->group_name->name);\n\t\t\tif (idx == TOMOYO_PATH_GROUP) {\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\ttomoyo_set_string(head, container_of\n\t\t\t\t\t       (ptr, struct tomoyo_path_group,\n\t\t\t\t\t\thead)->member_name->name);\n\t\t\t} else if (idx == TOMOYO_NUMBER_GROUP) {\n\t\t\t\ttomoyo_print_number_union(head, &container_of\n\t\t\t\t\t\t\t  (ptr,\n\t\t\t\t\t\t   struct tomoyo_number_group,\n\t\t\t\t\t\t\t   head)->number);\n\t\t\t} else if (idx == TOMOYO_ADDRESS_GROUP) {\n\t\t\t\tchar buffer[128];\n\n\t\t\t\tstruct tomoyo_address_group *member =\n\t\t\t\t\tcontainer_of(ptr, typeof(*member),\n\t\t\t\t\t\t     head);\n\t\t\t\ttomoyo_print_ip(buffer, sizeof(buffer),\n\t\t\t\t\t\t&member->address);\n\t\t\t\ttomoyo_io_printf(head, \" %s\", buffer);\n\t\t\t}\n\t\t\ttomoyo_set_lf(head);\n\t\t}\n\t\thead->r.acl = NULL;\n\t}\n\thead->r.group = NULL;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_policy",
          "args": [
            "head",
            "head->r.step"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1799-1847",
          "snippet": "static bool tomoyo_read_policy(struct tomoyo_io_buffer *head, const int idx)\n{\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tstruct list_head *list = &ns->policy_list[idx];\n\tlist_for_each_cookie(head->r.acl, list) {\n\t\tstruct tomoyo_acl_head *acl =\n\t\t\tcontainer_of(head->r.acl, typeof(*acl), list);\n\t\tif (acl->is_deleted)\n\t\t\tcontinue;\n\t\tif (!tomoyo_flush(head))\n\t\t\treturn false;\n\t\tswitch (idx) {\n\t\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\t\t{\n\t\t\t\tstruct tomoyo_transition_control *ptr =\n\t\t\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\t\t\ttomoyo_print_namespace(head);\n\t\t\t\ttomoyo_set_string(head, tomoyo_transition_type\n\t\t\t\t\t\t  [ptr->type]);\n\t\t\t\ttomoyo_set_string(head, ptr->program ?\n\t\t\t\t\t\t  ptr->program->name : \"any\");\n\t\t\t\ttomoyo_set_string(head, \" from \");\n\t\t\t\ttomoyo_set_string(head, ptr->domainname ?\n\t\t\t\t\t\t  ptr->domainname->name :\n\t\t\t\t\t\t  \"any\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TOMOYO_ID_AGGREGATOR:\n\t\t\t{\n\t\t\t\tstruct tomoyo_aggregator *ptr =\n\t\t\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\t\t\ttomoyo_print_namespace(head);\n\t\t\t\ttomoyo_set_string(head, \"aggregator \");\n\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t  ptr->original_name->name);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t       ptr->aggregated_name->name);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\ttomoyo_set_lf(head);\n\t}\n\thead->r.acl = NULL;\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *tomoyo_transition_type[TOMOYO_MAX_TRANSITION_TYPE] = {\n\t[TOMOYO_TRANSITION_CONTROL_NO_RESET]      = \"no_reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_RESET]         = \"reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE] = \"no_initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_INITIALIZE]    = \"initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_KEEP]       = \"no_keep_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_KEEP]          = \"keep_domain \",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic const char *tomoyo_transition_type[TOMOYO_MAX_TRANSITION_TYPE] = {\n\t[TOMOYO_TRANSITION_CONTROL_NO_RESET]      = \"no_reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_RESET]         = \"reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE] = \"no_initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_INITIALIZE]    = \"initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_KEEP]       = \"no_keep_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_KEEP]          = \"keep_domain \",\n};\n\nstatic bool tomoyo_read_policy(struct tomoyo_io_buffer *head, const int idx)\n{\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tstruct list_head *list = &ns->policy_list[idx];\n\tlist_for_each_cookie(head->r.acl, list) {\n\t\tstruct tomoyo_acl_head *acl =\n\t\t\tcontainer_of(head->r.acl, typeof(*acl), list);\n\t\tif (acl->is_deleted)\n\t\t\tcontinue;\n\t\tif (!tomoyo_flush(head))\n\t\t\treturn false;\n\t\tswitch (idx) {\n\t\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\t\t{\n\t\t\t\tstruct tomoyo_transition_control *ptr =\n\t\t\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\t\t\ttomoyo_print_namespace(head);\n\t\t\t\ttomoyo_set_string(head, tomoyo_transition_type\n\t\t\t\t\t\t  [ptr->type]);\n\t\t\t\ttomoyo_set_string(head, ptr->program ?\n\t\t\t\t\t\t  ptr->program->name : \"any\");\n\t\t\t\ttomoyo_set_string(head, \" from \");\n\t\t\t\ttomoyo_set_string(head, ptr->domainname ?\n\t\t\t\t\t\t  ptr->domainname->name :\n\t\t\t\t\t\t  \"any\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TOMOYO_ID_AGGREGATOR:\n\t\t\t{\n\t\t\t\tstruct tomoyo_aggregator *ptr =\n\t\t\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\t\t\ttomoyo_print_namespace(head);\n\t\t\t\ttomoyo_set_string(head, \"aggregator \");\n\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t  ptr->original_name->name);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t       ptr->aggregated_name->name);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\ttomoyo_set_lf(head);\n\t}\n\thead->r.acl = NULL;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head->r.ns",
            "typeof(*ns)",
            "namespace_list"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ns"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_read_exception(struct tomoyo_io_buffer *head)\n{\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tif (head->r.eof)\n\t\treturn;\n\twhile (head->r.step < TOMOYO_MAX_POLICY &&\n\t       tomoyo_read_policy(head, head->r.step))\n\t\thead->r.step++;\n\tif (head->r.step < TOMOYO_MAX_POLICY)\n\t\treturn;\n\twhile (head->r.step < TOMOYO_MAX_POLICY + TOMOYO_MAX_GROUP &&\n\t       tomoyo_read_group(head, head->r.step - TOMOYO_MAX_POLICY))\n\t\thead->r.step++;\n\tif (head->r.step < TOMOYO_MAX_POLICY + TOMOYO_MAX_GROUP)\n\t\treturn;\n\twhile (head->r.step < TOMOYO_MAX_POLICY + TOMOYO_MAX_GROUP\n\t       + TOMOYO_MAX_ACL_GROUPS) {\n\t\thead->r.acl_group_index = head->r.step - TOMOYO_MAX_POLICY\n\t\t\t- TOMOYO_MAX_GROUP;\n\t\tif (!tomoyo_read_domain2(head, &ns->acl_group\n\t\t\t\t\t [head->r.acl_group_index]))\n\t\t\treturn;\n\t\thead->r.step++;\n\t}\n\thead->r.eof = true;\n}"
  },
  {
    "function_name": "tomoyo_read_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1799-1847",
    "snippet": "static bool tomoyo_read_policy(struct tomoyo_io_buffer *head, const int idx)\n{\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tstruct list_head *list = &ns->policy_list[idx];\n\tlist_for_each_cookie(head->r.acl, list) {\n\t\tstruct tomoyo_acl_head *acl =\n\t\t\tcontainer_of(head->r.acl, typeof(*acl), list);\n\t\tif (acl->is_deleted)\n\t\t\tcontinue;\n\t\tif (!tomoyo_flush(head))\n\t\t\treturn false;\n\t\tswitch (idx) {\n\t\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\t\t{\n\t\t\t\tstruct tomoyo_transition_control *ptr =\n\t\t\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\t\t\ttomoyo_print_namespace(head);\n\t\t\t\ttomoyo_set_string(head, tomoyo_transition_type\n\t\t\t\t\t\t  [ptr->type]);\n\t\t\t\ttomoyo_set_string(head, ptr->program ?\n\t\t\t\t\t\t  ptr->program->name : \"any\");\n\t\t\t\ttomoyo_set_string(head, \" from \");\n\t\t\t\ttomoyo_set_string(head, ptr->domainname ?\n\t\t\t\t\t\t  ptr->domainname->name :\n\t\t\t\t\t\t  \"any\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TOMOYO_ID_AGGREGATOR:\n\t\t\t{\n\t\t\t\tstruct tomoyo_aggregator *ptr =\n\t\t\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\t\t\ttomoyo_print_namespace(head);\n\t\t\t\ttomoyo_set_string(head, \"aggregator \");\n\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t  ptr->original_name->name);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t       ptr->aggregated_name->name);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\ttomoyo_set_lf(head);\n\t}\n\thead->r.acl = NULL;\n\treturn true;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *tomoyo_transition_type[TOMOYO_MAX_TRANSITION_TYPE] = {\n\t[TOMOYO_TRANSITION_CONTROL_NO_RESET]      = \"no_reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_RESET]         = \"reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE] = \"no_initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_INITIALIZE]    = \"initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_KEEP]       = \"no_keep_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_KEEP]          = \"keep_domain \",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_lf",
          "args": [
            "head"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_lf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "314-318",
          "snippet": "static bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "ptr->aggregated_name->name"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_space",
          "args": [
            "head"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "302-305",
          "snippet": "static void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_print_namespace",
          "args": [
            "head"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "365-374",
          "snippet": "static void tomoyo_print_namespace(struct tomoyo_io_buffer *head)\n{\n\tif (!tomoyo_namespace_enabled)\n\t\treturn;\n\ttomoyo_set_string(head,\n\t\t\t  container_of(head->r.ns,\n\t\t\t\t       struct tomoyo_policy_namespace,\n\t\t\t\t       namespace_list)->name);\n\ttomoyo_set_space(head);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool tomoyo_namespace_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_namespace_enabled;\n\nstatic void tomoyo_print_namespace(struct tomoyo_io_buffer *head)\n{\n\tif (!tomoyo_namespace_enabled)\n\t\treturn;\n\ttomoyo_set_string(head,\n\t\t\t  container_of(head->r.ns,\n\t\t\t\t       struct tomoyo_policy_namespace,\n\t\t\t\t       namespace_list)->name);\n\ttomoyo_set_space(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*ptr)",
            "head"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*ptr)",
            "head"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_flush",
          "args": [
            "head"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "212-245",
          "snippet": "static bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head->r.acl",
            "typeof(*acl)",
            "list"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*acl"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_cookie",
          "args": [
            "head->r.acl",
            "list"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head->r.ns",
            "typeof(*ns)",
            "namespace_list"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ns"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic const char *tomoyo_transition_type[TOMOYO_MAX_TRANSITION_TYPE] = {\n\t[TOMOYO_TRANSITION_CONTROL_NO_RESET]      = \"no_reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_RESET]         = \"reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE] = \"no_initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_INITIALIZE]    = \"initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_KEEP]       = \"no_keep_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_KEEP]          = \"keep_domain \",\n};\n\nstatic bool tomoyo_read_policy(struct tomoyo_io_buffer *head, const int idx)\n{\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tstruct list_head *list = &ns->policy_list[idx];\n\tlist_for_each_cookie(head->r.acl, list) {\n\t\tstruct tomoyo_acl_head *acl =\n\t\t\tcontainer_of(head->r.acl, typeof(*acl), list);\n\t\tif (acl->is_deleted)\n\t\t\tcontinue;\n\t\tif (!tomoyo_flush(head))\n\t\t\treturn false;\n\t\tswitch (idx) {\n\t\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\t\t{\n\t\t\t\tstruct tomoyo_transition_control *ptr =\n\t\t\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\t\t\ttomoyo_print_namespace(head);\n\t\t\t\ttomoyo_set_string(head, tomoyo_transition_type\n\t\t\t\t\t\t  [ptr->type]);\n\t\t\t\ttomoyo_set_string(head, ptr->program ?\n\t\t\t\t\t\t  ptr->program->name : \"any\");\n\t\t\t\ttomoyo_set_string(head, \" from \");\n\t\t\t\ttomoyo_set_string(head, ptr->domainname ?\n\t\t\t\t\t\t  ptr->domainname->name :\n\t\t\t\t\t\t  \"any\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TOMOYO_ID_AGGREGATOR:\n\t\t\t{\n\t\t\t\tstruct tomoyo_aggregator *ptr =\n\t\t\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\t\t\ttomoyo_print_namespace(head);\n\t\t\t\ttomoyo_set_string(head, \"aggregator \");\n\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t  ptr->original_name->name);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t       ptr->aggregated_name->name);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\ttomoyo_set_lf(head);\n\t}\n\thead->r.acl = NULL;\n\treturn true;\n}"
  },
  {
    "function_name": "tomoyo_read_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1743-1787",
    "snippet": "static bool tomoyo_read_group(struct tomoyo_io_buffer *head, const int idx)\n{\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tstruct list_head *list = &ns->group_list[idx];\n\tlist_for_each_cookie(head->r.group, list) {\n\t\tstruct tomoyo_group *group =\n\t\t\tlist_entry(head->r.group, typeof(*group), head.list);\n\t\tlist_for_each_cookie(head->r.acl, &group->member_list) {\n\t\t\tstruct tomoyo_acl_head *ptr =\n\t\t\t\tlist_entry(head->r.acl, typeof(*ptr), list);\n\t\t\tif (ptr->is_deleted)\n\t\t\t\tcontinue;\n\t\t\tif (!tomoyo_flush(head))\n\t\t\t\treturn false;\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_set_string(head, tomoyo_group_name[idx]);\n\t\t\ttomoyo_set_string(head, group->group_name->name);\n\t\t\tif (idx == TOMOYO_PATH_GROUP) {\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\ttomoyo_set_string(head, container_of\n\t\t\t\t\t       (ptr, struct tomoyo_path_group,\n\t\t\t\t\t\thead)->member_name->name);\n\t\t\t} else if (idx == TOMOYO_NUMBER_GROUP) {\n\t\t\t\ttomoyo_print_number_union(head, &container_of\n\t\t\t\t\t\t\t  (ptr,\n\t\t\t\t\t\t   struct tomoyo_number_group,\n\t\t\t\t\t\t\t   head)->number);\n\t\t\t} else if (idx == TOMOYO_ADDRESS_GROUP) {\n\t\t\t\tchar buffer[128];\n\n\t\t\t\tstruct tomoyo_address_group *member =\n\t\t\t\t\tcontainer_of(ptr, typeof(*member),\n\t\t\t\t\t\t     head);\n\t\t\t\ttomoyo_print_ip(buffer, sizeof(buffer),\n\t\t\t\t\t\t&member->address);\n\t\t\t\ttomoyo_io_printf(head, \" %s\", buffer);\n\t\t\t}\n\t\t\ttomoyo_set_lf(head);\n\t\t}\n\t\thead->r.acl = NULL;\n\t}\n\thead->r.group = NULL;\n\treturn true;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *tomoyo_group_name[TOMOYO_MAX_GROUP] = {\n\t[TOMOYO_PATH_GROUP]    = \"path_group \",\n\t[TOMOYO_NUMBER_GROUP]  = \"number_group \",\n\t[TOMOYO_ADDRESS_GROUP] = \"address_group \",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_lf",
          "args": [
            "head"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_lf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "314-318",
          "snippet": "static bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_io_printf",
          "args": [
            "head",
            "\" %s\"",
            "buffer"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_io_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "275-293",
          "snippet": "static void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_print_ip",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "&member->address"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "124-132",
          "snippet": "void tomoyo_print_ip(char *buf, const unsigned int size,\n\t\t     const struct tomoyo_ipaddr_union *ptr)\n{\n\tif (ptr->is_ipv6)\n\t\ttomoyo_print_ipv6(buf, size, &ptr->ip[0], &ptr->ip[1]);\n\telse\n\t\ttomoyo_print_ipv4(buf, size, &ptr->ip[0].s6_addr32[0],\n\t\t\t\t  &ptr->ip[1].s6_addr32[0]);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_print_ip(char *buf, const unsigned int size,\n\t\t     const struct tomoyo_ipaddr_union *ptr)\n{\n\tif (ptr->is_ipv6)\n\t\ttomoyo_print_ipv6(buf, size, &ptr->ip[0], &ptr->ip[1]);\n\telse\n\t\ttomoyo_print_ipv4(buf, size, &ptr->ip[0].s6_addr32[0],\n\t\t\t\t  &ptr->ip[1].s6_addr32[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ptr",
            "typeof(*member)",
            "head"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*member"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_print_number_union",
          "args": [
            "head",
            "&container_of\n\t\t\t\t\t\t\t  (ptr,\n\t\t\t\t\t\t   struct tomoyo_number_group,\n\t\t\t\t\t\t\t   head)->number"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_number_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "470-475",
          "snippet": "static void tomoyo_print_number_union(struct tomoyo_io_buffer *head,\n\t\t\t\t      const struct tomoyo_number_union *ptr)\n{\n\ttomoyo_set_space(head);\n\ttomoyo_print_number_union_nospace(head, ptr);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_print_number_union(struct tomoyo_io_buffer *head,\n\t\t\t\t      const struct tomoyo_number_union *ptr)\n{\n\ttomoyo_set_space(head);\n\ttomoyo_print_number_union_nospace(head, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ptr",
            "structtomoyo_number_group",
            "head"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "container_of\n\t\t\t\t\t       (ptr, struct tomoyo_path_group,\n\t\t\t\t\t\thead)->member_name->name"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ptr",
            "structtomoyo_path_group",
            "head"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_set_space",
          "args": [
            "head"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "302-305",
          "snippet": "static void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_print_namespace",
          "args": [
            "head"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "365-374",
          "snippet": "static void tomoyo_print_namespace(struct tomoyo_io_buffer *head)\n{\n\tif (!tomoyo_namespace_enabled)\n\t\treturn;\n\ttomoyo_set_string(head,\n\t\t\t  container_of(head->r.ns,\n\t\t\t\t       struct tomoyo_policy_namespace,\n\t\t\t\t       namespace_list)->name);\n\ttomoyo_set_space(head);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool tomoyo_namespace_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_namespace_enabled;\n\nstatic void tomoyo_print_namespace(struct tomoyo_io_buffer *head)\n{\n\tif (!tomoyo_namespace_enabled)\n\t\treturn;\n\ttomoyo_set_string(head,\n\t\t\t  container_of(head->r.ns,\n\t\t\t\t       struct tomoyo_policy_namespace,\n\t\t\t\t       namespace_list)->name);\n\ttomoyo_set_space(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_flush",
          "args": [
            "head"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "212-245",
          "snippet": "static bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->r.acl",
            "typeof(*ptr)",
            "list"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_cookie",
          "args": [
            "head->r.acl",
            "&group->member_list"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->r.group",
            "typeof(*group)",
            "head.list"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*group"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_cookie",
          "args": [
            "head->r.group",
            "list"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head->r.ns",
            "typeof(*ns)",
            "namespace_list"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ns"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic const char *tomoyo_group_name[TOMOYO_MAX_GROUP] = {\n\t[TOMOYO_PATH_GROUP]    = \"path_group \",\n\t[TOMOYO_NUMBER_GROUP]  = \"number_group \",\n\t[TOMOYO_ADDRESS_GROUP] = \"address_group \",\n};\n\nstatic bool tomoyo_read_group(struct tomoyo_io_buffer *head, const int idx)\n{\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tstruct list_head *list = &ns->group_list[idx];\n\tlist_for_each_cookie(head->r.group, list) {\n\t\tstruct tomoyo_group *group =\n\t\t\tlist_entry(head->r.group, typeof(*group), head.list);\n\t\tlist_for_each_cookie(head->r.acl, &group->member_list) {\n\t\t\tstruct tomoyo_acl_head *ptr =\n\t\t\t\tlist_entry(head->r.acl, typeof(*ptr), list);\n\t\t\tif (ptr->is_deleted)\n\t\t\t\tcontinue;\n\t\t\tif (!tomoyo_flush(head))\n\t\t\t\treturn false;\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_set_string(head, tomoyo_group_name[idx]);\n\t\t\ttomoyo_set_string(head, group->group_name->name);\n\t\t\tif (idx == TOMOYO_PATH_GROUP) {\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\ttomoyo_set_string(head, container_of\n\t\t\t\t\t       (ptr, struct tomoyo_path_group,\n\t\t\t\t\t\thead)->member_name->name);\n\t\t\t} else if (idx == TOMOYO_NUMBER_GROUP) {\n\t\t\t\ttomoyo_print_number_union(head, &container_of\n\t\t\t\t\t\t\t  (ptr,\n\t\t\t\t\t\t   struct tomoyo_number_group,\n\t\t\t\t\t\t\t   head)->number);\n\t\t\t} else if (idx == TOMOYO_ADDRESS_GROUP) {\n\t\t\t\tchar buffer[128];\n\n\t\t\t\tstruct tomoyo_address_group *member =\n\t\t\t\t\tcontainer_of(ptr, typeof(*member),\n\t\t\t\t\t\t     head);\n\t\t\t\ttomoyo_print_ip(buffer, sizeof(buffer),\n\t\t\t\t\t\t&member->address);\n\t\t\t\ttomoyo_io_printf(head, \" %s\", buffer);\n\t\t\t}\n\t\t\ttomoyo_set_lf(head);\n\t\t}\n\t\thead->r.acl = NULL;\n\t}\n\thead->r.group = NULL;\n\treturn true;\n}"
  },
  {
    "function_name": "tomoyo_write_exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1704-1731",
    "snippet": "static int tomoyo_write_exception(struct tomoyo_io_buffer *head)\n{\n\tconst bool is_delete = head->w.is_delete;\n\tstruct tomoyo_acl_param param = {\n\t\t.ns = head->w.ns,\n\t\t.is_delete = is_delete,\n\t\t.data = head->write_buf,\n\t};\n\tu8 i;\n\tif (tomoyo_str_starts(&param.data, \"aggregator \"))\n\t\treturn tomoyo_write_aggregator(&param);\n\tfor (i = 0; i < TOMOYO_MAX_TRANSITION_TYPE; i++)\n\t\tif (tomoyo_str_starts(&param.data, tomoyo_transition_type[i]))\n\t\t\treturn tomoyo_write_transition_control(&param, i);\n\tfor (i = 0; i < TOMOYO_MAX_GROUP; i++)\n\t\tif (tomoyo_str_starts(&param.data, tomoyo_group_name[i]))\n\t\t\treturn tomoyo_write_group(&param, i);\n\tif (tomoyo_str_starts(&param.data, \"acl_group \")) {\n\t\tunsigned int group;\n\t\tchar *data;\n\t\tgroup = simple_strtoul(param.data, &data, 10);\n\t\tif (group < TOMOYO_MAX_ACL_GROUPS && *data++ == ' ')\n\t\t\treturn tomoyo_write_domain2\n\t\t\t\t(head->w.ns, &head->w.ns->acl_group[group],\n\t\t\t\t data, is_delete);\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *tomoyo_transition_type[TOMOYO_MAX_TRANSITION_TYPE] = {\n\t[TOMOYO_TRANSITION_CONTROL_NO_RESET]      = \"no_reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_RESET]         = \"reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE] = \"no_initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_INITIALIZE]    = \"initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_KEEP]       = \"no_keep_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_KEEP]          = \"keep_domain \",\n};",
      "static const char *tomoyo_group_name[TOMOYO_MAX_GROUP] = {\n\t[TOMOYO_PATH_GROUP]    = \"path_group \",\n\t[TOMOYO_NUMBER_GROUP]  = \"number_group \",\n\t[TOMOYO_ADDRESS_GROUP] = \"address_group \",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_write_domain2",
          "args": [
            "head->w.ns",
            "&head->w.ns->acl_group[group]",
            "data",
            "is_delete"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_write_domain2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1101-1130",
          "snippet": "static int tomoyo_write_domain2(struct tomoyo_policy_namespace *ns,\n\t\t\t\tstruct list_head *list, char *data,\n\t\t\t\tconst bool is_delete)\n{\n\tstruct tomoyo_acl_param param = {\n\t\t.ns = ns,\n\t\t.list = list,\n\t\t.data = data,\n\t\t.is_delete = is_delete,\n\t};\n\tstatic const struct {\n\t\tconst char *keyword;\n\t\tint (*write) (struct tomoyo_acl_param *);\n\t} tomoyo_callback[5] = {\n\t\t{ \"file \", tomoyo_write_file },\n\t\t{ \"network inet \", tomoyo_write_inet_network },\n\t\t{ \"network unix \", tomoyo_write_unix_network },\n\t\t{ \"misc \", tomoyo_write_misc },\n\t\t{ \"task \", tomoyo_write_task },\n\t};\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tomoyo_callback); i++) {\n\t\tif (!tomoyo_str_starts(&param.data,\n\t\t\t\t       tomoyo_callback[i].keyword))\n\t\t\tcontinue;\n\t\treturn tomoyo_callback[i].write(&param);\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_write_domain2(struct tomoyo_policy_namespace *ns,\n\t\t\t\tstruct list_head *list, char *data,\n\t\t\t\tconst bool is_delete)\n{\n\tstruct tomoyo_acl_param param = {\n\t\t.ns = ns,\n\t\t.list = list,\n\t\t.data = data,\n\t\t.is_delete = is_delete,\n\t};\n\tstatic const struct {\n\t\tconst char *keyword;\n\t\tint (*write) (struct tomoyo_acl_param *);\n\t} tomoyo_callback[5] = {\n\t\t{ \"file \", tomoyo_write_file },\n\t\t{ \"network inet \", tomoyo_write_inet_network },\n\t\t{ \"network unix \", tomoyo_write_unix_network },\n\t\t{ \"misc \", tomoyo_write_misc },\n\t\t{ \"task \", tomoyo_write_task },\n\t};\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tomoyo_callback); i++) {\n\t\tif (!tomoyo_str_starts(&param.data,\n\t\t\t\t       tomoyo_callback[i].keyword))\n\t\t\tcontinue;\n\t\treturn tomoyo_callback[i].write(&param);\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "param.data",
            "&data",
            "10"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_str_starts",
          "args": [
            "&param.data",
            "\"acl_group \""
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_str_starts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "374-384",
          "snippet": "bool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_write_group",
          "args": [
            "&param",
            "i"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_write_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/group.c",
          "lines": "74-114",
          "snippet": "int tomoyo_write_group(struct tomoyo_acl_param *param, const u8 type)\n{\n\tstruct tomoyo_group *group = tomoyo_get_group(param, type);\n\tint error = -EINVAL;\n\tif (!group)\n\t\treturn -ENOMEM;\n\tparam->list = &group->member_list;\n\tif (type == TOMOYO_PATH_GROUP) {\n\t\tstruct tomoyo_path_group e = { };\n\t\te.member_name = tomoyo_get_name(tomoyo_read_token(param));\n\t\tif (!e.member_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t  tomoyo_same_path_group);\n\t\ttomoyo_put_name(e.member_name);\n\t} else if (type == TOMOYO_NUMBER_GROUP) {\n\t\tstruct tomoyo_number_group e = { };\n\t\tif (param->data[0] == '@' ||\n\t\t    !tomoyo_parse_number_union(param, &e.number))\n\t\t\tgoto out;\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t  tomoyo_same_number_group);\n\t\t/*\n\t\t * tomoyo_put_number_union() is not needed because\n\t\t * param->data[0] != '@'.\n\t\t */\n\t} else {\n\t\tstruct tomoyo_address_group e = { };\n\n\t\tif (param->data[0] == '@' ||\n\t\t    !tomoyo_parse_ipaddr_union(param, &e.address))\n\t\t\tgoto out;\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t     tomoyo_same_address_group);\n\t}\nout:\n\ttomoyo_put_group(group);\n\treturn error;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nint tomoyo_write_group(struct tomoyo_acl_param *param, const u8 type)\n{\n\tstruct tomoyo_group *group = tomoyo_get_group(param, type);\n\tint error = -EINVAL;\n\tif (!group)\n\t\treturn -ENOMEM;\n\tparam->list = &group->member_list;\n\tif (type == TOMOYO_PATH_GROUP) {\n\t\tstruct tomoyo_path_group e = { };\n\t\te.member_name = tomoyo_get_name(tomoyo_read_token(param));\n\t\tif (!e.member_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t  tomoyo_same_path_group);\n\t\ttomoyo_put_name(e.member_name);\n\t} else if (type == TOMOYO_NUMBER_GROUP) {\n\t\tstruct tomoyo_number_group e = { };\n\t\tif (param->data[0] == '@' ||\n\t\t    !tomoyo_parse_number_union(param, &e.number))\n\t\t\tgoto out;\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t  tomoyo_same_number_group);\n\t\t/*\n\t\t * tomoyo_put_number_union() is not needed because\n\t\t * param->data[0] != '@'.\n\t\t */\n\t} else {\n\t\tstruct tomoyo_address_group e = { };\n\n\t\tif (param->data[0] == '@' ||\n\t\t    !tomoyo_parse_ipaddr_union(param, &e.address))\n\t\t\tgoto out;\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t\t     tomoyo_same_address_group);\n\t}\nout:\n\ttomoyo_put_group(group);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_write_transition_control",
          "args": [
            "&param",
            "i"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_write_transition_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "236-275",
          "snippet": "int tomoyo_write_transition_control(struct tomoyo_acl_param *param,\n\t\t\t\t    const u8 type)\n{\n\tstruct tomoyo_transition_control e = { .type = type };\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tchar *program = param->data;\n\tchar *domainname = strstr(program, \" from \");\n\tif (domainname) {\n\t\t*domainname = '\\0';\n\t\tdomainname += 6;\n\t} else if (type == TOMOYO_TRANSITION_CONTROL_NO_KEEP ||\n\t\t   type == TOMOYO_TRANSITION_CONTROL_KEEP) {\n\t\tdomainname = program;\n\t\tprogram = NULL;\n\t}\n\tif (program && strcmp(program, \"any\")) {\n\t\tif (!tomoyo_correct_path(program))\n\t\t\treturn -EINVAL;\n\t\te.program = tomoyo_get_name(program);\n\t\tif (!e.program)\n\t\t\tgoto out;\n\t}\n\tif (domainname && strcmp(domainname, \"any\")) {\n\t\tif (!tomoyo_correct_domain(domainname)) {\n\t\t\tif (!tomoyo_correct_path(domainname))\n\t\t\t\tgoto out;\n\t\t\te.is_last_name = true;\n\t\t}\n\t\te.domainname = tomoyo_get_name(domainname);\n\t\tif (!e.domainname)\n\t\t\tgoto out;\n\t}\n\tparam->list = &param->ns->policy_list[TOMOYO_ID_TRANSITION_CONTROL];\n\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_transition_control);\nout:\n\ttomoyo_put_name(e.domainname);\n\ttomoyo_put_name(e.program);\n\treturn error;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_write_transition_control(struct tomoyo_acl_param *param,\n\t\t\t\t    const u8 type)\n{\n\tstruct tomoyo_transition_control e = { .type = type };\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tchar *program = param->data;\n\tchar *domainname = strstr(program, \" from \");\n\tif (domainname) {\n\t\t*domainname = '\\0';\n\t\tdomainname += 6;\n\t} else if (type == TOMOYO_TRANSITION_CONTROL_NO_KEEP ||\n\t\t   type == TOMOYO_TRANSITION_CONTROL_KEEP) {\n\t\tdomainname = program;\n\t\tprogram = NULL;\n\t}\n\tif (program && strcmp(program, \"any\")) {\n\t\tif (!tomoyo_correct_path(program))\n\t\t\treturn -EINVAL;\n\t\te.program = tomoyo_get_name(program);\n\t\tif (!e.program)\n\t\t\tgoto out;\n\t}\n\tif (domainname && strcmp(domainname, \"any\")) {\n\t\tif (!tomoyo_correct_domain(domainname)) {\n\t\t\tif (!tomoyo_correct_path(domainname))\n\t\t\t\tgoto out;\n\t\t\te.is_last_name = true;\n\t\t}\n\t\te.domainname = tomoyo_get_name(domainname);\n\t\tif (!e.domainname)\n\t\t\tgoto out;\n\t}\n\tparam->list = &param->ns->policy_list[TOMOYO_ID_TRANSITION_CONTROL];\n\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_transition_control);\nout:\n\ttomoyo_put_name(e.domainname);\n\ttomoyo_put_name(e.program);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_write_aggregator",
          "args": [
            "&param"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_write_aggregator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "391-412",
          "snippet": "int tomoyo_write_aggregator(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_aggregator e = { };\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tconst char *original_name = tomoyo_read_token(param);\n\tconst char *aggregated_name = tomoyo_read_token(param);\n\tif (!tomoyo_correct_word(original_name) ||\n\t    !tomoyo_correct_path(aggregated_name))\n\t\treturn -EINVAL;\n\te.original_name = tomoyo_get_name(original_name);\n\te.aggregated_name = tomoyo_get_name(aggregated_name);\n\tif (!e.original_name || !e.aggregated_name ||\n\t    e.aggregated_name->is_patterned) /* No patterns allowed. */\n\t\tgoto out;\n\tparam->list = &param->ns->policy_list[TOMOYO_ID_AGGREGATOR];\n\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_aggregator);\nout:\n\ttomoyo_put_name(e.original_name);\n\ttomoyo_put_name(e.aggregated_name);\n\treturn error;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_write_aggregator(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_aggregator e = { };\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tconst char *original_name = tomoyo_read_token(param);\n\tconst char *aggregated_name = tomoyo_read_token(param);\n\tif (!tomoyo_correct_word(original_name) ||\n\t    !tomoyo_correct_path(aggregated_name))\n\t\treturn -EINVAL;\n\te.original_name = tomoyo_get_name(original_name);\n\te.aggregated_name = tomoyo_get_name(aggregated_name);\n\tif (!e.original_name || !e.aggregated_name ||\n\t    e.aggregated_name->is_patterned) /* No patterns allowed. */\n\t\tgoto out;\n\tparam->list = &param->ns->policy_list[TOMOYO_ID_AGGREGATOR];\n\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_aggregator);\nout:\n\ttomoyo_put_name(e.original_name);\n\ttomoyo_put_name(e.aggregated_name);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic const char *tomoyo_transition_type[TOMOYO_MAX_TRANSITION_TYPE] = {\n\t[TOMOYO_TRANSITION_CONTROL_NO_RESET]      = \"no_reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_RESET]         = \"reset_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE] = \"no_initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_INITIALIZE]    = \"initialize_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_NO_KEEP]       = \"no_keep_domain \",\n\t[TOMOYO_TRANSITION_CONTROL_KEEP]          = \"keep_domain \",\n};\nstatic const char *tomoyo_group_name[TOMOYO_MAX_GROUP] = {\n\t[TOMOYO_PATH_GROUP]    = \"path_group \",\n\t[TOMOYO_NUMBER_GROUP]  = \"number_group \",\n\t[TOMOYO_ADDRESS_GROUP] = \"address_group \",\n};\n\nstatic int tomoyo_write_exception(struct tomoyo_io_buffer *head)\n{\n\tconst bool is_delete = head->w.is_delete;\n\tstruct tomoyo_acl_param param = {\n\t\t.ns = head->w.ns,\n\t\t.is_delete = is_delete,\n\t\t.data = head->write_buf,\n\t};\n\tu8 i;\n\tif (tomoyo_str_starts(&param.data, \"aggregator \"))\n\t\treturn tomoyo_write_aggregator(&param);\n\tfor (i = 0; i < TOMOYO_MAX_TRANSITION_TYPE; i++)\n\t\tif (tomoyo_str_starts(&param.data, tomoyo_transition_type[i]))\n\t\t\treturn tomoyo_write_transition_control(&param, i);\n\tfor (i = 0; i < TOMOYO_MAX_GROUP; i++)\n\t\tif (tomoyo_str_starts(&param.data, tomoyo_group_name[i]))\n\t\t\treturn tomoyo_write_group(&param, i);\n\tif (tomoyo_str_starts(&param.data, \"acl_group \")) {\n\t\tunsigned int group;\n\t\tchar *data;\n\t\tgroup = simple_strtoul(param.data, &data, 10);\n\t\tif (group < TOMOYO_MAX_ACL_GROUPS && *data++ == ' ')\n\t\t\treturn tomoyo_write_domain2\n\t\t\t\t(head->w.ns, &head->w.ns->acl_group[group],\n\t\t\t\t data, is_delete);\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "tomoyo_read_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1645-1676",
    "snippet": "static void tomoyo_read_pid(struct tomoyo_io_buffer *head)\n{\n\tchar *buf = head->write_buf;\n\tbool global_pid = false;\n\tunsigned int pid;\n\tstruct task_struct *p;\n\tstruct tomoyo_domain_info *domain = NULL;\n\n\t/* Accessing write_buf is safe because head->io_sem is held. */\n\tif (!buf) {\n\t\thead->r.eof = true;\n\t\treturn; /* Do nothing if open(O_RDONLY). */\n\t}\n\tif (head->r.w_pos || head->r.eof)\n\t\treturn;\n\thead->r.eof = true;\n\tif (tomoyo_str_starts(&buf, \"global-pid \"))\n\t\tglobal_pid = true;\n\tpid = (unsigned int) simple_strtoul(buf, NULL, 10);\n\trcu_read_lock();\n\tif (global_pid)\n\t\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\telse\n\t\tp = find_task_by_vpid(pid);\n\tif (p)\n\t\tdomain = tomoyo_real_domain(p);\n\trcu_read_unlock();\n\tif (!domain)\n\t\treturn;\n\ttomoyo_io_printf(head, \"%u %u \", pid, domain->profile);\n\ttomoyo_set_string(head, domain->domainname->name);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "domain->domainname->name"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_io_printf",
          "args": [
            "head",
            "\"%u %u \"",
            "pid",
            "domain->profile"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_io_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "275-293",
          "snippet": "static void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_real_domain",
          "args": [
            "p"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_real_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1216-1220",
          "snippet": "static inline struct tomoyo_domain_info *tomoyo_real_domain(struct task_struct\n\t\t\t\t\t\t\t    *task)\n{\n\treturn task_cred_xxx(task, security);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline struct tomoyo_domain_info *tomoyo_real_domain(struct task_struct\n\t\t\t\t\t\t\t    *task)\n{\n\treturn task_cred_xxx(task, security);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_pid_ns",
          "args": [
            "pid",
            "&init_pid_ns"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "buf",
            "NULL",
            "10"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_str_starts",
          "args": [
            "&buf",
            "\"global-pid \""
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_str_starts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "374-384",
          "snippet": "bool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_read_pid(struct tomoyo_io_buffer *head)\n{\n\tchar *buf = head->write_buf;\n\tbool global_pid = false;\n\tunsigned int pid;\n\tstruct task_struct *p;\n\tstruct tomoyo_domain_info *domain = NULL;\n\n\t/* Accessing write_buf is safe because head->io_sem is held. */\n\tif (!buf) {\n\t\thead->r.eof = true;\n\t\treturn; /* Do nothing if open(O_RDONLY). */\n\t}\n\tif (head->r.w_pos || head->r.eof)\n\t\treturn;\n\thead->r.eof = true;\n\tif (tomoyo_str_starts(&buf, \"global-pid \"))\n\t\tglobal_pid = true;\n\tpid = (unsigned int) simple_strtoul(buf, NULL, 10);\n\trcu_read_lock();\n\tif (global_pid)\n\t\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\telse\n\t\tp = find_task_by_vpid(pid);\n\tif (p)\n\t\tdomain = tomoyo_real_domain(p);\n\trcu_read_unlock();\n\tif (!domain)\n\t\treturn;\n\ttomoyo_io_printf(head, \"%u %u \", pid, domain->profile);\n\ttomoyo_set_string(head, domain->domainname->name);\n}"
  },
  {
    "function_name": "tomoyo_write_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1629-1633",
    "snippet": "static int tomoyo_write_pid(struct tomoyo_io_buffer *head)\n{\n\thead->r.eof = false;\n\treturn 0;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_write_pid(struct tomoyo_io_buffer *head)\n{\n\thead->r.eof = false;\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_read_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1579-1620",
    "snippet": "static void tomoyo_read_domain(struct tomoyo_io_buffer *head)\n{\n\tif (head->r.eof)\n\t\treturn;\n\tlist_for_each_cookie(head->r.domain, &tomoyo_domain_list) {\n\t\tstruct tomoyo_domain_info *domain =\n\t\t\tlist_entry(head->r.domain, typeof(*domain), list);\n\t\tswitch (head->r.step) {\n\t\t\tu8 i;\n\t\tcase 0:\n\t\t\tif (domain->is_deleted &&\n\t\t\t    !head->r.print_this_domain_only)\n\t\t\t\tcontinue;\n\t\t\t/* Print domainname and flags. */\n\t\t\ttomoyo_set_string(head, domain->domainname->name);\n\t\t\ttomoyo_set_lf(head);\n\t\t\ttomoyo_io_printf(head, \"use_profile %u\\n\",\n\t\t\t\t\t domain->profile);\n\t\t\ttomoyo_io_printf(head, \"use_group %u\\n\",\n\t\t\t\t\t domain->group);\n\t\t\tfor (i = 0; i < TOMOYO_MAX_DOMAIN_INFO_FLAGS; i++)\n\t\t\t\tif (domain->flags[i])\n\t\t\t\t\ttomoyo_set_string(head, tomoyo_dif[i]);\n\t\t\thead->r.step++;\n\t\t\ttomoyo_set_lf(head);\n\t\t\t/* fall through */\n\t\tcase 1:\n\t\t\tif (!tomoyo_read_domain2(head, &domain->acl_info_list))\n\t\t\t\treturn;\n\t\t\thead->r.step++;\n\t\t\tif (!tomoyo_set_lf(head))\n\t\t\t\treturn;\n\t\t\t/* fall through */\n\t\tcase 2:\n\t\t\thead->r.step = 0;\n\t\t\tif (head->r.print_this_domain_only)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n done:\n\thead->r.eof = true;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const char * const tomoyo_dif[TOMOYO_MAX_DOMAIN_INFO_FLAGS] = {\n\t[TOMOYO_DIF_QUOTA_WARNED]      = \"quota_exceeded\\n\",\n\t[TOMOYO_DIF_TRANSITION_FAILED] = \"transition_failed\\n\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_lf",
          "args": [
            "head"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_lf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "314-318",
          "snippet": "static bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_domain2",
          "args": [
            "head",
            "&domain->acl_info_list"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_domain2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1559-1570",
          "snippet": "static bool tomoyo_read_domain2(struct tomoyo_io_buffer *head,\n\t\t\t\tstruct list_head *list)\n{\n\tlist_for_each_cookie(head->r.acl, list) {\n\t\tstruct tomoyo_acl_info *ptr =\n\t\t\tlist_entry(head->r.acl, typeof(*ptr), list);\n\t\tif (!tomoyo_print_entry(head, ptr))\n\t\t\treturn false;\n\t}\n\thead->r.acl = NULL;\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_read_domain2(struct tomoyo_io_buffer *head,\n\t\t\t\tstruct list_head *list)\n{\n\tlist_for_each_cookie(head->r.acl, list) {\n\t\tstruct tomoyo_acl_info *ptr =\n\t\t\tlist_entry(head->r.acl, typeof(*ptr), list);\n\t\tif (!tomoyo_print_entry(head, ptr))\n\t\t\treturn false;\n\t}\n\thead->r.acl = NULL;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "tomoyo_dif[i]"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_io_printf",
          "args": [
            "head",
            "\"use_group %u\\n\"",
            "domain->group"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_io_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "275-293",
          "snippet": "static void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->r.domain",
            "typeof(*domain)",
            "list"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*domain"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_cookie",
          "args": [
            "head->r.domain",
            "&tomoyo_domain_list"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char * const tomoyo_dif[TOMOYO_MAX_DOMAIN_INFO_FLAGS] = {\n\t[TOMOYO_DIF_QUOTA_WARNED]      = \"quota_exceeded\\n\",\n\t[TOMOYO_DIF_TRANSITION_FAILED] = \"transition_failed\\n\",\n};\n\nstatic void tomoyo_read_domain(struct tomoyo_io_buffer *head)\n{\n\tif (head->r.eof)\n\t\treturn;\n\tlist_for_each_cookie(head->r.domain, &tomoyo_domain_list) {\n\t\tstruct tomoyo_domain_info *domain =\n\t\t\tlist_entry(head->r.domain, typeof(*domain), list);\n\t\tswitch (head->r.step) {\n\t\t\tu8 i;\n\t\tcase 0:\n\t\t\tif (domain->is_deleted &&\n\t\t\t    !head->r.print_this_domain_only)\n\t\t\t\tcontinue;\n\t\t\t/* Print domainname and flags. */\n\t\t\ttomoyo_set_string(head, domain->domainname->name);\n\t\t\ttomoyo_set_lf(head);\n\t\t\ttomoyo_io_printf(head, \"use_profile %u\\n\",\n\t\t\t\t\t domain->profile);\n\t\t\ttomoyo_io_printf(head, \"use_group %u\\n\",\n\t\t\t\t\t domain->group);\n\t\t\tfor (i = 0; i < TOMOYO_MAX_DOMAIN_INFO_FLAGS; i++)\n\t\t\t\tif (domain->flags[i])\n\t\t\t\t\ttomoyo_set_string(head, tomoyo_dif[i]);\n\t\t\thead->r.step++;\n\t\t\ttomoyo_set_lf(head);\n\t\t\t/* fall through */\n\t\tcase 1:\n\t\t\tif (!tomoyo_read_domain2(head, &domain->acl_info_list))\n\t\t\t\treturn;\n\t\t\thead->r.step++;\n\t\t\tif (!tomoyo_set_lf(head))\n\t\t\t\treturn;\n\t\t\t/* fall through */\n\t\tcase 2:\n\t\t\thead->r.step = 0;\n\t\t\tif (head->r.print_this_domain_only)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n done:\n\thead->r.eof = true;\n}"
  },
  {
    "function_name": "tomoyo_read_domain2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1559-1570",
    "snippet": "static bool tomoyo_read_domain2(struct tomoyo_io_buffer *head,\n\t\t\t\tstruct list_head *list)\n{\n\tlist_for_each_cookie(head->r.acl, list) {\n\t\tstruct tomoyo_acl_info *ptr =\n\t\t\tlist_entry(head->r.acl, typeof(*ptr), list);\n\t\tif (!tomoyo_print_entry(head, ptr))\n\t\t\treturn false;\n\t}\n\thead->r.acl = NULL;\n\treturn true;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_print_entry",
          "args": [
            "head",
            "ptr"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1361-1547",
          "snippet": "static bool tomoyo_print_entry(struct tomoyo_io_buffer *head,\n\t\t\t       struct tomoyo_acl_info *acl)\n{\n\tconst u8 acl_type = acl->type;\n\tbool first = true;\n\tu8 bit;\n\n\tif (head->r.print_cond_part)\n\t\tgoto print_cond_part;\n\tif (acl->is_deleted)\n\t\treturn true;\n\tif (!tomoyo_flush(head))\n\t\treturn false;\n\telse if (acl_type == TOMOYO_TYPE_PATH_ACL) {\n\t\tstruct tomoyo_path_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u16 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (head->r.print_transition_related_only &&\n\t\t\t    bit != TOMOYO_TYPE_EXECUTE)\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_path_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t} else if (acl_type == TOMOYO_TYPE_MANUAL_TASK_ACL) {\n\t\tstruct tomoyo_task_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\ttomoyo_set_group(head, \"task \");\n\t\ttomoyo_set_string(head, \"manual_domain_transition \");\n\t\ttomoyo_set_string(head, ptr->domainname->name);\n\t} else if (head->r.print_transition_related_only) {\n\t\treturn true;\n\t} else if (acl_type == TOMOYO_TYPE_PATH2_ACL) {\n\t\tstruct tomoyo_path2_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH2_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pp2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name1);\n\t\ttomoyo_print_name_union(head, &ptr->name2);\n\t} else if (acl_type == TOMOYO_TYPE_PATH_NUMBER_ACL) {\n\t\tstruct tomoyo_path_number_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH_NUMBER_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pn2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t\ttomoyo_print_number_union(head, &ptr->number);\n\t} else if (acl_type == TOMOYO_TYPE_MKDEV_ACL) {\n\t\tstruct tomoyo_mkdev_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_MKDEV_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pnnn2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t\ttomoyo_print_number_union(head, &ptr->mode);\n\t\ttomoyo_print_number_union(head, &ptr->major);\n\t\ttomoyo_print_number_union(head, &ptr->minor);\n\t} else if (acl_type == TOMOYO_TYPE_INET_ACL) {\n\t\tstruct tomoyo_inet_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_NETWORK_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"network inet \");\n\t\t\t\ttomoyo_set_string(head, tomoyo_proto_keyword\n\t\t\t\t\t\t  [ptr->protocol]);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_socket_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_set_space(head);\n\t\tif (ptr->address.group) {\n\t\t\ttomoyo_set_string(head, \"@\");\n\t\t\ttomoyo_set_string(head, ptr->address.group->group_name\n\t\t\t\t\t  ->name);\n\t\t} else {\n\t\t\tchar buf[128];\n\t\t\ttomoyo_print_ip(buf, sizeof(buf), &ptr->address);\n\t\t\ttomoyo_io_printf(head, \"%s\", buf);\n\t\t}\n\t\ttomoyo_print_number_union(head, &ptr->port);\n\t} else if (acl_type == TOMOYO_TYPE_UNIX_ACL) {\n\t\tstruct tomoyo_unix_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_NETWORK_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"network unix \");\n\t\t\t\ttomoyo_set_string(head, tomoyo_proto_keyword\n\t\t\t\t\t\t  [ptr->protocol]);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_socket_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t} else if (acl_type == TOMOYO_TYPE_MOUNT_ACL) {\n\t\tstruct tomoyo_mount_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\ttomoyo_set_group(head, \"file mount\");\n\t\ttomoyo_print_name_union(head, &ptr->dev_name);\n\t\ttomoyo_print_name_union(head, &ptr->dir_name);\n\t\ttomoyo_print_name_union(head, &ptr->fs_type);\n\t\ttomoyo_print_number_union(head, &ptr->flags);\n\t} else if (acl_type == TOMOYO_TYPE_ENV_ACL) {\n\t\tstruct tomoyo_env_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\n\t\ttomoyo_set_group(head, \"misc env \");\n\t\ttomoyo_set_string(head, ptr->env->name);\n\t}\n\tif (acl->cond) {\n\t\thead->r.print_cond_part = true;\n\t\thead->r.cond_step = 0;\n\t\tif (!tomoyo_flush(head))\n\t\t\treturn false;\nprint_cond_part:\n\t\tif (!tomoyo_print_condition(head, acl->cond))\n\t\t\treturn false;\n\t\thead->r.print_cond_part = false;\n\t} else {\n\t\ttomoyo_set_lf(head);\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const char * const tomoyo_mac_keywords[TOMOYO_MAX_MAC_INDEX\n\t\t\t\t       + TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t/* CONFIG::file group */\n\t[TOMOYO_MAC_FILE_EXECUTE]    = \"execute\",\n\t[TOMOYO_MAC_FILE_OPEN]       = \"open\",\n\t[TOMOYO_MAC_FILE_CREATE]     = \"create\",\n\t[TOMOYO_MAC_FILE_UNLINK]     = \"unlink\",\n\t[TOMOYO_MAC_FILE_GETATTR]    = \"getattr\",\n\t[TOMOYO_MAC_FILE_MKDIR]      = \"mkdir\",\n\t[TOMOYO_MAC_FILE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_MAC_FILE_MKFIFO]     = \"mkfifo\",\n\t[TOMOYO_MAC_FILE_MKSOCK]     = \"mksock\",\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_MAC_FILE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = \"mkblock\",\n\t[TOMOYO_MAC_FILE_MKCHAR]     = \"mkchar\",\n\t[TOMOYO_MAC_FILE_LINK]       = \"link\",\n\t[TOMOYO_MAC_FILE_RENAME]     = \"rename\",\n\t[TOMOYO_MAC_FILE_CHMOD]      = \"chmod\",\n\t[TOMOYO_MAC_FILE_CHOWN]      = \"chown\",\n\t[TOMOYO_MAC_FILE_CHGRP]      = \"chgrp\",\n\t[TOMOYO_MAC_FILE_IOCTL]      = \"ioctl\",\n\t[TOMOYO_MAC_FILE_CHROOT]     = \"chroot\",\n\t[TOMOYO_MAC_FILE_MOUNT]      = \"mount\",\n\t[TOMOYO_MAC_FILE_UMOUNT]     = \"unmount\",\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = \"pivot_root\",\n\t/* CONFIG::network group */\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       = \"inet_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     = \"inet_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    = \"inet_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        = \"inet_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        = \"inet_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          = \"inet_raw_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          = \"inet_raw_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       = \"unix_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     = \"unix_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    = \"unix_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        = \"unix_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        = \"unix_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    = \"unix_seqpacket_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  = \"unix_seqpacket_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = \"unix_seqpacket_connect\",\n\t/* CONFIG::misc group */\n\t[TOMOYO_MAC_ENVIRON] = \"env\",\n\t/* CONFIG group */\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_FILE] = \"file\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_MISC] = \"misc\",\n};",
            "const char * const tomoyo_path_keyword[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = \"execute\",\n\t[TOMOYO_TYPE_READ]       = \"read\",\n\t[TOMOYO_TYPE_WRITE]      = \"write\",\n\t[TOMOYO_TYPE_APPEND]     = \"append\",\n\t[TOMOYO_TYPE_UNLINK]     = \"unlink\",\n\t[TOMOYO_TYPE_GETATTR]    = \"getattr\",\n\t[TOMOYO_TYPE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_TYPE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_TYPE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_TYPE_CHROOT]     = \"chroot\",\n\t[TOMOYO_TYPE_UMOUNT]     = \"unmount\",\n};",
            "const char * const tomoyo_socket_keyword[TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[TOMOYO_NETWORK_BIND]    = \"bind\",\n\t[TOMOYO_NETWORK_LISTEN]  = \"listen\",\n\t[TOMOYO_NETWORK_CONNECT] = \"connect\",\n\t[TOMOYO_NETWORK_SEND]    = \"send\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char * const tomoyo_mac_keywords[TOMOYO_MAX_MAC_INDEX\n\t\t\t\t       + TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t/* CONFIG::file group */\n\t[TOMOYO_MAC_FILE_EXECUTE]    = \"execute\",\n\t[TOMOYO_MAC_FILE_OPEN]       = \"open\",\n\t[TOMOYO_MAC_FILE_CREATE]     = \"create\",\n\t[TOMOYO_MAC_FILE_UNLINK]     = \"unlink\",\n\t[TOMOYO_MAC_FILE_GETATTR]    = \"getattr\",\n\t[TOMOYO_MAC_FILE_MKDIR]      = \"mkdir\",\n\t[TOMOYO_MAC_FILE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_MAC_FILE_MKFIFO]     = \"mkfifo\",\n\t[TOMOYO_MAC_FILE_MKSOCK]     = \"mksock\",\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_MAC_FILE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = \"mkblock\",\n\t[TOMOYO_MAC_FILE_MKCHAR]     = \"mkchar\",\n\t[TOMOYO_MAC_FILE_LINK]       = \"link\",\n\t[TOMOYO_MAC_FILE_RENAME]     = \"rename\",\n\t[TOMOYO_MAC_FILE_CHMOD]      = \"chmod\",\n\t[TOMOYO_MAC_FILE_CHOWN]      = \"chown\",\n\t[TOMOYO_MAC_FILE_CHGRP]      = \"chgrp\",\n\t[TOMOYO_MAC_FILE_IOCTL]      = \"ioctl\",\n\t[TOMOYO_MAC_FILE_CHROOT]     = \"chroot\",\n\t[TOMOYO_MAC_FILE_MOUNT]      = \"mount\",\n\t[TOMOYO_MAC_FILE_UMOUNT]     = \"unmount\",\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = \"pivot_root\",\n\t/* CONFIG::network group */\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       = \"inet_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     = \"inet_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    = \"inet_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        = \"inet_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        = \"inet_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          = \"inet_raw_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          = \"inet_raw_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       = \"unix_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     = \"unix_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    = \"unix_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        = \"unix_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        = \"unix_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    = \"unix_seqpacket_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  = \"unix_seqpacket_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = \"unix_seqpacket_connect\",\n\t/* CONFIG::misc group */\n\t[TOMOYO_MAC_ENVIRON] = \"env\",\n\t/* CONFIG group */\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_FILE] = \"file\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_MISC] = \"misc\",\n};\nconst char * const tomoyo_path_keyword[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = \"execute\",\n\t[TOMOYO_TYPE_READ]       = \"read\",\n\t[TOMOYO_TYPE_WRITE]      = \"write\",\n\t[TOMOYO_TYPE_APPEND]     = \"append\",\n\t[TOMOYO_TYPE_UNLINK]     = \"unlink\",\n\t[TOMOYO_TYPE_GETATTR]    = \"getattr\",\n\t[TOMOYO_TYPE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_TYPE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_TYPE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_TYPE_CHROOT]     = \"chroot\",\n\t[TOMOYO_TYPE_UMOUNT]     = \"unmount\",\n};\nconst char * const tomoyo_socket_keyword[TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[TOMOYO_NETWORK_BIND]    = \"bind\",\n\t[TOMOYO_NETWORK_LISTEN]  = \"listen\",\n\t[TOMOYO_NETWORK_CONNECT] = \"connect\",\n\t[TOMOYO_NETWORK_SEND]    = \"send\",\n};\n\nstatic bool tomoyo_print_entry(struct tomoyo_io_buffer *head,\n\t\t\t       struct tomoyo_acl_info *acl)\n{\n\tconst u8 acl_type = acl->type;\n\tbool first = true;\n\tu8 bit;\n\n\tif (head->r.print_cond_part)\n\t\tgoto print_cond_part;\n\tif (acl->is_deleted)\n\t\treturn true;\n\tif (!tomoyo_flush(head))\n\t\treturn false;\n\telse if (acl_type == TOMOYO_TYPE_PATH_ACL) {\n\t\tstruct tomoyo_path_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u16 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (head->r.print_transition_related_only &&\n\t\t\t    bit != TOMOYO_TYPE_EXECUTE)\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_path_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t} else if (acl_type == TOMOYO_TYPE_MANUAL_TASK_ACL) {\n\t\tstruct tomoyo_task_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\ttomoyo_set_group(head, \"task \");\n\t\ttomoyo_set_string(head, \"manual_domain_transition \");\n\t\ttomoyo_set_string(head, ptr->domainname->name);\n\t} else if (head->r.print_transition_related_only) {\n\t\treturn true;\n\t} else if (acl_type == TOMOYO_TYPE_PATH2_ACL) {\n\t\tstruct tomoyo_path2_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH2_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pp2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name1);\n\t\ttomoyo_print_name_union(head, &ptr->name2);\n\t} else if (acl_type == TOMOYO_TYPE_PATH_NUMBER_ACL) {\n\t\tstruct tomoyo_path_number_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH_NUMBER_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pn2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t\ttomoyo_print_number_union(head, &ptr->number);\n\t} else if (acl_type == TOMOYO_TYPE_MKDEV_ACL) {\n\t\tstruct tomoyo_mkdev_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_MKDEV_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pnnn2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t\ttomoyo_print_number_union(head, &ptr->mode);\n\t\ttomoyo_print_number_union(head, &ptr->major);\n\t\ttomoyo_print_number_union(head, &ptr->minor);\n\t} else if (acl_type == TOMOYO_TYPE_INET_ACL) {\n\t\tstruct tomoyo_inet_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_NETWORK_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"network inet \");\n\t\t\t\ttomoyo_set_string(head, tomoyo_proto_keyword\n\t\t\t\t\t\t  [ptr->protocol]);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_socket_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_set_space(head);\n\t\tif (ptr->address.group) {\n\t\t\ttomoyo_set_string(head, \"@\");\n\t\t\ttomoyo_set_string(head, ptr->address.group->group_name\n\t\t\t\t\t  ->name);\n\t\t} else {\n\t\t\tchar buf[128];\n\t\t\ttomoyo_print_ip(buf, sizeof(buf), &ptr->address);\n\t\t\ttomoyo_io_printf(head, \"%s\", buf);\n\t\t}\n\t\ttomoyo_print_number_union(head, &ptr->port);\n\t} else if (acl_type == TOMOYO_TYPE_UNIX_ACL) {\n\t\tstruct tomoyo_unix_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_NETWORK_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"network unix \");\n\t\t\t\ttomoyo_set_string(head, tomoyo_proto_keyword\n\t\t\t\t\t\t  [ptr->protocol]);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_socket_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t} else if (acl_type == TOMOYO_TYPE_MOUNT_ACL) {\n\t\tstruct tomoyo_mount_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\ttomoyo_set_group(head, \"file mount\");\n\t\ttomoyo_print_name_union(head, &ptr->dev_name);\n\t\ttomoyo_print_name_union(head, &ptr->dir_name);\n\t\ttomoyo_print_name_union(head, &ptr->fs_type);\n\t\ttomoyo_print_number_union(head, &ptr->flags);\n\t} else if (acl_type == TOMOYO_TYPE_ENV_ACL) {\n\t\tstruct tomoyo_env_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\n\t\ttomoyo_set_group(head, \"misc env \");\n\t\ttomoyo_set_string(head, ptr->env->name);\n\t}\n\tif (acl->cond) {\n\t\thead->r.print_cond_part = true;\n\t\thead->r.cond_step = 0;\n\t\tif (!tomoyo_flush(head))\n\t\t\treturn false;\nprint_cond_part:\n\t\tif (!tomoyo_print_condition(head, acl->cond))\n\t\t\treturn false;\n\t\thead->r.print_cond_part = false;\n\t} else {\n\t\ttomoyo_set_lf(head);\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->r.acl",
            "typeof(*ptr)",
            "list"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_cookie",
          "args": [
            "head->r.acl",
            "list"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_read_domain2(struct tomoyo_io_buffer *head,\n\t\t\t\tstruct list_head *list)\n{\n\tlist_for_each_cookie(head->r.acl, list) {\n\t\tstruct tomoyo_acl_info *ptr =\n\t\t\tlist_entry(head->r.acl, typeof(*ptr), list);\n\t\tif (!tomoyo_print_entry(head, ptr))\n\t\t\treturn false;\n\t}\n\thead->r.acl = NULL;\n\treturn true;\n}"
  },
  {
    "function_name": "tomoyo_print_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1361-1547",
    "snippet": "static bool tomoyo_print_entry(struct tomoyo_io_buffer *head,\n\t\t\t       struct tomoyo_acl_info *acl)\n{\n\tconst u8 acl_type = acl->type;\n\tbool first = true;\n\tu8 bit;\n\n\tif (head->r.print_cond_part)\n\t\tgoto print_cond_part;\n\tif (acl->is_deleted)\n\t\treturn true;\n\tif (!tomoyo_flush(head))\n\t\treturn false;\n\telse if (acl_type == TOMOYO_TYPE_PATH_ACL) {\n\t\tstruct tomoyo_path_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u16 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (head->r.print_transition_related_only &&\n\t\t\t    bit != TOMOYO_TYPE_EXECUTE)\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_path_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t} else if (acl_type == TOMOYO_TYPE_MANUAL_TASK_ACL) {\n\t\tstruct tomoyo_task_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\ttomoyo_set_group(head, \"task \");\n\t\ttomoyo_set_string(head, \"manual_domain_transition \");\n\t\ttomoyo_set_string(head, ptr->domainname->name);\n\t} else if (head->r.print_transition_related_only) {\n\t\treturn true;\n\t} else if (acl_type == TOMOYO_TYPE_PATH2_ACL) {\n\t\tstruct tomoyo_path2_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH2_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pp2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name1);\n\t\ttomoyo_print_name_union(head, &ptr->name2);\n\t} else if (acl_type == TOMOYO_TYPE_PATH_NUMBER_ACL) {\n\t\tstruct tomoyo_path_number_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH_NUMBER_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pn2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t\ttomoyo_print_number_union(head, &ptr->number);\n\t} else if (acl_type == TOMOYO_TYPE_MKDEV_ACL) {\n\t\tstruct tomoyo_mkdev_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_MKDEV_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pnnn2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t\ttomoyo_print_number_union(head, &ptr->mode);\n\t\ttomoyo_print_number_union(head, &ptr->major);\n\t\ttomoyo_print_number_union(head, &ptr->minor);\n\t} else if (acl_type == TOMOYO_TYPE_INET_ACL) {\n\t\tstruct tomoyo_inet_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_NETWORK_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"network inet \");\n\t\t\t\ttomoyo_set_string(head, tomoyo_proto_keyword\n\t\t\t\t\t\t  [ptr->protocol]);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_socket_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_set_space(head);\n\t\tif (ptr->address.group) {\n\t\t\ttomoyo_set_string(head, \"@\");\n\t\t\ttomoyo_set_string(head, ptr->address.group->group_name\n\t\t\t\t\t  ->name);\n\t\t} else {\n\t\t\tchar buf[128];\n\t\t\ttomoyo_print_ip(buf, sizeof(buf), &ptr->address);\n\t\t\ttomoyo_io_printf(head, \"%s\", buf);\n\t\t}\n\t\ttomoyo_print_number_union(head, &ptr->port);\n\t} else if (acl_type == TOMOYO_TYPE_UNIX_ACL) {\n\t\tstruct tomoyo_unix_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_NETWORK_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"network unix \");\n\t\t\t\ttomoyo_set_string(head, tomoyo_proto_keyword\n\t\t\t\t\t\t  [ptr->protocol]);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_socket_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t} else if (acl_type == TOMOYO_TYPE_MOUNT_ACL) {\n\t\tstruct tomoyo_mount_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\ttomoyo_set_group(head, \"file mount\");\n\t\ttomoyo_print_name_union(head, &ptr->dev_name);\n\t\ttomoyo_print_name_union(head, &ptr->dir_name);\n\t\ttomoyo_print_name_union(head, &ptr->fs_type);\n\t\ttomoyo_print_number_union(head, &ptr->flags);\n\t} else if (acl_type == TOMOYO_TYPE_ENV_ACL) {\n\t\tstruct tomoyo_env_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\n\t\ttomoyo_set_group(head, \"misc env \");\n\t\ttomoyo_set_string(head, ptr->env->name);\n\t}\n\tif (acl->cond) {\n\t\thead->r.print_cond_part = true;\n\t\thead->r.cond_step = 0;\n\t\tif (!tomoyo_flush(head))\n\t\t\treturn false;\nprint_cond_part:\n\t\tif (!tomoyo_print_condition(head, acl->cond))\n\t\t\treturn false;\n\t\thead->r.print_cond_part = false;\n\t} else {\n\t\ttomoyo_set_lf(head);\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const char * const tomoyo_mac_keywords[TOMOYO_MAX_MAC_INDEX\n\t\t\t\t       + TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t/* CONFIG::file group */\n\t[TOMOYO_MAC_FILE_EXECUTE]    = \"execute\",\n\t[TOMOYO_MAC_FILE_OPEN]       = \"open\",\n\t[TOMOYO_MAC_FILE_CREATE]     = \"create\",\n\t[TOMOYO_MAC_FILE_UNLINK]     = \"unlink\",\n\t[TOMOYO_MAC_FILE_GETATTR]    = \"getattr\",\n\t[TOMOYO_MAC_FILE_MKDIR]      = \"mkdir\",\n\t[TOMOYO_MAC_FILE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_MAC_FILE_MKFIFO]     = \"mkfifo\",\n\t[TOMOYO_MAC_FILE_MKSOCK]     = \"mksock\",\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_MAC_FILE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = \"mkblock\",\n\t[TOMOYO_MAC_FILE_MKCHAR]     = \"mkchar\",\n\t[TOMOYO_MAC_FILE_LINK]       = \"link\",\n\t[TOMOYO_MAC_FILE_RENAME]     = \"rename\",\n\t[TOMOYO_MAC_FILE_CHMOD]      = \"chmod\",\n\t[TOMOYO_MAC_FILE_CHOWN]      = \"chown\",\n\t[TOMOYO_MAC_FILE_CHGRP]      = \"chgrp\",\n\t[TOMOYO_MAC_FILE_IOCTL]      = \"ioctl\",\n\t[TOMOYO_MAC_FILE_CHROOT]     = \"chroot\",\n\t[TOMOYO_MAC_FILE_MOUNT]      = \"mount\",\n\t[TOMOYO_MAC_FILE_UMOUNT]     = \"unmount\",\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = \"pivot_root\",\n\t/* CONFIG::network group */\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       = \"inet_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     = \"inet_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    = \"inet_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        = \"inet_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        = \"inet_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          = \"inet_raw_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          = \"inet_raw_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       = \"unix_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     = \"unix_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    = \"unix_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        = \"unix_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        = \"unix_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    = \"unix_seqpacket_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  = \"unix_seqpacket_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = \"unix_seqpacket_connect\",\n\t/* CONFIG::misc group */\n\t[TOMOYO_MAC_ENVIRON] = \"env\",\n\t/* CONFIG group */\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_FILE] = \"file\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_MISC] = \"misc\",\n};",
      "const char * const tomoyo_path_keyword[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = \"execute\",\n\t[TOMOYO_TYPE_READ]       = \"read\",\n\t[TOMOYO_TYPE_WRITE]      = \"write\",\n\t[TOMOYO_TYPE_APPEND]     = \"append\",\n\t[TOMOYO_TYPE_UNLINK]     = \"unlink\",\n\t[TOMOYO_TYPE_GETATTR]    = \"getattr\",\n\t[TOMOYO_TYPE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_TYPE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_TYPE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_TYPE_CHROOT]     = \"chroot\",\n\t[TOMOYO_TYPE_UMOUNT]     = \"unmount\",\n};",
      "const char * const tomoyo_socket_keyword[TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[TOMOYO_NETWORK_BIND]    = \"bind\",\n\t[TOMOYO_NETWORK_LISTEN]  = \"listen\",\n\t[TOMOYO_NETWORK_CONNECT] = \"connect\",\n\t[TOMOYO_NETWORK_SEND]    = \"send\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_lf",
          "args": [
            "head"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_lf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "314-318",
          "snippet": "static bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_print_condition",
          "args": [
            "head",
            "acl->cond"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_condition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1201-1332",
          "snippet": "static bool tomoyo_print_condition(struct tomoyo_io_buffer *head,\n\t\t\t\t   const struct tomoyo_condition *cond)\n{\n\tswitch (head->r.cond_step) {\n\tcase 0:\n\t\thead->r.cond_index = 0;\n\t\thead->r.cond_step++;\n\t\tif (cond->transit) {\n\t\t\ttomoyo_set_space(head);\n\t\t\ttomoyo_set_string(head, cond->transit->name);\n\t\t}\n\t\t/* fall through */\n\tcase 1:\n\t\t{\n\t\t\tconst u16 condc = cond->condc;\n\t\t\tconst struct tomoyo_condition_element *condp =\n\t\t\t\t(typeof(condp)) (cond + 1);\n\t\t\tconst struct tomoyo_number_union *numbers_p =\n\t\t\t\t(typeof(numbers_p)) (condp + condc);\n\t\t\tconst struct tomoyo_name_union *names_p =\n\t\t\t\t(typeof(names_p))\n\t\t\t\t(numbers_p + cond->numbers_count);\n\t\t\tconst struct tomoyo_argv *argv =\n\t\t\t\t(typeof(argv)) (names_p + cond->names_count);\n\t\t\tconst struct tomoyo_envp *envp =\n\t\t\t\t(typeof(envp)) (argv + cond->argc);\n\t\t\tu16 skip;\n\t\t\tfor (skip = 0; skip < head->r.cond_index; skip++) {\n\t\t\t\tconst u8 left = condp->left;\n\t\t\t\tconst u8 right = condp->right;\n\t\t\t\tcondp++;\n\t\t\t\tswitch (left) {\n\t\t\t\tcase TOMOYO_ARGV_ENTRY:\n\t\t\t\t\targv++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_ENVP_ENTRY:\n\t\t\t\t\tenvp++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\tnumbers_p++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (right) {\n\t\t\t\tcase TOMOYO_NAME_UNION:\n\t\t\t\t\tnames_p++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\tnumbers_p++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (head->r.cond_index < condc) {\n\t\t\t\tconst u8 match = condp->equals;\n\t\t\t\tconst u8 left = condp->left;\n\t\t\t\tconst u8 right = condp->right;\n\t\t\t\tif (!tomoyo_flush(head))\n\t\t\t\t\treturn false;\n\t\t\t\tcondp++;\n\t\t\t\thead->r.cond_index++;\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tswitch (left) {\n\t\t\t\tcase TOMOYO_ARGV_ENTRY:\n\t\t\t\t\ttomoyo_io_printf(head,\n\t\t\t\t\t\t\t \"exec.argv[%lu]%s=\\\"\",\n\t\t\t\t\t\t\t argv->index, argv->\n\t\t\t\t\t\t\t is_not ? \"!\" : \"\");\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  argv->value->name);\n\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\targv++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_ENVP_ENTRY:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  \"exec.envp[\\\"\");\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  envp->name->name);\n\t\t\t\t\ttomoyo_io_printf(head, \"\\\"]%s=\", envp->\n\t\t\t\t\t\t\t is_not ? \"!\" : \"\");\n\t\t\t\t\tif (envp->value) {\n\t\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\t\ttomoyo_set_string(head, envp->\n\t\t\t\t\t\t\t\t  value->name);\n\t\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t\t  \"NULL\");\n\t\t\t\t\t}\n\t\t\t\t\tenvp++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\ttomoyo_print_number_union_nospace\n\t\t\t\t\t\t(head, numbers_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t       tomoyo_condition_keyword[left]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttomoyo_set_string(head, match ? \"=\" : \"!=\");\n\t\t\t\tswitch (right) {\n\t\t\t\tcase TOMOYO_NAME_UNION:\n\t\t\t\t\ttomoyo_print_name_union_quoted\n\t\t\t\t\t\t(head, names_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\ttomoyo_print_number_union_nospace\n\t\t\t\t\t\t(head, numbers_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t  tomoyo_condition_keyword[right]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thead->r.cond_step++;\n\t\t/* fall through */\n\tcase 2:\n\t\tif (!tomoyo_flush(head))\n\t\t\tbreak;\n\t\thead->r.cond_step++;\n\t\t/* fall through */\n\tcase 3:\n\t\tif (cond->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\t\ttomoyo_io_printf(head, \" grant_log=%s\",\n\t\t\t\t\t tomoyo_yesno(cond->grant_log ==\n\t\t\t\t\t\t      TOMOYO_GRANTLOG_YES));\n\t\ttomoyo_set_lf(head);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const char * const tomoyo_condition_keyword[TOMOYO_MAX_CONDITION_KEYWORD] = {\n\t[TOMOYO_TASK_UID]             = \"task.uid\",\n\t[TOMOYO_TASK_EUID]            = \"task.euid\",\n\t[TOMOYO_TASK_SUID]            = \"task.suid\",\n\t[TOMOYO_TASK_FSUID]           = \"task.fsuid\",\n\t[TOMOYO_TASK_GID]             = \"task.gid\",\n\t[TOMOYO_TASK_EGID]            = \"task.egid\",\n\t[TOMOYO_TASK_SGID]            = \"task.sgid\",\n\t[TOMOYO_TASK_FSGID]           = \"task.fsgid\",\n\t[TOMOYO_TASK_PID]             = \"task.pid\",\n\t[TOMOYO_TASK_PPID]            = \"task.ppid\",\n\t[TOMOYO_EXEC_ARGC]            = \"exec.argc\",\n\t[TOMOYO_EXEC_ENVC]            = \"exec.envc\",\n\t[TOMOYO_TYPE_IS_SOCKET]       = \"socket\",\n\t[TOMOYO_TYPE_IS_SYMLINK]      = \"symlink\",\n\t[TOMOYO_TYPE_IS_FILE]         = \"file\",\n\t[TOMOYO_TYPE_IS_BLOCK_DEV]    = \"block\",\n\t[TOMOYO_TYPE_IS_DIRECTORY]    = \"directory\",\n\t[TOMOYO_TYPE_IS_CHAR_DEV]     = \"char\",\n\t[TOMOYO_TYPE_IS_FIFO]         = \"fifo\",\n\t[TOMOYO_MODE_SETUID]          = \"setuid\",\n\t[TOMOYO_MODE_SETGID]          = \"setgid\",\n\t[TOMOYO_MODE_STICKY]          = \"sticky\",\n\t[TOMOYO_MODE_OWNER_READ]      = \"owner_read\",\n\t[TOMOYO_MODE_OWNER_WRITE]     = \"owner_write\",\n\t[TOMOYO_MODE_OWNER_EXECUTE]   = \"owner_execute\",\n\t[TOMOYO_MODE_GROUP_READ]      = \"group_read\",\n\t[TOMOYO_MODE_GROUP_WRITE]     = \"group_write\",\n\t[TOMOYO_MODE_GROUP_EXECUTE]   = \"group_execute\",\n\t[TOMOYO_MODE_OTHERS_READ]     = \"others_read\",\n\t[TOMOYO_MODE_OTHERS_WRITE]    = \"others_write\",\n\t[TOMOYO_MODE_OTHERS_EXECUTE]  = \"others_execute\",\n\t[TOMOYO_EXEC_REALPATH]        = \"exec.realpath\",\n\t[TOMOYO_SYMLINK_TARGET]       = \"symlink.target\",\n\t[TOMOYO_PATH1_UID]            = \"path1.uid\",\n\t[TOMOYO_PATH1_GID]            = \"path1.gid\",\n\t[TOMOYO_PATH1_INO]            = \"path1.ino\",\n\t[TOMOYO_PATH1_MAJOR]          = \"path1.major\",\n\t[TOMOYO_PATH1_MINOR]          = \"path1.minor\",\n\t[TOMOYO_PATH1_PERM]           = \"path1.perm\",\n\t[TOMOYO_PATH1_TYPE]           = \"path1.type\",\n\t[TOMOYO_PATH1_DEV_MAJOR]      = \"path1.dev_major\",\n\t[TOMOYO_PATH1_DEV_MINOR]      = \"path1.dev_minor\",\n\t[TOMOYO_PATH2_UID]            = \"path2.uid\",\n\t[TOMOYO_PATH2_GID]            = \"path2.gid\",\n\t[TOMOYO_PATH2_INO]            = \"path2.ino\",\n\t[TOMOYO_PATH2_MAJOR]          = \"path2.major\",\n\t[TOMOYO_PATH2_MINOR]          = \"path2.minor\",\n\t[TOMOYO_PATH2_PERM]           = \"path2.perm\",\n\t[TOMOYO_PATH2_TYPE]           = \"path2.type\",\n\t[TOMOYO_PATH2_DEV_MAJOR]      = \"path2.dev_major\",\n\t[TOMOYO_PATH2_DEV_MINOR]      = \"path2.dev_minor\",\n\t[TOMOYO_PATH1_PARENT_UID]     = \"path1.parent.uid\",\n\t[TOMOYO_PATH1_PARENT_GID]     = \"path1.parent.gid\",\n\t[TOMOYO_PATH1_PARENT_INO]     = \"path1.parent.ino\",\n\t[TOMOYO_PATH1_PARENT_PERM]    = \"path1.parent.perm\",\n\t[TOMOYO_PATH2_PARENT_UID]     = \"path2.parent.uid\",\n\t[TOMOYO_PATH2_PARENT_GID]     = \"path2.parent.gid\",\n\t[TOMOYO_PATH2_PARENT_INO]     = \"path2.parent.ino\",\n\t[TOMOYO_PATH2_PARENT_PERM]    = \"path2.parent.perm\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char * const tomoyo_condition_keyword[TOMOYO_MAX_CONDITION_KEYWORD] = {\n\t[TOMOYO_TASK_UID]             = \"task.uid\",\n\t[TOMOYO_TASK_EUID]            = \"task.euid\",\n\t[TOMOYO_TASK_SUID]            = \"task.suid\",\n\t[TOMOYO_TASK_FSUID]           = \"task.fsuid\",\n\t[TOMOYO_TASK_GID]             = \"task.gid\",\n\t[TOMOYO_TASK_EGID]            = \"task.egid\",\n\t[TOMOYO_TASK_SGID]            = \"task.sgid\",\n\t[TOMOYO_TASK_FSGID]           = \"task.fsgid\",\n\t[TOMOYO_TASK_PID]             = \"task.pid\",\n\t[TOMOYO_TASK_PPID]            = \"task.ppid\",\n\t[TOMOYO_EXEC_ARGC]            = \"exec.argc\",\n\t[TOMOYO_EXEC_ENVC]            = \"exec.envc\",\n\t[TOMOYO_TYPE_IS_SOCKET]       = \"socket\",\n\t[TOMOYO_TYPE_IS_SYMLINK]      = \"symlink\",\n\t[TOMOYO_TYPE_IS_FILE]         = \"file\",\n\t[TOMOYO_TYPE_IS_BLOCK_DEV]    = \"block\",\n\t[TOMOYO_TYPE_IS_DIRECTORY]    = \"directory\",\n\t[TOMOYO_TYPE_IS_CHAR_DEV]     = \"char\",\n\t[TOMOYO_TYPE_IS_FIFO]         = \"fifo\",\n\t[TOMOYO_MODE_SETUID]          = \"setuid\",\n\t[TOMOYO_MODE_SETGID]          = \"setgid\",\n\t[TOMOYO_MODE_STICKY]          = \"sticky\",\n\t[TOMOYO_MODE_OWNER_READ]      = \"owner_read\",\n\t[TOMOYO_MODE_OWNER_WRITE]     = \"owner_write\",\n\t[TOMOYO_MODE_OWNER_EXECUTE]   = \"owner_execute\",\n\t[TOMOYO_MODE_GROUP_READ]      = \"group_read\",\n\t[TOMOYO_MODE_GROUP_WRITE]     = \"group_write\",\n\t[TOMOYO_MODE_GROUP_EXECUTE]   = \"group_execute\",\n\t[TOMOYO_MODE_OTHERS_READ]     = \"others_read\",\n\t[TOMOYO_MODE_OTHERS_WRITE]    = \"others_write\",\n\t[TOMOYO_MODE_OTHERS_EXECUTE]  = \"others_execute\",\n\t[TOMOYO_EXEC_REALPATH]        = \"exec.realpath\",\n\t[TOMOYO_SYMLINK_TARGET]       = \"symlink.target\",\n\t[TOMOYO_PATH1_UID]            = \"path1.uid\",\n\t[TOMOYO_PATH1_GID]            = \"path1.gid\",\n\t[TOMOYO_PATH1_INO]            = \"path1.ino\",\n\t[TOMOYO_PATH1_MAJOR]          = \"path1.major\",\n\t[TOMOYO_PATH1_MINOR]          = \"path1.minor\",\n\t[TOMOYO_PATH1_PERM]           = \"path1.perm\",\n\t[TOMOYO_PATH1_TYPE]           = \"path1.type\",\n\t[TOMOYO_PATH1_DEV_MAJOR]      = \"path1.dev_major\",\n\t[TOMOYO_PATH1_DEV_MINOR]      = \"path1.dev_minor\",\n\t[TOMOYO_PATH2_UID]            = \"path2.uid\",\n\t[TOMOYO_PATH2_GID]            = \"path2.gid\",\n\t[TOMOYO_PATH2_INO]            = \"path2.ino\",\n\t[TOMOYO_PATH2_MAJOR]          = \"path2.major\",\n\t[TOMOYO_PATH2_MINOR]          = \"path2.minor\",\n\t[TOMOYO_PATH2_PERM]           = \"path2.perm\",\n\t[TOMOYO_PATH2_TYPE]           = \"path2.type\",\n\t[TOMOYO_PATH2_DEV_MAJOR]      = \"path2.dev_major\",\n\t[TOMOYO_PATH2_DEV_MINOR]      = \"path2.dev_minor\",\n\t[TOMOYO_PATH1_PARENT_UID]     = \"path1.parent.uid\",\n\t[TOMOYO_PATH1_PARENT_GID]     = \"path1.parent.gid\",\n\t[TOMOYO_PATH1_PARENT_INO]     = \"path1.parent.ino\",\n\t[TOMOYO_PATH1_PARENT_PERM]    = \"path1.parent.perm\",\n\t[TOMOYO_PATH2_PARENT_UID]     = \"path2.parent.uid\",\n\t[TOMOYO_PATH2_PARENT_GID]     = \"path2.parent.gid\",\n\t[TOMOYO_PATH2_PARENT_INO]     = \"path2.parent.ino\",\n\t[TOMOYO_PATH2_PARENT_PERM]    = \"path2.parent.perm\",\n};\n\nstatic bool tomoyo_print_condition(struct tomoyo_io_buffer *head,\n\t\t\t\t   const struct tomoyo_condition *cond)\n{\n\tswitch (head->r.cond_step) {\n\tcase 0:\n\t\thead->r.cond_index = 0;\n\t\thead->r.cond_step++;\n\t\tif (cond->transit) {\n\t\t\ttomoyo_set_space(head);\n\t\t\ttomoyo_set_string(head, cond->transit->name);\n\t\t}\n\t\t/* fall through */\n\tcase 1:\n\t\t{\n\t\t\tconst u16 condc = cond->condc;\n\t\t\tconst struct tomoyo_condition_element *condp =\n\t\t\t\t(typeof(condp)) (cond + 1);\n\t\t\tconst struct tomoyo_number_union *numbers_p =\n\t\t\t\t(typeof(numbers_p)) (condp + condc);\n\t\t\tconst struct tomoyo_name_union *names_p =\n\t\t\t\t(typeof(names_p))\n\t\t\t\t(numbers_p + cond->numbers_count);\n\t\t\tconst struct tomoyo_argv *argv =\n\t\t\t\t(typeof(argv)) (names_p + cond->names_count);\n\t\t\tconst struct tomoyo_envp *envp =\n\t\t\t\t(typeof(envp)) (argv + cond->argc);\n\t\t\tu16 skip;\n\t\t\tfor (skip = 0; skip < head->r.cond_index; skip++) {\n\t\t\t\tconst u8 left = condp->left;\n\t\t\t\tconst u8 right = condp->right;\n\t\t\t\tcondp++;\n\t\t\t\tswitch (left) {\n\t\t\t\tcase TOMOYO_ARGV_ENTRY:\n\t\t\t\t\targv++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_ENVP_ENTRY:\n\t\t\t\t\tenvp++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\tnumbers_p++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (right) {\n\t\t\t\tcase TOMOYO_NAME_UNION:\n\t\t\t\t\tnames_p++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\tnumbers_p++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (head->r.cond_index < condc) {\n\t\t\t\tconst u8 match = condp->equals;\n\t\t\t\tconst u8 left = condp->left;\n\t\t\t\tconst u8 right = condp->right;\n\t\t\t\tif (!tomoyo_flush(head))\n\t\t\t\t\treturn false;\n\t\t\t\tcondp++;\n\t\t\t\thead->r.cond_index++;\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tswitch (left) {\n\t\t\t\tcase TOMOYO_ARGV_ENTRY:\n\t\t\t\t\ttomoyo_io_printf(head,\n\t\t\t\t\t\t\t \"exec.argv[%lu]%s=\\\"\",\n\t\t\t\t\t\t\t argv->index, argv->\n\t\t\t\t\t\t\t is_not ? \"!\" : \"\");\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  argv->value->name);\n\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\targv++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_ENVP_ENTRY:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  \"exec.envp[\\\"\");\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  envp->name->name);\n\t\t\t\t\ttomoyo_io_printf(head, \"\\\"]%s=\", envp->\n\t\t\t\t\t\t\t is_not ? \"!\" : \"\");\n\t\t\t\t\tif (envp->value) {\n\t\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\t\ttomoyo_set_string(head, envp->\n\t\t\t\t\t\t\t\t  value->name);\n\t\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t\t  \"NULL\");\n\t\t\t\t\t}\n\t\t\t\t\tenvp++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\ttomoyo_print_number_union_nospace\n\t\t\t\t\t\t(head, numbers_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t       tomoyo_condition_keyword[left]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttomoyo_set_string(head, match ? \"=\" : \"!=\");\n\t\t\t\tswitch (right) {\n\t\t\t\tcase TOMOYO_NAME_UNION:\n\t\t\t\t\ttomoyo_print_name_union_quoted\n\t\t\t\t\t\t(head, names_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\ttomoyo_print_number_union_nospace\n\t\t\t\t\t\t(head, numbers_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t  tomoyo_condition_keyword[right]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thead->r.cond_step++;\n\t\t/* fall through */\n\tcase 2:\n\t\tif (!tomoyo_flush(head))\n\t\t\tbreak;\n\t\thead->r.cond_step++;\n\t\t/* fall through */\n\tcase 3:\n\t\tif (cond->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\t\ttomoyo_io_printf(head, \" grant_log=%s\",\n\t\t\t\t\t tomoyo_yesno(cond->grant_log ==\n\t\t\t\t\t\t      TOMOYO_GRANTLOG_YES));\n\t\ttomoyo_set_lf(head);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_flush",
          "args": [
            "head"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "212-245",
          "snippet": "static bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "ptr->env->name"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_group",
          "args": [
            "head",
            "\"misc env \""
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1342-1351",
          "snippet": "static void tomoyo_set_group(struct tomoyo_io_buffer *head,\n\t\t\t     const char *category)\n{\n\tif (head->type == TOMOYO_EXCEPTIONPOLICY) {\n\t\ttomoyo_print_namespace(head);\n\t\ttomoyo_io_printf(head, \"acl_group %u \",\n\t\t\t\t head->r.acl_group_index);\n\t}\n\ttomoyo_set_string(head, category);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_group(struct tomoyo_io_buffer *head,\n\t\t\t     const char *category)\n{\n\tif (head->type == TOMOYO_EXCEPTIONPOLICY) {\n\t\ttomoyo_print_namespace(head);\n\t\ttomoyo_io_printf(head, \"acl_group %u \",\n\t\t\t\t head->r.acl_group_index);\n\t}\n\ttomoyo_set_string(head, category);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*ptr)",
            "head"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_print_number_union",
          "args": [
            "head",
            "&ptr->flags"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_number_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "470-475",
          "snippet": "static void tomoyo_print_number_union(struct tomoyo_io_buffer *head,\n\t\t\t\t      const struct tomoyo_number_union *ptr)\n{\n\ttomoyo_set_space(head);\n\ttomoyo_print_number_union_nospace(head, ptr);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_print_number_union(struct tomoyo_io_buffer *head,\n\t\t\t\t      const struct tomoyo_number_union *ptr)\n{\n\ttomoyo_set_space(head);\n\ttomoyo_print_number_union_nospace(head, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_print_name_union",
          "args": [
            "head",
            "&ptr->fs_type"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_name_union_quoted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "402-413",
          "snippet": "static void tomoyo_print_name_union_quoted(struct tomoyo_io_buffer *head,\n\t\t\t\t\t   const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t\ttomoyo_set_string(head, ptr->filename->name);\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t}\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_print_name_union_quoted(struct tomoyo_io_buffer *head,\n\t\t\t\t\t   const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t\ttomoyo_set_string(head, ptr->filename->name);\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*ptr)",
            "head"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_set_slash",
          "args": [
            "head"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_slash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "327-330",
          "snippet": "static void tomoyo_set_slash(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"/\");\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_slash(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"/\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_space",
          "args": [
            "head"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "302-305",
          "snippet": "static void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*ptr)",
            "head"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_io_printf",
          "args": [
            "head",
            "\"%s\"",
            "buf"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_io_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "275-293",
          "snippet": "static void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_print_ip",
          "args": [
            "buf",
            "sizeof(buf)",
            "&ptr->address"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "124-132",
          "snippet": "void tomoyo_print_ip(char *buf, const unsigned int size,\n\t\t     const struct tomoyo_ipaddr_union *ptr)\n{\n\tif (ptr->is_ipv6)\n\t\ttomoyo_print_ipv6(buf, size, &ptr->ip[0], &ptr->ip[1]);\n\telse\n\t\ttomoyo_print_ipv4(buf, size, &ptr->ip[0].s6_addr32[0],\n\t\t\t\t  &ptr->ip[1].s6_addr32[0]);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_print_ip(char *buf, const unsigned int size,\n\t\t     const struct tomoyo_ipaddr_union *ptr)\n{\n\tif (ptr->is_ipv6)\n\t\ttomoyo_print_ipv6(buf, size, &ptr->ip[0], &ptr->ip[1]);\n\telse\n\t\ttomoyo_print_ipv4(buf, size, &ptr->ip[0].s6_addr32[0],\n\t\t\t\t  &ptr->ip[1].s6_addr32[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*ptr)",
            "head"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*ptr)",
            "head"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*ptr)",
            "head"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*ptr)",
            "head"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*ptr)",
            "head"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*ptr)",
            "head"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char * const tomoyo_mac_keywords[TOMOYO_MAX_MAC_INDEX\n\t\t\t\t       + TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t/* CONFIG::file group */\n\t[TOMOYO_MAC_FILE_EXECUTE]    = \"execute\",\n\t[TOMOYO_MAC_FILE_OPEN]       = \"open\",\n\t[TOMOYO_MAC_FILE_CREATE]     = \"create\",\n\t[TOMOYO_MAC_FILE_UNLINK]     = \"unlink\",\n\t[TOMOYO_MAC_FILE_GETATTR]    = \"getattr\",\n\t[TOMOYO_MAC_FILE_MKDIR]      = \"mkdir\",\n\t[TOMOYO_MAC_FILE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_MAC_FILE_MKFIFO]     = \"mkfifo\",\n\t[TOMOYO_MAC_FILE_MKSOCK]     = \"mksock\",\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_MAC_FILE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = \"mkblock\",\n\t[TOMOYO_MAC_FILE_MKCHAR]     = \"mkchar\",\n\t[TOMOYO_MAC_FILE_LINK]       = \"link\",\n\t[TOMOYO_MAC_FILE_RENAME]     = \"rename\",\n\t[TOMOYO_MAC_FILE_CHMOD]      = \"chmod\",\n\t[TOMOYO_MAC_FILE_CHOWN]      = \"chown\",\n\t[TOMOYO_MAC_FILE_CHGRP]      = \"chgrp\",\n\t[TOMOYO_MAC_FILE_IOCTL]      = \"ioctl\",\n\t[TOMOYO_MAC_FILE_CHROOT]     = \"chroot\",\n\t[TOMOYO_MAC_FILE_MOUNT]      = \"mount\",\n\t[TOMOYO_MAC_FILE_UMOUNT]     = \"unmount\",\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = \"pivot_root\",\n\t/* CONFIG::network group */\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       = \"inet_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     = \"inet_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    = \"inet_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        = \"inet_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        = \"inet_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          = \"inet_raw_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          = \"inet_raw_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       = \"unix_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     = \"unix_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    = \"unix_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        = \"unix_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        = \"unix_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    = \"unix_seqpacket_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  = \"unix_seqpacket_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = \"unix_seqpacket_connect\",\n\t/* CONFIG::misc group */\n\t[TOMOYO_MAC_ENVIRON] = \"env\",\n\t/* CONFIG group */\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_FILE] = \"file\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_MISC] = \"misc\",\n};\nconst char * const tomoyo_path_keyword[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = \"execute\",\n\t[TOMOYO_TYPE_READ]       = \"read\",\n\t[TOMOYO_TYPE_WRITE]      = \"write\",\n\t[TOMOYO_TYPE_APPEND]     = \"append\",\n\t[TOMOYO_TYPE_UNLINK]     = \"unlink\",\n\t[TOMOYO_TYPE_GETATTR]    = \"getattr\",\n\t[TOMOYO_TYPE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_TYPE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_TYPE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_TYPE_CHROOT]     = \"chroot\",\n\t[TOMOYO_TYPE_UMOUNT]     = \"unmount\",\n};\nconst char * const tomoyo_socket_keyword[TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[TOMOYO_NETWORK_BIND]    = \"bind\",\n\t[TOMOYO_NETWORK_LISTEN]  = \"listen\",\n\t[TOMOYO_NETWORK_CONNECT] = \"connect\",\n\t[TOMOYO_NETWORK_SEND]    = \"send\",\n};\n\nstatic bool tomoyo_print_entry(struct tomoyo_io_buffer *head,\n\t\t\t       struct tomoyo_acl_info *acl)\n{\n\tconst u8 acl_type = acl->type;\n\tbool first = true;\n\tu8 bit;\n\n\tif (head->r.print_cond_part)\n\t\tgoto print_cond_part;\n\tif (acl->is_deleted)\n\t\treturn true;\n\tif (!tomoyo_flush(head))\n\t\treturn false;\n\telse if (acl_type == TOMOYO_TYPE_PATH_ACL) {\n\t\tstruct tomoyo_path_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u16 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (head->r.print_transition_related_only &&\n\t\t\t    bit != TOMOYO_TYPE_EXECUTE)\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_path_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t} else if (acl_type == TOMOYO_TYPE_MANUAL_TASK_ACL) {\n\t\tstruct tomoyo_task_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\ttomoyo_set_group(head, \"task \");\n\t\ttomoyo_set_string(head, \"manual_domain_transition \");\n\t\ttomoyo_set_string(head, ptr->domainname->name);\n\t} else if (head->r.print_transition_related_only) {\n\t\treturn true;\n\t} else if (acl_type == TOMOYO_TYPE_PATH2_ACL) {\n\t\tstruct tomoyo_path2_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH2_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pp2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name1);\n\t\ttomoyo_print_name_union(head, &ptr->name2);\n\t} else if (acl_type == TOMOYO_TYPE_PATH_NUMBER_ACL) {\n\t\tstruct tomoyo_path_number_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_PATH_NUMBER_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pn2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t\ttomoyo_print_number_union(head, &ptr->number);\n\t} else if (acl_type == TOMOYO_TYPE_MKDEV_ACL) {\n\t\tstruct tomoyo_mkdev_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\t\tfor (bit = 0; bit < TOMOYO_MAX_MKDEV_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"file \");\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_mac_keywords\n\t\t\t\t\t  [tomoyo_pnnn2mac[bit]]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t\ttomoyo_print_number_union(head, &ptr->mode);\n\t\ttomoyo_print_number_union(head, &ptr->major);\n\t\ttomoyo_print_number_union(head, &ptr->minor);\n\t} else if (acl_type == TOMOYO_TYPE_INET_ACL) {\n\t\tstruct tomoyo_inet_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_NETWORK_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"network inet \");\n\t\t\t\ttomoyo_set_string(head, tomoyo_proto_keyword\n\t\t\t\t\t\t  [ptr->protocol]);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_socket_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_set_space(head);\n\t\tif (ptr->address.group) {\n\t\t\ttomoyo_set_string(head, \"@\");\n\t\t\ttomoyo_set_string(head, ptr->address.group->group_name\n\t\t\t\t\t  ->name);\n\t\t} else {\n\t\t\tchar buf[128];\n\t\t\ttomoyo_print_ip(buf, sizeof(buf), &ptr->address);\n\t\t\ttomoyo_io_printf(head, \"%s\", buf);\n\t\t}\n\t\ttomoyo_print_number_union(head, &ptr->port);\n\t} else if (acl_type == TOMOYO_TYPE_UNIX_ACL) {\n\t\tstruct tomoyo_unix_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\tconst u8 perm = ptr->perm;\n\n\t\tfor (bit = 0; bit < TOMOYO_MAX_NETWORK_OPERATION; bit++) {\n\t\t\tif (!(perm & (1 << bit)))\n\t\t\t\tcontinue;\n\t\t\tif (first) {\n\t\t\t\ttomoyo_set_group(head, \"network unix \");\n\t\t\t\ttomoyo_set_string(head, tomoyo_proto_keyword\n\t\t\t\t\t\t  [ptr->protocol]);\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\ttomoyo_set_slash(head);\n\t\t\t}\n\t\t\ttomoyo_set_string(head, tomoyo_socket_keyword[bit]);\n\t\t}\n\t\tif (first)\n\t\t\treturn true;\n\t\ttomoyo_print_name_union(head, &ptr->name);\n\t} else if (acl_type == TOMOYO_TYPE_MOUNT_ACL) {\n\t\tstruct tomoyo_mount_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\t\ttomoyo_set_group(head, \"file mount\");\n\t\ttomoyo_print_name_union(head, &ptr->dev_name);\n\t\ttomoyo_print_name_union(head, &ptr->dir_name);\n\t\ttomoyo_print_name_union(head, &ptr->fs_type);\n\t\ttomoyo_print_number_union(head, &ptr->flags);\n\t} else if (acl_type == TOMOYO_TYPE_ENV_ACL) {\n\t\tstruct tomoyo_env_acl *ptr =\n\t\t\tcontainer_of(acl, typeof(*ptr), head);\n\n\t\ttomoyo_set_group(head, \"misc env \");\n\t\ttomoyo_set_string(head, ptr->env->name);\n\t}\n\tif (acl->cond) {\n\t\thead->r.print_cond_part = true;\n\t\thead->r.cond_step = 0;\n\t\tif (!tomoyo_flush(head))\n\t\t\treturn false;\nprint_cond_part:\n\t\tif (!tomoyo_print_condition(head, acl->cond))\n\t\t\treturn false;\n\t\thead->r.print_cond_part = false;\n\t} else {\n\t\ttomoyo_set_lf(head);\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "tomoyo_set_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1342-1351",
    "snippet": "static void tomoyo_set_group(struct tomoyo_io_buffer *head,\n\t\t\t     const char *category)\n{\n\tif (head->type == TOMOYO_EXCEPTIONPOLICY) {\n\t\ttomoyo_print_namespace(head);\n\t\ttomoyo_io_printf(head, \"acl_group %u \",\n\t\t\t\t head->r.acl_group_index);\n\t}\n\ttomoyo_set_string(head, category);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "category"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_io_printf",
          "args": [
            "head",
            "\"acl_group %u \"",
            "head->r.acl_group_index"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_io_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "275-293",
          "snippet": "static void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_print_namespace",
          "args": [
            "head"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "365-374",
          "snippet": "static void tomoyo_print_namespace(struct tomoyo_io_buffer *head)\n{\n\tif (!tomoyo_namespace_enabled)\n\t\treturn;\n\ttomoyo_set_string(head,\n\t\t\t  container_of(head->r.ns,\n\t\t\t\t       struct tomoyo_policy_namespace,\n\t\t\t\t       namespace_list)->name);\n\ttomoyo_set_space(head);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool tomoyo_namespace_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_namespace_enabled;\n\nstatic void tomoyo_print_namespace(struct tomoyo_io_buffer *head)\n{\n\tif (!tomoyo_namespace_enabled)\n\t\treturn;\n\ttomoyo_set_string(head,\n\t\t\t  container_of(head->r.ns,\n\t\t\t\t       struct tomoyo_policy_namespace,\n\t\t\t\t       namespace_list)->name);\n\ttomoyo_set_space(head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_group(struct tomoyo_io_buffer *head,\n\t\t\t     const char *category)\n{\n\tif (head->type == TOMOYO_EXCEPTIONPOLICY) {\n\t\ttomoyo_print_namespace(head);\n\t\ttomoyo_io_printf(head, \"acl_group %u \",\n\t\t\t\t head->r.acl_group_index);\n\t}\n\ttomoyo_set_string(head, category);\n}"
  },
  {
    "function_name": "tomoyo_print_condition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1201-1332",
    "snippet": "static bool tomoyo_print_condition(struct tomoyo_io_buffer *head,\n\t\t\t\t   const struct tomoyo_condition *cond)\n{\n\tswitch (head->r.cond_step) {\n\tcase 0:\n\t\thead->r.cond_index = 0;\n\t\thead->r.cond_step++;\n\t\tif (cond->transit) {\n\t\t\ttomoyo_set_space(head);\n\t\t\ttomoyo_set_string(head, cond->transit->name);\n\t\t}\n\t\t/* fall through */\n\tcase 1:\n\t\t{\n\t\t\tconst u16 condc = cond->condc;\n\t\t\tconst struct tomoyo_condition_element *condp =\n\t\t\t\t(typeof(condp)) (cond + 1);\n\t\t\tconst struct tomoyo_number_union *numbers_p =\n\t\t\t\t(typeof(numbers_p)) (condp + condc);\n\t\t\tconst struct tomoyo_name_union *names_p =\n\t\t\t\t(typeof(names_p))\n\t\t\t\t(numbers_p + cond->numbers_count);\n\t\t\tconst struct tomoyo_argv *argv =\n\t\t\t\t(typeof(argv)) (names_p + cond->names_count);\n\t\t\tconst struct tomoyo_envp *envp =\n\t\t\t\t(typeof(envp)) (argv + cond->argc);\n\t\t\tu16 skip;\n\t\t\tfor (skip = 0; skip < head->r.cond_index; skip++) {\n\t\t\t\tconst u8 left = condp->left;\n\t\t\t\tconst u8 right = condp->right;\n\t\t\t\tcondp++;\n\t\t\t\tswitch (left) {\n\t\t\t\tcase TOMOYO_ARGV_ENTRY:\n\t\t\t\t\targv++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_ENVP_ENTRY:\n\t\t\t\t\tenvp++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\tnumbers_p++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (right) {\n\t\t\t\tcase TOMOYO_NAME_UNION:\n\t\t\t\t\tnames_p++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\tnumbers_p++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (head->r.cond_index < condc) {\n\t\t\t\tconst u8 match = condp->equals;\n\t\t\t\tconst u8 left = condp->left;\n\t\t\t\tconst u8 right = condp->right;\n\t\t\t\tif (!tomoyo_flush(head))\n\t\t\t\t\treturn false;\n\t\t\t\tcondp++;\n\t\t\t\thead->r.cond_index++;\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tswitch (left) {\n\t\t\t\tcase TOMOYO_ARGV_ENTRY:\n\t\t\t\t\ttomoyo_io_printf(head,\n\t\t\t\t\t\t\t \"exec.argv[%lu]%s=\\\"\",\n\t\t\t\t\t\t\t argv->index, argv->\n\t\t\t\t\t\t\t is_not ? \"!\" : \"\");\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  argv->value->name);\n\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\targv++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_ENVP_ENTRY:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  \"exec.envp[\\\"\");\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  envp->name->name);\n\t\t\t\t\ttomoyo_io_printf(head, \"\\\"]%s=\", envp->\n\t\t\t\t\t\t\t is_not ? \"!\" : \"\");\n\t\t\t\t\tif (envp->value) {\n\t\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\t\ttomoyo_set_string(head, envp->\n\t\t\t\t\t\t\t\t  value->name);\n\t\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t\t  \"NULL\");\n\t\t\t\t\t}\n\t\t\t\t\tenvp++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\ttomoyo_print_number_union_nospace\n\t\t\t\t\t\t(head, numbers_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t       tomoyo_condition_keyword[left]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttomoyo_set_string(head, match ? \"=\" : \"!=\");\n\t\t\t\tswitch (right) {\n\t\t\t\tcase TOMOYO_NAME_UNION:\n\t\t\t\t\ttomoyo_print_name_union_quoted\n\t\t\t\t\t\t(head, names_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\ttomoyo_print_number_union_nospace\n\t\t\t\t\t\t(head, numbers_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t  tomoyo_condition_keyword[right]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thead->r.cond_step++;\n\t\t/* fall through */\n\tcase 2:\n\t\tif (!tomoyo_flush(head))\n\t\t\tbreak;\n\t\thead->r.cond_step++;\n\t\t/* fall through */\n\tcase 3:\n\t\tif (cond->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\t\ttomoyo_io_printf(head, \" grant_log=%s\",\n\t\t\t\t\t tomoyo_yesno(cond->grant_log ==\n\t\t\t\t\t\t      TOMOYO_GRANTLOG_YES));\n\t\ttomoyo_set_lf(head);\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const char * const tomoyo_condition_keyword[TOMOYO_MAX_CONDITION_KEYWORD] = {\n\t[TOMOYO_TASK_UID]             = \"task.uid\",\n\t[TOMOYO_TASK_EUID]            = \"task.euid\",\n\t[TOMOYO_TASK_SUID]            = \"task.suid\",\n\t[TOMOYO_TASK_FSUID]           = \"task.fsuid\",\n\t[TOMOYO_TASK_GID]             = \"task.gid\",\n\t[TOMOYO_TASK_EGID]            = \"task.egid\",\n\t[TOMOYO_TASK_SGID]            = \"task.sgid\",\n\t[TOMOYO_TASK_FSGID]           = \"task.fsgid\",\n\t[TOMOYO_TASK_PID]             = \"task.pid\",\n\t[TOMOYO_TASK_PPID]            = \"task.ppid\",\n\t[TOMOYO_EXEC_ARGC]            = \"exec.argc\",\n\t[TOMOYO_EXEC_ENVC]            = \"exec.envc\",\n\t[TOMOYO_TYPE_IS_SOCKET]       = \"socket\",\n\t[TOMOYO_TYPE_IS_SYMLINK]      = \"symlink\",\n\t[TOMOYO_TYPE_IS_FILE]         = \"file\",\n\t[TOMOYO_TYPE_IS_BLOCK_DEV]    = \"block\",\n\t[TOMOYO_TYPE_IS_DIRECTORY]    = \"directory\",\n\t[TOMOYO_TYPE_IS_CHAR_DEV]     = \"char\",\n\t[TOMOYO_TYPE_IS_FIFO]         = \"fifo\",\n\t[TOMOYO_MODE_SETUID]          = \"setuid\",\n\t[TOMOYO_MODE_SETGID]          = \"setgid\",\n\t[TOMOYO_MODE_STICKY]          = \"sticky\",\n\t[TOMOYO_MODE_OWNER_READ]      = \"owner_read\",\n\t[TOMOYO_MODE_OWNER_WRITE]     = \"owner_write\",\n\t[TOMOYO_MODE_OWNER_EXECUTE]   = \"owner_execute\",\n\t[TOMOYO_MODE_GROUP_READ]      = \"group_read\",\n\t[TOMOYO_MODE_GROUP_WRITE]     = \"group_write\",\n\t[TOMOYO_MODE_GROUP_EXECUTE]   = \"group_execute\",\n\t[TOMOYO_MODE_OTHERS_READ]     = \"others_read\",\n\t[TOMOYO_MODE_OTHERS_WRITE]    = \"others_write\",\n\t[TOMOYO_MODE_OTHERS_EXECUTE]  = \"others_execute\",\n\t[TOMOYO_EXEC_REALPATH]        = \"exec.realpath\",\n\t[TOMOYO_SYMLINK_TARGET]       = \"symlink.target\",\n\t[TOMOYO_PATH1_UID]            = \"path1.uid\",\n\t[TOMOYO_PATH1_GID]            = \"path1.gid\",\n\t[TOMOYO_PATH1_INO]            = \"path1.ino\",\n\t[TOMOYO_PATH1_MAJOR]          = \"path1.major\",\n\t[TOMOYO_PATH1_MINOR]          = \"path1.minor\",\n\t[TOMOYO_PATH1_PERM]           = \"path1.perm\",\n\t[TOMOYO_PATH1_TYPE]           = \"path1.type\",\n\t[TOMOYO_PATH1_DEV_MAJOR]      = \"path1.dev_major\",\n\t[TOMOYO_PATH1_DEV_MINOR]      = \"path1.dev_minor\",\n\t[TOMOYO_PATH2_UID]            = \"path2.uid\",\n\t[TOMOYO_PATH2_GID]            = \"path2.gid\",\n\t[TOMOYO_PATH2_INO]            = \"path2.ino\",\n\t[TOMOYO_PATH2_MAJOR]          = \"path2.major\",\n\t[TOMOYO_PATH2_MINOR]          = \"path2.minor\",\n\t[TOMOYO_PATH2_PERM]           = \"path2.perm\",\n\t[TOMOYO_PATH2_TYPE]           = \"path2.type\",\n\t[TOMOYO_PATH2_DEV_MAJOR]      = \"path2.dev_major\",\n\t[TOMOYO_PATH2_DEV_MINOR]      = \"path2.dev_minor\",\n\t[TOMOYO_PATH1_PARENT_UID]     = \"path1.parent.uid\",\n\t[TOMOYO_PATH1_PARENT_GID]     = \"path1.parent.gid\",\n\t[TOMOYO_PATH1_PARENT_INO]     = \"path1.parent.ino\",\n\t[TOMOYO_PATH1_PARENT_PERM]    = \"path1.parent.perm\",\n\t[TOMOYO_PATH2_PARENT_UID]     = \"path2.parent.uid\",\n\t[TOMOYO_PATH2_PARENT_GID]     = \"path2.parent.gid\",\n\t[TOMOYO_PATH2_PARENT_INO]     = \"path2.parent.ino\",\n\t[TOMOYO_PATH2_PARENT_PERM]    = \"path2.parent.perm\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_lf",
          "args": [
            "head"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_lf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "314-318",
          "snippet": "static bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_io_printf",
          "args": [
            "head",
            "\" grant_log=%s\"",
            "tomoyo_yesno(cond->grant_log ==\n\t\t\t\t\t\t      TOMOYO_GRANTLOG_YES)"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_io_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "275-293",
          "snippet": "static void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_yesno",
          "args": [
            "cond->grant_log ==\n\t\t\t\t\t\t      TOMOYO_GRANTLOG_YES"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_yesno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "182-185",
          "snippet": "const char *tomoyo_yesno(const unsigned int value)\n{\n\treturn value ? \"yes\" : \"no\";\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char *tomoyo_yesno(const unsigned int value)\n{\n\treturn value ? \"yes\" : \"no\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_flush",
          "args": [
            "head"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "212-245",
          "snippet": "static bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "tomoyo_condition_keyword[right]"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_print_number_union_nospace",
          "args": [
            "head",
            "numbers_p++"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_number_union_nospace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "423-460",
          "snippet": "static void tomoyo_print_number_union_nospace\n(struct tomoyo_io_buffer *head, const struct tomoyo_number_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\tint i;\n\t\tunsigned long min = ptr->values[0];\n\t\tconst unsigned long max = ptr->values[1];\n\t\tu8 min_type = ptr->value_type[0];\n\t\tconst u8 max_type = ptr->value_type[1];\n\t\tchar buffer[128];\n\t\tbuffer[0] = '\\0';\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tswitch (min_type) {\n\t\t\tcase TOMOYO_VALUE_TYPE_HEXADECIMAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0x%lX\", min);\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_VALUE_TYPE_OCTAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0%lo\", min);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t min);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (min == max && min_type == max_type)\n\t\t\t\tbreak;\n\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"-\");\n\t\t\tmin_type = max_type;\n\t\t\tmin = max;\n\t\t}\n\t\ttomoyo_io_printf(head, \"%s\", buffer);\n\t}\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_print_number_union_nospace\n(struct tomoyo_io_buffer *head, const struct tomoyo_number_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\tint i;\n\t\tunsigned long min = ptr->values[0];\n\t\tconst unsigned long max = ptr->values[1];\n\t\tu8 min_type = ptr->value_type[0];\n\t\tconst u8 max_type = ptr->value_type[1];\n\t\tchar buffer[128];\n\t\tbuffer[0] = '\\0';\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tswitch (min_type) {\n\t\t\tcase TOMOYO_VALUE_TYPE_HEXADECIMAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0x%lX\", min);\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_VALUE_TYPE_OCTAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0%lo\", min);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t min);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (min == max && min_type == max_type)\n\t\t\t\tbreak;\n\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"-\");\n\t\t\tmin_type = max_type;\n\t\t\tmin = max;\n\t\t}\n\t\ttomoyo_io_printf(head, \"%s\", buffer);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_print_name_union_quoted",
          "args": [
            "head",
            "names_p++"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_name_union_quoted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "402-413",
          "snippet": "static void tomoyo_print_name_union_quoted(struct tomoyo_io_buffer *head,\n\t\t\t\t\t   const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t\ttomoyo_set_string(head, ptr->filename->name);\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t}\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_print_name_union_quoted(struct tomoyo_io_buffer *head,\n\t\t\t\t\t   const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t\ttomoyo_set_string(head, ptr->filename->name);\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_space",
          "args": [
            "head"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "302-305",
          "snippet": "static void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "argv + cond->argc"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "envp"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "names_p + cond->names_count"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "argv"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "numbers_p + cond->numbers_count"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "names_p"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "condp + condc"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "numbers_p"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cond + 1"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "condp"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char * const tomoyo_condition_keyword[TOMOYO_MAX_CONDITION_KEYWORD] = {\n\t[TOMOYO_TASK_UID]             = \"task.uid\",\n\t[TOMOYO_TASK_EUID]            = \"task.euid\",\n\t[TOMOYO_TASK_SUID]            = \"task.suid\",\n\t[TOMOYO_TASK_FSUID]           = \"task.fsuid\",\n\t[TOMOYO_TASK_GID]             = \"task.gid\",\n\t[TOMOYO_TASK_EGID]            = \"task.egid\",\n\t[TOMOYO_TASK_SGID]            = \"task.sgid\",\n\t[TOMOYO_TASK_FSGID]           = \"task.fsgid\",\n\t[TOMOYO_TASK_PID]             = \"task.pid\",\n\t[TOMOYO_TASK_PPID]            = \"task.ppid\",\n\t[TOMOYO_EXEC_ARGC]            = \"exec.argc\",\n\t[TOMOYO_EXEC_ENVC]            = \"exec.envc\",\n\t[TOMOYO_TYPE_IS_SOCKET]       = \"socket\",\n\t[TOMOYO_TYPE_IS_SYMLINK]      = \"symlink\",\n\t[TOMOYO_TYPE_IS_FILE]         = \"file\",\n\t[TOMOYO_TYPE_IS_BLOCK_DEV]    = \"block\",\n\t[TOMOYO_TYPE_IS_DIRECTORY]    = \"directory\",\n\t[TOMOYO_TYPE_IS_CHAR_DEV]     = \"char\",\n\t[TOMOYO_TYPE_IS_FIFO]         = \"fifo\",\n\t[TOMOYO_MODE_SETUID]          = \"setuid\",\n\t[TOMOYO_MODE_SETGID]          = \"setgid\",\n\t[TOMOYO_MODE_STICKY]          = \"sticky\",\n\t[TOMOYO_MODE_OWNER_READ]      = \"owner_read\",\n\t[TOMOYO_MODE_OWNER_WRITE]     = \"owner_write\",\n\t[TOMOYO_MODE_OWNER_EXECUTE]   = \"owner_execute\",\n\t[TOMOYO_MODE_GROUP_READ]      = \"group_read\",\n\t[TOMOYO_MODE_GROUP_WRITE]     = \"group_write\",\n\t[TOMOYO_MODE_GROUP_EXECUTE]   = \"group_execute\",\n\t[TOMOYO_MODE_OTHERS_READ]     = \"others_read\",\n\t[TOMOYO_MODE_OTHERS_WRITE]    = \"others_write\",\n\t[TOMOYO_MODE_OTHERS_EXECUTE]  = \"others_execute\",\n\t[TOMOYO_EXEC_REALPATH]        = \"exec.realpath\",\n\t[TOMOYO_SYMLINK_TARGET]       = \"symlink.target\",\n\t[TOMOYO_PATH1_UID]            = \"path1.uid\",\n\t[TOMOYO_PATH1_GID]            = \"path1.gid\",\n\t[TOMOYO_PATH1_INO]            = \"path1.ino\",\n\t[TOMOYO_PATH1_MAJOR]          = \"path1.major\",\n\t[TOMOYO_PATH1_MINOR]          = \"path1.minor\",\n\t[TOMOYO_PATH1_PERM]           = \"path1.perm\",\n\t[TOMOYO_PATH1_TYPE]           = \"path1.type\",\n\t[TOMOYO_PATH1_DEV_MAJOR]      = \"path1.dev_major\",\n\t[TOMOYO_PATH1_DEV_MINOR]      = \"path1.dev_minor\",\n\t[TOMOYO_PATH2_UID]            = \"path2.uid\",\n\t[TOMOYO_PATH2_GID]            = \"path2.gid\",\n\t[TOMOYO_PATH2_INO]            = \"path2.ino\",\n\t[TOMOYO_PATH2_MAJOR]          = \"path2.major\",\n\t[TOMOYO_PATH2_MINOR]          = \"path2.minor\",\n\t[TOMOYO_PATH2_PERM]           = \"path2.perm\",\n\t[TOMOYO_PATH2_TYPE]           = \"path2.type\",\n\t[TOMOYO_PATH2_DEV_MAJOR]      = \"path2.dev_major\",\n\t[TOMOYO_PATH2_DEV_MINOR]      = \"path2.dev_minor\",\n\t[TOMOYO_PATH1_PARENT_UID]     = \"path1.parent.uid\",\n\t[TOMOYO_PATH1_PARENT_GID]     = \"path1.parent.gid\",\n\t[TOMOYO_PATH1_PARENT_INO]     = \"path1.parent.ino\",\n\t[TOMOYO_PATH1_PARENT_PERM]    = \"path1.parent.perm\",\n\t[TOMOYO_PATH2_PARENT_UID]     = \"path2.parent.uid\",\n\t[TOMOYO_PATH2_PARENT_GID]     = \"path2.parent.gid\",\n\t[TOMOYO_PATH2_PARENT_INO]     = \"path2.parent.ino\",\n\t[TOMOYO_PATH2_PARENT_PERM]    = \"path2.parent.perm\",\n};\n\nstatic bool tomoyo_print_condition(struct tomoyo_io_buffer *head,\n\t\t\t\t   const struct tomoyo_condition *cond)\n{\n\tswitch (head->r.cond_step) {\n\tcase 0:\n\t\thead->r.cond_index = 0;\n\t\thead->r.cond_step++;\n\t\tif (cond->transit) {\n\t\t\ttomoyo_set_space(head);\n\t\t\ttomoyo_set_string(head, cond->transit->name);\n\t\t}\n\t\t/* fall through */\n\tcase 1:\n\t\t{\n\t\t\tconst u16 condc = cond->condc;\n\t\t\tconst struct tomoyo_condition_element *condp =\n\t\t\t\t(typeof(condp)) (cond + 1);\n\t\t\tconst struct tomoyo_number_union *numbers_p =\n\t\t\t\t(typeof(numbers_p)) (condp + condc);\n\t\t\tconst struct tomoyo_name_union *names_p =\n\t\t\t\t(typeof(names_p))\n\t\t\t\t(numbers_p + cond->numbers_count);\n\t\t\tconst struct tomoyo_argv *argv =\n\t\t\t\t(typeof(argv)) (names_p + cond->names_count);\n\t\t\tconst struct tomoyo_envp *envp =\n\t\t\t\t(typeof(envp)) (argv + cond->argc);\n\t\t\tu16 skip;\n\t\t\tfor (skip = 0; skip < head->r.cond_index; skip++) {\n\t\t\t\tconst u8 left = condp->left;\n\t\t\t\tconst u8 right = condp->right;\n\t\t\t\tcondp++;\n\t\t\t\tswitch (left) {\n\t\t\t\tcase TOMOYO_ARGV_ENTRY:\n\t\t\t\t\targv++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_ENVP_ENTRY:\n\t\t\t\t\tenvp++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\tnumbers_p++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (right) {\n\t\t\t\tcase TOMOYO_NAME_UNION:\n\t\t\t\t\tnames_p++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\tnumbers_p++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (head->r.cond_index < condc) {\n\t\t\t\tconst u8 match = condp->equals;\n\t\t\t\tconst u8 left = condp->left;\n\t\t\t\tconst u8 right = condp->right;\n\t\t\t\tif (!tomoyo_flush(head))\n\t\t\t\t\treturn false;\n\t\t\t\tcondp++;\n\t\t\t\thead->r.cond_index++;\n\t\t\t\ttomoyo_set_space(head);\n\t\t\t\tswitch (left) {\n\t\t\t\tcase TOMOYO_ARGV_ENTRY:\n\t\t\t\t\ttomoyo_io_printf(head,\n\t\t\t\t\t\t\t \"exec.argv[%lu]%s=\\\"\",\n\t\t\t\t\t\t\t argv->index, argv->\n\t\t\t\t\t\t\t is_not ? \"!\" : \"\");\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  argv->value->name);\n\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\targv++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_ENVP_ENTRY:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  \"exec.envp[\\\"\");\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t  envp->name->name);\n\t\t\t\t\ttomoyo_io_printf(head, \"\\\"]%s=\", envp->\n\t\t\t\t\t\t\t is_not ? \"!\" : \"\");\n\t\t\t\t\tif (envp->value) {\n\t\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\t\ttomoyo_set_string(head, envp->\n\t\t\t\t\t\t\t\t  value->name);\n\t\t\t\t\t\ttomoyo_set_string(head, \"\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t\t\t\t  \"NULL\");\n\t\t\t\t\t}\n\t\t\t\t\tenvp++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\ttomoyo_print_number_union_nospace\n\t\t\t\t\t\t(head, numbers_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t       tomoyo_condition_keyword[left]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttomoyo_set_string(head, match ? \"=\" : \"!=\");\n\t\t\t\tswitch (right) {\n\t\t\t\tcase TOMOYO_NAME_UNION:\n\t\t\t\t\ttomoyo_print_name_union_quoted\n\t\t\t\t\t\t(head, names_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t\ttomoyo_print_number_union_nospace\n\t\t\t\t\t\t(head, numbers_p++);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttomoyo_set_string(head,\n\t\t\t\t\t  tomoyo_condition_keyword[right]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thead->r.cond_step++;\n\t\t/* fall through */\n\tcase 2:\n\t\tif (!tomoyo_flush(head))\n\t\t\tbreak;\n\t\thead->r.cond_step++;\n\t\t/* fall through */\n\tcase 3:\n\t\tif (cond->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\t\ttomoyo_io_printf(head, \" grant_log=%s\",\n\t\t\t\t\t tomoyo_yesno(cond->grant_log ==\n\t\t\t\t\t\t      TOMOYO_GRANTLOG_YES));\n\t\ttomoyo_set_lf(head);\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "tomoyo_write_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1147-1191",
    "snippet": "static int tomoyo_write_domain(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\tstruct tomoyo_policy_namespace *ns;\n\tstruct tomoyo_domain_info *domain = head->w.domain;\n\tconst bool is_delete = head->w.is_delete;\n\tbool is_select = !is_delete && tomoyo_str_starts(&data, \"select \");\n\tunsigned int profile;\n\tif (*data == '<') {\n\t\tint ret = 0;\n\t\tdomain = NULL;\n\t\tif (is_delete)\n\t\t\tret = tomoyo_delete_domain(data);\n\t\telse if (is_select)\n\t\t\tdomain = tomoyo_find_domain(data);\n\t\telse\n\t\t\tdomain = tomoyo_assign_domain(data, false);\n\t\thead->w.domain = domain;\n\t\treturn ret;\n\t}\n\tif (!domain)\n\t\treturn -EINVAL;\n\tns = domain->ns;\n\tif (sscanf(data, \"use_profile %u\", &profile) == 1\n\t    && profile < TOMOYO_MAX_PROFILES) {\n\t\tif (!tomoyo_policy_loaded || ns->profile_ptr[profile])\n\t\t\tdomain->profile = (u8) profile;\n\t\treturn 0;\n\t}\n\tif (sscanf(data, \"use_group %u\\n\", &profile) == 1\n\t    && profile < TOMOYO_MAX_ACL_GROUPS) {\n\t\tif (!is_delete)\n\t\t\tdomain->group = (u8) profile;\n\t\treturn 0;\n\t}\n\tfor (profile = 0; profile < TOMOYO_MAX_DOMAIN_INFO_FLAGS; profile++) {\n\t\tconst char *cp = tomoyo_dif[profile];\n\t\tif (strncmp(data, cp, strlen(cp) - 1))\n\t\t\tcontinue;\n\t\tdomain->flags[profile] = !is_delete;\n\t\treturn 0;\n\t}\n\treturn tomoyo_write_domain2(ns, &domain->acl_info_list, data,\n\t\t\t\t    is_delete);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const char * const tomoyo_dif[TOMOYO_MAX_DOMAIN_INFO_FLAGS] = {\n\t[TOMOYO_DIF_QUOTA_WARNED]      = \"quota_exceeded\\n\",\n\t[TOMOYO_DIF_TRANSITION_FAILED] = \"transition_failed\\n\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_write_domain2",
          "args": [
            "ns",
            "&domain->acl_info_list",
            "data",
            "is_delete"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_write_domain2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1101-1130",
          "snippet": "static int tomoyo_write_domain2(struct tomoyo_policy_namespace *ns,\n\t\t\t\tstruct list_head *list, char *data,\n\t\t\t\tconst bool is_delete)\n{\n\tstruct tomoyo_acl_param param = {\n\t\t.ns = ns,\n\t\t.list = list,\n\t\t.data = data,\n\t\t.is_delete = is_delete,\n\t};\n\tstatic const struct {\n\t\tconst char *keyword;\n\t\tint (*write) (struct tomoyo_acl_param *);\n\t} tomoyo_callback[5] = {\n\t\t{ \"file \", tomoyo_write_file },\n\t\t{ \"network inet \", tomoyo_write_inet_network },\n\t\t{ \"network unix \", tomoyo_write_unix_network },\n\t\t{ \"misc \", tomoyo_write_misc },\n\t\t{ \"task \", tomoyo_write_task },\n\t};\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tomoyo_callback); i++) {\n\t\tif (!tomoyo_str_starts(&param.data,\n\t\t\t\t       tomoyo_callback[i].keyword))\n\t\t\tcontinue;\n\t\treturn tomoyo_callback[i].write(&param);\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_write_domain2(struct tomoyo_policy_namespace *ns,\n\t\t\t\tstruct list_head *list, char *data,\n\t\t\t\tconst bool is_delete)\n{\n\tstruct tomoyo_acl_param param = {\n\t\t.ns = ns,\n\t\t.list = list,\n\t\t.data = data,\n\t\t.is_delete = is_delete,\n\t};\n\tstatic const struct {\n\t\tconst char *keyword;\n\t\tint (*write) (struct tomoyo_acl_param *);\n\t} tomoyo_callback[5] = {\n\t\t{ \"file \", tomoyo_write_file },\n\t\t{ \"network inet \", tomoyo_write_inet_network },\n\t\t{ \"network unix \", tomoyo_write_unix_network },\n\t\t{ \"misc \", tomoyo_write_misc },\n\t\t{ \"task \", tomoyo_write_task },\n\t};\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tomoyo_callback); i++) {\n\t\tif (!tomoyo_str_starts(&param.data,\n\t\t\t\t       tomoyo_callback[i].keyword))\n\t\t\tcontinue;\n\t\treturn tomoyo_callback[i].write(&param);\n\t}\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "data",
            "cp",
            "strlen(cp) - 1"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "data",
            "\"use_group %u\\n\"",
            "&profile"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "data",
            "\"use_profile %u\"",
            "&profile"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_assign_domain",
          "args": [
            "data",
            "false"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_assign_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "507-582",
          "snippet": "struct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,\n\t\t\t\t\t\tconst bool transit)\n{\n\tstruct tomoyo_domain_info e = { };\n\tstruct tomoyo_domain_info *entry = tomoyo_find_domain(domainname);\n\tbool created = false;\n\tif (entry) {\n\t\tif (transit) {\n\t\t\t/*\n\t\t\t * Since namespace is created at runtime, profiles may\n\t\t\t * not be created by the moment the process transits to\n\t\t\t * that domain. Do not perform domain transition if\n\t\t\t * profile for that domain is not yet created.\n\t\t\t */\n\t\t\tif (tomoyo_policy_loaded &&\n\t\t\t    !entry->ns->profile_ptr[entry->profile])\n\t\t\t\treturn NULL;\n\t\t}\n\t\treturn entry;\n\t}\n\t/* Requested domain does not exist. */\n\t/* Don't create requested domain if domainname is invalid. */\n\tif (strlen(domainname) >= TOMOYO_EXEC_TMPSIZE - 10 ||\n\t    !tomoyo_correct_domain(domainname))\n\t\treturn NULL;\n\t/*\n\t * Since definition of profiles and acl_groups may differ across\n\t * namespaces, do not inherit \"use_profile\" and \"use_group\" settings\n\t * by automatically creating requested domain upon domain transition.\n\t */\n\tif (transit && tomoyo_namespace_jump(domainname))\n\t\treturn NULL;\n\te.ns = tomoyo_assign_namespace(domainname);\n\tif (!e.ns)\n\t\treturn NULL;\n\t/*\n\t * \"use_profile\" and \"use_group\" settings for automatically created\n\t * domains are inherited from current domain. These are 0 for manually\n\t * created domains.\n\t */\n\tif (transit) {\n\t\tconst struct tomoyo_domain_info *domain = tomoyo_domain();\n\t\te.profile = domain->profile;\n\t\te.group = domain->group;\n\t}\n\te.domainname = tomoyo_get_name(domainname);\n\tif (!e.domainname)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tentry = tomoyo_find_domain(domainname);\n\tif (!entry) {\n\t\tentry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->acl_info_list);\n\t\t\tlist_add_tail_rcu(&entry->list, &tomoyo_domain_list);\n\t\t\tcreated = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.domainname);\n\tif (entry && transit) {\n\t\tif (created) {\n\t\t\tstruct tomoyo_request_info r;\n\t\t\ttomoyo_init_request_info(&r, entry,\n\t\t\t\t\t\t TOMOYO_MAC_FILE_EXECUTE);\n\t\t\tr.granted = false;\n\t\t\ttomoyo_write_log(&r, \"use_profile %u\\n\",\n\t\t\t\t\t entry->profile);\n\t\t\ttomoyo_write_log(&r, \"use_group %u\\n\", entry->group);\n\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t}\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstruct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,\n\t\t\t\t\t\tconst bool transit)\n{\n\tstruct tomoyo_domain_info e = { };\n\tstruct tomoyo_domain_info *entry = tomoyo_find_domain(domainname);\n\tbool created = false;\n\tif (entry) {\n\t\tif (transit) {\n\t\t\t/*\n\t\t\t * Since namespace is created at runtime, profiles may\n\t\t\t * not be created by the moment the process transits to\n\t\t\t * that domain. Do not perform domain transition if\n\t\t\t * profile for that domain is not yet created.\n\t\t\t */\n\t\t\tif (tomoyo_policy_loaded &&\n\t\t\t    !entry->ns->profile_ptr[entry->profile])\n\t\t\t\treturn NULL;\n\t\t}\n\t\treturn entry;\n\t}\n\t/* Requested domain does not exist. */\n\t/* Don't create requested domain if domainname is invalid. */\n\tif (strlen(domainname) >= TOMOYO_EXEC_TMPSIZE - 10 ||\n\t    !tomoyo_correct_domain(domainname))\n\t\treturn NULL;\n\t/*\n\t * Since definition of profiles and acl_groups may differ across\n\t * namespaces, do not inherit \"use_profile\" and \"use_group\" settings\n\t * by automatically creating requested domain upon domain transition.\n\t */\n\tif (transit && tomoyo_namespace_jump(domainname))\n\t\treturn NULL;\n\te.ns = tomoyo_assign_namespace(domainname);\n\tif (!e.ns)\n\t\treturn NULL;\n\t/*\n\t * \"use_profile\" and \"use_group\" settings for automatically created\n\t * domains are inherited from current domain. These are 0 for manually\n\t * created domains.\n\t */\n\tif (transit) {\n\t\tconst struct tomoyo_domain_info *domain = tomoyo_domain();\n\t\te.profile = domain->profile;\n\t\te.group = domain->group;\n\t}\n\te.domainname = tomoyo_get_name(domainname);\n\tif (!e.domainname)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tentry = tomoyo_find_domain(domainname);\n\tif (!entry) {\n\t\tentry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->acl_info_list);\n\t\t\tlist_add_tail_rcu(&entry->list, &tomoyo_domain_list);\n\t\t\tcreated = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.domainname);\n\tif (entry && transit) {\n\t\tif (created) {\n\t\t\tstruct tomoyo_request_info r;\n\t\t\ttomoyo_init_request_info(&r, entry,\n\t\t\t\t\t\t TOMOYO_MAC_FILE_EXECUTE);\n\t\t\tr.granted = false;\n\t\t\ttomoyo_write_log(&r, \"use_profile %u\\n\",\n\t\t\t\t\t entry->profile);\n\t\t\ttomoyo_write_log(&r, \"use_group %u\\n\", entry->group);\n\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t}\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_find_domain",
          "args": [
            "data"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_find_domain_by_qid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2097-2111",
          "snippet": "static struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial)\n{\n\tstruct tomoyo_query *ptr;\n\tstruct tomoyo_domain_info *domain = NULL;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each_entry(ptr, &tomoyo_query_list, list) {\n\t\tif (ptr->serial != serial)\n\t\t\tcontinue;\n\t\tdomain = ptr->domain;\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\treturn domain;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);",
            "static LIST_HEAD(tomoyo_query_list);",
            "static DEFINE_SPINLOCK(tomoyo_query_list_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);\nstatic LIST_HEAD(tomoyo_query_list);\nstatic DEFINE_SPINLOCK(tomoyo_query_list_lock);\n\nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial)\n{\n\tstruct tomoyo_query *ptr;\n\tstruct tomoyo_domain_info *domain = NULL;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each_entry(ptr, &tomoyo_query_list, list) {\n\t\tif (ptr->serial != serial)\n\t\t\tcontinue;\n\t\tdomain = ptr->domain;\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\treturn domain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_delete_domain",
          "args": [
            "data"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_delete_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1065-1087",
          "snippet": "static int tomoyo_delete_domain(char *domainname)\n{\n\tstruct tomoyo_domain_info *domain;\n\tstruct tomoyo_path_info name;\n\n\tname.name = domainname;\n\ttomoyo_fill_path_info(&name);\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -EINTR;\n\t/* Is there an active domain? */\n\tlist_for_each_entry_rcu(domain, &tomoyo_domain_list, list) {\n\t\t/* Never delete tomoyo_kernel_domain */\n\t\tif (domain == &tomoyo_kernel_domain)\n\t\t\tcontinue;\n\t\tif (domain->is_deleted ||\n\t\t    tomoyo_pathcmp(domain->domainname, &name))\n\t\t\tcontinue;\n\t\tdomain->is_deleted = true;\n\t\tbreak;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_delete_domain(char *domainname)\n{\n\tstruct tomoyo_domain_info *domain;\n\tstruct tomoyo_path_info name;\n\n\tname.name = domainname;\n\ttomoyo_fill_path_info(&name);\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -EINTR;\n\t/* Is there an active domain? */\n\tlist_for_each_entry_rcu(domain, &tomoyo_domain_list, list) {\n\t\t/* Never delete tomoyo_kernel_domain */\n\t\tif (domain == &tomoyo_kernel_domain)\n\t\t\tcontinue;\n\t\tif (domain->is_deleted ||\n\t\t    tomoyo_pathcmp(domain->domainname, &name))\n\t\t\tcontinue;\n\t\tdomain->is_deleted = true;\n\t\tbreak;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_str_starts",
          "args": [
            "&data",
            "\"select \""
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_str_starts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "374-384",
          "snippet": "bool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char * const tomoyo_dif[TOMOYO_MAX_DOMAIN_INFO_FLAGS] = {\n\t[TOMOYO_DIF_QUOTA_WARNED]      = \"quota_exceeded\\n\",\n\t[TOMOYO_DIF_TRANSITION_FAILED] = \"transition_failed\\n\",\n};\n\nstatic int tomoyo_write_domain(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\tstruct tomoyo_policy_namespace *ns;\n\tstruct tomoyo_domain_info *domain = head->w.domain;\n\tconst bool is_delete = head->w.is_delete;\n\tbool is_select = !is_delete && tomoyo_str_starts(&data, \"select \");\n\tunsigned int profile;\n\tif (*data == '<') {\n\t\tint ret = 0;\n\t\tdomain = NULL;\n\t\tif (is_delete)\n\t\t\tret = tomoyo_delete_domain(data);\n\t\telse if (is_select)\n\t\t\tdomain = tomoyo_find_domain(data);\n\t\telse\n\t\t\tdomain = tomoyo_assign_domain(data, false);\n\t\thead->w.domain = domain;\n\t\treturn ret;\n\t}\n\tif (!domain)\n\t\treturn -EINVAL;\n\tns = domain->ns;\n\tif (sscanf(data, \"use_profile %u\", &profile) == 1\n\t    && profile < TOMOYO_MAX_PROFILES) {\n\t\tif (!tomoyo_policy_loaded || ns->profile_ptr[profile])\n\t\t\tdomain->profile = (u8) profile;\n\t\treturn 0;\n\t}\n\tif (sscanf(data, \"use_group %u\\n\", &profile) == 1\n\t    && profile < TOMOYO_MAX_ACL_GROUPS) {\n\t\tif (!is_delete)\n\t\t\tdomain->group = (u8) profile;\n\t\treturn 0;\n\t}\n\tfor (profile = 0; profile < TOMOYO_MAX_DOMAIN_INFO_FLAGS; profile++) {\n\t\tconst char *cp = tomoyo_dif[profile];\n\t\tif (strncmp(data, cp, strlen(cp) - 1))\n\t\t\tcontinue;\n\t\tdomain->flags[profile] = !is_delete;\n\t\treturn 0;\n\t}\n\treturn tomoyo_write_domain2(ns, &domain->acl_info_list, data,\n\t\t\t\t    is_delete);\n}"
  },
  {
    "function_name": "tomoyo_write_domain2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1101-1130",
    "snippet": "static int tomoyo_write_domain2(struct tomoyo_policy_namespace *ns,\n\t\t\t\tstruct list_head *list, char *data,\n\t\t\t\tconst bool is_delete)\n{\n\tstruct tomoyo_acl_param param = {\n\t\t.ns = ns,\n\t\t.list = list,\n\t\t.data = data,\n\t\t.is_delete = is_delete,\n\t};\n\tstatic const struct {\n\t\tconst char *keyword;\n\t\tint (*write) (struct tomoyo_acl_param *);\n\t} tomoyo_callback[5] = {\n\t\t{ \"file \", tomoyo_write_file },\n\t\t{ \"network inet \", tomoyo_write_inet_network },\n\t\t{ \"network unix \", tomoyo_write_unix_network },\n\t\t{ \"misc \", tomoyo_write_misc },\n\t\t{ \"task \", tomoyo_write_task },\n\t};\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tomoyo_callback); i++) {\n\t\tif (!tomoyo_str_starts(&param.data,\n\t\t\t\t       tomoyo_callback[i].keyword))\n\t\t\tcontinue;\n\t\treturn tomoyo_callback[i].write(&param);\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_callback[i].write",
          "args": [
            "&param"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_str_starts",
          "args": [
            "&param.data",
            "tomoyo_callback[i].keyword"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_str_starts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "374-384",
          "snippet": "bool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tomoyo_callback"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_write_domain2(struct tomoyo_policy_namespace *ns,\n\t\t\t\tstruct list_head *list, char *data,\n\t\t\t\tconst bool is_delete)\n{\n\tstruct tomoyo_acl_param param = {\n\t\t.ns = ns,\n\t\t.list = list,\n\t\t.data = data,\n\t\t.is_delete = is_delete,\n\t};\n\tstatic const struct {\n\t\tconst char *keyword;\n\t\tint (*write) (struct tomoyo_acl_param *);\n\t} tomoyo_callback[5] = {\n\t\t{ \"file \", tomoyo_write_file },\n\t\t{ \"network inet \", tomoyo_write_inet_network },\n\t\t{ \"network unix \", tomoyo_write_unix_network },\n\t\t{ \"misc \", tomoyo_write_misc },\n\t\t{ \"task \", tomoyo_write_task },\n\t};\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tomoyo_callback); i++) {\n\t\tif (!tomoyo_str_starts(&param.data,\n\t\t\t\t       tomoyo_callback[i].keyword))\n\t\t\tcontinue;\n\t\treturn tomoyo_callback[i].write(&param);\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "tomoyo_delete_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1065-1087",
    "snippet": "static int tomoyo_delete_domain(char *domainname)\n{\n\tstruct tomoyo_domain_info *domain;\n\tstruct tomoyo_path_info name;\n\n\tname.name = domainname;\n\ttomoyo_fill_path_info(&name);\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -EINTR;\n\t/* Is there an active domain? */\n\tlist_for_each_entry_rcu(domain, &tomoyo_domain_list, list) {\n\t\t/* Never delete tomoyo_kernel_domain */\n\t\tif (domain == &tomoyo_kernel_domain)\n\t\t\tcontinue;\n\t\tif (domain->is_deleted ||\n\t\t    tomoyo_pathcmp(domain->domainname, &name))\n\t\t\tcontinue;\n\t\tdomain->is_deleted = true;\n\t\tbreak;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_pathcmp",
          "args": [
            "domain->domainname",
            "&name"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_pathcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1151-1155",
          "snippet": "static inline bool tomoyo_pathcmp(const struct tomoyo_path_info *a,\n\t\t\t\t  const struct tomoyo_path_info *b)\n{\n\treturn a->hash != b->hash || strcmp(a->name, b->name);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline bool tomoyo_pathcmp(const struct tomoyo_path_info *a,\n\t\t\t\t  const struct tomoyo_path_info *b)\n{\n\treturn a->hash != b->hash || strcmp(a->name, b->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "domain",
            "&tomoyo_domain_list",
            "list"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_fill_path_info",
          "args": [
            "&name"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_fill_path_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "643-652",
          "snippet": "void tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_delete_domain(char *domainname)\n{\n\tstruct tomoyo_domain_info *domain;\n\tstruct tomoyo_path_info name;\n\n\tname.name = domainname;\n\ttomoyo_fill_path_info(&name);\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -EINTR;\n\t/* Is there an active domain? */\n\tlist_for_each_entry_rcu(domain, &tomoyo_domain_list, list) {\n\t\t/* Never delete tomoyo_kernel_domain */\n\t\tif (domain == &tomoyo_kernel_domain)\n\t\t\tcontinue;\n\t\tif (domain->is_deleted ||\n\t\t    tomoyo_pathcmp(domain->domainname, &name))\n\t\t\tcontinue;\n\t\tdomain->is_deleted = true;\n\t\tbreak;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_write_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1039-1054",
    "snippet": "static int tomoyo_write_task(struct tomoyo_acl_param *param)\n{\n\tint error = -EINVAL;\n\tif (tomoyo_str_starts(&param->data, \"manual_domain_transition \")) {\n\t\tstruct tomoyo_task_acl e = {\n\t\t\t.head.type = TOMOYO_TYPE_MANUAL_TASK_ACL,\n\t\t\t.domainname = tomoyo_get_domainname(param),\n\t\t};\n\t\tif (e.domainname)\n\t\t\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t\t\t     tomoyo_same_task_acl,\n\t\t\t\t\t\t     NULL);\n\t\ttomoyo_put_name(e.domainname);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "e.domainname"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_update_domain",
          "args": [
            "&e.head",
            "sizeof(e)",
            "param",
            "tomoyo_same_task_acl",
            "NULL"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_update_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "91-147",
          "snippet": "int tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_info\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_info\n\t\t\t\t\t\t  *),\n\t\t\t bool (*merge_duplicate) (struct tomoyo_acl_info *,\n\t\t\t\t\t\t  struct tomoyo_acl_info *,\n\t\t\t\t\t\t  const bool))\n{\n\tconst bool is_delete = param->is_delete;\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_info *entry;\n\tstruct list_head * const list = param->list;\n\n\tif (param->data[0]) {\n\t\tnew_entry->cond = tomoyo_get_condition(param);\n\t\tif (!new_entry->cond)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Domain transition preference is allowed for only\n\t\t * \"file execute\" entries.\n\t\t */\n\t\tif (new_entry->cond->transit &&\n\t\t    !(new_entry->type == TOMOYO_TYPE_PATH_ACL &&\n\t\t      container_of(new_entry, struct tomoyo_path_acl, head)\n\t\t      ->perm == 1 << TOMOYO_TYPE_EXECUTE))\n\t\t\tgoto out;\n\t}\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!tomoyo_same_acl_head(entry, new_entry) ||\n\t\t    !check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tif (merge_duplicate)\n\t\t\tentry->is_deleted = merge_duplicate(entry, new_entry,\n\t\t\t\t\t\t\t    is_delete);\n\t\telse\n\t\t\tentry->is_deleted = is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_condition(new_entry->cond);\n\treturn error;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_info\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_info\n\t\t\t\t\t\t  *),\n\t\t\t bool (*merge_duplicate) (struct tomoyo_acl_info *,\n\t\t\t\t\t\t  struct tomoyo_acl_info *,\n\t\t\t\t\t\t  const bool))\n{\n\tconst bool is_delete = param->is_delete;\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_info *entry;\n\tstruct list_head * const list = param->list;\n\n\tif (param->data[0]) {\n\t\tnew_entry->cond = tomoyo_get_condition(param);\n\t\tif (!new_entry->cond)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Domain transition preference is allowed for only\n\t\t * \"file execute\" entries.\n\t\t */\n\t\tif (new_entry->cond->transit &&\n\t\t    !(new_entry->type == TOMOYO_TYPE_PATH_ACL &&\n\t\t      container_of(new_entry, struct tomoyo_path_acl, head)\n\t\t      ->perm == 1 << TOMOYO_TYPE_EXECUTE))\n\t\t\tgoto out;\n\t}\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!tomoyo_same_acl_head(entry, new_entry) ||\n\t\t    !check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tif (merge_duplicate)\n\t\t\tentry->is_deleted = merge_duplicate(entry, new_entry,\n\t\t\t\t\t\t\t    is_delete);\n\t\telse\n\t\t\tentry->is_deleted = is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_condition(new_entry->cond);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_get_domainname",
          "args": [
            "param"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_domainname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "150-166",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_domainname\n(struct tomoyo_acl_param *param)\n{\n\tchar *start = param->data;\n\tchar *pos = start;\n\twhile (*pos) {\n\t\tif (*pos++ != ' ' || *pos++ == '/')\n\t\t\tcontinue;\n\t\tpos -= 2;\n\t\t*pos++ = '\\0';\n\t\tbreak;\n\t}\n\tparam->data = pos;\n\tif (tomoyo_correct_domain(start))\n\t\treturn tomoyo_get_name(start);\n\treturn NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nconst struct tomoyo_path_info *tomoyo_get_domainname\n(struct tomoyo_acl_param *param)\n{\n\tchar *start = param->data;\n\tchar *pos = start;\n\twhile (*pos) {\n\t\tif (*pos++ != ' ' || *pos++ == '/')\n\t\t\tcontinue;\n\t\tpos -= 2;\n\t\t*pos++ = '\\0';\n\t\tbreak;\n\t}\n\tparam->data = pos;\n\tif (tomoyo_correct_domain(start))\n\t\treturn tomoyo_get_name(start);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_str_starts",
          "args": [
            "&param->data",
            "\"manual_domain_transition \""
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_str_starts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "374-384",
          "snippet": "bool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_write_task(struct tomoyo_acl_param *param)\n{\n\tint error = -EINVAL;\n\tif (tomoyo_str_starts(&param->data, \"manual_domain_transition \")) {\n\t\tstruct tomoyo_task_acl e = {\n\t\t\t.head.type = TOMOYO_TYPE_MANUAL_TASK_ACL,\n\t\t\t.domainname = tomoyo_get_domainname(param),\n\t\t};\n\t\tif (e.domainname)\n\t\t\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t\t\t     tomoyo_same_task_acl,\n\t\t\t\t\t\t     NULL);\n\t\ttomoyo_put_name(e.domainname);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_same_task_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "1022-1028",
    "snippet": "static bool tomoyo_same_task_acl(const struct tomoyo_acl_info *a,\n\t\t\t      const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_task_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_task_acl *p2 = container_of(b, typeof(*p2), head);\n\treturn p1->domainname == p2->domainname;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "typeof(*p2)",
            "head"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p2"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "typeof(*p1)",
            "head"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p1"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_same_task_acl(const struct tomoyo_acl_info *a,\n\t\t\t      const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_task_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_task_acl *p2 = container_of(b, typeof(*p2), head);\n\treturn p1->domainname == p2->domainname;\n}"
  },
  {
    "function_name": "tomoyo_select_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "971-1012",
    "snippet": "static bool tomoyo_select_domain(struct tomoyo_io_buffer *head,\n\t\t\t\t const char *data)\n{\n\tunsigned int pid;\n\tstruct tomoyo_domain_info *domain = NULL;\n\tbool global_pid = false;\n\tif (strncmp(data, \"select \", 7))\n\t\treturn false;\n\tdata += 7;\n\tif (sscanf(data, \"pid=%u\", &pid) == 1 ||\n\t    (global_pid = true, sscanf(data, \"global-pid=%u\", &pid) == 1)) {\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tif (global_pid)\n\t\t\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\t\telse\n\t\t\tp = find_task_by_vpid(pid);\n\t\tif (p)\n\t\t\tdomain = tomoyo_real_domain(p);\n\t\trcu_read_unlock();\n\t} else if (!strncmp(data, \"domain=\", 7)) {\n\t\tif (tomoyo_domain_def(data + 7))\n\t\t\tdomain = tomoyo_find_domain(data + 7);\n\t} else if (sscanf(data, \"Q=%u\", &pid) == 1) {\n\t\tdomain = tomoyo_find_domain_by_qid(pid);\n\t} else\n\t\treturn false;\n\thead->w.domain = domain;\n\t/* Accessing read_buf is safe because head->io_sem is held. */\n\tif (!head->read_buf)\n\t\treturn true; /* Do nothing if open(O_WRONLY). */\n\tmemset(&head->r, 0, sizeof(head->r));\n\thead->r.print_this_domain_only = true;\n\tif (domain)\n\t\thead->r.domain = &domain->list;\n\telse\n\t\thead->r.eof = 1;\n\ttomoyo_io_printf(head, \"# select %s\\n\", data);\n\tif (domain && domain->is_deleted)\n\t\ttomoyo_io_printf(head, \"# This is a deleted domain.\\n\");\n\treturn true;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_io_printf",
          "args": [
            "head",
            "\"# This is a deleted domain.\\n\""
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_io_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "275-293",
          "snippet": "static void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&head->r",
            "0",
            "sizeof(head->r)"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_find_domain_by_qid",
          "args": [
            "pid"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_find_domain_by_qid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2097-2111",
          "snippet": "static struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial)\n{\n\tstruct tomoyo_query *ptr;\n\tstruct tomoyo_domain_info *domain = NULL;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each_entry(ptr, &tomoyo_query_list, list) {\n\t\tif (ptr->serial != serial)\n\t\t\tcontinue;\n\t\tdomain = ptr->domain;\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\treturn domain;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);",
            "static LIST_HEAD(tomoyo_query_list);",
            "static DEFINE_SPINLOCK(tomoyo_query_list_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);\nstatic LIST_HEAD(tomoyo_query_list);\nstatic DEFINE_SPINLOCK(tomoyo_query_list_lock);\n\nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial)\n{\n\tstruct tomoyo_query *ptr;\n\tstruct tomoyo_domain_info *domain = NULL;\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_for_each_entry(ptr, &tomoyo_query_list, list) {\n\t\tif (ptr->serial != serial)\n\t\t\tcontinue;\n\t\tdomain = ptr->domain;\n\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\treturn domain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "data",
            "\"Q=%u\"",
            "&pid"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_domain_def",
          "args": [
            "data + 7"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_domain_def",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "553-568",
          "snippet": "bool tomoyo_domain_def(const unsigned char *buffer)\n{\n\tconst unsigned char *cp;\n\tint len;\n\tif (*buffer != '<')\n\t\treturn false;\n\tcp = strchr(buffer, ' ');\n\tif (!cp)\n\t\tlen = strlen(buffer);\n\telse\n\t\tlen = cp - buffer;\n\tif (buffer[len - 1] != '>' ||\n\t    !tomoyo_correct_word2(buffer + 1, len - 2))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_domain_def(const unsigned char *buffer)\n{\n\tconst unsigned char *cp;\n\tint len;\n\tif (*buffer != '<')\n\t\treturn false;\n\tcp = strchr(buffer, ' ');\n\tif (!cp)\n\t\tlen = strlen(buffer);\n\telse\n\t\tlen = cp - buffer;\n\tif (buffer[len - 1] != '>' ||\n\t    !tomoyo_correct_word2(buffer + 1, len - 2))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "data",
            "\"domain=\"",
            "7"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_real_domain",
          "args": [
            "p"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_real_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1216-1220",
          "snippet": "static inline struct tomoyo_domain_info *tomoyo_real_domain(struct task_struct\n\t\t\t\t\t\t\t    *task)\n{\n\treturn task_cred_xxx(task, security);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline struct tomoyo_domain_info *tomoyo_real_domain(struct task_struct\n\t\t\t\t\t\t\t    *task)\n{\n\treturn task_cred_xxx(task, security);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_pid_ns",
          "args": [
            "pid",
            "&init_pid_ns"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "data",
            "\"global-pid=%u\"",
            "&pid"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "data",
            "\"pid=%u\"",
            "&pid"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "data",
            "\"select \"",
            "7"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_select_domain(struct tomoyo_io_buffer *head,\n\t\t\t\t const char *data)\n{\n\tunsigned int pid;\n\tstruct tomoyo_domain_info *domain = NULL;\n\tbool global_pid = false;\n\tif (strncmp(data, \"select \", 7))\n\t\treturn false;\n\tdata += 7;\n\tif (sscanf(data, \"pid=%u\", &pid) == 1 ||\n\t    (global_pid = true, sscanf(data, \"global-pid=%u\", &pid) == 1)) {\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tif (global_pid)\n\t\t\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\t\telse\n\t\t\tp = find_task_by_vpid(pid);\n\t\tif (p)\n\t\t\tdomain = tomoyo_real_domain(p);\n\t\trcu_read_unlock();\n\t} else if (!strncmp(data, \"domain=\", 7)) {\n\t\tif (tomoyo_domain_def(data + 7))\n\t\t\tdomain = tomoyo_find_domain(data + 7);\n\t} else if (sscanf(data, \"Q=%u\", &pid) == 1) {\n\t\tdomain = tomoyo_find_domain_by_qid(pid);\n\t} else\n\t\treturn false;\n\thead->w.domain = domain;\n\t/* Accessing read_buf is safe because head->io_sem is held. */\n\tif (!head->read_buf)\n\t\treturn true; /* Do nothing if open(O_WRONLY). */\n\tmemset(&head->r, 0, sizeof(head->r));\n\thead->r.print_this_domain_only = true;\n\tif (domain)\n\t\thead->r.domain = &domain->list;\n\telse\n\t\thead->r.eof = 1;\n\ttomoyo_io_printf(head, \"# select %s\\n\", data);\n\tif (domain && domain->is_deleted)\n\t\ttomoyo_io_printf(head, \"# This is a deleted domain.\\n\");\n\treturn true;\n}"
  },
  {
    "function_name": "tomoyo_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "919-956",
    "snippet": "static bool tomoyo_manager(void)\n{\n\tstruct tomoyo_manager *ptr;\n\tconst char *exe;\n\tconst struct task_struct *task = current;\n\tconst struct tomoyo_path_info *domainname = tomoyo_domain()->domainname;\n\tbool found = false;\n\n\tif (!tomoyo_policy_loaded)\n\t\treturn true;\n\tif (!tomoyo_manage_by_non_root &&\n\t    (!uid_eq(task->cred->uid,  GLOBAL_ROOT_UID) ||\n\t     !uid_eq(task->cred->euid, GLOBAL_ROOT_UID)))\n\t\treturn false;\n\texe = tomoyo_get_exe();\n\tif (!exe)\n\t\treturn false;\n\tlist_for_each_entry_rcu(ptr, &tomoyo_kernel_namespace.\n\t\t\t\tpolicy_list[TOMOYO_ID_MANAGER], head.list) {\n\t\tif (!ptr->head.is_deleted &&\n\t\t    (!tomoyo_pathcmp(domainname, ptr->manager) ||\n\t\t     !strcmp(exe, ptr->manager->name))) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) { /* Reduce error messages. */\n\t\tstatic pid_t last_pid;\n\t\tconst pid_t pid = current->pid;\n\t\tif (last_pid != pid) {\n\t\t\tprintk(KERN_WARNING \"%s ( %s ) is not permitted to \"\n\t\t\t       \"update policies.\\n\", domainname->name, exe);\n\t\t\tlast_pid = pid;\n\t\t}\n\t}\n\tkfree(exe);\n\treturn found;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool tomoyo_manage_by_non_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "exe"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s ( %s ) is not permitted to \"\n\t\t\t       \"update policies.\\n\"",
            "domainname->name",
            "exe"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "exe",
            "ptr->manager->name"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_pathcmp",
          "args": [
            "domainname",
            "ptr->manager"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_pathcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1151-1155",
          "snippet": "static inline bool tomoyo_pathcmp(const struct tomoyo_path_info *a,\n\t\t\t\t  const struct tomoyo_path_info *b)\n{\n\treturn a->hash != b->hash || strcmp(a->name, b->name);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline bool tomoyo_pathcmp(const struct tomoyo_path_info *a,\n\t\t\t\t  const struct tomoyo_path_info *b)\n{\n\treturn a->hash != b->hash || strcmp(a->name, b->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "ptr",
            "&tomoyo_kernel_namespace.\n\t\t\t\tpolicy_list[TOMOYO_ID_MANAGER]",
            "head.list"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_exe",
          "args": [],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_exe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "931-946",
          "snippet": "const char *tomoyo_get_exe(void)\n{\n\tstruct file *exe_file;\n\tconst char *cp;\n\tstruct mm_struct *mm = current->mm;\n\n\tif (!mm)\n\t\treturn NULL;\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\treturn NULL;\n\n\tcp = tomoyo_realpath_from_path(&exe_file->f_path);\n\tfput(exe_file);\n\treturn cp;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nconst char *tomoyo_get_exe(void)\n{\n\tstruct file *exe_file;\n\tconst char *cp;\n\tstruct mm_struct *mm = current->mm;\n\n\tif (!mm)\n\t\treturn NULL;\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\treturn NULL;\n\n\tcp = tomoyo_realpath_from_path(&exe_file->f_path);\n\tfput(exe_file);\n\treturn cp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "task->cred->euid",
            "GLOBAL_ROOT_UID"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "task->cred->uid",
            "GLOBAL_ROOT_UID"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_domain",
          "args": [],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1204-1207",
          "snippet": "static inline struct tomoyo_domain_info *tomoyo_domain(void)\n{\n\treturn current_cred()->security;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline struct tomoyo_domain_info *tomoyo_domain(void)\n{\n\treturn current_cred()->security;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_manage_by_non_root;\n\nstatic bool tomoyo_manager(void)\n{\n\tstruct tomoyo_manager *ptr;\n\tconst char *exe;\n\tconst struct task_struct *task = current;\n\tconst struct tomoyo_path_info *domainname = tomoyo_domain()->domainname;\n\tbool found = false;\n\n\tif (!tomoyo_policy_loaded)\n\t\treturn true;\n\tif (!tomoyo_manage_by_non_root &&\n\t    (!uid_eq(task->cred->uid,  GLOBAL_ROOT_UID) ||\n\t     !uid_eq(task->cred->euid, GLOBAL_ROOT_UID)))\n\t\treturn false;\n\texe = tomoyo_get_exe();\n\tif (!exe)\n\t\treturn false;\n\tlist_for_each_entry_rcu(ptr, &tomoyo_kernel_namespace.\n\t\t\t\tpolicy_list[TOMOYO_ID_MANAGER], head.list) {\n\t\tif (!ptr->head.is_deleted &&\n\t\t    (!tomoyo_pathcmp(domainname, ptr->manager) ||\n\t\t     !strcmp(exe, ptr->manager->name))) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) { /* Reduce error messages. */\n\t\tstatic pid_t last_pid;\n\t\tconst pid_t pid = current->pid;\n\t\tif (last_pid != pid) {\n\t\t\tprintk(KERN_WARNING \"%s ( %s ) is not permitted to \"\n\t\t\t       \"update policies.\\n\", domainname->name, exe);\n\t\t\tlast_pid = pid;\n\t\t}\n\t}\n\tkfree(exe);\n\treturn found;\n}"
  },
  {
    "function_name": "tomoyo_read_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "893-909",
    "snippet": "static void tomoyo_read_manager(struct tomoyo_io_buffer *head)\n{\n\tif (head->r.eof)\n\t\treturn;\n\tlist_for_each_cookie(head->r.acl, &tomoyo_kernel_namespace.\n\t\t\t     policy_list[TOMOYO_ID_MANAGER]) {\n\t\tstruct tomoyo_manager *ptr =\n\t\t\tlist_entry(head->r.acl, typeof(*ptr), head.list);\n\t\tif (ptr->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (!tomoyo_flush(head))\n\t\t\treturn;\n\t\ttomoyo_set_string(head, ptr->manager->name);\n\t\ttomoyo_set_lf(head);\n\t}\n\thead->r.eof = true;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_lf",
          "args": [
            "head"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_lf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "314-318",
          "snippet": "static bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "ptr->manager->name"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_flush",
          "args": [
            "head"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "212-245",
          "snippet": "static bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->r.acl",
            "typeof(*ptr)",
            "head.list"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_cookie",
          "args": [
            "head->r.acl",
            "&tomoyo_kernel_namespace.\n\t\t\t     policy_list[TOMOYO_ID_MANAGER]"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_read_manager(struct tomoyo_io_buffer *head)\n{\n\tif (head->r.eof)\n\t\treturn;\n\tlist_for_each_cookie(head->r.acl, &tomoyo_kernel_namespace.\n\t\t\t     policy_list[TOMOYO_ID_MANAGER]) {\n\t\tstruct tomoyo_manager *ptr =\n\t\t\tlist_entry(head->r.acl, typeof(*ptr), head.list);\n\t\tif (ptr->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (!tomoyo_flush(head))\n\t\t\treturn;\n\t\ttomoyo_set_string(head, ptr->manager->name);\n\t\ttomoyo_set_lf(head);\n\t}\n\thead->r.eof = true;\n}"
  },
  {
    "function_name": "tomoyo_write_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "875-884",
    "snippet": "static int tomoyo_write_manager(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\n\tif (!strcmp(data, \"manage_by_non_root\")) {\n\t\ttomoyo_manage_by_non_root = !head->w.is_delete;\n\t\treturn 0;\n\t}\n\treturn tomoyo_update_manager_entry(data, head->w.is_delete);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool tomoyo_manage_by_non_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_update_manager_entry",
          "args": [
            "data",
            "head->w.is_delete"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_update_manager_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "843-864",
          "snippet": "static int tomoyo_update_manager_entry(const char *manager,\n\t\t\t\t       const bool is_delete)\n{\n\tstruct tomoyo_manager e = { };\n\tstruct tomoyo_acl_param param = {\n\t\t/* .ns = &tomoyo_kernel_namespace, */\n\t\t.is_delete = is_delete,\n\t\t.list = &tomoyo_kernel_namespace.\n\t\tpolicy_list[TOMOYO_ID_MANAGER],\n\t};\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tif (!tomoyo_correct_domain(manager) &&\n\t    !tomoyo_correct_word(manager))\n\t\treturn -EINVAL;\n\te.manager = tomoyo_get_name(manager);\n\tif (e.manager) {\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), &param,\n\t\t\t\t\t     tomoyo_same_manager);\n\t\ttomoyo_put_name(e.manager);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_update_manager_entry(const char *manager,\n\t\t\t\t       const bool is_delete)\n{\n\tstruct tomoyo_manager e = { };\n\tstruct tomoyo_acl_param param = {\n\t\t/* .ns = &tomoyo_kernel_namespace, */\n\t\t.is_delete = is_delete,\n\t\t.list = &tomoyo_kernel_namespace.\n\t\tpolicy_list[TOMOYO_ID_MANAGER],\n\t};\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tif (!tomoyo_correct_domain(manager) &&\n\t    !tomoyo_correct_word(manager))\n\t\treturn -EINVAL;\n\te.manager = tomoyo_get_name(manager);\n\tif (e.manager) {\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), &param,\n\t\t\t\t\t     tomoyo_same_manager);\n\t\ttomoyo_put_name(e.manager);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data",
            "\"manage_by_non_root\""
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_manage_by_non_root;\n\nstatic int tomoyo_write_manager(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\n\tif (!strcmp(data, \"manage_by_non_root\")) {\n\t\ttomoyo_manage_by_non_root = !head->w.is_delete;\n\t\treturn 0;\n\t}\n\treturn tomoyo_update_manager_entry(data, head->w.is_delete);\n}"
  },
  {
    "function_name": "tomoyo_update_manager_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "843-864",
    "snippet": "static int tomoyo_update_manager_entry(const char *manager,\n\t\t\t\t       const bool is_delete)\n{\n\tstruct tomoyo_manager e = { };\n\tstruct tomoyo_acl_param param = {\n\t\t/* .ns = &tomoyo_kernel_namespace, */\n\t\t.is_delete = is_delete,\n\t\t.list = &tomoyo_kernel_namespace.\n\t\tpolicy_list[TOMOYO_ID_MANAGER],\n\t};\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tif (!tomoyo_correct_domain(manager) &&\n\t    !tomoyo_correct_word(manager))\n\t\treturn -EINVAL;\n\te.manager = tomoyo_get_name(manager);\n\tif (e.manager) {\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), &param,\n\t\t\t\t\t     tomoyo_same_manager);\n\t\ttomoyo_put_name(e.manager);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "e.manager"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_update_policy",
          "args": [
            "&e.head",
            "sizeof(e)",
            "&param",
            "tomoyo_same_manager"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_update_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "31-62",
          "snippet": "int tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_head\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_head\n\t\t\t\t\t\t  *))\n{\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_head *entry;\n\tstruct list_head *list = param->list;\n\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -ENOMEM;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tentry->is_deleted = param->is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !param->is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn error;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_head\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_head\n\t\t\t\t\t\t  *))\n{\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_head *entry;\n\tstruct list_head *list = param->list;\n\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -ENOMEM;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tentry->is_deleted = param->is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !param->is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_get_name",
          "args": [
            "manager"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "148-183",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_correct_word",
          "args": [
            "manager"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_correct_word",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "502-505",
          "snippet": "bool tomoyo_correct_word(const char *string)\n{\n\treturn tomoyo_correct_word2(string, strlen(string));\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_correct_word(const char *string)\n{\n\treturn tomoyo_correct_word2(string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_correct_domain",
          "args": [
            "manager"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_correct_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "527-544",
          "snippet": "bool tomoyo_correct_domain(const unsigned char *domainname)\n{\n\tif (!domainname || !tomoyo_domain_def(domainname))\n\t\treturn false;\n\tdomainname = strchr(domainname, ' ');\n\tif (!domainname++)\n\t\treturn true;\n\twhile (1) {\n\t\tconst unsigned char *cp = strchr(domainname, ' ');\n\t\tif (!cp)\n\t\t\tbreak;\n\t\tif (*domainname != '/' ||\n\t\t    !tomoyo_correct_word2(domainname, cp - domainname))\n\t\t\treturn false;\n\t\tdomainname = cp + 1;\n\t}\n\treturn tomoyo_correct_path(domainname);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_correct_domain(const unsigned char *domainname)\n{\n\tif (!domainname || !tomoyo_domain_def(domainname))\n\t\treturn false;\n\tdomainname = strchr(domainname, ' ');\n\tif (!domainname++)\n\t\treturn true;\n\twhile (1) {\n\t\tconst unsigned char *cp = strchr(domainname, ' ');\n\t\tif (!cp)\n\t\t\tbreak;\n\t\tif (*domainname != '/' ||\n\t\t    !tomoyo_correct_word2(domainname, cp - domainname))\n\t\t\treturn false;\n\t\tdomainname = cp + 1;\n\t}\n\treturn tomoyo_correct_path(domainname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic int tomoyo_update_manager_entry(const char *manager,\n\t\t\t\t       const bool is_delete)\n{\n\tstruct tomoyo_manager e = { };\n\tstruct tomoyo_acl_param param = {\n\t\t/* .ns = &tomoyo_kernel_namespace, */\n\t\t.is_delete = is_delete,\n\t\t.list = &tomoyo_kernel_namespace.\n\t\tpolicy_list[TOMOYO_ID_MANAGER],\n\t};\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tif (!tomoyo_correct_domain(manager) &&\n\t    !tomoyo_correct_word(manager))\n\t\treturn -EINVAL;\n\te.manager = tomoyo_get_name(manager);\n\tif (e.manager) {\n\t\terror = tomoyo_update_policy(&e.head, sizeof(e), &param,\n\t\t\t\t\t     tomoyo_same_manager);\n\t\ttomoyo_put_name(e.manager);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_same_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "826-831",
    "snippet": "static bool tomoyo_same_manager(const struct tomoyo_acl_head *a,\n\t\t\t\tconst struct tomoyo_acl_head *b)\n{\n\treturn container_of(a, struct tomoyo_manager, head)->manager ==\n\t\tcontainer_of(b, struct tomoyo_manager, head)->manager;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "structtomoyo_manager",
            "head"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "structtomoyo_manager",
            "head"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_same_manager(const struct tomoyo_acl_head *a,\n\t\t\t\tconst struct tomoyo_acl_head *b)\n{\n\treturn container_of(a, struct tomoyo_manager, head)->manager ==\n\t\tcontainer_of(b, struct tomoyo_manager, head)->manager;\n}"
  },
  {
    "function_name": "tomoyo_read_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "729-816",
    "snippet": "static void tomoyo_read_profile(struct tomoyo_io_buffer *head)\n{\n\tu8 index;\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tconst struct tomoyo_profile *profile;\n\tif (head->r.eof)\n\t\treturn;\n next:\n\tindex = head->r.index;\n\tprofile = ns->profile_ptr[index];\n\tswitch (head->r.step) {\n\tcase 0:\n\t\ttomoyo_print_namespace(head);\n\t\ttomoyo_io_printf(head, \"PROFILE_VERSION=%u\\n\",\n\t\t\t\t ns->profile_version);\n\t\thead->r.step++;\n\t\tbreak;\n\tcase 1:\n\t\tfor ( ; head->r.index < TOMOYO_MAX_PROFILES;\n\t\t      head->r.index++)\n\t\t\tif (ns->profile_ptr[head->r.index])\n\t\t\t\tbreak;\n\t\tif (head->r.index == TOMOYO_MAX_PROFILES) {\n\t\t\thead->r.eof = true;\n\t\t\treturn;\n\t\t}\n\t\thead->r.step++;\n\t\tbreak;\n\tcase 2:\n\t\t{\n\t\t\tu8 i;\n\t\t\tconst struct tomoyo_path_info *comment =\n\t\t\t\tprofile->comment;\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_io_printf(head, \"%u-COMMENT=\", index);\n\t\t\ttomoyo_set_string(head, comment ? comment->name : \"\");\n\t\t\ttomoyo_set_lf(head);\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_io_printf(head, \"%u-PREFERENCE={ \", index);\n\t\t\tfor (i = 0; i < TOMOYO_MAX_PREF; i++)\n\t\t\t\ttomoyo_io_printf(head, \"%s=%u \",\n\t\t\t\t\t\t tomoyo_pref_keywords[i],\n\t\t\t\t\t\t profile->pref[i]);\n\t\t\ttomoyo_set_string(head, \"}\\n\");\n\t\t\thead->r.step++;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\t{\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_io_printf(head, \"%u-%s\", index, \"CONFIG\");\n\t\t\ttomoyo_print_config(head, profile->default_config);\n\t\t\thead->r.bit = 0;\n\t\t\thead->r.step++;\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tfor ( ; head->r.bit < TOMOYO_MAX_MAC_INDEX\n\t\t\t      + TOMOYO_MAX_MAC_CATEGORY_INDEX; head->r.bit++) {\n\t\t\tconst u8 i = head->r.bit;\n\t\t\tconst u8 config = profile->config[i];\n\t\t\tif (config == TOMOYO_CONFIG_USE_DEFAULT)\n\t\t\t\tcontinue;\n\t\t\ttomoyo_print_namespace(head);\n\t\t\tif (i < TOMOYO_MAX_MAC_INDEX)\n\t\t\t\ttomoyo_io_printf(head, \"%u-CONFIG::%s::%s\",\n\t\t\t\t\t\t index,\n\t\t\t\t\t\t tomoyo_category_keywords\n\t\t\t\t\t\t [tomoyo_index2category[i]],\n\t\t\t\t\t\t tomoyo_mac_keywords[i]);\n\t\t\telse\n\t\t\t\ttomoyo_io_printf(head, \"%u-CONFIG::%s\", index,\n\t\t\t\t\t\t tomoyo_mac_keywords[i]);\n\t\t\ttomoyo_print_config(head, config);\n\t\t\thead->r.bit++;\n\t\t\tbreak;\n\t\t}\n\t\tif (head->r.bit == TOMOYO_MAX_MAC_INDEX\n\t\t    + TOMOYO_MAX_MAC_CATEGORY_INDEX) {\n\t\t\thead->r.index++;\n\t\t\thead->r.step = 1;\n\t\t}\n\t\tbreak;\n\t}\n\tif (tomoyo_flush(head))\n\t\tgoto next;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const char * const tomoyo_mac_keywords[TOMOYO_MAX_MAC_INDEX\n\t\t\t\t       + TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t/* CONFIG::file group */\n\t[TOMOYO_MAC_FILE_EXECUTE]    = \"execute\",\n\t[TOMOYO_MAC_FILE_OPEN]       = \"open\",\n\t[TOMOYO_MAC_FILE_CREATE]     = \"create\",\n\t[TOMOYO_MAC_FILE_UNLINK]     = \"unlink\",\n\t[TOMOYO_MAC_FILE_GETATTR]    = \"getattr\",\n\t[TOMOYO_MAC_FILE_MKDIR]      = \"mkdir\",\n\t[TOMOYO_MAC_FILE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_MAC_FILE_MKFIFO]     = \"mkfifo\",\n\t[TOMOYO_MAC_FILE_MKSOCK]     = \"mksock\",\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_MAC_FILE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = \"mkblock\",\n\t[TOMOYO_MAC_FILE_MKCHAR]     = \"mkchar\",\n\t[TOMOYO_MAC_FILE_LINK]       = \"link\",\n\t[TOMOYO_MAC_FILE_RENAME]     = \"rename\",\n\t[TOMOYO_MAC_FILE_CHMOD]      = \"chmod\",\n\t[TOMOYO_MAC_FILE_CHOWN]      = \"chown\",\n\t[TOMOYO_MAC_FILE_CHGRP]      = \"chgrp\",\n\t[TOMOYO_MAC_FILE_IOCTL]      = \"ioctl\",\n\t[TOMOYO_MAC_FILE_CHROOT]     = \"chroot\",\n\t[TOMOYO_MAC_FILE_MOUNT]      = \"mount\",\n\t[TOMOYO_MAC_FILE_UMOUNT]     = \"unmount\",\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = \"pivot_root\",\n\t/* CONFIG::network group */\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       = \"inet_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     = \"inet_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    = \"inet_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        = \"inet_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        = \"inet_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          = \"inet_raw_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          = \"inet_raw_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       = \"unix_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     = \"unix_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    = \"unix_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        = \"unix_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        = \"unix_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    = \"unix_seqpacket_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  = \"unix_seqpacket_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = \"unix_seqpacket_connect\",\n\t/* CONFIG::misc group */\n\t[TOMOYO_MAC_ENVIRON] = \"env\",\n\t/* CONFIG group */\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_FILE] = \"file\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_MISC] = \"misc\",\n};",
      "static const char * const tomoyo_pref_keywords[TOMOYO_MAX_PREF] = {\n\t[TOMOYO_PREF_MAX_AUDIT_LOG]      = \"max_audit_log\",\n\t[TOMOYO_PREF_MAX_LEARNING_ENTRY] = \"max_learning_entry\",\n};",
      "static const char * const tomoyo_category_keywords\n[TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t[TOMOYO_MAC_CATEGORY_FILE]    = \"file\",\n\t[TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAC_CATEGORY_MISC]    = \"misc\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_flush",
          "args": [
            "head"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "212-245",
          "snippet": "static bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_print_config",
          "args": [
            "head",
            "config"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "714-720",
          "snippet": "static void tomoyo_print_config(struct tomoyo_io_buffer *head, const u8 config)\n{\n\ttomoyo_io_printf(head, \"={ mode=%s grant_log=%s reject_log=%s }\\n\",\n\t\t\t tomoyo_mode[config & 3],\n\t\t\t tomoyo_yesno(config & TOMOYO_CONFIG_WANT_GRANT_LOG),\n\t\t\t tomoyo_yesno(config & TOMOYO_CONFIG_WANT_REJECT_LOG));\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const char * const tomoyo_mode[TOMOYO_CONFIG_MAX_MODE] = {\n\t[TOMOYO_CONFIG_DISABLED]   = \"disabled\",\n\t[TOMOYO_CONFIG_LEARNING]   = \"learning\",\n\t[TOMOYO_CONFIG_PERMISSIVE] = \"permissive\",\n\t[TOMOYO_CONFIG_ENFORCING]  = \"enforcing\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char * const tomoyo_mode[TOMOYO_CONFIG_MAX_MODE] = {\n\t[TOMOYO_CONFIG_DISABLED]   = \"disabled\",\n\t[TOMOYO_CONFIG_LEARNING]   = \"learning\",\n\t[TOMOYO_CONFIG_PERMISSIVE] = \"permissive\",\n\t[TOMOYO_CONFIG_ENFORCING]  = \"enforcing\"\n};\n\nstatic void tomoyo_print_config(struct tomoyo_io_buffer *head, const u8 config)\n{\n\ttomoyo_io_printf(head, \"={ mode=%s grant_log=%s reject_log=%s }\\n\",\n\t\t\t tomoyo_mode[config & 3],\n\t\t\t tomoyo_yesno(config & TOMOYO_CONFIG_WANT_GRANT_LOG),\n\t\t\t tomoyo_yesno(config & TOMOYO_CONFIG_WANT_REJECT_LOG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_io_printf",
          "args": [
            "head",
            "\"%u-CONFIG::%s\"",
            "index",
            "tomoyo_mac_keywords[i]"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_io_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "275-293",
          "snippet": "static void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_print_namespace",
          "args": [
            "head"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "365-374",
          "snippet": "static void tomoyo_print_namespace(struct tomoyo_io_buffer *head)\n{\n\tif (!tomoyo_namespace_enabled)\n\t\treturn;\n\ttomoyo_set_string(head,\n\t\t\t  container_of(head->r.ns,\n\t\t\t\t       struct tomoyo_policy_namespace,\n\t\t\t\t       namespace_list)->name);\n\ttomoyo_set_space(head);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool tomoyo_namespace_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_namespace_enabled;\n\nstatic void tomoyo_print_namespace(struct tomoyo_io_buffer *head)\n{\n\tif (!tomoyo_namespace_enabled)\n\t\treturn;\n\ttomoyo_set_string(head,\n\t\t\t  container_of(head->r.ns,\n\t\t\t\t       struct tomoyo_policy_namespace,\n\t\t\t\t       namespace_list)->name);\n\ttomoyo_set_space(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "\"}\\n\""
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_lf",
          "args": [
            "head"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_lf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "314-318",
          "snippet": "static bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head->r.ns",
            "typeof(*ns)",
            "namespace_list"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ns"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char * const tomoyo_mac_keywords[TOMOYO_MAX_MAC_INDEX\n\t\t\t\t       + TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t/* CONFIG::file group */\n\t[TOMOYO_MAC_FILE_EXECUTE]    = \"execute\",\n\t[TOMOYO_MAC_FILE_OPEN]       = \"open\",\n\t[TOMOYO_MAC_FILE_CREATE]     = \"create\",\n\t[TOMOYO_MAC_FILE_UNLINK]     = \"unlink\",\n\t[TOMOYO_MAC_FILE_GETATTR]    = \"getattr\",\n\t[TOMOYO_MAC_FILE_MKDIR]      = \"mkdir\",\n\t[TOMOYO_MAC_FILE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_MAC_FILE_MKFIFO]     = \"mkfifo\",\n\t[TOMOYO_MAC_FILE_MKSOCK]     = \"mksock\",\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_MAC_FILE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = \"mkblock\",\n\t[TOMOYO_MAC_FILE_MKCHAR]     = \"mkchar\",\n\t[TOMOYO_MAC_FILE_LINK]       = \"link\",\n\t[TOMOYO_MAC_FILE_RENAME]     = \"rename\",\n\t[TOMOYO_MAC_FILE_CHMOD]      = \"chmod\",\n\t[TOMOYO_MAC_FILE_CHOWN]      = \"chown\",\n\t[TOMOYO_MAC_FILE_CHGRP]      = \"chgrp\",\n\t[TOMOYO_MAC_FILE_IOCTL]      = \"ioctl\",\n\t[TOMOYO_MAC_FILE_CHROOT]     = \"chroot\",\n\t[TOMOYO_MAC_FILE_MOUNT]      = \"mount\",\n\t[TOMOYO_MAC_FILE_UMOUNT]     = \"unmount\",\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = \"pivot_root\",\n\t/* CONFIG::network group */\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       = \"inet_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     = \"inet_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    = \"inet_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        = \"inet_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        = \"inet_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          = \"inet_raw_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          = \"inet_raw_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       = \"unix_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     = \"unix_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    = \"unix_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        = \"unix_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        = \"unix_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    = \"unix_seqpacket_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  = \"unix_seqpacket_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = \"unix_seqpacket_connect\",\n\t/* CONFIG::misc group */\n\t[TOMOYO_MAC_ENVIRON] = \"env\",\n\t/* CONFIG group */\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_FILE] = \"file\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_MISC] = \"misc\",\n};\nstatic const char * const tomoyo_pref_keywords[TOMOYO_MAX_PREF] = {\n\t[TOMOYO_PREF_MAX_AUDIT_LOG]      = \"max_audit_log\",\n\t[TOMOYO_PREF_MAX_LEARNING_ENTRY] = \"max_learning_entry\",\n};\nstatic const char * const tomoyo_category_keywords\n[TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t[TOMOYO_MAC_CATEGORY_FILE]    = \"file\",\n\t[TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAC_CATEGORY_MISC]    = \"misc\",\n};\n\nstatic void tomoyo_read_profile(struct tomoyo_io_buffer *head)\n{\n\tu8 index;\n\tstruct tomoyo_policy_namespace *ns =\n\t\tcontainer_of(head->r.ns, typeof(*ns), namespace_list);\n\tconst struct tomoyo_profile *profile;\n\tif (head->r.eof)\n\t\treturn;\n next:\n\tindex = head->r.index;\n\tprofile = ns->profile_ptr[index];\n\tswitch (head->r.step) {\n\tcase 0:\n\t\ttomoyo_print_namespace(head);\n\t\ttomoyo_io_printf(head, \"PROFILE_VERSION=%u\\n\",\n\t\t\t\t ns->profile_version);\n\t\thead->r.step++;\n\t\tbreak;\n\tcase 1:\n\t\tfor ( ; head->r.index < TOMOYO_MAX_PROFILES;\n\t\t      head->r.index++)\n\t\t\tif (ns->profile_ptr[head->r.index])\n\t\t\t\tbreak;\n\t\tif (head->r.index == TOMOYO_MAX_PROFILES) {\n\t\t\thead->r.eof = true;\n\t\t\treturn;\n\t\t}\n\t\thead->r.step++;\n\t\tbreak;\n\tcase 2:\n\t\t{\n\t\t\tu8 i;\n\t\t\tconst struct tomoyo_path_info *comment =\n\t\t\t\tprofile->comment;\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_io_printf(head, \"%u-COMMENT=\", index);\n\t\t\ttomoyo_set_string(head, comment ? comment->name : \"\");\n\t\t\ttomoyo_set_lf(head);\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_io_printf(head, \"%u-PREFERENCE={ \", index);\n\t\t\tfor (i = 0; i < TOMOYO_MAX_PREF; i++)\n\t\t\t\ttomoyo_io_printf(head, \"%s=%u \",\n\t\t\t\t\t\t tomoyo_pref_keywords[i],\n\t\t\t\t\t\t profile->pref[i]);\n\t\t\ttomoyo_set_string(head, \"}\\n\");\n\t\t\thead->r.step++;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\t{\n\t\t\ttomoyo_print_namespace(head);\n\t\t\ttomoyo_io_printf(head, \"%u-%s\", index, \"CONFIG\");\n\t\t\ttomoyo_print_config(head, profile->default_config);\n\t\t\thead->r.bit = 0;\n\t\t\thead->r.step++;\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tfor ( ; head->r.bit < TOMOYO_MAX_MAC_INDEX\n\t\t\t      + TOMOYO_MAX_MAC_CATEGORY_INDEX; head->r.bit++) {\n\t\t\tconst u8 i = head->r.bit;\n\t\t\tconst u8 config = profile->config[i];\n\t\t\tif (config == TOMOYO_CONFIG_USE_DEFAULT)\n\t\t\t\tcontinue;\n\t\t\ttomoyo_print_namespace(head);\n\t\t\tif (i < TOMOYO_MAX_MAC_INDEX)\n\t\t\t\ttomoyo_io_printf(head, \"%u-CONFIG::%s::%s\",\n\t\t\t\t\t\t index,\n\t\t\t\t\t\t tomoyo_category_keywords\n\t\t\t\t\t\t [tomoyo_index2category[i]],\n\t\t\t\t\t\t tomoyo_mac_keywords[i]);\n\t\t\telse\n\t\t\t\ttomoyo_io_printf(head, \"%u-CONFIG::%s\", index,\n\t\t\t\t\t\t tomoyo_mac_keywords[i]);\n\t\t\ttomoyo_print_config(head, config);\n\t\t\thead->r.bit++;\n\t\t\tbreak;\n\t\t}\n\t\tif (head->r.bit == TOMOYO_MAX_MAC_INDEX\n\t\t    + TOMOYO_MAX_MAC_CATEGORY_INDEX) {\n\t\t\thead->r.index++;\n\t\t\thead->r.step = 1;\n\t\t}\n\t\tbreak;\n\t}\n\tif (tomoyo_flush(head))\n\t\tgoto next;\n}"
  },
  {
    "function_name": "tomoyo_print_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "714-720",
    "snippet": "static void tomoyo_print_config(struct tomoyo_io_buffer *head, const u8 config)\n{\n\ttomoyo_io_printf(head, \"={ mode=%s grant_log=%s reject_log=%s }\\n\",\n\t\t\t tomoyo_mode[config & 3],\n\t\t\t tomoyo_yesno(config & TOMOYO_CONFIG_WANT_GRANT_LOG),\n\t\t\t tomoyo_yesno(config & TOMOYO_CONFIG_WANT_REJECT_LOG));\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const char * const tomoyo_mode[TOMOYO_CONFIG_MAX_MODE] = {\n\t[TOMOYO_CONFIG_DISABLED]   = \"disabled\",\n\t[TOMOYO_CONFIG_LEARNING]   = \"learning\",\n\t[TOMOYO_CONFIG_PERMISSIVE] = \"permissive\",\n\t[TOMOYO_CONFIG_ENFORCING]  = \"enforcing\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_io_printf",
          "args": [
            "head",
            "\"={ mode=%s grant_log=%s reject_log=%s }\\n\"",
            "tomoyo_mode[config & 3]",
            "tomoyo_yesno(config & TOMOYO_CONFIG_WANT_GRANT_LOG)",
            "tomoyo_yesno(config & TOMOYO_CONFIG_WANT_REJECT_LOG)"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_io_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "275-293",
          "snippet": "static void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_yesno",
          "args": [
            "config & TOMOYO_CONFIG_WANT_REJECT_LOG"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_yesno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "182-185",
          "snippet": "const char *tomoyo_yesno(const unsigned int value)\n{\n\treturn value ? \"yes\" : \"no\";\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char *tomoyo_yesno(const unsigned int value)\n{\n\treturn value ? \"yes\" : \"no\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char * const tomoyo_mode[TOMOYO_CONFIG_MAX_MODE] = {\n\t[TOMOYO_CONFIG_DISABLED]   = \"disabled\",\n\t[TOMOYO_CONFIG_LEARNING]   = \"learning\",\n\t[TOMOYO_CONFIG_PERMISSIVE] = \"permissive\",\n\t[TOMOYO_CONFIG_ENFORCING]  = \"enforcing\"\n};\n\nstatic void tomoyo_print_config(struct tomoyo_io_buffer *head, const u8 config)\n{\n\ttomoyo_io_printf(head, \"={ mode=%s grant_log=%s reject_log=%s }\\n\",\n\t\t\t tomoyo_mode[config & 3],\n\t\t\t tomoyo_yesno(config & TOMOYO_CONFIG_WANT_GRANT_LOG),\n\t\t\t tomoyo_yesno(config & TOMOYO_CONFIG_WANT_REJECT_LOG));\n}"
  },
  {
    "function_name": "tomoyo_write_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "661-702",
    "snippet": "static int tomoyo_write_profile(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\tunsigned int i;\n\tchar *cp;\n\tstruct tomoyo_profile *profile;\n\tif (sscanf(data, \"PROFILE_VERSION=%u\", &head->w.ns->profile_version)\n\t    == 1)\n\t\treturn 0;\n\ti = simple_strtoul(data, &cp, 10);\n\tif (*cp != '-')\n\t\treturn -EINVAL;\n\tdata = cp + 1;\n\tprofile = tomoyo_assign_profile(head->w.ns, i);\n\tif (!profile)\n\t\treturn -EINVAL;\n\tcp = strchr(data, '=');\n\tif (!cp)\n\t\treturn -EINVAL;\n\t*cp++ = '\\0';\n\tif (!strcmp(data, \"COMMENT\")) {\n\t\tstatic DEFINE_SPINLOCK(lock);\n\t\tconst struct tomoyo_path_info *new_comment\n\t\t\t= tomoyo_get_name(cp);\n\t\tconst struct tomoyo_path_info *old_comment;\n\t\tif (!new_comment)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock(&lock);\n\t\told_comment = profile->comment;\n\t\tprofile->comment = new_comment;\n\t\tspin_unlock(&lock);\n\t\ttomoyo_put_name(old_comment);\n\t\treturn 0;\n\t}\n\tif (!strcmp(data, \"PREFERENCE\")) {\n\t\tfor (i = 0; i < TOMOYO_MAX_PREF; i++)\n\t\t\ttomoyo_set_uint(&profile->pref[i], cp,\n\t\t\t\t\ttomoyo_pref_keywords[i]);\n\t\treturn 0;\n\t}\n\treturn tomoyo_set_mode(data, cp, profile);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const tomoyo_pref_keywords[TOMOYO_MAX_PREF] = {\n\t[TOMOYO_PREF_MAX_AUDIT_LOG]      = \"max_audit_log\",\n\t[TOMOYO_PREF_MAX_LEARNING_ENTRY] = \"max_learning_entry\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_mode",
          "args": [
            "data",
            "cp",
            "profile"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "585-652",
          "snippet": "static int tomoyo_set_mode(char *name, const char *value,\n\t\t\t   struct tomoyo_profile *profile)\n{\n\tu8 i;\n\tu8 config;\n\tif (!strcmp(name, \"CONFIG\")) {\n\t\ti = TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX;\n\t\tconfig = profile->default_config;\n\t} else if (tomoyo_str_starts(&name, \"CONFIG::\")) {\n\t\tconfig = 0;\n\t\tfor (i = 0; i < TOMOYO_MAX_MAC_INDEX\n\t\t\t     + TOMOYO_MAX_MAC_CATEGORY_INDEX; i++) {\n\t\t\tint len = 0;\n\t\t\tif (i < TOMOYO_MAX_MAC_INDEX) {\n\t\t\t\tconst u8 c = tomoyo_index2category[i];\n\t\t\t\tconst char *category =\n\t\t\t\t\ttomoyo_category_keywords[c];\n\t\t\t\tlen = strlen(category);\n\t\t\t\tif (strncmp(name, category, len) ||\n\t\t\t\t    name[len++] != ':' || name[len++] != ':')\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(name + len, tomoyo_mac_keywords[i]))\n\t\t\t\tcontinue;\n\t\t\tconfig = profile->config[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (i == TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (strstr(value, \"use_default\")) {\n\t\tconfig = TOMOYO_CONFIG_USE_DEFAULT;\n\t} else {\n\t\tu8 mode;\n\t\tfor (mode = 0; mode < 4; mode++)\n\t\t\tif (strstr(value, tomoyo_mode[mode]))\n\t\t\t\t/*\n\t\t\t\t * Update lower 3 bits in order to distinguish\n\t\t\t\t * 'config' from 'TOMOYO_CONFIG_USE_DEAFULT'.\n\t\t\t\t */\n\t\t\t\tconfig = (config & ~7) | mode;\n\t\tif (config != TOMOYO_CONFIG_USE_DEFAULT) {\n\t\t\tswitch (tomoyo_find_yesno(value, \"grant_log\")) {\n\t\t\tcase 1:\n\t\t\t\tconfig |= TOMOYO_CONFIG_WANT_GRANT_LOG;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tconfig &= ~TOMOYO_CONFIG_WANT_GRANT_LOG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (tomoyo_find_yesno(value, \"reject_log\")) {\n\t\t\tcase 1:\n\t\t\t\tconfig |= TOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tconfig &= ~TOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (i < TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX)\n\t\tprofile->config[i] = config;\n\telse if (config != TOMOYO_CONFIG_USE_DEFAULT)\n\t\tprofile->default_config = config;\n\treturn 0;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const char * const tomoyo_mode[TOMOYO_CONFIG_MAX_MODE] = {\n\t[TOMOYO_CONFIG_DISABLED]   = \"disabled\",\n\t[TOMOYO_CONFIG_LEARNING]   = \"learning\",\n\t[TOMOYO_CONFIG_PERMISSIVE] = \"permissive\",\n\t[TOMOYO_CONFIG_ENFORCING]  = \"enforcing\"\n};",
            "const char * const tomoyo_mac_keywords[TOMOYO_MAX_MAC_INDEX\n\t\t\t\t       + TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t/* CONFIG::file group */\n\t[TOMOYO_MAC_FILE_EXECUTE]    = \"execute\",\n\t[TOMOYO_MAC_FILE_OPEN]       = \"open\",\n\t[TOMOYO_MAC_FILE_CREATE]     = \"create\",\n\t[TOMOYO_MAC_FILE_UNLINK]     = \"unlink\",\n\t[TOMOYO_MAC_FILE_GETATTR]    = \"getattr\",\n\t[TOMOYO_MAC_FILE_MKDIR]      = \"mkdir\",\n\t[TOMOYO_MAC_FILE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_MAC_FILE_MKFIFO]     = \"mkfifo\",\n\t[TOMOYO_MAC_FILE_MKSOCK]     = \"mksock\",\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_MAC_FILE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = \"mkblock\",\n\t[TOMOYO_MAC_FILE_MKCHAR]     = \"mkchar\",\n\t[TOMOYO_MAC_FILE_LINK]       = \"link\",\n\t[TOMOYO_MAC_FILE_RENAME]     = \"rename\",\n\t[TOMOYO_MAC_FILE_CHMOD]      = \"chmod\",\n\t[TOMOYO_MAC_FILE_CHOWN]      = \"chown\",\n\t[TOMOYO_MAC_FILE_CHGRP]      = \"chgrp\",\n\t[TOMOYO_MAC_FILE_IOCTL]      = \"ioctl\",\n\t[TOMOYO_MAC_FILE_CHROOT]     = \"chroot\",\n\t[TOMOYO_MAC_FILE_MOUNT]      = \"mount\",\n\t[TOMOYO_MAC_FILE_UMOUNT]     = \"unmount\",\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = \"pivot_root\",\n\t/* CONFIG::network group */\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       = \"inet_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     = \"inet_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    = \"inet_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        = \"inet_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        = \"inet_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          = \"inet_raw_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          = \"inet_raw_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       = \"unix_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     = \"unix_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    = \"unix_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        = \"unix_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        = \"unix_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    = \"unix_seqpacket_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  = \"unix_seqpacket_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = \"unix_seqpacket_connect\",\n\t/* CONFIG::misc group */\n\t[TOMOYO_MAC_ENVIRON] = \"env\",\n\t/* CONFIG group */\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_FILE] = \"file\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_MISC] = \"misc\",\n};",
            "static const char * const tomoyo_category_keywords\n[TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t[TOMOYO_MAC_CATEGORY_FILE]    = \"file\",\n\t[TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAC_CATEGORY_MISC]    = \"misc\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char * const tomoyo_mode[TOMOYO_CONFIG_MAX_MODE] = {\n\t[TOMOYO_CONFIG_DISABLED]   = \"disabled\",\n\t[TOMOYO_CONFIG_LEARNING]   = \"learning\",\n\t[TOMOYO_CONFIG_PERMISSIVE] = \"permissive\",\n\t[TOMOYO_CONFIG_ENFORCING]  = \"enforcing\"\n};\nconst char * const tomoyo_mac_keywords[TOMOYO_MAX_MAC_INDEX\n\t\t\t\t       + TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t/* CONFIG::file group */\n\t[TOMOYO_MAC_FILE_EXECUTE]    = \"execute\",\n\t[TOMOYO_MAC_FILE_OPEN]       = \"open\",\n\t[TOMOYO_MAC_FILE_CREATE]     = \"create\",\n\t[TOMOYO_MAC_FILE_UNLINK]     = \"unlink\",\n\t[TOMOYO_MAC_FILE_GETATTR]    = \"getattr\",\n\t[TOMOYO_MAC_FILE_MKDIR]      = \"mkdir\",\n\t[TOMOYO_MAC_FILE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_MAC_FILE_MKFIFO]     = \"mkfifo\",\n\t[TOMOYO_MAC_FILE_MKSOCK]     = \"mksock\",\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_MAC_FILE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = \"mkblock\",\n\t[TOMOYO_MAC_FILE_MKCHAR]     = \"mkchar\",\n\t[TOMOYO_MAC_FILE_LINK]       = \"link\",\n\t[TOMOYO_MAC_FILE_RENAME]     = \"rename\",\n\t[TOMOYO_MAC_FILE_CHMOD]      = \"chmod\",\n\t[TOMOYO_MAC_FILE_CHOWN]      = \"chown\",\n\t[TOMOYO_MAC_FILE_CHGRP]      = \"chgrp\",\n\t[TOMOYO_MAC_FILE_IOCTL]      = \"ioctl\",\n\t[TOMOYO_MAC_FILE_CHROOT]     = \"chroot\",\n\t[TOMOYO_MAC_FILE_MOUNT]      = \"mount\",\n\t[TOMOYO_MAC_FILE_UMOUNT]     = \"unmount\",\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = \"pivot_root\",\n\t/* CONFIG::network group */\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       = \"inet_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     = \"inet_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    = \"inet_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        = \"inet_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        = \"inet_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          = \"inet_raw_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          = \"inet_raw_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       = \"unix_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     = \"unix_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    = \"unix_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        = \"unix_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        = \"unix_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    = \"unix_seqpacket_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  = \"unix_seqpacket_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = \"unix_seqpacket_connect\",\n\t/* CONFIG::misc group */\n\t[TOMOYO_MAC_ENVIRON] = \"env\",\n\t/* CONFIG group */\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_FILE] = \"file\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_MISC] = \"misc\",\n};\nstatic const char * const tomoyo_category_keywords\n[TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t[TOMOYO_MAC_CATEGORY_FILE]    = \"file\",\n\t[TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAC_CATEGORY_MISC]    = \"misc\",\n};\n\nstatic int tomoyo_set_mode(char *name, const char *value,\n\t\t\t   struct tomoyo_profile *profile)\n{\n\tu8 i;\n\tu8 config;\n\tif (!strcmp(name, \"CONFIG\")) {\n\t\ti = TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX;\n\t\tconfig = profile->default_config;\n\t} else if (tomoyo_str_starts(&name, \"CONFIG::\")) {\n\t\tconfig = 0;\n\t\tfor (i = 0; i < TOMOYO_MAX_MAC_INDEX\n\t\t\t     + TOMOYO_MAX_MAC_CATEGORY_INDEX; i++) {\n\t\t\tint len = 0;\n\t\t\tif (i < TOMOYO_MAX_MAC_INDEX) {\n\t\t\t\tconst u8 c = tomoyo_index2category[i];\n\t\t\t\tconst char *category =\n\t\t\t\t\ttomoyo_category_keywords[c];\n\t\t\t\tlen = strlen(category);\n\t\t\t\tif (strncmp(name, category, len) ||\n\t\t\t\t    name[len++] != ':' || name[len++] != ':')\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(name + len, tomoyo_mac_keywords[i]))\n\t\t\t\tcontinue;\n\t\t\tconfig = profile->config[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (i == TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (strstr(value, \"use_default\")) {\n\t\tconfig = TOMOYO_CONFIG_USE_DEFAULT;\n\t} else {\n\t\tu8 mode;\n\t\tfor (mode = 0; mode < 4; mode++)\n\t\t\tif (strstr(value, tomoyo_mode[mode]))\n\t\t\t\t/*\n\t\t\t\t * Update lower 3 bits in order to distinguish\n\t\t\t\t * 'config' from 'TOMOYO_CONFIG_USE_DEAFULT'.\n\t\t\t\t */\n\t\t\t\tconfig = (config & ~7) | mode;\n\t\tif (config != TOMOYO_CONFIG_USE_DEFAULT) {\n\t\t\tswitch (tomoyo_find_yesno(value, \"grant_log\")) {\n\t\t\tcase 1:\n\t\t\t\tconfig |= TOMOYO_CONFIG_WANT_GRANT_LOG;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tconfig &= ~TOMOYO_CONFIG_WANT_GRANT_LOG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (tomoyo_find_yesno(value, \"reject_log\")) {\n\t\t\tcase 1:\n\t\t\t\tconfig |= TOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tconfig &= ~TOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (i < TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX)\n\t\tprofile->config[i] = config;\n\telse if (config != TOMOYO_CONFIG_USE_DEFAULT)\n\t\tprofile->default_config = config;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_uint",
          "args": [
            "&profile->pref[i]",
            "cp",
            "tomoyo_pref_keywords[i]"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_uint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "568-574",
          "snippet": "static void tomoyo_set_uint(unsigned int *i, const char *string,\n\t\t\t    const char *find)\n{\n\tconst char *cp = strstr(string, find);\n\tif (cp)\n\t\tsscanf(cp + strlen(find), \"=%u\", i);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_uint(unsigned int *i, const char *string,\n\t\t\t    const char *find)\n{\n\tconst char *cp = strstr(string, find);\n\tif (cp)\n\t\tsscanf(cp + strlen(find), \"=%u\", i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data",
            "\"PREFERENCE\""
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "old_comment"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lock"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lock"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_name",
          "args": [
            "cp"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "148-183",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data",
            "\"COMMENT\""
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "data",
            "'='"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_assign_profile",
          "args": [
            "head->w.ns",
            "i"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_assign_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "485-518",
          "snippet": "static struct tomoyo_profile *tomoyo_assign_profile\n(struct tomoyo_policy_namespace *ns, const unsigned int profile)\n{\n\tstruct tomoyo_profile *ptr;\n\tstruct tomoyo_profile *entry;\n\tif (profile >= TOMOYO_MAX_PROFILES)\n\t\treturn NULL;\n\tptr = ns->profile_ptr[profile];\n\tif (ptr)\n\t\treturn ptr;\n\tentry = kzalloc(sizeof(*entry), GFP_NOFS);\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tptr = ns->profile_ptr[profile];\n\tif (!ptr && tomoyo_memory_ok(entry)) {\n\t\tptr = entry;\n\t\tptr->default_config = TOMOYO_CONFIG_DISABLED |\n\t\t\tTOMOYO_CONFIG_WANT_GRANT_LOG |\n\t\t\tTOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\tmemset(ptr->config, TOMOYO_CONFIG_USE_DEFAULT,\n\t\t       sizeof(ptr->config));\n\t\tptr->pref[TOMOYO_PREF_MAX_AUDIT_LOG] =\n\t\t\tCONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG;\n\t\tptr->pref[TOMOYO_PREF_MAX_LEARNING_ENTRY] =\n\t\t\tCONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY;\n\t\tmb(); /* Avoid out-of-order execution. */\n\t\tns->profile_ptr[profile] = ptr;\n\t\tentry = NULL;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n out:\n\tkfree(entry);\n\treturn ptr;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic struct tomoyo_profile *tomoyo_assign_profile\n(struct tomoyo_policy_namespace *ns, const unsigned int profile)\n{\n\tstruct tomoyo_profile *ptr;\n\tstruct tomoyo_profile *entry;\n\tif (profile >= TOMOYO_MAX_PROFILES)\n\t\treturn NULL;\n\tptr = ns->profile_ptr[profile];\n\tif (ptr)\n\t\treturn ptr;\n\tentry = kzalloc(sizeof(*entry), GFP_NOFS);\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tptr = ns->profile_ptr[profile];\n\tif (!ptr && tomoyo_memory_ok(entry)) {\n\t\tptr = entry;\n\t\tptr->default_config = TOMOYO_CONFIG_DISABLED |\n\t\t\tTOMOYO_CONFIG_WANT_GRANT_LOG |\n\t\t\tTOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\tmemset(ptr->config, TOMOYO_CONFIG_USE_DEFAULT,\n\t\t       sizeof(ptr->config));\n\t\tptr->pref[TOMOYO_PREF_MAX_AUDIT_LOG] =\n\t\t\tCONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG;\n\t\tptr->pref[TOMOYO_PREF_MAX_LEARNING_ENTRY] =\n\t\t\tCONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY;\n\t\tmb(); /* Avoid out-of-order execution. */\n\t\tns->profile_ptr[profile] = ptr;\n\t\tentry = NULL;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n out:\n\tkfree(entry);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "data",
            "&cp",
            "10"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "data",
            "\"PROFILE_VERSION=%u\"",
            "&head->w.ns->profile_version"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic const char * const tomoyo_pref_keywords[TOMOYO_MAX_PREF] = {\n\t[TOMOYO_PREF_MAX_AUDIT_LOG]      = \"max_audit_log\",\n\t[TOMOYO_PREF_MAX_LEARNING_ENTRY] = \"max_learning_entry\",\n};\n\nstatic int tomoyo_write_profile(struct tomoyo_io_buffer *head)\n{\n\tchar *data = head->write_buf;\n\tunsigned int i;\n\tchar *cp;\n\tstruct tomoyo_profile *profile;\n\tif (sscanf(data, \"PROFILE_VERSION=%u\", &head->w.ns->profile_version)\n\t    == 1)\n\t\treturn 0;\n\ti = simple_strtoul(data, &cp, 10);\n\tif (*cp != '-')\n\t\treturn -EINVAL;\n\tdata = cp + 1;\n\tprofile = tomoyo_assign_profile(head->w.ns, i);\n\tif (!profile)\n\t\treturn -EINVAL;\n\tcp = strchr(data, '=');\n\tif (!cp)\n\t\treturn -EINVAL;\n\t*cp++ = '\\0';\n\tif (!strcmp(data, \"COMMENT\")) {\n\t\tstatic DEFINE_SPINLOCK(lock);\n\t\tconst struct tomoyo_path_info *new_comment\n\t\t\t= tomoyo_get_name(cp);\n\t\tconst struct tomoyo_path_info *old_comment;\n\t\tif (!new_comment)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock(&lock);\n\t\told_comment = profile->comment;\n\t\tprofile->comment = new_comment;\n\t\tspin_unlock(&lock);\n\t\ttomoyo_put_name(old_comment);\n\t\treturn 0;\n\t}\n\tif (!strcmp(data, \"PREFERENCE\")) {\n\t\tfor (i = 0; i < TOMOYO_MAX_PREF; i++)\n\t\t\ttomoyo_set_uint(&profile->pref[i], cp,\n\t\t\t\t\ttomoyo_pref_keywords[i]);\n\t\treturn 0;\n\t}\n\treturn tomoyo_set_mode(data, cp, profile);\n}"
  },
  {
    "function_name": "tomoyo_set_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "585-652",
    "snippet": "static int tomoyo_set_mode(char *name, const char *value,\n\t\t\t   struct tomoyo_profile *profile)\n{\n\tu8 i;\n\tu8 config;\n\tif (!strcmp(name, \"CONFIG\")) {\n\t\ti = TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX;\n\t\tconfig = profile->default_config;\n\t} else if (tomoyo_str_starts(&name, \"CONFIG::\")) {\n\t\tconfig = 0;\n\t\tfor (i = 0; i < TOMOYO_MAX_MAC_INDEX\n\t\t\t     + TOMOYO_MAX_MAC_CATEGORY_INDEX; i++) {\n\t\t\tint len = 0;\n\t\t\tif (i < TOMOYO_MAX_MAC_INDEX) {\n\t\t\t\tconst u8 c = tomoyo_index2category[i];\n\t\t\t\tconst char *category =\n\t\t\t\t\ttomoyo_category_keywords[c];\n\t\t\t\tlen = strlen(category);\n\t\t\t\tif (strncmp(name, category, len) ||\n\t\t\t\t    name[len++] != ':' || name[len++] != ':')\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(name + len, tomoyo_mac_keywords[i]))\n\t\t\t\tcontinue;\n\t\t\tconfig = profile->config[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (i == TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (strstr(value, \"use_default\")) {\n\t\tconfig = TOMOYO_CONFIG_USE_DEFAULT;\n\t} else {\n\t\tu8 mode;\n\t\tfor (mode = 0; mode < 4; mode++)\n\t\t\tif (strstr(value, tomoyo_mode[mode]))\n\t\t\t\t/*\n\t\t\t\t * Update lower 3 bits in order to distinguish\n\t\t\t\t * 'config' from 'TOMOYO_CONFIG_USE_DEAFULT'.\n\t\t\t\t */\n\t\t\t\tconfig = (config & ~7) | mode;\n\t\tif (config != TOMOYO_CONFIG_USE_DEFAULT) {\n\t\t\tswitch (tomoyo_find_yesno(value, \"grant_log\")) {\n\t\t\tcase 1:\n\t\t\t\tconfig |= TOMOYO_CONFIG_WANT_GRANT_LOG;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tconfig &= ~TOMOYO_CONFIG_WANT_GRANT_LOG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (tomoyo_find_yesno(value, \"reject_log\")) {\n\t\t\tcase 1:\n\t\t\t\tconfig |= TOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tconfig &= ~TOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (i < TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX)\n\t\tprofile->config[i] = config;\n\telse if (config != TOMOYO_CONFIG_USE_DEFAULT)\n\t\tprofile->default_config = config;\n\treturn 0;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const char * const tomoyo_mode[TOMOYO_CONFIG_MAX_MODE] = {\n\t[TOMOYO_CONFIG_DISABLED]   = \"disabled\",\n\t[TOMOYO_CONFIG_LEARNING]   = \"learning\",\n\t[TOMOYO_CONFIG_PERMISSIVE] = \"permissive\",\n\t[TOMOYO_CONFIG_ENFORCING]  = \"enforcing\"\n};",
      "const char * const tomoyo_mac_keywords[TOMOYO_MAX_MAC_INDEX\n\t\t\t\t       + TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t/* CONFIG::file group */\n\t[TOMOYO_MAC_FILE_EXECUTE]    = \"execute\",\n\t[TOMOYO_MAC_FILE_OPEN]       = \"open\",\n\t[TOMOYO_MAC_FILE_CREATE]     = \"create\",\n\t[TOMOYO_MAC_FILE_UNLINK]     = \"unlink\",\n\t[TOMOYO_MAC_FILE_GETATTR]    = \"getattr\",\n\t[TOMOYO_MAC_FILE_MKDIR]      = \"mkdir\",\n\t[TOMOYO_MAC_FILE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_MAC_FILE_MKFIFO]     = \"mkfifo\",\n\t[TOMOYO_MAC_FILE_MKSOCK]     = \"mksock\",\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_MAC_FILE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = \"mkblock\",\n\t[TOMOYO_MAC_FILE_MKCHAR]     = \"mkchar\",\n\t[TOMOYO_MAC_FILE_LINK]       = \"link\",\n\t[TOMOYO_MAC_FILE_RENAME]     = \"rename\",\n\t[TOMOYO_MAC_FILE_CHMOD]      = \"chmod\",\n\t[TOMOYO_MAC_FILE_CHOWN]      = \"chown\",\n\t[TOMOYO_MAC_FILE_CHGRP]      = \"chgrp\",\n\t[TOMOYO_MAC_FILE_IOCTL]      = \"ioctl\",\n\t[TOMOYO_MAC_FILE_CHROOT]     = \"chroot\",\n\t[TOMOYO_MAC_FILE_MOUNT]      = \"mount\",\n\t[TOMOYO_MAC_FILE_UMOUNT]     = \"unmount\",\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = \"pivot_root\",\n\t/* CONFIG::network group */\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       = \"inet_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     = \"inet_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    = \"inet_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        = \"inet_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        = \"inet_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          = \"inet_raw_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          = \"inet_raw_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       = \"unix_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     = \"unix_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    = \"unix_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        = \"unix_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        = \"unix_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    = \"unix_seqpacket_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  = \"unix_seqpacket_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = \"unix_seqpacket_connect\",\n\t/* CONFIG::misc group */\n\t[TOMOYO_MAC_ENVIRON] = \"env\",\n\t/* CONFIG group */\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_FILE] = \"file\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_MISC] = \"misc\",\n};",
      "static const char * const tomoyo_category_keywords\n[TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t[TOMOYO_MAC_CATEGORY_FILE]    = \"file\",\n\t[TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAC_CATEGORY_MISC]    = \"misc\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_find_yesno",
          "args": [
            "value",
            "\"reject_log\""
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_find_yesno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "546-557",
          "snippet": "static s8 tomoyo_find_yesno(const char *string, const char *find)\n{\n\tconst char *cp = strstr(string, find);\n\tif (cp) {\n\t\tcp += strlen(find);\n\t\tif (!strncmp(cp, \"=yes\", 4))\n\t\t\treturn 1;\n\t\telse if (!strncmp(cp, \"=no\", 3))\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic s8 tomoyo_find_yesno(const char *string, const char *find)\n{\n\tconst char *cp = strstr(string, find);\n\tif (cp) {\n\t\tcp += strlen(find);\n\t\tif (!strncmp(cp, \"=yes\", 4))\n\t\t\treturn 1;\n\t\telse if (!strncmp(cp, \"=no\", 3))\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "value",
            "tomoyo_mode[mode]"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "value",
            "\"use_default\""
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name + len",
            "tomoyo_mac_keywords[i]"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "category",
            "len"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "category"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_str_starts",
          "args": [
            "&name",
            "\"CONFIG::\""
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_str_starts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "374-384",
          "snippet": "bool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"CONFIG\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char * const tomoyo_mode[TOMOYO_CONFIG_MAX_MODE] = {\n\t[TOMOYO_CONFIG_DISABLED]   = \"disabled\",\n\t[TOMOYO_CONFIG_LEARNING]   = \"learning\",\n\t[TOMOYO_CONFIG_PERMISSIVE] = \"permissive\",\n\t[TOMOYO_CONFIG_ENFORCING]  = \"enforcing\"\n};\nconst char * const tomoyo_mac_keywords[TOMOYO_MAX_MAC_INDEX\n\t\t\t\t       + TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t/* CONFIG::file group */\n\t[TOMOYO_MAC_FILE_EXECUTE]    = \"execute\",\n\t[TOMOYO_MAC_FILE_OPEN]       = \"open\",\n\t[TOMOYO_MAC_FILE_CREATE]     = \"create\",\n\t[TOMOYO_MAC_FILE_UNLINK]     = \"unlink\",\n\t[TOMOYO_MAC_FILE_GETATTR]    = \"getattr\",\n\t[TOMOYO_MAC_FILE_MKDIR]      = \"mkdir\",\n\t[TOMOYO_MAC_FILE_RMDIR]      = \"rmdir\",\n\t[TOMOYO_MAC_FILE_MKFIFO]     = \"mkfifo\",\n\t[TOMOYO_MAC_FILE_MKSOCK]     = \"mksock\",\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = \"truncate\",\n\t[TOMOYO_MAC_FILE_SYMLINK]    = \"symlink\",\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = \"mkblock\",\n\t[TOMOYO_MAC_FILE_MKCHAR]     = \"mkchar\",\n\t[TOMOYO_MAC_FILE_LINK]       = \"link\",\n\t[TOMOYO_MAC_FILE_RENAME]     = \"rename\",\n\t[TOMOYO_MAC_FILE_CHMOD]      = \"chmod\",\n\t[TOMOYO_MAC_FILE_CHOWN]      = \"chown\",\n\t[TOMOYO_MAC_FILE_CHGRP]      = \"chgrp\",\n\t[TOMOYO_MAC_FILE_IOCTL]      = \"ioctl\",\n\t[TOMOYO_MAC_FILE_CHROOT]     = \"chroot\",\n\t[TOMOYO_MAC_FILE_MOUNT]      = \"mount\",\n\t[TOMOYO_MAC_FILE_UMOUNT]     = \"unmount\",\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = \"pivot_root\",\n\t/* CONFIG::network group */\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       = \"inet_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     = \"inet_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    = \"inet_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        = \"inet_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        = \"inet_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          = \"inet_raw_bind\",\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          = \"inet_raw_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       = \"unix_stream_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     = \"unix_stream_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    = \"unix_stream_connect\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        = \"unix_dgram_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        = \"unix_dgram_send\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    = \"unix_seqpacket_bind\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  = \"unix_seqpacket_listen\",\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = \"unix_seqpacket_connect\",\n\t/* CONFIG::misc group */\n\t[TOMOYO_MAC_ENVIRON] = \"env\",\n\t/* CONFIG group */\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_FILE] = \"file\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_MISC] = \"misc\",\n};\nstatic const char * const tomoyo_category_keywords\n[TOMOYO_MAX_MAC_CATEGORY_INDEX] = {\n\t[TOMOYO_MAC_CATEGORY_FILE]    = \"file\",\n\t[TOMOYO_MAC_CATEGORY_NETWORK] = \"network\",\n\t[TOMOYO_MAC_CATEGORY_MISC]    = \"misc\",\n};\n\nstatic int tomoyo_set_mode(char *name, const char *value,\n\t\t\t   struct tomoyo_profile *profile)\n{\n\tu8 i;\n\tu8 config;\n\tif (!strcmp(name, \"CONFIG\")) {\n\t\ti = TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX;\n\t\tconfig = profile->default_config;\n\t} else if (tomoyo_str_starts(&name, \"CONFIG::\")) {\n\t\tconfig = 0;\n\t\tfor (i = 0; i < TOMOYO_MAX_MAC_INDEX\n\t\t\t     + TOMOYO_MAX_MAC_CATEGORY_INDEX; i++) {\n\t\t\tint len = 0;\n\t\t\tif (i < TOMOYO_MAX_MAC_INDEX) {\n\t\t\t\tconst u8 c = tomoyo_index2category[i];\n\t\t\t\tconst char *category =\n\t\t\t\t\ttomoyo_category_keywords[c];\n\t\t\t\tlen = strlen(category);\n\t\t\t\tif (strncmp(name, category, len) ||\n\t\t\t\t    name[len++] != ':' || name[len++] != ':')\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(name + len, tomoyo_mac_keywords[i]))\n\t\t\t\tcontinue;\n\t\t\tconfig = profile->config[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (i == TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (strstr(value, \"use_default\")) {\n\t\tconfig = TOMOYO_CONFIG_USE_DEFAULT;\n\t} else {\n\t\tu8 mode;\n\t\tfor (mode = 0; mode < 4; mode++)\n\t\t\tif (strstr(value, tomoyo_mode[mode]))\n\t\t\t\t/*\n\t\t\t\t * Update lower 3 bits in order to distinguish\n\t\t\t\t * 'config' from 'TOMOYO_CONFIG_USE_DEAFULT'.\n\t\t\t\t */\n\t\t\t\tconfig = (config & ~7) | mode;\n\t\tif (config != TOMOYO_CONFIG_USE_DEFAULT) {\n\t\t\tswitch (tomoyo_find_yesno(value, \"grant_log\")) {\n\t\t\tcase 1:\n\t\t\t\tconfig |= TOMOYO_CONFIG_WANT_GRANT_LOG;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tconfig &= ~TOMOYO_CONFIG_WANT_GRANT_LOG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (tomoyo_find_yesno(value, \"reject_log\")) {\n\t\t\tcase 1:\n\t\t\t\tconfig |= TOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tconfig &= ~TOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (i < TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX)\n\t\tprofile->config[i] = config;\n\telse if (config != TOMOYO_CONFIG_USE_DEFAULT)\n\t\tprofile->default_config = config;\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_set_uint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "568-574",
    "snippet": "static void tomoyo_set_uint(unsigned int *i, const char *string,\n\t\t\t    const char *find)\n{\n\tconst char *cp = strstr(string, find);\n\tif (cp)\n\t\tsscanf(cp + strlen(find), \"=%u\", i);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "cp + strlen(find)",
            "\"=%u\"",
            "i"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "find"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "string",
            "find"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_uint(unsigned int *i, const char *string,\n\t\t\t    const char *find)\n{\n\tconst char *cp = strstr(string, find);\n\tif (cp)\n\t\tsscanf(cp + strlen(find), \"=%u\", i);\n}"
  },
  {
    "function_name": "tomoyo_find_yesno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "546-557",
    "snippet": "static s8 tomoyo_find_yesno(const char *string, const char *find)\n{\n\tconst char *cp = strstr(string, find);\n\tif (cp) {\n\t\tcp += strlen(find);\n\t\tif (!strncmp(cp, \"=yes\", 4))\n\t\t\treturn 1;\n\t\telse if (!strncmp(cp, \"=no\", 3))\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cp",
            "\"=no\"",
            "3"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cp",
            "\"=yes\"",
            "4"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "find"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "string",
            "find"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic s8 tomoyo_find_yesno(const char *string, const char *find)\n{\n\tconst char *cp = strstr(string, find);\n\tif (cp) {\n\t\tcp += strlen(find);\n\t\tif (!strncmp(cp, \"=yes\", 4))\n\t\t\treturn 1;\n\t\telse if (!strncmp(cp, \"=no\", 3))\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "tomoyo_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "528-536",
    "snippet": "struct tomoyo_profile *tomoyo_profile(const struct tomoyo_policy_namespace *ns,\n\t\t\t\t      const u8 profile)\n{\n\tstatic struct tomoyo_profile tomoyo_null_profile;\n\tstruct tomoyo_profile *ptr = ns->profile_ptr[profile];\n\tif (!ptr)\n\t\tptr = &tomoyo_null_profile;\n\treturn ptr;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstruct tomoyo_profile *tomoyo_profile(const struct tomoyo_policy_namespace *ns,\n\t\t\t\t      const u8 profile)\n{\n\tstatic struct tomoyo_profile tomoyo_null_profile;\n\tstruct tomoyo_profile *ptr = ns->profile_ptr[profile];\n\tif (!ptr)\n\t\tptr = &tomoyo_null_profile;\n\treturn ptr;\n}"
  },
  {
    "function_name": "tomoyo_assign_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "485-518",
    "snippet": "static struct tomoyo_profile *tomoyo_assign_profile\n(struct tomoyo_policy_namespace *ns, const unsigned int profile)\n{\n\tstruct tomoyo_profile *ptr;\n\tstruct tomoyo_profile *entry;\n\tif (profile >= TOMOYO_MAX_PROFILES)\n\t\treturn NULL;\n\tptr = ns->profile_ptr[profile];\n\tif (ptr)\n\t\treturn ptr;\n\tentry = kzalloc(sizeof(*entry), GFP_NOFS);\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tptr = ns->profile_ptr[profile];\n\tif (!ptr && tomoyo_memory_ok(entry)) {\n\t\tptr = entry;\n\t\tptr->default_config = TOMOYO_CONFIG_DISABLED |\n\t\t\tTOMOYO_CONFIG_WANT_GRANT_LOG |\n\t\t\tTOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\tmemset(ptr->config, TOMOYO_CONFIG_USE_DEFAULT,\n\t\t       sizeof(ptr->config));\n\t\tptr->pref[TOMOYO_PREF_MAX_AUDIT_LOG] =\n\t\t\tCONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG;\n\t\tptr->pref[TOMOYO_PREF_MAX_LEARNING_ENTRY] =\n\t\t\tCONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY;\n\t\tmb(); /* Avoid out-of-order execution. */\n\t\tns->profile_ptr[profile] = ptr;\n\t\tentry = NULL;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n out:\n\tkfree(entry);\n\treturn ptr;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ptr->config",
            "TOMOYO_CONFIG_USE_DEFAULT",
            "sizeof(ptr->config)"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_memory_ok",
          "args": [
            "entry"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_memory_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "47-60",
          "snippet": "bool tomoyo_memory_ok(void *ptr)\n{\n\tif (ptr) {\n\t\tconst size_t s = ksize(ptr);\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] += s;\n\t\tif (!tomoyo_memory_quota[TOMOYO_MEMORY_POLICY] ||\n\t\t    tomoyo_memory_used[TOMOYO_MEMORY_POLICY] <=\n\t\t    tomoyo_memory_quota[TOMOYO_MEMORY_POLICY])\n\t\t\treturn true;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= s;\n\t}\n\ttomoyo_warn_oom(__func__);\n\treturn false;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];",
            "unsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nunsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];\nunsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];\n\nbool tomoyo_memory_ok(void *ptr)\n{\n\tif (ptr) {\n\t\tconst size_t s = ksize(ptr);\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] += s;\n\t\tif (!tomoyo_memory_quota[TOMOYO_MEMORY_POLICY] ||\n\t\t    tomoyo_memory_used[TOMOYO_MEMORY_POLICY] <=\n\t\t    tomoyo_memory_quota[TOMOYO_MEMORY_POLICY])\n\t\t\treturn true;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= s;\n\t}\n\ttomoyo_warn_oom(__func__);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*entry)",
            "GFP_NOFS"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic struct tomoyo_profile *tomoyo_assign_profile\n(struct tomoyo_policy_namespace *ns, const unsigned int profile)\n{\n\tstruct tomoyo_profile *ptr;\n\tstruct tomoyo_profile *entry;\n\tif (profile >= TOMOYO_MAX_PROFILES)\n\t\treturn NULL;\n\tptr = ns->profile_ptr[profile];\n\tif (ptr)\n\t\treturn ptr;\n\tentry = kzalloc(sizeof(*entry), GFP_NOFS);\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tptr = ns->profile_ptr[profile];\n\tif (!ptr && tomoyo_memory_ok(entry)) {\n\t\tptr = entry;\n\t\tptr->default_config = TOMOYO_CONFIG_DISABLED |\n\t\t\tTOMOYO_CONFIG_WANT_GRANT_LOG |\n\t\t\tTOMOYO_CONFIG_WANT_REJECT_LOG;\n\t\tmemset(ptr->config, TOMOYO_CONFIG_USE_DEFAULT,\n\t\t       sizeof(ptr->config));\n\t\tptr->pref[TOMOYO_PREF_MAX_AUDIT_LOG] =\n\t\t\tCONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG;\n\t\tptr->pref[TOMOYO_PREF_MAX_LEARNING_ENTRY] =\n\t\t\tCONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY;\n\t\tmb(); /* Avoid out-of-order execution. */\n\t\tns->profile_ptr[profile] = ptr;\n\t\tentry = NULL;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n out:\n\tkfree(entry);\n\treturn ptr;\n}"
  },
  {
    "function_name": "tomoyo_print_number_union",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "470-475",
    "snippet": "static void tomoyo_print_number_union(struct tomoyo_io_buffer *head,\n\t\t\t\t      const struct tomoyo_number_union *ptr)\n{\n\ttomoyo_set_space(head);\n\ttomoyo_print_number_union_nospace(head, ptr);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_print_number_union_nospace",
          "args": [
            "head",
            "ptr"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_number_union_nospace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "423-460",
          "snippet": "static void tomoyo_print_number_union_nospace\n(struct tomoyo_io_buffer *head, const struct tomoyo_number_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\tint i;\n\t\tunsigned long min = ptr->values[0];\n\t\tconst unsigned long max = ptr->values[1];\n\t\tu8 min_type = ptr->value_type[0];\n\t\tconst u8 max_type = ptr->value_type[1];\n\t\tchar buffer[128];\n\t\tbuffer[0] = '\\0';\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tswitch (min_type) {\n\t\t\tcase TOMOYO_VALUE_TYPE_HEXADECIMAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0x%lX\", min);\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_VALUE_TYPE_OCTAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0%lo\", min);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t min);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (min == max && min_type == max_type)\n\t\t\t\tbreak;\n\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"-\");\n\t\t\tmin_type = max_type;\n\t\t\tmin = max;\n\t\t}\n\t\ttomoyo_io_printf(head, \"%s\", buffer);\n\t}\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_print_number_union_nospace\n(struct tomoyo_io_buffer *head, const struct tomoyo_number_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\tint i;\n\t\tunsigned long min = ptr->values[0];\n\t\tconst unsigned long max = ptr->values[1];\n\t\tu8 min_type = ptr->value_type[0];\n\t\tconst u8 max_type = ptr->value_type[1];\n\t\tchar buffer[128];\n\t\tbuffer[0] = '\\0';\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tswitch (min_type) {\n\t\t\tcase TOMOYO_VALUE_TYPE_HEXADECIMAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0x%lX\", min);\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_VALUE_TYPE_OCTAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0%lo\", min);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t min);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (min == max && min_type == max_type)\n\t\t\t\tbreak;\n\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"-\");\n\t\t\tmin_type = max_type;\n\t\t\tmin = max;\n\t\t}\n\t\ttomoyo_io_printf(head, \"%s\", buffer);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_space",
          "args": [
            "head"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "302-305",
          "snippet": "static void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_print_number_union(struct tomoyo_io_buffer *head,\n\t\t\t\t      const struct tomoyo_number_union *ptr)\n{\n\ttomoyo_set_space(head);\n\ttomoyo_print_number_union_nospace(head, ptr);\n}"
  },
  {
    "function_name": "tomoyo_print_number_union_nospace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "423-460",
    "snippet": "static void tomoyo_print_number_union_nospace\n(struct tomoyo_io_buffer *head, const struct tomoyo_number_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\tint i;\n\t\tunsigned long min = ptr->values[0];\n\t\tconst unsigned long max = ptr->values[1];\n\t\tu8 min_type = ptr->value_type[0];\n\t\tconst u8 max_type = ptr->value_type[1];\n\t\tchar buffer[128];\n\t\tbuffer[0] = '\\0';\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tswitch (min_type) {\n\t\t\tcase TOMOYO_VALUE_TYPE_HEXADECIMAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0x%lX\", min);\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_VALUE_TYPE_OCTAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0%lo\", min);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t min);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (min == max && min_type == max_type)\n\t\t\t\tbreak;\n\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"-\");\n\t\t\tmin_type = max_type;\n\t\t\tmin = max;\n\t\t}\n\t\ttomoyo_io_printf(head, \"%s\", buffer);\n\t}\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_io_printf",
          "args": [
            "head",
            "\"%s\"",
            "buffer"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_io_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "275-293",
          "snippet": "static void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_addprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"-\""
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_addprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "196-203",
          "snippet": "static void tomoyo_addprintf(char *buffer, int len, const char *fmt, ...)\n{\n\tva_list args;\n\tconst int pos = strlen(buffer);\n\tva_start(args, fmt);\n\tvsnprintf(buffer + pos, len - pos - 1, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_addprintf(char *buffer, int len, const char *fmt, ...)\n{\n\tva_list args;\n\tconst int pos = strlen(buffer);\n\tva_start(args, fmt);\n\tvsnprintf(buffer + pos, len - pos - 1, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "ptr->group->group_name->name"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_print_number_union_nospace\n(struct tomoyo_io_buffer *head, const struct tomoyo_number_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\tint i;\n\t\tunsigned long min = ptr->values[0];\n\t\tconst unsigned long max = ptr->values[1];\n\t\tu8 min_type = ptr->value_type[0];\n\t\tconst u8 max_type = ptr->value_type[1];\n\t\tchar buffer[128];\n\t\tbuffer[0] = '\\0';\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tswitch (min_type) {\n\t\t\tcase TOMOYO_VALUE_TYPE_HEXADECIMAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0x%lX\", min);\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_VALUE_TYPE_OCTAL:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer),\n\t\t\t\t\t\t \"0%lo\", min);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t min);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (min == max && min_type == max_type)\n\t\t\t\tbreak;\n\t\t\ttomoyo_addprintf(buffer, sizeof(buffer), \"-\");\n\t\t\tmin_type = max_type;\n\t\t\tmin = max;\n\t\t}\n\t\ttomoyo_io_printf(head, \"%s\", buffer);\n\t}\n}"
  },
  {
    "function_name": "tomoyo_print_name_union_quoted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "402-413",
    "snippet": "static void tomoyo_print_name_union_quoted(struct tomoyo_io_buffer *head,\n\t\t\t\t\t   const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t\ttomoyo_set_string(head, ptr->filename->name);\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t}\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "\"\\\"\""
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_print_name_union_quoted(struct tomoyo_io_buffer *head,\n\t\t\t\t\t   const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t\ttomoyo_set_string(head, ptr->filename->name);\n\t\ttomoyo_set_string(head, \"\\\"\");\n\t}\n}"
  },
  {
    "function_name": "tomoyo_print_name_union",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "382-392",
    "snippet": "static void tomoyo_print_name_union(struct tomoyo_io_buffer *head,\n\t\t\t\t    const struct tomoyo_name_union *ptr)\n{\n\ttomoyo_set_space(head);\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\ttomoyo_set_string(head, ptr->filename->name);\n\t}\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "ptr->filename->name"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_space",
          "args": [
            "head"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "302-305",
          "snippet": "static void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_print_name_union(struct tomoyo_io_buffer *head,\n\t\t\t\t    const struct tomoyo_name_union *ptr)\n{\n\ttomoyo_set_space(head);\n\tif (ptr->group) {\n\t\ttomoyo_set_string(head, \"@\");\n\t\ttomoyo_set_string(head, ptr->group->group_name->name);\n\t} else {\n\t\ttomoyo_set_string(head, ptr->filename->name);\n\t}\n}"
  },
  {
    "function_name": "tomoyo_print_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "365-374",
    "snippet": "static void tomoyo_print_namespace(struct tomoyo_io_buffer *head)\n{\n\tif (!tomoyo_namespace_enabled)\n\t\treturn;\n\ttomoyo_set_string(head,\n\t\t\t  container_of(head->r.ns,\n\t\t\t\t       struct tomoyo_policy_namespace,\n\t\t\t\t       namespace_list)->name);\n\ttomoyo_set_space(head);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool tomoyo_namespace_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_space",
          "args": [
            "head"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "302-305",
          "snippet": "static void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "container_of(head->r.ns,\n\t\t\t\t       struct tomoyo_policy_namespace,\n\t\t\t\t       namespace_list)->name"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head->r.ns",
            "structtomoyo_policy_namespace",
            "namespace_list"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_namespace_enabled;\n\nstatic void tomoyo_print_namespace(struct tomoyo_io_buffer *head)\n{\n\tif (!tomoyo_namespace_enabled)\n\t\treturn;\n\ttomoyo_set_string(head,\n\t\t\t  container_of(head->r.ns,\n\t\t\t\t       struct tomoyo_policy_namespace,\n\t\t\t\t       namespace_list)->name);\n\ttomoyo_set_space(head);\n}"
  },
  {
    "function_name": "tomoyo_init_policy_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "344-356",
    "snippet": "void tomoyo_init_policy_namespace(struct tomoyo_policy_namespace *ns)\n{\n\tunsigned int idx;\n\tfor (idx = 0; idx < TOMOYO_MAX_ACL_GROUPS; idx++)\n\t\tINIT_LIST_HEAD(&ns->acl_group[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_GROUP; idx++)\n\t\tINIT_LIST_HEAD(&ns->group_list[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_POLICY; idx++)\n\t\tINIT_LIST_HEAD(&ns->policy_list[idx]);\n\tns->profile_version = 20110903;\n\ttomoyo_namespace_enabled = !list_empty(&tomoyo_namespace_list);\n\tlist_add_tail_rcu(&ns->namespace_list, &tomoyo_namespace_list);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool tomoyo_namespace_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&ns->namespace_list",
            "&tomoyo_namespace_list"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tomoyo_namespace_list"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ns->policy_list[idx]"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ns->group_list[idx]"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ns->acl_group[idx]"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_namespace_enabled;\n\nvoid tomoyo_init_policy_namespace(struct tomoyo_policy_namespace *ns)\n{\n\tunsigned int idx;\n\tfor (idx = 0; idx < TOMOYO_MAX_ACL_GROUPS; idx++)\n\t\tINIT_LIST_HEAD(&ns->acl_group[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_GROUP; idx++)\n\t\tINIT_LIST_HEAD(&ns->group_list[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_POLICY; idx++)\n\t\tINIT_LIST_HEAD(&ns->policy_list[idx]);\n\tns->profile_version = 20110903;\n\ttomoyo_namespace_enabled = !list_empty(&tomoyo_namespace_list);\n\tlist_add_tail_rcu(&ns->namespace_list, &tomoyo_namespace_list);\n}"
  },
  {
    "function_name": "tomoyo_set_slash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "327-330",
    "snippet": "static void tomoyo_set_slash(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"/\");\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "\"/\""
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_slash(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"/\");\n}"
  },
  {
    "function_name": "tomoyo_set_lf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "314-318",
    "snippet": "static bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "\"\\n\""
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_set_lf(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \"\\n\");\n\treturn !head->r.w_pos;\n}"
  },
  {
    "function_name": "tomoyo_set_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "302-305",
    "snippet": "static void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "\" \""
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_space(struct tomoyo_io_buffer *head)\n{\n\ttomoyo_set_string(head, \" \");\n}"
  },
  {
    "function_name": "tomoyo_io_printf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "275-293",
    "snippet": "static void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_set_string",
          "args": [
            "head",
            "head->read_buf + pos"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "257-264",
          "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "head->read_buf + pos",
            "size",
            "fmt",
            "args"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt,\n\t\t\t     ...)\n{\n\tva_list args;\n\tsize_t len;\n\tsize_t pos = head->r.avail;\n\tint size = head->readbuf_size - pos;\n\tif (size <= 0)\n\t\treturn;\n\tva_start(args, fmt);\n\tlen = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;\n\tva_end(args);\n\tif (pos + len >= head->readbuf_size) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\thead->r.avail += len;\n\ttomoyo_set_string(head, head->read_buf + pos);\n}"
  },
  {
    "function_name": "tomoyo_set_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "257-264",
    "snippet": "static void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_flush",
          "args": [
            "head"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "212-245",
          "snippet": "static bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_set_string(struct tomoyo_io_buffer *head, const char *string)\n{\n\tif (head->r.w_pos < TOMOYO_MAX_IO_READ_QUEUE) {\n\t\thead->r.w[head->r.w_pos++] = string;\n\t\ttomoyo_flush(head);\n\t} else\n\t\tWARN_ON(1);\n}"
  },
  {
    "function_name": "tomoyo_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "212-245",
    "snippet": "static bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "head->read_user_buf",
            "\"\"",
            "1"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "head->read_user_buf",
            "w",
            "len"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "w"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_flush(struct tomoyo_io_buffer *head)\n{\n\twhile (head->r.w_pos) {\n\t\tconst char *w = head->r.w[0];\n\t\tsize_t len = strlen(w);\n\t\tif (len) {\n\t\t\tif (len > head->read_user_buf_avail)\n\t\t\t\tlen = head->read_user_buf_avail;\n\t\t\tif (!len)\n\t\t\t\treturn false;\n\t\t\tif (copy_to_user(head->read_user_buf, w, len))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail -= len;\n\t\t\thead->read_user_buf += len;\n\t\t\tw += len;\n\t\t}\n\t\thead->r.w[0] = w;\n\t\tif (*w)\n\t\t\treturn false;\n\t\t/* Add '\\0' for audit logs and query. */\n\t\tif (head->poll) {\n\t\t\tif (!head->read_user_buf_avail ||\n\t\t\t    copy_to_user(head->read_user_buf, \"\", 1))\n\t\t\t\treturn false;\n\t\t\thead->read_user_buf_avail--;\n\t\t\thead->read_user_buf++;\n\t\t}\n\t\thead->r.w_pos--;\n\t\tfor (len = 0; len < head->r.w_pos; len++)\n\t\t\thead->r.w[len] = head->r.w[len + 1];\n\t}\n\thead->r.avail = 0;\n\treturn true;\n}"
  },
  {
    "function_name": "tomoyo_addprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "196-203",
    "snippet": "static void tomoyo_addprintf(char *buffer, int len, const char *fmt, ...)\n{\n\tva_list args;\n\tconst int pos = strlen(buffer);\n\tva_start(args, fmt);\n\tvsnprintf(buffer + pos, len - pos - 1, fmt, args);\n\tva_end(args);\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "buffer + pos",
            "len - pos - 1",
            "fmt",
            "args"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic void tomoyo_addprintf(char *buffer, int len, const char *fmt, ...)\n{\n\tva_list args;\n\tconst int pos = strlen(buffer);\n\tva_start(args, fmt);\n\tvsnprintf(buffer + pos, len - pos - 1, fmt, args);\n\tva_end(args);\n}"
  },
  {
    "function_name": "tomoyo_yesno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
    "lines": "182-185",
    "snippet": "const char *tomoyo_yesno(const unsigned int value)\n{\n\treturn value ? \"yes\" : \"no\";\n}",
    "includes": [
      "#include \"builtin-policy.h\"",
      "#include \"common.h\"",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char *tomoyo_yesno(const unsigned int value)\n{\n\treturn value ? \"yes\" : \"no\";\n}"
  }
]