[
  {
    "function_name": "compat_keyctl_dh_compute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/compat_dh.c",
    "lines": "20-40",
    "snippet": "long compat_keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t      char __user *buffer, size_t buflen,\n\t\t\t      struct compat_keyctl_kdf_params __user *kdf)\n{\n\tstruct keyctl_kdf_params kdfcopy;\n\tstruct compat_keyctl_kdf_params compat_kdfcopy;\n\n\tif (!kdf)\n\t\treturn __keyctl_dh_compute(params, buffer, buflen, NULL);\n\n\tif (copy_from_user(&compat_kdfcopy, kdf, sizeof(compat_kdfcopy)) != 0)\n\t\treturn -EFAULT;\n\n\tkdfcopy.hashname = compat_ptr(compat_kdfcopy.hashname);\n\tkdfcopy.otherinfo = compat_ptr(compat_kdfcopy.otherinfo);\n\tkdfcopy.otherinfolen = compat_kdfcopy.otherinfolen;\n\tmemcpy(kdfcopy.__spare, compat_kdfcopy.__spare,\n\t       sizeof(kdfcopy.__spare));\n\n\treturn __keyctl_dh_compute(params, buffer, buflen, &kdfcopy);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__keyctl_dh_compute",
          "args": [
            "params",
            "buffer",
            "buflen",
            "&kdfcopy"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "__keyctl_dh_compute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
          "lines": "239-420",
          "snippet": "long __keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t char __user *buffer, size_t buflen,\n\t\t\t struct keyctl_kdf_params *kdfcopy)\n{\n\tlong ret;\n\tssize_t dlen;\n\tint secretlen;\n\tint outlen;\n\tstruct keyctl_dh_params pcopy;\n\tstruct dh dh_inputs;\n\tstruct scatterlist outsg;\n\tstruct dh_completion compl;\n\tstruct crypto_kpp *tfm;\n\tstruct kpp_request *req;\n\tuint8_t *secret;\n\tuint8_t *outbuf;\n\tstruct kdf_sdesc *sdesc = NULL;\n\n\tif (!params || (!buffer && buflen)) {\n\t\tret = -EINVAL;\n\t\tgoto out1;\n\t}\n\tif (copy_from_user(&pcopy, params, sizeof(pcopy)) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto out1;\n\t}\n\n\tif (kdfcopy) {\n\t\tchar *hashname;\n\n\t\tif (memchr_inv(kdfcopy->__spare, 0, sizeof(kdfcopy->__spare))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out1;\n\t\t}\n\n\t\tif (buflen > KEYCTL_KDF_MAX_OUTPUT_LEN ||\n\t\t    kdfcopy->otherinfolen > KEYCTL_KDF_MAX_OI_LEN) {\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto out1;\n\t\t}\n\n\t\t/* get KDF name string */\n\t\thashname = strndup_user(kdfcopy->hashname, CRYPTO_MAX_ALG_NAME);\n\t\tif (IS_ERR(hashname)) {\n\t\t\tret = PTR_ERR(hashname);\n\t\t\tgoto out1;\n\t\t}\n\n\t\t/* allocate KDF from the kernel crypto API */\n\t\tret = kdf_alloc(&sdesc, hashname);\n\t\tkfree(hashname);\n\t\tif (ret)\n\t\t\tgoto out1;\n\t}\n\n\tmemset(&dh_inputs, 0, sizeof(dh_inputs));\n\n\tdlen = dh_data_from_key(pcopy.prime, &dh_inputs.p);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out1;\n\t}\n\tdh_inputs.p_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.base, &dh_inputs.g);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.g_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.private, &dh_inputs.key);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.key_size = dlen;\n\n\tsecretlen = crypto_dh_key_len(&dh_inputs);\n\tsecret = kmalloc(secretlen, GFP_KERNEL);\n\tif (!secret) {\n\t\tret = -ENOMEM;\n\t\tgoto out2;\n\t}\n\tret = crypto_dh_encode_key(secret, secretlen, &dh_inputs);\n\tif (ret)\n\t\tgoto out3;\n\n\ttfm = crypto_alloc_kpp(\"dh\", CRYPTO_ALG_TYPE_KPP, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto out3;\n\t}\n\n\tret = crypto_kpp_set_secret(tfm, secret, secretlen);\n\tif (ret)\n\t\tgoto out4;\n\n\toutlen = crypto_kpp_maxsize(tfm);\n\n\tif (!kdfcopy) {\n\t\t/*\n\t\t * When not using a KDF, buflen 0 is used to read the\n\t\t * required buffer length\n\t\t */\n\t\tif (buflen == 0) {\n\t\t\tret = outlen;\n\t\t\tgoto out4;\n\t\t} else if (outlen > buflen) {\n\t\t\tret = -EOVERFLOW;\n\t\t\tgoto out4;\n\t\t}\n\t}\n\n\toutbuf = kzalloc(kdfcopy ? (outlen + kdfcopy->otherinfolen) : outlen,\n\t\t\t GFP_KERNEL);\n\tif (!outbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out4;\n\t}\n\n\tsg_init_one(&outsg, outbuf, outlen);\n\n\treq = kpp_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto out5;\n\t}\n\n\tkpp_request_set_input(req, NULL, 0);\n\tkpp_request_set_output(req, &outsg, outlen);\n\tinit_completion(&compl.completion);\n\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t dh_crypto_done, &compl);\n\n\t/*\n\t * For DH, generate_public_key and generate_shared_secret are\n\t * the same calculation\n\t */\n\tret = crypto_kpp_generate_public_key(req);\n\tif (ret == -EINPROGRESS) {\n\t\twait_for_completion(&compl.completion);\n\t\tret = compl.err;\n\t\tif (ret)\n\t\t\tgoto out6;\n\t}\n\n\tif (kdfcopy) {\n\t\t/*\n\t\t * Concatenate SP800-56A otherinfo past DH shared secret -- the\n\t\t * input to the KDF is (DH shared secret || otherinfo)\n\t\t */\n\t\tif (copy_from_user(outbuf + req->dst_len, kdfcopy->otherinfo,\n\t\t\t\t   kdfcopy->otherinfolen) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out6;\n\t\t}\n\n\t\tret = keyctl_dh_compute_kdf(sdesc, buffer, buflen, outbuf,\n\t\t\t\t\t    req->dst_len + kdfcopy->otherinfolen,\n\t\t\t\t\t    outlen - req->dst_len);\n\t} else if (copy_to_user(buffer, outbuf, req->dst_len) == 0) {\n\t\tret = req->dst_len;\n\t} else {\n\t\tret = -EFAULT;\n\t}\n\nout6:\n\tkpp_request_free(req);\nout5:\n\tkzfree(outbuf);\nout4:\n\tcrypto_free_kpp(tfm);\nout3:\n\tkzfree(secret);\nout2:\n\tdh_free_data(&dh_inputs);\nout1:\n\tkdf_dealloc(sdesc);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/user-type.h>",
            "#include <crypto/dh.h>",
            "#include <crypto/kpp.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nlong __keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t char __user *buffer, size_t buflen,\n\t\t\t struct keyctl_kdf_params *kdfcopy)\n{\n\tlong ret;\n\tssize_t dlen;\n\tint secretlen;\n\tint outlen;\n\tstruct keyctl_dh_params pcopy;\n\tstruct dh dh_inputs;\n\tstruct scatterlist outsg;\n\tstruct dh_completion compl;\n\tstruct crypto_kpp *tfm;\n\tstruct kpp_request *req;\n\tuint8_t *secret;\n\tuint8_t *outbuf;\n\tstruct kdf_sdesc *sdesc = NULL;\n\n\tif (!params || (!buffer && buflen)) {\n\t\tret = -EINVAL;\n\t\tgoto out1;\n\t}\n\tif (copy_from_user(&pcopy, params, sizeof(pcopy)) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto out1;\n\t}\n\n\tif (kdfcopy) {\n\t\tchar *hashname;\n\n\t\tif (memchr_inv(kdfcopy->__spare, 0, sizeof(kdfcopy->__spare))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out1;\n\t\t}\n\n\t\tif (buflen > KEYCTL_KDF_MAX_OUTPUT_LEN ||\n\t\t    kdfcopy->otherinfolen > KEYCTL_KDF_MAX_OI_LEN) {\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto out1;\n\t\t}\n\n\t\t/* get KDF name string */\n\t\thashname = strndup_user(kdfcopy->hashname, CRYPTO_MAX_ALG_NAME);\n\t\tif (IS_ERR(hashname)) {\n\t\t\tret = PTR_ERR(hashname);\n\t\t\tgoto out1;\n\t\t}\n\n\t\t/* allocate KDF from the kernel crypto API */\n\t\tret = kdf_alloc(&sdesc, hashname);\n\t\tkfree(hashname);\n\t\tif (ret)\n\t\t\tgoto out1;\n\t}\n\n\tmemset(&dh_inputs, 0, sizeof(dh_inputs));\n\n\tdlen = dh_data_from_key(pcopy.prime, &dh_inputs.p);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out1;\n\t}\n\tdh_inputs.p_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.base, &dh_inputs.g);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.g_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.private, &dh_inputs.key);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.key_size = dlen;\n\n\tsecretlen = crypto_dh_key_len(&dh_inputs);\n\tsecret = kmalloc(secretlen, GFP_KERNEL);\n\tif (!secret) {\n\t\tret = -ENOMEM;\n\t\tgoto out2;\n\t}\n\tret = crypto_dh_encode_key(secret, secretlen, &dh_inputs);\n\tif (ret)\n\t\tgoto out3;\n\n\ttfm = crypto_alloc_kpp(\"dh\", CRYPTO_ALG_TYPE_KPP, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto out3;\n\t}\n\n\tret = crypto_kpp_set_secret(tfm, secret, secretlen);\n\tif (ret)\n\t\tgoto out4;\n\n\toutlen = crypto_kpp_maxsize(tfm);\n\n\tif (!kdfcopy) {\n\t\t/*\n\t\t * When not using a KDF, buflen 0 is used to read the\n\t\t * required buffer length\n\t\t */\n\t\tif (buflen == 0) {\n\t\t\tret = outlen;\n\t\t\tgoto out4;\n\t\t} else if (outlen > buflen) {\n\t\t\tret = -EOVERFLOW;\n\t\t\tgoto out4;\n\t\t}\n\t}\n\n\toutbuf = kzalloc(kdfcopy ? (outlen + kdfcopy->otherinfolen) : outlen,\n\t\t\t GFP_KERNEL);\n\tif (!outbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out4;\n\t}\n\n\tsg_init_one(&outsg, outbuf, outlen);\n\n\treq = kpp_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto out5;\n\t}\n\n\tkpp_request_set_input(req, NULL, 0);\n\tkpp_request_set_output(req, &outsg, outlen);\n\tinit_completion(&compl.completion);\n\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t dh_crypto_done, &compl);\n\n\t/*\n\t * For DH, generate_public_key and generate_shared_secret are\n\t * the same calculation\n\t */\n\tret = crypto_kpp_generate_public_key(req);\n\tif (ret == -EINPROGRESS) {\n\t\twait_for_completion(&compl.completion);\n\t\tret = compl.err;\n\t\tif (ret)\n\t\t\tgoto out6;\n\t}\n\n\tif (kdfcopy) {\n\t\t/*\n\t\t * Concatenate SP800-56A otherinfo past DH shared secret -- the\n\t\t * input to the KDF is (DH shared secret || otherinfo)\n\t\t */\n\t\tif (copy_from_user(outbuf + req->dst_len, kdfcopy->otherinfo,\n\t\t\t\t   kdfcopy->otherinfolen) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out6;\n\t\t}\n\n\t\tret = keyctl_dh_compute_kdf(sdesc, buffer, buflen, outbuf,\n\t\t\t\t\t    req->dst_len + kdfcopy->otherinfolen,\n\t\t\t\t\t    outlen - req->dst_len);\n\t} else if (copy_to_user(buffer, outbuf, req->dst_len) == 0) {\n\t\tret = req->dst_len;\n\t} else {\n\t\tret = -EFAULT;\n\t}\n\nout6:\n\tkpp_request_free(req);\nout5:\n\tkzfree(outbuf);\nout4:\n\tcrypto_free_kpp(tfm);\nout3:\n\tkzfree(secret);\nout2:\n\tdh_free_data(&dh_inputs);\nout1:\n\tkdf_dealloc(sdesc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kdfcopy.__spare",
            "compat_kdfcopy.__spare",
            "sizeof(kdfcopy.__spare)"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "compat_kdfcopy.otherinfo"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "compat_kdfcopy.hashname"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&compat_kdfcopy",
            "kdf",
            "sizeof(compat_kdfcopy)"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n\nlong compat_keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t      char __user *buffer, size_t buflen,\n\t\t\t      struct compat_keyctl_kdf_params __user *kdf)\n{\n\tstruct keyctl_kdf_params kdfcopy;\n\tstruct compat_keyctl_kdf_params compat_kdfcopy;\n\n\tif (!kdf)\n\t\treturn __keyctl_dh_compute(params, buffer, buflen, NULL);\n\n\tif (copy_from_user(&compat_kdfcopy, kdf, sizeof(compat_kdfcopy)) != 0)\n\t\treturn -EFAULT;\n\n\tkdfcopy.hashname = compat_ptr(compat_kdfcopy.hashname);\n\tkdfcopy.otherinfo = compat_ptr(compat_kdfcopy.otherinfo);\n\tkdfcopy.otherinfolen = compat_kdfcopy.otherinfolen;\n\tmemcpy(kdfcopy.__spare, compat_kdfcopy.__spare,\n\t       sizeof(kdfcopy.__spare));\n\n\treturn __keyctl_dh_compute(params, buffer, buflen, &kdfcopy);\n}"
  }
]