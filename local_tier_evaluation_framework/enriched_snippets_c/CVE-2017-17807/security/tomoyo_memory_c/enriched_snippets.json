[
  {
    "function_name": "tomoyo_mm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
    "lines": "191-202",
    "snippet": "void __init tomoyo_mm_init(void)\n{\n\tint idx;\n\tfor (idx = 0; idx < TOMOYO_MAX_HASH; idx++)\n\t\tINIT_LIST_HEAD(&tomoyo_name_list[idx]);\n\ttomoyo_kernel_namespace.name = \"<kernel>\";\n\ttomoyo_init_policy_namespace(&tomoyo_kernel_namespace);\n\ttomoyo_kernel_domain.ns = &tomoyo_kernel_namespace;\n\tINIT_LIST_HEAD(&tomoyo_kernel_domain.acl_info_list);\n\ttomoyo_kernel_domain.domainname = tomoyo_get_name(\"<kernel>\");\n\tlist_add_tail_rcu(&tomoyo_kernel_domain.list, &tomoyo_domain_list);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/slab.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];",
      "struct tomoyo_policy_namespace tomoyo_kernel_namespace;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&tomoyo_kernel_domain.list",
            "&tomoyo_domain_list"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_name",
          "args": [
            "\"<kernel>\""
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "148-183",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tomoyo_kernel_domain.acl_info_list"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_init_policy_namespace",
          "args": [
            "&tomoyo_kernel_namespace"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_init_policy_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "344-356",
          "snippet": "void tomoyo_init_policy_namespace(struct tomoyo_policy_namespace *ns)\n{\n\tunsigned int idx;\n\tfor (idx = 0; idx < TOMOYO_MAX_ACL_GROUPS; idx++)\n\t\tINIT_LIST_HEAD(&ns->acl_group[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_GROUP; idx++)\n\t\tINIT_LIST_HEAD(&ns->group_list[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_POLICY; idx++)\n\t\tINIT_LIST_HEAD(&ns->policy_list[idx]);\n\tns->profile_version = 20110903;\n\ttomoyo_namespace_enabled = !list_empty(&tomoyo_namespace_list);\n\tlist_add_tail_rcu(&ns->namespace_list, &tomoyo_namespace_list);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool tomoyo_namespace_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_namespace_enabled;\n\nvoid tomoyo_init_policy_namespace(struct tomoyo_policy_namespace *ns)\n{\n\tunsigned int idx;\n\tfor (idx = 0; idx < TOMOYO_MAX_ACL_GROUPS; idx++)\n\t\tINIT_LIST_HEAD(&ns->acl_group[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_GROUP; idx++)\n\t\tINIT_LIST_HEAD(&ns->group_list[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_POLICY; idx++)\n\t\tINIT_LIST_HEAD(&ns->policy_list[idx]);\n\tns->profile_version = 20110903;\n\ttomoyo_namespace_enabled = !list_empty(&tomoyo_namespace_list);\n\tlist_add_tail_rcu(&ns->namespace_list, &tomoyo_namespace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tomoyo_name_list[idx]"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\nstruct tomoyo_policy_namespace tomoyo_kernel_namespace;\n\nvoid __init tomoyo_mm_init(void)\n{\n\tint idx;\n\tfor (idx = 0; idx < TOMOYO_MAX_HASH; idx++)\n\t\tINIT_LIST_HEAD(&tomoyo_name_list[idx]);\n\ttomoyo_kernel_namespace.name = \"<kernel>\";\n\ttomoyo_init_policy_namespace(&tomoyo_kernel_namespace);\n\ttomoyo_kernel_domain.ns = &tomoyo_kernel_namespace;\n\tINIT_LIST_HEAD(&tomoyo_kernel_domain.acl_info_list);\n\ttomoyo_kernel_domain.domainname = tomoyo_get_name(\"<kernel>\");\n\tlist_add_tail_rcu(&tomoyo_kernel_domain.list, &tomoyo_domain_list);\n}"
  },
  {
    "function_name": "tomoyo_get_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
    "lines": "148-183",
    "snippet": "const struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/slab.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ptr"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ptr->head.list",
            "head"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_fill_path_info",
          "args": [
            "&ptr->entry"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_fill_path_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "643-652",
          "snippet": "void tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ptr->head.users",
            "1"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(char *) ptr->entry.name",
            "name",
            "len"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_memory_ok",
          "args": [
            "ptr"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_memory_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "47-60",
          "snippet": "bool tomoyo_memory_ok(void *ptr)\n{\n\tif (ptr) {\n\t\tconst size_t s = ksize(ptr);\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] += s;\n\t\tif (!tomoyo_memory_quota[TOMOYO_MEMORY_POLICY] ||\n\t\t    tomoyo_memory_used[TOMOYO_MEMORY_POLICY] <=\n\t\t    tomoyo_memory_quota[TOMOYO_MEMORY_POLICY])\n\t\t\treturn true;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= s;\n\t}\n\ttomoyo_warn_oom(__func__);\n\treturn false;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];",
            "unsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nunsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];\nunsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];\n\nbool tomoyo_memory_ok(void *ptr)\n{\n\tif (ptr) {\n\t\tconst size_t s = ksize(ptr);\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] += s;\n\t\tif (!tomoyo_memory_quota[TOMOYO_MEMORY_POLICY] ||\n\t\t    tomoyo_memory_used[TOMOYO_MEMORY_POLICY] <=\n\t\t    tomoyo_memory_quota[TOMOYO_MEMORY_POLICY])\n\t\t\treturn true;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= s;\n\t}\n\ttomoyo_warn_oom(__func__);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ptr) + len",
            "GFP_NOFS"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ptr->head.users"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ptr->head.users"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "ptr->entry.name"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ptr",
            "head",
            "head.list"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_long",
          "args": [
            "hash",
            "TOMOYO_HASH_BITS"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "NULL",
            "(const unsigned char *) name",
            "len - 1"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}"
  },
  {
    "function_name": "tomoyo_get_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
    "lines": "93-131",
    "snippet": "struct tomoyo_group *tomoyo_get_group(struct tomoyo_acl_param *param,\n\t\t\t\t      const u8 idx)\n{\n\tstruct tomoyo_group e = { };\n\tstruct tomoyo_group *group = NULL;\n\tstruct list_head *list;\n\tconst char *group_name = tomoyo_read_token(param);\n\tbool found = false;\n\tif (!tomoyo_correct_word(group_name) || idx >= TOMOYO_MAX_GROUP)\n\t\treturn NULL;\n\te.group_name = tomoyo_get_name(group_name);\n\tif (!e.group_name)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist = &param->ns->group_list[idx];\n\tlist_for_each_entry(group, list, head.list) {\n\t\tif (e.group_name != group->group_name ||\n\t\t    atomic_read(&group->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&group->head.users);\n\t\tfound = true;\n\t\tbreak;\n\t}\n\tif (!found) {\n\t\tstruct tomoyo_group *entry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->member_list);\n\t\t\tatomic_set(&entry->head.users, 1);\n\t\t\tlist_add_tail_rcu(&entry->head.list, list);\n\t\t\tgroup = entry;\n\t\t\tfound = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.group_name);\n\treturn found ? group : NULL;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/slab.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "e.group_name"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&entry->head.list",
            "list"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&entry->head.users",
            "1"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->member_list"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_commit_ok",
          "args": [
            "&e",
            "sizeof(e)"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_commit_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "73-83",
          "snippet": "void *tomoyo_commit_ok(void *data, const unsigned int size)\n{\n\tvoid *ptr = kzalloc(size, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tmemmove(ptr, data, size);\n\t\tmemset(data, 0, size);\n\t\treturn ptr;\n\t}\n\tkfree(ptr);\n\treturn NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nvoid *tomoyo_commit_ok(void *data, const unsigned int size)\n{\n\tvoid *ptr = kzalloc(size, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tmemmove(ptr, data, size);\n\t\tmemset(data, 0, size);\n\t\treturn ptr;\n\t}\n\tkfree(ptr);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&group->head.users"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&group->head.users"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "group",
            "list",
            "head.list"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_name",
          "args": [
            "group_name"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "148-183",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_correct_word",
          "args": [
            "group_name"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_correct_word",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "502-505",
          "snippet": "bool tomoyo_correct_word(const char *string)\n{\n\treturn tomoyo_correct_word2(string, strlen(string));\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_correct_word(const char *string)\n{\n\treturn tomoyo_correct_word2(string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_token",
          "args": [
            "param"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "131-141",
          "snippet": "char *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nchar *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct tomoyo_group *tomoyo_get_group(struct tomoyo_acl_param *param,\n\t\t\t\t      const u8 idx)\n{\n\tstruct tomoyo_group e = { };\n\tstruct tomoyo_group *group = NULL;\n\tstruct list_head *list;\n\tconst char *group_name = tomoyo_read_token(param);\n\tbool found = false;\n\tif (!tomoyo_correct_word(group_name) || idx >= TOMOYO_MAX_GROUP)\n\t\treturn NULL;\n\te.group_name = tomoyo_get_name(group_name);\n\tif (!e.group_name)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist = &param->ns->group_list[idx];\n\tlist_for_each_entry(group, list, head.list) {\n\t\tif (e.group_name != group->group_name ||\n\t\t    atomic_read(&group->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&group->head.users);\n\t\tfound = true;\n\t\tbreak;\n\t}\n\tif (!found) {\n\t\tstruct tomoyo_group *entry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->member_list);\n\t\t\tatomic_set(&entry->head.users, 1);\n\t\t\tlist_add_tail_rcu(&entry->head.list, list);\n\t\t\tgroup = entry;\n\t\t\tfound = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.group_name);\n\treturn found ? group : NULL;\n}"
  },
  {
    "function_name": "tomoyo_commit_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
    "lines": "73-83",
    "snippet": "void *tomoyo_commit_ok(void *data, const unsigned int size)\n{\n\tvoid *ptr = kzalloc(size, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tmemmove(ptr, data, size);\n\t\tmemset(data, 0, size);\n\t\treturn ptr;\n\t}\n\tkfree(ptr);\n\treturn NULL;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/slab.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ptr"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "size"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ptr",
            "data",
            "size"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_memory_ok",
          "args": [
            "ptr"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_memory_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "47-60",
          "snippet": "bool tomoyo_memory_ok(void *ptr)\n{\n\tif (ptr) {\n\t\tconst size_t s = ksize(ptr);\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] += s;\n\t\tif (!tomoyo_memory_quota[TOMOYO_MEMORY_POLICY] ||\n\t\t    tomoyo_memory_used[TOMOYO_MEMORY_POLICY] <=\n\t\t    tomoyo_memory_quota[TOMOYO_MEMORY_POLICY])\n\t\t\treturn true;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= s;\n\t}\n\ttomoyo_warn_oom(__func__);\n\treturn false;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];",
            "unsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nunsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];\nunsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];\n\nbool tomoyo_memory_ok(void *ptr)\n{\n\tif (ptr) {\n\t\tconst size_t s = ksize(ptr);\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] += s;\n\t\tif (!tomoyo_memory_quota[TOMOYO_MEMORY_POLICY] ||\n\t\t    tomoyo_memory_used[TOMOYO_MEMORY_POLICY] <=\n\t\t    tomoyo_memory_quota[TOMOYO_MEMORY_POLICY])\n\t\t\treturn true;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= s;\n\t}\n\ttomoyo_warn_oom(__func__);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_NOFS"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nvoid *tomoyo_commit_ok(void *data, const unsigned int size)\n{\n\tvoid *ptr = kzalloc(size, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tmemmove(ptr, data, size);\n\t\tmemset(data, 0, size);\n\t\treturn ptr;\n\t}\n\tkfree(ptr);\n\treturn NULL;\n}"
  },
  {
    "function_name": "tomoyo_memory_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
    "lines": "47-60",
    "snippet": "bool tomoyo_memory_ok(void *ptr)\n{\n\tif (ptr) {\n\t\tconst size_t s = ksize(ptr);\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] += s;\n\t\tif (!tomoyo_memory_quota[TOMOYO_MEMORY_POLICY] ||\n\t\t    tomoyo_memory_used[TOMOYO_MEMORY_POLICY] <=\n\t\t    tomoyo_memory_quota[TOMOYO_MEMORY_POLICY])\n\t\t\treturn true;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= s;\n\t}\n\ttomoyo_warn_oom(__func__);\n\treturn false;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/slab.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];",
      "unsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_warn_oom",
          "args": [
            "__func__"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_warn_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "17-29",
          "snippet": "void tomoyo_warn_oom(const char *function)\n{\n\t/* Reduce error messages. */\n\tstatic pid_t tomoyo_last_pid;\n\tconst pid_t pid = current->pid;\n\tif (tomoyo_last_pid != pid) {\n\t\tprintk(KERN_WARNING \"ERROR: Out of memory at %s.\\n\",\n\t\t       function);\n\t\ttomoyo_last_pid = pid;\n\t}\n\tif (!tomoyo_policy_loaded)\n\t\tpanic(\"MAC Initialization failed.\\n\");\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nvoid tomoyo_warn_oom(const char *function)\n{\n\t/* Reduce error messages. */\n\tstatic pid_t tomoyo_last_pid;\n\tconst pid_t pid = current->pid;\n\tif (tomoyo_last_pid != pid) {\n\t\tprintk(KERN_WARNING \"ERROR: Out of memory at %s.\\n\",\n\t\t       function);\n\t\ttomoyo_last_pid = pid;\n\t}\n\tif (!tomoyo_policy_loaded)\n\t\tpanic(\"MAC Initialization failed.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ksize",
          "args": [
            "ptr"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nunsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];\nunsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];\n\nbool tomoyo_memory_ok(void *ptr)\n{\n\tif (ptr) {\n\t\tconst size_t s = ksize(ptr);\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] += s;\n\t\tif (!tomoyo_memory_quota[TOMOYO_MEMORY_POLICY] ||\n\t\t    tomoyo_memory_used[TOMOYO_MEMORY_POLICY] <=\n\t\t    tomoyo_memory_quota[TOMOYO_MEMORY_POLICY])\n\t\t\treturn true;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= s;\n\t}\n\ttomoyo_warn_oom(__func__);\n\treturn false;\n}"
  },
  {
    "function_name": "tomoyo_warn_oom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
    "lines": "17-29",
    "snippet": "void tomoyo_warn_oom(const char *function)\n{\n\t/* Reduce error messages. */\n\tstatic pid_t tomoyo_last_pid;\n\tconst pid_t pid = current->pid;\n\tif (tomoyo_last_pid != pid) {\n\t\tprintk(KERN_WARNING \"ERROR: Out of memory at %s.\\n\",\n\t\t       function);\n\t\ttomoyo_last_pid = pid;\n\t}\n\tif (!tomoyo_policy_loaded)\n\t\tpanic(\"MAC Initialization failed.\\n\");\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/slab.h>",
      "#include <linux/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"MAC Initialization failed.\\n\""
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"ERROR: Out of memory at %s.\\n\"",
            "function"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nvoid tomoyo_warn_oom(const char *function)\n{\n\t/* Reduce error messages. */\n\tstatic pid_t tomoyo_last_pid;\n\tconst pid_t pid = current->pid;\n\tif (tomoyo_last_pid != pid) {\n\t\tprintk(KERN_WARNING \"ERROR: Out of memory at %s.\\n\",\n\t\t       function);\n\t\ttomoyo_last_pid = pid;\n\t}\n\tif (!tomoyo_policy_loaded)\n\t\tpanic(\"MAC Initialization failed.\\n\");\n}"
  }
]