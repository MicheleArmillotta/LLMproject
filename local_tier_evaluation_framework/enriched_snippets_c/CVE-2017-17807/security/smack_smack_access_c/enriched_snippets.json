[
  {
    "function_name": "smack_privileged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "632-664",
    "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "sklep",
            "&smack_onlycap_list",
            "list"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&smack_onlycap_list"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_capable",
          "args": [
            "current_cred()",
            "&init_user_ns",
            "cap",
            "SECURITY_CAP_AUDIT"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "cap_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "71-107",
          "snippet": "int cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, int audit)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t/* See if cred has the capability in the target user namespace\n\t * by examining the target user namespace and all of the target\n\t * user namespace's parents.\n\t */\n\tfor (;;) {\n\t\t/* Do we have the necessary capabilities? */\n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t/*\n\t\t * If we're already at a lower level than we're looking for,\n\t\t * we're done searching.\n\t\t */\n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t/* \n\t\t * The owner of the user namespace in the parent of the\n\t\t * user namespace has all caps.\n\t\t */\n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If you have a capability in a parent user ns, then you have\n\t\t * it over all children user namespaces as well.\n\t\t */\n\t\tns = ns->parent;\n\t}\n\n\t/* We never get here */\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_capable(const struct cred *cred, struct user_namespace *targ_ns,\n\t\tint cap, int audit)\n{\n\tstruct user_namespace *ns = targ_ns;\n\n\t/* See if cred has the capability in the target user namespace\n\t * by examining the target user namespace and all of the target\n\t * user namespace's parents.\n\t */\n\tfor (;;) {\n\t\t/* Do we have the necessary capabilities? */\n\t\tif (ns == cred->user_ns)\n\t\t\treturn cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;\n\n\t\t/*\n\t\t * If we're already at a lower level than we're looking for,\n\t\t * we're done searching.\n\t\t */\n\t\tif (ns->level <= cred->user_ns->level)\n\t\t\treturn -EPERM;\n\n\t\t/* \n\t\t * The owner of the user namespace in the parent of the\n\t\t * user namespace has all caps.\n\t\t */\n\t\tif ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If you have a capability in a parent user ns, then you have\n\t\t * it over all children user namespaces as well.\n\t\t */\n\t\tns = ns->parent;\n\t}\n\n\t/* We never get here */\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->flags & PF_KTHREAD"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
  },
  {
    "function_name": "smack_from_secid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "596-614",
    "snippet": "struct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "skp",
            "&smack_known_list",
            "list"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};\n\nstruct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}"
  },
  {
    "function_name": "smk_import_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "526-587",
    "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 smack_next_secid = 10;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&smack_known_lock"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "smack"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "skp"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_insert_entry",
          "args": [
            "skp"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "smk_insert_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "406-416",
          "snippet": "void smk_insert_entry(struct smack_known *skp)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\n\thash = full_name_hash(NULL, skp->smk_known, strlen(skp->smk_known));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_add_head_rcu(&skp->smk_hashed, head);\n\tlist_add_rcu(&skp->list, &smack_known_list);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct hlist_head smack_known_hash[SMACK_HASH_SLOTS];\n\nvoid smk_insert_entry(struct smack_known *skp)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\n\thash = full_name_hash(NULL, skp->smk_known, strlen(skp->smk_known));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_add_head_rcu(&skp->smk_hashed, head);\n\tlist_add_rcu(&skp->list, &smack_known_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&skp->smk_rules_lock"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&skp->smk_rules"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_netlbl_mls",
          "args": [
            "smack_cipso_mapped",
            "(char *)&skp->smk_secid",
            "&skp->smk_netlabel",
            "sizeof(skp->smk_secid)"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "smk_netlbl_mls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "489-515",
          "snippet": "int smk_netlbl_mls(int level, char *catset, struct netlbl_lsm_secattr *sap,\n\t\t\tint len)\n{\n\tunsigned char *cp;\n\tunsigned char m;\n\tint cat;\n\tint rc;\n\tint byte;\n\n\tsap->flags |= NETLBL_SECATTR_MLS_CAT;\n\tsap->attr.mls.lvl = level;\n\tsap->attr.mls.cat = NULL;\n\n\tfor (cat = 1, cp = catset, byte = 0; byte < len; cp++, byte++)\n\t\tfor (m = 0x80; m != 0; m >>= 1, cat++) {\n\t\t\tif ((m & *cp) == 0)\n\t\t\t\tcontinue;\n\t\t\trc = netlbl_catmap_setbit(&sap->attr.mls.cat,\n\t\t\t\t\t\t  cat, GFP_KERNEL);\n\t\t\tif (rc < 0) {\n\t\t\t\tnetlbl_catmap_free(sap->attr.mls.cat);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_netlbl_mls(int level, char *catset, struct netlbl_lsm_secattr *sap,\n\t\t\tint len)\n{\n\tunsigned char *cp;\n\tunsigned char m;\n\tint cat;\n\tint rc;\n\tint byte;\n\n\tsap->flags |= NETLBL_SECATTR_MLS_CAT;\n\tsap->attr.mls.lvl = level;\n\tsap->attr.mls.cat = NULL;\n\n\tfor (cat = 1, cp = catset, byte = 0; byte < len; cp++, byte++)\n\t\tfor (m = 0x80; m != 0; m >>= 1, cat++) {\n\t\t\tif ((m & *cp) == 0)\n\t\t\t\tcontinue;\n\t\t\trc = netlbl_catmap_setbit(&sap->attr.mls.cat,\n\t\t\t\t\t\t  cat, GFP_KERNEL);\n\t\t\tif (rc < 0) {\n\t\t\t\tnetlbl_catmap_free(sap->attr.mls.cat);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "smack"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*skp)",
            "GFP_KERNEL"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_find_entry",
          "args": [
            "smack"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "smk_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "425-439",
          "snippet": "struct smack_known *smk_find_entry(const char *string)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\tstruct smack_known *skp;\n\n\thash = full_name_hash(NULL, string, strlen(string));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_for_each_entry_rcu(skp, head, smk_hashed)\n\t\tif (strcmp(skp->smk_known, string) == 0)\n\t\t\treturn skp;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct hlist_head smack_known_hash[SMACK_HASH_SLOTS];\n\nstruct smack_known *smk_find_entry(const char *string)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\tstruct smack_known *skp;\n\n\thash = full_name_hash(NULL, string, strlen(string));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_for_each_entry_rcu(skp, head, smk_hashed)\n\t\tif (strcmp(skp->smk_known, string) == 0)\n\t\t\treturn skp;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&smack_known_lock"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "smack"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "smack"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_parse_smack",
          "args": [
            "string",
            "len"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "smk_parse_smack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "448-479",
          "snippet": "char *smk_parse_smack(const char *string, int len)\n{\n\tchar *smack;\n\tint i;\n\n\tif (len <= 0)\n\t\tlen = strlen(string) + 1;\n\n\t/*\n\t * Reserve a leading '-' as an indicator that\n\t * this isn't a label, but an option to interfaces\n\t * including /smack/cipso and /smack/cipso2\n\t */\n\tif (string[0] == '-')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < len; i++)\n\t\tif (string[i] > '~' || string[i] <= ' ' || string[i] == '/' ||\n\t\t    string[i] == '\"' || string[i] == '\\\\' || string[i] == '\\'')\n\t\t\tbreak;\n\n\tif (i == 0 || i >= SMK_LONGLABEL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsmack = kzalloc(i + 1, GFP_KERNEL);\n\tif (smack == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(smack, string, i);\n\n\treturn smack;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nchar *smk_parse_smack(const char *string, int len)\n{\n\tchar *smack;\n\tint i;\n\n\tif (len <= 0)\n\t\tlen = strlen(string) + 1;\n\n\t/*\n\t * Reserve a leading '-' as an indicator that\n\t * this isn't a label, but an option to interfaces\n\t * including /smack/cipso and /smack/cipso2\n\t */\n\tif (string[0] == '-')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < len; i++)\n\t\tif (string[i] > '~' || string[i] <= ' ' || string[i] == '/' ||\n\t\t    string[i] == '\"' || string[i] == '\\\\' || string[i] == '\\'')\n\t\t\tbreak;\n\n\tif (i == 0 || i >= SMK_LONGLABEL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsmack = kzalloc(i + 1, GFP_KERNEL);\n\tif (smack == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(smack, string, i);\n\n\treturn smack;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
  },
  {
    "function_name": "smk_netlbl_mls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "489-515",
    "snippet": "int smk_netlbl_mls(int level, char *catset, struct netlbl_lsm_secattr *sap,\n\t\t\tint len)\n{\n\tunsigned char *cp;\n\tunsigned char m;\n\tint cat;\n\tint rc;\n\tint byte;\n\n\tsap->flags |= NETLBL_SECATTR_MLS_CAT;\n\tsap->attr.mls.lvl = level;\n\tsap->attr.mls.cat = NULL;\n\n\tfor (cat = 1, cp = catset, byte = 0; byte < len; cp++, byte++)\n\t\tfor (m = 0x80; m != 0; m >>= 1, cat++) {\n\t\t\tif ((m & *cp) == 0)\n\t\t\t\tcontinue;\n\t\t\trc = netlbl_catmap_setbit(&sap->attr.mls.cat,\n\t\t\t\t\t\t  cat, GFP_KERNEL);\n\t\t\tif (rc < 0) {\n\t\t\t\tnetlbl_catmap_free(sap->attr.mls.cat);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_catmap_free",
          "args": [
            "sap->attr.mls.cat"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_catmap_setbit",
          "args": [
            "&sap->attr.mls.cat",
            "cat",
            "GFP_KERNEL"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_netlbl_mls(int level, char *catset, struct netlbl_lsm_secattr *sap,\n\t\t\tint len)\n{\n\tunsigned char *cp;\n\tunsigned char m;\n\tint cat;\n\tint rc;\n\tint byte;\n\n\tsap->flags |= NETLBL_SECATTR_MLS_CAT;\n\tsap->attr.mls.lvl = level;\n\tsap->attr.mls.cat = NULL;\n\n\tfor (cat = 1, cp = catset, byte = 0; byte < len; cp++, byte++)\n\t\tfor (m = 0x80; m != 0; m >>= 1, cat++) {\n\t\t\tif ((m & *cp) == 0)\n\t\t\t\tcontinue;\n\t\t\trc = netlbl_catmap_setbit(&sap->attr.mls.cat,\n\t\t\t\t\t\t  cat, GFP_KERNEL);\n\t\t\tif (rc < 0) {\n\t\t\t\tnetlbl_catmap_free(sap->attr.mls.cat);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_parse_smack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "448-479",
    "snippet": "char *smk_parse_smack(const char *string, int len)\n{\n\tchar *smack;\n\tint i;\n\n\tif (len <= 0)\n\t\tlen = strlen(string) + 1;\n\n\t/*\n\t * Reserve a leading '-' as an indicator that\n\t * this isn't a label, but an option to interfaces\n\t * including /smack/cipso and /smack/cipso2\n\t */\n\tif (string[0] == '-')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < len; i++)\n\t\tif (string[i] > '~' || string[i] <= ' ' || string[i] == '/' ||\n\t\t    string[i] == '\"' || string[i] == '\\\\' || string[i] == '\\'')\n\t\t\tbreak;\n\n\tif (i == 0 || i >= SMK_LONGLABEL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsmack = kzalloc(i + 1, GFP_KERNEL);\n\tif (smack == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(smack, string, i);\n\n\treturn smack;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "smack",
            "string",
            "i"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "i + 1",
            "GFP_KERNEL"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "string"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nchar *smk_parse_smack(const char *string, int len)\n{\n\tchar *smack;\n\tint i;\n\n\tif (len <= 0)\n\t\tlen = strlen(string) + 1;\n\n\t/*\n\t * Reserve a leading '-' as an indicator that\n\t * this isn't a label, but an option to interfaces\n\t * including /smack/cipso and /smack/cipso2\n\t */\n\tif (string[0] == '-')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < len; i++)\n\t\tif (string[i] > '~' || string[i] <= ' ' || string[i] == '/' ||\n\t\t    string[i] == '\"' || string[i] == '\\\\' || string[i] == '\\'')\n\t\t\tbreak;\n\n\tif (i == 0 || i >= SMK_LONGLABEL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsmack = kzalloc(i + 1, GFP_KERNEL);\n\tif (smack == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(smack, string, i);\n\n\treturn smack;\n}"
  },
  {
    "function_name": "smk_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "425-439",
    "snippet": "struct smack_known *smk_find_entry(const char *string)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\tstruct smack_known *skp;\n\n\thash = full_name_hash(NULL, string, strlen(string));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_for_each_entry_rcu(skp, head, smk_hashed)\n\t\tif (strcmp(skp->smk_known, string) == 0)\n\t\t\treturn skp;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "skp->smk_known",
            "string"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "skp",
            "head",
            "smk_hashed"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "NULL",
            "string",
            "strlen(string)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "string"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct hlist_head smack_known_hash[SMACK_HASH_SLOTS];\n\nstruct smack_known *smk_find_entry(const char *string)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\tstruct smack_known *skp;\n\n\thash = full_name_hash(NULL, string, strlen(string));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_for_each_entry_rcu(skp, head, smk_hashed)\n\t\tif (strcmp(skp->smk_known, string) == 0)\n\t\t\treturn skp;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "smk_insert_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "406-416",
    "snippet": "void smk_insert_entry(struct smack_known *skp)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\n\thash = full_name_hash(NULL, skp->smk_known, strlen(skp->smk_known));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_add_head_rcu(&skp->smk_hashed, head);\n\tlist_add_rcu(&skp->list, &smack_known_list);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&skp->list",
            "&smack_known_list"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&skp->smk_hashed",
            "head"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "NULL",
            "skp->smk_known",
            "strlen(skp->smk_known)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "skp->smk_known"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct hlist_head smack_known_hash[SMACK_HASH_SLOTS];\n\nvoid smk_insert_entry(struct smack_known *skp)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\n\thash = full_name_hash(NULL, skp->smk_known, strlen(skp->smk_known));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_add_head_rcu(&skp->smk_hashed, head);\n\tlist_add_rcu(&skp->list, &smack_known_list);\n}"
  },
  {
    "function_name": "smack_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "391-394",
    "snippet": "void smack_log(char *subject_label, char *object_label, int request,\n               int result, struct smk_audit_info *ad)\n{\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid smack_log(char *subject_label, char *object_label, int request,\n               int result, struct smk_audit_info *ad)\n{\n}"
  },
  {
    "function_name": "smack_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "344-389",
    "snippet": "void smack_log(char *subject_label, char *object_label, int request,\n\t       int result, struct smk_audit_info *ad)\n{\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tchar request_buffer[SMK_NUM_ACCESS_TYPE + 5];\n#else\n\tchar request_buffer[SMK_NUM_ACCESS_TYPE + 1];\n#endif\n\tstruct smack_audit_data *sad;\n\tstruct common_audit_data *a = &ad->a;\n\n\t/* check if we have to log the current event */\n\tif (result < 0 && (log_policy & SMACK_AUDIT_DENIED) == 0)\n\t\treturn;\n\tif (result == 0 && (log_policy & SMACK_AUDIT_ACCEPT) == 0)\n\t\treturn;\n\n\tsad = a->smack_audit_data;\n\n\tif (sad->function == NULL)\n\t\tsad->function = \"unknown\";\n\n\t/* end preparing the audit data */\n\tsmack_str_from_perm(request_buffer, request);\n\tsad->subject = subject_label;\n\tsad->object  = object_label;\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * The result may be positive in bringup mode.\n\t * A positive result is an allow, but not for normal reasons.\n\t * Mark it as successful, but don't filter it out even if\n\t * the logging policy says to do so.\n\t */\n\tif (result == SMACK_UNCONFINED_SUBJECT)\n\t\tstrcat(request_buffer, \"(US)\");\n\telse if (result == SMACK_UNCONFINED_OBJECT)\n\t\tstrcat(request_buffer, \"(UO)\");\n\n\tif (result > 0)\n\t\tresult = 0;\n#endif\n\tsad->request = request_buffer;\n\tsad->result  = result;\n\n\tcommon_lsm_audit(a, smack_log_callback, NULL);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int log_policy = SMACK_AUDIT_DENIED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_lsm_audit",
          "args": [
            "a",
            "smack_log_callback",
            "NULL"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "common_lsm_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/lsm_audit.c",
          "lines": "441-465",
          "snippet": "void common_lsm_audit(struct common_audit_data *a,\n\tvoid (*pre_audit)(struct audit_buffer *, void *),\n\tvoid (*post_audit)(struct audit_buffer *, void *))\n{\n\tstruct audit_buffer *ab;\n\n\tif (a == NULL)\n\t\treturn;\n\t/* we use GFP_ATOMIC so we won't sleep */\n\tab = audit_log_start(current->audit_context, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t     AUDIT_AVC);\n\n\tif (ab == NULL)\n\t\treturn;\n\n\tif (pre_audit)\n\t\tpre_audit(ab, a);\n\n\tdump_common_audit_data(ab, a);\n\n\tif (post_audit)\n\t\tpost_audit(ab, a);\n\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/sctp.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <linux/ip.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/sctp.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nvoid common_lsm_audit(struct common_audit_data *a,\n\tvoid (*pre_audit)(struct audit_buffer *, void *),\n\tvoid (*post_audit)(struct audit_buffer *, void *))\n{\n\tstruct audit_buffer *ab;\n\n\tif (a == NULL)\n\t\treturn;\n\t/* we use GFP_ATOMIC so we won't sleep */\n\tab = audit_log_start(current->audit_context, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t     AUDIT_AVC);\n\n\tif (ab == NULL)\n\t\treturn;\n\n\tif (pre_audit)\n\t\tpre_audit(ab, a);\n\n\tdump_common_audit_data(ab, a);\n\n\tif (post_audit)\n\t\tpost_audit(ab, a);\n\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "request_buffer",
            "\"(UO)\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "request_buffer",
            "\"(US)\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_str_from_perm",
          "args": [
            "request_buffer",
            "request"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "smack_str_from_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "291-308",
          "snippet": "static inline void smack_str_from_perm(char *string, int access)\n{\n\tint i = 0;\n\n\tif (access & MAY_READ)\n\t\tstring[i++] = 'r';\n\tif (access & MAY_WRITE)\n\t\tstring[i++] = 'w';\n\tif (access & MAY_EXEC)\n\t\tstring[i++] = 'x';\n\tif (access & MAY_APPEND)\n\t\tstring[i++] = 'a';\n\tif (access & MAY_TRANSMUTE)\n\t\tstring[i++] = 't';\n\tif (access & MAY_LOCK)\n\t\tstring[i++] = 'l';\n\tstring[i] = '\\0';\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline void smack_str_from_perm(char *string, int access)\n{\n\tint i = 0;\n\n\tif (access & MAY_READ)\n\t\tstring[i++] = 'r';\n\tif (access & MAY_WRITE)\n\t\tstring[i++] = 'w';\n\tif (access & MAY_EXEC)\n\t\tstring[i++] = 'x';\n\tif (access & MAY_APPEND)\n\t\tstring[i++] = 'a';\n\tif (access & MAY_TRANSMUTE)\n\t\tstring[i++] = 't';\n\tif (access & MAY_LOCK)\n\t\tstring[i++] = 'l';\n\tstring[i] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint log_policy = SMACK_AUDIT_DENIED;\n\nvoid smack_log(char *subject_label, char *object_label, int request,\n\t       int result, struct smk_audit_info *ad)\n{\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tchar request_buffer[SMK_NUM_ACCESS_TYPE + 5];\n#else\n\tchar request_buffer[SMK_NUM_ACCESS_TYPE + 1];\n#endif\n\tstruct smack_audit_data *sad;\n\tstruct common_audit_data *a = &ad->a;\n\n\t/* check if we have to log the current event */\n\tif (result < 0 && (log_policy & SMACK_AUDIT_DENIED) == 0)\n\t\treturn;\n\tif (result == 0 && (log_policy & SMACK_AUDIT_ACCEPT) == 0)\n\t\treturn;\n\n\tsad = a->smack_audit_data;\n\n\tif (sad->function == NULL)\n\t\tsad->function = \"unknown\";\n\n\t/* end preparing the audit data */\n\tsmack_str_from_perm(request_buffer, request);\n\tsad->subject = subject_label;\n\tsad->object  = object_label;\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * The result may be positive in bringup mode.\n\t * A positive result is an allow, but not for normal reasons.\n\t * Mark it as successful, but don't filter it out even if\n\t * the logging policy says to do so.\n\t */\n\tif (result == SMACK_UNCONFINED_SUBJECT)\n\t\tstrcat(request_buffer, \"(US)\");\n\telse if (result == SMACK_UNCONFINED_OBJECT)\n\t\tstrcat(request_buffer, \"(UO)\");\n\n\tif (result > 0)\n\t\tresult = 0;\n#endif\n\tsad->request = request_buffer;\n\tsad->result  = result;\n\n\tcommon_lsm_audit(a, smack_log_callback, NULL);\n}"
  },
  {
    "function_name": "smack_log_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "316-331",
    "snippet": "static void smack_log_callback(struct audit_buffer *ab, void *a)\n{\n\tstruct common_audit_data *ad = a;\n\tstruct smack_audit_data *sad = ad->smack_audit_data;\n\taudit_log_format(ab, \"lsm=SMACK fn=%s action=%s\",\n\t\t\t ad->smack_audit_data->function,\n\t\t\t sad->result ? \"denied\" : \"granted\");\n\taudit_log_format(ab, \" subject=\");\n\taudit_log_untrustedstring(ab, sad->subject);\n\taudit_log_format(ab, \" object=\");\n\taudit_log_untrustedstring(ab, sad->object);\n\tif (sad->request[0] == '\\0')\n\t\taudit_log_format(ab, \" labels_differ\");\n\telse\n\t\taudit_log_format(ab, \" requested=%s\", sad->request);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" requested=%s\"",
            "sad->request"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" labels_differ\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "sad->object"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" object=\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "sad->subject"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" subject=\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"lsm=SMACK fn=%s action=%s\"",
            "ad->smack_audit_data->function",
            "sad->result ? \"denied\" : \"granted\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void smack_log_callback(struct audit_buffer *ab, void *a)\n{\n\tstruct common_audit_data *ad = a;\n\tstruct smack_audit_data *sad = ad->smack_audit_data;\n\taudit_log_format(ab, \"lsm=SMACK fn=%s action=%s\",\n\t\t\t ad->smack_audit_data->function,\n\t\t\t sad->result ? \"denied\" : \"granted\");\n\taudit_log_format(ab, \" subject=\");\n\taudit_log_untrustedstring(ab, sad->subject);\n\taudit_log_format(ab, \" object=\");\n\taudit_log_untrustedstring(ab, sad->object);\n\tif (sad->request[0] == '\\0')\n\t\taudit_log_format(ab, \" labels_differ\");\n\telse\n\t\taudit_log_format(ab, \" requested=%s\", sad->request);\n}"
  },
  {
    "function_name": "smack_str_from_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "291-308",
    "snippet": "static inline void smack_str_from_perm(char *string, int access)\n{\n\tint i = 0;\n\n\tif (access & MAY_READ)\n\t\tstring[i++] = 'r';\n\tif (access & MAY_WRITE)\n\t\tstring[i++] = 'w';\n\tif (access & MAY_EXEC)\n\t\tstring[i++] = 'x';\n\tif (access & MAY_APPEND)\n\t\tstring[i++] = 'a';\n\tif (access & MAY_TRANSMUTE)\n\t\tstring[i++] = 't';\n\tif (access & MAY_LOCK)\n\t\tstring[i++] = 'l';\n\tstring[i] = '\\0';\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline void smack_str_from_perm(char *string, int access)\n{\n\tint i = 0;\n\n\tif (access & MAY_READ)\n\t\tstring[i++] = 'r';\n\tif (access & MAY_WRITE)\n\t\tstring[i++] = 'w';\n\tif (access & MAY_EXEC)\n\t\tstring[i++] = 'x';\n\tif (access & MAY_APPEND)\n\t\tstring[i++] = 'a';\n\tif (access & MAY_TRANSMUTE)\n\t\tstring[i++] = 't';\n\tif (access & MAY_LOCK)\n\t\tstring[i++] = 'l';\n\tstring[i] = '\\0';\n}"
  },
  {
    "function_name": "smk_curacc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "275-281",
    "snippet": "int smk_curacc(struct smack_known *obj_known,\n\t       u32 mode, struct smk_audit_info *a)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_tskacc(tsp, obj_known, mode, a);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_tskacc",
          "args": [
            "tsp",
            "obj_known",
            "mode",
            "a"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "smk_tskacc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "223-262",
          "snippet": "int smk_tskacc(struct task_smack *tsp, struct smack_known *obj_known,\n\t       u32 mode, struct smk_audit_info *a)\n{\n\tstruct smack_known *sbj_known = smk_of_task(tsp);\n\tint may;\n\tint rc;\n\n\t/*\n\t * Check the global rule list\n\t */\n\trc = smk_access(sbj_known, obj_known, mode, NULL);\n\tif (rc >= 0) {\n\t\t/*\n\t\t * If there is an entry in the task's rule list\n\t\t * it can further restrict access.\n\t\t */\n\t\tmay = smk_access_entry(sbj_known->smk_known,\n\t\t\t\t       obj_known->smk_known,\n\t\t\t\t       &tsp->smk_rules);\n\t\tif (may < 0)\n\t\t\tgoto out_audit;\n\t\tif ((mode & may) == mode)\n\t\t\tgoto out_audit;\n\t\trc = -EACCES;\n\t}\n\n\t/*\n\t * Allow for priviliged to override policy.\n\t */\n\tif (rc != 0 && smack_privileged(CAP_MAC_OVERRIDE))\n\t\trc = 0;\n\nout_audit:\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(sbj_known->smk_known, obj_known->smk_known,\n\t\t\t  mode, rc, a);\n#endif\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_tskacc(struct task_smack *tsp, struct smack_known *obj_known,\n\t       u32 mode, struct smk_audit_info *a)\n{\n\tstruct smack_known *sbj_known = smk_of_task(tsp);\n\tint may;\n\tint rc;\n\n\t/*\n\t * Check the global rule list\n\t */\n\trc = smk_access(sbj_known, obj_known, mode, NULL);\n\tif (rc >= 0) {\n\t\t/*\n\t\t * If there is an entry in the task's rule list\n\t\t * it can further restrict access.\n\t\t */\n\t\tmay = smk_access_entry(sbj_known->smk_known,\n\t\t\t\t       obj_known->smk_known,\n\t\t\t\t       &tsp->smk_rules);\n\t\tif (may < 0)\n\t\t\tgoto out_audit;\n\t\tif ((mode & may) == mode)\n\t\t\tgoto out_audit;\n\t\trc = -EACCES;\n\t}\n\n\t/*\n\t * Allow for priviliged to override policy.\n\t */\n\tif (rc != 0 && smack_privileged(CAP_MAC_OVERRIDE))\n\t\trc = 0;\n\nout_audit:\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(sbj_known->smk_known, obj_known->smk_known,\n\t\t\t  mode, rc, a);\n#endif\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_curacc(struct smack_known *obj_known,\n\t       u32 mode, struct smk_audit_info *a)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_tskacc(tsp, obj_known, mode, a);\n}"
  },
  {
    "function_name": "smk_tskacc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "223-262",
    "snippet": "int smk_tskacc(struct task_smack *tsp, struct smack_known *obj_known,\n\t       u32 mode, struct smk_audit_info *a)\n{\n\tstruct smack_known *sbj_known = smk_of_task(tsp);\n\tint may;\n\tint rc;\n\n\t/*\n\t * Check the global rule list\n\t */\n\trc = smk_access(sbj_known, obj_known, mode, NULL);\n\tif (rc >= 0) {\n\t\t/*\n\t\t * If there is an entry in the task's rule list\n\t\t * it can further restrict access.\n\t\t */\n\t\tmay = smk_access_entry(sbj_known->smk_known,\n\t\t\t\t       obj_known->smk_known,\n\t\t\t\t       &tsp->smk_rules);\n\t\tif (may < 0)\n\t\t\tgoto out_audit;\n\t\tif ((mode & may) == mode)\n\t\t\tgoto out_audit;\n\t\trc = -EACCES;\n\t}\n\n\t/*\n\t * Allow for priviliged to override policy.\n\t */\n\tif (rc != 0 && smack_privileged(CAP_MAC_OVERRIDE))\n\t\trc = 0;\n\nout_audit:\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(sbj_known->smk_known, obj_known->smk_known,\n\t\t\t  mode, rc, a);\n#endif\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smack_log",
          "args": [
            "sbj_known->smk_known",
            "obj_known->smk_known",
            "mode",
            "rc",
            "a"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "smack_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "391-394",
          "snippet": "void smack_log(char *subject_label, char *object_label, int request,\n               int result, struct smk_audit_info *ad)\n{\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid smack_log(char *subject_label, char *object_label, int request,\n               int result, struct smk_audit_info *ad)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_OVERRIDE"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_access_entry",
          "args": [
            "sbj_known->smk_known",
            "obj_known->smk_known",
            "&tsp->smk_rules"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "85-105",
          "snippet": "int smk_access_entry(char *subject_label, char *object_label,\n\t\t\tstruct list_head *rule_list)\n{\n\tint may = -ENOENT;\n\tstruct smack_rule *srp;\n\n\tlist_for_each_entry_rcu(srp, rule_list, list) {\n\t\tif (srp->smk_object->smk_known == object_label &&\n\t\t    srp->smk_subject->smk_known == subject_label) {\n\t\t\tmay = srp->smk_access;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * MAY_WRITE implies MAY_LOCK.\n\t */\n\tif ((may & MAY_WRITE) == MAY_WRITE)\n\t\tmay |= MAY_LOCK;\n\treturn may;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_access_entry(char *subject_label, char *object_label,\n\t\t\tstruct list_head *rule_list)\n{\n\tint may = -ENOENT;\n\tstruct smack_rule *srp;\n\n\tlist_for_each_entry_rcu(srp, rule_list, list) {\n\t\tif (srp->smk_object->smk_known == object_label &&\n\t\t    srp->smk_subject->smk_known == subject_label) {\n\t\t\tmay = srp->smk_access;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * MAY_WRITE implies MAY_LOCK.\n\t */\n\tif ((may & MAY_WRITE) == MAY_WRITE)\n\t\tmay |= MAY_LOCK;\n\treturn may;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_access",
          "args": [
            "sbj_known",
            "obj_known",
            "mode",
            "NULL"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "120-209",
          "snippet": "int smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};",
            "struct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};",
            "struct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};",
            "struct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_task",
          "args": [
            "tsp"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "384-392",
          "snippet": "static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_tskacc(struct task_smack *tsp, struct smack_known *obj_known,\n\t       u32 mode, struct smk_audit_info *a)\n{\n\tstruct smack_known *sbj_known = smk_of_task(tsp);\n\tint may;\n\tint rc;\n\n\t/*\n\t * Check the global rule list\n\t */\n\trc = smk_access(sbj_known, obj_known, mode, NULL);\n\tif (rc >= 0) {\n\t\t/*\n\t\t * If there is an entry in the task's rule list\n\t\t * it can further restrict access.\n\t\t */\n\t\tmay = smk_access_entry(sbj_known->smk_known,\n\t\t\t\t       obj_known->smk_known,\n\t\t\t\t       &tsp->smk_rules);\n\t\tif (may < 0)\n\t\t\tgoto out_audit;\n\t\tif ((mode & may) == mode)\n\t\t\tgoto out_audit;\n\t\trc = -EACCES;\n\t}\n\n\t/*\n\t * Allow for priviliged to override policy.\n\t */\n\tif (rc != 0 && smack_privileged(CAP_MAC_OVERRIDE))\n\t\trc = 0;\n\nout_audit:\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(sbj_known->smk_known, obj_known->smk_known,\n\t\t\t  mode, rc, a);\n#endif\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "120-209",
    "snippet": "int smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};",
      "struct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};",
      "struct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};",
      "struct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smack_log",
          "args": [
            "subject->smk_known",
            "object->smk_known",
            "request",
            "rc",
            "a"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "smack_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "391-394",
          "snippet": "void smack_log(char *subject_label, char *object_label, int request,\n               int result, struct smk_audit_info *ad)\n{\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid smack_log(char *subject_label, char *object_label, int request,\n               int result, struct smk_audit_info *ad)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_access_entry",
          "args": [
            "subject->smk_known",
            "object->smk_known",
            "&subject->smk_rules"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "85-105",
          "snippet": "int smk_access_entry(char *subject_label, char *object_label,\n\t\t\tstruct list_head *rule_list)\n{\n\tint may = -ENOENT;\n\tstruct smack_rule *srp;\n\n\tlist_for_each_entry_rcu(srp, rule_list, list) {\n\t\tif (srp->smk_object->smk_known == object_label &&\n\t\t    srp->smk_subject->smk_known == subject_label) {\n\t\t\tmay = srp->smk_access;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * MAY_WRITE implies MAY_LOCK.\n\t */\n\tif ((may & MAY_WRITE) == MAY_WRITE)\n\t\tmay |= MAY_LOCK;\n\treturn may;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_access_entry(char *subject_label, char *object_label,\n\t\t\tstruct list_head *rule_list)\n{\n\tint may = -ENOENT;\n\tstruct smack_rule *srp;\n\n\tlist_for_each_entry_rcu(srp, rule_list, list) {\n\t\tif (srp->smk_object->smk_known == object_label &&\n\t\t    srp->smk_subject->smk_known == subject_label) {\n\t\t\tmay = srp->smk_access;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * MAY_WRITE implies MAY_LOCK.\n\t */\n\tif ((may & MAY_WRITE) == MAY_WRITE)\n\t\tmay |= MAY_LOCK;\n\treturn may;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_access_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
    "lines": "85-105",
    "snippet": "int smk_access_entry(char *subject_label, char *object_label,\n\t\t\tstruct list_head *rule_list)\n{\n\tint may = -ENOENT;\n\tstruct smack_rule *srp;\n\n\tlist_for_each_entry_rcu(srp, rule_list, list) {\n\t\tif (srp->smk_object->smk_known == object_label &&\n\t\t    srp->smk_subject->smk_known == subject_label) {\n\t\t\tmay = srp->smk_access;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * MAY_WRITE implies MAY_LOCK.\n\t */\n\tif ((may & MAY_WRITE) == MAY_WRITE)\n\t\tmay |= MAY_LOCK;\n\treturn may;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "srp",
            "rule_list",
            "list"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_access_entry(char *subject_label, char *object_label,\n\t\t\tstruct list_head *rule_list)\n{\n\tint may = -ENOENT;\n\tstruct smack_rule *srp;\n\n\tlist_for_each_entry_rcu(srp, rule_list, list) {\n\t\tif (srp->smk_object->smk_known == object_label &&\n\t\t    srp->smk_subject->smk_known == subject_label) {\n\t\t\tmay = srp->smk_access;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * MAY_WRITE implies MAY_LOCK.\n\t */\n\tif ((may & MAY_WRITE) == MAY_WRITE)\n\t\tmay |= MAY_LOCK;\n\treturn may;\n}"
  }
]