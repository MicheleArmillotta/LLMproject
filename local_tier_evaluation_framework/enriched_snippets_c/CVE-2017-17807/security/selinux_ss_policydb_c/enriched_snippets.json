[
  {
    "function_name": "policydb_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "3404-3535",
    "snippet": "int policydb_write(struct policydb *p, void *fp)\n{\n\tunsigned int i, num_syms;\n\tint rc;\n\t__le32 buf[4];\n\tu32 config;\n\tsize_t len;\n\tstruct policydb_compat_info *info;\n\n\t/*\n\t * refuse to write policy older than compressed avtab\n\t * to simplify the writer.  There are other tests dropped\n\t * since we assume this throughout the writer code.  Be\n\t * careful if you ever try to remove this restriction\n\t */\n\tif (p->policyvers < POLICYDB_VERSION_AVTAB) {\n\t\tprintk(KERN_ERR \"SELinux: refusing to write policy version %d.\"\n\t\t       \"  Because it is less than version %d\\n\", p->policyvers,\n\t\t       POLICYDB_VERSION_AVTAB);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig = 0;\n\tif (p->mls_enabled)\n\t\tconfig |= POLICYDB_CONFIG_MLS;\n\n\tif (p->reject_unknown)\n\t\tconfig |= REJECT_UNKNOWN;\n\tif (p->allow_unknown)\n\t\tconfig |= ALLOW_UNKNOWN;\n\n\t/* Write the magic number and string identifiers. */\n\tbuf[0] = cpu_to_le32(POLICYDB_MAGIC);\n\tlen = strlen(POLICYDB_STRING);\n\tbuf[1] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\trc = put_entry(POLICYDB_STRING, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Write the version, config, and table sizes. */\n\tinfo = policydb_lookup_compat(p->policyvers);\n\tif (!info) {\n\t\tprintk(KERN_ERR \"SELinux: compatibility lookup failed for policy \"\n\t\t    \"version %d\", p->policyvers);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf[0] = cpu_to_le32(p->policyvers);\n\tbuf[1] = cpu_to_le32(config);\n\tbuf[2] = cpu_to_le32(info->sym_num);\n\tbuf[3] = cpu_to_le32(info->ocon_num);\n\n\trc = put_entry(buf, sizeof(u32), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (p->policyvers >= POLICYDB_VERSION_POLCAP) {\n\t\trc = ebitmap_write(&p->policycaps, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_PERMISSIVE) {\n\t\trc = ebitmap_write(&p->permissive_map, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tnum_syms = info->sym_num;\n\tfor (i = 0; i < num_syms; i++) {\n\t\tstruct policy_data pd;\n\n\t\tpd.fp = fp;\n\t\tpd.p = p;\n\n\t\tbuf[0] = cpu_to_le32(p->symtab[i].nprim);\n\t\tbuf[1] = cpu_to_le32(p->symtab[i].table->nel);\n\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = hashtab_map(p->symtab[i].table, write_f[i], &pd);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = avtab_write(p, &p->te_avtab, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cond_write_list(p, p->cond_list, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = role_trans_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = role_allow_write(p->role_allow, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = filename_trans_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ocontext_write(p, info, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = genfs_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = range_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\tstruct ebitmap *e = flex_array_get(p->type_attr_map_array, i);\n\n\t\tBUG_ON(!e);\n\t\trc = ebitmap_write(e, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int (*write_f[SYM_NUM]) (void *key, void *datum,\n\t\t\t\tvoid *datap) =\n{\n\tcommon_write,\n\tclass_write,\n\trole_write,\n\ttype_write,\n\tuser_write,\n\tcond_write_bool,\n\tsens_write,\n\tcat_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_write",
          "args": [
            "e",
            "fp"
          ],
          "line": 3529
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "451-524",
          "snippet": "int ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nint ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!e"
          ],
          "line": 3528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get",
          "args": [
            "p->type_attr_map_array",
            "i"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_write",
          "args": [
            "p",
            "fp"
          ],
          "line": 3521
        },
        "resolved": true,
        "details": {
          "function_name": "range_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "3314-3340",
          "snippet": "static int range_write(struct policydb *p, void *fp)\n{\n\t__le32 buf[1];\n\tint rc, nel;\n\tstruct policy_data pd;\n\n\tpd.p = p;\n\tpd.fp = fp;\n\n\t/* count the number of entries in the hashtab */\n\tnel = 0;\n\trc = hashtab_map(p->range_tr, hashtab_cnt, &nel);\n\tif (rc)\n\t\treturn rc;\n\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* actually write all of the entries */\n\trc = hashtab_map(p->range_tr, range_write_helper, &pd);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int range_write(struct policydb *p, void *fp)\n{\n\t__le32 buf[1];\n\tint rc, nel;\n\tstruct policy_data pd;\n\n\tpd.p = p;\n\tpd.fp = fp;\n\n\t/* count the number of entries in the hashtab */\n\tnel = 0;\n\trc = hashtab_map(p->range_tr, hashtab_cnt, &nel);\n\tif (rc)\n\t\treturn rc;\n\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* actually write all of the entries */\n\trc = hashtab_map(p->range_tr, range_write_helper, &pd);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "genfs_write",
          "args": [
            "p",
            "fp"
          ],
          "line": 3517
        },
        "resolved": true,
        "details": {
          "function_name": "genfs_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "3226-3276",
          "snippet": "static int genfs_write(struct policydb *p, void *fp)\n{\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tsize_t len;\n\t__le32 buf[1];\n\tint rc;\n\n\tlen = 0;\n\tfor (genfs = p->genfs; genfs; genfs = genfs->next)\n\t\tlen++;\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (genfs = p->genfs; genfs; genfs = genfs->next) {\n\t\tlen = strlen(genfs->fstype);\n\t\tbuf[0] = cpu_to_le32(len);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = put_entry(genfs->fstype, 1, len, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tlen = 0;\n\t\tfor (c = genfs->head; c; c = c->next)\n\t\t\tlen++;\n\t\tbuf[0] = cpu_to_le32(len);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (c = genfs->head; c; c = c->next) {\n\t\t\tlen = strlen(c->u.name);\n\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbuf[0] = cpu_to_le32(c->v.sclass);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int genfs_write(struct policydb *p, void *fp)\n{\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tsize_t len;\n\t__le32 buf[1];\n\tint rc;\n\n\tlen = 0;\n\tfor (genfs = p->genfs; genfs; genfs = genfs->next)\n\t\tlen++;\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (genfs = p->genfs; genfs; genfs = genfs->next) {\n\t\tlen = strlen(genfs->fstype);\n\t\tbuf[0] = cpu_to_le32(len);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = put_entry(genfs->fstype, 1, len, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tlen = 0;\n\t\tfor (c = genfs->head; c; c = c->next)\n\t\t\tlen++;\n\t\tbuf[0] = cpu_to_le32(len);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (c = genfs->head; c; c = c->next) {\n\t\t\tlen = strlen(c->u.name);\n\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbuf[0] = cpu_to_le32(c->v.sclass);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocontext_write",
          "args": [
            "p",
            "info",
            "fp"
          ],
          "line": 3513
        },
        "resolved": true,
        "details": {
          "function_name": "ocontext_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "3102-3224",
          "snippet": "static int ocontext_write(struct policydb *p, struct policydb_compat_info *info,\n\t\t\t  void *fp)\n{\n\tunsigned int i, j, rc;\n\tsize_t nel, len;\n\t__le32 buf[3];\n\tu32 nodebuf[8];\n\tstruct ocontext *c;\n\tfor (i = 0; i < info->ocon_num; i++) {\n\t\tnel = 0;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next)\n\t\t\tnel++;\n\t\tbuf[0] = cpu_to_le32(nel);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next) {\n\t\t\tswitch (i) {\n\t\t\tcase OCON_ISID:\n\t\t\t\tbuf[0] = cpu_to_le32(c->sid[0]);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FS:\n\t\t\tcase OCON_NETIF:\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[1], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_PORT:\n\t\t\t\tbuf[0] = cpu_to_le32(c->u.port.protocol);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.port.low_port);\n\t\t\t\tbuf[2] = cpu_to_le32(c->u.port.high_port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE:\n\t\t\t\tnodebuf[0] = c->u.node.addr; /* network order */\n\t\t\t\tnodebuf[1] = c->u.node.mask; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FSUSE:\n\t\t\t\tbuf[0] = cpu_to_le32(c->v.behavior);\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[1] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE6:\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j] = c->u.node6.addr[j]; /* network order */\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j + 4] = c->u.node6.mask[j]; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 8, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBPKEY:\n\t\t\t\t*((__be64 *)nodebuf) = cpu_to_be64(c->u.ibpkey.subnet_prefix);\n\n\t\t\t\tnodebuf[2] = cpu_to_le32(c->u.ibpkey.low_pkey);\n\t\t\t\tnodebuf[3] = cpu_to_le32(c->u.ibpkey.high_pkey);\n\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 4, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBENDPORT:\n\t\t\t\tlen = strlen(c->u.ibendport.dev_name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.ibendport.port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.ibendport.dev_name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int ocontext_write(struct policydb *p, struct policydb_compat_info *info,\n\t\t\t  void *fp)\n{\n\tunsigned int i, j, rc;\n\tsize_t nel, len;\n\t__le32 buf[3];\n\tu32 nodebuf[8];\n\tstruct ocontext *c;\n\tfor (i = 0; i < info->ocon_num; i++) {\n\t\tnel = 0;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next)\n\t\t\tnel++;\n\t\tbuf[0] = cpu_to_le32(nel);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next) {\n\t\t\tswitch (i) {\n\t\t\tcase OCON_ISID:\n\t\t\t\tbuf[0] = cpu_to_le32(c->sid[0]);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FS:\n\t\t\tcase OCON_NETIF:\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[1], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_PORT:\n\t\t\t\tbuf[0] = cpu_to_le32(c->u.port.protocol);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.port.low_port);\n\t\t\t\tbuf[2] = cpu_to_le32(c->u.port.high_port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE:\n\t\t\t\tnodebuf[0] = c->u.node.addr; /* network order */\n\t\t\t\tnodebuf[1] = c->u.node.mask; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FSUSE:\n\t\t\t\tbuf[0] = cpu_to_le32(c->v.behavior);\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[1] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE6:\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j] = c->u.node6.addr[j]; /* network order */\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j + 4] = c->u.node6.mask[j]; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 8, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBPKEY:\n\t\t\t\t*((__be64 *)nodebuf) = cpu_to_be64(c->u.ibpkey.subnet_prefix);\n\n\t\t\t\tnodebuf[2] = cpu_to_le32(c->u.ibpkey.low_pkey);\n\t\t\t\tnodebuf[3] = cpu_to_le32(c->u.ibpkey.high_pkey);\n\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 4, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBENDPORT:\n\t\t\t\tlen = strlen(c->u.ibendport.dev_name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.ibendport.port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.ibendport.dev_name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filename_trans_write",
          "args": [
            "p",
            "fp"
          ],
          "line": 3509
        },
        "resolved": true,
        "details": {
          "function_name": "filename_trans_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "3373-3397",
          "snippet": "static int filename_trans_write(struct policydb *p, void *fp)\n{\n\tu32 nel;\n\t__le32 buf[1];\n\tint rc;\n\n\tif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\n\t\treturn 0;\n\n\tnel = 0;\n\trc = hashtab_map(p->filename_trans, hashtab_cnt, &nel);\n\tif (rc)\n\t\treturn rc;\n\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(p->filename_trans, filename_write_helper, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int filename_trans_write(struct policydb *p, void *fp)\n{\n\tu32 nel;\n\t__le32 buf[1];\n\tint rc;\n\n\tif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\n\t\treturn 0;\n\n\tnel = 0;\n\trc = hashtab_map(p->filename_trans, hashtab_cnt, &nel);\n\tif (rc)\n\t\treturn rc;\n\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(p->filename_trans, filename_write_helper, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "role_allow_write",
          "args": [
            "p->role_allow",
            "fp"
          ],
          "line": 3505
        },
        "resolved": true,
        "details": {
          "function_name": "role_allow_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "2708-2730",
          "snippet": "static int role_allow_write(struct role_allow *r, void *fp)\n{\n\tstruct role_allow *ra;\n\tu32 buf[2];\n\tsize_t nel;\n\tint rc;\n\n\tnel = 0;\n\tfor (ra = r; ra; ra = ra->next)\n\t\tnel++;\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (ra = r; ra; ra = ra->next) {\n\t\tbuf[0] = cpu_to_le32(ra->role);\n\t\tbuf[1] = cpu_to_le32(ra->new_role);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int role_allow_write(struct role_allow *r, void *fp)\n{\n\tstruct role_allow *ra;\n\tu32 buf[2];\n\tsize_t nel;\n\tint rc;\n\n\tnel = 0;\n\tfor (ra = r; ra; ra = ra->next)\n\t\tnel++;\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (ra = r; ra; ra = ra->next) {\n\t\tbuf[0] = cpu_to_le32(ra->role);\n\t\tbuf[1] = cpu_to_le32(ra->new_role);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "role_trans_write",
          "args": [
            "p",
            "fp"
          ],
          "line": 3501
        },
        "resolved": true,
        "details": {
          "function_name": "role_trans_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "2675-2706",
          "snippet": "static int role_trans_write(struct policydb *p, void *fp)\n{\n\tstruct role_trans *r = p->role_tr;\n\tstruct role_trans *tr;\n\tu32 buf[3];\n\tsize_t nel;\n\tint rc;\n\n\tnel = 0;\n\tfor (tr = r; tr; tr = tr->next)\n\t\tnel++;\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (tr = r; tr; tr = tr->next) {\n\t\tbuf[0] = cpu_to_le32(tr->role);\n\t\tbuf[1] = cpu_to_le32(tr->type);\n\t\tbuf[2] = cpu_to_le32(tr->new_role);\n\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (p->policyvers >= POLICYDB_VERSION_ROLETRANS) {\n\t\t\tbuf[0] = cpu_to_le32(tr->tclass);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int role_trans_write(struct policydb *p, void *fp)\n{\n\tstruct role_trans *r = p->role_tr;\n\tstruct role_trans *tr;\n\tu32 buf[3];\n\tsize_t nel;\n\tint rc;\n\n\tnel = 0;\n\tfor (tr = r; tr; tr = tr->next)\n\t\tnel++;\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (tr = r; tr; tr = tr->next) {\n\t\tbuf[0] = cpu_to_le32(tr->role);\n\t\tbuf[1] = cpu_to_le32(tr->type);\n\t\tbuf[2] = cpu_to_le32(tr->new_role);\n\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (p->policyvers >= POLICYDB_VERSION_ROLETRANS) {\n\t\t\tbuf[0] = cpu_to_le32(tr->tclass);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_write_list",
          "args": [
            "p",
            "p->cond_list",
            "fp"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "cond_write_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "595-617",
          "snippet": "int cond_write_list(struct policydb *p, struct cond_node *list, void *fp)\n{\n\tstruct cond_node *cur;\n\tu32 len;\n\t__le32 buf[1];\n\tint rc;\n\n\tlen = 0;\n\tfor (cur = list; cur != NULL; cur = cur->next)\n\t\tlen++;\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (cur = list; cur != NULL; cur = cur->next) {\n\t\trc = cond_write_node(p, cur, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint cond_write_list(struct policydb *p, struct cond_node *list, void *fp)\n{\n\tstruct cond_node *cur;\n\tu32 len;\n\t__le32 buf[1];\n\tint rc;\n\n\tlen = 0;\n\tfor (cur = list; cur != NULL; cur = cur->next)\n\t\tlen++;\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (cur = list; cur != NULL; cur = cur->next) {\n\t\trc = cond_write_node(p, cur, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avtab_write",
          "args": [
            "p",
            "&p->te_avtab",
            "fp"
          ],
          "line": 3493
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "635-657",
          "snippet": "int avtab_write(struct policydb *p, struct avtab *a, void *fp)\n{\n\tunsigned int i;\n\tint rc = 0;\n\tstruct avtab_node *cur;\n\t__le32 buf[1];\n\n\tbuf[0] = cpu_to_le32(a->nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < a->nslot; i++) {\n\t\tfor (cur = flex_array_get_ptr(a->htable, i); cur;\n\t\t     cur = cur->next) {\n\t\t\trc = avtab_write_item(p, cur, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint avtab_write(struct policydb *p, struct avtab *a, void *fp)\n{\n\tunsigned int i;\n\tint rc = 0;\n\tstruct avtab_node *cur;\n\t__le32 buf[1];\n\n\tbuf[0] = cpu_to_le32(a->nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < a->nslot; i++) {\n\t\tfor (cur = flex_array_get_ptr(a->htable, i); cur;\n\t\t     cur = cur->next) {\n\t\t\trc = avtab_write_item(p, cur, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_map",
          "args": [
            "p->symtab[i].table",
            "write_f[i]",
            "&pd"
          ],
          "line": 3488
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "123-144",
          "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "2",
            "fp"
          ],
          "line": 3485
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "p->symtab[i].table->nel"
          ],
          "line": 3483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "p->symtab[i].nprim"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "info->ocon_num"
          ],
          "line": 3457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "info->sym_num"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "config"
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "p->policyvers"
          ],
          "line": 3454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: compatibility lookup failed for policy \"\n\t\t    \"version %d\"",
            "p->policyvers"
          ],
          "line": 3449
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policydb_lookup_compat",
          "args": [
            "p->policyvers"
          ],
          "line": 3447
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_lookup_compat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "168-180",
          "snippet": "static struct policydb_compat_info *policydb_lookup_compat(int version)\n{\n\tint i;\n\tstruct policydb_compat_info *info = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(policydb_compat); i++) {\n\t\tif (policydb_compat[i].version == version) {\n\t\t\tinfo = &policydb_compat[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn info;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct policydb_compat_info policydb_compat[] = {\n\t{\n\t\t.version\t= POLICYDB_VERSION_BASE,\n\t\t.sym_num\t= SYM_NUM - 3,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOOL,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_IPV6,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NLCLASS,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_MLS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_AVTAB,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_RANGETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_POLCAP,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_PERMISSIVE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOUNDARY,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_FILENAME_TRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_ROLETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NEW_OBJECT_DEFAULTS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_DEFAULT_TYPE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_CONSTRAINT_NAMES,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_XPERMS_IOCTL,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_INFINIBAND,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic struct policydb_compat_info policydb_compat[] = {\n\t{\n\t\t.version\t= POLICYDB_VERSION_BASE,\n\t\t.sym_num\t= SYM_NUM - 3,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOOL,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_IPV6,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NLCLASS,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_MLS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_AVTAB,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_RANGETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_POLCAP,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_PERMISSIVE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOUNDARY,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_FILENAME_TRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_ROLETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NEW_OBJECT_DEFAULTS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_DEFAULT_TYPE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_CONSTRAINT_NAMES,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_XPERMS_IOCTL,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_INFINIBAND,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM,\n\t},\n};\n\nstatic struct policydb_compat_info *policydb_lookup_compat(int version)\n{\n\tint i;\n\tstruct policydb_compat_info *info = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(policydb_compat); i++) {\n\t\tif (policydb_compat[i].version == version) {\n\t\t\tinfo = &policydb_compat[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "POLICYDB_STRING"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "POLICYDB_MAGIC"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: refusing to write policy version %d.\"\n\t\t       \"  Because it is less than version %d\\n\"",
            "p->policyvers",
            "POLICYDB_VERSION_AVTAB"
          ],
          "line": 3420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int (*write_f[SYM_NUM]) (void *key, void *datum,\n\t\t\t\tvoid *datap) =\n{\n\tcommon_write,\n\tclass_write,\n\trole_write,\n\ttype_write,\n\tuser_write,\n\tcond_write_bool,\n\tsens_write,\n\tcat_write,\n};\n\nint policydb_write(struct policydb *p, void *fp)\n{\n\tunsigned int i, num_syms;\n\tint rc;\n\t__le32 buf[4];\n\tu32 config;\n\tsize_t len;\n\tstruct policydb_compat_info *info;\n\n\t/*\n\t * refuse to write policy older than compressed avtab\n\t * to simplify the writer.  There are other tests dropped\n\t * since we assume this throughout the writer code.  Be\n\t * careful if you ever try to remove this restriction\n\t */\n\tif (p->policyvers < POLICYDB_VERSION_AVTAB) {\n\t\tprintk(KERN_ERR \"SELinux: refusing to write policy version %d.\"\n\t\t       \"  Because it is less than version %d\\n\", p->policyvers,\n\t\t       POLICYDB_VERSION_AVTAB);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig = 0;\n\tif (p->mls_enabled)\n\t\tconfig |= POLICYDB_CONFIG_MLS;\n\n\tif (p->reject_unknown)\n\t\tconfig |= REJECT_UNKNOWN;\n\tif (p->allow_unknown)\n\t\tconfig |= ALLOW_UNKNOWN;\n\n\t/* Write the magic number and string identifiers. */\n\tbuf[0] = cpu_to_le32(POLICYDB_MAGIC);\n\tlen = strlen(POLICYDB_STRING);\n\tbuf[1] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\trc = put_entry(POLICYDB_STRING, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Write the version, config, and table sizes. */\n\tinfo = policydb_lookup_compat(p->policyvers);\n\tif (!info) {\n\t\tprintk(KERN_ERR \"SELinux: compatibility lookup failed for policy \"\n\t\t    \"version %d\", p->policyvers);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf[0] = cpu_to_le32(p->policyvers);\n\tbuf[1] = cpu_to_le32(config);\n\tbuf[2] = cpu_to_le32(info->sym_num);\n\tbuf[3] = cpu_to_le32(info->ocon_num);\n\n\trc = put_entry(buf, sizeof(u32), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (p->policyvers >= POLICYDB_VERSION_POLCAP) {\n\t\trc = ebitmap_write(&p->policycaps, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_PERMISSIVE) {\n\t\trc = ebitmap_write(&p->permissive_map, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tnum_syms = info->sym_num;\n\tfor (i = 0; i < num_syms; i++) {\n\t\tstruct policy_data pd;\n\n\t\tpd.fp = fp;\n\t\tpd.p = p;\n\n\t\tbuf[0] = cpu_to_le32(p->symtab[i].nprim);\n\t\tbuf[1] = cpu_to_le32(p->symtab[i].table->nel);\n\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = hashtab_map(p->symtab[i].table, write_f[i], &pd);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = avtab_write(p, &p->te_avtab, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cond_write_list(p, p->cond_list, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = role_trans_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = role_allow_write(p->role_allow, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = filename_trans_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ocontext_write(p, info, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = genfs_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = range_write(p, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\tstruct ebitmap *e = flex_array_get(p->type_attr_map_array, i);\n\n\t\tBUG_ON(!e);\n\t\trc = ebitmap_write(e, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "filename_trans_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "3373-3397",
    "snippet": "static int filename_trans_write(struct policydb *p, void *fp)\n{\n\tu32 nel;\n\t__le32 buf[1];\n\tint rc;\n\n\tif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\n\t\treturn 0;\n\n\tnel = 0;\n\trc = hashtab_map(p->filename_trans, hashtab_cnt, &nel);\n\tif (rc)\n\t\treturn rc;\n\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(p->filename_trans, filename_write_helper, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashtab_map",
          "args": [
            "p->filename_trans",
            "filename_write_helper",
            "fp"
          ],
          "line": 3392
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "123-144",
          "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "1",
            "fp"
          ],
          "line": 3388
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "nel"
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int filename_trans_write(struct policydb *p, void *fp)\n{\n\tu32 nel;\n\t__le32 buf[1];\n\tint rc;\n\n\tif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\n\t\treturn 0;\n\n\tnel = 0;\n\trc = hashtab_map(p->filename_trans, hashtab_cnt, &nel);\n\tif (rc)\n\t\treturn rc;\n\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(p->filename_trans, filename_write_helper, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "filename_write_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "3342-3371",
    "snippet": "static int filename_write_helper(void *key, void *data, void *ptr)\n{\n\t__le32 buf[4];\n\tstruct filename_trans *ft = key;\n\tstruct filename_trans_datum *otype = data;\n\tvoid *fp = ptr;\n\tint rc;\n\tu32 len;\n\n\tlen = strlen(ft->name);\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(ft->name, sizeof(char), len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tbuf[0] = cpu_to_le32(ft->stype);\n\tbuf[1] = cpu_to_le32(ft->ttype);\n\tbuf[2] = cpu_to_le32(ft->tclass);\n\tbuf[3] = cpu_to_le32(otype->otype);\n\n\trc = put_entry(buf, sizeof(u32), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "4",
            "fp"
          ],
          "line": 3366
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "otype->otype"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ft->tclass"
          ],
          "line": 3363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ft->ttype"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ft->stype"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 3352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ft->name"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int filename_write_helper(void *key, void *data, void *ptr)\n{\n\t__le32 buf[4];\n\tstruct filename_trans *ft = key;\n\tstruct filename_trans_datum *otype = data;\n\tvoid *fp = ptr;\n\tint rc;\n\tu32 len;\n\n\tlen = strlen(ft->name);\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(ft->name, sizeof(char), len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tbuf[0] = cpu_to_le32(ft->stype);\n\tbuf[1] = cpu_to_le32(ft->ttype);\n\tbuf[2] = cpu_to_le32(ft->tclass);\n\tbuf[3] = cpu_to_le32(otype->otype);\n\n\trc = put_entry(buf, sizeof(u32), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "range_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "3314-3340",
    "snippet": "static int range_write(struct policydb *p, void *fp)\n{\n\t__le32 buf[1];\n\tint rc, nel;\n\tstruct policy_data pd;\n\n\tpd.p = p;\n\tpd.fp = fp;\n\n\t/* count the number of entries in the hashtab */\n\tnel = 0;\n\trc = hashtab_map(p->range_tr, hashtab_cnt, &nel);\n\tif (rc)\n\t\treturn rc;\n\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* actually write all of the entries */\n\trc = hashtab_map(p->range_tr, range_write_helper, &pd);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashtab_map",
          "args": [
            "p->range_tr",
            "range_write_helper",
            "&pd"
          ],
          "line": 3335
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "123-144",
          "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "1",
            "fp"
          ],
          "line": 3330
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "nel"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int range_write(struct policydb *p, void *fp)\n{\n\t__le32 buf[1];\n\tint rc, nel;\n\tstruct policy_data pd;\n\n\tpd.p = p;\n\tpd.fp = fp;\n\n\t/* count the number of entries in the hashtab */\n\tnel = 0;\n\trc = hashtab_map(p->range_tr, hashtab_cnt, &nel);\n\tif (rc)\n\t\treturn rc;\n\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* actually write all of the entries */\n\trc = hashtab_map(p->range_tr, range_write_helper, &pd);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "range_write_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "3286-3312",
    "snippet": "static int range_write_helper(void *key, void *data, void *ptr)\n{\n\t__le32 buf[2];\n\tstruct range_trans *rt = key;\n\tstruct mls_range *r = data;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\tstruct policydb *p = pd->p;\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(rt->source_type);\n\tbuf[1] = cpu_to_le32(rt->target_type);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\tif (p->policyvers >= POLICYDB_VERSION_RANGETRANS) {\n\t\tbuf[0] = cpu_to_le32(rt->target_class);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\trc = mls_write_range_helper(r, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mls_write_range_helper",
          "args": [
            "r",
            "fp"
          ],
          "line": 3307
        },
        "resolved": true,
        "details": {
          "function_name": "mls_write_range_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "2587-2620",
          "snippet": "static int mls_write_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[3];\n\tsize_t items;\n\tint rc, eq;\n\n\teq = mls_level_eq(&r->level[1], &r->level[0]);\n\n\tif (eq)\n\t\titems = 2;\n\telse\n\t\titems = 3;\n\tbuf[0] = cpu_to_le32(items-1);\n\tbuf[1] = cpu_to_le32(r->level[0].sens);\n\tif (!eq)\n\t\tbuf[2] = cpu_to_le32(r->level[1].sens);\n\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&r->level[0].cat, fp);\n\tif (rc)\n\t\treturn rc;\n\tif (!eq) {\n\t\trc = ebitmap_write(&r->level[1].cat, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_write_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[3];\n\tsize_t items;\n\tint rc, eq;\n\n\teq = mls_level_eq(&r->level[1], &r->level[0]);\n\n\tif (eq)\n\t\titems = 2;\n\telse\n\t\titems = 3;\n\tbuf[0] = cpu_to_le32(items-1);\n\tbuf[1] = cpu_to_le32(r->level[0].sens);\n\tif (!eq)\n\t\tbuf[2] = cpu_to_le32(r->level[1].sens);\n\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&r->level[0].cat, fp);\n\tif (rc)\n\t\treturn rc;\n\tif (!eq) {\n\t\trc = ebitmap_write(&r->level[1].cat, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "1",
            "fp"
          ],
          "line": 3303
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "rt->target_class"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "rt->target_type"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "rt->source_type"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int range_write_helper(void *key, void *data, void *ptr)\n{\n\t__le32 buf[2];\n\tstruct range_trans *rt = key;\n\tstruct mls_range *r = data;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\tstruct policydb *p = pd->p;\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(rt->source_type);\n\tbuf[1] = cpu_to_le32(rt->target_type);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\tif (p->policyvers >= POLICYDB_VERSION_RANGETRANS) {\n\t\tbuf[0] = cpu_to_le32(rt->target_class);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\trc = mls_write_range_helper(r, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hashtab_cnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "3278-3284",
    "snippet": "static int hashtab_cnt(void *key, void *data, void *ptr)\n{\n\tint *cnt = ptr;\n\t*cnt = *cnt + 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int hashtab_cnt(void *key, void *data, void *ptr)\n{\n\tint *cnt = ptr;\n\t*cnt = *cnt + 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "genfs_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "3226-3276",
    "snippet": "static int genfs_write(struct policydb *p, void *fp)\n{\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tsize_t len;\n\t__le32 buf[1];\n\tint rc;\n\n\tlen = 0;\n\tfor (genfs = p->genfs; genfs; genfs = genfs->next)\n\t\tlen++;\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (genfs = p->genfs; genfs; genfs = genfs->next) {\n\t\tlen = strlen(genfs->fstype);\n\t\tbuf[0] = cpu_to_le32(len);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = put_entry(genfs->fstype, 1, len, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tlen = 0;\n\t\tfor (c = genfs->head; c; c = c->next)\n\t\t\tlen++;\n\t\tbuf[0] = cpu_to_le32(len);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (c = genfs->head; c; c = c->next) {\n\t\t\tlen = strlen(c->u.name);\n\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbuf[0] = cpu_to_le32(c->v.sclass);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_write",
          "args": [
            "p",
            "&c->context[0]",
            "fp"
          ],
          "line": 3270
        },
        "resolved": true,
        "details": {
          "function_name": "ocontext_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "3102-3224",
          "snippet": "static int ocontext_write(struct policydb *p, struct policydb_compat_info *info,\n\t\t\t  void *fp)\n{\n\tunsigned int i, j, rc;\n\tsize_t nel, len;\n\t__le32 buf[3];\n\tu32 nodebuf[8];\n\tstruct ocontext *c;\n\tfor (i = 0; i < info->ocon_num; i++) {\n\t\tnel = 0;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next)\n\t\t\tnel++;\n\t\tbuf[0] = cpu_to_le32(nel);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next) {\n\t\t\tswitch (i) {\n\t\t\tcase OCON_ISID:\n\t\t\t\tbuf[0] = cpu_to_le32(c->sid[0]);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FS:\n\t\t\tcase OCON_NETIF:\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[1], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_PORT:\n\t\t\t\tbuf[0] = cpu_to_le32(c->u.port.protocol);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.port.low_port);\n\t\t\t\tbuf[2] = cpu_to_le32(c->u.port.high_port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE:\n\t\t\t\tnodebuf[0] = c->u.node.addr; /* network order */\n\t\t\t\tnodebuf[1] = c->u.node.mask; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FSUSE:\n\t\t\t\tbuf[0] = cpu_to_le32(c->v.behavior);\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[1] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE6:\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j] = c->u.node6.addr[j]; /* network order */\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j + 4] = c->u.node6.mask[j]; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 8, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBPKEY:\n\t\t\t\t*((__be64 *)nodebuf) = cpu_to_be64(c->u.ibpkey.subnet_prefix);\n\n\t\t\t\tnodebuf[2] = cpu_to_le32(c->u.ibpkey.low_pkey);\n\t\t\t\tnodebuf[3] = cpu_to_le32(c->u.ibpkey.high_pkey);\n\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 4, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBENDPORT:\n\t\t\t\tlen = strlen(c->u.ibendport.dev_name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.ibendport.port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.ibendport.dev_name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int ocontext_write(struct policydb *p, struct policydb_compat_info *info,\n\t\t\t  void *fp)\n{\n\tunsigned int i, j, rc;\n\tsize_t nel, len;\n\t__le32 buf[3];\n\tu32 nodebuf[8];\n\tstruct ocontext *c;\n\tfor (i = 0; i < info->ocon_num; i++) {\n\t\tnel = 0;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next)\n\t\t\tnel++;\n\t\tbuf[0] = cpu_to_le32(nel);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next) {\n\t\t\tswitch (i) {\n\t\t\tcase OCON_ISID:\n\t\t\t\tbuf[0] = cpu_to_le32(c->sid[0]);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FS:\n\t\t\tcase OCON_NETIF:\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[1], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_PORT:\n\t\t\t\tbuf[0] = cpu_to_le32(c->u.port.protocol);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.port.low_port);\n\t\t\t\tbuf[2] = cpu_to_le32(c->u.port.high_port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE:\n\t\t\t\tnodebuf[0] = c->u.node.addr; /* network order */\n\t\t\t\tnodebuf[1] = c->u.node.mask; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FSUSE:\n\t\t\t\tbuf[0] = cpu_to_le32(c->v.behavior);\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[1] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE6:\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j] = c->u.node6.addr[j]; /* network order */\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j + 4] = c->u.node6.mask[j]; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 8, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBPKEY:\n\t\t\t\t*((__be64 *)nodebuf) = cpu_to_be64(c->u.ibpkey.subnet_prefix);\n\n\t\t\t\tnodebuf[2] = cpu_to_le32(c->u.ibpkey.low_pkey);\n\t\t\t\tnodebuf[3] = cpu_to_le32(c->u.ibpkey.high_pkey);\n\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 4, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBENDPORT:\n\t\t\t\tlen = strlen(c->u.ibendport.dev_name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.ibendport.port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.ibendport.dev_name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "1",
            "fp"
          ],
          "line": 3267
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "c->v.sclass"
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->u.name"
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 3243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "genfs->fstype"
          ],
          "line": 3242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int genfs_write(struct policydb *p, void *fp)\n{\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tsize_t len;\n\t__le32 buf[1];\n\tint rc;\n\n\tlen = 0;\n\tfor (genfs = p->genfs; genfs; genfs = genfs->next)\n\t\tlen++;\n\tbuf[0] = cpu_to_le32(len);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (genfs = p->genfs; genfs; genfs = genfs->next) {\n\t\tlen = strlen(genfs->fstype);\n\t\tbuf[0] = cpu_to_le32(len);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = put_entry(genfs->fstype, 1, len, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tlen = 0;\n\t\tfor (c = genfs->head; c; c = c->next)\n\t\t\tlen++;\n\t\tbuf[0] = cpu_to_le32(len);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (c = genfs->head; c; c = c->next) {\n\t\t\tlen = strlen(c->u.name);\n\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbuf[0] = cpu_to_le32(c->v.sclass);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ocontext_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "3102-3224",
    "snippet": "static int ocontext_write(struct policydb *p, struct policydb_compat_info *info,\n\t\t\t  void *fp)\n{\n\tunsigned int i, j, rc;\n\tsize_t nel, len;\n\t__le32 buf[3];\n\tu32 nodebuf[8];\n\tstruct ocontext *c;\n\tfor (i = 0; i < info->ocon_num; i++) {\n\t\tnel = 0;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next)\n\t\t\tnel++;\n\t\tbuf[0] = cpu_to_le32(nel);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next) {\n\t\t\tswitch (i) {\n\t\t\tcase OCON_ISID:\n\t\t\t\tbuf[0] = cpu_to_le32(c->sid[0]);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FS:\n\t\t\tcase OCON_NETIF:\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[1], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_PORT:\n\t\t\t\tbuf[0] = cpu_to_le32(c->u.port.protocol);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.port.low_port);\n\t\t\t\tbuf[2] = cpu_to_le32(c->u.port.high_port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE:\n\t\t\t\tnodebuf[0] = c->u.node.addr; /* network order */\n\t\t\t\tnodebuf[1] = c->u.node.mask; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FSUSE:\n\t\t\t\tbuf[0] = cpu_to_le32(c->v.behavior);\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[1] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE6:\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j] = c->u.node6.addr[j]; /* network order */\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j + 4] = c->u.node6.mask[j]; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 8, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBPKEY:\n\t\t\t\t*((__be64 *)nodebuf) = cpu_to_be64(c->u.ibpkey.subnet_prefix);\n\n\t\t\t\tnodebuf[2] = cpu_to_le32(c->u.ibpkey.low_pkey);\n\t\t\t\tnodebuf[3] = cpu_to_le32(c->u.ibpkey.high_pkey);\n\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 4, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBENDPORT:\n\t\t\t\tlen = strlen(c->u.ibendport.dev_name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.ibendport.port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.ibendport.dev_name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_write",
          "args": [
            "p",
            "&c->context[0]",
            "fp"
          ],
          "line": 3216
        },
        "resolved": true,
        "details": {
          "function_name": "ocontext_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "3102-3224",
          "snippet": "static int ocontext_write(struct policydb *p, struct policydb_compat_info *info,\n\t\t\t  void *fp)\n{\n\tunsigned int i, j, rc;\n\tsize_t nel, len;\n\t__le32 buf[3];\n\tu32 nodebuf[8];\n\tstruct ocontext *c;\n\tfor (i = 0; i < info->ocon_num; i++) {\n\t\tnel = 0;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next)\n\t\t\tnel++;\n\t\tbuf[0] = cpu_to_le32(nel);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next) {\n\t\t\tswitch (i) {\n\t\t\tcase OCON_ISID:\n\t\t\t\tbuf[0] = cpu_to_le32(c->sid[0]);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FS:\n\t\t\tcase OCON_NETIF:\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[1], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_PORT:\n\t\t\t\tbuf[0] = cpu_to_le32(c->u.port.protocol);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.port.low_port);\n\t\t\t\tbuf[2] = cpu_to_le32(c->u.port.high_port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE:\n\t\t\t\tnodebuf[0] = c->u.node.addr; /* network order */\n\t\t\t\tnodebuf[1] = c->u.node.mask; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FSUSE:\n\t\t\t\tbuf[0] = cpu_to_le32(c->v.behavior);\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[1] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE6:\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j] = c->u.node6.addr[j]; /* network order */\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j + 4] = c->u.node6.mask[j]; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 8, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBPKEY:\n\t\t\t\t*((__be64 *)nodebuf) = cpu_to_be64(c->u.ibpkey.subnet_prefix);\n\n\t\t\t\tnodebuf[2] = cpu_to_le32(c->u.ibpkey.low_pkey);\n\t\t\t\tnodebuf[3] = cpu_to_le32(c->u.ibpkey.high_pkey);\n\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 4, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBENDPORT:\n\t\t\t\tlen = strlen(c->u.ibendport.dev_name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.ibendport.port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.ibendport.dev_name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "c->u.ibendport.dev_name",
            "1",
            "len",
            "fp"
          ],
          "line": 3213
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "c->u.ibendport.port"
          ],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->u.ibendport.dev_name"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "c->u.ibpkey.high_pkey"
          ],
          "line": 3197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "c->u.ibpkey.low_pkey"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "c->u.ibpkey.subnet_prefix"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->u.name"
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "c->v.behavior"
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "c->u.port.high_port"
          ],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "c->u.port.low_port"
          ],
          "line": 3148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "c->u.port.protocol"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->u.name"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "c->sid[0]"
          ],
          "line": 3121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "nel"
          ],
          "line": 3114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int ocontext_write(struct policydb *p, struct policydb_compat_info *info,\n\t\t\t  void *fp)\n{\n\tunsigned int i, j, rc;\n\tsize_t nel, len;\n\t__le32 buf[3];\n\tu32 nodebuf[8];\n\tstruct ocontext *c;\n\tfor (i = 0; i < info->ocon_num; i++) {\n\t\tnel = 0;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next)\n\t\t\tnel++;\n\t\tbuf[0] = cpu_to_le32(nel);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (c = p->ocontexts[i]; c; c = c->next) {\n\t\t\tswitch (i) {\n\t\t\tcase OCON_ISID:\n\t\t\t\tbuf[0] = cpu_to_le32(c->sid[0]);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FS:\n\t\t\tcase OCON_NETIF:\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[1], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_PORT:\n\t\t\t\tbuf[0] = cpu_to_le32(c->u.port.protocol);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.port.low_port);\n\t\t\t\tbuf[2] = cpu_to_le32(c->u.port.high_port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE:\n\t\t\t\tnodebuf[0] = c->u.node.addr; /* network order */\n\t\t\t\tnodebuf[1] = c->u.node.mask; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FSUSE:\n\t\t\t\tbuf[0] = cpu_to_le32(c->v.behavior);\n\t\t\t\tlen = strlen(c->u.name);\n\t\t\t\tbuf[1] = cpu_to_le32(len);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE6:\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j] = c->u.node6.addr[j]; /* network order */\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tnodebuf[j + 4] = c->u.node6.mask[j]; /* network order */\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 8, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBPKEY:\n\t\t\t\t*((__be64 *)nodebuf) = cpu_to_be64(c->u.ibpkey.subnet_prefix);\n\n\t\t\t\tnodebuf[2] = cpu_to_le32(c->u.ibpkey.low_pkey);\n\t\t\t\tnodebuf[3] = cpu_to_le32(c->u.ibpkey.high_pkey);\n\n\t\t\t\trc = put_entry(nodebuf, sizeof(u32), 4, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBENDPORT:\n\t\t\t\tlen = strlen(c->u.ibendport.dev_name);\n\t\t\t\tbuf[0] = cpu_to_le32(len);\n\t\t\t\tbuf[1] = cpu_to_le32(c->u.ibendport.port);\n\t\t\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = put_entry(c->u.ibendport.dev_name, 1, len, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\trc = context_write(p, &c->context[0], fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "user_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "3048-3087",
    "snippet": "static int user_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct user_datum *usrdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tstruct policydb *p = pd->p;\n\tvoid *fp = pd->fp;\n\t__le32 buf[3];\n\tsize_t items, len;\n\tint rc;\n\n\tlen = strlen(key);\n\titems = 0;\n\tbuf[items++] = cpu_to_le32(len);\n\tbuf[items++] = cpu_to_le32(usrdatum->value);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tbuf[items++] = cpu_to_le32(usrdatum->bounds);\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&usrdatum->roles, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mls_write_range_helper(&usrdatum->range, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mls_write_level(&usrdatum->dfltlevel, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mls_write_level",
          "args": [
            "&usrdatum->dfltlevel",
            "fp"
          ],
          "line": 3082
        },
        "resolved": true,
        "details": {
          "function_name": "mls_write_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "2566-2581",
          "snippet": "static int mls_write_level(struct mls_level *l, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(l->sens);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&l->cat, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_write_level(struct mls_level *l, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(l->sens);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&l->cat, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_write_range_helper",
          "args": [
            "&usrdatum->range",
            "fp"
          ],
          "line": 3078
        },
        "resolved": true,
        "details": {
          "function_name": "mls_write_range_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "2587-2620",
          "snippet": "static int mls_write_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[3];\n\tsize_t items;\n\tint rc, eq;\n\n\teq = mls_level_eq(&r->level[1], &r->level[0]);\n\n\tif (eq)\n\t\titems = 2;\n\telse\n\t\titems = 3;\n\tbuf[0] = cpu_to_le32(items-1);\n\tbuf[1] = cpu_to_le32(r->level[0].sens);\n\tif (!eq)\n\t\tbuf[2] = cpu_to_le32(r->level[1].sens);\n\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&r->level[0].cat, fp);\n\tif (rc)\n\t\treturn rc;\n\tif (!eq) {\n\t\trc = ebitmap_write(&r->level[1].cat, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_write_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[3];\n\tsize_t items;\n\tint rc, eq;\n\n\teq = mls_level_eq(&r->level[1], &r->level[0]);\n\n\tif (eq)\n\t\titems = 2;\n\telse\n\t\titems = 3;\n\tbuf[0] = cpu_to_le32(items-1);\n\tbuf[1] = cpu_to_le32(r->level[0].sens);\n\tif (!eq)\n\t\tbuf[2] = cpu_to_le32(r->level[1].sens);\n\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&r->level[0].cat, fp);\n\tif (rc)\n\t\treturn rc;\n\tif (!eq) {\n\t\trc = ebitmap_write(&r->level[1].cat, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_write",
          "args": [
            "&usrdatum->roles",
            "fp"
          ],
          "line": 3074
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "451-524",
          "snippet": "int ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nint ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "key",
            "1",
            "len",
            "fp"
          ],
          "line": 3070
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "items > ARRAY_SIZE(buf)"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "usrdatum->bounds"
          ],
          "line": 3064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "usrdatum->value"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int user_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct user_datum *usrdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tstruct policydb *p = pd->p;\n\tvoid *fp = pd->fp;\n\t__le32 buf[3];\n\tsize_t items, len;\n\tint rc;\n\n\tlen = strlen(key);\n\titems = 0;\n\tbuf[items++] = cpu_to_le32(len);\n\tbuf[items++] = cpu_to_le32(usrdatum->value);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tbuf[items++] = cpu_to_le32(usrdatum->bounds);\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&usrdatum->roles, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mls_write_range_helper(&usrdatum->range, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mls_write_level(&usrdatum->dfltlevel, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "type_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "3007-3046",
    "snippet": "static int type_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct type_datum *typdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tstruct policydb *p = pd->p;\n\tvoid *fp = pd->fp;\n\t__le32 buf[4];\n\tint rc;\n\tsize_t items, len;\n\n\tlen = strlen(key);\n\titems = 0;\n\tbuf[items++] = cpu_to_le32(len);\n\tbuf[items++] = cpu_to_le32(typdatum->value);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY) {\n\t\tu32 properties = 0;\n\n\t\tif (typdatum->primary)\n\t\t\tproperties |= TYPEDATUM_PROPERTY_PRIMARY;\n\n\t\tif (typdatum->attribute)\n\t\t\tproperties |= TYPEDATUM_PROPERTY_ATTRIBUTE;\n\n\t\tbuf[items++] = cpu_to_le32(properties);\n\t\tbuf[items++] = cpu_to_le32(typdatum->bounds);\n\t} else {\n\t\tbuf[items++] = cpu_to_le32(typdatum->primary);\n\t}\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "key",
            "1",
            "len",
            "fp"
          ],
          "line": 3041
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "items > ARRAY_SIZE(buf)"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "typdatum->primary"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "typdatum->bounds"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "properties"
          ],
          "line": 3031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "typdatum->value"
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int type_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct type_datum *typdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tstruct policydb *p = pd->p;\n\tvoid *fp = pd->fp;\n\t__le32 buf[4];\n\tint rc;\n\tsize_t items, len;\n\n\tlen = strlen(key);\n\titems = 0;\n\tbuf[items++] = cpu_to_le32(len);\n\tbuf[items++] = cpu_to_le32(typdatum->value);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY) {\n\t\tu32 properties = 0;\n\n\t\tif (typdatum->primary)\n\t\t\tproperties |= TYPEDATUM_PROPERTY_PRIMARY;\n\n\t\tif (typdatum->attribute)\n\t\t\tproperties |= TYPEDATUM_PROPERTY_ATTRIBUTE;\n\n\t\tbuf[items++] = cpu_to_le32(properties);\n\t\tbuf[items++] = cpu_to_le32(typdatum->bounds);\n\t} else {\n\t\tbuf[items++] = cpu_to_le32(typdatum->primary);\n\t}\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "role_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2968-3005",
    "snippet": "static int role_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct role_datum *role = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\tstruct policydb *p = pd->p;\n\t__le32 buf[3];\n\tsize_t items, len;\n\tint rc;\n\n\tlen = strlen(key);\n\titems = 0;\n\tbuf[items++] = cpu_to_le32(len);\n\tbuf[items++] = cpu_to_le32(role->value);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tbuf[items++] = cpu_to_le32(role->bounds);\n\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&role->dominates, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&role->types, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_write",
          "args": [
            "&role->types",
            "fp"
          ],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "451-524",
          "snippet": "int ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nint ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "key",
            "1",
            "len",
            "fp"
          ],
          "line": 2992
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "items > ARRAY_SIZE(buf)"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "role->bounds"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "role->value"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int role_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct role_datum *role = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\tstruct policydb *p = pd->p;\n\t__le32 buf[3];\n\tsize_t items, len;\n\tint rc;\n\n\tlen = strlen(key);\n\titems = 0;\n\tbuf[items++] = cpu_to_le32(len);\n\tbuf[items++] = cpu_to_le32(role->value);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tbuf[items++] = cpu_to_le32(role->bounds);\n\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&role->dominates, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&role->types, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "class_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2880-2966",
    "snippet": "static int class_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct class_datum *cladatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\tstruct policydb *p = pd->p;\n\tstruct constraint_node *c;\n\t__le32 buf[6];\n\tu32 ncons;\n\tsize_t len, len2;\n\tint rc;\n\n\tlen = strlen(key);\n\tif (cladatum->comkey)\n\t\tlen2 = strlen(cladatum->comkey);\n\telse\n\t\tlen2 = 0;\n\n\tncons = 0;\n\tfor (c = cladatum->constraints; c; c = c->next)\n\t\tncons++;\n\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(len2);\n\tbuf[2] = cpu_to_le32(cladatum->value);\n\tbuf[3] = cpu_to_le32(cladatum->permissions.nprim);\n\tif (cladatum->permissions.table)\n\t\tbuf[4] = cpu_to_le32(cladatum->permissions.table->nel);\n\telse\n\t\tbuf[4] = 0;\n\tbuf[5] = cpu_to_le32(ncons);\n\trc = put_entry(buf, sizeof(u32), 6, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cladatum->comkey) {\n\t\trc = put_entry(cladatum->comkey, 1, len2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = hashtab_map(cladatum->permissions.table, perm_write, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = write_cons_helper(p, cladatum->constraints, fp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* write out the validatetrans rule */\n\tncons = 0;\n\tfor (c = cladatum->validatetrans; c; c = c->next)\n\t\tncons++;\n\n\tbuf[0] = cpu_to_le32(ncons);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = write_cons_helper(p, cladatum->validatetrans, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (p->policyvers >= POLICYDB_VERSION_NEW_OBJECT_DEFAULTS) {\n\t\tbuf[0] = cpu_to_le32(cladatum->default_user);\n\t\tbuf[1] = cpu_to_le32(cladatum->default_role);\n\t\tbuf[2] = cpu_to_le32(cladatum->default_range);\n\n\t\trc = put_entry(buf, sizeof(uint32_t), 3, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_DEFAULT_TYPE) {\n\t\tbuf[0] = cpu_to_le32(cladatum->default_type);\n\t\trc = put_entry(buf, sizeof(uint32_t), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(uint32_t)",
            "1",
            "fp"
          ],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cladatum->default_type"
          ],
          "line": 2959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cladatum->default_range"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cladatum->default_role"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cladatum->default_user"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_cons_helper",
          "args": [
            "p",
            "cladatum->validatetrans",
            "fp"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "write_cons_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "2833-2878",
          "snippet": "static int write_cons_helper(struct policydb *p, struct constraint_node *node,\n\t\t\t     void *fp)\n{\n\tstruct constraint_node *c;\n\tstruct constraint_expr *e;\n\t__le32 buf[3];\n\tu32 nel;\n\tint rc;\n\n\tfor (c = node; c; c = c->next) {\n\t\tnel = 0;\n\t\tfor (e = c->expr; e; e = e->next)\n\t\t\tnel++;\n\t\tbuf[0] = cpu_to_le32(c->permissions);\n\t\tbuf[1] = cpu_to_le32(nel);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (e = c->expr; e; e = e->next) {\n\t\t\tbuf[0] = cpu_to_le32(e->expr_type);\n\t\t\tbuf[1] = cpu_to_le32(e->attr);\n\t\t\tbuf[2] = cpu_to_le32(e->op);\n\t\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tswitch (e->expr_type) {\n\t\t\tcase CEXPR_NAMES:\n\t\t\t\trc = ebitmap_write(&e->names, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tif (p->policyvers >=\n\t\t\t\t\tPOLICYDB_VERSION_CONSTRAINT_NAMES) {\n\t\t\t\t\trc = type_set_write(e->type_names, fp);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int write_cons_helper(struct policydb *p, struct constraint_node *node,\n\t\t\t     void *fp)\n{\n\tstruct constraint_node *c;\n\tstruct constraint_expr *e;\n\t__le32 buf[3];\n\tu32 nel;\n\tint rc;\n\n\tfor (c = node; c; c = c->next) {\n\t\tnel = 0;\n\t\tfor (e = c->expr; e; e = e->next)\n\t\t\tnel++;\n\t\tbuf[0] = cpu_to_le32(c->permissions);\n\t\tbuf[1] = cpu_to_le32(nel);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (e = c->expr; e; e = e->next) {\n\t\t\tbuf[0] = cpu_to_le32(e->expr_type);\n\t\t\tbuf[1] = cpu_to_le32(e->attr);\n\t\t\tbuf[2] = cpu_to_le32(e->op);\n\t\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tswitch (e->expr_type) {\n\t\t\tcase CEXPR_NAMES:\n\t\t\t\trc = ebitmap_write(&e->names, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tif (p->policyvers >=\n\t\t\t\t\tPOLICYDB_VERSION_CONSTRAINT_NAMES) {\n\t\t\t\t\trc = type_set_write(e->type_names, fp);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ncons"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashtab_map",
          "args": [
            "cladatum->permissions.table",
            "perm_write",
            "fp"
          ],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "123-144",
          "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ncons"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cladatum->permissions.table->nel"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cladatum->permissions.nprim"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cladatum->value"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len2"
          ],
          "line": 2904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cladatum->comkey"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int class_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct class_datum *cladatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\tstruct policydb *p = pd->p;\n\tstruct constraint_node *c;\n\t__le32 buf[6];\n\tu32 ncons;\n\tsize_t len, len2;\n\tint rc;\n\n\tlen = strlen(key);\n\tif (cladatum->comkey)\n\t\tlen2 = strlen(cladatum->comkey);\n\telse\n\t\tlen2 = 0;\n\n\tncons = 0;\n\tfor (c = cladatum->constraints; c; c = c->next)\n\t\tncons++;\n\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(len2);\n\tbuf[2] = cpu_to_le32(cladatum->value);\n\tbuf[3] = cpu_to_le32(cladatum->permissions.nprim);\n\tif (cladatum->permissions.table)\n\t\tbuf[4] = cpu_to_le32(cladatum->permissions.table->nel);\n\telse\n\t\tbuf[4] = 0;\n\tbuf[5] = cpu_to_le32(ncons);\n\trc = put_entry(buf, sizeof(u32), 6, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cladatum->comkey) {\n\t\trc = put_entry(cladatum->comkey, 1, len2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = hashtab_map(cladatum->permissions.table, perm_write, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = write_cons_helper(p, cladatum->constraints, fp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* write out the validatetrans rule */\n\tncons = 0;\n\tfor (c = cladatum->validatetrans; c; c = c->next)\n\t\tncons++;\n\n\tbuf[0] = cpu_to_le32(ncons);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = write_cons_helper(p, cladatum->validatetrans, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (p->policyvers >= POLICYDB_VERSION_NEW_OBJECT_DEFAULTS) {\n\t\tbuf[0] = cpu_to_le32(cladatum->default_user);\n\t\tbuf[1] = cpu_to_le32(cladatum->default_role);\n\t\tbuf[2] = cpu_to_le32(cladatum->default_range);\n\n\t\trc = put_entry(buf, sizeof(uint32_t), 3, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_DEFAULT_TYPE) {\n\t\tbuf[0] = cpu_to_le32(cladatum->default_type);\n\t\trc = put_entry(buf, sizeof(uint32_t), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "write_cons_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2833-2878",
    "snippet": "static int write_cons_helper(struct policydb *p, struct constraint_node *node,\n\t\t\t     void *fp)\n{\n\tstruct constraint_node *c;\n\tstruct constraint_expr *e;\n\t__le32 buf[3];\n\tu32 nel;\n\tint rc;\n\n\tfor (c = node; c; c = c->next) {\n\t\tnel = 0;\n\t\tfor (e = c->expr; e; e = e->next)\n\t\t\tnel++;\n\t\tbuf[0] = cpu_to_le32(c->permissions);\n\t\tbuf[1] = cpu_to_le32(nel);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (e = c->expr; e; e = e->next) {\n\t\t\tbuf[0] = cpu_to_le32(e->expr_type);\n\t\t\tbuf[1] = cpu_to_le32(e->attr);\n\t\t\tbuf[2] = cpu_to_le32(e->op);\n\t\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tswitch (e->expr_type) {\n\t\t\tcase CEXPR_NAMES:\n\t\t\t\trc = ebitmap_write(&e->names, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tif (p->policyvers >=\n\t\t\t\t\tPOLICYDB_VERSION_CONSTRAINT_NAMES) {\n\t\t\t\t\trc = type_set_write(e->type_names, fp);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "type_set_write",
          "args": [
            "e->type_names",
            "fp"
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "type_set_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "2815-2831",
          "snippet": "static int type_set_write(struct type_set *t, void *fp)\n{\n\tint rc;\n\t__le32 buf[1];\n\n\tif (ebitmap_write(&t->types, fp))\n\t\treturn -EINVAL;\n\tif (ebitmap_write(&t->negset, fp))\n\t\treturn -EINVAL;\n\n\tbuf[0] = cpu_to_le32(t->flags);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int type_set_write(struct type_set *t, void *fp)\n{\n\tint rc;\n\t__le32 buf[1];\n\n\tif (ebitmap_write(&t->types, fp))\n\t\treturn -EINVAL;\n\tif (ebitmap_write(&t->negset, fp))\n\t\treturn -EINVAL;\n\n\tbuf[0] = cpu_to_le32(t->flags);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_write",
          "args": [
            "&e->names",
            "fp"
          ],
          "line": 2861
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "451-524",
          "snippet": "int ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nint ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "3",
            "fp"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "e->op"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "e->attr"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "e->expr_type"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "nel"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "c->permissions"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int write_cons_helper(struct policydb *p, struct constraint_node *node,\n\t\t\t     void *fp)\n{\n\tstruct constraint_node *c;\n\tstruct constraint_expr *e;\n\t__le32 buf[3];\n\tu32 nel;\n\tint rc;\n\n\tfor (c = node; c; c = c->next) {\n\t\tnel = 0;\n\t\tfor (e = c->expr; e; e = e->next)\n\t\t\tnel++;\n\t\tbuf[0] = cpu_to_le32(c->permissions);\n\t\tbuf[1] = cpu_to_le32(nel);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (e = c->expr; e; e = e->next) {\n\t\t\tbuf[0] = cpu_to_le32(e->expr_type);\n\t\t\tbuf[1] = cpu_to_le32(e->attr);\n\t\t\tbuf[2] = cpu_to_le32(e->op);\n\t\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tswitch (e->expr_type) {\n\t\t\tcase CEXPR_NAMES:\n\t\t\t\trc = ebitmap_write(&e->names, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tif (p->policyvers >=\n\t\t\t\t\tPOLICYDB_VERSION_CONSTRAINT_NAMES) {\n\t\t\t\t\trc = type_set_write(e->type_names, fp);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "type_set_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2815-2831",
    "snippet": "static int type_set_write(struct type_set *t, void *fp)\n{\n\tint rc;\n\t__le32 buf[1];\n\n\tif (ebitmap_write(&t->types, fp))\n\t\treturn -EINVAL;\n\tif (ebitmap_write(&t->negset, fp))\n\t\treturn -EINVAL;\n\n\tbuf[0] = cpu_to_le32(t->flags);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "1",
            "fp"
          ],
          "line": 2826
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "t->flags"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_write",
          "args": [
            "&t->negset",
            "fp"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "451-524",
          "snippet": "int ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nint ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int type_set_write(struct type_set *t, void *fp)\n{\n\tint rc;\n\t__le32 buf[1];\n\n\tif (ebitmap_write(&t->types, fp))\n\t\treturn -EINVAL;\n\tif (ebitmap_write(&t->negset, fp))\n\t\treturn -EINVAL;\n\n\tbuf[0] = cpu_to_le32(t->flags);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "common_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2785-2813",
    "snippet": "static int common_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct common_datum *comdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\t__le32 buf[4];\n\tsize_t len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(comdatum->value);\n\tbuf[2] = cpu_to_le32(comdatum->permissions.nprim);\n\tbuf[3] = cpu_to_le32(comdatum->permissions.table->nel);\n\trc = put_entry(buf, sizeof(u32), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(comdatum->permissions.table, perm_write, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashtab_map",
          "args": [
            "comdatum->permissions.table",
            "perm_write",
            "fp"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "123-144",
          "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "key",
            "1",
            "len",
            "fp"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "comdatum->permissions.table->nel"
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "comdatum->permissions.nprim"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "comdatum->value"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int common_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct common_datum *comdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\t__le32 buf[4];\n\tsize_t len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(comdatum->value);\n\tbuf[2] = cpu_to_le32(comdatum->permissions.nprim);\n\tbuf[3] = cpu_to_le32(comdatum->permissions.table->nel);\n\trc = put_entry(buf, sizeof(u32), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(comdatum->permissions.table, perm_write, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "perm_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2763-2783",
    "snippet": "static int perm_write(void *vkey, void *datum, void *fp)\n{\n\tchar *key = vkey;\n\tstruct perm_datum *perdatum = datum;\n\t__le32 buf[2];\n\tsize_t len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(perdatum->value);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "key",
            "1",
            "len",
            "fp"
          ],
          "line": 2778
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "perdatum->value"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int perm_write(void *vkey, void *datum, void *fp)\n{\n\tchar *key = vkey;\n\tstruct perm_datum *perdatum = datum;\n\t__le32 buf[2];\n\tsize_t len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(perdatum->value);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "context_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2736-2755",
    "snippet": "static int context_write(struct policydb *p, struct context *c,\n\t\t\t void *fp)\n{\n\tint rc;\n\t__le32 buf[3];\n\n\tbuf[0] = cpu_to_le32(c->user);\n\tbuf[1] = cpu_to_le32(c->role);\n\tbuf[2] = cpu_to_le32(c->type);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mls_write_range_helper(&c->range, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mls_write_range_helper",
          "args": [
            "&c->range",
            "fp"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "mls_write_range_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "2587-2620",
          "snippet": "static int mls_write_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[3];\n\tsize_t items;\n\tint rc, eq;\n\n\teq = mls_level_eq(&r->level[1], &r->level[0]);\n\n\tif (eq)\n\t\titems = 2;\n\telse\n\t\titems = 3;\n\tbuf[0] = cpu_to_le32(items-1);\n\tbuf[1] = cpu_to_le32(r->level[0].sens);\n\tif (!eq)\n\t\tbuf[2] = cpu_to_le32(r->level[1].sens);\n\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&r->level[0].cat, fp);\n\tif (rc)\n\t\treturn rc;\n\tif (!eq) {\n\t\trc = ebitmap_write(&r->level[1].cat, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_write_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[3];\n\tsize_t items;\n\tint rc, eq;\n\n\teq = mls_level_eq(&r->level[1], &r->level[0]);\n\n\tif (eq)\n\t\titems = 2;\n\telse\n\t\titems = 3;\n\tbuf[0] = cpu_to_le32(items-1);\n\tbuf[1] = cpu_to_le32(r->level[0].sens);\n\tif (!eq)\n\t\tbuf[2] = cpu_to_le32(r->level[1].sens);\n\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&r->level[0].cat, fp);\n\tif (rc)\n\t\treturn rc;\n\tif (!eq) {\n\t\trc = ebitmap_write(&r->level[1].cat, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "3",
            "fp"
          ],
          "line": 2746
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "c->type"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "c->role"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "c->user"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int context_write(struct policydb *p, struct context *c,\n\t\t\t void *fp)\n{\n\tint rc;\n\t__le32 buf[3];\n\n\tbuf[0] = cpu_to_le32(c->user);\n\tbuf[1] = cpu_to_le32(c->role);\n\tbuf[2] = cpu_to_le32(c->type);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mls_write_range_helper(&c->range, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "role_allow_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2708-2730",
    "snippet": "static int role_allow_write(struct role_allow *r, void *fp)\n{\n\tstruct role_allow *ra;\n\tu32 buf[2];\n\tsize_t nel;\n\tint rc;\n\n\tnel = 0;\n\tfor (ra = r; ra; ra = ra->next)\n\t\tnel++;\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (ra = r; ra; ra = ra->next) {\n\t\tbuf[0] = cpu_to_le32(ra->role);\n\t\tbuf[1] = cpu_to_le32(ra->new_role);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "2",
            "fp"
          ],
          "line": 2725
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ra->new_role"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ra->role"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "nel"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int role_allow_write(struct role_allow *r, void *fp)\n{\n\tstruct role_allow *ra;\n\tu32 buf[2];\n\tsize_t nel;\n\tint rc;\n\n\tnel = 0;\n\tfor (ra = r; ra; ra = ra->next)\n\t\tnel++;\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (ra = r; ra; ra = ra->next) {\n\t\tbuf[0] = cpu_to_le32(ra->role);\n\t\tbuf[1] = cpu_to_le32(ra->new_role);\n\t\trc = put_entry(buf, sizeof(u32), 2, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "role_trans_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2675-2706",
    "snippet": "static int role_trans_write(struct policydb *p, void *fp)\n{\n\tstruct role_trans *r = p->role_tr;\n\tstruct role_trans *tr;\n\tu32 buf[3];\n\tsize_t nel;\n\tint rc;\n\n\tnel = 0;\n\tfor (tr = r; tr; tr = tr->next)\n\t\tnel++;\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (tr = r; tr; tr = tr->next) {\n\t\tbuf[0] = cpu_to_le32(tr->role);\n\t\tbuf[1] = cpu_to_le32(tr->type);\n\t\tbuf[2] = cpu_to_le32(tr->new_role);\n\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (p->policyvers >= POLICYDB_VERSION_ROLETRANS) {\n\t\t\tbuf[0] = cpu_to_le32(tr->tclass);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "1",
            "fp"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tr->tclass"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tr->new_role"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tr->type"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "tr->role"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "nel"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int role_trans_write(struct policydb *p, void *fp)\n{\n\tstruct role_trans *r = p->role_tr;\n\tstruct role_trans *tr;\n\tu32 buf[3];\n\tsize_t nel;\n\tint rc;\n\n\tnel = 0;\n\tfor (tr = r; tr; tr = tr->next)\n\t\tnel++;\n\tbuf[0] = cpu_to_le32(nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\tfor (tr = r; tr; tr = tr->next) {\n\t\tbuf[0] = cpu_to_le32(tr->role);\n\t\tbuf[1] = cpu_to_le32(tr->type);\n\t\tbuf[2] = cpu_to_le32(tr->new_role);\n\t\trc = put_entry(buf, sizeof(u32), 3, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (p->policyvers >= POLICYDB_VERSION_ROLETRANS) {\n\t\t\tbuf[0] = cpu_to_le32(tr->tclass);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cat_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2650-2673",
    "snippet": "static int cat_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct cat_datum *catdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\t__le32 buf[3];\n\tsize_t len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(catdatum->value);\n\tbuf[2] = cpu_to_le32(catdatum->isalias);\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "key",
            "1",
            "len",
            "fp"
          ],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "catdatum->isalias"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "catdatum->value"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int cat_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct cat_datum *catdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\t__le32 buf[3];\n\tsize_t len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(catdatum->value);\n\tbuf[2] = cpu_to_le32(catdatum->isalias);\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sens_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2622-2648",
    "snippet": "static int sens_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct level_datum *levdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\t__le32 buf[2];\n\tsize_t len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(levdatum->isalias);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mls_write_level(levdatum->level, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mls_write_level",
          "args": [
            "levdatum->level",
            "fp"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "mls_write_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "2566-2581",
          "snippet": "static int mls_write_level(struct mls_level *l, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(l->sens);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&l->cat, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_write_level(struct mls_level *l, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(l->sens);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&l->cat, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "key",
            "1",
            "len",
            "fp"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "levdatum->isalias"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int sens_write(void *vkey, void *datum, void *ptr)\n{\n\tchar *key = vkey;\n\tstruct level_datum *levdatum = datum;\n\tstruct policy_data *pd = ptr;\n\tvoid *fp = pd->fp;\n\t__le32 buf[2];\n\tsize_t len;\n\tint rc;\n\n\tlen = strlen(key);\n\tbuf[0] = cpu_to_le32(len);\n\tbuf[1] = cpu_to_le32(levdatum->isalias);\n\trc = put_entry(buf, sizeof(u32), 2, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = put_entry(key, 1, len, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mls_write_level(levdatum->level, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mls_write_range_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2587-2620",
    "snippet": "static int mls_write_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[3];\n\tsize_t items;\n\tint rc, eq;\n\n\teq = mls_level_eq(&r->level[1], &r->level[0]);\n\n\tif (eq)\n\t\titems = 2;\n\telse\n\t\titems = 3;\n\tbuf[0] = cpu_to_le32(items-1);\n\tbuf[1] = cpu_to_le32(r->level[0].sens);\n\tif (!eq)\n\t\tbuf[2] = cpu_to_le32(r->level[1].sens);\n\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&r->level[0].cat, fp);\n\tif (rc)\n\t\treturn rc;\n\tif (!eq) {\n\t\trc = ebitmap_write(&r->level[1].cat, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_write",
          "args": [
            "&r->level[1].cat",
            "fp"
          ],
          "line": 2614
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "451-524",
          "snippet": "int ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nint ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "items",
            "fp"
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "items > ARRAY_SIZE(buf)"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "r->level[1].sens"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "r->level[0].sens"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "items-1"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mls_level_eq",
          "args": [
            "&r->level[1]",
            "&r->level[0]"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "mls_level_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls_types.h",
          "lines": "30-34",
          "snippet": "static inline int mls_level_eq(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens == l2->sens) &&\n\t\tebitmap_cmp(&l1->cat, &l2->cat));\n}",
          "includes": [
            "#include \"ebitmap.h\"",
            "#include \"security.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebitmap.h\"\n#include \"security.h\"\n\nstatic inline int mls_level_eq(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens == l2->sens) &&\n\t\tebitmap_cmp(&l1->cat, &l2->cat));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_write_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[3];\n\tsize_t items;\n\tint rc, eq;\n\n\teq = mls_level_eq(&r->level[1], &r->level[0]);\n\n\tif (eq)\n\t\titems = 2;\n\telse\n\t\titems = 3;\n\tbuf[0] = cpu_to_le32(items-1);\n\tbuf[1] = cpu_to_le32(r->level[0].sens);\n\tif (!eq)\n\t\tbuf[2] = cpu_to_le32(r->level[1].sens);\n\n\tBUG_ON(items > ARRAY_SIZE(buf));\n\n\trc = put_entry(buf, sizeof(u32), items, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&r->level[0].cat, fp);\n\tif (rc)\n\t\treturn rc;\n\tif (!eq) {\n\t\trc = ebitmap_write(&r->level[1].cat, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mls_write_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2566-2581",
    "snippet": "static int mls_write_level(struct mls_level *l, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(l->sens);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&l->cat, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_write",
          "args": [
            "&l->cat",
            "fp"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "451-524",
          "snippet": "int ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nint ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "1",
            "fp"
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "l->sens"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_write_level(struct mls_level *l, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tbuf[0] = cpu_to_le32(l->sens);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ebitmap_write(&l->cat, fp);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "policydb_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2276-2560",
    "snippet": "int policydb_read(struct policydb *p, void *fp)\n{\n\tstruct role_allow *ra, *lra;\n\tstruct role_trans *tr, *ltr;\n\tint i, j, rc;\n\t__le32 buf[4];\n\tu32 len, nprim, nel;\n\n\tchar *policydb_str;\n\tstruct policydb_compat_info *info;\n\n\trc = policydb_init(p);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Read the magic number and string length. */\n\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tif (le32_to_cpu(buf[0]) != POLICYDB_MAGIC) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb magic number 0x%x does \"\n\t\t       \"not match expected magic number 0x%x\\n\",\n\t\t       le32_to_cpu(buf[0]), POLICYDB_MAGIC);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tlen = le32_to_cpu(buf[1]);\n\tif (len != strlen(POLICYDB_STRING)) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb string length %d does not \"\n\t\t       \"match expected length %zu\\n\",\n\t\t       len, strlen(POLICYDB_STRING));\n\t\tgoto bad;\n\t}\n\n\trc = -ENOMEM;\n\tpolicydb_str = kmalloc(len + 1, GFP_KERNEL);\n\tif (!policydb_str) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to allocate memory for policydb \"\n\t\t       \"string of length %d\\n\", len);\n\t\tgoto bad;\n\t}\n\n\trc = next_entry(policydb_str, fp, len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  truncated policydb string identifier\\n\");\n\t\tkfree(policydb_str);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tpolicydb_str[len] = '\\0';\n\tif (strcmp(policydb_str, POLICYDB_STRING)) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb string %s does not match \"\n\t\t       \"my string %s\\n\", policydb_str, POLICYDB_STRING);\n\t\tkfree(policydb_str);\n\t\tgoto bad;\n\t}\n\t/* Done with policydb_str. */\n\tkfree(policydb_str);\n\tpolicydb_str = NULL;\n\n\t/* Read the version and table sizes. */\n\trc = next_entry(buf, fp, sizeof(u32)*4);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tp->policyvers = le32_to_cpu(buf[0]);\n\tif (p->policyvers < POLICYDB_VERSION_MIN ||\n\t    p->policyvers > POLICYDB_VERSION_MAX) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb version %d does not match \"\n\t\t       \"my version range %d-%d\\n\",\n\t\t       le32_to_cpu(buf[0]), POLICYDB_VERSION_MIN, POLICYDB_VERSION_MAX);\n\t\tgoto bad;\n\t}\n\n\tif ((le32_to_cpu(buf[1]) & POLICYDB_CONFIG_MLS)) {\n\t\tp->mls_enabled = 1;\n\n\t\trc = -EINVAL;\n\t\tif (p->policyvers < POLICYDB_VERSION_MLS) {\n\t\t\tprintk(KERN_ERR \"SELinux: security policydb version %d \"\n\t\t\t\t\"(MLS) not backwards compatible\\n\",\n\t\t\t\tp->policyvers);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tp->reject_unknown = !!(le32_to_cpu(buf[1]) & REJECT_UNKNOWN);\n\tp->allow_unknown = !!(le32_to_cpu(buf[1]) & ALLOW_UNKNOWN);\n\n\tif (p->policyvers >= POLICYDB_VERSION_POLCAP) {\n\t\trc = ebitmap_read(&p->policycaps, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_PERMISSIVE) {\n\t\trc = ebitmap_read(&p->permissive_map, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tinfo = policydb_lookup_compat(p->policyvers);\n\tif (!info) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to find policy compat info \"\n\t\t       \"for version %d\\n\", p->policyvers);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tif (le32_to_cpu(buf[2]) != info->sym_num ||\n\t\tle32_to_cpu(buf[3]) != info->ocon_num) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb table sizes (%d,%d) do \"\n\t\t       \"not match mine (%d,%d)\\n\", le32_to_cpu(buf[2]),\n\t\t\tle32_to_cpu(buf[3]),\n\t\t       info->sym_num, info->ocon_num);\n\t\tgoto bad;\n\t}\n\n\tfor (i = 0; i < info->sym_num; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\tnprim = le32_to_cpu(buf[0]);\n\t\tnel = le32_to_cpu(buf[1]);\n\t\tfor (j = 0; j < nel; j++) {\n\t\t\trc = read_f[i](p, p->symtab[i].table, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t}\n\n\t\tp->symtab[i].nprim = nprim;\n\t}\n\n\trc = -EINVAL;\n\tp->process_class = string_to_security_class(p, \"process\");\n\tif (!p->process_class)\n\t\tgoto bad;\n\n\trc = avtab_read(&p->te_avtab, fp, p);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOOL) {\n\t\trc = cond_read_list(p, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto bad;\n\tnel = le32_to_cpu(buf[0]);\n\tltr = NULL;\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\ttr = kzalloc(sizeof(*tr), GFP_KERNEL);\n\t\tif (!tr)\n\t\t\tgoto bad;\n\t\tif (ltr)\n\t\t\tltr->next = tr;\n\t\telse\n\t\t\tp->role_tr = tr;\n\t\trc = next_entry(buf, fp, sizeof(u32)*3);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trc = -EINVAL;\n\t\ttr->role = le32_to_cpu(buf[0]);\n\t\ttr->type = le32_to_cpu(buf[1]);\n\t\ttr->new_role = le32_to_cpu(buf[2]);\n\t\tif (p->policyvers >= POLICYDB_VERSION_ROLETRANS) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t\ttr->tclass = le32_to_cpu(buf[0]);\n\t\t} else\n\t\t\ttr->tclass = p->process_class;\n\n\t\trc = -EINVAL;\n\t\tif (!policydb_role_isvalid(p, tr->role) ||\n\t\t    !policydb_type_isvalid(p, tr->type) ||\n\t\t    !policydb_class_isvalid(p, tr->tclass) ||\n\t\t    !policydb_role_isvalid(p, tr->new_role))\n\t\t\tgoto bad;\n\t\tltr = tr;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto bad;\n\tnel = le32_to_cpu(buf[0]);\n\tlra = NULL;\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\tra = kzalloc(sizeof(*ra), GFP_KERNEL);\n\t\tif (!ra)\n\t\t\tgoto bad;\n\t\tif (lra)\n\t\t\tlra->next = ra;\n\t\telse\n\t\t\tp->role_allow = ra;\n\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trc = -EINVAL;\n\t\tra->role = le32_to_cpu(buf[0]);\n\t\tra->new_role = le32_to_cpu(buf[1]);\n\t\tif (!policydb_role_isvalid(p, ra->role) ||\n\t\t    !policydb_role_isvalid(p, ra->new_role))\n\t\t\tgoto bad;\n\t\tlra = ra;\n\t}\n\n\trc = filename_trans_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = policydb_index(p);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tp->process_trans_perms = string_to_av_perm(p, p->process_class, \"transition\");\n\tp->process_trans_perms |= string_to_av_perm(p, p->process_class, \"dyntransition\");\n\tif (!p->process_trans_perms)\n\t\tgoto bad;\n\n\trc = ocontext_read(p, info, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = genfs_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = range_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -ENOMEM;\n\tp->type_attr_map_array = flex_array_alloc(sizeof(struct ebitmap),\n\t\t\t\t\t\t  p->p_types.nprim,\n\t\t\t\t\t\t  GFP_KERNEL | __GFP_ZERO);\n\tif (!p->type_attr_map_array)\n\t\tgoto bad;\n\n\t/* preallocate so we don't have to worry about the put ever failing */\n\trc = flex_array_prealloc(p->type_attr_map_array, 0, p->p_types.nprim,\n\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\tif (rc)\n\t\tgoto bad;\n\n\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\tstruct ebitmap *e = flex_array_get(p->type_attr_map_array, i);\n\n\t\tBUG_ON(!e);\n\t\tebitmap_init(e);\n\t\tif (p->policyvers >= POLICYDB_VERSION_AVTAB) {\n\t\t\trc = ebitmap_read(e, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t}\n\t\t/* add the type itself as the degenerate case */\n\t\trc = ebitmap_set_bit(e, i, 1);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = policydb_bounds_sanity_check(p);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tpolicydb_destroy(p);\n\tgoto out;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int (*read_f[SYM_NUM]) (struct policydb *p, struct hashtab *h, void *fp) =\n{\n\tcommon_read,\n\tclass_read,\n\trole_read,\n\ttype_read,\n\tuser_read,\n\tcond_read_bool,\n\tsens_read,\n\tcat_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "policydb_destroy",
          "args": [
            "p"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "796-887",
          "snippet": "void policydb_destroy(struct policydb *p)\n{\n\tstruct ocontext *c, *ctmp;\n\tstruct genfs *g, *gtmp;\n\tint i;\n\tstruct role_allow *ra, *lra = NULL;\n\tstruct role_trans *tr, *ltr = NULL;\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tcond_resched();\n\t\thashtab_map(p->symtab[i].table, destroy_f[i], NULL);\n\t\thashtab_destroy(p->symtab[i].table);\n\t}\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tif (p->sym_val_to_name[i])\n\t\t\tflex_array_free(p->sym_val_to_name[i]);\n\t}\n\n\tkfree(p->class_val_to_struct);\n\tkfree(p->role_val_to_struct);\n\tkfree(p->user_val_to_struct);\n\tif (p->type_val_to_struct_array)\n\t\tflex_array_free(p->type_val_to_struct_array);\n\n\tavtab_destroy(&p->te_avtab);\n\n\tfor (i = 0; i < OCON_NUM; i++) {\n\t\tcond_resched();\n\t\tc = p->ocontexts[i];\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, i);\n\t\t}\n\t\tp->ocontexts[i] = NULL;\n\t}\n\n\tg = p->genfs;\n\twhile (g) {\n\t\tcond_resched();\n\t\tkfree(g->fstype);\n\t\tc = g->head;\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, OCON_FSUSE);\n\t\t}\n\t\tgtmp = g;\n\t\tg = g->next;\n\t\tkfree(gtmp);\n\t}\n\tp->genfs = NULL;\n\n\tcond_policydb_destroy(p);\n\n\tfor (tr = p->role_tr; tr; tr = tr->next) {\n\t\tcond_resched();\n\t\tkfree(ltr);\n\t\tltr = tr;\n\t}\n\tkfree(ltr);\n\n\tfor (ra = p->role_allow; ra; ra = ra->next) {\n\t\tcond_resched();\n\t\tkfree(lra);\n\t\tlra = ra;\n\t}\n\tkfree(lra);\n\n\thashtab_map(p->filename_trans, filenametr_destroy, NULL);\n\thashtab_destroy(p->filename_trans);\n\n\thashtab_map(p->range_tr, range_tr_destroy, NULL);\n\thashtab_destroy(p->range_tr);\n\n\tif (p->type_attr_map_array) {\n\t\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\t\tstruct ebitmap *e;\n\n\t\t\te = flex_array_get(p->type_attr_map_array, i);\n\t\t\tif (!e)\n\t\t\t\tcontinue;\n\t\t\tebitmap_destroy(e);\n\t\t}\n\t\tflex_array_free(p->type_attr_map_array);\n\t}\n\n\tebitmap_destroy(&p->filename_trans_ttypes);\n\tebitmap_destroy(&p->policycaps);\n\tebitmap_destroy(&p->permissive_map);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*destroy_f[SYM_NUM]) (void *key, void *datum, void *datap) =\n{\n\tcommon_destroy,\n\tcls_destroy,\n\trole_destroy,\n\ttype_destroy,\n\tuser_destroy,\n\tcond_destroy_bool,\n\tsens_destroy,\n\tcat_destroy,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int (*destroy_f[SYM_NUM]) (void *key, void *datum, void *datap) =\n{\n\tcommon_destroy,\n\tcls_destroy,\n\trole_destroy,\n\ttype_destroy,\n\tuser_destroy,\n\tcond_destroy_bool,\n\tsens_destroy,\n\tcat_destroy,\n};\n\nvoid policydb_destroy(struct policydb *p)\n{\n\tstruct ocontext *c, *ctmp;\n\tstruct genfs *g, *gtmp;\n\tint i;\n\tstruct role_allow *ra, *lra = NULL;\n\tstruct role_trans *tr, *ltr = NULL;\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tcond_resched();\n\t\thashtab_map(p->symtab[i].table, destroy_f[i], NULL);\n\t\thashtab_destroy(p->symtab[i].table);\n\t}\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tif (p->sym_val_to_name[i])\n\t\t\tflex_array_free(p->sym_val_to_name[i]);\n\t}\n\n\tkfree(p->class_val_to_struct);\n\tkfree(p->role_val_to_struct);\n\tkfree(p->user_val_to_struct);\n\tif (p->type_val_to_struct_array)\n\t\tflex_array_free(p->type_val_to_struct_array);\n\n\tavtab_destroy(&p->te_avtab);\n\n\tfor (i = 0; i < OCON_NUM; i++) {\n\t\tcond_resched();\n\t\tc = p->ocontexts[i];\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, i);\n\t\t}\n\t\tp->ocontexts[i] = NULL;\n\t}\n\n\tg = p->genfs;\n\twhile (g) {\n\t\tcond_resched();\n\t\tkfree(g->fstype);\n\t\tc = g->head;\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, OCON_FSUSE);\n\t\t}\n\t\tgtmp = g;\n\t\tg = g->next;\n\t\tkfree(gtmp);\n\t}\n\tp->genfs = NULL;\n\n\tcond_policydb_destroy(p);\n\n\tfor (tr = p->role_tr; tr; tr = tr->next) {\n\t\tcond_resched();\n\t\tkfree(ltr);\n\t\tltr = tr;\n\t}\n\tkfree(ltr);\n\n\tfor (ra = p->role_allow; ra; ra = ra->next) {\n\t\tcond_resched();\n\t\tkfree(lra);\n\t\tlra = ra;\n\t}\n\tkfree(lra);\n\n\thashtab_map(p->filename_trans, filenametr_destroy, NULL);\n\thashtab_destroy(p->filename_trans);\n\n\thashtab_map(p->range_tr, range_tr_destroy, NULL);\n\thashtab_destroy(p->range_tr);\n\n\tif (p->type_attr_map_array) {\n\t\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\t\tstruct ebitmap *e;\n\n\t\t\te = flex_array_get(p->type_attr_map_array, i);\n\t\t\tif (!e)\n\t\t\t\tcontinue;\n\t\t\tebitmap_destroy(e);\n\t\t}\n\t\tflex_array_free(p->type_attr_map_array);\n\t}\n\n\tebitmap_destroy(&p->filename_trans_ttypes);\n\tebitmap_destroy(&p->policycaps);\n\tebitmap_destroy(&p->permissive_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policydb_bounds_sanity_check",
          "args": [
            "p"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_bounds_sanity_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1779-1802",
          "snippet": "static int policydb_bounds_sanity_check(struct policydb *p)\n{\n\tint rc;\n\n\tif (p->policyvers < POLICYDB_VERSION_BOUNDARY)\n\t\treturn 0;\n\n\trc = hashtab_map(p->p_users.table,\n\t\t\t user_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(p->p_roles.table,\n\t\t\t role_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(p->p_types.table,\n\t\t\t type_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int policydb_bounds_sanity_check(struct policydb *p)\n{\n\tint rc;\n\n\tif (p->policyvers < POLICYDB_VERSION_BOUNDARY)\n\t\treturn 0;\n\n\trc = hashtab_map(p->p_users.table,\n\t\t\t user_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(p->p_roles.table,\n\t\t\t role_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(p->p_types.table,\n\t\t\t type_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_set_bit",
          "args": [
            "e",
            "i",
            "1"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "259-325",
          "snippet": "int ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\n{\n\tstruct ebitmap_node *n, *prev, *new;\n\n\tprev = NULL;\n\tn = e->node;\n\twhile (n && n->startbit <= bit) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit) {\n\t\t\tif (value) {\n\t\t\t\tebitmap_node_set_bit(n, bit);\n\t\t\t} else {\n\t\t\t\tunsigned int s;\n\n\t\t\t\tebitmap_node_clr_bit(n, bit);\n\n\t\t\t\ts = find_first_bit(n->maps, EBITMAP_SIZE);\n\t\t\t\tif (s < EBITMAP_SIZE)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* drop this node from the bitmap */\n\t\t\t\tif (!n->next) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this was the highest map\n\t\t\t\t\t * within the bitmap\n\t\t\t\t\t */\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\te->highbit = prev->startbit\n\t\t\t\t\t\t\t     + EBITMAP_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\te->highbit = 0;\n\t\t\t\t}\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = n->next;\n\t\t\t\telse\n\t\t\t\t\te->node = n->next;\n\t\t\t\tkmem_cache_free(ebitmap_node_cachep, n);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->startbit = bit - (bit % EBITMAP_SIZE);\n\tebitmap_node_set_bit(new, bit);\n\n\tif (!n)\n\t\t/* this node will be the highest map within the bitmap */\n\t\te->highbit = new->startbit + EBITMAP_SIZE;\n\n\tif (prev) {\n\t\tnew->next = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tnew->next = e->node;\n\t\te->node = new;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\n{\n\tstruct ebitmap_node *n, *prev, *new;\n\n\tprev = NULL;\n\tn = e->node;\n\twhile (n && n->startbit <= bit) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit) {\n\t\t\tif (value) {\n\t\t\t\tebitmap_node_set_bit(n, bit);\n\t\t\t} else {\n\t\t\t\tunsigned int s;\n\n\t\t\t\tebitmap_node_clr_bit(n, bit);\n\n\t\t\t\ts = find_first_bit(n->maps, EBITMAP_SIZE);\n\t\t\t\tif (s < EBITMAP_SIZE)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* drop this node from the bitmap */\n\t\t\t\tif (!n->next) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this was the highest map\n\t\t\t\t\t * within the bitmap\n\t\t\t\t\t */\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\te->highbit = prev->startbit\n\t\t\t\t\t\t\t     + EBITMAP_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\te->highbit = 0;\n\t\t\t\t}\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = n->next;\n\t\t\t\telse\n\t\t\t\t\te->node = n->next;\n\t\t\t\tkmem_cache_free(ebitmap_node_cachep, n);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->startbit = bit - (bit % EBITMAP_SIZE);\n\tebitmap_node_set_bit(new, bit);\n\n\tif (!n)\n\t\t/* this node will be the highest map within the bitmap */\n\t\te->highbit = new->startbit + EBITMAP_SIZE;\n\n\tif (prev) {\n\t\tnew->next = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tnew->next = e->node;\n\t\te->node = new;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_read",
          "args": [
            "e",
            "fp"
          ],
          "line": 2540
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "346-449",
          "snippet": "int ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_init",
          "args": [
            "e"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.h",
          "lines": "60-63",
          "snippet": "static inline void ebitmap_init(struct ebitmap *e)\n{\n\tmemset(e, 0, sizeof(*e));\n}",
          "includes": [
            "#include <net/netlabel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/netlabel.h>\n\nstatic inline void ebitmap_init(struct ebitmap *e)\n{\n\tmemset(e, 0, sizeof(*e));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!e"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get",
          "args": [
            "p->type_attr_map_array",
            "i"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_prealloc",
          "args": [
            "p->type_attr_map_array",
            "0",
            "p->p_types.nprim",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_alloc",
          "args": [
            "sizeof(struct ebitmap)",
            "p->p_types.nprim",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_read",
          "args": [
            "p",
            "fp"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "range_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1838-1908",
          "snippet": "static int range_read(struct policydb *p, void *fp)\n{\n\tstruct range_trans *rt = NULL;\n\tstruct mls_range *r = NULL;\n\tint i, rc;\n\t__le32 buf[2];\n\tu32 nel;\n\n\tif (p->policyvers < POLICYDB_VERSION_MLS)\n\t\treturn 0;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\n\tnel = le32_to_cpu(buf[0]);\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\trt = kzalloc(sizeof(*rt), GFP_KERNEL);\n\t\tif (!rt)\n\t\t\tgoto out;\n\n\t\trc = next_entry(buf, fp, (sizeof(u32) * 2));\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trt->source_type = le32_to_cpu(buf[0]);\n\t\trt->target_type = le32_to_cpu(buf[1]);\n\t\tif (p->policyvers >= POLICYDB_VERSION_RANGETRANS) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\trt->target_class = le32_to_cpu(buf[0]);\n\t\t} else\n\t\t\trt->target_class = p->process_class;\n\n\t\trc = -EINVAL;\n\t\tif (!policydb_type_isvalid(p, rt->source_type) ||\n\t\t    !policydb_type_isvalid(p, rt->target_type) ||\n\t\t    !policydb_class_isvalid(p, rt->target_class))\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\tr = kzalloc(sizeof(*r), GFP_KERNEL);\n\t\tif (!r)\n\t\t\tgoto out;\n\n\t\trc = mls_read_range_helper(r, fp);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = -EINVAL;\n\t\tif (!mls_range_isvalid(p, r)) {\n\t\t\tprintk(KERN_WARNING \"SELinux:  rangetrans:  invalid range\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = hashtab_insert(p->range_tr, rt, r);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trt = NULL;\n\t\tr = NULL;\n\t}\n\thash_eval(p->range_tr, \"rangetr\");\n\trc = 0;\nout:\n\tkfree(rt);\n\tkfree(r);\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int range_read(struct policydb *p, void *fp)\n{\n\tstruct range_trans *rt = NULL;\n\tstruct mls_range *r = NULL;\n\tint i, rc;\n\t__le32 buf[2];\n\tu32 nel;\n\n\tif (p->policyvers < POLICYDB_VERSION_MLS)\n\t\treturn 0;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\n\tnel = le32_to_cpu(buf[0]);\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\trt = kzalloc(sizeof(*rt), GFP_KERNEL);\n\t\tif (!rt)\n\t\t\tgoto out;\n\n\t\trc = next_entry(buf, fp, (sizeof(u32) * 2));\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trt->source_type = le32_to_cpu(buf[0]);\n\t\trt->target_type = le32_to_cpu(buf[1]);\n\t\tif (p->policyvers >= POLICYDB_VERSION_RANGETRANS) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\trt->target_class = le32_to_cpu(buf[0]);\n\t\t} else\n\t\t\trt->target_class = p->process_class;\n\n\t\trc = -EINVAL;\n\t\tif (!policydb_type_isvalid(p, rt->source_type) ||\n\t\t    !policydb_type_isvalid(p, rt->target_type) ||\n\t\t    !policydb_class_isvalid(p, rt->target_class))\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\tr = kzalloc(sizeof(*r), GFP_KERNEL);\n\t\tif (!r)\n\t\t\tgoto out;\n\n\t\trc = mls_read_range_helper(r, fp);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = -EINVAL;\n\t\tif (!mls_range_isvalid(p, r)) {\n\t\t\tprintk(KERN_WARNING \"SELinux:  rangetrans:  invalid range\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = hashtab_insert(p->range_tr, rt, r);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trt = NULL;\n\t\tr = NULL;\n\t}\n\thash_eval(p->range_tr, \"rangetr\");\n\trc = 0;\nout:\n\tkfree(rt);\n\tkfree(r);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "genfs_read",
          "args": [
            "p",
            "fp"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "genfs_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1992-2103",
          "snippet": "static int genfs_read(struct policydb *p, void *fp)\n{\n\tint i, j, rc;\n\tu32 nel, nel2, len, len2;\n\t__le32 buf[1];\n\tstruct ocontext *l, *c;\n\tstruct ocontext *newc = NULL;\n\tstruct genfs *genfs_p, *genfs;\n\tstruct genfs *newgenfs = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tnel = le32_to_cpu(buf[0]);\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tlen = le32_to_cpu(buf[0]);\n\n\t\trc = -ENOMEM;\n\t\tnewgenfs = kzalloc(sizeof(*newgenfs), GFP_KERNEL);\n\t\tif (!newgenfs)\n\t\t\tgoto out;\n\n\t\trc = str_read(&newgenfs->fstype, GFP_KERNEL, fp, len);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tfor (genfs_p = NULL, genfs = p->genfs; genfs;\n\t\t     genfs_p = genfs, genfs = genfs->next) {\n\t\t\trc = -EINVAL;\n\t\t\tif (strcmp(newgenfs->fstype, genfs->fstype) == 0) {\n\t\t\t\tprintk(KERN_ERR \"SELinux:  dup genfs fstype %s\\n\",\n\t\t\t\t       newgenfs->fstype);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strcmp(newgenfs->fstype, genfs->fstype) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tnewgenfs->next = genfs;\n\t\tif (genfs_p)\n\t\t\tgenfs_p->next = newgenfs;\n\t\telse\n\t\t\tp->genfs = newgenfs;\n\t\tgenfs = newgenfs;\n\t\tnewgenfs = NULL;\n\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tnel2 = le32_to_cpu(buf[0]);\n\t\tfor (j = 0; j < nel2; j++) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\trc = -ENOMEM;\n\t\t\tnewc = kzalloc(sizeof(*newc), GFP_KERNEL);\n\t\t\tif (!newc)\n\t\t\t\tgoto out;\n\n\t\t\trc = str_read(&newc->u.name, GFP_KERNEL, fp, len);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\tnewc->v.sclass = le32_to_cpu(buf[0]);\n\t\t\trc = context_read_and_validate(&newc->context[0], p, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\tfor (l = NULL, c = genfs->head; c;\n\t\t\t     l = c, c = c->next) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tif (!strcmp(newc->u.name, c->u.name) &&\n\t\t\t\t    (!c->v.sclass || !newc->v.sclass ||\n\t\t\t\t     newc->v.sclass == c->v.sclass)) {\n\t\t\t\t\tprintk(KERN_ERR \"SELinux:  dup genfs entry (%s,%s)\\n\",\n\t\t\t\t\t       genfs->fstype, c->u.name);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tlen = strlen(newc->u.name);\n\t\t\t\tlen2 = strlen(c->u.name);\n\t\t\t\tif (len > len2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnewc->next = c;\n\t\t\tif (l)\n\t\t\t\tl->next = newc;\n\t\t\telse\n\t\t\t\tgenfs->head = newc;\n\t\t\tnewc = NULL;\n\t\t}\n\t}\n\trc = 0;\nout:\n\tif (newgenfs) {\n\t\tkfree(newgenfs->fstype);\n\t\tkfree(newgenfs);\n\t}\n\tocontext_destroy(newc, OCON_FSUSE);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int genfs_read(struct policydb *p, void *fp)\n{\n\tint i, j, rc;\n\tu32 nel, nel2, len, len2;\n\t__le32 buf[1];\n\tstruct ocontext *l, *c;\n\tstruct ocontext *newc = NULL;\n\tstruct genfs *genfs_p, *genfs;\n\tstruct genfs *newgenfs = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tnel = le32_to_cpu(buf[0]);\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tlen = le32_to_cpu(buf[0]);\n\n\t\trc = -ENOMEM;\n\t\tnewgenfs = kzalloc(sizeof(*newgenfs), GFP_KERNEL);\n\t\tif (!newgenfs)\n\t\t\tgoto out;\n\n\t\trc = str_read(&newgenfs->fstype, GFP_KERNEL, fp, len);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tfor (genfs_p = NULL, genfs = p->genfs; genfs;\n\t\t     genfs_p = genfs, genfs = genfs->next) {\n\t\t\trc = -EINVAL;\n\t\t\tif (strcmp(newgenfs->fstype, genfs->fstype) == 0) {\n\t\t\t\tprintk(KERN_ERR \"SELinux:  dup genfs fstype %s\\n\",\n\t\t\t\t       newgenfs->fstype);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strcmp(newgenfs->fstype, genfs->fstype) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tnewgenfs->next = genfs;\n\t\tif (genfs_p)\n\t\t\tgenfs_p->next = newgenfs;\n\t\telse\n\t\t\tp->genfs = newgenfs;\n\t\tgenfs = newgenfs;\n\t\tnewgenfs = NULL;\n\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tnel2 = le32_to_cpu(buf[0]);\n\t\tfor (j = 0; j < nel2; j++) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\trc = -ENOMEM;\n\t\t\tnewc = kzalloc(sizeof(*newc), GFP_KERNEL);\n\t\t\tif (!newc)\n\t\t\t\tgoto out;\n\n\t\t\trc = str_read(&newc->u.name, GFP_KERNEL, fp, len);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\tnewc->v.sclass = le32_to_cpu(buf[0]);\n\t\t\trc = context_read_and_validate(&newc->context[0], p, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\tfor (l = NULL, c = genfs->head; c;\n\t\t\t     l = c, c = c->next) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tif (!strcmp(newc->u.name, c->u.name) &&\n\t\t\t\t    (!c->v.sclass || !newc->v.sclass ||\n\t\t\t\t     newc->v.sclass == c->v.sclass)) {\n\t\t\t\t\tprintk(KERN_ERR \"SELinux:  dup genfs entry (%s,%s)\\n\",\n\t\t\t\t\t       genfs->fstype, c->u.name);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tlen = strlen(newc->u.name);\n\t\t\t\tlen2 = strlen(c->u.name);\n\t\t\t\tif (len > len2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnewc->next = c;\n\t\t\tif (l)\n\t\t\t\tl->next = newc;\n\t\t\telse\n\t\t\t\tgenfs->head = newc;\n\t\t\tnewc = NULL;\n\t\t}\n\t}\n\trc = 0;\nout:\n\tif (newgenfs) {\n\t\tkfree(newgenfs->fstype);\n\t\tkfree(newgenfs);\n\t}\n\tocontext_destroy(newc, OCON_FSUSE);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocontext_read",
          "args": [
            "p",
            "info",
            "fp"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "ocontext_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "2105-2270",
          "snippet": "static int ocontext_read(struct policydb *p, struct policydb_compat_info *info,\n\t\t\t void *fp)\n{\n\tint i, j, rc;\n\tu32 nel, len;\n\t__le32 buf[3];\n\tstruct ocontext *l, *c;\n\tu32 nodebuf[8];\n\n\tfor (i = 0; i < info->ocon_num; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tnel = le32_to_cpu(buf[0]);\n\n\t\tl = NULL;\n\t\tfor (j = 0; j < nel; j++) {\n\t\t\trc = -ENOMEM;\n\t\t\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\t\t\tif (!c)\n\t\t\t\tgoto out;\n\t\t\tif (l)\n\t\t\t\tl->next = c;\n\t\t\telse\n\t\t\t\tp->ocontexts[i] = c;\n\t\t\tl = c;\n\n\t\t\tswitch (i) {\n\t\t\tcase OCON_ISID:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tc->sid[0] = le32_to_cpu(buf[0]);\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FS:\n\t\t\tcase OCON_NETIF:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\t\trc = str_read(&c->u.name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\trc = context_read_and_validate(&c->context[1], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_PORT:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32)*3);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tc->u.port.protocol = le32_to_cpu(buf[0]);\n\t\t\t\tc->u.port.low_port = le32_to_cpu(buf[1]);\n\t\t\t\tc->u.port.high_port = le32_to_cpu(buf[2]);\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE:\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tc->u.node.addr = nodebuf[0]; /* network order */\n\t\t\t\tc->u.node.mask = nodebuf[1]; /* network order */\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FSUSE:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = -EINVAL;\n\t\t\t\tc->v.behavior = le32_to_cpu(buf[0]);\n\t\t\t\t/* Determined at runtime, not in policy DB. */\n\t\t\t\tif (c->v.behavior == SECURITY_FS_USE_MNTPOINT)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (c->v.behavior > SECURITY_FS_USE_MAX)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tlen = le32_to_cpu(buf[1]);\n\t\t\t\trc = str_read(&c->u.name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE6: {\n\t\t\t\tint k;\n\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 8);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tc->u.node6.addr[k] = nodebuf[k];\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tc->u.node6.mask[k] = nodebuf[k+4];\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase OCON_IBPKEY:\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 4);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tc->u.ibpkey.subnet_prefix = be64_to_cpu(*((__be64 *)nodebuf));\n\n\t\t\t\tif (nodebuf[2] > 0xffff ||\n\t\t\t\t    nodebuf[3] > 0xffff) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tc->u.ibpkey.low_pkey = le32_to_cpu(nodebuf[2]);\n\t\t\t\tc->u.ibpkey.high_pkey = le32_to_cpu(nodebuf[3]);\n\n\t\t\t\trc = context_read_and_validate(&c->context[0],\n\t\t\t\t\t\t\t       p,\n\t\t\t\t\t\t\t       fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBENDPORT:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\t\trc = str_read(&c->u.ibendport.dev_name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tif (buf[1] > 0xff || buf[1] == 0) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tc->u.ibendport.port = le32_to_cpu(buf[1]);\n\n\t\t\t\trc = context_read_and_validate(&c->context[0],\n\t\t\t\t\t\t\t       p,\n\t\t\t\t\t\t\t       fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int ocontext_read(struct policydb *p, struct policydb_compat_info *info,\n\t\t\t void *fp)\n{\n\tint i, j, rc;\n\tu32 nel, len;\n\t__le32 buf[3];\n\tstruct ocontext *l, *c;\n\tu32 nodebuf[8];\n\n\tfor (i = 0; i < info->ocon_num; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tnel = le32_to_cpu(buf[0]);\n\n\t\tl = NULL;\n\t\tfor (j = 0; j < nel; j++) {\n\t\t\trc = -ENOMEM;\n\t\t\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\t\t\tif (!c)\n\t\t\t\tgoto out;\n\t\t\tif (l)\n\t\t\t\tl->next = c;\n\t\t\telse\n\t\t\t\tp->ocontexts[i] = c;\n\t\t\tl = c;\n\n\t\t\tswitch (i) {\n\t\t\tcase OCON_ISID:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tc->sid[0] = le32_to_cpu(buf[0]);\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FS:\n\t\t\tcase OCON_NETIF:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\t\trc = str_read(&c->u.name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\trc = context_read_and_validate(&c->context[1], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_PORT:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32)*3);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tc->u.port.protocol = le32_to_cpu(buf[0]);\n\t\t\t\tc->u.port.low_port = le32_to_cpu(buf[1]);\n\t\t\t\tc->u.port.high_port = le32_to_cpu(buf[2]);\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE:\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tc->u.node.addr = nodebuf[0]; /* network order */\n\t\t\t\tc->u.node.mask = nodebuf[1]; /* network order */\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FSUSE:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = -EINVAL;\n\t\t\t\tc->v.behavior = le32_to_cpu(buf[0]);\n\t\t\t\t/* Determined at runtime, not in policy DB. */\n\t\t\t\tif (c->v.behavior == SECURITY_FS_USE_MNTPOINT)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (c->v.behavior > SECURITY_FS_USE_MAX)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tlen = le32_to_cpu(buf[1]);\n\t\t\t\trc = str_read(&c->u.name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE6: {\n\t\t\t\tint k;\n\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 8);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tc->u.node6.addr[k] = nodebuf[k];\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tc->u.node6.mask[k] = nodebuf[k+4];\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase OCON_IBPKEY:\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 4);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tc->u.ibpkey.subnet_prefix = be64_to_cpu(*((__be64 *)nodebuf));\n\n\t\t\t\tif (nodebuf[2] > 0xffff ||\n\t\t\t\t    nodebuf[3] > 0xffff) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tc->u.ibpkey.low_pkey = le32_to_cpu(nodebuf[2]);\n\t\t\t\tc->u.ibpkey.high_pkey = le32_to_cpu(nodebuf[3]);\n\n\t\t\t\trc = context_read_and_validate(&c->context[0],\n\t\t\t\t\t\t\t       p,\n\t\t\t\t\t\t\t       fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBENDPORT:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\t\trc = str_read(&c->u.ibendport.dev_name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tif (buf[1] > 0xff || buf[1] == 0) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tc->u.ibendport.port = le32_to_cpu(buf[1]);\n\n\t\t\t\trc = context_read_and_validate(&c->context[0],\n\t\t\t\t\t\t\t       p,\n\t\t\t\t\t\t\t       fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_to_av_perm",
          "args": [
            "p",
            "p->process_class",
            "\"dyntransition\""
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "string_to_av_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1815-1836",
          "snippet": "u32 string_to_av_perm(struct policydb *p, u16 tclass, const char *name)\n{\n\tstruct class_datum *cladatum;\n\tstruct perm_datum *perdatum = NULL;\n\tstruct common_datum *comdatum;\n\n\tif (!tclass || tclass > p->p_classes.nprim)\n\t\treturn 0;\n\n\tcladatum = p->class_val_to_struct[tclass-1];\n\tcomdatum = cladatum->comdatum;\n\tif (comdatum)\n\t\tperdatum = hashtab_search(comdatum->permissions.table,\n\t\t\t\t\t  name);\n\tif (!perdatum)\n\t\tperdatum = hashtab_search(cladatum->permissions.table,\n\t\t\t\t\t  name);\n\tif (!perdatum)\n\t\treturn 0;\n\n\treturn 1U << (perdatum->value-1);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nu32 string_to_av_perm(struct policydb *p, u16 tclass, const char *name)\n{\n\tstruct class_datum *cladatum;\n\tstruct perm_datum *perdatum = NULL;\n\tstruct common_datum *comdatum;\n\n\tif (!tclass || tclass > p->p_classes.nprim)\n\t\treturn 0;\n\n\tcladatum = p->class_val_to_struct[tclass-1];\n\tcomdatum = cladatum->comdatum;\n\tif (comdatum)\n\t\tperdatum = hashtab_search(comdatum->permissions.table,\n\t\t\t\t\t  name);\n\tif (!perdatum)\n\t\tperdatum = hashtab_search(cladatum->permissions.table,\n\t\t\t\t\t  name);\n\tif (!perdatum)\n\t\treturn 0;\n\n\treturn 1U << (perdatum->value-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policydb_index",
          "args": [
            "p"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "532-605",
          "snippet": "static int policydb_index(struct policydb *p)\n{\n\tint i, rc;\n\n\tprintk(KERN_DEBUG \"SELinux:  %d users, %d roles, %d types, %d bools\",\n\t       p->p_users.nprim, p->p_roles.nprim, p->p_types.nprim, p->p_bools.nprim);\n\tif (p->mls_enabled)\n\t\tprintk(KERN_CONT \", %d sens, %d cats\", p->p_levels.nprim,\n\t\t       p->p_cats.nprim);\n\tprintk(KERN_CONT \"\\n\");\n\n\tprintk(KERN_DEBUG \"SELinux:  %d classes, %d rules\\n\",\n\t       p->p_classes.nprim, p->te_avtab.nel);\n\n#ifdef DEBUG_HASHES\n\tavtab_hash_eval(&p->te_avtab, \"rules\");\n\tsymtab_hash_eval(p->symtab);\n#endif\n\n\tp->class_val_to_struct = kcalloc(p->p_classes.nprim,\n\t\t\t\t\t sizeof(*p->class_val_to_struct),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!p->class_val_to_struct)\n\t\treturn -ENOMEM;\n\n\tp->role_val_to_struct = kcalloc(p->p_roles.nprim,\n\t\t\t\t\tsizeof(*p->role_val_to_struct),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!p->role_val_to_struct)\n\t\treturn -ENOMEM;\n\n\tp->user_val_to_struct = kcalloc(p->p_users.nprim,\n\t\t\t\t\tsizeof(*p->user_val_to_struct),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!p->user_val_to_struct)\n\t\treturn -ENOMEM;\n\n\t/* Yes, I want the sizeof the pointer, not the structure */\n\tp->type_val_to_struct_array = flex_array_alloc(sizeof(struct type_datum *),\n\t\t\t\t\t\t       p->p_types.nprim,\n\t\t\t\t\t\t       GFP_KERNEL | __GFP_ZERO);\n\tif (!p->type_val_to_struct_array)\n\t\treturn -ENOMEM;\n\n\trc = flex_array_prealloc(p->type_val_to_struct_array, 0,\n\t\t\t\t p->p_types.nprim, GFP_KERNEL | __GFP_ZERO);\n\tif (rc)\n\t\tgoto out;\n\n\trc = cond_init_bool_indexes(p);\n\tif (rc)\n\t\tgoto out;\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tp->sym_val_to_name[i] = flex_array_alloc(sizeof(char *),\n\t\t\t\t\t\t\t p->symtab[i].nprim,\n\t\t\t\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\t\tif (!p->sym_val_to_name[i])\n\t\t\treturn -ENOMEM;\n\n\t\trc = flex_array_prealloc(p->sym_val_to_name[i],\n\t\t\t\t\t 0, p->symtab[i].nprim,\n\t\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = hashtab_map(p->symtab[i].table, index_f[i], p);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int (*index_f[SYM_NUM]) (void *key, void *datum, void *datap) =\n{\n\tcommon_index,\n\tclass_index,\n\trole_index,\n\ttype_index,\n\tuser_index,\n\tcond_index_bool,\n\tsens_index,\n\tcat_index,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int (*index_f[SYM_NUM]) (void *key, void *datum, void *datap) =\n{\n\tcommon_index,\n\tclass_index,\n\trole_index,\n\ttype_index,\n\tuser_index,\n\tcond_index_bool,\n\tsens_index,\n\tcat_index,\n};\n\nstatic int policydb_index(struct policydb *p)\n{\n\tint i, rc;\n\n\tprintk(KERN_DEBUG \"SELinux:  %d users, %d roles, %d types, %d bools\",\n\t       p->p_users.nprim, p->p_roles.nprim, p->p_types.nprim, p->p_bools.nprim);\n\tif (p->mls_enabled)\n\t\tprintk(KERN_CONT \", %d sens, %d cats\", p->p_levels.nprim,\n\t\t       p->p_cats.nprim);\n\tprintk(KERN_CONT \"\\n\");\n\n\tprintk(KERN_DEBUG \"SELinux:  %d classes, %d rules\\n\",\n\t       p->p_classes.nprim, p->te_avtab.nel);\n\n#ifdef DEBUG_HASHES\n\tavtab_hash_eval(&p->te_avtab, \"rules\");\n\tsymtab_hash_eval(p->symtab);\n#endif\n\n\tp->class_val_to_struct = kcalloc(p->p_classes.nprim,\n\t\t\t\t\t sizeof(*p->class_val_to_struct),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!p->class_val_to_struct)\n\t\treturn -ENOMEM;\n\n\tp->role_val_to_struct = kcalloc(p->p_roles.nprim,\n\t\t\t\t\tsizeof(*p->role_val_to_struct),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!p->role_val_to_struct)\n\t\treturn -ENOMEM;\n\n\tp->user_val_to_struct = kcalloc(p->p_users.nprim,\n\t\t\t\t\tsizeof(*p->user_val_to_struct),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!p->user_val_to_struct)\n\t\treturn -ENOMEM;\n\n\t/* Yes, I want the sizeof the pointer, not the structure */\n\tp->type_val_to_struct_array = flex_array_alloc(sizeof(struct type_datum *),\n\t\t\t\t\t\t       p->p_types.nprim,\n\t\t\t\t\t\t       GFP_KERNEL | __GFP_ZERO);\n\tif (!p->type_val_to_struct_array)\n\t\treturn -ENOMEM;\n\n\trc = flex_array_prealloc(p->type_val_to_struct_array, 0,\n\t\t\t\t p->p_types.nprim, GFP_KERNEL | __GFP_ZERO);\n\tif (rc)\n\t\tgoto out;\n\n\trc = cond_init_bool_indexes(p);\n\tif (rc)\n\t\tgoto out;\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tp->sym_val_to_name[i] = flex_array_alloc(sizeof(char *),\n\t\t\t\t\t\t\t p->symtab[i].nprim,\n\t\t\t\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\t\tif (!p->sym_val_to_name[i])\n\t\t\treturn -ENOMEM;\n\n\t\trc = flex_array_prealloc(p->sym_val_to_name[i],\n\t\t\t\t\t 0, p->symtab[i].nprim,\n\t\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = hashtab_map(p->symtab[i].table, index_f[i], p);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filename_trans_read",
          "args": [
            "p",
            "fp"
          ],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "filename_trans_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1910-1990",
          "snippet": "static int filename_trans_read(struct policydb *p, void *fp)\n{\n\tstruct filename_trans *ft;\n\tstruct filename_trans_datum *otype;\n\tchar *name;\n\tu32 nel, len;\n\t__le32 buf[4];\n\tint rc, i;\n\n\tif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\n\t\treturn 0;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tnel = le32_to_cpu(buf[0]);\n\n\tfor (i = 0; i < nel; i++) {\n\t\totype = NULL;\n\t\tname = NULL;\n\n\t\trc = -ENOMEM;\n\t\tft = kzalloc(sizeof(*ft), GFP_KERNEL);\n\t\tif (!ft)\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\totype = kmalloc(sizeof(*otype), GFP_KERNEL);\n\t\tif (!otype)\n\t\t\tgoto out;\n\n\t\t/* length of the path component string */\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t/* path component string */\n\t\trc = str_read(&name, GFP_KERNEL, fp, len);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tft->name = name;\n\n\t\trc = next_entry(buf, fp, sizeof(u32) * 4);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tft->stype = le32_to_cpu(buf[0]);\n\t\tft->ttype = le32_to_cpu(buf[1]);\n\t\tft->tclass = le32_to_cpu(buf[2]);\n\n\t\totype->otype = le32_to_cpu(buf[3]);\n\n\t\trc = ebitmap_set_bit(&p->filename_trans_ttypes, ft->ttype, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = hashtab_insert(p->filename_trans, ft, otype);\n\t\tif (rc) {\n\t\t\t/*\n\t\t\t * Do not return -EEXIST to the caller, or the system\n\t\t\t * will not boot.\n\t\t\t */\n\t\t\tif (rc != -EEXIST)\n\t\t\t\tgoto out;\n\t\t\t/* But free memory to avoid memory leak. */\n\t\t\tkfree(ft);\n\t\t\tkfree(name);\n\t\t\tkfree(otype);\n\t\t}\n\t}\n\thash_eval(p->filename_trans, \"filenametr\");\n\treturn 0;\nout:\n\tkfree(ft);\n\tkfree(name);\n\tkfree(otype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int filename_trans_read(struct policydb *p, void *fp)\n{\n\tstruct filename_trans *ft;\n\tstruct filename_trans_datum *otype;\n\tchar *name;\n\tu32 nel, len;\n\t__le32 buf[4];\n\tint rc, i;\n\n\tif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\n\t\treturn 0;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tnel = le32_to_cpu(buf[0]);\n\n\tfor (i = 0; i < nel; i++) {\n\t\totype = NULL;\n\t\tname = NULL;\n\n\t\trc = -ENOMEM;\n\t\tft = kzalloc(sizeof(*ft), GFP_KERNEL);\n\t\tif (!ft)\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\totype = kmalloc(sizeof(*otype), GFP_KERNEL);\n\t\tif (!otype)\n\t\t\tgoto out;\n\n\t\t/* length of the path component string */\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t/* path component string */\n\t\trc = str_read(&name, GFP_KERNEL, fp, len);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tft->name = name;\n\n\t\trc = next_entry(buf, fp, sizeof(u32) * 4);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tft->stype = le32_to_cpu(buf[0]);\n\t\tft->ttype = le32_to_cpu(buf[1]);\n\t\tft->tclass = le32_to_cpu(buf[2]);\n\n\t\totype->otype = le32_to_cpu(buf[3]);\n\n\t\trc = ebitmap_set_bit(&p->filename_trans_ttypes, ft->ttype, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = hashtab_insert(p->filename_trans, ft, otype);\n\t\tif (rc) {\n\t\t\t/*\n\t\t\t * Do not return -EEXIST to the caller, or the system\n\t\t\t * will not boot.\n\t\t\t */\n\t\t\tif (rc != -EEXIST)\n\t\t\t\tgoto out;\n\t\t\t/* But free memory to avoid memory leak. */\n\t\t\tkfree(ft);\n\t\t\tkfree(name);\n\t\t\tkfree(otype);\n\t\t}\n\t}\n\thash_eval(p->filename_trans, \"filenametr\");\n\treturn 0;\nout:\n\tkfree(ft);\n\tkfree(name);\n\tkfree(otype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "policydb_role_isvalid",
          "args": [
            "p",
            "ra->new_role"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_role_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "932-937",
          "snippet": "int policydb_role_isvalid(struct policydb *p, unsigned int role)\n{\n\tif (!role || role > p->p_roles.nprim)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_role_isvalid(struct policydb *p, unsigned int role)\n{\n\tif (!role || role > p->p_roles.nprim)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(u32)*2"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ra)",
            "GFP_KERNEL"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policydb_class_isvalid",
          "args": [
            "p",
            "tr->tclass"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_class_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "925-930",
          "snippet": "int policydb_class_isvalid(struct policydb *p, unsigned int class)\n{\n\tif (!class || class > p->p_classes.nprim)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_class_isvalid(struct policydb *p, unsigned int class)\n{\n\tif (!class || class > p->p_classes.nprim)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "policydb_type_isvalid",
          "args": [
            "p",
            "tr->type"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_type_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "939-944",
          "snippet": "int policydb_type_isvalid(struct policydb *p, unsigned int type)\n{\n\tif (!type || type > p->p_types.nprim)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_type_isvalid(struct policydb *p, unsigned int type)\n{\n\tif (!type || type > p->p_types.nprim)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tr)",
            "GFP_KERNEL"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_read_list",
          "args": [
            "p",
            "fp"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "cond_read_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "455-493",
          "snippet": "int cond_read_list(struct policydb *p, void *fp)\n{\n\tstruct cond_node *node, *last = NULL;\n\t__le32 buf[1];\n\tu32 i, len;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\treturn rc;\n\n\tlen = le32_to_cpu(buf[0]);\n\n\trc = avtab_alloc(&(p->te_cond_avtab), p->te_avtab.nel);\n\tif (rc)\n\t\tgoto err;\n\n\tfor (i = 0; i < len; i++) {\n\t\trc = -ENOMEM;\n\t\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\t\tif (!node)\n\t\t\tgoto err;\n\n\t\trc = cond_read_node(p, node, fp);\n\t\tif (rc)\n\t\t\tgoto err;\n\n\t\tif (i == 0)\n\t\t\tp->cond_list = node;\n\t\telse\n\t\t\tlast->next = node;\n\t\tlast = node;\n\t}\n\treturn 0;\nerr:\n\tcond_list_destroy(p->cond_list);\n\tp->cond_list = NULL;\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint cond_read_list(struct policydb *p, void *fp)\n{\n\tstruct cond_node *node, *last = NULL;\n\t__le32 buf[1];\n\tu32 i, len;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\treturn rc;\n\n\tlen = le32_to_cpu(buf[0]);\n\n\trc = avtab_alloc(&(p->te_cond_avtab), p->te_avtab.nel);\n\tif (rc)\n\t\tgoto err;\n\n\tfor (i = 0; i < len; i++) {\n\t\trc = -ENOMEM;\n\t\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\t\tif (!node)\n\t\t\tgoto err;\n\n\t\trc = cond_read_node(p, node, fp);\n\t\tif (rc)\n\t\t\tgoto err;\n\n\t\tif (i == 0)\n\t\t\tp->cond_list = node;\n\t\telse\n\t\t\tlast->next = node;\n\t\tlast = node;\n\t}\n\treturn 0;\nerr:\n\tcond_list_destroy(p->cond_list);\n\tp->cond_list = NULL;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avtab_read",
          "args": [
            "&p->te_avtab",
            "fp",
            "p"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "556-598",
          "snippet": "int avtab_read(struct avtab *a, void *fp, struct policydb *pol)\n{\n\tint rc;\n\t__le32 buf[1];\n\tu32 nel, i;\n\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: truncated table\\n\");\n\t\tgoto bad;\n\t}\n\tnel = le32_to_cpu(buf[0]);\n\tif (!nel) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: table is empty\\n\");\n\t\trc = -EINVAL;\n\t\tgoto bad;\n\t}\n\n\trc = avtab_alloc(a, nel);\n\tif (rc)\n\t\tgoto bad;\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = avtab_read_item(a, fp, pol, avtab_insertf, NULL);\n\t\tif (rc) {\n\t\t\tif (rc == -ENOMEM)\n\t\t\t\tprintk(KERN_ERR \"SELinux: avtab: out of memory\\n\");\n\t\t\telse if (rc == -EEXIST)\n\t\t\t\tprintk(KERN_ERR \"SELinux: avtab: duplicate entry\\n\");\n\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\trc = 0;\nout:\n\treturn rc;\n\nbad:\n\tavtab_destroy(a);\n\tgoto out;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint avtab_read(struct avtab *a, void *fp, struct policydb *pol)\n{\n\tint rc;\n\t__le32 buf[1];\n\tu32 nel, i;\n\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: truncated table\\n\");\n\t\tgoto bad;\n\t}\n\tnel = le32_to_cpu(buf[0]);\n\tif (!nel) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: table is empty\\n\");\n\t\trc = -EINVAL;\n\t\tgoto bad;\n\t}\n\n\trc = avtab_alloc(a, nel);\n\tif (rc)\n\t\tgoto bad;\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = avtab_read_item(a, fp, pol, avtab_insertf, NULL);\n\t\tif (rc) {\n\t\t\tif (rc == -ENOMEM)\n\t\t\t\tprintk(KERN_ERR \"SELinux: avtab: out of memory\\n\");\n\t\t\telse if (rc == -EEXIST)\n\t\t\t\tprintk(KERN_ERR \"SELinux: avtab: duplicate entry\\n\");\n\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\trc = 0;\nout:\n\treturn rc;\n\nbad:\n\tavtab_destroy(a);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_to_security_class",
          "args": [
            "p",
            "\"process\""
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "string_to_security_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1804-1813",
          "snippet": "u16 string_to_security_class(struct policydb *p, const char *name)\n{\n\tstruct class_datum *cladatum;\n\n\tcladatum = hashtab_search(p->p_classes.table, name);\n\tif (!cladatum)\n\t\treturn 0;\n\n\treturn cladatum->value;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nu16 string_to_security_class(struct policydb *p, const char *name)\n{\n\tstruct class_datum *cladatum;\n\n\tcladatum = hashtab_search(p->p_classes.table, name);\n\tif (!cladatum)\n\t\treturn 0;\n\n\treturn cladatum->value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_f[i]",
          "args": [
            "p",
            "p->symtab[i].table",
            "fp"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  policydb table sizes (%d,%d) do \"\n\t\t       \"not match mine (%d,%d)\\n\"",
            "le32_to_cpu(buf[2])",
            "le32_to_cpu(buf[3])",
            "info->sym_num",
            "info->ocon_num"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[3]"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[3]"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  unable to find policy compat info \"\n\t\t       \"for version %d\\n\"",
            "p->policyvers"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policydb_lookup_compat",
          "args": [
            "p->policyvers"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_lookup_compat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "168-180",
          "snippet": "static struct policydb_compat_info *policydb_lookup_compat(int version)\n{\n\tint i;\n\tstruct policydb_compat_info *info = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(policydb_compat); i++) {\n\t\tif (policydb_compat[i].version == version) {\n\t\t\tinfo = &policydb_compat[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn info;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct policydb_compat_info policydb_compat[] = {\n\t{\n\t\t.version\t= POLICYDB_VERSION_BASE,\n\t\t.sym_num\t= SYM_NUM - 3,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOOL,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_IPV6,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NLCLASS,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_MLS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_AVTAB,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_RANGETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_POLCAP,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_PERMISSIVE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOUNDARY,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_FILENAME_TRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_ROLETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NEW_OBJECT_DEFAULTS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_DEFAULT_TYPE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_CONSTRAINT_NAMES,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_XPERMS_IOCTL,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_INFINIBAND,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic struct policydb_compat_info policydb_compat[] = {\n\t{\n\t\t.version\t= POLICYDB_VERSION_BASE,\n\t\t.sym_num\t= SYM_NUM - 3,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOOL,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_IPV6,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NLCLASS,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_MLS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_AVTAB,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_RANGETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_POLCAP,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_PERMISSIVE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOUNDARY,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_FILENAME_TRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_ROLETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NEW_OBJECT_DEFAULTS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_DEFAULT_TYPE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_CONSTRAINT_NAMES,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_XPERMS_IOCTL,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_INFINIBAND,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM,\n\t},\n};\n\nstatic struct policydb_compat_info *policydb_lookup_compat(int version)\n{\n\tint i;\n\tstruct policydb_compat_info *info = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(policydb_compat); i++) {\n\t\tif (policydb_compat[i].version == version) {\n\t\t\tinfo = &policydb_compat[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  policydb version %d does not match \"\n\t\t       \"my version range %d-%d\\n\"",
            "le32_to_cpu(buf[0])",
            "POLICYDB_VERSION_MIN",
            "POLICYDB_VERSION_MAX"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_xprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1764-1785",
          "snippet": "void aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "policydb_str"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "policydb_str"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  policydb string %s does not match \"\n\t\t       \"my string %s\\n\"",
            "policydb_str",
            "POLICYDB_STRING"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "policydb_str",
            "POLICYDB_STRING"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "policydb_str"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  truncated policydb string identifier\\n\""
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  policydb string length %d does not \"\n\t\t       \"match expected length %zu\\n\"",
            "len",
            "strlen(POLICYDB_STRING)"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "POLICYDB_STRING"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "POLICYDB_STRING"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  policydb magic number 0x%x does \"\n\t\t       \"not match expected magic number 0x%x\\n\"",
            "le32_to_cpu(buf[0])",
            "POLICYDB_MAGIC"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policydb_init",
          "args": [
            "p"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "281-328",
          "snippet": "static int policydb_init(struct policydb *p)\n{\n\tint i, rc;\n\n\tmemset(p, 0, sizeof(*p));\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\trc = symtab_init(&p->symtab[i], symtab_sizes[i]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = avtab_init(&p->te_avtab);\n\tif (rc)\n\t\tgoto out;\n\n\trc = roles_init(p);\n\tif (rc)\n\t\tgoto out;\n\n\trc = cond_policydb_init(p);\n\tif (rc)\n\t\tgoto out;\n\n\tp->filename_trans = hashtab_create(filenametr_hash, filenametr_cmp, (1 << 10));\n\tif (!p->filename_trans) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tp->range_tr = hashtab_create(rangetr_hash, rangetr_cmp, 256);\n\tif (!p->range_tr) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tebitmap_init(&p->filename_trans_ttypes);\n\tebitmap_init(&p->policycaps);\n\tebitmap_init(&p->permissive_map);\n\n\treturn 0;\nout:\n\thashtab_destroy(p->filename_trans);\n\thashtab_destroy(p->range_tr);\n\tfor (i = 0; i < SYM_NUM; i++)\n\t\thashtab_destroy(p->symtab[i].table);\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int symtab_sizes[SYM_NUM] = {\n\t2,\n\t32,\n\t16,\n\t512,\n\t128,\n\t16,\n\t16,\n\t16,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic unsigned int symtab_sizes[SYM_NUM] = {\n\t2,\n\t32,\n\t16,\n\t512,\n\t128,\n\t16,\n\t16,\n\t16,\n};\n\nstatic int policydb_init(struct policydb *p)\n{\n\tint i, rc;\n\n\tmemset(p, 0, sizeof(*p));\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\trc = symtab_init(&p->symtab[i], symtab_sizes[i]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = avtab_init(&p->te_avtab);\n\tif (rc)\n\t\tgoto out;\n\n\trc = roles_init(p);\n\tif (rc)\n\t\tgoto out;\n\n\trc = cond_policydb_init(p);\n\tif (rc)\n\t\tgoto out;\n\n\tp->filename_trans = hashtab_create(filenametr_hash, filenametr_cmp, (1 << 10));\n\tif (!p->filename_trans) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tp->range_tr = hashtab_create(rangetr_hash, rangetr_cmp, 256);\n\tif (!p->range_tr) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tebitmap_init(&p->filename_trans_ttypes);\n\tebitmap_init(&p->policycaps);\n\tebitmap_init(&p->permissive_map);\n\n\treturn 0;\nout:\n\thashtab_destroy(p->filename_trans);\n\thashtab_destroy(p->range_tr);\n\tfor (i = 0; i < SYM_NUM; i++)\n\t\thashtab_destroy(p->symtab[i].table);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int (*read_f[SYM_NUM]) (struct policydb *p, struct hashtab *h, void *fp) =\n{\n\tcommon_read,\n\tclass_read,\n\trole_read,\n\ttype_read,\n\tuser_read,\n\tcond_read_bool,\n\tsens_read,\n\tcat_read,\n};\n\nint policydb_read(struct policydb *p, void *fp)\n{\n\tstruct role_allow *ra, *lra;\n\tstruct role_trans *tr, *ltr;\n\tint i, j, rc;\n\t__le32 buf[4];\n\tu32 len, nprim, nel;\n\n\tchar *policydb_str;\n\tstruct policydb_compat_info *info;\n\n\trc = policydb_init(p);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Read the magic number and string length. */\n\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tif (le32_to_cpu(buf[0]) != POLICYDB_MAGIC) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb magic number 0x%x does \"\n\t\t       \"not match expected magic number 0x%x\\n\",\n\t\t       le32_to_cpu(buf[0]), POLICYDB_MAGIC);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tlen = le32_to_cpu(buf[1]);\n\tif (len != strlen(POLICYDB_STRING)) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb string length %d does not \"\n\t\t       \"match expected length %zu\\n\",\n\t\t       len, strlen(POLICYDB_STRING));\n\t\tgoto bad;\n\t}\n\n\trc = -ENOMEM;\n\tpolicydb_str = kmalloc(len + 1, GFP_KERNEL);\n\tif (!policydb_str) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to allocate memory for policydb \"\n\t\t       \"string of length %d\\n\", len);\n\t\tgoto bad;\n\t}\n\n\trc = next_entry(policydb_str, fp, len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  truncated policydb string identifier\\n\");\n\t\tkfree(policydb_str);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tpolicydb_str[len] = '\\0';\n\tif (strcmp(policydb_str, POLICYDB_STRING)) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb string %s does not match \"\n\t\t       \"my string %s\\n\", policydb_str, POLICYDB_STRING);\n\t\tkfree(policydb_str);\n\t\tgoto bad;\n\t}\n\t/* Done with policydb_str. */\n\tkfree(policydb_str);\n\tpolicydb_str = NULL;\n\n\t/* Read the version and table sizes. */\n\trc = next_entry(buf, fp, sizeof(u32)*4);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tp->policyvers = le32_to_cpu(buf[0]);\n\tif (p->policyvers < POLICYDB_VERSION_MIN ||\n\t    p->policyvers > POLICYDB_VERSION_MAX) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb version %d does not match \"\n\t\t       \"my version range %d-%d\\n\",\n\t\t       le32_to_cpu(buf[0]), POLICYDB_VERSION_MIN, POLICYDB_VERSION_MAX);\n\t\tgoto bad;\n\t}\n\n\tif ((le32_to_cpu(buf[1]) & POLICYDB_CONFIG_MLS)) {\n\t\tp->mls_enabled = 1;\n\n\t\trc = -EINVAL;\n\t\tif (p->policyvers < POLICYDB_VERSION_MLS) {\n\t\t\tprintk(KERN_ERR \"SELinux: security policydb version %d \"\n\t\t\t\t\"(MLS) not backwards compatible\\n\",\n\t\t\t\tp->policyvers);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tp->reject_unknown = !!(le32_to_cpu(buf[1]) & REJECT_UNKNOWN);\n\tp->allow_unknown = !!(le32_to_cpu(buf[1]) & ALLOW_UNKNOWN);\n\n\tif (p->policyvers >= POLICYDB_VERSION_POLCAP) {\n\t\trc = ebitmap_read(&p->policycaps, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_PERMISSIVE) {\n\t\trc = ebitmap_read(&p->permissive_map, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tinfo = policydb_lookup_compat(p->policyvers);\n\tif (!info) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to find policy compat info \"\n\t\t       \"for version %d\\n\", p->policyvers);\n\t\tgoto bad;\n\t}\n\n\trc = -EINVAL;\n\tif (le32_to_cpu(buf[2]) != info->sym_num ||\n\t\tle32_to_cpu(buf[3]) != info->ocon_num) {\n\t\tprintk(KERN_ERR \"SELinux:  policydb table sizes (%d,%d) do \"\n\t\t       \"not match mine (%d,%d)\\n\", le32_to_cpu(buf[2]),\n\t\t\tle32_to_cpu(buf[3]),\n\t\t       info->sym_num, info->ocon_num);\n\t\tgoto bad;\n\t}\n\n\tfor (i = 0; i < info->sym_num; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\tnprim = le32_to_cpu(buf[0]);\n\t\tnel = le32_to_cpu(buf[1]);\n\t\tfor (j = 0; j < nel; j++) {\n\t\t\trc = read_f[i](p, p->symtab[i].table, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t}\n\n\t\tp->symtab[i].nprim = nprim;\n\t}\n\n\trc = -EINVAL;\n\tp->process_class = string_to_security_class(p, \"process\");\n\tif (!p->process_class)\n\t\tgoto bad;\n\n\trc = avtab_read(&p->te_avtab, fp, p);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOOL) {\n\t\trc = cond_read_list(p, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto bad;\n\tnel = le32_to_cpu(buf[0]);\n\tltr = NULL;\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\ttr = kzalloc(sizeof(*tr), GFP_KERNEL);\n\t\tif (!tr)\n\t\t\tgoto bad;\n\t\tif (ltr)\n\t\t\tltr->next = tr;\n\t\telse\n\t\t\tp->role_tr = tr;\n\t\trc = next_entry(buf, fp, sizeof(u32)*3);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trc = -EINVAL;\n\t\ttr->role = le32_to_cpu(buf[0]);\n\t\ttr->type = le32_to_cpu(buf[1]);\n\t\ttr->new_role = le32_to_cpu(buf[2]);\n\t\tif (p->policyvers >= POLICYDB_VERSION_ROLETRANS) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t\ttr->tclass = le32_to_cpu(buf[0]);\n\t\t} else\n\t\t\ttr->tclass = p->process_class;\n\n\t\trc = -EINVAL;\n\t\tif (!policydb_role_isvalid(p, tr->role) ||\n\t\t    !policydb_type_isvalid(p, tr->type) ||\n\t\t    !policydb_class_isvalid(p, tr->tclass) ||\n\t\t    !policydb_role_isvalid(p, tr->new_role))\n\t\t\tgoto bad;\n\t\tltr = tr;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto bad;\n\tnel = le32_to_cpu(buf[0]);\n\tlra = NULL;\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\tra = kzalloc(sizeof(*ra), GFP_KERNEL);\n\t\tif (!ra)\n\t\t\tgoto bad;\n\t\tif (lra)\n\t\t\tlra->next = ra;\n\t\telse\n\t\t\tp->role_allow = ra;\n\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trc = -EINVAL;\n\t\tra->role = le32_to_cpu(buf[0]);\n\t\tra->new_role = le32_to_cpu(buf[1]);\n\t\tif (!policydb_role_isvalid(p, ra->role) ||\n\t\t    !policydb_role_isvalid(p, ra->new_role))\n\t\t\tgoto bad;\n\t\tlra = ra;\n\t}\n\n\trc = filename_trans_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = policydb_index(p);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -EINVAL;\n\tp->process_trans_perms = string_to_av_perm(p, p->process_class, \"transition\");\n\tp->process_trans_perms |= string_to_av_perm(p, p->process_class, \"dyntransition\");\n\tif (!p->process_trans_perms)\n\t\tgoto bad;\n\n\trc = ocontext_read(p, info, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = genfs_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = range_read(p, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -ENOMEM;\n\tp->type_attr_map_array = flex_array_alloc(sizeof(struct ebitmap),\n\t\t\t\t\t\t  p->p_types.nprim,\n\t\t\t\t\t\t  GFP_KERNEL | __GFP_ZERO);\n\tif (!p->type_attr_map_array)\n\t\tgoto bad;\n\n\t/* preallocate so we don't have to worry about the put ever failing */\n\trc = flex_array_prealloc(p->type_attr_map_array, 0, p->p_types.nprim,\n\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\tif (rc)\n\t\tgoto bad;\n\n\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\tstruct ebitmap *e = flex_array_get(p->type_attr_map_array, i);\n\n\t\tBUG_ON(!e);\n\t\tebitmap_init(e);\n\t\tif (p->policyvers >= POLICYDB_VERSION_AVTAB) {\n\t\t\trc = ebitmap_read(e, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto bad;\n\t\t}\n\t\t/* add the type itself as the degenerate case */\n\t\trc = ebitmap_set_bit(e, i, 1);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = policydb_bounds_sanity_check(p);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tpolicydb_destroy(p);\n\tgoto out;\n}"
  },
  {
    "function_name": "ocontext_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "2105-2270",
    "snippet": "static int ocontext_read(struct policydb *p, struct policydb_compat_info *info,\n\t\t\t void *fp)\n{\n\tint i, j, rc;\n\tu32 nel, len;\n\t__le32 buf[3];\n\tstruct ocontext *l, *c;\n\tu32 nodebuf[8];\n\n\tfor (i = 0; i < info->ocon_num; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tnel = le32_to_cpu(buf[0]);\n\n\t\tl = NULL;\n\t\tfor (j = 0; j < nel; j++) {\n\t\t\trc = -ENOMEM;\n\t\t\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\t\t\tif (!c)\n\t\t\t\tgoto out;\n\t\t\tif (l)\n\t\t\t\tl->next = c;\n\t\t\telse\n\t\t\t\tp->ocontexts[i] = c;\n\t\t\tl = c;\n\n\t\t\tswitch (i) {\n\t\t\tcase OCON_ISID:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tc->sid[0] = le32_to_cpu(buf[0]);\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FS:\n\t\t\tcase OCON_NETIF:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\t\trc = str_read(&c->u.name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\trc = context_read_and_validate(&c->context[1], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_PORT:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32)*3);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tc->u.port.protocol = le32_to_cpu(buf[0]);\n\t\t\t\tc->u.port.low_port = le32_to_cpu(buf[1]);\n\t\t\t\tc->u.port.high_port = le32_to_cpu(buf[2]);\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE:\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tc->u.node.addr = nodebuf[0]; /* network order */\n\t\t\t\tc->u.node.mask = nodebuf[1]; /* network order */\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FSUSE:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = -EINVAL;\n\t\t\t\tc->v.behavior = le32_to_cpu(buf[0]);\n\t\t\t\t/* Determined at runtime, not in policy DB. */\n\t\t\t\tif (c->v.behavior == SECURITY_FS_USE_MNTPOINT)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (c->v.behavior > SECURITY_FS_USE_MAX)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tlen = le32_to_cpu(buf[1]);\n\t\t\t\trc = str_read(&c->u.name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE6: {\n\t\t\t\tint k;\n\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 8);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tc->u.node6.addr[k] = nodebuf[k];\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tc->u.node6.mask[k] = nodebuf[k+4];\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase OCON_IBPKEY:\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 4);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tc->u.ibpkey.subnet_prefix = be64_to_cpu(*((__be64 *)nodebuf));\n\n\t\t\t\tif (nodebuf[2] > 0xffff ||\n\t\t\t\t    nodebuf[3] > 0xffff) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tc->u.ibpkey.low_pkey = le32_to_cpu(nodebuf[2]);\n\t\t\t\tc->u.ibpkey.high_pkey = le32_to_cpu(nodebuf[3]);\n\n\t\t\t\trc = context_read_and_validate(&c->context[0],\n\t\t\t\t\t\t\t       p,\n\t\t\t\t\t\t\t       fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBENDPORT:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\t\trc = str_read(&c->u.ibendport.dev_name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tif (buf[1] > 0xff || buf[1] == 0) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tc->u.ibendport.port = le32_to_cpu(buf[1]);\n\n\t\t\t\trc = context_read_and_validate(&c->context[0],\n\t\t\t\t\t\t\t       p,\n\t\t\t\t\t\t\t       fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_read_and_validate",
          "args": [
            "&c->context[0]",
            "p",
            "fp"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "context_read_and_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1054-1086",
          "snippet": "static int context_read_and_validate(struct context *c,\n\t\t\t\t     struct policydb *p,\n\t\t\t\t     void *fp)\n{\n\t__le32 buf[3];\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: context truncated\\n\");\n\t\tgoto out;\n\t}\n\tc->user = le32_to_cpu(buf[0]);\n\tc->role = le32_to_cpu(buf[1]);\n\tc->type = le32_to_cpu(buf[2]);\n\tif (p->policyvers >= POLICYDB_VERSION_MLS) {\n\t\trc = mls_read_range_helper(&c->range, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: error reading MLS range of context\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = -EINVAL;\n\tif (!policydb_context_isvalid(p, c)) {\n\t\tprintk(KERN_ERR \"SELinux:  invalid security context\\n\");\n\t\tcontext_destroy(c);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int context_read_and_validate(struct context *c,\n\t\t\t\t     struct policydb *p,\n\t\t\t\t     void *fp)\n{\n\t__le32 buf[3];\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: context truncated\\n\");\n\t\tgoto out;\n\t}\n\tc->user = le32_to_cpu(buf[0]);\n\tc->role = le32_to_cpu(buf[1]);\n\tc->type = le32_to_cpu(buf[2]);\n\tif (p->policyvers >= POLICYDB_VERSION_MLS) {\n\t\trc = mls_read_range_helper(&c->range, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: error reading MLS range of context\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = -EINVAL;\n\tif (!policydb_context_isvalid(p, c)) {\n\t\tprintk(KERN_ERR \"SELinux:  invalid security context\\n\");\n\t\tcontext_destroy(c);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_read",
          "args": [
            "&c->u.ibendport.dev_name",
            "GFP_KERNEL",
            "fp",
            "len"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "str_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1094-1115",
          "snippet": "static int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(u32) * 2"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "nodebuf[3]"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "nodebuf[2]"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*((__be64 *)nodebuf)"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*c)",
            "GFP_KERNEL"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int ocontext_read(struct policydb *p, struct policydb_compat_info *info,\n\t\t\t void *fp)\n{\n\tint i, j, rc;\n\tu32 nel, len;\n\t__le32 buf[3];\n\tstruct ocontext *l, *c;\n\tu32 nodebuf[8];\n\n\tfor (i = 0; i < info->ocon_num; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tnel = le32_to_cpu(buf[0]);\n\n\t\tl = NULL;\n\t\tfor (j = 0; j < nel; j++) {\n\t\t\trc = -ENOMEM;\n\t\t\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\t\t\tif (!c)\n\t\t\t\tgoto out;\n\t\t\tif (l)\n\t\t\t\tl->next = c;\n\t\t\telse\n\t\t\t\tp->ocontexts[i] = c;\n\t\t\tl = c;\n\n\t\t\tswitch (i) {\n\t\t\tcase OCON_ISID:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tc->sid[0] = le32_to_cpu(buf[0]);\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FS:\n\t\t\tcase OCON_NETIF:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\t\trc = str_read(&c->u.name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\trc = context_read_and_validate(&c->context[1], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_PORT:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32)*3);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tc->u.port.protocol = le32_to_cpu(buf[0]);\n\t\t\t\tc->u.port.low_port = le32_to_cpu(buf[1]);\n\t\t\t\tc->u.port.high_port = le32_to_cpu(buf[2]);\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE:\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tc->u.node.addr = nodebuf[0]; /* network order */\n\t\t\t\tc->u.node.mask = nodebuf[1]; /* network order */\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_FSUSE:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32)*2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = -EINVAL;\n\t\t\t\tc->v.behavior = le32_to_cpu(buf[0]);\n\t\t\t\t/* Determined at runtime, not in policy DB. */\n\t\t\t\tif (c->v.behavior == SECURITY_FS_USE_MNTPOINT)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (c->v.behavior > SECURITY_FS_USE_MAX)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tlen = le32_to_cpu(buf[1]);\n\t\t\t\trc = str_read(&c->u.name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_NODE6: {\n\t\t\t\tint k;\n\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 8);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tc->u.node6.addr[k] = nodebuf[k];\n\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\tc->u.node6.mask[k] = nodebuf[k+4];\n\t\t\t\trc = context_read_and_validate(&c->context[0], p, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase OCON_IBPKEY:\n\t\t\t\trc = next_entry(nodebuf, fp, sizeof(u32) * 4);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tc->u.ibpkey.subnet_prefix = be64_to_cpu(*((__be64 *)nodebuf));\n\n\t\t\t\tif (nodebuf[2] > 0xffff ||\n\t\t\t\t    nodebuf[3] > 0xffff) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tc->u.ibpkey.low_pkey = le32_to_cpu(nodebuf[2]);\n\t\t\t\tc->u.ibpkey.high_pkey = le32_to_cpu(nodebuf[3]);\n\n\t\t\t\trc = context_read_and_validate(&c->context[0],\n\t\t\t\t\t\t\t       p,\n\t\t\t\t\t\t\t       fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase OCON_IBENDPORT:\n\t\t\t\trc = next_entry(buf, fp, sizeof(u32) * 2);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\t\trc = str_read(&c->u.ibendport.dev_name, GFP_KERNEL, fp, len);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tif (buf[1] > 0xff || buf[1] == 0) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tc->u.ibendport.port = le32_to_cpu(buf[1]);\n\n\t\t\t\trc = context_read_and_validate(&c->context[0],\n\t\t\t\t\t\t\t       p,\n\t\t\t\t\t\t\t       fp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "genfs_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1992-2103",
    "snippet": "static int genfs_read(struct policydb *p, void *fp)\n{\n\tint i, j, rc;\n\tu32 nel, nel2, len, len2;\n\t__le32 buf[1];\n\tstruct ocontext *l, *c;\n\tstruct ocontext *newc = NULL;\n\tstruct genfs *genfs_p, *genfs;\n\tstruct genfs *newgenfs = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tnel = le32_to_cpu(buf[0]);\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tlen = le32_to_cpu(buf[0]);\n\n\t\trc = -ENOMEM;\n\t\tnewgenfs = kzalloc(sizeof(*newgenfs), GFP_KERNEL);\n\t\tif (!newgenfs)\n\t\t\tgoto out;\n\n\t\trc = str_read(&newgenfs->fstype, GFP_KERNEL, fp, len);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tfor (genfs_p = NULL, genfs = p->genfs; genfs;\n\t\t     genfs_p = genfs, genfs = genfs->next) {\n\t\t\trc = -EINVAL;\n\t\t\tif (strcmp(newgenfs->fstype, genfs->fstype) == 0) {\n\t\t\t\tprintk(KERN_ERR \"SELinux:  dup genfs fstype %s\\n\",\n\t\t\t\t       newgenfs->fstype);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strcmp(newgenfs->fstype, genfs->fstype) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tnewgenfs->next = genfs;\n\t\tif (genfs_p)\n\t\t\tgenfs_p->next = newgenfs;\n\t\telse\n\t\t\tp->genfs = newgenfs;\n\t\tgenfs = newgenfs;\n\t\tnewgenfs = NULL;\n\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tnel2 = le32_to_cpu(buf[0]);\n\t\tfor (j = 0; j < nel2; j++) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\trc = -ENOMEM;\n\t\t\tnewc = kzalloc(sizeof(*newc), GFP_KERNEL);\n\t\t\tif (!newc)\n\t\t\t\tgoto out;\n\n\t\t\trc = str_read(&newc->u.name, GFP_KERNEL, fp, len);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\tnewc->v.sclass = le32_to_cpu(buf[0]);\n\t\t\trc = context_read_and_validate(&newc->context[0], p, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\tfor (l = NULL, c = genfs->head; c;\n\t\t\t     l = c, c = c->next) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tif (!strcmp(newc->u.name, c->u.name) &&\n\t\t\t\t    (!c->v.sclass || !newc->v.sclass ||\n\t\t\t\t     newc->v.sclass == c->v.sclass)) {\n\t\t\t\t\tprintk(KERN_ERR \"SELinux:  dup genfs entry (%s,%s)\\n\",\n\t\t\t\t\t       genfs->fstype, c->u.name);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tlen = strlen(newc->u.name);\n\t\t\t\tlen2 = strlen(c->u.name);\n\t\t\t\tif (len > len2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnewc->next = c;\n\t\t\tif (l)\n\t\t\t\tl->next = newc;\n\t\t\telse\n\t\t\t\tgenfs->head = newc;\n\t\t\tnewc = NULL;\n\t\t}\n\t}\n\trc = 0;\nout:\n\tif (newgenfs) {\n\t\tkfree(newgenfs->fstype);\n\t\tkfree(newgenfs);\n\t}\n\tocontext_destroy(newc, OCON_FSUSE);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocontext_destroy",
          "args": [
            "newc",
            "OCON_FSUSE"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "ocontext_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "780-791",
          "snippet": "static void ocontext_destroy(struct ocontext *c, int i)\n{\n\tif (!c)\n\t\treturn;\n\n\tcontext_destroy(&c->context[0]);\n\tcontext_destroy(&c->context[1]);\n\tif (i == OCON_ISID || i == OCON_FS ||\n\t    i == OCON_NETIF || i == OCON_FSUSE)\n\t\tkfree(c->u.name);\n\tkfree(c);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void ocontext_destroy(struct ocontext *c, int i)\n{\n\tif (!c)\n\t\treturn;\n\n\tcontext_destroy(&c->context[0]);\n\tcontext_destroy(&c->context[1]);\n\tif (i == OCON_ISID || i == OCON_FS ||\n\t    i == OCON_NETIF || i == OCON_FSUSE)\n\t\tkfree(c->u.name);\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newgenfs"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newgenfs->fstype"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->u.name"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "newc->u.name"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  dup genfs entry (%s,%s)\\n\"",
            "genfs->fstype",
            "c->u.name"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "newc->u.name",
            "c->u.name"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_read_and_validate",
          "args": [
            "&newc->context[0]",
            "p",
            "fp"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "context_read_and_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1054-1086",
          "snippet": "static int context_read_and_validate(struct context *c,\n\t\t\t\t     struct policydb *p,\n\t\t\t\t     void *fp)\n{\n\t__le32 buf[3];\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: context truncated\\n\");\n\t\tgoto out;\n\t}\n\tc->user = le32_to_cpu(buf[0]);\n\tc->role = le32_to_cpu(buf[1]);\n\tc->type = le32_to_cpu(buf[2]);\n\tif (p->policyvers >= POLICYDB_VERSION_MLS) {\n\t\trc = mls_read_range_helper(&c->range, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: error reading MLS range of context\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = -EINVAL;\n\tif (!policydb_context_isvalid(p, c)) {\n\t\tprintk(KERN_ERR \"SELinux:  invalid security context\\n\");\n\t\tcontext_destroy(c);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int context_read_and_validate(struct context *c,\n\t\t\t\t     struct policydb *p,\n\t\t\t\t     void *fp)\n{\n\t__le32 buf[3];\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: context truncated\\n\");\n\t\tgoto out;\n\t}\n\tc->user = le32_to_cpu(buf[0]);\n\tc->role = le32_to_cpu(buf[1]);\n\tc->type = le32_to_cpu(buf[2]);\n\tif (p->policyvers >= POLICYDB_VERSION_MLS) {\n\t\trc = mls_read_range_helper(&c->range, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: error reading MLS range of context\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = -EINVAL;\n\tif (!policydb_context_isvalid(p, c)) {\n\t\tprintk(KERN_ERR \"SELinux:  invalid security context\\n\");\n\t\tcontext_destroy(c);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(u32)"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_read",
          "args": [
            "&newc->u.name",
            "GFP_KERNEL",
            "fp",
            "len"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "str_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1094-1115",
          "snippet": "static int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*newc)",
            "GFP_KERNEL"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "newgenfs->fstype",
            "genfs->fstype"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  dup genfs fstype %s\\n\"",
            "newgenfs->fstype"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "newgenfs->fstype",
            "genfs->fstype"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*newgenfs)",
            "GFP_KERNEL"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int genfs_read(struct policydb *p, void *fp)\n{\n\tint i, j, rc;\n\tu32 nel, nel2, len, len2;\n\t__le32 buf[1];\n\tstruct ocontext *l, *c;\n\tstruct ocontext *newc = NULL;\n\tstruct genfs *genfs_p, *genfs;\n\tstruct genfs *newgenfs = NULL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tnel = le32_to_cpu(buf[0]);\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tlen = le32_to_cpu(buf[0]);\n\n\t\trc = -ENOMEM;\n\t\tnewgenfs = kzalloc(sizeof(*newgenfs), GFP_KERNEL);\n\t\tif (!newgenfs)\n\t\t\tgoto out;\n\n\t\trc = str_read(&newgenfs->fstype, GFP_KERNEL, fp, len);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tfor (genfs_p = NULL, genfs = p->genfs; genfs;\n\t\t     genfs_p = genfs, genfs = genfs->next) {\n\t\t\trc = -EINVAL;\n\t\t\tif (strcmp(newgenfs->fstype, genfs->fstype) == 0) {\n\t\t\t\tprintk(KERN_ERR \"SELinux:  dup genfs fstype %s\\n\",\n\t\t\t\t       newgenfs->fstype);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strcmp(newgenfs->fstype, genfs->fstype) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tnewgenfs->next = genfs;\n\t\tif (genfs_p)\n\t\t\tgenfs_p->next = newgenfs;\n\t\telse\n\t\t\tp->genfs = newgenfs;\n\t\tgenfs = newgenfs;\n\t\tnewgenfs = NULL;\n\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tnel2 = le32_to_cpu(buf[0]);\n\t\tfor (j = 0; j < nel2; j++) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t\trc = -ENOMEM;\n\t\t\tnewc = kzalloc(sizeof(*newc), GFP_KERNEL);\n\t\t\tif (!newc)\n\t\t\t\tgoto out;\n\n\t\t\trc = str_read(&newc->u.name, GFP_KERNEL, fp, len);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\tnewc->v.sclass = le32_to_cpu(buf[0]);\n\t\t\trc = context_read_and_validate(&newc->context[0], p, fp);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\tfor (l = NULL, c = genfs->head; c;\n\t\t\t     l = c, c = c->next) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tif (!strcmp(newc->u.name, c->u.name) &&\n\t\t\t\t    (!c->v.sclass || !newc->v.sclass ||\n\t\t\t\t     newc->v.sclass == c->v.sclass)) {\n\t\t\t\t\tprintk(KERN_ERR \"SELinux:  dup genfs entry (%s,%s)\\n\",\n\t\t\t\t\t       genfs->fstype, c->u.name);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tlen = strlen(newc->u.name);\n\t\t\t\tlen2 = strlen(c->u.name);\n\t\t\t\tif (len > len2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnewc->next = c;\n\t\t\tif (l)\n\t\t\t\tl->next = newc;\n\t\t\telse\n\t\t\t\tgenfs->head = newc;\n\t\t\tnewc = NULL;\n\t\t}\n\t}\n\trc = 0;\nout:\n\tif (newgenfs) {\n\t\tkfree(newgenfs->fstype);\n\t\tkfree(newgenfs);\n\t}\n\tocontext_destroy(newc, OCON_FSUSE);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "filename_trans_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1910-1990",
    "snippet": "static int filename_trans_read(struct policydb *p, void *fp)\n{\n\tstruct filename_trans *ft;\n\tstruct filename_trans_datum *otype;\n\tchar *name;\n\tu32 nel, len;\n\t__le32 buf[4];\n\tint rc, i;\n\n\tif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\n\t\treturn 0;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tnel = le32_to_cpu(buf[0]);\n\n\tfor (i = 0; i < nel; i++) {\n\t\totype = NULL;\n\t\tname = NULL;\n\n\t\trc = -ENOMEM;\n\t\tft = kzalloc(sizeof(*ft), GFP_KERNEL);\n\t\tif (!ft)\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\totype = kmalloc(sizeof(*otype), GFP_KERNEL);\n\t\tif (!otype)\n\t\t\tgoto out;\n\n\t\t/* length of the path component string */\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t/* path component string */\n\t\trc = str_read(&name, GFP_KERNEL, fp, len);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tft->name = name;\n\n\t\trc = next_entry(buf, fp, sizeof(u32) * 4);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tft->stype = le32_to_cpu(buf[0]);\n\t\tft->ttype = le32_to_cpu(buf[1]);\n\t\tft->tclass = le32_to_cpu(buf[2]);\n\n\t\totype->otype = le32_to_cpu(buf[3]);\n\n\t\trc = ebitmap_set_bit(&p->filename_trans_ttypes, ft->ttype, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = hashtab_insert(p->filename_trans, ft, otype);\n\t\tif (rc) {\n\t\t\t/*\n\t\t\t * Do not return -EEXIST to the caller, or the system\n\t\t\t * will not boot.\n\t\t\t */\n\t\t\tif (rc != -EEXIST)\n\t\t\t\tgoto out;\n\t\t\t/* But free memory to avoid memory leak. */\n\t\t\tkfree(ft);\n\t\t\tkfree(name);\n\t\t\tkfree(otype);\n\t\t}\n\t}\n\thash_eval(p->filename_trans, \"filenametr\");\n\treturn 0;\nout:\n\tkfree(ft);\n\tkfree(name);\n\tkfree(otype);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "otype"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ft"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_eval",
          "args": [
            "p->filename_trans",
            "\"filenametr\""
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "hash_eval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "521-523",
          "snippet": "static inline void hash_eval(struct hashtab *h, char *hash_name)\n{\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic inline void hash_eval(struct hashtab *h, char *hash_name)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "otype"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ft"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashtab_insert",
          "args": [
            "p->filename_trans",
            "ft",
            "otype"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "42-78",
          "snippet": "int hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_set_bit",
          "args": [
            "&p->filename_trans_ttypes",
            "ft->ttype",
            "1"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "259-325",
          "snippet": "int ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\n{\n\tstruct ebitmap_node *n, *prev, *new;\n\n\tprev = NULL;\n\tn = e->node;\n\twhile (n && n->startbit <= bit) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit) {\n\t\t\tif (value) {\n\t\t\t\tebitmap_node_set_bit(n, bit);\n\t\t\t} else {\n\t\t\t\tunsigned int s;\n\n\t\t\t\tebitmap_node_clr_bit(n, bit);\n\n\t\t\t\ts = find_first_bit(n->maps, EBITMAP_SIZE);\n\t\t\t\tif (s < EBITMAP_SIZE)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* drop this node from the bitmap */\n\t\t\t\tif (!n->next) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this was the highest map\n\t\t\t\t\t * within the bitmap\n\t\t\t\t\t */\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\te->highbit = prev->startbit\n\t\t\t\t\t\t\t     + EBITMAP_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\te->highbit = 0;\n\t\t\t\t}\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = n->next;\n\t\t\t\telse\n\t\t\t\t\te->node = n->next;\n\t\t\t\tkmem_cache_free(ebitmap_node_cachep, n);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->startbit = bit - (bit % EBITMAP_SIZE);\n\tebitmap_node_set_bit(new, bit);\n\n\tif (!n)\n\t\t/* this node will be the highest map within the bitmap */\n\t\te->highbit = new->startbit + EBITMAP_SIZE;\n\n\tif (prev) {\n\t\tnew->next = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tnew->next = e->node;\n\t\te->node = new;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\n{\n\tstruct ebitmap_node *n, *prev, *new;\n\n\tprev = NULL;\n\tn = e->node;\n\twhile (n && n->startbit <= bit) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit) {\n\t\t\tif (value) {\n\t\t\t\tebitmap_node_set_bit(n, bit);\n\t\t\t} else {\n\t\t\t\tunsigned int s;\n\n\t\t\t\tebitmap_node_clr_bit(n, bit);\n\n\t\t\t\ts = find_first_bit(n->maps, EBITMAP_SIZE);\n\t\t\t\tif (s < EBITMAP_SIZE)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* drop this node from the bitmap */\n\t\t\t\tif (!n->next) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this was the highest map\n\t\t\t\t\t * within the bitmap\n\t\t\t\t\t */\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\te->highbit = prev->startbit\n\t\t\t\t\t\t\t     + EBITMAP_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\te->highbit = 0;\n\t\t\t\t}\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = n->next;\n\t\t\t\telse\n\t\t\t\t\te->node = n->next;\n\t\t\t\tkmem_cache_free(ebitmap_node_cachep, n);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->startbit = bit - (bit % EBITMAP_SIZE);\n\tebitmap_node_set_bit(new, bit);\n\n\tif (!n)\n\t\t/* this node will be the highest map within the bitmap */\n\t\te->highbit = new->startbit + EBITMAP_SIZE;\n\n\tif (prev) {\n\t\tnew->next = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tnew->next = e->node;\n\t\te->node = new;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[3]"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(u32) * 4"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_read",
          "args": [
            "&name",
            "GFP_KERNEL",
            "fp",
            "len"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "str_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1094-1115",
          "snippet": "static int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*otype)",
            "GFP_KERNEL"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ft)",
            "GFP_KERNEL"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int filename_trans_read(struct policydb *p, void *fp)\n{\n\tstruct filename_trans *ft;\n\tstruct filename_trans_datum *otype;\n\tchar *name;\n\tu32 nel, len;\n\t__le32 buf[4];\n\tint rc, i;\n\n\tif (p->policyvers < POLICYDB_VERSION_FILENAME_TRANS)\n\t\treturn 0;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\tnel = le32_to_cpu(buf[0]);\n\n\tfor (i = 0; i < nel; i++) {\n\t\totype = NULL;\n\t\tname = NULL;\n\n\t\trc = -ENOMEM;\n\t\tft = kzalloc(sizeof(*ft), GFP_KERNEL);\n\t\tif (!ft)\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\totype = kmalloc(sizeof(*otype), GFP_KERNEL);\n\t\tif (!otype)\n\t\t\tgoto out;\n\n\t\t/* length of the path component string */\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tlen = le32_to_cpu(buf[0]);\n\n\t\t/* path component string */\n\t\trc = str_read(&name, GFP_KERNEL, fp, len);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tft->name = name;\n\n\t\trc = next_entry(buf, fp, sizeof(u32) * 4);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tft->stype = le32_to_cpu(buf[0]);\n\t\tft->ttype = le32_to_cpu(buf[1]);\n\t\tft->tclass = le32_to_cpu(buf[2]);\n\n\t\totype->otype = le32_to_cpu(buf[3]);\n\n\t\trc = ebitmap_set_bit(&p->filename_trans_ttypes, ft->ttype, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = hashtab_insert(p->filename_trans, ft, otype);\n\t\tif (rc) {\n\t\t\t/*\n\t\t\t * Do not return -EEXIST to the caller, or the system\n\t\t\t * will not boot.\n\t\t\t */\n\t\t\tif (rc != -EEXIST)\n\t\t\t\tgoto out;\n\t\t\t/* But free memory to avoid memory leak. */\n\t\t\tkfree(ft);\n\t\t\tkfree(name);\n\t\t\tkfree(otype);\n\t\t}\n\t}\n\thash_eval(p->filename_trans, \"filenametr\");\n\treturn 0;\nout:\n\tkfree(ft);\n\tkfree(name);\n\tkfree(otype);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "range_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1838-1908",
    "snippet": "static int range_read(struct policydb *p, void *fp)\n{\n\tstruct range_trans *rt = NULL;\n\tstruct mls_range *r = NULL;\n\tint i, rc;\n\t__le32 buf[2];\n\tu32 nel;\n\n\tif (p->policyvers < POLICYDB_VERSION_MLS)\n\t\treturn 0;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\n\tnel = le32_to_cpu(buf[0]);\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\trt = kzalloc(sizeof(*rt), GFP_KERNEL);\n\t\tif (!rt)\n\t\t\tgoto out;\n\n\t\trc = next_entry(buf, fp, (sizeof(u32) * 2));\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trt->source_type = le32_to_cpu(buf[0]);\n\t\trt->target_type = le32_to_cpu(buf[1]);\n\t\tif (p->policyvers >= POLICYDB_VERSION_RANGETRANS) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\trt->target_class = le32_to_cpu(buf[0]);\n\t\t} else\n\t\t\trt->target_class = p->process_class;\n\n\t\trc = -EINVAL;\n\t\tif (!policydb_type_isvalid(p, rt->source_type) ||\n\t\t    !policydb_type_isvalid(p, rt->target_type) ||\n\t\t    !policydb_class_isvalid(p, rt->target_class))\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\tr = kzalloc(sizeof(*r), GFP_KERNEL);\n\t\tif (!r)\n\t\t\tgoto out;\n\n\t\trc = mls_read_range_helper(r, fp);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = -EINVAL;\n\t\tif (!mls_range_isvalid(p, r)) {\n\t\t\tprintk(KERN_WARNING \"SELinux:  rangetrans:  invalid range\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = hashtab_insert(p->range_tr, rt, r);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trt = NULL;\n\t\tr = NULL;\n\t}\n\thash_eval(p->range_tr, \"rangetr\");\n\trc = 0;\nout:\n\tkfree(rt);\n\tkfree(r);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "r"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rt"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_eval",
          "args": [
            "p->range_tr",
            "\"rangetr\""
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "hash_eval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "521-523",
          "snippet": "static inline void hash_eval(struct hashtab *h, char *hash_name)\n{\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic inline void hash_eval(struct hashtab *h, char *hash_name)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_insert",
          "args": [
            "p->range_tr",
            "rt",
            "r"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "42-78",
          "snippet": "int hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"SELinux:  rangetrans:  invalid range\\n\""
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mls_range_isvalid",
          "args": [
            "p",
            "r"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "mls_range_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "181-186",
          "snippet": "int mls_range_isvalid(struct policydb *p, struct mls_range *r)\n{\n\treturn (mls_level_isvalid(p, &r->level[0]) &&\n\t\tmls_level_isvalid(p, &r->level[1]) &&\n\t\tmls_level_dom(&r->level[1], &r->level[0]));\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_range_isvalid(struct policydb *p, struct mls_range *r)\n{\n\treturn (mls_level_isvalid(p, &r->level[0]) &&\n\t\tmls_level_isvalid(p, &r->level[1]) &&\n\t\tmls_level_dom(&r->level[1], &r->level[0]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_read_range_helper",
          "args": [
            "r",
            "fp"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "mls_read_range_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "995-1048",
          "snippet": "static int mls_read_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[2];\n\tu32 items;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\titems = le32_to_cpu(buf[0]);\n\tif (items > ARRAY_SIZE(buf)) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  range overflow\\n\");\n\t\tgoto out;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32) * items);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  truncated range\\n\");\n\t\tgoto out;\n\t}\n\n\tr->level[0].sens = le32_to_cpu(buf[0]);\n\tif (items > 1)\n\t\tr->level[1].sens = le32_to_cpu(buf[1]);\n\telse\n\t\tr->level[1].sens = r->level[0].sens;\n\n\trc = ebitmap_read(&r->level[0].cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading low categories\\n\");\n\t\tgoto out;\n\t}\n\tif (items > 1) {\n\t\trc = ebitmap_read(&r->level[1].cat, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  error reading high categories\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t} else {\n\t\trc = ebitmap_cpy(&r->level[1].cat, &r->level[0].cat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  out of memory\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t}\n\n\treturn 0;\nbad_high:\n\tebitmap_destroy(&r->level[0].cat);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_read_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[2];\n\tu32 items;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\titems = le32_to_cpu(buf[0]);\n\tif (items > ARRAY_SIZE(buf)) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  range overflow\\n\");\n\t\tgoto out;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32) * items);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  truncated range\\n\");\n\t\tgoto out;\n\t}\n\n\tr->level[0].sens = le32_to_cpu(buf[0]);\n\tif (items > 1)\n\t\tr->level[1].sens = le32_to_cpu(buf[1]);\n\telse\n\t\tr->level[1].sens = r->level[0].sens;\n\n\trc = ebitmap_read(&r->level[0].cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading low categories\\n\");\n\t\tgoto out;\n\t}\n\tif (items > 1) {\n\t\trc = ebitmap_read(&r->level[1].cat, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  error reading high categories\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t} else {\n\t\trc = ebitmap_cpy(&r->level[1].cat, &r->level[0].cat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  out of memory\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t}\n\n\treturn 0;\nbad_high:\n\tebitmap_destroy(&r->level[0].cat);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*r)",
            "GFP_KERNEL"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policydb_class_isvalid",
          "args": [
            "p",
            "rt->target_class"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_class_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "925-930",
          "snippet": "int policydb_class_isvalid(struct policydb *p, unsigned int class)\n{\n\tif (!class || class > p->p_classes.nprim)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_class_isvalid(struct policydb *p, unsigned int class)\n{\n\tif (!class || class > p->p_classes.nprim)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "policydb_type_isvalid",
          "args": [
            "p",
            "rt->target_type"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_type_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "939-944",
          "snippet": "int policydb_type_isvalid(struct policydb *p, unsigned int type)\n{\n\tif (!type || type > p->p_types.nprim)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_type_isvalid(struct policydb *p, unsigned int type)\n{\n\tif (!type || type > p->p_types.nprim)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(u32)"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*rt)",
            "GFP_KERNEL"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int range_read(struct policydb *p, void *fp)\n{\n\tstruct range_trans *rt = NULL;\n\tstruct mls_range *r = NULL;\n\tint i, rc;\n\t__le32 buf[2];\n\tu32 nel;\n\n\tif (p->policyvers < POLICYDB_VERSION_MLS)\n\t\treturn 0;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\treturn rc;\n\n\tnel = le32_to_cpu(buf[0]);\n\tfor (i = 0; i < nel; i++) {\n\t\trc = -ENOMEM;\n\t\trt = kzalloc(sizeof(*rt), GFP_KERNEL);\n\t\tif (!rt)\n\t\t\tgoto out;\n\n\t\trc = next_entry(buf, fp, (sizeof(u32) * 2));\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trt->source_type = le32_to_cpu(buf[0]);\n\t\trt->target_type = le32_to_cpu(buf[1]);\n\t\tif (p->policyvers >= POLICYDB_VERSION_RANGETRANS) {\n\t\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\trt->target_class = le32_to_cpu(buf[0]);\n\t\t} else\n\t\t\trt->target_class = p->process_class;\n\n\t\trc = -EINVAL;\n\t\tif (!policydb_type_isvalid(p, rt->source_type) ||\n\t\t    !policydb_type_isvalid(p, rt->target_type) ||\n\t\t    !policydb_class_isvalid(p, rt->target_class))\n\t\t\tgoto out;\n\n\t\trc = -ENOMEM;\n\t\tr = kzalloc(sizeof(*r), GFP_KERNEL);\n\t\tif (!r)\n\t\t\tgoto out;\n\n\t\trc = mls_read_range_helper(r, fp);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = -EINVAL;\n\t\tif (!mls_range_isvalid(p, r)) {\n\t\t\tprintk(KERN_WARNING \"SELinux:  rangetrans:  invalid range\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = hashtab_insert(p->range_tr, rt, r);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trt = NULL;\n\t\tr = NULL;\n\t}\n\thash_eval(p->range_tr, \"rangetr\");\n\trc = 0;\nout:\n\tkfree(rt);\n\tkfree(r);\n\treturn rc;\n}"
  },
  {
    "function_name": "string_to_av_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1815-1836",
    "snippet": "u32 string_to_av_perm(struct policydb *p, u16 tclass, const char *name)\n{\n\tstruct class_datum *cladatum;\n\tstruct perm_datum *perdatum = NULL;\n\tstruct common_datum *comdatum;\n\n\tif (!tclass || tclass > p->p_classes.nprim)\n\t\treturn 0;\n\n\tcladatum = p->class_val_to_struct[tclass-1];\n\tcomdatum = cladatum->comdatum;\n\tif (comdatum)\n\t\tperdatum = hashtab_search(comdatum->permissions.table,\n\t\t\t\t\t  name);\n\tif (!perdatum)\n\t\tperdatum = hashtab_search(cladatum->permissions.table,\n\t\t\t\t\t  name);\n\tif (!perdatum)\n\t\treturn 0;\n\n\treturn 1U << (perdatum->value-1);\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "cladatum->permissions.table",
            "name"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nu32 string_to_av_perm(struct policydb *p, u16 tclass, const char *name)\n{\n\tstruct class_datum *cladatum;\n\tstruct perm_datum *perdatum = NULL;\n\tstruct common_datum *comdatum;\n\n\tif (!tclass || tclass > p->p_classes.nprim)\n\t\treturn 0;\n\n\tcladatum = p->class_val_to_struct[tclass-1];\n\tcomdatum = cladatum->comdatum;\n\tif (comdatum)\n\t\tperdatum = hashtab_search(comdatum->permissions.table,\n\t\t\t\t\t  name);\n\tif (!perdatum)\n\t\tperdatum = hashtab_search(cladatum->permissions.table,\n\t\t\t\t\t  name);\n\tif (!perdatum)\n\t\treturn 0;\n\n\treturn 1U << (perdatum->value-1);\n}"
  },
  {
    "function_name": "string_to_security_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1804-1813",
    "snippet": "u16 string_to_security_class(struct policydb *p, const char *name)\n{\n\tstruct class_datum *cladatum;\n\n\tcladatum = hashtab_search(p->p_classes.table, name);\n\tif (!cladatum)\n\t\treturn 0;\n\n\treturn cladatum->value;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "p->p_classes.table",
            "name"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nu16 string_to_security_class(struct policydb *p, const char *name)\n{\n\tstruct class_datum *cladatum;\n\n\tcladatum = hashtab_search(p->p_classes.table, name);\n\tif (!cladatum)\n\t\treturn 0;\n\n\treturn cladatum->value;\n}"
  },
  {
    "function_name": "policydb_bounds_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1779-1802",
    "snippet": "static int policydb_bounds_sanity_check(struct policydb *p)\n{\n\tint rc;\n\n\tif (p->policyvers < POLICYDB_VERSION_BOUNDARY)\n\t\treturn 0;\n\n\trc = hashtab_map(p->p_users.table,\n\t\t\t user_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(p->p_roles.table,\n\t\t\t role_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(p->p_types.table,\n\t\t\t type_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashtab_map",
          "args": [
            "p->p_types.table",
            "type_bounds_sanity_check",
            "p"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "123-144",
          "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int policydb_bounds_sanity_check(struct policydb *p)\n{\n\tint rc;\n\n\tif (p->policyvers < POLICYDB_VERSION_BOUNDARY)\n\t\treturn 0;\n\n\trc = hashtab_map(p->p_users.table,\n\t\t\t user_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(p->p_roles.table,\n\t\t\t role_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\trc = hashtab_map(p->p_types.table,\n\t\t\t type_bounds_sanity_check, p);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "type_bounds_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1748-1777",
    "snippet": "static int type_bounds_sanity_check(void *key, void *datum, void *datap)\n{\n\tstruct type_datum *upper;\n\tstruct policydb *p = datap;\n\tint depth = 0;\n\n\tupper = datum;\n\twhile (upper->bounds) {\n\t\tif (++depth == POLICYDB_BOUNDS_MAXDEPTH) {\n\t\t\tprintk(KERN_ERR \"SELinux: type %s: \"\n\t\t\t       \"too deep or looped boundary\\n\",\n\t\t\t       (char *) key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tupper = flex_array_get_ptr(p->type_val_to_struct_array,\n\t\t\t\t\t   upper->bounds - 1);\n\t\tBUG_ON(!upper);\n\n\t\tif (upper->attribute) {\n\t\t\tprintk(KERN_ERR \"SELinux: type %s: \"\n\t\t\t       \"bounded by attribute %s\",\n\t\t\t       (char *) key,\n\t\t\t       sym_name(p, SYM_TYPES, upper->value - 1));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: type %s: \"\n\t\t\t       \"bounded by attribute %s\"",
            "(char *) key",
            "sym_name(p, SYM_TYPES, upper->value - 1)"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "p",
            "SYM_TYPES",
            "upper->value - 1"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!upper"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get_ptr",
          "args": [
            "p->type_val_to_struct_array",
            "upper->bounds - 1"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: type %s: \"\n\t\t\t       \"too deep or looped boundary\\n\"",
            "(char *) key"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int type_bounds_sanity_check(void *key, void *datum, void *datap)\n{\n\tstruct type_datum *upper;\n\tstruct policydb *p = datap;\n\tint depth = 0;\n\n\tupper = datum;\n\twhile (upper->bounds) {\n\t\tif (++depth == POLICYDB_BOUNDS_MAXDEPTH) {\n\t\t\tprintk(KERN_ERR \"SELinux: type %s: \"\n\t\t\t       \"too deep or looped boundary\\n\",\n\t\t\t       (char *) key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tupper = flex_array_get_ptr(p->type_val_to_struct_array,\n\t\t\t\t\t   upper->bounds - 1);\n\t\tBUG_ON(!upper);\n\n\t\tif (upper->attribute) {\n\t\t\tprintk(KERN_ERR \"SELinux: type %s: \"\n\t\t\t       \"bounded by attribute %s\",\n\t\t\t       (char *) key,\n\t\t\t       sym_name(p, SYM_TYPES, upper->value - 1));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "role_bounds_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1711-1746",
    "snippet": "static int role_bounds_sanity_check(void *key, void *datum, void *datap)\n{\n\tstruct role_datum *upper, *role;\n\tstruct policydb *p = datap;\n\tint depth = 0;\n\n\tupper = role = datum;\n\twhile (upper->bounds) {\n\t\tstruct ebitmap_node *node;\n\t\tunsigned long bit;\n\n\t\tif (++depth == POLICYDB_BOUNDS_MAXDEPTH) {\n\t\t\tprintk(KERN_ERR \"SELinux: role %s: \"\n\t\t\t       \"too deep or looped bounds\\n\",\n\t\t\t       (char *) key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tupper = p->role_val_to_struct[upper->bounds - 1];\n\t\tebitmap_for_each_positive_bit(&role->types, node, bit) {\n\t\t\tif (ebitmap_get_bit(&upper->types, bit))\n\t\t\t\tcontinue;\n\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"SELinux: boundary violated policy: \"\n\t\t\t       \"role=%s type=%s bounds=%s\\n\",\n\t\t\t       sym_name(p, SYM_ROLES, role->value - 1),\n\t\t\t       sym_name(p, SYM_TYPES, bit),\n\t\t\t       sym_name(p, SYM_ROLES, upper->value - 1));\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t       \"SELinux: boundary violated policy: \"\n\t\t\t       \"role=%s type=%s bounds=%s\\n\"",
            "sym_name(p, SYM_ROLES, role->value - 1)",
            "sym_name(p, SYM_TYPES, bit)",
            "sym_name(p, SYM_ROLES, upper->value - 1)"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_xprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1764-1785",
          "snippet": "void aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "p",
            "SYM_ROLES",
            "upper->value - 1"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_get_bit",
          "args": [
            "&upper->types",
            "bit"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_get_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "242-257",
          "snippet": "int ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "&role->types",
            "node",
            "bit"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: role %s: \"\n\t\t\t       \"too deep or looped bounds\\n\"",
            "(char *) key"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int role_bounds_sanity_check(void *key, void *datum, void *datap)\n{\n\tstruct role_datum *upper, *role;\n\tstruct policydb *p = datap;\n\tint depth = 0;\n\n\tupper = role = datum;\n\twhile (upper->bounds) {\n\t\tstruct ebitmap_node *node;\n\t\tunsigned long bit;\n\n\t\tif (++depth == POLICYDB_BOUNDS_MAXDEPTH) {\n\t\t\tprintk(KERN_ERR \"SELinux: role %s: \"\n\t\t\t       \"too deep or looped bounds\\n\",\n\t\t\t       (char *) key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tupper = p->role_val_to_struct[upper->bounds - 1];\n\t\tebitmap_for_each_positive_bit(&role->types, node, bit) {\n\t\t\tif (ebitmap_get_bit(&upper->types, bit))\n\t\t\t\tcontinue;\n\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"SELinux: boundary violated policy: \"\n\t\t\t       \"role=%s type=%s bounds=%s\\n\",\n\t\t\t       sym_name(p, SYM_ROLES, role->value - 1),\n\t\t\t       sym_name(p, SYM_TYPES, bit),\n\t\t\t       sym_name(p, SYM_ROLES, upper->value - 1));\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "user_bounds_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1674-1709",
    "snippet": "static int user_bounds_sanity_check(void *key, void *datum, void *datap)\n{\n\tstruct user_datum *upper, *user;\n\tstruct policydb *p = datap;\n\tint depth = 0;\n\n\tupper = user = datum;\n\twhile (upper->bounds) {\n\t\tstruct ebitmap_node *node;\n\t\tunsigned long bit;\n\n\t\tif (++depth == POLICYDB_BOUNDS_MAXDEPTH) {\n\t\t\tprintk(KERN_ERR \"SELinux: user %s: \"\n\t\t\t       \"too deep or looped boundary\",\n\t\t\t       (char *) key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tupper = p->user_val_to_struct[upper->bounds - 1];\n\t\tebitmap_for_each_positive_bit(&user->roles, node, bit) {\n\t\t\tif (ebitmap_get_bit(&upper->roles, bit))\n\t\t\t\tcontinue;\n\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"SELinux: boundary violated policy: \"\n\t\t\t       \"user=%s role=%s bounds=%s\\n\",\n\t\t\t       sym_name(p, SYM_USERS, user->value - 1),\n\t\t\t       sym_name(p, SYM_ROLES, bit),\n\t\t\t       sym_name(p, SYM_USERS, upper->value - 1));\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t       \"SELinux: boundary violated policy: \"\n\t\t\t       \"user=%s role=%s bounds=%s\\n\"",
            "sym_name(p, SYM_USERS, user->value - 1)",
            "sym_name(p, SYM_ROLES, bit)",
            "sym_name(p, SYM_USERS, upper->value - 1)"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_xprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1764-1785",
          "snippet": "void aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "p",
            "SYM_USERS",
            "upper->value - 1"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_get_bit",
          "args": [
            "&upper->roles",
            "bit"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_get_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "242-257",
          "snippet": "int ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "&user->roles",
            "node",
            "bit"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: user %s: \"\n\t\t\t       \"too deep or looped boundary\"",
            "(char *) key"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int user_bounds_sanity_check(void *key, void *datum, void *datap)\n{\n\tstruct user_datum *upper, *user;\n\tstruct policydb *p = datap;\n\tint depth = 0;\n\n\tupper = user = datum;\n\twhile (upper->bounds) {\n\t\tstruct ebitmap_node *node;\n\t\tunsigned long bit;\n\n\t\tif (++depth == POLICYDB_BOUNDS_MAXDEPTH) {\n\t\t\tprintk(KERN_ERR \"SELinux: user %s: \"\n\t\t\t       \"too deep or looped boundary\",\n\t\t\t       (char *) key);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tupper = p->user_val_to_struct[upper->bounds - 1];\n\t\tebitmap_for_each_positive_bit(&user->roles, node, bit) {\n\t\t\tif (ebitmap_get_bit(&upper->roles, bit))\n\t\t\t\tcontinue;\n\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"SELinux: boundary violated policy: \"\n\t\t\t       \"user=%s role=%s bounds=%s\\n\",\n\t\t\t       sym_name(p, SYM_USERS, user->value - 1),\n\t\t\t       sym_name(p, SYM_ROLES, bit),\n\t\t\t       sym_name(p, SYM_USERS, upper->value - 1));\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cat_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1629-1660",
    "snippet": "static int cat_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct cat_datum *catdatum;\n\tint rc;\n\t__le32 buf[3];\n\tu32 len;\n\n\tcatdatum = kzalloc(sizeof(*catdatum), GFP_ATOMIC);\n\tif (!catdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tcatdatum->value = le32_to_cpu(buf[1]);\n\tcatdatum->isalias = le32_to_cpu(buf[2]);\n\n\trc = str_read(&key, GFP_ATOMIC, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = hashtab_insert(h, key, catdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\tcat_destroy(key, catdatum, NULL);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cat_destroy",
          "args": [
            "key",
            "catdatum",
            "NULL"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "cat_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "740-745",
          "snippet": "static int cat_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int cat_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_insert",
          "args": [
            "h",
            "key",
            "catdatum"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "42-78",
          "snippet": "int hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_read",
          "args": [
            "&key",
            "GFP_ATOMIC",
            "fp",
            "len"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "str_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1094-1115",
          "snippet": "static int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof buf"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*catdatum)",
            "GFP_ATOMIC"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int cat_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct cat_datum *catdatum;\n\tint rc;\n\t__le32 buf[3];\n\tu32 len;\n\n\tcatdatum = kzalloc(sizeof(*catdatum), GFP_ATOMIC);\n\tif (!catdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tcatdatum->value = le32_to_cpu(buf[1]);\n\tcatdatum->isalias = le32_to_cpu(buf[2]);\n\n\trc = str_read(&key, GFP_ATOMIC, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = hashtab_insert(h, key, catdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\tcat_destroy(key, catdatum, NULL);\n\treturn rc;\n}"
  },
  {
    "function_name": "sens_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1588-1627",
    "snippet": "static int sens_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct level_datum *levdatum;\n\tint rc;\n\t__le32 buf[2];\n\tu32 len;\n\n\tlevdatum = kzalloc(sizeof(*levdatum), GFP_ATOMIC);\n\tif (!levdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tlevdatum->isalias = le32_to_cpu(buf[1]);\n\n\trc = str_read(&key, GFP_ATOMIC, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -ENOMEM;\n\tlevdatum->level = kmalloc(sizeof(*levdatum->level), GFP_ATOMIC);\n\tif (!levdatum->level)\n\t\tgoto bad;\n\n\trc = mls_read_level(levdatum->level, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = hashtab_insert(h, key, levdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\tsens_destroy(key, levdatum, NULL);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sens_destroy",
          "args": [
            "key",
            "levdatum",
            "NULL"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "sens_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "726-738",
          "snippet": "static int sens_destroy(void *key, void *datum, void *p)\n{\n\tstruct level_datum *levdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tlevdatum = datum;\n\t\tebitmap_destroy(&levdatum->level->cat);\n\t\tkfree(levdatum->level);\n\t}\n\tkfree(datum);\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int sens_destroy(void *key, void *datum, void *p)\n{\n\tstruct level_datum *levdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tlevdatum = datum;\n\t\tebitmap_destroy(&levdatum->level->cat);\n\t\tkfree(levdatum->level);\n\t}\n\tkfree(datum);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_insert",
          "args": [
            "h",
            "key",
            "levdatum"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "42-78",
          "snippet": "int hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_read_level",
          "args": [
            "levdatum->level",
            "fp"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "mls_read_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1516-1536",
          "snippet": "static int mls_read_level(struct mls_level *lp, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tmemset(lp, 0, sizeof(*lp));\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls: truncated level\\n\");\n\t\treturn rc;\n\t}\n\tlp->sens = le32_to_cpu(buf[0]);\n\n\trc = ebitmap_read(&lp->cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading level categories\\n\");\n\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_read_level(struct mls_level *lp, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tmemset(lp, 0, sizeof(*lp));\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls: truncated level\\n\");\n\t\treturn rc;\n\t}\n\tlp->sens = le32_to_cpu(buf[0]);\n\n\trc = ebitmap_read(&lp->cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading level categories\\n\");\n\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*levdatum->level)",
            "GFP_ATOMIC"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_read",
          "args": [
            "&key",
            "GFP_ATOMIC",
            "fp",
            "len"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "str_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1094-1115",
          "snippet": "static int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof buf"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*levdatum)",
            "GFP_ATOMIC"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int sens_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct level_datum *levdatum;\n\tint rc;\n\t__le32 buf[2];\n\tu32 len;\n\n\tlevdatum = kzalloc(sizeof(*levdatum), GFP_ATOMIC);\n\tif (!levdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tlevdatum->isalias = le32_to_cpu(buf[1]);\n\n\trc = str_read(&key, GFP_ATOMIC, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = -ENOMEM;\n\tlevdatum->level = kmalloc(sizeof(*levdatum->level), GFP_ATOMIC);\n\tif (!levdatum->level)\n\t\tgoto bad;\n\n\trc = mls_read_level(levdatum->level, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = hashtab_insert(h, key, levdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\tsens_destroy(key, levdatum, NULL);\n\treturn rc;\n}"
  },
  {
    "function_name": "user_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1538-1586",
    "snippet": "static int user_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct user_datum *usrdatum;\n\tint rc, to_read = 2;\n\t__le32 buf[3];\n\tu32 len;\n\n\tusrdatum = kzalloc(sizeof(*usrdatum), GFP_KERNEL);\n\tif (!usrdatum)\n\t\treturn -ENOMEM;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tto_read = 3;\n\n\trc = next_entry(buf, fp, sizeof(buf[0]) * to_read);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tusrdatum->value = le32_to_cpu(buf[1]);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tusrdatum->bounds = le32_to_cpu(buf[2]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = ebitmap_read(&usrdatum->roles, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (p->policyvers >= POLICYDB_VERSION_MLS) {\n\t\trc = mls_read_range_helper(&usrdatum->range, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\trc = mls_read_level(&usrdatum->dfltlevel, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = hashtab_insert(h, key, usrdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\tuser_destroy(key, usrdatum, NULL);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_destroy",
          "args": [
            "key",
            "usrdatum",
            "NULL"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "user_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "710-724",
          "snippet": "static int user_destroy(void *key, void *datum, void *p)\n{\n\tstruct user_datum *usrdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tusrdatum = datum;\n\t\tebitmap_destroy(&usrdatum->roles);\n\t\tebitmap_destroy(&usrdatum->range.level[0].cat);\n\t\tebitmap_destroy(&usrdatum->range.level[1].cat);\n\t\tebitmap_destroy(&usrdatum->dfltlevel.cat);\n\t}\n\tkfree(datum);\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int user_destroy(void *key, void *datum, void *p)\n{\n\tstruct user_datum *usrdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tusrdatum = datum;\n\t\tebitmap_destroy(&usrdatum->roles);\n\t\tebitmap_destroy(&usrdatum->range.level[0].cat);\n\t\tebitmap_destroy(&usrdatum->range.level[1].cat);\n\t\tebitmap_destroy(&usrdatum->dfltlevel.cat);\n\t}\n\tkfree(datum);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_insert",
          "args": [
            "h",
            "key",
            "usrdatum"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "42-78",
          "snippet": "int hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_read_level",
          "args": [
            "&usrdatum->dfltlevel",
            "fp"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "mls_read_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1516-1536",
          "snippet": "static int mls_read_level(struct mls_level *lp, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tmemset(lp, 0, sizeof(*lp));\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls: truncated level\\n\");\n\t\treturn rc;\n\t}\n\tlp->sens = le32_to_cpu(buf[0]);\n\n\trc = ebitmap_read(&lp->cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading level categories\\n\");\n\t\treturn rc;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_read_level(struct mls_level *lp, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tmemset(lp, 0, sizeof(*lp));\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls: truncated level\\n\");\n\t\treturn rc;\n\t}\n\tlp->sens = le32_to_cpu(buf[0]);\n\n\trc = ebitmap_read(&lp->cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading level categories\\n\");\n\t\treturn rc;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_read_range_helper",
          "args": [
            "&usrdatum->range",
            "fp"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "mls_read_range_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "995-1048",
          "snippet": "static int mls_read_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[2];\n\tu32 items;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\titems = le32_to_cpu(buf[0]);\n\tif (items > ARRAY_SIZE(buf)) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  range overflow\\n\");\n\t\tgoto out;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32) * items);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  truncated range\\n\");\n\t\tgoto out;\n\t}\n\n\tr->level[0].sens = le32_to_cpu(buf[0]);\n\tif (items > 1)\n\t\tr->level[1].sens = le32_to_cpu(buf[1]);\n\telse\n\t\tr->level[1].sens = r->level[0].sens;\n\n\trc = ebitmap_read(&r->level[0].cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading low categories\\n\");\n\t\tgoto out;\n\t}\n\tif (items > 1) {\n\t\trc = ebitmap_read(&r->level[1].cat, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  error reading high categories\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t} else {\n\t\trc = ebitmap_cpy(&r->level[1].cat, &r->level[0].cat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  out of memory\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t}\n\n\treturn 0;\nbad_high:\n\tebitmap_destroy(&r->level[0].cat);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_read_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[2];\n\tu32 items;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\titems = le32_to_cpu(buf[0]);\n\tif (items > ARRAY_SIZE(buf)) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  range overflow\\n\");\n\t\tgoto out;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32) * items);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  truncated range\\n\");\n\t\tgoto out;\n\t}\n\n\tr->level[0].sens = le32_to_cpu(buf[0]);\n\tif (items > 1)\n\t\tr->level[1].sens = le32_to_cpu(buf[1]);\n\telse\n\t\tr->level[1].sens = r->level[0].sens;\n\n\trc = ebitmap_read(&r->level[0].cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading low categories\\n\");\n\t\tgoto out;\n\t}\n\tif (items > 1) {\n\t\trc = ebitmap_read(&r->level[1].cat, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  error reading high categories\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t} else {\n\t\trc = ebitmap_cpy(&r->level[1].cat, &r->level[0].cat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  out of memory\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t}\n\n\treturn 0;\nbad_high:\n\tebitmap_destroy(&r->level[0].cat);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_read",
          "args": [
            "&usrdatum->roles",
            "fp"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "346-449",
          "snippet": "int ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_read",
          "args": [
            "&key",
            "GFP_KERNEL",
            "fp",
            "len"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "str_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1094-1115",
          "snippet": "static int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(buf[0]) * to_read"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*usrdatum)",
            "GFP_KERNEL"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int user_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct user_datum *usrdatum;\n\tint rc, to_read = 2;\n\t__le32 buf[3];\n\tu32 len;\n\n\tusrdatum = kzalloc(sizeof(*usrdatum), GFP_KERNEL);\n\tif (!usrdatum)\n\t\treturn -ENOMEM;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tto_read = 3;\n\n\trc = next_entry(buf, fp, sizeof(buf[0]) * to_read);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tusrdatum->value = le32_to_cpu(buf[1]);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tusrdatum->bounds = le32_to_cpu(buf[2]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = ebitmap_read(&usrdatum->roles, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (p->policyvers >= POLICYDB_VERSION_MLS) {\n\t\trc = mls_read_range_helper(&usrdatum->range, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\trc = mls_read_level(&usrdatum->dfltlevel, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = hashtab_insert(h, key, usrdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\tuser_destroy(key, usrdatum, NULL);\n\treturn rc;\n}"
  },
  {
    "function_name": "mls_read_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1516-1536",
    "snippet": "static int mls_read_level(struct mls_level *lp, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tmemset(lp, 0, sizeof(*lp));\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls: truncated level\\n\");\n\t\treturn rc;\n\t}\n\tlp->sens = le32_to_cpu(buf[0]);\n\n\trc = ebitmap_read(&lp->cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading level categories\\n\");\n\t\treturn rc;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: mls:  error reading level categories\\n\""
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_read",
          "args": [
            "&lp->cat",
            "fp"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "346-449",
          "snippet": "int ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: mls: truncated level\\n\""
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof buf"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "lp",
            "0",
            "sizeof(*lp)"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_read_level(struct mls_level *lp, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tmemset(lp, 0, sizeof(*lp));\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls: truncated level\\n\");\n\t\treturn rc;\n\t}\n\tlp->sens = le32_to_cpu(buf[0]);\n\n\trc = ebitmap_read(&lp->cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading level categories\\n\");\n\t\treturn rc;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "type_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1464-1509",
    "snippet": "static int type_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct type_datum *typdatum;\n\tint rc, to_read = 3;\n\t__le32 buf[4];\n\tu32 len;\n\n\ttypdatum = kzalloc(sizeof(*typdatum), GFP_KERNEL);\n\tif (!typdatum)\n\t\treturn -ENOMEM;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tto_read = 4;\n\n\trc = next_entry(buf, fp, sizeof(buf[0]) * to_read);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\ttypdatum->value = le32_to_cpu(buf[1]);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY) {\n\t\tu32 prop = le32_to_cpu(buf[2]);\n\n\t\tif (prop & TYPEDATUM_PROPERTY_PRIMARY)\n\t\t\ttypdatum->primary = 1;\n\t\tif (prop & TYPEDATUM_PROPERTY_ATTRIBUTE)\n\t\t\ttypdatum->attribute = 1;\n\n\t\ttypdatum->bounds = le32_to_cpu(buf[3]);\n\t} else {\n\t\ttypdatum->primary = le32_to_cpu(buf[2]);\n\t}\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = hashtab_insert(h, key, typdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\ttype_destroy(key, typdatum, NULL);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "type_destroy",
          "args": [
            "key",
            "typdatum",
            "NULL"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "type_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "703-708",
          "snippet": "static int type_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int type_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_insert",
          "args": [
            "h",
            "key",
            "typdatum"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "42-78",
          "snippet": "int hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_read",
          "args": [
            "&key",
            "GFP_KERNEL",
            "fp",
            "len"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "str_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1094-1115",
          "snippet": "static int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[3]"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(buf[0]) * to_read"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*typdatum)",
            "GFP_KERNEL"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int type_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct type_datum *typdatum;\n\tint rc, to_read = 3;\n\t__le32 buf[4];\n\tu32 len;\n\n\ttypdatum = kzalloc(sizeof(*typdatum), GFP_KERNEL);\n\tif (!typdatum)\n\t\treturn -ENOMEM;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tto_read = 4;\n\n\trc = next_entry(buf, fp, sizeof(buf[0]) * to_read);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\ttypdatum->value = le32_to_cpu(buf[1]);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY) {\n\t\tu32 prop = le32_to_cpu(buf[2]);\n\n\t\tif (prop & TYPEDATUM_PROPERTY_PRIMARY)\n\t\t\ttypdatum->primary = 1;\n\t\tif (prop & TYPEDATUM_PROPERTY_ATTRIBUTE)\n\t\t\ttypdatum->attribute = 1;\n\n\t\ttypdatum->bounds = le32_to_cpu(buf[3]);\n\t} else {\n\t\ttypdatum->primary = le32_to_cpu(buf[2]);\n\t}\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = hashtab_insert(h, key, typdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\ttype_destroy(key, typdatum, NULL);\n\treturn rc;\n}"
  },
  {
    "function_name": "role_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1408-1462",
    "snippet": "static int role_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct role_datum *role;\n\tint rc, to_read = 2;\n\t__le32 buf[3];\n\tu32 len;\n\n\trole = kzalloc(sizeof(*role), GFP_KERNEL);\n\tif (!role)\n\t\treturn -ENOMEM;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tto_read = 3;\n\n\trc = next_entry(buf, fp, sizeof(buf[0]) * to_read);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\trole->value = le32_to_cpu(buf[1]);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\trole->bounds = le32_to_cpu(buf[2]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = ebitmap_read(&role->dominates, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = ebitmap_read(&role->types, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (strcmp(key, OBJECT_R) == 0) {\n\t\trc = -EINVAL;\n\t\tif (role->value != OBJECT_R_VAL) {\n\t\t\tprintk(KERN_ERR \"SELinux: Role %s has wrong value %d\\n\",\n\t\t\t       OBJECT_R, role->value);\n\t\t\tgoto bad;\n\t\t}\n\t\trc = 0;\n\t\tgoto bad;\n\t}\n\n\trc = hashtab_insert(h, key, role);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\trole_destroy(key, role, NULL);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "role_destroy",
          "args": [
            "key",
            "role",
            "NULL"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "role_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "689-701",
          "snippet": "static int role_destroy(void *key, void *datum, void *p)\n{\n\tstruct role_datum *role;\n\n\tkfree(key);\n\tif (datum) {\n\t\trole = datum;\n\t\tebitmap_destroy(&role->dominates);\n\t\tebitmap_destroy(&role->types);\n\t}\n\tkfree(datum);\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int role_destroy(void *key, void *datum, void *p)\n{\n\tstruct role_datum *role;\n\n\tkfree(key);\n\tif (datum) {\n\t\trole = datum;\n\t\tebitmap_destroy(&role->dominates);\n\t\tebitmap_destroy(&role->types);\n\t}\n\tkfree(datum);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_insert",
          "args": [
            "h",
            "key",
            "role"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "42-78",
          "snippet": "int hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: Role %s has wrong value %d\\n\"",
            "OBJECT_R",
            "role->value"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "key",
            "OBJECT_R"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_read",
          "args": [
            "&role->types",
            "fp"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "346-449",
          "snippet": "int ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_read",
          "args": [
            "&key",
            "GFP_KERNEL",
            "fp",
            "len"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "str_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1094-1115",
          "snippet": "static int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(buf[0]) * to_read"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*role)",
            "GFP_KERNEL"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int role_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct role_datum *role;\n\tint rc, to_read = 2;\n\t__le32 buf[3];\n\tu32 len;\n\n\trole = kzalloc(sizeof(*role), GFP_KERNEL);\n\tif (!role)\n\t\treturn -ENOMEM;\n\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\tto_read = 3;\n\n\trc = next_entry(buf, fp, sizeof(buf[0]) * to_read);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\trole->value = le32_to_cpu(buf[1]);\n\tif (p->policyvers >= POLICYDB_VERSION_BOUNDARY)\n\t\trole->bounds = le32_to_cpu(buf[2]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = ebitmap_read(&role->dominates, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = ebitmap_read(&role->types, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (strcmp(key, OBJECT_R) == 0) {\n\t\trc = -EINVAL;\n\t\tif (role->value != OBJECT_R_VAL) {\n\t\t\tprintk(KERN_ERR \"SELinux: Role %s has wrong value %d\\n\",\n\t\t\t       OBJECT_R, role->value);\n\t\t\tgoto bad;\n\t\t}\n\t\trc = 0;\n\t\tgoto bad;\n\t}\n\n\trc = hashtab_insert(h, key, role);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\trole_destroy(key, role, NULL);\n\treturn rc;\n}"
  },
  {
    "function_name": "class_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1315-1406",
    "snippet": "static int class_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct class_datum *cladatum;\n\t__le32 buf[6];\n\tu32 len, len2, ncons, nel;\n\tint i, rc;\n\n\tcladatum = kzalloc(sizeof(*cladatum), GFP_KERNEL);\n\tif (!cladatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof(u32)*6);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tlen2 = le32_to_cpu(buf[1]);\n\tcladatum->value = le32_to_cpu(buf[2]);\n\n\trc = symtab_init(&cladatum->permissions, PERM_SYMTAB_SIZE);\n\tif (rc)\n\t\tgoto bad;\n\tcladatum->permissions.nprim = le32_to_cpu(buf[3]);\n\tnel = le32_to_cpu(buf[4]);\n\n\tncons = le32_to_cpu(buf[5]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (len2) {\n\t\trc = str_read(&cladatum->comkey, GFP_KERNEL, fp, len2);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trc = -EINVAL;\n\t\tcladatum->comdatum = hashtab_search(p->p_commons.table, cladatum->comkey);\n\t\tif (!cladatum->comdatum) {\n\t\t\tprintk(KERN_ERR \"SELinux:  unknown common %s\\n\", cladatum->comkey);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tfor (i = 0; i < nel; i++) {\n\t\trc = perm_read(p, cladatum->permissions.table, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = read_cons_helper(p, &cladatum->constraints, ncons, 0, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (p->policyvers >= POLICYDB_VERSION_VALIDATETRANS) {\n\t\t/* grab the validatetrans rules */\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\tncons = le32_to_cpu(buf[0]);\n\t\trc = read_cons_helper(p, &cladatum->validatetrans,\n\t\t\t\tncons, 1, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_NEW_OBJECT_DEFAULTS) {\n\t\trc = next_entry(buf, fp, sizeof(u32) * 3);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\tcladatum->default_user = le32_to_cpu(buf[0]);\n\t\tcladatum->default_role = le32_to_cpu(buf[1]);\n\t\tcladatum->default_range = le32_to_cpu(buf[2]);\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_DEFAULT_TYPE) {\n\t\trc = next_entry(buf, fp, sizeof(u32) * 1);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\tcladatum->default_type = le32_to_cpu(buf[0]);\n\t}\n\n\trc = hashtab_insert(h, key, cladatum);\n\tif (rc)\n\t\tgoto bad;\n\n\treturn 0;\nbad:\n\tcls_destroy(key, cladatum, NULL);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cls_destroy",
          "args": [
            "key",
            "cladatum",
            "NULL"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "cls_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "647-687",
          "snippet": "static int cls_destroy(void *key, void *datum, void *p)\n{\n\tstruct class_datum *cladatum;\n\tstruct constraint_node *constraint, *ctemp;\n\tstruct constraint_expr *e, *etmp;\n\n\tkfree(key);\n\tif (datum) {\n\t\tcladatum = datum;\n\t\thashtab_map(cladatum->permissions.table, perm_destroy, NULL);\n\t\thashtab_destroy(cladatum->permissions.table);\n\t\tconstraint = cladatum->constraints;\n\t\twhile (constraint) {\n\t\t\te = constraint->expr;\n\t\t\twhile (e) {\n\t\t\t\tetmp = e;\n\t\t\t\te = e->next;\n\t\t\t\tconstraint_expr_destroy(etmp);\n\t\t\t}\n\t\t\tctemp = constraint;\n\t\t\tconstraint = constraint->next;\n\t\t\tkfree(ctemp);\n\t\t}\n\n\t\tconstraint = cladatum->validatetrans;\n\t\twhile (constraint) {\n\t\t\te = constraint->expr;\n\t\t\twhile (e) {\n\t\t\t\tetmp = e;\n\t\t\t\te = e->next;\n\t\t\t\tconstraint_expr_destroy(etmp);\n\t\t\t}\n\t\t\tctemp = constraint;\n\t\t\tconstraint = constraint->next;\n\t\t\tkfree(ctemp);\n\t\t}\n\t\tkfree(cladatum->comkey);\n\t}\n\tkfree(datum);\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int cls_destroy(void *key, void *datum, void *p)\n{\n\tstruct class_datum *cladatum;\n\tstruct constraint_node *constraint, *ctemp;\n\tstruct constraint_expr *e, *etmp;\n\n\tkfree(key);\n\tif (datum) {\n\t\tcladatum = datum;\n\t\thashtab_map(cladatum->permissions.table, perm_destroy, NULL);\n\t\thashtab_destroy(cladatum->permissions.table);\n\t\tconstraint = cladatum->constraints;\n\t\twhile (constraint) {\n\t\t\te = constraint->expr;\n\t\t\twhile (e) {\n\t\t\t\tetmp = e;\n\t\t\t\te = e->next;\n\t\t\t\tconstraint_expr_destroy(etmp);\n\t\t\t}\n\t\t\tctemp = constraint;\n\t\t\tconstraint = constraint->next;\n\t\t\tkfree(ctemp);\n\t\t}\n\n\t\tconstraint = cladatum->validatetrans;\n\t\twhile (constraint) {\n\t\t\te = constraint->expr;\n\t\t\twhile (e) {\n\t\t\t\tetmp = e;\n\t\t\t\te = e->next;\n\t\t\t\tconstraint_expr_destroy(etmp);\n\t\t\t}\n\t\t\tctemp = constraint;\n\t\t\tconstraint = constraint->next;\n\t\t\tkfree(ctemp);\n\t\t}\n\t\tkfree(cladatum->comkey);\n\t}\n\tkfree(datum);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_insert",
          "args": [
            "h",
            "key",
            "cladatum"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "42-78",
          "snippet": "int hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(u32) * 1"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cons_helper",
          "args": [
            "p",
            "&cladatum->validatetrans",
            "ncons",
            "1",
            "fp"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "read_cons_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1219-1313",
          "snippet": "static int read_cons_helper(struct policydb *p,\n\t\t\t\tstruct constraint_node **nodep,\n\t\t\t\tint ncons, int allowxtarget, void *fp)\n{\n\tstruct constraint_node *c, *lc;\n\tstruct constraint_expr *e, *le;\n\t__le32 buf[3];\n\tu32 nexpr;\n\tint rc, i, j, depth;\n\n\tlc = NULL;\n\tfor (i = 0; i < ncons; i++) {\n\t\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\t\tif (!c)\n\t\t\treturn -ENOMEM;\n\n\t\tif (lc)\n\t\t\tlc->next = c;\n\t\telse\n\t\t\t*nodep = c;\n\n\t\trc = next_entry(buf, fp, (sizeof(u32) * 2));\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tc->permissions = le32_to_cpu(buf[0]);\n\t\tnexpr = le32_to_cpu(buf[1]);\n\t\tle = NULL;\n\t\tdepth = -1;\n\t\tfor (j = 0; j < nexpr; j++) {\n\t\t\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\t\t\tif (!e)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (le)\n\t\t\t\tle->next = e;\n\t\t\telse\n\t\t\t\tc->expr = e;\n\n\t\t\trc = next_entry(buf, fp, (sizeof(u32) * 3));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\te->expr_type = le32_to_cpu(buf[0]);\n\t\t\te->attr = le32_to_cpu(buf[1]);\n\t\t\te->op = le32_to_cpu(buf[2]);\n\n\t\t\tswitch (e->expr_type) {\n\t\t\tcase CEXPR_NOT:\n\t\t\t\tif (depth < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_AND:\n\t\t\tcase CEXPR_OR:\n\t\t\t\tif (depth < 1)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth--;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ATTR:\n\t\t\t\tif (depth == (CEXPR_MAXDEPTH - 1))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth++;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NAMES:\n\t\t\t\tif (!allowxtarget && (e->attr & CEXPR_XTARGET))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (depth == (CEXPR_MAXDEPTH - 1))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth++;\n\t\t\t\trc = ebitmap_read(&e->names, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tif (p->policyvers >=\n\t\t\t\t\tPOLICYDB_VERSION_CONSTRAINT_NAMES) {\n\t\t\t\t\t\te->type_names = kzalloc(sizeof\n\t\t\t\t\t\t(*e->type_names),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\tif (!e->type_names)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\ttype_set_init(e->type_names);\n\t\t\t\t\trc = type_set_read(e->type_names, fp);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tle = e;\n\t\t}\n\t\tif (depth != 0)\n\t\t\treturn -EINVAL;\n\t\tlc = c;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int read_cons_helper(struct policydb *p,\n\t\t\t\tstruct constraint_node **nodep,\n\t\t\t\tint ncons, int allowxtarget, void *fp)\n{\n\tstruct constraint_node *c, *lc;\n\tstruct constraint_expr *e, *le;\n\t__le32 buf[3];\n\tu32 nexpr;\n\tint rc, i, j, depth;\n\n\tlc = NULL;\n\tfor (i = 0; i < ncons; i++) {\n\t\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\t\tif (!c)\n\t\t\treturn -ENOMEM;\n\n\t\tif (lc)\n\t\t\tlc->next = c;\n\t\telse\n\t\t\t*nodep = c;\n\n\t\trc = next_entry(buf, fp, (sizeof(u32) * 2));\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tc->permissions = le32_to_cpu(buf[0]);\n\t\tnexpr = le32_to_cpu(buf[1]);\n\t\tle = NULL;\n\t\tdepth = -1;\n\t\tfor (j = 0; j < nexpr; j++) {\n\t\t\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\t\t\tif (!e)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (le)\n\t\t\t\tle->next = e;\n\t\t\telse\n\t\t\t\tc->expr = e;\n\n\t\t\trc = next_entry(buf, fp, (sizeof(u32) * 3));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\te->expr_type = le32_to_cpu(buf[0]);\n\t\t\te->attr = le32_to_cpu(buf[1]);\n\t\t\te->op = le32_to_cpu(buf[2]);\n\n\t\t\tswitch (e->expr_type) {\n\t\t\tcase CEXPR_NOT:\n\t\t\t\tif (depth < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_AND:\n\t\t\tcase CEXPR_OR:\n\t\t\t\tif (depth < 1)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth--;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ATTR:\n\t\t\t\tif (depth == (CEXPR_MAXDEPTH - 1))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth++;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NAMES:\n\t\t\t\tif (!allowxtarget && (e->attr & CEXPR_XTARGET))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (depth == (CEXPR_MAXDEPTH - 1))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth++;\n\t\t\t\trc = ebitmap_read(&e->names, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tif (p->policyvers >=\n\t\t\t\t\tPOLICYDB_VERSION_CONSTRAINT_NAMES) {\n\t\t\t\t\t\te->type_names = kzalloc(sizeof\n\t\t\t\t\t\t(*e->type_names),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\tif (!e->type_names)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\ttype_set_init(e->type_names);\n\t\t\t\t\trc = type_set_read(e->type_names, fp);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tle = e;\n\t\t}\n\t\tif (depth != 0)\n\t\t\treturn -EINVAL;\n\t\tlc = c;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perm_read",
          "args": [
            "p",
            "cladatum->permissions.table",
            "fp"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "perm_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1117-1148",
          "snippet": "static int perm_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct perm_datum *perdatum;\n\tint rc;\n\t__le32 buf[2];\n\tu32 len;\n\n\tperdatum = kzalloc(sizeof(*perdatum), GFP_KERNEL);\n\tif (!perdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tperdatum->value = le32_to_cpu(buf[1]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = hashtab_insert(h, key, perdatum);\n\tif (rc)\n\t\tgoto bad;\n\n\treturn 0;\nbad:\n\tperm_destroy(key, perdatum, NULL);\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int perm_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct perm_datum *perdatum;\n\tint rc;\n\t__le32 buf[2];\n\tu32 len;\n\n\tperdatum = kzalloc(sizeof(*perdatum), GFP_KERNEL);\n\tif (!perdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tperdatum->value = le32_to_cpu(buf[1]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = hashtab_insert(h, key, perdatum);\n\tif (rc)\n\t\tgoto bad;\n\n\treturn 0;\nbad:\n\tperm_destroy(key, perdatum, NULL);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  unknown common %s\\n\"",
            "cladatum->comkey"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "p->p_commons.table",
            "cladatum->comkey"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_read",
          "args": [
            "&cladatum->comkey",
            "GFP_KERNEL",
            "fp",
            "len2"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "str_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1094-1115",
          "snippet": "static int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[5]"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[4]"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[3]"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symtab_init",
          "args": [
            "&cladatum->permissions",
            "PERM_SYMTAB_SIZE"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "symtab_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/symtab.c",
          "lines": "36-43",
          "snippet": "int symtab_init(struct symtab *s, unsigned int size)\n{\n\ts->table = hashtab_create(symhash, symcmp, size);\n\tif (!s->table)\n\t\treturn -ENOMEM;\n\ts->nprim = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"symtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"symtab.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint symtab_init(struct symtab *s, unsigned int size)\n{\n\ts->table = hashtab_create(symhash, symcmp, size);\n\tif (!s->table)\n\t\treturn -ENOMEM;\n\ts->nprim = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*cladatum)",
            "GFP_KERNEL"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int class_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct class_datum *cladatum;\n\t__le32 buf[6];\n\tu32 len, len2, ncons, nel;\n\tint i, rc;\n\n\tcladatum = kzalloc(sizeof(*cladatum), GFP_KERNEL);\n\tif (!cladatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof(u32)*6);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tlen2 = le32_to_cpu(buf[1]);\n\tcladatum->value = le32_to_cpu(buf[2]);\n\n\trc = symtab_init(&cladatum->permissions, PERM_SYMTAB_SIZE);\n\tif (rc)\n\t\tgoto bad;\n\tcladatum->permissions.nprim = le32_to_cpu(buf[3]);\n\tnel = le32_to_cpu(buf[4]);\n\n\tncons = le32_to_cpu(buf[5]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (len2) {\n\t\trc = str_read(&cladatum->comkey, GFP_KERNEL, fp, len2);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\trc = -EINVAL;\n\t\tcladatum->comdatum = hashtab_search(p->p_commons.table, cladatum->comkey);\n\t\tif (!cladatum->comdatum) {\n\t\t\tprintk(KERN_ERR \"SELinux:  unknown common %s\\n\", cladatum->comkey);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tfor (i = 0; i < nel; i++) {\n\t\trc = perm_read(p, cladatum->permissions.table, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = read_cons_helper(p, &cladatum->constraints, ncons, 0, fp);\n\tif (rc)\n\t\tgoto bad;\n\n\tif (p->policyvers >= POLICYDB_VERSION_VALIDATETRANS) {\n\t\t/* grab the validatetrans rules */\n\t\trc = next_entry(buf, fp, sizeof(u32));\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\tncons = le32_to_cpu(buf[0]);\n\t\trc = read_cons_helper(p, &cladatum->validatetrans,\n\t\t\t\tncons, 1, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_NEW_OBJECT_DEFAULTS) {\n\t\trc = next_entry(buf, fp, sizeof(u32) * 3);\n\t\tif (rc)\n\t\t\tgoto bad;\n\n\t\tcladatum->default_user = le32_to_cpu(buf[0]);\n\t\tcladatum->default_role = le32_to_cpu(buf[1]);\n\t\tcladatum->default_range = le32_to_cpu(buf[2]);\n\t}\n\n\tif (p->policyvers >= POLICYDB_VERSION_DEFAULT_TYPE) {\n\t\trc = next_entry(buf, fp, sizeof(u32) * 1);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t\tcladatum->default_type = le32_to_cpu(buf[0]);\n\t}\n\n\trc = hashtab_insert(h, key, cladatum);\n\tif (rc)\n\t\tgoto bad;\n\n\treturn 0;\nbad:\n\tcls_destroy(key, cladatum, NULL);\n\treturn rc;\n}"
  },
  {
    "function_name": "read_cons_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1219-1313",
    "snippet": "static int read_cons_helper(struct policydb *p,\n\t\t\t\tstruct constraint_node **nodep,\n\t\t\t\tint ncons, int allowxtarget, void *fp)\n{\n\tstruct constraint_node *c, *lc;\n\tstruct constraint_expr *e, *le;\n\t__le32 buf[3];\n\tu32 nexpr;\n\tint rc, i, j, depth;\n\n\tlc = NULL;\n\tfor (i = 0; i < ncons; i++) {\n\t\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\t\tif (!c)\n\t\t\treturn -ENOMEM;\n\n\t\tif (lc)\n\t\t\tlc->next = c;\n\t\telse\n\t\t\t*nodep = c;\n\n\t\trc = next_entry(buf, fp, (sizeof(u32) * 2));\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tc->permissions = le32_to_cpu(buf[0]);\n\t\tnexpr = le32_to_cpu(buf[1]);\n\t\tle = NULL;\n\t\tdepth = -1;\n\t\tfor (j = 0; j < nexpr; j++) {\n\t\t\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\t\t\tif (!e)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (le)\n\t\t\t\tle->next = e;\n\t\t\telse\n\t\t\t\tc->expr = e;\n\n\t\t\trc = next_entry(buf, fp, (sizeof(u32) * 3));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\te->expr_type = le32_to_cpu(buf[0]);\n\t\t\te->attr = le32_to_cpu(buf[1]);\n\t\t\te->op = le32_to_cpu(buf[2]);\n\n\t\t\tswitch (e->expr_type) {\n\t\t\tcase CEXPR_NOT:\n\t\t\t\tif (depth < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_AND:\n\t\t\tcase CEXPR_OR:\n\t\t\t\tif (depth < 1)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth--;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ATTR:\n\t\t\t\tif (depth == (CEXPR_MAXDEPTH - 1))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth++;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NAMES:\n\t\t\t\tif (!allowxtarget && (e->attr & CEXPR_XTARGET))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (depth == (CEXPR_MAXDEPTH - 1))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth++;\n\t\t\t\trc = ebitmap_read(&e->names, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tif (p->policyvers >=\n\t\t\t\t\tPOLICYDB_VERSION_CONSTRAINT_NAMES) {\n\t\t\t\t\t\te->type_names = kzalloc(sizeof\n\t\t\t\t\t\t(*e->type_names),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\tif (!e->type_names)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\ttype_set_init(e->type_names);\n\t\t\t\t\trc = type_set_read(e->type_names, fp);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tle = e;\n\t\t}\n\t\tif (depth != 0)\n\t\t\treturn -EINVAL;\n\t\tlc = c;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "type_set_read",
          "args": [
            "e->type_names",
            "fp"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "type_set_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1200-1216",
          "snippet": "static int type_set_read(struct type_set *t, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tif (ebitmap_read(&t->types, fp))\n\t\treturn -EINVAL;\n\tif (ebitmap_read(&t->negset, fp))\n\t\treturn -EINVAL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc < 0)\n\t\treturn -EINVAL;\n\tt->flags = le32_to_cpu(buf[0]);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int type_set_read(struct type_set *t, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tif (ebitmap_read(&t->types, fp))\n\t\treturn -EINVAL;\n\tif (ebitmap_read(&t->negset, fp))\n\t\treturn -EINVAL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc < 0)\n\t\treturn -EINVAL;\n\tt->flags = le32_to_cpu(buf[0]);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "type_set_init",
          "args": [
            "e->type_names"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "type_set_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1194-1198",
          "snippet": "static void type_set_init(struct type_set *t)\n{\n\tebitmap_init(&t->types);\n\tebitmap_init(&t->negset);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void type_set_init(struct type_set *t)\n{\n\tebitmap_init(&t->types);\n\tebitmap_init(&t->negset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof\n\t\t\t\t\t\t(*e->type_names)",
            "GFP_KERNEL"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_read",
          "args": [
            "&e->names",
            "fp"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "346-449",
          "snippet": "int ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "(sizeof(u32) * 3)"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*e)",
            "GFP_KERNEL"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*c)",
            "GFP_KERNEL"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int read_cons_helper(struct policydb *p,\n\t\t\t\tstruct constraint_node **nodep,\n\t\t\t\tint ncons, int allowxtarget, void *fp)\n{\n\tstruct constraint_node *c, *lc;\n\tstruct constraint_expr *e, *le;\n\t__le32 buf[3];\n\tu32 nexpr;\n\tint rc, i, j, depth;\n\n\tlc = NULL;\n\tfor (i = 0; i < ncons; i++) {\n\t\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\t\tif (!c)\n\t\t\treturn -ENOMEM;\n\n\t\tif (lc)\n\t\t\tlc->next = c;\n\t\telse\n\t\t\t*nodep = c;\n\n\t\trc = next_entry(buf, fp, (sizeof(u32) * 2));\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tc->permissions = le32_to_cpu(buf[0]);\n\t\tnexpr = le32_to_cpu(buf[1]);\n\t\tle = NULL;\n\t\tdepth = -1;\n\t\tfor (j = 0; j < nexpr; j++) {\n\t\t\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\t\t\tif (!e)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (le)\n\t\t\t\tle->next = e;\n\t\t\telse\n\t\t\t\tc->expr = e;\n\n\t\t\trc = next_entry(buf, fp, (sizeof(u32) * 3));\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\te->expr_type = le32_to_cpu(buf[0]);\n\t\t\te->attr = le32_to_cpu(buf[1]);\n\t\t\te->op = le32_to_cpu(buf[2]);\n\n\t\t\tswitch (e->expr_type) {\n\t\t\tcase CEXPR_NOT:\n\t\t\t\tif (depth < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_AND:\n\t\t\tcase CEXPR_OR:\n\t\t\t\tif (depth < 1)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth--;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ATTR:\n\t\t\t\tif (depth == (CEXPR_MAXDEPTH - 1))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth++;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NAMES:\n\t\t\t\tif (!allowxtarget && (e->attr & CEXPR_XTARGET))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (depth == (CEXPR_MAXDEPTH - 1))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdepth++;\n\t\t\t\trc = ebitmap_read(&e->names, fp);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t\tif (p->policyvers >=\n\t\t\t\t\tPOLICYDB_VERSION_CONSTRAINT_NAMES) {\n\t\t\t\t\t\te->type_names = kzalloc(sizeof\n\t\t\t\t\t\t(*e->type_names),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\tif (!e->type_names)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\ttype_set_init(e->type_names);\n\t\t\t\t\trc = type_set_read(e->type_names, fp);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tle = e;\n\t\t}\n\t\tif (depth != 0)\n\t\t\treturn -EINVAL;\n\t\tlc = c;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "type_set_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1200-1216",
    "snippet": "static int type_set_read(struct type_set *t, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tif (ebitmap_read(&t->types, fp))\n\t\treturn -EINVAL;\n\tif (ebitmap_read(&t->negset, fp))\n\t\treturn -EINVAL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc < 0)\n\t\treturn -EINVAL;\n\tt->flags = le32_to_cpu(buf[0]);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(u32)"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_read",
          "args": [
            "&t->negset",
            "fp"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "346-449",
          "snippet": "int ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int type_set_read(struct type_set *t, void *fp)\n{\n\t__le32 buf[1];\n\tint rc;\n\n\tif (ebitmap_read(&t->types, fp))\n\t\treturn -EINVAL;\n\tif (ebitmap_read(&t->negset, fp))\n\t\treturn -EINVAL;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc < 0)\n\t\treturn -EINVAL;\n\tt->flags = le32_to_cpu(buf[0]);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "type_set_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1194-1198",
    "snippet": "static void type_set_init(struct type_set *t)\n{\n\tebitmap_init(&t->types);\n\tebitmap_init(&t->negset);\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_init",
          "args": [
            "&t->negset"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.h",
          "lines": "60-63",
          "snippet": "static inline void ebitmap_init(struct ebitmap *e)\n{\n\tmemset(e, 0, sizeof(*e));\n}",
          "includes": [
            "#include <net/netlabel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/netlabel.h>\n\nstatic inline void ebitmap_init(struct ebitmap *e)\n{\n\tmemset(e, 0, sizeof(*e));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void type_set_init(struct type_set *t)\n{\n\tebitmap_init(&t->types);\n\tebitmap_init(&t->negset);\n}"
  },
  {
    "function_name": "common_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1150-1192",
    "snippet": "static int common_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct common_datum *comdatum;\n\t__le32 buf[4];\n\tu32 len, nel;\n\tint i, rc;\n\n\tcomdatum = kzalloc(sizeof(*comdatum), GFP_KERNEL);\n\tif (!comdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tcomdatum->value = le32_to_cpu(buf[1]);\n\n\trc = symtab_init(&comdatum->permissions, PERM_SYMTAB_SIZE);\n\tif (rc)\n\t\tgoto bad;\n\tcomdatum->permissions.nprim = le32_to_cpu(buf[2]);\n\tnel = le32_to_cpu(buf[3]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = perm_read(p, comdatum->permissions.table, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = hashtab_insert(h, key, comdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\tcommon_destroy(key, comdatum, NULL);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_destroy",
          "args": [
            "key",
            "comdatum",
            "NULL"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "common_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "620-632",
          "snippet": "static int common_destroy(void *key, void *datum, void *p)\n{\n\tstruct common_datum *comdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tcomdatum = datum;\n\t\thashtab_map(comdatum->permissions.table, perm_destroy, NULL);\n\t\thashtab_destroy(comdatum->permissions.table);\n\t}\n\tkfree(datum);\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int common_destroy(void *key, void *datum, void *p)\n{\n\tstruct common_datum *comdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tcomdatum = datum;\n\t\thashtab_map(comdatum->permissions.table, perm_destroy, NULL);\n\t\thashtab_destroy(comdatum->permissions.table);\n\t}\n\tkfree(datum);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_insert",
          "args": [
            "h",
            "key",
            "comdatum"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "42-78",
          "snippet": "int hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perm_read",
          "args": [
            "p",
            "comdatum->permissions.table",
            "fp"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "perm_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1117-1148",
          "snippet": "static int perm_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct perm_datum *perdatum;\n\tint rc;\n\t__le32 buf[2];\n\tu32 len;\n\n\tperdatum = kzalloc(sizeof(*perdatum), GFP_KERNEL);\n\tif (!perdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tperdatum->value = le32_to_cpu(buf[1]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = hashtab_insert(h, key, perdatum);\n\tif (rc)\n\t\tgoto bad;\n\n\treturn 0;\nbad:\n\tperm_destroy(key, perdatum, NULL);\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int perm_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct perm_datum *perdatum;\n\tint rc;\n\t__le32 buf[2];\n\tu32 len;\n\n\tperdatum = kzalloc(sizeof(*perdatum), GFP_KERNEL);\n\tif (!perdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tperdatum->value = le32_to_cpu(buf[1]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = hashtab_insert(h, key, perdatum);\n\tif (rc)\n\t\tgoto bad;\n\n\treturn 0;\nbad:\n\tperm_destroy(key, perdatum, NULL);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_read",
          "args": [
            "&key",
            "GFP_KERNEL",
            "fp",
            "len"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "str_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1094-1115",
          "snippet": "static int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[3]"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symtab_init",
          "args": [
            "&comdatum->permissions",
            "PERM_SYMTAB_SIZE"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "symtab_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/symtab.c",
          "lines": "36-43",
          "snippet": "int symtab_init(struct symtab *s, unsigned int size)\n{\n\ts->table = hashtab_create(symhash, symcmp, size);\n\tif (!s->table)\n\t\treturn -ENOMEM;\n\ts->nprim = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"symtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"symtab.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint symtab_init(struct symtab *s, unsigned int size)\n{\n\ts->table = hashtab_create(symhash, symcmp, size);\n\tif (!s->table)\n\t\treturn -ENOMEM;\n\ts->nprim = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof buf"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*comdatum)",
            "GFP_KERNEL"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int common_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct common_datum *comdatum;\n\t__le32 buf[4];\n\tu32 len, nel;\n\tint i, rc;\n\n\tcomdatum = kzalloc(sizeof(*comdatum), GFP_KERNEL);\n\tif (!comdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tcomdatum->value = le32_to_cpu(buf[1]);\n\n\trc = symtab_init(&comdatum->permissions, PERM_SYMTAB_SIZE);\n\tif (rc)\n\t\tgoto bad;\n\tcomdatum->permissions.nprim = le32_to_cpu(buf[2]);\n\tnel = le32_to_cpu(buf[3]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = perm_read(p, comdatum->permissions.table, fp);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\trc = hashtab_insert(h, key, comdatum);\n\tif (rc)\n\t\tgoto bad;\n\treturn 0;\nbad:\n\tcommon_destroy(key, comdatum, NULL);\n\treturn rc;\n}"
  },
  {
    "function_name": "perm_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1117-1148",
    "snippet": "static int perm_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct perm_datum *perdatum;\n\tint rc;\n\t__le32 buf[2];\n\tu32 len;\n\n\tperdatum = kzalloc(sizeof(*perdatum), GFP_KERNEL);\n\tif (!perdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tperdatum->value = le32_to_cpu(buf[1]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = hashtab_insert(h, key, perdatum);\n\tif (rc)\n\t\tgoto bad;\n\n\treturn 0;\nbad:\n\tperm_destroy(key, perdatum, NULL);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perm_destroy",
          "args": [
            "key",
            "perdatum",
            "NULL"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "perm_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "613-618",
          "snippet": "static int perm_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int perm_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_insert",
          "args": [
            "h",
            "key",
            "perdatum"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "42-78",
          "snippet": "int hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_read",
          "args": [
            "&key",
            "GFP_KERNEL",
            "fp",
            "len"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "str_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "1094-1115",
          "snippet": "static int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof buf"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*perdatum)",
            "GFP_KERNEL"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int perm_read(struct policydb *p, struct hashtab *h, void *fp)\n{\n\tchar *key = NULL;\n\tstruct perm_datum *perdatum;\n\tint rc;\n\t__le32 buf[2];\n\tu32 len;\n\n\tperdatum = kzalloc(sizeof(*perdatum), GFP_KERNEL);\n\tif (!perdatum)\n\t\treturn -ENOMEM;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc)\n\t\tgoto bad;\n\n\tlen = le32_to_cpu(buf[0]);\n\tperdatum->value = le32_to_cpu(buf[1]);\n\n\trc = str_read(&key, GFP_KERNEL, fp, len);\n\tif (rc)\n\t\tgoto bad;\n\n\trc = hashtab_insert(h, key, perdatum);\n\tif (rc)\n\t\tgoto bad;\n\n\treturn 0;\nbad:\n\tperm_destroy(key, perdatum, NULL);\n\treturn rc;\n}"
  },
  {
    "function_name": "str_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1094-1115",
    "snippet": "static int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "str",
            "fp",
            "len"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "flags"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int str_read(char **strp, gfp_t flags, void *fp, u32 len)\n{\n\tint rc;\n\tchar *str;\n\n\tif ((len == 0) || (len == (u32)-1))\n\t\treturn -EINVAL;\n\n\tstr = kmalloc(len + 1, flags);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t/* it's expected the caller should free the str */\n\t*strp = str;\n\n\trc = next_entry(str, fp, len);\n\tif (rc)\n\t\treturn rc;\n\n\tstr[len] = '\\0';\n\treturn 0;\n}"
  },
  {
    "function_name": "context_read_and_validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "1054-1086",
    "snippet": "static int context_read_and_validate(struct context *c,\n\t\t\t\t     struct policydb *p,\n\t\t\t\t     void *fp)\n{\n\t__le32 buf[3];\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: context truncated\\n\");\n\t\tgoto out;\n\t}\n\tc->user = le32_to_cpu(buf[0]);\n\tc->role = le32_to_cpu(buf[1]);\n\tc->type = le32_to_cpu(buf[2]);\n\tif (p->policyvers >= POLICYDB_VERSION_MLS) {\n\t\trc = mls_read_range_helper(&c->range, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: error reading MLS range of context\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = -EINVAL;\n\tif (!policydb_context_isvalid(p, c)) {\n\t\tprintk(KERN_ERR \"SELinux:  invalid security context\\n\");\n\t\tcontext_destroy(c);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_destroy",
          "args": [
            "c"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "context_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "142-149",
          "snippet": "static inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  invalid security context\\n\""
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policydb_context_isvalid",
          "args": [
            "p",
            "c"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_context_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "950-989",
          "snippet": "int policydb_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct role_datum *role;\n\tstruct user_datum *usrdatum;\n\n\tif (!c->role || c->role > p->p_roles.nprim)\n\t\treturn 0;\n\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\n\tif (!c->type || c->type > p->p_types.nprim)\n\t\treturn 0;\n\n\tif (c->role != OBJECT_R_VAL) {\n\t\t/*\n\t\t * Role must be authorized for the type.\n\t\t */\n\t\trole = p->role_val_to_struct[c->role - 1];\n\t\tif (!role || !ebitmap_get_bit(&role->types, c->type - 1))\n\t\t\t/* role may not be associated with type */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * User must be authorized for the role.\n\t\t */\n\t\tusrdatum = p->user_val_to_struct[c->user - 1];\n\t\tif (!usrdatum)\n\t\t\treturn 0;\n\n\t\tif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\n\t\t\t/* user may not be associated with role */\n\t\t\treturn 0;\n\t}\n\n\tif (!mls_context_isvalid(p, c))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct role_datum *role;\n\tstruct user_datum *usrdatum;\n\n\tif (!c->role || c->role > p->p_roles.nprim)\n\t\treturn 0;\n\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\n\tif (!c->type || c->type > p->p_types.nprim)\n\t\treturn 0;\n\n\tif (c->role != OBJECT_R_VAL) {\n\t\t/*\n\t\t * Role must be authorized for the type.\n\t\t */\n\t\trole = p->role_val_to_struct[c->role - 1];\n\t\tif (!role || !ebitmap_get_bit(&role->types, c->type - 1))\n\t\t\t/* role may not be associated with type */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * User must be authorized for the role.\n\t\t */\n\t\tusrdatum = p->user_val_to_struct[c->user - 1];\n\t\tif (!usrdatum)\n\t\t\treturn 0;\n\n\t\tif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\n\t\t\t/* user may not be associated with role */\n\t\t\treturn 0;\n\t}\n\n\tif (!mls_context_isvalid(p, c))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: error reading MLS range of context\\n\""
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mls_read_range_helper",
          "args": [
            "&c->range",
            "fp"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "mls_read_range_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "995-1048",
          "snippet": "static int mls_read_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[2];\n\tu32 items;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\titems = le32_to_cpu(buf[0]);\n\tif (items > ARRAY_SIZE(buf)) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  range overflow\\n\");\n\t\tgoto out;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32) * items);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  truncated range\\n\");\n\t\tgoto out;\n\t}\n\n\tr->level[0].sens = le32_to_cpu(buf[0]);\n\tif (items > 1)\n\t\tr->level[1].sens = le32_to_cpu(buf[1]);\n\telse\n\t\tr->level[1].sens = r->level[0].sens;\n\n\trc = ebitmap_read(&r->level[0].cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading low categories\\n\");\n\t\tgoto out;\n\t}\n\tif (items > 1) {\n\t\trc = ebitmap_read(&r->level[1].cat, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  error reading high categories\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t} else {\n\t\trc = ebitmap_cpy(&r->level[1].cat, &r->level[0].cat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  out of memory\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t}\n\n\treturn 0;\nbad_high:\n\tebitmap_destroy(&r->level[0].cat);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_read_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[2];\n\tu32 items;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\titems = le32_to_cpu(buf[0]);\n\tif (items > ARRAY_SIZE(buf)) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  range overflow\\n\");\n\t\tgoto out;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32) * items);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  truncated range\\n\");\n\t\tgoto out;\n\t}\n\n\tr->level[0].sens = le32_to_cpu(buf[0]);\n\tif (items > 1)\n\t\tr->level[1].sens = le32_to_cpu(buf[1]);\n\telse\n\t\tr->level[1].sens = r->level[0].sens;\n\n\trc = ebitmap_read(&r->level[0].cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading low categories\\n\");\n\t\tgoto out;\n\t}\n\tif (items > 1) {\n\t\trc = ebitmap_read(&r->level[1].cat, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  error reading high categories\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t} else {\n\t\trc = ebitmap_cpy(&r->level[1].cat, &r->level[0].cat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  out of memory\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t}\n\n\treturn 0;\nbad_high:\n\tebitmap_destroy(&r->level[0].cat);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: context truncated\\n\""
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof buf"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int context_read_and_validate(struct context *c,\n\t\t\t\t     struct policydb *p,\n\t\t\t\t     void *fp)\n{\n\t__le32 buf[3];\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: context truncated\\n\");\n\t\tgoto out;\n\t}\n\tc->user = le32_to_cpu(buf[0]);\n\tc->role = le32_to_cpu(buf[1]);\n\tc->type = le32_to_cpu(buf[2]);\n\tif (p->policyvers >= POLICYDB_VERSION_MLS) {\n\t\trc = mls_read_range_helper(&c->range, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: error reading MLS range of context\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = -EINVAL;\n\tif (!policydb_context_isvalid(p, c)) {\n\t\tprintk(KERN_ERR \"SELinux:  invalid security context\\n\");\n\t\tcontext_destroy(c);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "mls_read_range_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "995-1048",
    "snippet": "static int mls_read_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[2];\n\tu32 items;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\titems = le32_to_cpu(buf[0]);\n\tif (items > ARRAY_SIZE(buf)) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  range overflow\\n\");\n\t\tgoto out;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32) * items);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  truncated range\\n\");\n\t\tgoto out;\n\t}\n\n\tr->level[0].sens = le32_to_cpu(buf[0]);\n\tif (items > 1)\n\t\tr->level[1].sens = le32_to_cpu(buf[1]);\n\telse\n\t\tr->level[1].sens = r->level[0].sens;\n\n\trc = ebitmap_read(&r->level[0].cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading low categories\\n\");\n\t\tgoto out;\n\t}\n\tif (items > 1) {\n\t\trc = ebitmap_read(&r->level[1].cat, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  error reading high categories\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t} else {\n\t\trc = ebitmap_cpy(&r->level[1].cat, &r->level[0].cat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  out of memory\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t}\n\n\treturn 0;\nbad_high:\n\tebitmap_destroy(&r->level[0].cat);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_destroy",
          "args": [
            "&r->level[0].cat"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "327-344",
          "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: mls:  out of memory\\n\""
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_cpy",
          "args": [
            "&r->level[1].cat",
            "&r->level[0].cat"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "52-78",
          "snippet": "int ebitmap_cpy(struct ebitmap *dst, struct ebitmap *src)\n{\n\tstruct ebitmap_node *n, *new, *prev;\n\n\tebitmap_init(dst);\n\tn = src->node;\n\tprev = NULL;\n\twhile (n) {\n\t\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\tif (!new) {\n\t\t\tebitmap_destroy(dst);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnew->startbit = n->startbit;\n\t\tmemcpy(new->maps, n->maps, EBITMAP_SIZE / 8);\n\t\tnew->next = NULL;\n\t\tif (prev)\n\t\t\tprev->next = new;\n\t\telse\n\t\t\tdst->node = new;\n\t\tprev = new;\n\t\tn = n->next;\n\t}\n\n\tdst->highbit = src->highbit;\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_cpy(struct ebitmap *dst, struct ebitmap *src)\n{\n\tstruct ebitmap_node *n, *new, *prev;\n\n\tebitmap_init(dst);\n\tn = src->node;\n\tprev = NULL;\n\twhile (n) {\n\t\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\tif (!new) {\n\t\t\tebitmap_destroy(dst);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnew->startbit = n->startbit;\n\t\tmemcpy(new->maps, n->maps, EBITMAP_SIZE / 8);\n\t\tnew->next = NULL;\n\t\tif (prev)\n\t\t\tprev->next = new;\n\t\telse\n\t\t\tdst->node = new;\n\t\tprev = new;\n\t\tn = n->next;\n\t}\n\n\tdst->highbit = src->highbit;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: mls:  error reading high categories\\n\""
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_read",
          "args": [
            "&r->level[1].cat",
            "fp"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "346-449",
          "snippet": "int ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64\t(sizeof(u64) * 8)"
          ],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: mls:  error reading low categories\\n\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: mls:  truncated range\\n\""
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(u32) * items"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: mls:  range overflow\\n\""
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int mls_read_range_helper(struct mls_range *r, void *fp)\n{\n\t__le32 buf[2];\n\tu32 items;\n\tint rc;\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\titems = le32_to_cpu(buf[0]);\n\tif (items > ARRAY_SIZE(buf)) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  range overflow\\n\");\n\t\tgoto out;\n\t}\n\n\trc = next_entry(buf, fp, sizeof(u32) * items);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  truncated range\\n\");\n\t\tgoto out;\n\t}\n\n\tr->level[0].sens = le32_to_cpu(buf[0]);\n\tif (items > 1)\n\t\tr->level[1].sens = le32_to_cpu(buf[1]);\n\telse\n\t\tr->level[1].sens = r->level[0].sens;\n\n\trc = ebitmap_read(&r->level[0].cat, fp);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: mls:  error reading low categories\\n\");\n\t\tgoto out;\n\t}\n\tif (items > 1) {\n\t\trc = ebitmap_read(&r->level[1].cat, fp);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  error reading high categories\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t} else {\n\t\trc = ebitmap_cpy(&r->level[1].cat, &r->level[0].cat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: mls:  out of memory\\n\");\n\t\t\tgoto bad_high;\n\t\t}\n\t}\n\n\treturn 0;\nbad_high:\n\tebitmap_destroy(&r->level[0].cat);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "policydb_context_isvalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "950-989",
    "snippet": "int policydb_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct role_datum *role;\n\tstruct user_datum *usrdatum;\n\n\tif (!c->role || c->role > p->p_roles.nprim)\n\t\treturn 0;\n\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\n\tif (!c->type || c->type > p->p_types.nprim)\n\t\treturn 0;\n\n\tif (c->role != OBJECT_R_VAL) {\n\t\t/*\n\t\t * Role must be authorized for the type.\n\t\t */\n\t\trole = p->role_val_to_struct[c->role - 1];\n\t\tif (!role || !ebitmap_get_bit(&role->types, c->type - 1))\n\t\t\t/* role may not be associated with type */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * User must be authorized for the role.\n\t\t */\n\t\tusrdatum = p->user_val_to_struct[c->user - 1];\n\t\tif (!usrdatum)\n\t\t\treturn 0;\n\n\t\tif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\n\t\t\t/* user may not be associated with role */\n\t\t\treturn 0;\n\t}\n\n\tif (!mls_context_isvalid(p, c))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mls_context_isvalid",
          "args": [
            "p",
            "c"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "mls_context_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "192-215",
          "snippet": "int mls_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct user_datum *usrdatum;\n\n\tif (!p->mls_enabled)\n\t\treturn 1;\n\n\tif (!mls_range_isvalid(p, &c->range))\n\t\treturn 0;\n\n\tif (c->role == OBJECT_R_VAL)\n\t\treturn 1;\n\n\t/*\n\t * User must be authorized for the MLS range.\n\t */\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\tusrdatum = p->user_val_to_struct[c->user - 1];\n\tif (!mls_range_contains(usrdatum->range, c->range))\n\t\treturn 0; /* user may not be associated with range */\n\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct user_datum *usrdatum;\n\n\tif (!p->mls_enabled)\n\t\treturn 1;\n\n\tif (!mls_range_isvalid(p, &c->range))\n\t\treturn 0;\n\n\tif (c->role == OBJECT_R_VAL)\n\t\treturn 1;\n\n\t/*\n\t * User must be authorized for the MLS range.\n\t */\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\tusrdatum = p->user_val_to_struct[c->user - 1];\n\tif (!mls_range_contains(usrdatum->range, c->range))\n\t\treturn 0; /* user may not be associated with range */\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_get_bit",
          "args": [
            "&usrdatum->roles",
            "c->role - 1"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_get_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "242-257",
          "snippet": "int ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct role_datum *role;\n\tstruct user_datum *usrdatum;\n\n\tif (!c->role || c->role > p->p_roles.nprim)\n\t\treturn 0;\n\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\n\tif (!c->type || c->type > p->p_types.nprim)\n\t\treturn 0;\n\n\tif (c->role != OBJECT_R_VAL) {\n\t\t/*\n\t\t * Role must be authorized for the type.\n\t\t */\n\t\trole = p->role_val_to_struct[c->role - 1];\n\t\tif (!role || !ebitmap_get_bit(&role->types, c->type - 1))\n\t\t\t/* role may not be associated with type */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * User must be authorized for the role.\n\t\t */\n\t\tusrdatum = p->user_val_to_struct[c->user - 1];\n\t\tif (!usrdatum)\n\t\t\treturn 0;\n\n\t\tif (!ebitmap_get_bit(&usrdatum->roles, c->role - 1))\n\t\t\t/* user may not be associated with role */\n\t\t\treturn 0;\n\t}\n\n\tif (!mls_context_isvalid(p, c))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "policydb_type_isvalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "939-944",
    "snippet": "int policydb_type_isvalid(struct policydb *p, unsigned int type)\n{\n\tif (!type || type > p->p_types.nprim)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_type_isvalid(struct policydb *p, unsigned int type)\n{\n\tif (!type || type > p->p_types.nprim)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "policydb_role_isvalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "932-937",
    "snippet": "int policydb_role_isvalid(struct policydb *p, unsigned int role)\n{\n\tif (!role || role > p->p_roles.nprim)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_role_isvalid(struct policydb *p, unsigned int role)\n{\n\tif (!role || role > p->p_roles.nprim)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "policydb_class_isvalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "925-930",
    "snippet": "int policydb_class_isvalid(struct policydb *p, unsigned int class)\n{\n\tif (!class || class > p->p_classes.nprim)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_class_isvalid(struct policydb *p, unsigned int class)\n{\n\tif (!class || class > p->p_classes.nprim)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "policydb_load_isids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "893-923",
    "snippet": "int policydb_load_isids(struct policydb *p, struct sidtab *s)\n{\n\tstruct ocontext *head, *c;\n\tint rc;\n\n\trc = sidtab_init(s);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  out of memory on SID table init\\n\");\n\t\tgoto out;\n\t}\n\n\thead = p->ocontexts[OCON_ISID];\n\tfor (c = head; c; c = c->next) {\n\t\trc = -EINVAL;\n\t\tif (!c->context[0].user) {\n\t\t\tprintk(KERN_ERR \"SELinux:  SID %s was never defined.\\n\",\n\t\t\t\tc->u.name);\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = sidtab_insert(s, c->sid[0], &c->context[0]);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux:  unable to load initial SID %s.\\n\",\n\t\t\t\tc->u.name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  unable to load initial SID %s.\\n\"",
            "c->u.name"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_insert",
          "args": [
            "s",
            "c->sid[0]",
            "&c->context[0]"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "34-77",
          "snippet": "int sidtab_insert(struct sidtab *s, u32 sid, struct context *context)\n{\n\tint hvalue;\n\tstruct sidtab_node *prev, *cur, *newnode;\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\thvalue = SIDTAB_HASH(sid);\n\tprev = NULL;\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && sid == cur->sid)\n\t\treturn -EEXIST;\n\n\tnewnode = kmalloc(sizeof(*newnode), GFP_ATOMIC);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\n\tnewnode->sid = sid;\n\tif (context_cpy(&newnode->context, context)) {\n\t\tkfree(newnode);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\twmb();\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = s->htable[hvalue];\n\t\twmb();\n\t\ts->htable[hvalue] = newnode;\n\t}\n\n\ts->nel++;\n\tif (sid >= s->next_sid)\n\t\ts->next_sid = sid + 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_insert(struct sidtab *s, u32 sid, struct context *context)\n{\n\tint hvalue;\n\tstruct sidtab_node *prev, *cur, *newnode;\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\thvalue = SIDTAB_HASH(sid);\n\tprev = NULL;\n\tcur = s->htable[hvalue];\n\twhile (cur && sid > cur->sid) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && sid == cur->sid)\n\t\treturn -EEXIST;\n\n\tnewnode = kmalloc(sizeof(*newnode), GFP_ATOMIC);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\n\tnewnode->sid = sid;\n\tif (context_cpy(&newnode->context, context)) {\n\t\tkfree(newnode);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\twmb();\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = s->htable[hvalue];\n\t\twmb();\n\t\ts->htable[hvalue] = newnode;\n\t}\n\n\ts->nel++;\n\tif (sid >= s->next_sid)\n\t\ts->next_sid = sid + 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  out of memory on SID table init\\n\""
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sidtab_init",
          "args": [
            "s"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "18-32",
          "snippet": "int sidtab_init(struct sidtab *s)\n{\n\tint i;\n\n\ts->htable = kmalloc_array(SIDTAB_SIZE, sizeof(*s->htable), GFP_ATOMIC);\n\tif (!s->htable)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < SIDTAB_SIZE; i++)\n\t\ts->htable[i] = NULL;\n\ts->nel = 0;\n\ts->next_sid = 1;\n\ts->shutdown = 0;\n\tspin_lock_init(&s->lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint sidtab_init(struct sidtab *s)\n{\n\tint i;\n\n\ts->htable = kmalloc_array(SIDTAB_SIZE, sizeof(*s->htable), GFP_ATOMIC);\n\tif (!s->htable)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < SIDTAB_SIZE; i++)\n\t\ts->htable[i] = NULL;\n\ts->nel = 0;\n\ts->next_sid = 1;\n\ts->shutdown = 0;\n\tspin_lock_init(&s->lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_load_isids(struct policydb *p, struct sidtab *s)\n{\n\tstruct ocontext *head, *c;\n\tint rc;\n\n\trc = sidtab_init(s);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  out of memory on SID table init\\n\");\n\t\tgoto out;\n\t}\n\n\thead = p->ocontexts[OCON_ISID];\n\tfor (c = head; c; c = c->next) {\n\t\trc = -EINVAL;\n\t\tif (!c->context[0].user) {\n\t\t\tprintk(KERN_ERR \"SELinux:  SID %s was never defined.\\n\",\n\t\t\t\tc->u.name);\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = sidtab_insert(s, c->sid[0], &c->context[0]);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux:  unable to load initial SID %s.\\n\",\n\t\t\t\tc->u.name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "policydb_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "796-887",
    "snippet": "void policydb_destroy(struct policydb *p)\n{\n\tstruct ocontext *c, *ctmp;\n\tstruct genfs *g, *gtmp;\n\tint i;\n\tstruct role_allow *ra, *lra = NULL;\n\tstruct role_trans *tr, *ltr = NULL;\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tcond_resched();\n\t\thashtab_map(p->symtab[i].table, destroy_f[i], NULL);\n\t\thashtab_destroy(p->symtab[i].table);\n\t}\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tif (p->sym_val_to_name[i])\n\t\t\tflex_array_free(p->sym_val_to_name[i]);\n\t}\n\n\tkfree(p->class_val_to_struct);\n\tkfree(p->role_val_to_struct);\n\tkfree(p->user_val_to_struct);\n\tif (p->type_val_to_struct_array)\n\t\tflex_array_free(p->type_val_to_struct_array);\n\n\tavtab_destroy(&p->te_avtab);\n\n\tfor (i = 0; i < OCON_NUM; i++) {\n\t\tcond_resched();\n\t\tc = p->ocontexts[i];\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, i);\n\t\t}\n\t\tp->ocontexts[i] = NULL;\n\t}\n\n\tg = p->genfs;\n\twhile (g) {\n\t\tcond_resched();\n\t\tkfree(g->fstype);\n\t\tc = g->head;\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, OCON_FSUSE);\n\t\t}\n\t\tgtmp = g;\n\t\tg = g->next;\n\t\tkfree(gtmp);\n\t}\n\tp->genfs = NULL;\n\n\tcond_policydb_destroy(p);\n\n\tfor (tr = p->role_tr; tr; tr = tr->next) {\n\t\tcond_resched();\n\t\tkfree(ltr);\n\t\tltr = tr;\n\t}\n\tkfree(ltr);\n\n\tfor (ra = p->role_allow; ra; ra = ra->next) {\n\t\tcond_resched();\n\t\tkfree(lra);\n\t\tlra = ra;\n\t}\n\tkfree(lra);\n\n\thashtab_map(p->filename_trans, filenametr_destroy, NULL);\n\thashtab_destroy(p->filename_trans);\n\n\thashtab_map(p->range_tr, range_tr_destroy, NULL);\n\thashtab_destroy(p->range_tr);\n\n\tif (p->type_attr_map_array) {\n\t\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\t\tstruct ebitmap *e;\n\n\t\t\te = flex_array_get(p->type_attr_map_array, i);\n\t\t\tif (!e)\n\t\t\t\tcontinue;\n\t\t\tebitmap_destroy(e);\n\t\t}\n\t\tflex_array_free(p->type_attr_map_array);\n\t}\n\n\tebitmap_destroy(&p->filename_trans_ttypes);\n\tebitmap_destroy(&p->policycaps);\n\tebitmap_destroy(&p->permissive_map);\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int (*destroy_f[SYM_NUM]) (void *key, void *datum, void *datap) =\n{\n\tcommon_destroy,\n\tcls_destroy,\n\trole_destroy,\n\ttype_destroy,\n\tuser_destroy,\n\tcond_destroy_bool,\n\tsens_destroy,\n\tcat_destroy,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_destroy",
          "args": [
            "&p->permissive_map"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "327-344",
          "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flex_array_free",
          "args": [
            "p->type_attr_map_array"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get",
          "args": [
            "p->type_attr_map_array",
            "i"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashtab_destroy",
          "args": [
            "p->range_tr"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "99-121",
          "snippet": "void hashtab_destroy(struct hashtab *h)\n{\n\tu32 i;\n\tstruct hashtab_node *cur, *temp;\n\n\tif (!h)\n\t\treturn;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tkmem_cache_free(hashtab_node_cachep, temp);\n\t\t}\n\t\th->htable[i] = NULL;\n\t}\n\n\tkfree(h->htable);\n\th->htable = NULL;\n\n\tkfree(h);\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nvoid hashtab_destroy(struct hashtab *h)\n{\n\tu32 i;\n\tstruct hashtab_node *cur, *temp;\n\n\tif (!h)\n\t\treturn;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tkmem_cache_free(hashtab_node_cachep, temp);\n\t\t}\n\t\th->htable[i] = NULL;\n\t}\n\n\tkfree(h->htable);\n\th->htable = NULL;\n\n\tkfree(h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_map",
          "args": [
            "p->range_tr",
            "range_tr_destroy",
            "NULL"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "123-144",
          "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lra"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lra"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ltr"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ltr"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_policydb_destroy",
          "args": [
            "p"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "cond_policydb_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "169-174",
          "snippet": "void cond_policydb_destroy(struct policydb *p)\n{\n\tkfree(p->bool_val_to_struct);\n\tavtab_destroy(&p->te_cond_avtab);\n\tcond_list_destroy(p->cond_list);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nvoid cond_policydb_destroy(struct policydb *p)\n{\n\tkfree(p->bool_val_to_struct);\n\tavtab_destroy(&p->te_cond_avtab);\n\tcond_list_destroy(p->cond_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "gtmp"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocontext_destroy",
          "args": [
            "ctmp",
            "OCON_FSUSE"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "ocontext_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "780-791",
          "snippet": "static void ocontext_destroy(struct ocontext *c, int i)\n{\n\tif (!c)\n\t\treturn;\n\n\tcontext_destroy(&c->context[0]);\n\tcontext_destroy(&c->context[1]);\n\tif (i == OCON_ISID || i == OCON_FS ||\n\t    i == OCON_NETIF || i == OCON_FSUSE)\n\t\tkfree(c->u.name);\n\tkfree(c);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void ocontext_destroy(struct ocontext *c, int i)\n{\n\tif (!c)\n\t\treturn;\n\n\tcontext_destroy(&c->context[0]);\n\tcontext_destroy(&c->context[1]);\n\tif (i == OCON_ISID || i == OCON_FS ||\n\t    i == OCON_NETIF || i == OCON_FSUSE)\n\t\tkfree(c->u.name);\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "g->fstype"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avtab_destroy",
          "args": [
            "&p->te_avtab"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "279-302",
          "snippet": "void avtab_destroy(struct avtab *h)\n{\n\tint i;\n\tstruct avtab_node *cur, *temp;\n\n\tif (!h || !h->htable)\n\t\treturn;\n\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tif (temp->key.specified & AVTAB_XPERMS)\n\t\t\t\tkmem_cache_free(avtab_xperms_cachep,\n\t\t\t\t\t\ttemp->datum.u.xperms);\n\t\t\tkmem_cache_free(avtab_node_cachep, temp);\n\t\t}\n\t}\n\tflex_array_free(h->htable);\n\th->htable = NULL;\n\th->nslot = 0;\n\th->mask = 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avtab_node_cachep;",
            "static struct kmem_cache *avtab_xperms_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *avtab_node_cachep;\nstatic struct kmem_cache *avtab_xperms_cachep;\n\nvoid avtab_destroy(struct avtab *h)\n{\n\tint i;\n\tstruct avtab_node *cur, *temp;\n\n\tif (!h || !h->htable)\n\t\treturn;\n\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tif (temp->key.specified & AVTAB_XPERMS)\n\t\t\t\tkmem_cache_free(avtab_xperms_cachep,\n\t\t\t\t\t\ttemp->datum.u.xperms);\n\t\t\tkmem_cache_free(avtab_node_cachep, temp);\n\t\t}\n\t}\n\tflex_array_free(h->htable);\n\th->htable = NULL;\n\th->nslot = 0;\n\th->mask = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flex_array_free",
          "args": [
            "p->type_val_to_struct_array"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p->user_val_to_struct"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p->role_val_to_struct"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p->class_val_to_struct"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_free",
          "args": [
            "p->sym_val_to_name[i]"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int (*destroy_f[SYM_NUM]) (void *key, void *datum, void *datap) =\n{\n\tcommon_destroy,\n\tcls_destroy,\n\trole_destroy,\n\ttype_destroy,\n\tuser_destroy,\n\tcond_destroy_bool,\n\tsens_destroy,\n\tcat_destroy,\n};\n\nvoid policydb_destroy(struct policydb *p)\n{\n\tstruct ocontext *c, *ctmp;\n\tstruct genfs *g, *gtmp;\n\tint i;\n\tstruct role_allow *ra, *lra = NULL;\n\tstruct role_trans *tr, *ltr = NULL;\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tcond_resched();\n\t\thashtab_map(p->symtab[i].table, destroy_f[i], NULL);\n\t\thashtab_destroy(p->symtab[i].table);\n\t}\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tif (p->sym_val_to_name[i])\n\t\t\tflex_array_free(p->sym_val_to_name[i]);\n\t}\n\n\tkfree(p->class_val_to_struct);\n\tkfree(p->role_val_to_struct);\n\tkfree(p->user_val_to_struct);\n\tif (p->type_val_to_struct_array)\n\t\tflex_array_free(p->type_val_to_struct_array);\n\n\tavtab_destroy(&p->te_avtab);\n\n\tfor (i = 0; i < OCON_NUM; i++) {\n\t\tcond_resched();\n\t\tc = p->ocontexts[i];\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, i);\n\t\t}\n\t\tp->ocontexts[i] = NULL;\n\t}\n\n\tg = p->genfs;\n\twhile (g) {\n\t\tcond_resched();\n\t\tkfree(g->fstype);\n\t\tc = g->head;\n\t\twhile (c) {\n\t\t\tctmp = c;\n\t\t\tc = c->next;\n\t\t\tocontext_destroy(ctmp, OCON_FSUSE);\n\t\t}\n\t\tgtmp = g;\n\t\tg = g->next;\n\t\tkfree(gtmp);\n\t}\n\tp->genfs = NULL;\n\n\tcond_policydb_destroy(p);\n\n\tfor (tr = p->role_tr; tr; tr = tr->next) {\n\t\tcond_resched();\n\t\tkfree(ltr);\n\t\tltr = tr;\n\t}\n\tkfree(ltr);\n\n\tfor (ra = p->role_allow; ra; ra = ra->next) {\n\t\tcond_resched();\n\t\tkfree(lra);\n\t\tlra = ra;\n\t}\n\tkfree(lra);\n\n\thashtab_map(p->filename_trans, filenametr_destroy, NULL);\n\thashtab_destroy(p->filename_trans);\n\n\thashtab_map(p->range_tr, range_tr_destroy, NULL);\n\thashtab_destroy(p->range_tr);\n\n\tif (p->type_attr_map_array) {\n\t\tfor (i = 0; i < p->p_types.nprim; i++) {\n\t\t\tstruct ebitmap *e;\n\n\t\t\te = flex_array_get(p->type_attr_map_array, i);\n\t\t\tif (!e)\n\t\t\t\tcontinue;\n\t\t\tebitmap_destroy(e);\n\t\t}\n\t\tflex_array_free(p->type_attr_map_array);\n\t}\n\n\tebitmap_destroy(&p->filename_trans_ttypes);\n\tebitmap_destroy(&p->policycaps);\n\tebitmap_destroy(&p->permissive_map);\n}"
  },
  {
    "function_name": "ocontext_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "780-791",
    "snippet": "static void ocontext_destroy(struct ocontext *c, int i)\n{\n\tif (!c)\n\t\treturn;\n\n\tcontext_destroy(&c->context[0]);\n\tcontext_destroy(&c->context[1]);\n\tif (i == OCON_ISID || i == OCON_FS ||\n\t    i == OCON_NETIF || i == OCON_FSUSE)\n\t\tkfree(c->u.name);\n\tkfree(c);\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "c"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "c->u.name"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_destroy",
          "args": [
            "&c->context[1]"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "context_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "142-149",
          "snippet": "static inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline void context_destroy(struct context *c)\n{\n\tc->user = c->role = c->type = 0;\n\tkfree(c->str);\n\tc->str = NULL;\n\tc->len = 0;\n\tmls_context_destroy(c);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void ocontext_destroy(struct ocontext *c, int i)\n{\n\tif (!c)\n\t\treturn;\n\n\tcontext_destroy(&c->context[0]);\n\tcontext_destroy(&c->context[1]);\n\tif (i == OCON_ISID || i == OCON_FS ||\n\t    i == OCON_NETIF || i == OCON_FSUSE)\n\t\tkfree(c->u.name);\n\tkfree(c);\n}"
  },
  {
    "function_name": "range_tr_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "769-778",
    "snippet": "static int range_tr_destroy(void *key, void *datum, void *p)\n{\n\tstruct mls_range *rt = datum;\n\tkfree(key);\n\tebitmap_destroy(&rt->level[0].cat);\n\tebitmap_destroy(&rt->level[1].cat);\n\tkfree(datum);\n\tcond_resched();\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "datum"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_destroy",
          "args": [
            "&rt->level[1].cat"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "327-344",
          "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int range_tr_destroy(void *key, void *datum, void *p)\n{\n\tstruct mls_range *rt = datum;\n\tkfree(key);\n\tebitmap_destroy(&rt->level[0].cat);\n\tebitmap_destroy(&rt->level[1].cat);\n\tkfree(datum);\n\tcond_resched();\n\treturn 0;\n}"
  },
  {
    "function_name": "filenametr_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "759-767",
    "snippet": "static int filenametr_destroy(void *key, void *datum, void *p)\n{\n\tstruct filename_trans *ft = key;\n\tkfree(ft->name);\n\tkfree(key);\n\tkfree(datum);\n\tcond_resched();\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "datum"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ft->name"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int filenametr_destroy(void *key, void *datum, void *p)\n{\n\tstruct filename_trans *ft = key;\n\tkfree(ft->name);\n\tkfree(key);\n\tkfree(datum);\n\tcond_resched();\n\treturn 0;\n}"
  },
  {
    "function_name": "cat_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "740-745",
    "snippet": "static int cat_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "datum"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int cat_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}"
  },
  {
    "function_name": "sens_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "726-738",
    "snippet": "static int sens_destroy(void *key, void *datum, void *p)\n{\n\tstruct level_datum *levdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tlevdatum = datum;\n\t\tebitmap_destroy(&levdatum->level->cat);\n\t\tkfree(levdatum->level);\n\t}\n\tkfree(datum);\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "datum"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "levdatum->level"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_destroy",
          "args": [
            "&levdatum->level->cat"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "327-344",
          "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int sens_destroy(void *key, void *datum, void *p)\n{\n\tstruct level_datum *levdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tlevdatum = datum;\n\t\tebitmap_destroy(&levdatum->level->cat);\n\t\tkfree(levdatum->level);\n\t}\n\tkfree(datum);\n\treturn 0;\n}"
  },
  {
    "function_name": "user_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "710-724",
    "snippet": "static int user_destroy(void *key, void *datum, void *p)\n{\n\tstruct user_datum *usrdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tusrdatum = datum;\n\t\tebitmap_destroy(&usrdatum->roles);\n\t\tebitmap_destroy(&usrdatum->range.level[0].cat);\n\t\tebitmap_destroy(&usrdatum->range.level[1].cat);\n\t\tebitmap_destroy(&usrdatum->dfltlevel.cat);\n\t}\n\tkfree(datum);\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "datum"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_destroy",
          "args": [
            "&usrdatum->dfltlevel.cat"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "327-344",
          "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int user_destroy(void *key, void *datum, void *p)\n{\n\tstruct user_datum *usrdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tusrdatum = datum;\n\t\tebitmap_destroy(&usrdatum->roles);\n\t\tebitmap_destroy(&usrdatum->range.level[0].cat);\n\t\tebitmap_destroy(&usrdatum->range.level[1].cat);\n\t\tebitmap_destroy(&usrdatum->dfltlevel.cat);\n\t}\n\tkfree(datum);\n\treturn 0;\n}"
  },
  {
    "function_name": "type_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "703-708",
    "snippet": "static int type_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "datum"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int type_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}"
  },
  {
    "function_name": "role_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "689-701",
    "snippet": "static int role_destroy(void *key, void *datum, void *p)\n{\n\tstruct role_datum *role;\n\n\tkfree(key);\n\tif (datum) {\n\t\trole = datum;\n\t\tebitmap_destroy(&role->dominates);\n\t\tebitmap_destroy(&role->types);\n\t}\n\tkfree(datum);\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "datum"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_destroy",
          "args": [
            "&role->types"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "327-344",
          "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int role_destroy(void *key, void *datum, void *p)\n{\n\tstruct role_datum *role;\n\n\tkfree(key);\n\tif (datum) {\n\t\trole = datum;\n\t\tebitmap_destroy(&role->dominates);\n\t\tebitmap_destroy(&role->types);\n\t}\n\tkfree(datum);\n\treturn 0;\n}"
  },
  {
    "function_name": "cls_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "647-687",
    "snippet": "static int cls_destroy(void *key, void *datum, void *p)\n{\n\tstruct class_datum *cladatum;\n\tstruct constraint_node *constraint, *ctemp;\n\tstruct constraint_expr *e, *etmp;\n\n\tkfree(key);\n\tif (datum) {\n\t\tcladatum = datum;\n\t\thashtab_map(cladatum->permissions.table, perm_destroy, NULL);\n\t\thashtab_destroy(cladatum->permissions.table);\n\t\tconstraint = cladatum->constraints;\n\t\twhile (constraint) {\n\t\t\te = constraint->expr;\n\t\t\twhile (e) {\n\t\t\t\tetmp = e;\n\t\t\t\te = e->next;\n\t\t\t\tconstraint_expr_destroy(etmp);\n\t\t\t}\n\t\t\tctemp = constraint;\n\t\t\tconstraint = constraint->next;\n\t\t\tkfree(ctemp);\n\t\t}\n\n\t\tconstraint = cladatum->validatetrans;\n\t\twhile (constraint) {\n\t\t\te = constraint->expr;\n\t\t\twhile (e) {\n\t\t\t\tetmp = e;\n\t\t\t\te = e->next;\n\t\t\t\tconstraint_expr_destroy(etmp);\n\t\t\t}\n\t\t\tctemp = constraint;\n\t\t\tconstraint = constraint->next;\n\t\t\tkfree(ctemp);\n\t\t}\n\t\tkfree(cladatum->comkey);\n\t}\n\tkfree(datum);\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "datum"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cladatum->comkey"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctemp"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "constraint_expr_destroy",
          "args": [
            "etmp"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "constraint_expr_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "634-645",
          "snippet": "static void constraint_expr_destroy(struct constraint_expr *expr)\n{\n\tif (expr) {\n\t\tebitmap_destroy(&expr->names);\n\t\tif (expr->type_names) {\n\t\t\tebitmap_destroy(&expr->type_names->types);\n\t\t\tebitmap_destroy(&expr->type_names->negset);\n\t\t\tkfree(expr->type_names);\n\t\t}\n\t\tkfree(expr);\n\t}\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void constraint_expr_destroy(struct constraint_expr *expr)\n{\n\tif (expr) {\n\t\tebitmap_destroy(&expr->names);\n\t\tif (expr->type_names) {\n\t\t\tebitmap_destroy(&expr->type_names->types);\n\t\t\tebitmap_destroy(&expr->type_names->negset);\n\t\t\tkfree(expr->type_names);\n\t\t}\n\t\tkfree(expr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctemp"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashtab_destroy",
          "args": [
            "cladatum->permissions.table"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "99-121",
          "snippet": "void hashtab_destroy(struct hashtab *h)\n{\n\tu32 i;\n\tstruct hashtab_node *cur, *temp;\n\n\tif (!h)\n\t\treturn;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tkmem_cache_free(hashtab_node_cachep, temp);\n\t\t}\n\t\th->htable[i] = NULL;\n\t}\n\n\tkfree(h->htable);\n\th->htable = NULL;\n\n\tkfree(h);\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nvoid hashtab_destroy(struct hashtab *h)\n{\n\tu32 i;\n\tstruct hashtab_node *cur, *temp;\n\n\tif (!h)\n\t\treturn;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tkmem_cache_free(hashtab_node_cachep, temp);\n\t\t}\n\t\th->htable[i] = NULL;\n\t}\n\n\tkfree(h->htable);\n\th->htable = NULL;\n\n\tkfree(h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_map",
          "args": [
            "cladatum->permissions.table",
            "perm_destroy",
            "NULL"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "123-144",
          "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int cls_destroy(void *key, void *datum, void *p)\n{\n\tstruct class_datum *cladatum;\n\tstruct constraint_node *constraint, *ctemp;\n\tstruct constraint_expr *e, *etmp;\n\n\tkfree(key);\n\tif (datum) {\n\t\tcladatum = datum;\n\t\thashtab_map(cladatum->permissions.table, perm_destroy, NULL);\n\t\thashtab_destroy(cladatum->permissions.table);\n\t\tconstraint = cladatum->constraints;\n\t\twhile (constraint) {\n\t\t\te = constraint->expr;\n\t\t\twhile (e) {\n\t\t\t\tetmp = e;\n\t\t\t\te = e->next;\n\t\t\t\tconstraint_expr_destroy(etmp);\n\t\t\t}\n\t\t\tctemp = constraint;\n\t\t\tconstraint = constraint->next;\n\t\t\tkfree(ctemp);\n\t\t}\n\n\t\tconstraint = cladatum->validatetrans;\n\t\twhile (constraint) {\n\t\t\te = constraint->expr;\n\t\t\twhile (e) {\n\t\t\t\tetmp = e;\n\t\t\t\te = e->next;\n\t\t\t\tconstraint_expr_destroy(etmp);\n\t\t\t}\n\t\t\tctemp = constraint;\n\t\t\tconstraint = constraint->next;\n\t\t\tkfree(ctemp);\n\t\t}\n\t\tkfree(cladatum->comkey);\n\t}\n\tkfree(datum);\n\treturn 0;\n}"
  },
  {
    "function_name": "constraint_expr_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "634-645",
    "snippet": "static void constraint_expr_destroy(struct constraint_expr *expr)\n{\n\tif (expr) {\n\t\tebitmap_destroy(&expr->names);\n\t\tif (expr->type_names) {\n\t\t\tebitmap_destroy(&expr->type_names->types);\n\t\t\tebitmap_destroy(&expr->type_names->negset);\n\t\t\tkfree(expr->type_names);\n\t\t}\n\t\tkfree(expr);\n\t}\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "expr"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "expr->type_names"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_destroy",
          "args": [
            "&expr->type_names->negset"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "327-344",
          "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void constraint_expr_destroy(struct constraint_expr *expr)\n{\n\tif (expr) {\n\t\tebitmap_destroy(&expr->names);\n\t\tif (expr->type_names) {\n\t\t\tebitmap_destroy(&expr->type_names->types);\n\t\t\tebitmap_destroy(&expr->type_names->negset);\n\t\t\tkfree(expr->type_names);\n\t\t}\n\t\tkfree(expr);\n\t}\n}"
  },
  {
    "function_name": "common_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "620-632",
    "snippet": "static int common_destroy(void *key, void *datum, void *p)\n{\n\tstruct common_datum *comdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tcomdatum = datum;\n\t\thashtab_map(comdatum->permissions.table, perm_destroy, NULL);\n\t\thashtab_destroy(comdatum->permissions.table);\n\t}\n\tkfree(datum);\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "datum"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashtab_destroy",
          "args": [
            "comdatum->permissions.table"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "99-121",
          "snippet": "void hashtab_destroy(struct hashtab *h)\n{\n\tu32 i;\n\tstruct hashtab_node *cur, *temp;\n\n\tif (!h)\n\t\treturn;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tkmem_cache_free(hashtab_node_cachep, temp);\n\t\t}\n\t\th->htable[i] = NULL;\n\t}\n\n\tkfree(h->htable);\n\th->htable = NULL;\n\n\tkfree(h);\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nvoid hashtab_destroy(struct hashtab *h)\n{\n\tu32 i;\n\tstruct hashtab_node *cur, *temp;\n\n\tif (!h)\n\t\treturn;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tkmem_cache_free(hashtab_node_cachep, temp);\n\t\t}\n\t\th->htable[i] = NULL;\n\t}\n\n\tkfree(h->htable);\n\th->htable = NULL;\n\n\tkfree(h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_map",
          "args": [
            "comdatum->permissions.table",
            "perm_destroy",
            "NULL"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "123-144",
          "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int common_destroy(void *key, void *datum, void *p)\n{\n\tstruct common_datum *comdatum;\n\n\tkfree(key);\n\tif (datum) {\n\t\tcomdatum = datum;\n\t\thashtab_map(comdatum->permissions.table, perm_destroy, NULL);\n\t\thashtab_destroy(comdatum->permissions.table);\n\t}\n\tkfree(datum);\n\treturn 0;\n}"
  },
  {
    "function_name": "perm_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "613-618",
    "snippet": "static int perm_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "datum"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int perm_destroy(void *key, void *datum, void *p)\n{\n\tkfree(key);\n\tkfree(datum);\n\treturn 0;\n}"
  },
  {
    "function_name": "policydb_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "532-605",
    "snippet": "static int policydb_index(struct policydb *p)\n{\n\tint i, rc;\n\n\tprintk(KERN_DEBUG \"SELinux:  %d users, %d roles, %d types, %d bools\",\n\t       p->p_users.nprim, p->p_roles.nprim, p->p_types.nprim, p->p_bools.nprim);\n\tif (p->mls_enabled)\n\t\tprintk(KERN_CONT \", %d sens, %d cats\", p->p_levels.nprim,\n\t\t       p->p_cats.nprim);\n\tprintk(KERN_CONT \"\\n\");\n\n\tprintk(KERN_DEBUG \"SELinux:  %d classes, %d rules\\n\",\n\t       p->p_classes.nprim, p->te_avtab.nel);\n\n#ifdef DEBUG_HASHES\n\tavtab_hash_eval(&p->te_avtab, \"rules\");\n\tsymtab_hash_eval(p->symtab);\n#endif\n\n\tp->class_val_to_struct = kcalloc(p->p_classes.nprim,\n\t\t\t\t\t sizeof(*p->class_val_to_struct),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!p->class_val_to_struct)\n\t\treturn -ENOMEM;\n\n\tp->role_val_to_struct = kcalloc(p->p_roles.nprim,\n\t\t\t\t\tsizeof(*p->role_val_to_struct),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!p->role_val_to_struct)\n\t\treturn -ENOMEM;\n\n\tp->user_val_to_struct = kcalloc(p->p_users.nprim,\n\t\t\t\t\tsizeof(*p->user_val_to_struct),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!p->user_val_to_struct)\n\t\treturn -ENOMEM;\n\n\t/* Yes, I want the sizeof the pointer, not the structure */\n\tp->type_val_to_struct_array = flex_array_alloc(sizeof(struct type_datum *),\n\t\t\t\t\t\t       p->p_types.nprim,\n\t\t\t\t\t\t       GFP_KERNEL | __GFP_ZERO);\n\tif (!p->type_val_to_struct_array)\n\t\treturn -ENOMEM;\n\n\trc = flex_array_prealloc(p->type_val_to_struct_array, 0,\n\t\t\t\t p->p_types.nprim, GFP_KERNEL | __GFP_ZERO);\n\tif (rc)\n\t\tgoto out;\n\n\trc = cond_init_bool_indexes(p);\n\tif (rc)\n\t\tgoto out;\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tp->sym_val_to_name[i] = flex_array_alloc(sizeof(char *),\n\t\t\t\t\t\t\t p->symtab[i].nprim,\n\t\t\t\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\t\tif (!p->sym_val_to_name[i])\n\t\t\treturn -ENOMEM;\n\n\t\trc = flex_array_prealloc(p->sym_val_to_name[i],\n\t\t\t\t\t 0, p->symtab[i].nprim,\n\t\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = hashtab_map(p->symtab[i].table, index_f[i], p);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int (*index_f[SYM_NUM]) (void *key, void *datum, void *datap) =\n{\n\tcommon_index,\n\tclass_index,\n\trole_index,\n\ttype_index,\n\tuser_index,\n\tcond_index_bool,\n\tsens_index,\n\tcat_index,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashtab_map",
          "args": [
            "p->symtab[i].table",
            "index_f[i]",
            "p"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "123-144",
          "snippet": "int hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint hashtab_map(struct hashtab *h,\n\t\tint (*apply)(void *k, void *d, void *args),\n\t\tvoid *args)\n{\n\tu32 i;\n\tint ret;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn 0;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\tret = apply(cur->key, cur->datum, args);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flex_array_prealloc",
          "args": [
            "p->sym_val_to_name[i]",
            "0",
            "p->symtab[i].nprim",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_alloc",
          "args": [
            "sizeof(char *)",
            "p->symtab[i].nprim",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_init_bool_indexes",
          "args": [
            "p"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "cond_init_bool_indexes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "176-185",
          "snippet": "int cond_init_bool_indexes(struct policydb *p)\n{\n\tkfree(p->bool_val_to_struct);\n\tp->bool_val_to_struct = kmalloc_array(p->p_bools.nprim,\n\t\t\t\t\t      sizeof(*p->bool_val_to_struct),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!p->bool_val_to_struct)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint cond_init_bool_indexes(struct policydb *p)\n{\n\tkfree(p->bool_val_to_struct);\n\tp->bool_val_to_struct = kmalloc_array(p->p_bools.nprim,\n\t\t\t\t\t      sizeof(*p->bool_val_to_struct),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!p->bool_val_to_struct)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flex_array_prealloc",
          "args": [
            "p->type_val_to_struct_array",
            "0",
            "p->p_types.nprim",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_alloc",
          "args": [
            "sizeof(struct type_datum *)",
            "p->p_types.nprim",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "p->p_users.nprim",
            "sizeof(*p->user_val_to_struct)",
            "GFP_KERNEL"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "p->p_roles.nprim",
            "sizeof(*p->role_val_to_struct)",
            "GFP_KERNEL"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "p->p_classes.nprim",
            "sizeof(*p->class_val_to_struct)",
            "GFP_KERNEL"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symtab_hash_eval",
          "args": [
            "p->symtab"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "symtab_hash_eval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "512-518",
          "snippet": "static void symtab_hash_eval(struct symtab *s)\n{\n\tint i;\n\n\tfor (i = 0; i < SYM_NUM; i++)\n\t\thash_eval(s[i].table, symtab_name[i]);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void symtab_hash_eval(struct symtab *s)\n{\n\tint i;\n\n\tfor (i = 0; i < SYM_NUM; i++)\n\t\thash_eval(s[i].table, symtab_name[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avtab_hash_eval",
          "args": [
            "&p->te_avtab",
            "\"rules\""
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_hash_eval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "346-375",
          "snippet": "void avtab_hash_eval(struct avtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tunsigned long long chain2_len_sum;\n\tstruct avtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tchain2_len_sum = 0;\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain2_len_sum += chain_len * chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\",\n\t       tag, h->nel, slots_used, h->nslot, max_chain_len,\n\t       chain2_len_sum);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid avtab_hash_eval(struct avtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tunsigned long long chain2_len_sum;\n\tstruct avtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tchain2_len_sum = 0;\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain2_len_sum += chain_len * chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\",\n\t       tag, h->nel, slots_used, h->nslot, max_chain_len,\n\t       chain2_len_sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"SELinux:  %d classes, %d rules\\n\"",
            "p->p_classes.nprim",
            "p->te_avtab.nel"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"\\n\""
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \", %d sens, %d cats\"",
            "p->p_levels.nprim",
            "p->p_cats.nprim"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"SELinux:  %d users, %d roles, %d types, %d bools\"",
            "p->p_users.nprim",
            "p->p_roles.nprim",
            "p->p_types.nprim",
            "p->p_bools.nprim"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int (*index_f[SYM_NUM]) (void *key, void *datum, void *datap) =\n{\n\tcommon_index,\n\tclass_index,\n\trole_index,\n\ttype_index,\n\tuser_index,\n\tcond_index_bool,\n\tsens_index,\n\tcat_index,\n};\n\nstatic int policydb_index(struct policydb *p)\n{\n\tint i, rc;\n\n\tprintk(KERN_DEBUG \"SELinux:  %d users, %d roles, %d types, %d bools\",\n\t       p->p_users.nprim, p->p_roles.nprim, p->p_types.nprim, p->p_bools.nprim);\n\tif (p->mls_enabled)\n\t\tprintk(KERN_CONT \", %d sens, %d cats\", p->p_levels.nprim,\n\t\t       p->p_cats.nprim);\n\tprintk(KERN_CONT \"\\n\");\n\n\tprintk(KERN_DEBUG \"SELinux:  %d classes, %d rules\\n\",\n\t       p->p_classes.nprim, p->te_avtab.nel);\n\n#ifdef DEBUG_HASHES\n\tavtab_hash_eval(&p->te_avtab, \"rules\");\n\tsymtab_hash_eval(p->symtab);\n#endif\n\n\tp->class_val_to_struct = kcalloc(p->p_classes.nprim,\n\t\t\t\t\t sizeof(*p->class_val_to_struct),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!p->class_val_to_struct)\n\t\treturn -ENOMEM;\n\n\tp->role_val_to_struct = kcalloc(p->p_roles.nprim,\n\t\t\t\t\tsizeof(*p->role_val_to_struct),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!p->role_val_to_struct)\n\t\treturn -ENOMEM;\n\n\tp->user_val_to_struct = kcalloc(p->p_users.nprim,\n\t\t\t\t\tsizeof(*p->user_val_to_struct),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!p->user_val_to_struct)\n\t\treturn -ENOMEM;\n\n\t/* Yes, I want the sizeof the pointer, not the structure */\n\tp->type_val_to_struct_array = flex_array_alloc(sizeof(struct type_datum *),\n\t\t\t\t\t\t       p->p_types.nprim,\n\t\t\t\t\t\t       GFP_KERNEL | __GFP_ZERO);\n\tif (!p->type_val_to_struct_array)\n\t\treturn -ENOMEM;\n\n\trc = flex_array_prealloc(p->type_val_to_struct_array, 0,\n\t\t\t\t p->p_types.nprim, GFP_KERNEL | __GFP_ZERO);\n\tif (rc)\n\t\tgoto out;\n\n\trc = cond_init_bool_indexes(p);\n\tif (rc)\n\t\tgoto out;\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\tp->sym_val_to_name[i] = flex_array_alloc(sizeof(char *),\n\t\t\t\t\t\t\t p->symtab[i].nprim,\n\t\t\t\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\t\tif (!p->sym_val_to_name[i])\n\t\t\treturn -ENOMEM;\n\n\t\trc = flex_array_prealloc(p->sym_val_to_name[i],\n\t\t\t\t\t 0, p->symtab[i].nprim,\n\t\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = hashtab_map(p->symtab[i].table, index_f[i], p);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "hash_eval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "521-523",
    "snippet": "static inline void hash_eval(struct hashtab *h, char *hash_name)\n{\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic inline void hash_eval(struct hashtab *h, char *hash_name)\n{\n}"
  },
  {
    "function_name": "symtab_hash_eval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "512-518",
    "snippet": "static void symtab_hash_eval(struct symtab *s)\n{\n\tint i;\n\n\tfor (i = 0; i < SYM_NUM; i++)\n\t\thash_eval(s[i].table, symtab_name[i]);\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_eval",
          "args": [
            "s[i].table",
            "symtab_name[i]"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "hash_eval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "521-523",
          "snippet": "static inline void hash_eval(struct hashtab *h, char *hash_name)\n{\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic inline void hash_eval(struct hashtab *h, char *hash_name)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void symtab_hash_eval(struct symtab *s)\n{\n\tint i;\n\n\tfor (i = 0; i < SYM_NUM; i++)\n\t\thash_eval(s[i].table, symtab_name[i]);\n}"
  },
  {
    "function_name": "hash_eval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "502-510",
    "snippet": "static void hash_eval(struct hashtab *h, const char *hash_name)\n{\n\tstruct hashtab_info info;\n\n\thashtab_stat(h, &info);\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d\\n\", hash_name, h->nel,\n\t       info.slots_used, h->size, info.max_chain_len);\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d\\n\"",
            "hash_name",
            "h->nel",
            "info.slots_used",
            "h->size",
            "info.max_chain_len"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashtab_stat",
          "args": [
            "h",
            "&info"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "147-171",
          "snippet": "void hashtab_stat(struct hashtab *h, struct hashtab_info *info)\n{\n\tu32 i, chain_len, slots_used, max_chain_len;\n\tstruct hashtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\tinfo->slots_used = slots_used;\n\tinfo->max_chain_len = max_chain_len;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid hashtab_stat(struct hashtab *h, struct hashtab_info *info)\n{\n\tu32 i, chain_len, slots_used, max_chain_len;\n\tstruct hashtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t}\n\t}\n\n\tinfo->slots_used = slots_used;\n\tinfo->max_chain_len = max_chain_len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void hash_eval(struct hashtab *h, const char *hash_name)\n{\n\tstruct hashtab_info info;\n\n\thashtab_stat(h, &info);\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d\\n\", hash_name, h->nel,\n\t       info.slots_used, h->size, info.max_chain_len);\n}"
  },
  {
    "function_name": "cat_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "468-487",
    "snippet": "static int cat_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct cat_datum *catdatum;\n\tstruct flex_array *fa;\n\n\tcatdatum = datum;\n\tp = datap;\n\n\tif (!catdatum->isalias) {\n\t\tif (!catdatum->value || catdatum->value > p->p_cats.nprim)\n\t\t\treturn -EINVAL;\n\t\tfa = p->sym_val_to_name[SYM_CATS];\n\t\tif (flex_array_put_ptr(fa, catdatum->value - 1, key,\n\t\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\t\tBUG();\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_put_ptr",
          "args": [
            "fa",
            "catdatum->value - 1",
            "key",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int cat_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct cat_datum *catdatum;\n\tstruct flex_array *fa;\n\n\tcatdatum = datum;\n\tp = datap;\n\n\tif (!catdatum->isalias) {\n\t\tif (!catdatum->value || catdatum->value > p->p_cats.nprim)\n\t\t\treturn -EINVAL;\n\t\tfa = p->sym_val_to_name[SYM_CATS];\n\t\tif (flex_array_put_ptr(fa, catdatum->value - 1, key,\n\t\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\t\tBUG();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sens_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "446-466",
    "snippet": "static int sens_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct level_datum *levdatum;\n\tstruct flex_array *fa;\n\n\tlevdatum = datum;\n\tp = datap;\n\n\tif (!levdatum->isalias) {\n\t\tif (!levdatum->level->sens ||\n\t\t    levdatum->level->sens > p->p_levels.nprim)\n\t\t\treturn -EINVAL;\n\t\tfa = p->sym_val_to_name[SYM_LEVELS];\n\t\tif (flex_array_put_ptr(fa, levdatum->level->sens - 1, key,\n\t\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\t\tBUG();\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_put_ptr",
          "args": [
            "fa",
            "levdatum->level->sens - 1",
            "key",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int sens_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct level_datum *levdatum;\n\tstruct flex_array *fa;\n\n\tlevdatum = datum;\n\tp = datap;\n\n\tif (!levdatum->isalias) {\n\t\tif (!levdatum->level->sens ||\n\t\t    levdatum->level->sens > p->p_levels.nprim)\n\t\t\treturn -EINVAL;\n\t\tfa = p->sym_val_to_name[SYM_LEVELS];\n\t\tif (flex_array_put_ptr(fa, levdatum->level->sens - 1, key,\n\t\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\t\tBUG();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "user_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "425-444",
    "snippet": "static int user_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct user_datum *usrdatum;\n\tstruct flex_array *fa;\n\n\tusrdatum = datum;\n\tp = datap;\n\tif (!usrdatum->value\n\t    || usrdatum->value > p->p_users.nprim\n\t    || usrdatum->bounds > p->p_users.nprim)\n\t\treturn -EINVAL;\n\n\tfa = p->sym_val_to_name[SYM_USERS];\n\tif (flex_array_put_ptr(fa, usrdatum->value - 1, key,\n\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\tBUG();\n\tp->user_val_to_struct[usrdatum->value - 1] = usrdatum;\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_put_ptr",
          "args": [
            "fa",
            "usrdatum->value - 1",
            "key",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int user_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct user_datum *usrdatum;\n\tstruct flex_array *fa;\n\n\tusrdatum = datum;\n\tp = datap;\n\tif (!usrdatum->value\n\t    || usrdatum->value > p->p_users.nprim\n\t    || usrdatum->bounds > p->p_users.nprim)\n\t\treturn -EINVAL;\n\n\tfa = p->sym_val_to_name[SYM_USERS];\n\tif (flex_array_put_ptr(fa, usrdatum->value - 1, key,\n\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\tBUG();\n\tp->user_val_to_struct[usrdatum->value - 1] = usrdatum;\n\treturn 0;\n}"
  },
  {
    "function_name": "type_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "397-423",
    "snippet": "static int type_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct type_datum *typdatum;\n\tstruct flex_array *fa;\n\n\ttypdatum = datum;\n\tp = datap;\n\n\tif (typdatum->primary) {\n\t\tif (!typdatum->value\n\t\t    || typdatum->value > p->p_types.nprim\n\t\t    || typdatum->bounds > p->p_types.nprim)\n\t\t\treturn -EINVAL;\n\t\tfa = p->sym_val_to_name[SYM_TYPES];\n\t\tif (flex_array_put_ptr(fa, typdatum->value - 1, key,\n\t\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\t\tBUG();\n\n\t\tfa = p->type_val_to_struct_array;\n\t\tif (flex_array_put_ptr(fa, typdatum->value - 1, typdatum,\n\t\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\t\tBUG();\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_put_ptr",
          "args": [
            "fa",
            "typdatum->value - 1",
            "typdatum",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_put_ptr",
          "args": [
            "fa",
            "typdatum->value - 1",
            "key",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int type_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct type_datum *typdatum;\n\tstruct flex_array *fa;\n\n\ttypdatum = datum;\n\tp = datap;\n\n\tif (typdatum->primary) {\n\t\tif (!typdatum->value\n\t\t    || typdatum->value > p->p_types.nprim\n\t\t    || typdatum->bounds > p->p_types.nprim)\n\t\t\treturn -EINVAL;\n\t\tfa = p->sym_val_to_name[SYM_TYPES];\n\t\tif (flex_array_put_ptr(fa, typdatum->value - 1, key,\n\t\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\t\tBUG();\n\n\t\tfa = p->type_val_to_struct_array;\n\t\tif (flex_array_put_ptr(fa, typdatum->value - 1, typdatum,\n\t\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\t\tBUG();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "role_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "376-395",
    "snippet": "static int role_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct role_datum *role;\n\tstruct flex_array *fa;\n\n\trole = datum;\n\tp = datap;\n\tif (!role->value\n\t    || role->value > p->p_roles.nprim\n\t    || role->bounds > p->p_roles.nprim)\n\t\treturn -EINVAL;\n\n\tfa = p->sym_val_to_name[SYM_ROLES];\n\tif (flex_array_put_ptr(fa, role->value - 1, key,\n\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\tBUG();\n\tp->role_val_to_struct[role->value - 1] = role;\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_put_ptr",
          "args": [
            "fa",
            "role->value - 1",
            "key",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int role_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct role_datum *role;\n\tstruct flex_array *fa;\n\n\trole = datum;\n\tp = datap;\n\tif (!role->value\n\t    || role->value > p->p_roles.nprim\n\t    || role->bounds > p->p_roles.nprim)\n\t\treturn -EINVAL;\n\n\tfa = p->sym_val_to_name[SYM_ROLES];\n\tif (flex_array_put_ptr(fa, role->value - 1, key,\n\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\tBUG();\n\tp->role_val_to_struct[role->value - 1] = role;\n\treturn 0;\n}"
  },
  {
    "function_name": "class_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "358-374",
    "snippet": "static int class_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct class_datum *cladatum;\n\tstruct flex_array *fa;\n\n\tcladatum = datum;\n\tp = datap;\n\tif (!cladatum->value || cladatum->value > p->p_classes.nprim)\n\t\treturn -EINVAL;\n\tfa = p->sym_val_to_name[SYM_CLASSES];\n\tif (flex_array_put_ptr(fa, cladatum->value - 1, key,\n\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\tBUG();\n\tp->class_val_to_struct[cladatum->value - 1] = cladatum;\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_put_ptr",
          "args": [
            "fa",
            "cladatum->value - 1",
            "key",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int class_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct class_datum *cladatum;\n\tstruct flex_array *fa;\n\n\tcladatum = datum;\n\tp = datap;\n\tif (!cladatum->value || cladatum->value > p->p_classes.nprim)\n\t\treturn -EINVAL;\n\tfa = p->sym_val_to_name[SYM_CLASSES];\n\tif (flex_array_put_ptr(fa, cladatum->value - 1, key,\n\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\tBUG();\n\tp->class_val_to_struct[cladatum->value - 1] = cladatum;\n\treturn 0;\n}"
  },
  {
    "function_name": "common_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "340-356",
    "snippet": "static int common_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct common_datum *comdatum;\n\tstruct flex_array *fa;\n\n\tcomdatum = datum;\n\tp = datap;\n\tif (!comdatum->value || comdatum->value > p->p_commons.nprim)\n\t\treturn -EINVAL;\n\n\tfa = p->sym_val_to_name[SYM_COMMONS];\n\tif (flex_array_put_ptr(fa, comdatum->value - 1, key,\n\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\tBUG();\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_put_ptr",
          "args": [
            "fa",
            "comdatum->value - 1",
            "key",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int common_index(void *key, void *datum, void *datap)\n{\n\tstruct policydb *p;\n\tstruct common_datum *comdatum;\n\tstruct flex_array *fa;\n\n\tcomdatum = datum;\n\tp = datap;\n\tif (!comdatum->value || comdatum->value > p->p_commons.nprim)\n\t\treturn -EINVAL;\n\n\tfa = p->sym_val_to_name[SYM_COMMONS];\n\tif (flex_array_put_ptr(fa, comdatum->value - 1, key,\n\t\t\t       GFP_KERNEL | __GFP_ZERO))\n\t\tBUG();\n\treturn 0;\n}"
  },
  {
    "function_name": "policydb_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "281-328",
    "snippet": "static int policydb_init(struct policydb *p)\n{\n\tint i, rc;\n\n\tmemset(p, 0, sizeof(*p));\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\trc = symtab_init(&p->symtab[i], symtab_sizes[i]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = avtab_init(&p->te_avtab);\n\tif (rc)\n\t\tgoto out;\n\n\trc = roles_init(p);\n\tif (rc)\n\t\tgoto out;\n\n\trc = cond_policydb_init(p);\n\tif (rc)\n\t\tgoto out;\n\n\tp->filename_trans = hashtab_create(filenametr_hash, filenametr_cmp, (1 << 10));\n\tif (!p->filename_trans) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tp->range_tr = hashtab_create(rangetr_hash, rangetr_cmp, 256);\n\tif (!p->range_tr) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tebitmap_init(&p->filename_trans_ttypes);\n\tebitmap_init(&p->policycaps);\n\tebitmap_init(&p->permissive_map);\n\n\treturn 0;\nout:\n\thashtab_destroy(p->filename_trans);\n\thashtab_destroy(p->range_tr);\n\tfor (i = 0; i < SYM_NUM; i++)\n\t\thashtab_destroy(p->symtab[i].table);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int symtab_sizes[SYM_NUM] = {\n\t2,\n\t32,\n\t16,\n\t512,\n\t128,\n\t16,\n\t16,\n\t16,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashtab_destroy",
          "args": [
            "p->symtab[i].table"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "99-121",
          "snippet": "void hashtab_destroy(struct hashtab *h)\n{\n\tu32 i;\n\tstruct hashtab_node *cur, *temp;\n\n\tif (!h)\n\t\treturn;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tkmem_cache_free(hashtab_node_cachep, temp);\n\t\t}\n\t\th->htable[i] = NULL;\n\t}\n\n\tkfree(h->htable);\n\th->htable = NULL;\n\n\tkfree(h);\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nvoid hashtab_destroy(struct hashtab *h)\n{\n\tu32 i;\n\tstruct hashtab_node *cur, *temp;\n\n\tif (!h)\n\t\treturn;\n\n\tfor (i = 0; i < h->size; i++) {\n\t\tcur = h->htable[i];\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tkmem_cache_free(hashtab_node_cachep, temp);\n\t\t}\n\t\th->htable[i] = NULL;\n\t}\n\n\tkfree(h->htable);\n\th->htable = NULL;\n\n\tkfree(h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_init",
          "args": [
            "&p->permissive_map"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.h",
          "lines": "60-63",
          "snippet": "static inline void ebitmap_init(struct ebitmap *e)\n{\n\tmemset(e, 0, sizeof(*e));\n}",
          "includes": [
            "#include <net/netlabel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/netlabel.h>\n\nstatic inline void ebitmap_init(struct ebitmap *e)\n{\n\tmemset(e, 0, sizeof(*e));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_create",
          "args": [
            "rangetr_hash",
            "rangetr_cmp",
            "256"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "15-40",
          "snippet": "struct hashtab *hashtab_create(u32 (*hash_value)(struct hashtab *h, const void *key),\n\t\t\t       int (*keycmp)(struct hashtab *h, const void *key1, const void *key2),\n\t\t\t       u32 size)\n{\n\tstruct hashtab *p;\n\tu32 i;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn p;\n\n\tp->size = size;\n\tp->nel = 0;\n\tp->hash_value = hash_value;\n\tp->keycmp = keycmp;\n\tp->htable = kmalloc_array(size, sizeof(*p->htable), GFP_KERNEL);\n\tif (!p->htable) {\n\t\tkfree(p);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++)\n\t\tp->htable[i] = NULL;\n\n\treturn p;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct hashtab *hashtab_create(u32 (*hash_value)(struct hashtab *h, const void *key),\n\t\t\t       int (*keycmp)(struct hashtab *h, const void *key1, const void *key2),\n\t\t\t       u32 size)\n{\n\tstruct hashtab *p;\n\tu32 i;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn p;\n\n\tp->size = size;\n\tp->nel = 0;\n\tp->hash_value = hash_value;\n\tp->keycmp = keycmp;\n\tp->htable = kmalloc_array(size, sizeof(*p->htable), GFP_KERNEL);\n\tif (!p->htable) {\n\t\tkfree(p);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++)\n\t\tp->htable[i] = NULL;\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_policydb_init",
          "args": [
            "p"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "cond_policydb_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/conditional.c",
          "lines": "119-131",
          "snippet": "int cond_policydb_init(struct policydb *p)\n{\n\tint rc;\n\n\tp->bool_val_to_struct = NULL;\n\tp->cond_list = NULL;\n\n\trc = avtab_init(&p->te_cond_avtab);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"conditional.h\"",
            "#include \"security.h\"",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"conditional.h\"\n#include \"security.h\"\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nint cond_policydb_init(struct policydb *p)\n{\n\tint rc;\n\n\tp->bool_val_to_struct = NULL;\n\tp->cond_list = NULL;\n\n\trc = avtab_init(&p->te_cond_avtab);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roles_init",
          "args": [
            "p"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "roles_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "185-214",
          "snippet": "static int roles_init(struct policydb *p)\n{\n\tchar *key = NULL;\n\tint rc;\n\tstruct role_datum *role;\n\n\trole = kzalloc(sizeof(*role), GFP_KERNEL);\n\tif (!role)\n\t\treturn -ENOMEM;\n\n\trc = -EINVAL;\n\trole->value = ++p->p_roles.nprim;\n\tif (role->value != OBJECT_R_VAL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tkey = kstrdup(OBJECT_R, GFP_KERNEL);\n\tif (!key)\n\t\tgoto out;\n\n\trc = hashtab_insert(p->p_roles.table, key, role);\n\tif (rc)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tkfree(key);\n\tkfree(role);\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int roles_init(struct policydb *p)\n{\n\tchar *key = NULL;\n\tint rc;\n\tstruct role_datum *role;\n\n\trole = kzalloc(sizeof(*role), GFP_KERNEL);\n\tif (!role)\n\t\treturn -ENOMEM;\n\n\trc = -EINVAL;\n\trole->value = ++p->p_roles.nprim;\n\tif (role->value != OBJECT_R_VAL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tkey = kstrdup(OBJECT_R, GFP_KERNEL);\n\tif (!key)\n\t\tgoto out;\n\n\trc = hashtab_insert(p->p_roles.table, key, role);\n\tif (rc)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tkfree(key);\n\tkfree(role);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avtab_init",
          "args": [
            "&p->te_avtab"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "304-309",
          "snippet": "int avtab_init(struct avtab *h)\n{\n\th->htable = NULL;\n\th->nel = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint avtab_init(struct avtab *h)\n{\n\th->htable = NULL;\n\th->nel = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "symtab_init",
          "args": [
            "&p->symtab[i]",
            "symtab_sizes[i]"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "symtab_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/symtab.c",
          "lines": "36-43",
          "snippet": "int symtab_init(struct symtab *s, unsigned int size)\n{\n\ts->table = hashtab_create(symhash, symcmp, size);\n\tif (!s->table)\n\t\treturn -ENOMEM;\n\ts->nprim = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"symtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"symtab.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nint symtab_init(struct symtab *s, unsigned int size)\n{\n\ts->table = hashtab_create(symhash, symcmp, size);\n\tif (!s->table)\n\t\treturn -ENOMEM;\n\ts->nprim = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p",
            "0",
            "sizeof(*p)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic unsigned int symtab_sizes[SYM_NUM] = {\n\t2,\n\t32,\n\t16,\n\t512,\n\t128,\n\t16,\n\t16,\n\t16,\n};\n\nstatic int policydb_init(struct policydb *p)\n{\n\tint i, rc;\n\n\tmemset(p, 0, sizeof(*p));\n\n\tfor (i = 0; i < SYM_NUM; i++) {\n\t\trc = symtab_init(&p->symtab[i], symtab_sizes[i]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = avtab_init(&p->te_avtab);\n\tif (rc)\n\t\tgoto out;\n\n\trc = roles_init(p);\n\tif (rc)\n\t\tgoto out;\n\n\trc = cond_policydb_init(p);\n\tif (rc)\n\t\tgoto out;\n\n\tp->filename_trans = hashtab_create(filenametr_hash, filenametr_cmp, (1 << 10));\n\tif (!p->filename_trans) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tp->range_tr = hashtab_create(rangetr_hash, rangetr_cmp, 256);\n\tif (!p->range_tr) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tebitmap_init(&p->filename_trans_ttypes);\n\tebitmap_init(&p->policycaps);\n\tebitmap_init(&p->permissive_map);\n\n\treturn 0;\nout:\n\thashtab_destroy(p->filename_trans);\n\thashtab_destroy(p->range_tr);\n\tfor (i = 0; i < SYM_NUM; i++)\n\t\thashtab_destroy(p->symtab[i].table);\n\treturn rc;\n}"
  },
  {
    "function_name": "rangetr_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "260-276",
    "snippet": "static int rangetr_cmp(struct hashtab *h, const void *k1, const void *k2)\n{\n\tconst struct range_trans *key1 = k1, *key2 = k2;\n\tint v;\n\n\tv = key1->source_type - key2->source_type;\n\tif (v)\n\t\treturn v;\n\n\tv = key1->target_type - key2->target_type;\n\tif (v)\n\t\treturn v;\n\n\tv = key1->target_class - key2->target_class;\n\n\treturn v;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int rangetr_cmp(struct hashtab *h, const void *k1, const void *k2)\n{\n\tconst struct range_trans *key1 = k1, *key2 = k2;\n\tint v;\n\n\tv = key1->source_type - key2->source_type;\n\tif (v)\n\t\treturn v;\n\n\tv = key1->target_type - key2->target_type;\n\tif (v)\n\t\treturn v;\n\n\tv = key1->target_class - key2->target_class;\n\n\treturn v;\n}"
  },
  {
    "function_name": "rangetr_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "253-258",
    "snippet": "static u32 rangetr_hash(struct hashtab *h, const void *k)\n{\n\tconst struct range_trans *key = k;\n\treturn (key->source_type + (key->target_type << 3) +\n\t\t(key->target_class << 5)) & (h->size - 1);\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic u32 rangetr_hash(struct hashtab *h, const void *k)\n{\n\tconst struct range_trans *key = k;\n\treturn (key->source_type + (key->target_type << 3) +\n\t\t(key->target_class << 5)) & (h->size - 1);\n}"
  },
  {
    "function_name": "filenametr_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "231-251",
    "snippet": "static int filenametr_cmp(struct hashtab *h, const void *k1, const void *k2)\n{\n\tconst struct filename_trans *ft1 = k1;\n\tconst struct filename_trans *ft2 = k2;\n\tint v;\n\n\tv = ft1->stype - ft2->stype;\n\tif (v)\n\t\treturn v;\n\n\tv = ft1->ttype - ft2->ttype;\n\tif (v)\n\t\treturn v;\n\n\tv = ft1->tclass - ft2->tclass;\n\tif (v)\n\t\treturn v;\n\n\treturn strcmp(ft1->name, ft2->name);\n\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ft1->name",
            "ft2->name"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int filenametr_cmp(struct hashtab *h, const void *k1, const void *k2)\n{\n\tconst struct filename_trans *ft1 = k1;\n\tconst struct filename_trans *ft2 = k2;\n\tint v;\n\n\tv = ft1->stype - ft2->stype;\n\tif (v)\n\t\treturn v;\n\n\tv = ft1->ttype - ft2->ttype;\n\tif (v)\n\t\treturn v;\n\n\tv = ft1->tclass - ft2->tclass;\n\tif (v)\n\t\treturn v;\n\n\treturn strcmp(ft1->name, ft2->name);\n\n}"
  },
  {
    "function_name": "filenametr_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "216-229",
    "snippet": "static u32 filenametr_hash(struct hashtab *h, const void *k)\n{\n\tconst struct filename_trans *ft = k;\n\tunsigned long hash;\n\tunsigned int byte_num;\n\tunsigned char focus;\n\n\thash = ft->stype ^ ft->ttype ^ ft->tclass;\n\n\tbyte_num = 0;\n\twhile ((focus = ft->name[byte_num++]))\n\t\thash = partial_name_hash(focus, hash);\n\treturn hash & (h->size - 1);\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "partial_name_hash",
          "args": [
            "focus",
            "hash"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic u32 filenametr_hash(struct hashtab *h, const void *k)\n{\n\tconst struct filename_trans *ft = k;\n\tunsigned long hash;\n\tunsigned int byte_num;\n\tunsigned char focus;\n\n\thash = ft->stype ^ ft->ttype ^ ft->tclass;\n\n\tbyte_num = 0;\n\twhile ((focus = ft->name[byte_num++]))\n\t\thash = partial_name_hash(focus, hash);\n\treturn hash & (h->size - 1);\n}"
  },
  {
    "function_name": "roles_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "185-214",
    "snippet": "static int roles_init(struct policydb *p)\n{\n\tchar *key = NULL;\n\tint rc;\n\tstruct role_datum *role;\n\n\trole = kzalloc(sizeof(*role), GFP_KERNEL);\n\tif (!role)\n\t\treturn -ENOMEM;\n\n\trc = -EINVAL;\n\trole->value = ++p->p_roles.nprim;\n\tif (role->value != OBJECT_R_VAL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tkey = kstrdup(OBJECT_R, GFP_KERNEL);\n\tif (!key)\n\t\tgoto out;\n\n\trc = hashtab_insert(p->p_roles.table, key, role);\n\tif (rc)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tkfree(key);\n\tkfree(role);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "role"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashtab_insert",
          "args": [
            "p->p_roles.table",
            "key",
            "role"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "42-78",
          "snippet": "int hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hashtab_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *hashtab_node_cachep;\n\nint hashtab_insert(struct hashtab *h, void *key, void *datum)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *prev, *cur, *newnode;\n\n\tcond_resched();\n\n\tif (!h || h->nel == HASHTAB_MAX_NODES)\n\t\treturn -EINVAL;\n\n\thvalue = h->hash_value(h, key);\n\tprev = NULL;\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0) {\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\n\tif (cur && (h->keycmp(h, key, cur->key) == 0))\n\t\treturn -EEXIST;\n\n\tnewnode = kmem_cache_zalloc(hashtab_node_cachep, GFP_KERNEL);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\tnewnode->key = key;\n\tnewnode->datum = datum;\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = h->htable[hvalue];\n\t\th->htable[hvalue] = newnode;\n\t}\n\n\th->nel++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "OBJECT_R",
            "GFP_KERNEL"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*role)",
            "GFP_KERNEL"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int roles_init(struct policydb *p)\n{\n\tchar *key = NULL;\n\tint rc;\n\tstruct role_datum *role;\n\n\trole = kzalloc(sizeof(*role), GFP_KERNEL);\n\tif (!role)\n\t\treturn -ENOMEM;\n\n\trc = -EINVAL;\n\trole->value = ++p->p_roles.nprim;\n\tif (role->value != OBJECT_R_VAL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tkey = kstrdup(OBJECT_R, GFP_KERNEL);\n\tif (!key)\n\t\tgoto out;\n\n\trc = hashtab_insert(p->p_roles.table, key, role);\n\tif (rc)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tkfree(key);\n\tkfree(role);\n\treturn rc;\n}"
  },
  {
    "function_name": "policydb_lookup_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
    "lines": "168-180",
    "snippet": "static struct policydb_compat_info *policydb_lookup_compat(int version)\n{\n\tint i;\n\tstruct policydb_compat_info *info = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(policydb_compat); i++) {\n\t\tif (policydb_compat[i].version == version) {\n\t\t\tinfo = &policydb_compat[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn info;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"mls.h\"",
      "#include \"conditional.h\"",
      "#include \"policydb.h\"",
      "#include \"security.h\"",
      "#include <linux/flex_array.h>",
      "#include <linux/audit.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct policydb_compat_info policydb_compat[] = {\n\t{\n\t\t.version\t= POLICYDB_VERSION_BASE,\n\t\t.sym_num\t= SYM_NUM - 3,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOOL,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_IPV6,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NLCLASS,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_MLS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_AVTAB,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_RANGETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_POLCAP,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_PERMISSIVE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOUNDARY,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_FILENAME_TRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_ROLETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NEW_OBJECT_DEFAULTS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_DEFAULT_TYPE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_CONSTRAINT_NAMES,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_XPERMS_IOCTL,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_INFINIBAND,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "policydb_compat"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic struct policydb_compat_info policydb_compat[] = {\n\t{\n\t\t.version\t= POLICYDB_VERSION_BASE,\n\t\t.sym_num\t= SYM_NUM - 3,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOOL,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 3,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_IPV6,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NLCLASS,\n\t\t.sym_num\t= SYM_NUM - 2,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_MLS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_AVTAB,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_RANGETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_POLCAP,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_PERMISSIVE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_BOUNDARY,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_FILENAME_TRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_ROLETRANS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_NEW_OBJECT_DEFAULTS,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_DEFAULT_TYPE,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_CONSTRAINT_NAMES,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_XPERMS_IOCTL,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM - 2,\n\t},\n\t{\n\t\t.version\t= POLICYDB_VERSION_INFINIBAND,\n\t\t.sym_num\t= SYM_NUM,\n\t\t.ocon_num\t= OCON_NUM,\n\t},\n};\n\nstatic struct policydb_compat_info *policydb_lookup_compat(int version)\n{\n\tint i;\n\tstruct policydb_compat_info *info = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(policydb_compat); i++) {\n\t\tif (policydb_compat[i].version == version) {\n\t\t\tinfo = &policydb_compat[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn info;\n}"
  }
]