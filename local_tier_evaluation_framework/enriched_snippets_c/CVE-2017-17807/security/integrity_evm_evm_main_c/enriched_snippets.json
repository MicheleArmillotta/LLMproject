[
  {
    "function_name": "evm_display_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "531-538",
    "snippet": "static int __init evm_display_config(void)\n{\n\tchar **xattrname;\n\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++)\n\t\tpr_info(\"%s\\n\", *xattrname);\n\treturn 0;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s\\n\"",
            "*xattrname"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int __init evm_display_config(void)\n{\n\tchar **xattrname;\n\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++)\n\t\tpr_info(\"%s\\n\", *xattrname);\n\treturn 0;\n}"
  },
  {
    "function_name": "init_evm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "509-526",
    "snippet": "static int __init init_evm(void)\n{\n\tint error;\n\n\tevm_init_config();\n\n\terror = integrity_init_keyring(INTEGRITY_KEYRING_EVM);\n\tif (error)\n\t\treturn error;\n\n\terror = evm_init_secfs();\n\tif (error < 0) {\n\t\tpr_info(\"Error registering secfs\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Error registering secfs\\n\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evm_init_secfs",
          "args": [],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "evm_init_secfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_secfs.c",
          "lines": "96-105",
          "snippet": "int __init evm_init_secfs(void)\n{\n\tint error = 0;\n\n\tevm_init_tpm = securityfs_create_file(\"evm\", S_IRUSR | S_IRGRP,\n\t\t\t\t\t      NULL, NULL, &evm_key_ops);\n\tif (!evm_init_tpm || IS_ERR(evm_init_tpm))\n\t\terror = -EFAULT;\n\treturn error;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *evm_init_tpm;",
            "static const struct file_operations evm_key_ops = {\n\t.read\t\t= evm_read_key,\n\t.write\t\t= evm_write_key,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic struct dentry *evm_init_tpm;\nstatic const struct file_operations evm_key_ops = {\n\t.read\t\t= evm_read_key,\n\t.write\t\t= evm_write_key,\n};\n\nint __init evm_init_secfs(void)\n{\n\tint error = 0;\n\n\tevm_init_tpm = securityfs_create_file(\"evm\", S_IRUSR | S_IRGRP,\n\t\t\t\t\t      NULL, NULL, &evm_key_ops);\n\tif (!evm_init_tpm || IS_ERR(evm_init_tpm))\n\t\terror = -EFAULT;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "integrity_init_keyring",
          "args": [
            "INTEGRITY_KEYRING_EVM"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_init_keyring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "144-147",
          "snippet": "static inline int integrity_init_keyring(const unsigned int id)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstatic inline int integrity_init_keyring(const unsigned int id)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "evm_init_config",
          "args": [],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "evm_init_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "71-77",
          "snippet": "static void __init evm_init_config(void)\n{\n#ifdef CONFIG_EVM_ATTR_FSUUID\n\tevm_hmac_attrs |= EVM_ATTR_FSUUID;\n#endif\n\tpr_info(\"HMAC attrs: 0x%x\\n\", evm_hmac_attrs);\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int evm_hmac_attrs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_hmac_attrs;\n\nstatic void __init evm_init_config(void)\n{\n#ifdef CONFIG_EVM_ATTR_FSUUID\n\tevm_hmac_attrs |= EVM_ATTR_FSUUID;\n#endif\n\tpr_info(\"HMAC attrs: 0x%x\\n\", evm_hmac_attrs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int __init init_evm(void)\n{\n\tint error;\n\n\tevm_init_config();\n\n\terror = integrity_init_keyring(INTEGRITY_KEYRING_EVM);\n\tif (error)\n\t\treturn error;\n\n\terror = evm_init_secfs();\n\tif (error < 0) {\n\t\tpr_info(\"Error registering secfs\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "evm_load_x509",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "499-506",
    "snippet": "void __init evm_load_x509(void)\n{\n\tint rc;\n\n\trc = integrity_load_x509(INTEGRITY_KEYRING_EVM, CONFIG_EVM_X509_PATH);\n\tif (!rc)\n\t\tevm_initialized |= EVM_INIT_X509;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int evm_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "integrity_load_x509",
          "args": [
            "INTEGRITY_KEYRING_EVM",
            "CONFIG_EVM_X509_PATH"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_load_x509",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/digsig.c",
          "lines": "112-148",
          "snippet": "int __init integrity_load_x509(const unsigned int id, const char *path)\n{\n\tkey_ref_t key;\n\tvoid *data;\n\tloff_t size;\n\tint rc;\n\n\tif (!keyring[id])\n\t\treturn -EINVAL;\n\n\trc = kernel_read_file_from_path(path, &data, &size, 0,\n\t\t\t\t\tREADING_X509_CERTIFICATE);\n\tif (rc < 0) {\n\t\tpr_err(\"Unable to open file: %s (%d)\", path, rc);\n\t\treturn rc;\n\t}\n\n\tkey = key_create_or_update(make_key_ref(keyring[id], 1),\n\t\t\t\t   \"asymmetric\",\n\t\t\t\t   NULL,\n\t\t\t\t   data,\n\t\t\t\t   size,\n\t\t\t\t   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\trc = PTR_ERR(key);\n\t\tpr_err(\"Problem loading X.509 certificate (%d): %s\\n\",\n\t\t       rc, path);\n\t} else {\n\t\tpr_notice(\"Loaded X.509 cert '%s': %s\\n\",\n\t\t\t  key_ref_to_ptr(key)->description, path);\n\t\tkey_ref_put(key);\n\t}\n\tvfree(data);\n\treturn 0;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <keys/system_keyring.h>",
            "#include <crypto/public_key.h>",
            "#include <linux/digsig.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct key *keyring[INTEGRITY_KEYRING_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <keys/system_keyring.h>\n#include <crypto/public_key.h>\n#include <linux/digsig.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n\nstatic struct key *keyring[INTEGRITY_KEYRING_MAX];\n\nint __init integrity_load_x509(const unsigned int id, const char *path)\n{\n\tkey_ref_t key;\n\tvoid *data;\n\tloff_t size;\n\tint rc;\n\n\tif (!keyring[id])\n\t\treturn -EINVAL;\n\n\trc = kernel_read_file_from_path(path, &data, &size, 0,\n\t\t\t\t\tREADING_X509_CERTIFICATE);\n\tif (rc < 0) {\n\t\tpr_err(\"Unable to open file: %s (%d)\", path, rc);\n\t\treturn rc;\n\t}\n\n\tkey = key_create_or_update(make_key_ref(keyring[id], 1),\n\t\t\t\t   \"asymmetric\",\n\t\t\t\t   NULL,\n\t\t\t\t   data,\n\t\t\t\t   size,\n\t\t\t\t   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\trc = PTR_ERR(key);\n\t\tpr_err(\"Problem loading X.509 certificate (%d): %s\\n\",\n\t\t       rc, path);\n\t} else {\n\t\tpr_notice(\"Loaded X.509 cert '%s': %s\\n\",\n\t\t\t  key_ref_to_ptr(key)->description, path);\n\t\tkey_ref_put(key);\n\t}\n\tvfree(data);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_initialized;\n\nvoid __init evm_load_x509(void)\n{\n\tint rc;\n\n\trc = integrity_load_x509(INTEGRITY_KEYRING_EVM, CONFIG_EVM_X509_PATH);\n\tif (!rc)\n\t\tevm_initialized |= EVM_INIT_X509;\n}"
  },
  {
    "function_name": "evm_inode_init_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "469-495",
    "snippet": "int evm_inode_init_security(struct inode *inode,\n\t\t\t\t const struct xattr *lsm_xattr,\n\t\t\t\t struct xattr *evm_xattr)\n{\n\tstruct evm_ima_xattr_data *xattr_data;\n\tint rc;\n\n\tif (!evm_initialized || !evm_protected_xattr(lsm_xattr->name))\n\t\treturn 0;\n\n\txattr_data = kzalloc(sizeof(*xattr_data), GFP_NOFS);\n\tif (!xattr_data)\n\t\treturn -ENOMEM;\n\n\txattr_data->type = EVM_XATTR_HMAC;\n\trc = evm_init_hmac(inode, lsm_xattr, xattr_data->digest);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tevm_xattr->value = xattr_data;\n\tevm_xattr->value_len = sizeof(*xattr_data);\n\tevm_xattr->name = XATTR_EVM_SUFFIX;\n\treturn 0;\nout:\n\tkfree(xattr_data);\n\treturn rc;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int evm_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr_data"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evm_init_hmac",
          "args": [
            "inode",
            "lsm_xattr",
            "xattr_data->digest"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "evm_init_hmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "271-286",
          "snippet": "int evm_init_hmac(struct inode *inode, const struct xattr *lsm_xattr,\n\t\t  char *hmac_val)\n{\n\tstruct shash_desc *desc;\n\n\tdesc = init_desc(EVM_XATTR_HMAC);\n\tif (IS_ERR(desc)) {\n\t\tpr_info(\"init_desc failed\\n\");\n\t\treturn PTR_ERR(desc);\n\t}\n\n\tcrypto_shash_update(desc, lsm_xattr->value, lsm_xattr->value_len);\n\thmac_add_misc(desc, inode, hmac_val);\n\tkfree(desc);\n\treturn 0;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_init_hmac(struct inode *inode, const struct xattr *lsm_xattr,\n\t\t  char *hmac_val)\n{\n\tstruct shash_desc *desc;\n\n\tdesc = init_desc(EVM_XATTR_HMAC);\n\tif (IS_ERR(desc)) {\n\t\tpr_info(\"init_desc failed\\n\");\n\t\treturn PTR_ERR(desc);\n\t}\n\n\tcrypto_shash_update(desc, lsm_xattr->value, lsm_xattr->value_len);\n\thmac_add_misc(desc, inode, hmac_val);\n\tkfree(desc);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*xattr_data)",
            "GFP_NOFS"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evm_protected_xattr",
          "args": [
            "lsm_xattr->name"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "evm_protected_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "200-221",
          "snippet": "static int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_initialized;\n\nint evm_inode_init_security(struct inode *inode,\n\t\t\t\t const struct xattr *lsm_xattr,\n\t\t\t\t struct xattr *evm_xattr)\n{\n\tstruct evm_ima_xattr_data *xattr_data;\n\tint rc;\n\n\tif (!evm_initialized || !evm_protected_xattr(lsm_xattr->name))\n\t\treturn 0;\n\n\txattr_data = kzalloc(sizeof(*xattr_data), GFP_NOFS);\n\tif (!xattr_data)\n\t\treturn -ENOMEM;\n\n\txattr_data->type = EVM_XATTR_HMAC;\n\trc = evm_init_hmac(inode, lsm_xattr, xattr_data->digest);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tevm_xattr->value = xattr_data;\n\tevm_xattr->value_len = sizeof(*xattr_data);\n\tevm_xattr->name = XATTR_EVM_SUFFIX;\n\treturn 0;\nout:\n\tkfree(xattr_data);\n\treturn rc;\n}"
  },
  {
    "function_name": "evm_inode_post_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "457-464",
    "snippet": "void evm_inode_post_setattr(struct dentry *dentry, int ia_valid)\n{\n\tif (!evm_initialized)\n\t\treturn;\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))\n\t\tevm_update_evmxattr(dentry, NULL, NULL, 0);\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int evm_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "evm_update_evmxattr",
          "args": [
            "dentry",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "evm_update_evmxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "251-269",
          "snippet": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t} else if (rc == -ENODATA && (inode->i_opflags & IOP_XATTR)) {\n\t\trc = __vfs_removexattr(dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t} else if (rc == -ENODATA && (inode->i_opflags & IOP_XATTR)) {\n\t\trc = __vfs_removexattr(dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_initialized;\n\nvoid evm_inode_post_setattr(struct dentry *dentry, int ia_valid)\n{\n\tif (!evm_initialized)\n\t\treturn;\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))\n\t\tevm_update_evmxattr(dentry, NULL, NULL, 0);\n}"
  },
  {
    "function_name": "evm_inode_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "429-444",
    "snippet": "int evm_inode_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tenum integrity_status evm_status;\n\n\tif (!(ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID)))\n\t\treturn 0;\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif ((evm_status == INTEGRITY_PASS) ||\n\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\treturn 0;\n\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t    integrity_status_msg[evm_status], -EPERM, 0);\n\treturn -EPERM;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *integrity_status_msg[] = {\n\t\"pass\", \"fail\", \"no_label\", \"no_xattrs\", \"unknown\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "integrity_audit_msg",
          "args": [
            "AUDIT_INTEGRITY_METADATA",
            "d_backing_inode(dentry)",
            "dentry->d_name.name",
            "\"appraise_metadata\"",
            "integrity_status_msg[evm_status]",
            "-EPERM",
            "0"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "183-188",
          "snippet": "static inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct integrity_iint_cache *integrity_iint_find(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode);\n\nstatic inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evm_verify_current_integrity",
          "args": [
            "dentry"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "evm_verify_current_integrity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "264-271",
          "snippet": "static enum integrity_status evm_verify_current_integrity(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\tif (!evm_initialized || !S_ISREG(inode->i_mode) || evm_fixmode)\n\t\treturn 0;\n\treturn evm_verify_hmac(dentry, NULL, NULL, 0, NULL);\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int evm_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_initialized;\n\nstatic enum integrity_status evm_verify_current_integrity(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\tif (!evm_initialized || !S_ISREG(inode->i_mode) || evm_fixmode)\n\t\treturn 0;\n\treturn evm_verify_hmac(dentry, NULL, NULL, 0, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic char *integrity_status_msg[] = {\n\t\"pass\", \"fail\", \"no_label\", \"no_xattrs\", \"unknown\"\n};\n\nint evm_inode_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tenum integrity_status evm_status;\n\n\tif (!(ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID)))\n\t\treturn 0;\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif ((evm_status == INTEGRITY_PASS) ||\n\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\treturn 0;\n\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t    integrity_status_msg[evm_status], -EPERM, 0);\n\treturn -EPERM;\n}"
  },
  {
    "function_name": "evm_inode_post_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "415-423",
    "snippet": "void evm_inode_post_removexattr(struct dentry *dentry, const char *xattr_name)\n{\n\tif (!evm_initialized || !evm_protected_xattr(xattr_name))\n\t\treturn;\n\n\tevm_reset_status(dentry->d_inode);\n\n\tevm_update_evmxattr(dentry, xattr_name, NULL, 0);\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int evm_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "evm_update_evmxattr",
          "args": [
            "dentry",
            "xattr_name",
            "NULL",
            "0"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "evm_update_evmxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "251-269",
          "snippet": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t} else if (rc == -ENODATA && (inode->i_opflags & IOP_XATTR)) {\n\t\trc = __vfs_removexattr(dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t} else if (rc == -ENODATA && (inode->i_opflags & IOP_XATTR)) {\n\t\trc = __vfs_removexattr(dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "evm_reset_status",
          "args": [
            "dentry->d_inode"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "evm_reset_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "371-378",
          "snippet": "static void evm_reset_status(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\tiint->evm_status = INTEGRITY_UNKNOWN;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic void evm_reset_status(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\tiint->evm_status = INTEGRITY_UNKNOWN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "evm_protected_xattr",
          "args": [
            "xattr_name"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "evm_protected_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "200-221",
          "snippet": "static int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_initialized;\n\nvoid evm_inode_post_removexattr(struct dentry *dentry, const char *xattr_name)\n{\n\tif (!evm_initialized || !evm_protected_xattr(xattr_name))\n\t\treturn;\n\n\tevm_reset_status(dentry->d_inode);\n\n\tevm_update_evmxattr(dentry, xattr_name, NULL, 0);\n}"
  },
  {
    "function_name": "evm_inode_post_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "393-403",
    "snippet": "void evm_inode_post_setxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tif (!evm_initialized || (!evm_protected_xattr(xattr_name)\n\t\t\t\t && !posix_xattr_acl(xattr_name)))\n\t\treturn;\n\n\tevm_reset_status(dentry->d_inode);\n\n\tevm_update_evmxattr(dentry, xattr_name, xattr_value, xattr_value_len);\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int evm_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "evm_update_evmxattr",
          "args": [
            "dentry",
            "xattr_name",
            "xattr_value",
            "xattr_value_len"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "evm_update_evmxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "251-269",
          "snippet": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t} else if (rc == -ENODATA && (inode->i_opflags & IOP_XATTR)) {\n\t\trc = __vfs_removexattr(dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t} else if (rc == -ENODATA && (inode->i_opflags & IOP_XATTR)) {\n\t\trc = __vfs_removexattr(dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "evm_reset_status",
          "args": [
            "dentry->d_inode"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "evm_reset_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "371-378",
          "snippet": "static void evm_reset_status(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\tiint->evm_status = INTEGRITY_UNKNOWN;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic void evm_reset_status(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\tiint->evm_status = INTEGRITY_UNKNOWN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_xattr_acl",
          "args": [
            "xattr_name"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "posix_xattr_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_posix_acl.c",
          "lines": "16-27",
          "snippet": "int posix_xattr_acl(const char *xattr)\n{\n\tint xattr_len = strlen(xattr);\n\n\tif ((strlen(XATTR_NAME_POSIX_ACL_ACCESS) == xattr_len)\n\t     && (strncmp(XATTR_NAME_POSIX_ACL_ACCESS, xattr, xattr_len) == 0))\n\t\treturn 1;\n\tif ((strlen(XATTR_NAME_POSIX_ACL_DEFAULT) == xattr_len)\n\t     && (strncmp(XATTR_NAME_POSIX_ACL_DEFAULT, xattr, xattr_len) == 0))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/module.h>\n\nint posix_xattr_acl(const char *xattr)\n{\n\tint xattr_len = strlen(xattr);\n\n\tif ((strlen(XATTR_NAME_POSIX_ACL_ACCESS) == xattr_len)\n\t     && (strncmp(XATTR_NAME_POSIX_ACL_ACCESS, xattr, xattr_len) == 0))\n\t\treturn 1;\n\tif ((strlen(XATTR_NAME_POSIX_ACL_DEFAULT) == xattr_len)\n\t     && (strncmp(XATTR_NAME_POSIX_ACL_DEFAULT, xattr, xattr_len) == 0))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "evm_protected_xattr",
          "args": [
            "xattr_name"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "evm_protected_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "200-221",
          "snippet": "static int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_initialized;\n\nvoid evm_inode_post_setxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tif (!evm_initialized || (!evm_protected_xattr(xattr_name)\n\t\t\t\t && !posix_xattr_acl(xattr_name)))\n\t\treturn;\n\n\tevm_reset_status(dentry->d_inode);\n\n\tevm_update_evmxattr(dentry, xattr_name, xattr_value, xattr_value_len);\n}"
  },
  {
    "function_name": "evm_reset_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "371-378",
    "snippet": "static void evm_reset_status(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\tiint->evm_status = INTEGRITY_UNKNOWN;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "integrity_iint_find",
          "args": [
            "inode"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_iint_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/iint.c",
          "lines": "57-69",
          "snippet": "struct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(integrity_iint_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(integrity_iint_lock);\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic void evm_reset_status(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\tiint->evm_status = INTEGRITY_UNKNOWN;\n}"
  },
  {
    "function_name": "evm_inode_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "366-369",
    "snippet": "int evm_inode_removexattr(struct dentry *dentry, const char *xattr_name)\n{\n\treturn evm_protect_xattr(dentry, xattr_name, NULL, 0);\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "evm_protect_xattr",
          "args": [
            "dentry",
            "xattr_name",
            "NULL",
            "0"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "evm_protect_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "285-328",
          "snippet": "static int evm_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tenum integrity_status evm_status;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t} else if (!evm_protected_xattr(xattr_name)) {\n\t\tif (!posix_xattr_acl(xattr_name))\n\t\t\treturn 0;\n\t\tevm_status = evm_verify_current_integrity(dentry);\n\t\tif ((evm_status == INTEGRITY_PASS) ||\n\t\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif (evm_status == INTEGRITY_NOXATTRS) {\n\t\tstruct integrity_iint_cache *iint;\n\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (iint && (iint->flags & IMA_NEW_FILE))\n\t\t\treturn 0;\n\n\t\t/* exception for pseudo filesystems */\n\t\tif (dentry->d_sb->s_magic == TMPFS_MAGIC\n\t\t    || dentry->d_sb->s_magic == SYSFS_MAGIC)\n\t\t\treturn 0;\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA,\n\t\t\t\t    dentry->d_inode, dentry->d_name.name,\n\t\t\t\t    \"update_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\t}\nout:\n\tif (evm_status != INTEGRITY_PASS)\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\treturn evm_status == INTEGRITY_PASS ? 0 : -EPERM;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *integrity_status_msg[] = {\n\t\"pass\", \"fail\", \"no_label\", \"no_xattrs\", \"unknown\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic char *integrity_status_msg[] = {\n\t\"pass\", \"fail\", \"no_label\", \"no_xattrs\", \"unknown\"\n};\n\nstatic int evm_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tenum integrity_status evm_status;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t} else if (!evm_protected_xattr(xattr_name)) {\n\t\tif (!posix_xattr_acl(xattr_name))\n\t\t\treturn 0;\n\t\tevm_status = evm_verify_current_integrity(dentry);\n\t\tif ((evm_status == INTEGRITY_PASS) ||\n\t\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif (evm_status == INTEGRITY_NOXATTRS) {\n\t\tstruct integrity_iint_cache *iint;\n\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (iint && (iint->flags & IMA_NEW_FILE))\n\t\t\treturn 0;\n\n\t\t/* exception for pseudo filesystems */\n\t\tif (dentry->d_sb->s_magic == TMPFS_MAGIC\n\t\t    || dentry->d_sb->s_magic == SYSFS_MAGIC)\n\t\t\treturn 0;\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA,\n\t\t\t\t    dentry->d_inode, dentry->d_name.name,\n\t\t\t\t    \"update_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\t}\nout:\n\tif (evm_status != INTEGRITY_PASS)\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\treturn evm_status == INTEGRITY_PASS ? 0 : -EPERM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_inode_removexattr(struct dentry *dentry, const char *xattr_name)\n{\n\treturn evm_protect_xattr(dentry, xattr_name, NULL, 0);\n}"
  },
  {
    "function_name": "evm_inode_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "343-356",
    "snippet": "int evm_inode_setxattr(struct dentry *dentry, const char *xattr_name,\n\t\t       const void *xattr_value, size_t xattr_value_len)\n{\n\tconst struct evm_ima_xattr_data *xattr_data = xattr_value;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!xattr_value_len)\n\t\t\treturn -EINVAL;\n\t\tif (xattr_data->type != EVM_IMA_XATTR_DIGSIG)\n\t\t\treturn -EPERM;\n\t}\n\treturn evm_protect_xattr(dentry, xattr_name, xattr_value,\n\t\t\t\t xattr_value_len);\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "evm_protect_xattr",
          "args": [
            "dentry",
            "xattr_name",
            "xattr_value",
            "xattr_value_len"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "evm_protect_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "285-328",
          "snippet": "static int evm_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tenum integrity_status evm_status;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t} else if (!evm_protected_xattr(xattr_name)) {\n\t\tif (!posix_xattr_acl(xattr_name))\n\t\t\treturn 0;\n\t\tevm_status = evm_verify_current_integrity(dentry);\n\t\tif ((evm_status == INTEGRITY_PASS) ||\n\t\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif (evm_status == INTEGRITY_NOXATTRS) {\n\t\tstruct integrity_iint_cache *iint;\n\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (iint && (iint->flags & IMA_NEW_FILE))\n\t\t\treturn 0;\n\n\t\t/* exception for pseudo filesystems */\n\t\tif (dentry->d_sb->s_magic == TMPFS_MAGIC\n\t\t    || dentry->d_sb->s_magic == SYSFS_MAGIC)\n\t\t\treturn 0;\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA,\n\t\t\t\t    dentry->d_inode, dentry->d_name.name,\n\t\t\t\t    \"update_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\t}\nout:\n\tif (evm_status != INTEGRITY_PASS)\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\treturn evm_status == INTEGRITY_PASS ? 0 : -EPERM;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *integrity_status_msg[] = {\n\t\"pass\", \"fail\", \"no_label\", \"no_xattrs\", \"unknown\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic char *integrity_status_msg[] = {\n\t\"pass\", \"fail\", \"no_label\", \"no_xattrs\", \"unknown\"\n};\n\nstatic int evm_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tenum integrity_status evm_status;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t} else if (!evm_protected_xattr(xattr_name)) {\n\t\tif (!posix_xattr_acl(xattr_name))\n\t\t\treturn 0;\n\t\tevm_status = evm_verify_current_integrity(dentry);\n\t\tif ((evm_status == INTEGRITY_PASS) ||\n\t\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif (evm_status == INTEGRITY_NOXATTRS) {\n\t\tstruct integrity_iint_cache *iint;\n\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (iint && (iint->flags & IMA_NEW_FILE))\n\t\t\treturn 0;\n\n\t\t/* exception for pseudo filesystems */\n\t\tif (dentry->d_sb->s_magic == TMPFS_MAGIC\n\t\t    || dentry->d_sb->s_magic == SYSFS_MAGIC)\n\t\t\treturn 0;\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA,\n\t\t\t\t    dentry->d_inode, dentry->d_name.name,\n\t\t\t\t    \"update_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\t}\nout:\n\tif (evm_status != INTEGRITY_PASS)\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\treturn evm_status == INTEGRITY_PASS ? 0 : -EPERM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "xattr_name",
            "XATTR_NAME_EVM"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_inode_setxattr(struct dentry *dentry, const char *xattr_name,\n\t\t       const void *xattr_value, size_t xattr_value_len)\n{\n\tconst struct evm_ima_xattr_data *xattr_data = xattr_value;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!xattr_value_len)\n\t\t\treturn -EINVAL;\n\t\tif (xattr_data->type != EVM_IMA_XATTR_DIGSIG)\n\t\t\treturn -EPERM;\n\t}\n\treturn evm_protect_xattr(dentry, xattr_name, xattr_value,\n\t\t\t\t xattr_value_len);\n}"
  },
  {
    "function_name": "evm_protect_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "285-328",
    "snippet": "static int evm_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tenum integrity_status evm_status;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t} else if (!evm_protected_xattr(xattr_name)) {\n\t\tif (!posix_xattr_acl(xattr_name))\n\t\t\treturn 0;\n\t\tevm_status = evm_verify_current_integrity(dentry);\n\t\tif ((evm_status == INTEGRITY_PASS) ||\n\t\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif (evm_status == INTEGRITY_NOXATTRS) {\n\t\tstruct integrity_iint_cache *iint;\n\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (iint && (iint->flags & IMA_NEW_FILE))\n\t\t\treturn 0;\n\n\t\t/* exception for pseudo filesystems */\n\t\tif (dentry->d_sb->s_magic == TMPFS_MAGIC\n\t\t    || dentry->d_sb->s_magic == SYSFS_MAGIC)\n\t\t\treturn 0;\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA,\n\t\t\t\t    dentry->d_inode, dentry->d_name.name,\n\t\t\t\t    \"update_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\t}\nout:\n\tif (evm_status != INTEGRITY_PASS)\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\treturn evm_status == INTEGRITY_PASS ? 0 : -EPERM;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *integrity_status_msg[] = {\n\t\"pass\", \"fail\", \"no_label\", \"no_xattrs\", \"unknown\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "integrity_audit_msg",
          "args": [
            "AUDIT_INTEGRITY_METADATA",
            "d_backing_inode(dentry)",
            "dentry->d_name.name",
            "\"appraise_metadata\"",
            "integrity_status_msg[evm_status]",
            "-EPERM",
            "0"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "183-188",
          "snippet": "static inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct integrity_iint_cache *integrity_iint_find(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode);\n\nstatic inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "integrity_iint_find",
          "args": [
            "d_backing_inode(dentry)"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_iint_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/iint.c",
          "lines": "57-69",
          "snippet": "struct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(integrity_iint_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(integrity_iint_lock);\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evm_verify_current_integrity",
          "args": [
            "dentry"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "evm_verify_current_integrity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "264-271",
          "snippet": "static enum integrity_status evm_verify_current_integrity(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\tif (!evm_initialized || !S_ISREG(inode->i_mode) || evm_fixmode)\n\t\treturn 0;\n\treturn evm_verify_hmac(dentry, NULL, NULL, 0, NULL);\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int evm_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_initialized;\n\nstatic enum integrity_status evm_verify_current_integrity(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\tif (!evm_initialized || !S_ISREG(inode->i_mode) || evm_fixmode)\n\t\treturn 0;\n\treturn evm_verify_hmac(dentry, NULL, NULL, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_xattr_acl",
          "args": [
            "xattr_name"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "posix_xattr_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_posix_acl.c",
          "lines": "16-27",
          "snippet": "int posix_xattr_acl(const char *xattr)\n{\n\tint xattr_len = strlen(xattr);\n\n\tif ((strlen(XATTR_NAME_POSIX_ACL_ACCESS) == xattr_len)\n\t     && (strncmp(XATTR_NAME_POSIX_ACL_ACCESS, xattr, xattr_len) == 0))\n\t\treturn 1;\n\tif ((strlen(XATTR_NAME_POSIX_ACL_DEFAULT) == xattr_len)\n\t     && (strncmp(XATTR_NAME_POSIX_ACL_DEFAULT, xattr, xattr_len) == 0))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/module.h>\n\nint posix_xattr_acl(const char *xattr)\n{\n\tint xattr_len = strlen(xattr);\n\n\tif ((strlen(XATTR_NAME_POSIX_ACL_ACCESS) == xattr_len)\n\t     && (strncmp(XATTR_NAME_POSIX_ACL_ACCESS, xattr, xattr_len) == 0))\n\t\treturn 1;\n\tif ((strlen(XATTR_NAME_POSIX_ACL_DEFAULT) == xattr_len)\n\t     && (strncmp(XATTR_NAME_POSIX_ACL_DEFAULT, xattr, xattr_len) == 0))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "evm_protected_xattr",
          "args": [
            "xattr_name"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "evm_protected_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "200-221",
          "snippet": "static int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "xattr_name",
            "XATTR_NAME_EVM"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic char *integrity_status_msg[] = {\n\t\"pass\", \"fail\", \"no_label\", \"no_xattrs\", \"unknown\"\n};\n\nstatic int evm_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tenum integrity_status evm_status;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t} else if (!evm_protected_xattr(xattr_name)) {\n\t\tif (!posix_xattr_acl(xattr_name))\n\t\t\treturn 0;\n\t\tevm_status = evm_verify_current_integrity(dentry);\n\t\tif ((evm_status == INTEGRITY_PASS) ||\n\t\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif (evm_status == INTEGRITY_NOXATTRS) {\n\t\tstruct integrity_iint_cache *iint;\n\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (iint && (iint->flags & IMA_NEW_FILE))\n\t\t\treturn 0;\n\n\t\t/* exception for pseudo filesystems */\n\t\tif (dentry->d_sb->s_magic == TMPFS_MAGIC\n\t\t    || dentry->d_sb->s_magic == SYSFS_MAGIC)\n\t\t\treturn 0;\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA,\n\t\t\t\t    dentry->d_inode, dentry->d_name.name,\n\t\t\t\t    \"update_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\t}\nout:\n\tif (evm_status != INTEGRITY_PASS)\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\treturn evm_status == INTEGRITY_PASS ? 0 : -EPERM;\n}"
  },
  {
    "function_name": "evm_verify_current_integrity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "264-271",
    "snippet": "static enum integrity_status evm_verify_current_integrity(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\tif (!evm_initialized || !S_ISREG(inode->i_mode) || evm_fixmode)\n\t\treturn 0;\n\treturn evm_verify_hmac(dentry, NULL, NULL, 0, NULL);\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int evm_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "evm_verify_hmac",
          "args": [
            "dentry",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "evm_verify_hmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "115-198",
          "snippet": "static enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct evm_ima_xattr_data calc;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tint rc, xattr_len;\n\n\tif (iint && iint->evm_status == INTEGRITY_PASS)\n\t\treturn iint->evm_status;\n\n\t/* if status is not PASS, try to check again - against -ENOMEM */\n\n\t/* first need to know the sig type */\n\trc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS; /* new file */\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t/* check value type */\n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\tif (xattr_len != sizeof(struct evm_ima_xattr_data)) {\n\t\t\tevm_status = INTEGRITY_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = crypto_memneq(xattr_data->digest, calc.digest,\n\t\t\t    sizeof(calc.digest));\n\t\tif (rc)\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\txattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tcalc.digest, sizeof(calc.digest));\n\t\tif (!rc) {\n\t\t\t/* Replace RSA with HMAC if not mounted readonly and\n\t\t\t * not immutable\n\t\t\t */\n\t\t\tif (!IS_RDONLY(d_backing_inode(dentry)) &&\n\t\t\t    !IS_IMMUTABLE(d_backing_inode(dentry)))\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tevm_status = (rc == -ENODATA) ?\n\t\t\t\tINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct evm_ima_xattr_data calc;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tint rc, xattr_len;\n\n\tif (iint && iint->evm_status == INTEGRITY_PASS)\n\t\treturn iint->evm_status;\n\n\t/* if status is not PASS, try to check again - against -ENOMEM */\n\n\t/* first need to know the sig type */\n\trc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS; /* new file */\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t/* check value type */\n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\tif (xattr_len != sizeof(struct evm_ima_xattr_data)) {\n\t\t\tevm_status = INTEGRITY_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = crypto_memneq(xattr_data->digest, calc.digest,\n\t\t\t    sizeof(calc.digest));\n\t\tif (rc)\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\txattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tcalc.digest, sizeof(calc.digest));\n\t\tif (!rc) {\n\t\t\t/* Replace RSA with HMAC if not mounted readonly and\n\t\t\t * not immutable\n\t\t\t */\n\t\t\tif (!IS_RDONLY(d_backing_inode(dentry)) &&\n\t\t\t    !IS_IMMUTABLE(d_backing_inode(dentry)))\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tevm_status = (rc == -ENODATA) ?\n\t\t\t\tINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_initialized;\n\nstatic enum integrity_status evm_verify_current_integrity(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\tif (!evm_initialized || !S_ISREG(inode->i_mode) || evm_fixmode)\n\t\treturn 0;\n\treturn evm_verify_hmac(dentry, NULL, NULL, 0, NULL);\n}"
  },
  {
    "function_name": "evm_verifyxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "239-254",
    "snippet": "enum integrity_status evm_verifyxattr(struct dentry *dentry,\n\t\t\t\t      const char *xattr_name,\n\t\t\t\t      void *xattr_value, size_t xattr_value_len,\n\t\t\t\t      struct integrity_iint_cache *iint)\n{\n\tif (!evm_initialized || !evm_protected_xattr(xattr_name))\n\t\treturn INTEGRITY_UNKNOWN;\n\n\tif (!iint) {\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (!iint)\n\t\t\treturn INTEGRITY_UNKNOWN;\n\t}\n\treturn evm_verify_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t xattr_value_len, iint);\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int evm_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "evm_verify_hmac",
          "args": [
            "dentry",
            "xattr_name",
            "xattr_value",
            "xattr_value_len",
            "iint"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "evm_verify_hmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "115-198",
          "snippet": "static enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct evm_ima_xattr_data calc;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tint rc, xattr_len;\n\n\tif (iint && iint->evm_status == INTEGRITY_PASS)\n\t\treturn iint->evm_status;\n\n\t/* if status is not PASS, try to check again - against -ENOMEM */\n\n\t/* first need to know the sig type */\n\trc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS; /* new file */\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t/* check value type */\n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\tif (xattr_len != sizeof(struct evm_ima_xattr_data)) {\n\t\t\tevm_status = INTEGRITY_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = crypto_memneq(xattr_data->digest, calc.digest,\n\t\t\t    sizeof(calc.digest));\n\t\tif (rc)\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\txattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tcalc.digest, sizeof(calc.digest));\n\t\tif (!rc) {\n\t\t\t/* Replace RSA with HMAC if not mounted readonly and\n\t\t\t * not immutable\n\t\t\t */\n\t\t\tif (!IS_RDONLY(d_backing_inode(dentry)) &&\n\t\t\t    !IS_IMMUTABLE(d_backing_inode(dentry)))\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tevm_status = (rc == -ENODATA) ?\n\t\t\t\tINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct evm_ima_xattr_data calc;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tint rc, xattr_len;\n\n\tif (iint && iint->evm_status == INTEGRITY_PASS)\n\t\treturn iint->evm_status;\n\n\t/* if status is not PASS, try to check again - against -ENOMEM */\n\n\t/* first need to know the sig type */\n\trc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS; /* new file */\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t/* check value type */\n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\tif (xattr_len != sizeof(struct evm_ima_xattr_data)) {\n\t\t\tevm_status = INTEGRITY_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = crypto_memneq(xattr_data->digest, calc.digest,\n\t\t\t    sizeof(calc.digest));\n\t\tif (rc)\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\txattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tcalc.digest, sizeof(calc.digest));\n\t\tif (!rc) {\n\t\t\t/* Replace RSA with HMAC if not mounted readonly and\n\t\t\t * not immutable\n\t\t\t */\n\t\t\tif (!IS_RDONLY(d_backing_inode(dentry)) &&\n\t\t\t    !IS_IMMUTABLE(d_backing_inode(dentry)))\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tevm_status = (rc == -ENODATA) ?\n\t\t\t\tINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "integrity_iint_find",
          "args": [
            "d_backing_inode(dentry)"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_iint_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/iint.c",
          "lines": "57-69",
          "snippet": "struct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(integrity_iint_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(integrity_iint_lock);\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evm_protected_xattr",
          "args": [
            "xattr_name"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "evm_protected_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "200-221",
          "snippet": "static int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_initialized;\n\nenum integrity_status evm_verifyxattr(struct dentry *dentry,\n\t\t\t\t      const char *xattr_name,\n\t\t\t\t      void *xattr_value, size_t xattr_value_len,\n\t\t\t\t      struct integrity_iint_cache *iint)\n{\n\tif (!evm_initialized || !evm_protected_xattr(xattr_name))\n\t\treturn INTEGRITY_UNKNOWN;\n\n\tif (!iint) {\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (!iint)\n\t\t\treturn INTEGRITY_UNKNOWN;\n\t}\n\treturn evm_verify_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t xattr_value_len, iint);\n}"
  },
  {
    "function_name": "evm_protected_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "200-221",
    "snippet": "static int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "req_xattr_name",
            "*xattrname + XATTR_SECURITY_PREFIX_LEN",
            "strlen(req_xattr_name)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "req_xattr_name"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "req_xattr_name",
            "*xattrname",
            "namelen"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*xattrname"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "req_xattr_name"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}"
  },
  {
    "function_name": "evm_verify_hmac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "115-198",
    "snippet": "static enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct evm_ima_xattr_data calc;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tint rc, xattr_len;\n\n\tif (iint && iint->evm_status == INTEGRITY_PASS)\n\t\treturn iint->evm_status;\n\n\t/* if status is not PASS, try to check again - against -ENOMEM */\n\n\t/* first need to know the sig type */\n\trc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS; /* new file */\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t/* check value type */\n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\tif (xattr_len != sizeof(struct evm_ima_xattr_data)) {\n\t\t\tevm_status = INTEGRITY_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = crypto_memneq(xattr_data->digest, calc.digest,\n\t\t\t    sizeof(calc.digest));\n\t\tif (rc)\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\txattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tcalc.digest, sizeof(calc.digest));\n\t\tif (!rc) {\n\t\t\t/* Replace RSA with HMAC if not mounted readonly and\n\t\t\t * not immutable\n\t\t\t */\n\t\t\tif (!IS_RDONLY(d_backing_inode(dentry)) &&\n\t\t\t    !IS_IMMUTABLE(d_backing_inode(dentry)))\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tevm_status = (rc == -ENODATA) ?\n\t\t\t\tINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr_data"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evm_update_evmxattr",
          "args": [
            "dentry",
            "xattr_name",
            "xattr_value",
            "xattr_value_len"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "evm_update_evmxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "251-269",
          "snippet": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t} else if (rc == -ENODATA && (inode->i_opflags & IOP_XATTR)) {\n\t\trc = __vfs_removexattr(dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t} else if (rc == -ENODATA && (inode->i_opflags & IOP_XATTR)) {\n\t\trc = __vfs_removexattr(dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "d_backing_inode(dentry)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_RDONLY",
          "args": [
            "d_backing_inode(dentry)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "integrity_digsig_verify",
          "args": [
            "INTEGRITY_KEYRING_EVM",
            "(const char *)xattr_data",
            "xattr_len",
            "calc.digest",
            "sizeof(calc.digest)"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_digsig_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "137-142",
          "snippet": "static inline int integrity_digsig_verify(const unsigned int id,\n\t\t\t\t\t  const char *sig, int siglen,\n\t\t\t\t\t  const char *digest, int digestlen)\n{\n\treturn -EOPNOTSUPP;\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct evm_ima_xattr_data {\n\tu8 type;\n\tu8 digest[SHA1_DIGEST_SIZE];\n} __packed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct evm_ima_xattr_data {\n\tu8 type;\n\tu8 digest[SHA1_DIGEST_SIZE];\n} __packed;\n\nstatic inline int integrity_digsig_verify(const unsigned int id,\n\t\t\t\t\t  const char *sig, int siglen,\n\t\t\t\t\t  const char *digest, int digestlen)\n{\n\treturn -EOPNOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "evm_calc_hash",
          "args": [
            "dentry",
            "xattr_name",
            "xattr_value",
            "xattr_value_len",
            "calc.digest"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "evm_calc_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "238-244",
          "snippet": "int evm_calc_hash(struct dentry *dentry, const char *req_xattr_name,\n\t\t  const char *req_xattr_value, size_t req_xattr_value_len,\n\t\t  char *digest)\n{\n\treturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\n\t\t\t\treq_xattr_value_len, IMA_XATTR_DIGEST, digest);\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_calc_hash(struct dentry *dentry, const char *req_xattr_name,\n\t\t  const char *req_xattr_value, size_t req_xattr_value_len,\n\t\t  char *digest)\n{\n\treturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\n\t\t\t\treq_xattr_value_len, IMA_XATTR_DIGEST, digest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_memneq",
          "args": [
            "xattr_data->digest",
            "calc.digest",
            "sizeof(calc.digest)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evm_calc_hmac",
          "args": [
            "dentry",
            "xattr_name",
            "xattr_value",
            "xattr_value_len",
            "calc.digest"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "evm_calc_hmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "230-236",
          "snippet": "int evm_calc_hmac(struct dentry *dentry, const char *req_xattr_name,\n\t\t  const char *req_xattr_value, size_t req_xattr_value_len,\n\t\t  char *digest)\n{\n\treturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\n\t\t\t\treq_xattr_value_len, EVM_XATTR_HMAC, digest);\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_calc_hmac(struct dentry *dentry, const char *req_xattr_name,\n\t\t  const char *req_xattr_value, size_t req_xattr_value_len,\n\t\t  char *digest)\n{\n\treturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\n\t\t\t\treq_xattr_value_len, EVM_XATTR_HMAC, digest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "evm_find_protected_xattrs",
          "args": [
            "dentry"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "evm_find_protected_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "79-100",
          "snippet": "static int evm_find_protected_xattrs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tchar **xattr;\n\tint error;\n\tint count = 0;\n\n\tif (!(inode->i_opflags & IOP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tfor (xattr = evm_config_xattrnames; *xattr != NULL; xattr++) {\n\t\terror = __vfs_getxattr(dentry, inode, *xattr, NULL, 0);\n\t\tif (error < 0) {\n\t\t\tif (error == -ENODATA)\n\t\t\t\tcontinue;\n\t\t\treturn error;\n\t\t}\n\t\tcount++;\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int evm_find_protected_xattrs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tchar **xattr;\n\tint error;\n\tint count = 0;\n\n\tif (!(inode->i_opflags & IOP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tfor (xattr = evm_config_xattrnames; *xattr != NULL; xattr++) {\n\t\terror = __vfs_getxattr(dentry, inode, *xattr, NULL, 0);\n\t\tif (error < 0) {\n\t\t\tif (error == -ENODATA)\n\t\t\t\tcontinue;\n\t\t\treturn error;\n\t\t}\n\t\tcount++;\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_getxattr_alloc",
          "args": [
            "dentry",
            "XATTR_NAME_EVM",
            "(char **)&xattr_data",
            "0",
            "GFP_NOFS"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct evm_ima_xattr_data calc;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tint rc, xattr_len;\n\n\tif (iint && iint->evm_status == INTEGRITY_PASS)\n\t\treturn iint->evm_status;\n\n\t/* if status is not PASS, try to check again - against -ENOMEM */\n\n\t/* first need to know the sig type */\n\trc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS; /* new file */\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t/* check value type */\n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\tif (xattr_len != sizeof(struct evm_ima_xattr_data)) {\n\t\t\tevm_status = INTEGRITY_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = crypto_memneq(xattr_data->digest, calc.digest,\n\t\t\t    sizeof(calc.digest));\n\t\tif (rc)\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\txattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tcalc.digest, sizeof(calc.digest));\n\t\tif (!rc) {\n\t\t\t/* Replace RSA with HMAC if not mounted readonly and\n\t\t\t * not immutable\n\t\t\t */\n\t\t\tif (!IS_RDONLY(d_backing_inode(dentry)) &&\n\t\t\t    !IS_IMMUTABLE(d_backing_inode(dentry)))\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tevm_status = (rc == -ENODATA) ?\n\t\t\t\tINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}"
  },
  {
    "function_name": "evm_find_protected_xattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "79-100",
    "snippet": "static int evm_find_protected_xattrs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tchar **xattr;\n\tint error;\n\tint count = 0;\n\n\tif (!(inode->i_opflags & IOP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tfor (xattr = evm_config_xattrnames; *xattr != NULL; xattr++) {\n\t\terror = __vfs_getxattr(dentry, inode, *xattr, NULL, 0);\n\t\tif (error < 0) {\n\t\t\tif (error == -ENODATA)\n\t\t\t\tcontinue;\n\t\t\treturn error;\n\t\t}\n\t\tcount++;\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vfs_getxattr",
          "args": [
            "dentry",
            "inode",
            "*xattr",
            "NULL",
            "0"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int evm_find_protected_xattrs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tchar **xattr;\n\tint error;\n\tint count = 0;\n\n\tif (!(inode->i_opflags & IOP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tfor (xattr = evm_config_xattrnames; *xattr != NULL; xattr++) {\n\t\terror = __vfs_getxattr(dentry, inode, *xattr, NULL, 0);\n\t\tif (error < 0) {\n\t\t\tif (error == -ENODATA)\n\t\t\t\tcontinue;\n\t\t\treturn error;\n\t\t}\n\t\tcount++;\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "evm_init_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "71-77",
    "snippet": "static void __init evm_init_config(void)\n{\n#ifdef CONFIG_EVM_ATTR_FSUUID\n\tevm_hmac_attrs |= EVM_ATTR_FSUUID;\n#endif\n\tpr_info(\"HMAC attrs: 0x%x\\n\", evm_hmac_attrs);\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int evm_hmac_attrs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"HMAC attrs: 0x%x\\n\"",
            "evm_hmac_attrs"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_hmac_attrs;\n\nstatic void __init evm_init_config(void)\n{\n#ifdef CONFIG_EVM_ATTR_FSUUID\n\tevm_hmac_attrs |= EVM_ATTR_FSUUID;\n#endif\n\tpr_info(\"HMAC attrs: 0x%x\\n\", evm_hmac_attrs);\n}"
  },
  {
    "function_name": "evm_set_fixmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
    "lines": "63-68",
    "snippet": "static int __init evm_set_fixmode(char *str)\n{\n\tif (strncmp(str, \"fix\", 3) == 0)\n\t\tevm_fixmode = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/algapi.h>",
      "#include <crypto/hash.h>",
      "#include <linux/magic.h>",
      "#include <linux/evm.h>",
      "#include <linux/integrity.h>",
      "#include <linux/xattr.h>",
      "#include <linux/audit.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"fix\"",
            "3"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int __init evm_set_fixmode(char *str)\n{\n\tif (strncmp(str, \"fix\", 3) == 0)\n\t\tevm_fixmode = 1;\n\treturn 0;\n}"
  }
]