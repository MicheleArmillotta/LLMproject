[
  {
    "function_name": "logon_vet_description",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/user_defined.c",
    "lines": "198-212",
    "snippet": "static int logon_vet_description(const char *desc)\n{\n\tchar *p;\n\n\t/* require a \"qualified\" description string */\n\tp = strchr(desc, ':');\n\tif (!p)\n\t\treturn -EINVAL;\n\n\t/* also reject description with ':' as first char */\n\tif (p == desc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int logon_vet_description(const char *desc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "desc",
            "':'"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int logon_vet_description(const char *desc);\n\nstatic int logon_vet_description(const char *desc)\n{\n\tchar *p;\n\n\t/* require a \"qualified\" description string */\n\tp = strchr(desc, ':');\n\tif (!p)\n\t\treturn -EINVAL;\n\n\t/* also reject description with ':' as first char */\n\tif (p == desc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "user_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/user_defined.c",
    "lines": "175-193",
    "snippet": "long user_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tconst struct user_key_payload *upayload;\n\tlong ret;\n\n\tupayload = user_key_payload_locked(key);\n\tret = upayload->datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > upayload->datalen)\n\t\t\tbuflen = upayload->datalen;\n\n\t\tif (copy_to_user(buffer, upayload->data, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer",
            "upayload->data",
            "buflen"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_key_payload_locked",
          "args": [
            "key"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong user_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tconst struct user_key_payload *upayload;\n\tlong ret;\n\n\tupayload = user_key_payload_locked(key);\n\tret = upayload->datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > upayload->datalen)\n\t\t\tbuflen = upayload->datalen;\n\n\t\tif (copy_to_user(buffer, upayload->data, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "user_describe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/user_defined.c",
    "lines": "162-167",
    "snippet": "void user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\": %u\"",
            "key->datalen"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_is_positive",
          "args": [
            "key"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "key->description"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}"
  },
  {
    "function_name": "user_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/user_defined.c",
    "lines": "150-155",
    "snippet": "void user_destroy(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data[0];\n\n\tkzfree(upayload);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "upayload"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid user_destroy(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data[0];\n\n\tkzfree(upayload);\n}"
  },
  {
    "function_name": "user_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/user_defined.c",
    "lines": "132-143",
    "snippet": "void user_revoke(struct key *key)\n{\n\tstruct user_key_payload *upayload = user_key_payload_locked(key);\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\n\tif (upayload) {\n\t\trcu_assign_keypointer(key, NULL);\n\t\tcall_rcu(&upayload->rcu, user_free_payload_rcu);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&upayload->rcu",
            "user_free_payload_rcu"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_keypointer",
          "args": [
            "key",
            "NULL"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_payload_reserve",
          "args": [
            "key",
            "0"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "key_payload_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "370-401",
          "snippet": "int key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int key_quota_root_maxbytes = 25000000;",
            "unsigned int key_quota_maxbytes = 20000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nunsigned int key_quota_root_maxbytes = 25000000;\nunsigned int key_quota_maxbytes = 20000;\n\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_key_payload_locked",
          "args": [
            "key"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid user_revoke(struct key *key)\n{\n\tstruct user_key_payload *upayload = user_key_payload_locked(key);\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\n\tif (upayload) {\n\t\trcu_assign_keypointer(key, NULL);\n\t\tcall_rcu(&upayload->rcu, user_free_payload_rcu);\n\t}\n}"
  },
  {
    "function_name": "user_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/user_defined.c",
    "lines": "105-125",
    "snippet": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\n\t/* check the quota and attach the new data */\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* attach the new data, displacing the old */\n\tkey->expiry = prep->expiry;\n\tif (key_is_positive(key))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&zap->rcu",
            "user_free_payload_rcu"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_keypointer",
          "args": [
            "key",
            "prep->payload.data[0]"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dereference_key_locked",
          "args": [
            "key"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_is_positive",
          "args": [
            "key"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_payload_reserve",
          "args": [
            "key",
            "prep->datalen"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "key_payload_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "370-401",
          "snippet": "int key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int key_quota_root_maxbytes = 25000000;",
            "unsigned int key_quota_maxbytes = 20000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nunsigned int key_quota_root_maxbytes = 25000000;\nunsigned int key_quota_maxbytes = 20000;\n\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\n\t/* check the quota and attach the new data */\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* attach the new data, displacing the old */\n\tkey->expiry = prep->expiry;\n\tif (key_is_positive(key))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}"
  },
  {
    "function_name": "user_free_payload_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/user_defined.c",
    "lines": "93-99",
    "snippet": "static void user_free_payload_rcu(struct rcu_head *head)\n{\n\tstruct user_key_payload *payload;\n\n\tpayload = container_of(head, struct user_key_payload, rcu);\n\tkzfree(payload);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "payload"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structuser_key_payload",
            "rcu"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void user_free_payload_rcu(struct rcu_head *head)\n{\n\tstruct user_key_payload *payload;\n\n\tpayload = container_of(head, struct user_key_payload, rcu);\n\tkzfree(payload);\n}"
  },
  {
    "function_name": "user_free_preparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/user_defined.c",
    "lines": "87-90",
    "snippet": "void user_free_preparse(struct key_preparsed_payload *prep)\n{\n\tkzfree(prep->payload.data[0]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "prep->payload.data[0]"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid user_free_preparse(struct key_preparsed_payload *prep)\n{\n\tkzfree(prep->payload.data[0]);\n}"
  },
  {
    "function_name": "user_preparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/user_defined.c",
    "lines": "63-81",
    "snippet": "int user_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tsize_t datalen = prep->datalen;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\treturn -ENOMEM;\n\n\t/* attach the data */\n\tprep->quotalen = datalen;\n\tprep->payload.data[0] = upayload;\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "upayload->data",
            "prep->data",
            "datalen"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*upayload) + datalen",
            "GFP_KERNEL"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint user_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tsize_t datalen = prep->datalen;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\treturn -ENOMEM;\n\n\t/* attach the data */\n\tprep->quotalen = datalen;\n\tprep->payload.data[0] = upayload;\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\treturn 0;\n}"
  }
]