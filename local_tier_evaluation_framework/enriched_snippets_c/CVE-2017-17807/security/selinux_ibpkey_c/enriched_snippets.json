[
  {
    "function_name": "sel_ib_pkey_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ibpkey.c",
    "lines": "230-243",
    "snippet": "static __init int sel_ib_pkey_init(void)\n{\n\tint iter;\n\n\tif (!selinux_enabled)\n\t\treturn 0;\n\n\tfor (iter = 0; iter < SEL_PKEY_HASH_SIZE; iter++) {\n\t\tINIT_LIST_HEAD(&sel_ib_pkey_hash[iter].list);\n\t\tsel_ib_pkey_hash[iter].size = 0;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"ibpkey.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define SEL_PKEY_HASH_SIZE       256"
    ],
    "globals_used": [
      "static struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sel_ib_pkey_hash[iter].list"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"ibpkey.h\"\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_PKEY_HASH_SIZE       256\n\nstatic struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];\n\nstatic __init int sel_ib_pkey_init(void)\n{\n\tint iter;\n\n\tif (!selinux_enabled)\n\t\treturn 0;\n\n\tfor (iter = 0; iter < SEL_PKEY_HASH_SIZE; iter++) {\n\t\tINIT_LIST_HEAD(&sel_ib_pkey_hash[iter].list);\n\t\tsel_ib_pkey_hash[iter].size = 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sel_ib_pkey_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ibpkey.c",
    "lines": "212-228",
    "snippet": "void sel_ib_pkey_flush(void)\n{\n\tunsigned int idx;\n\tstruct sel_ib_pkey *pkey, *pkey_tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sel_ib_pkey_lock, flags);\n\tfor (idx = 0; idx < SEL_PKEY_HASH_SIZE; idx++) {\n\t\tlist_for_each_entry_safe(pkey, pkey_tmp,\n\t\t\t\t\t &sel_ib_pkey_hash[idx].list, list) {\n\t\t\tlist_del_rcu(&pkey->list);\n\t\t\tkfree_rcu(pkey, rcu);\n\t\t}\n\t\tsel_ib_pkey_hash[idx].size = 0;\n\t}\n\tspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"ibpkey.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define SEL_PKEY_HASH_SIZE       256"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(sel_ib_pkey_lock);",
      "static struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&sel_ib_pkey_lock",
            "flags"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "pkey",
            "rcu"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&pkey->list"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "pkey",
            "pkey_tmp",
            "&sel_ib_pkey_hash[idx].list",
            "list"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&sel_ib_pkey_lock",
            "flags"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"ibpkey.h\"\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_PKEY_HASH_SIZE       256\n\nstatic DEFINE_SPINLOCK(sel_ib_pkey_lock);\nstatic struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];\n\nvoid sel_ib_pkey_flush(void)\n{\n\tunsigned int idx;\n\tstruct sel_ib_pkey *pkey, *pkey_tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sel_ib_pkey_lock, flags);\n\tfor (idx = 0; idx < SEL_PKEY_HASH_SIZE; idx++) {\n\t\tlist_for_each_entry_safe(pkey, pkey_tmp,\n\t\t\t\t\t &sel_ib_pkey_hash[idx].list, list) {\n\t\t\tlist_del_rcu(&pkey->list);\n\t\t\tkfree_rcu(pkey, rcu);\n\t\t}\n\t\tsel_ib_pkey_hash[idx].size = 0;\n\t}\n\tspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\n}"
  },
  {
    "function_name": "sel_ib_pkey_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ibpkey.c",
    "lines": "189-203",
    "snippet": "int sel_ib_pkey_sid(u64 subnet_prefix, u16 pkey_num, u32 *sid)\n{\n\tstruct sel_ib_pkey *pkey;\n\n\trcu_read_lock();\n\tpkey = sel_ib_pkey_find(subnet_prefix, pkey_num);\n\tif (pkey) {\n\t\t*sid = pkey->psec.sid;\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\treturn sel_ib_pkey_sid_slow(subnet_prefix, pkey_num, sid);\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"ibpkey.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sel_ib_pkey_sid_slow",
          "args": [
            "subnet_prefix",
            "pkey_num",
            "sid"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "sel_ib_pkey_sid_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ibpkey.c",
          "lines": "140-174",
          "snippet": "static int sel_ib_pkey_sid_slow(u64 subnet_prefix, u16 pkey_num, u32 *sid)\n{\n\tint ret;\n\tstruct sel_ib_pkey *pkey;\n\tstruct sel_ib_pkey *new = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sel_ib_pkey_lock, flags);\n\tpkey = sel_ib_pkey_find(subnet_prefix, pkey_num);\n\tif (pkey) {\n\t\t*sid = pkey->psec.sid;\n\t\tspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\n\t\treturn 0;\n\t}\n\n\tret = security_ib_pkey_sid(subnet_prefix, pkey_num, sid);\n\tif (ret)\n\t\tgoto out;\n\n\t/* If this memory allocation fails still return 0. The SID\n\t * is valid, it just won't be added to the cache.\n\t */\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new)\n\t\tgoto out;\n\n\tnew->psec.subnet_prefix = subnet_prefix;\n\tnew->psec.pkey = pkey_num;\n\tnew->psec.sid = *sid;\n\tsel_ib_pkey_insert(new);\n\nout:\n\tspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"ibpkey.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sel_ib_pkey_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"ibpkey.h\"\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(sel_ib_pkey_lock);\n\nstatic int sel_ib_pkey_sid_slow(u64 subnet_prefix, u16 pkey_num, u32 *sid)\n{\n\tint ret;\n\tstruct sel_ib_pkey *pkey;\n\tstruct sel_ib_pkey *new = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sel_ib_pkey_lock, flags);\n\tpkey = sel_ib_pkey_find(subnet_prefix, pkey_num);\n\tif (pkey) {\n\t\t*sid = pkey->psec.sid;\n\t\tspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\n\t\treturn 0;\n\t}\n\n\tret = security_ib_pkey_sid(subnet_prefix, pkey_num, sid);\n\tif (ret)\n\t\tgoto out;\n\n\t/* If this memory allocation fails still return 0. The SID\n\t * is valid, it just won't be added to the cache.\n\t */\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new)\n\t\tgoto out;\n\n\tnew->psec.subnet_prefix = subnet_prefix;\n\tnew->psec.pkey = pkey_num;\n\tnew->psec.sid = *sid;\n\tsel_ib_pkey_insert(new);\n\nout:\n\tspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_ib_pkey_find",
          "args": [
            "subnet_prefix",
            "pkey_num"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "sel_ib_pkey_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ibpkey.c",
          "lines": "81-94",
          "snippet": "static struct sel_ib_pkey *sel_ib_pkey_find(u64 subnet_prefix, u16 pkey_num)\n{\n\tunsigned int idx;\n\tstruct sel_ib_pkey *pkey;\n\n\tidx = sel_ib_pkey_hashfn(pkey_num);\n\tlist_for_each_entry_rcu(pkey, &sel_ib_pkey_hash[idx].list, list) {\n\t\tif (pkey->psec.pkey == pkey_num &&\n\t\t    pkey->psec.subnet_prefix == subnet_prefix)\n\t\t\treturn pkey;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"ibpkey.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"ibpkey.h\"\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\nstatic struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];\n\nstatic struct sel_ib_pkey *sel_ib_pkey_find(u64 subnet_prefix, u16 pkey_num)\n{\n\tunsigned int idx;\n\tstruct sel_ib_pkey *pkey;\n\n\tidx = sel_ib_pkey_hashfn(pkey_num);\n\tlist_for_each_entry_rcu(pkey, &sel_ib_pkey_hash[idx].list, list) {\n\t\tif (pkey->psec.pkey == pkey_num &&\n\t\t    pkey->psec.subnet_prefix == subnet_prefix)\n\t\t\treturn pkey;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"ibpkey.h\"\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\nint sel_ib_pkey_sid(u64 subnet_prefix, u16 pkey_num, u32 *sid)\n{\n\tstruct sel_ib_pkey *pkey;\n\n\trcu_read_lock();\n\tpkey = sel_ib_pkey_find(subnet_prefix, pkey_num);\n\tif (pkey) {\n\t\t*sid = pkey->psec.sid;\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\treturn sel_ib_pkey_sid_slow(subnet_prefix, pkey_num, sid);\n}"
  },
  {
    "function_name": "sel_ib_pkey_sid_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ibpkey.c",
    "lines": "140-174",
    "snippet": "static int sel_ib_pkey_sid_slow(u64 subnet_prefix, u16 pkey_num, u32 *sid)\n{\n\tint ret;\n\tstruct sel_ib_pkey *pkey;\n\tstruct sel_ib_pkey *new = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sel_ib_pkey_lock, flags);\n\tpkey = sel_ib_pkey_find(subnet_prefix, pkey_num);\n\tif (pkey) {\n\t\t*sid = pkey->psec.sid;\n\t\tspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\n\t\treturn 0;\n\t}\n\n\tret = security_ib_pkey_sid(subnet_prefix, pkey_num, sid);\n\tif (ret)\n\t\tgoto out;\n\n\t/* If this memory allocation fails still return 0. The SID\n\t * is valid, it just won't be added to the cache.\n\t */\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new)\n\t\tgoto out;\n\n\tnew->psec.subnet_prefix = subnet_prefix;\n\tnew->psec.pkey = pkey_num;\n\tnew->psec.sid = *sid;\n\tsel_ib_pkey_insert(new);\n\nout:\n\tspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"ibpkey.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sel_ib_pkey_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&sel_ib_pkey_lock",
            "flags"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_ib_pkey_insert",
          "args": [
            "new"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "sel_ib_pkey_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ibpkey.c",
          "lines": "104-126",
          "snippet": "static void sel_ib_pkey_insert(struct sel_ib_pkey *pkey)\n{\n\tunsigned int idx;\n\n\t/* we need to impose a limit on the growth of the hash table so check\n\t * this bucket to make sure it is within the specified bounds\n\t */\n\tidx = sel_ib_pkey_hashfn(pkey->psec.pkey);\n\tlist_add_rcu(&pkey->list, &sel_ib_pkey_hash[idx].list);\n\tif (sel_ib_pkey_hash[idx].size == SEL_PKEY_HASH_BKT_LIMIT) {\n\t\tstruct sel_ib_pkey *tail;\n\n\t\ttail = list_entry(\n\t\t\trcu_dereference_protected(\n\t\t\t\tsel_ib_pkey_hash[idx].list.prev,\n\t\t\t\tlockdep_is_held(&sel_ib_pkey_lock)),\n\t\t\tstruct sel_ib_pkey, list);\n\t\tlist_del_rcu(&tail->list);\n\t\tkfree_rcu(tail, rcu);\n\t} else {\n\t\tsel_ib_pkey_hash[idx].size++;\n\t}\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"ibpkey.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define SEL_PKEY_HASH_BKT_LIMIT   16"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(sel_ib_pkey_lock);",
            "static struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"ibpkey.h\"\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_PKEY_HASH_BKT_LIMIT   16\n\nstatic DEFINE_SPINLOCK(sel_ib_pkey_lock);\nstatic struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];\n\nstatic void sel_ib_pkey_insert(struct sel_ib_pkey *pkey)\n{\n\tunsigned int idx;\n\n\t/* we need to impose a limit on the growth of the hash table so check\n\t * this bucket to make sure it is within the specified bounds\n\t */\n\tidx = sel_ib_pkey_hashfn(pkey->psec.pkey);\n\tlist_add_rcu(&pkey->list, &sel_ib_pkey_hash[idx].list);\n\tif (sel_ib_pkey_hash[idx].size == SEL_PKEY_HASH_BKT_LIMIT) {\n\t\tstruct sel_ib_pkey *tail;\n\n\t\ttail = list_entry(\n\t\t\trcu_dereference_protected(\n\t\t\t\tsel_ib_pkey_hash[idx].list.prev,\n\t\t\t\tlockdep_is_held(&sel_ib_pkey_lock)),\n\t\t\tstruct sel_ib_pkey, list);\n\t\tlist_del_rcu(&tail->list);\n\t\tkfree_rcu(tail, rcu);\n\t} else {\n\t\tsel_ib_pkey_hash[idx].size++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new)",
            "GFP_ATOMIC"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_ib_pkey_sid",
          "args": [
            "subnet_prefix",
            "pkey_num",
            "sid"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "security_ib_pkey_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2254-2286",
          "snippet": "int security_ib_pkey_sid(u64 subnet_prefix, u16 pkey_num, u32 *out_sid)\n{\n\tstruct ocontext *c;\n\tint rc = 0;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_IBPKEY];\n\twhile (c) {\n\t\tif (c->u.ibpkey.low_pkey <= pkey_num &&\n\t\t    c->u.ibpkey.high_pkey >= pkey_num &&\n\t\t    c->u.ibpkey.subnet_prefix == subnet_prefix)\n\t\t\tbreak;\n\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else\n\t\t*out_sid = SECINITSID_UNLABELED;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\n\nint security_ib_pkey_sid(u64 subnet_prefix, u16 pkey_num, u32 *out_sid)\n{\n\tstruct ocontext *c;\n\tint rc = 0;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_IBPKEY];\n\twhile (c) {\n\t\tif (c->u.ibpkey.low_pkey <= pkey_num &&\n\t\t    c->u.ibpkey.high_pkey >= pkey_num &&\n\t\t    c->u.ibpkey.subnet_prefix == subnet_prefix)\n\t\t\tbreak;\n\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else\n\t\t*out_sid = SECINITSID_UNLABELED;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&sel_ib_pkey_lock",
            "flags"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_ib_pkey_find",
          "args": [
            "subnet_prefix",
            "pkey_num"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "sel_ib_pkey_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ibpkey.c",
          "lines": "81-94",
          "snippet": "static struct sel_ib_pkey *sel_ib_pkey_find(u64 subnet_prefix, u16 pkey_num)\n{\n\tunsigned int idx;\n\tstruct sel_ib_pkey *pkey;\n\n\tidx = sel_ib_pkey_hashfn(pkey_num);\n\tlist_for_each_entry_rcu(pkey, &sel_ib_pkey_hash[idx].list, list) {\n\t\tif (pkey->psec.pkey == pkey_num &&\n\t\t    pkey->psec.subnet_prefix == subnet_prefix)\n\t\t\treturn pkey;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"ibpkey.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"ibpkey.h\"\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\nstatic struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];\n\nstatic struct sel_ib_pkey *sel_ib_pkey_find(u64 subnet_prefix, u16 pkey_num)\n{\n\tunsigned int idx;\n\tstruct sel_ib_pkey *pkey;\n\n\tidx = sel_ib_pkey_hashfn(pkey_num);\n\tlist_for_each_entry_rcu(pkey, &sel_ib_pkey_hash[idx].list, list) {\n\t\tif (pkey->psec.pkey == pkey_num &&\n\t\t    pkey->psec.subnet_prefix == subnet_prefix)\n\t\t\treturn pkey;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&sel_ib_pkey_lock",
            "flags"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"ibpkey.h\"\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(sel_ib_pkey_lock);\n\nstatic int sel_ib_pkey_sid_slow(u64 subnet_prefix, u16 pkey_num, u32 *sid)\n{\n\tint ret;\n\tstruct sel_ib_pkey *pkey;\n\tstruct sel_ib_pkey *new = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sel_ib_pkey_lock, flags);\n\tpkey = sel_ib_pkey_find(subnet_prefix, pkey_num);\n\tif (pkey) {\n\t\t*sid = pkey->psec.sid;\n\t\tspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\n\t\treturn 0;\n\t}\n\n\tret = security_ib_pkey_sid(subnet_prefix, pkey_num, sid);\n\tif (ret)\n\t\tgoto out;\n\n\t/* If this memory allocation fails still return 0. The SID\n\t * is valid, it just won't be added to the cache.\n\t */\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new)\n\t\tgoto out;\n\n\tnew->psec.subnet_prefix = subnet_prefix;\n\tnew->psec.pkey = pkey_num;\n\tnew->psec.sid = *sid;\n\tsel_ib_pkey_insert(new);\n\nout:\n\tspin_unlock_irqrestore(&sel_ib_pkey_lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "sel_ib_pkey_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ibpkey.c",
    "lines": "104-126",
    "snippet": "static void sel_ib_pkey_insert(struct sel_ib_pkey *pkey)\n{\n\tunsigned int idx;\n\n\t/* we need to impose a limit on the growth of the hash table so check\n\t * this bucket to make sure it is within the specified bounds\n\t */\n\tidx = sel_ib_pkey_hashfn(pkey->psec.pkey);\n\tlist_add_rcu(&pkey->list, &sel_ib_pkey_hash[idx].list);\n\tif (sel_ib_pkey_hash[idx].size == SEL_PKEY_HASH_BKT_LIMIT) {\n\t\tstruct sel_ib_pkey *tail;\n\n\t\ttail = list_entry(\n\t\t\trcu_dereference_protected(\n\t\t\t\tsel_ib_pkey_hash[idx].list.prev,\n\t\t\t\tlockdep_is_held(&sel_ib_pkey_lock)),\n\t\t\tstruct sel_ib_pkey, list);\n\t\tlist_del_rcu(&tail->list);\n\t\tkfree_rcu(tail, rcu);\n\t} else {\n\t\tsel_ib_pkey_hash[idx].size++;\n\t}\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"ibpkey.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define SEL_PKEY_HASH_BKT_LIMIT   16"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(sel_ib_pkey_lock);",
      "static struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "tail",
            "rcu"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&tail->list"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "rcu_dereference_protected(\n\t\t\t\tsel_ib_pkey_hash[idx].list.prev,\n\t\t\t\tlockdep_is_held(&sel_ib_pkey_lock))",
            "structsel_ib_pkey",
            "list"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "sel_ib_pkey_hash[idx].list.prev",
            "lockdep_is_held(&sel_ib_pkey_lock)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&sel_ib_pkey_lock"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&pkey->list",
            "&sel_ib_pkey_hash[idx].list"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_ib_pkey_hashfn",
          "args": [
            "pkey->psec.pkey"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "sel_ib_pkey_hashfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ibpkey.c",
          "lines": "66-69",
          "snippet": "static unsigned int sel_ib_pkey_hashfn(u16 pkey)\n{\n\treturn (pkey & (SEL_PKEY_HASH_SIZE - 1));\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"ibpkey.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define SEL_PKEY_HASH_SIZE       256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"ibpkey.h\"\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_PKEY_HASH_SIZE       256\n\nstatic unsigned int sel_ib_pkey_hashfn(u16 pkey)\n{\n\treturn (pkey & (SEL_PKEY_HASH_SIZE - 1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"ibpkey.h\"\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_PKEY_HASH_BKT_LIMIT   16\n\nstatic DEFINE_SPINLOCK(sel_ib_pkey_lock);\nstatic struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];\n\nstatic void sel_ib_pkey_insert(struct sel_ib_pkey *pkey)\n{\n\tunsigned int idx;\n\n\t/* we need to impose a limit on the growth of the hash table so check\n\t * this bucket to make sure it is within the specified bounds\n\t */\n\tidx = sel_ib_pkey_hashfn(pkey->psec.pkey);\n\tlist_add_rcu(&pkey->list, &sel_ib_pkey_hash[idx].list);\n\tif (sel_ib_pkey_hash[idx].size == SEL_PKEY_HASH_BKT_LIMIT) {\n\t\tstruct sel_ib_pkey *tail;\n\n\t\ttail = list_entry(\n\t\t\trcu_dereference_protected(\n\t\t\t\tsel_ib_pkey_hash[idx].list.prev,\n\t\t\t\tlockdep_is_held(&sel_ib_pkey_lock)),\n\t\t\tstruct sel_ib_pkey, list);\n\t\tlist_del_rcu(&tail->list);\n\t\tkfree_rcu(tail, rcu);\n\t} else {\n\t\tsel_ib_pkey_hash[idx].size++;\n\t}\n}"
  },
  {
    "function_name": "sel_ib_pkey_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ibpkey.c",
    "lines": "81-94",
    "snippet": "static struct sel_ib_pkey *sel_ib_pkey_find(u64 subnet_prefix, u16 pkey_num)\n{\n\tunsigned int idx;\n\tstruct sel_ib_pkey *pkey;\n\n\tidx = sel_ib_pkey_hashfn(pkey_num);\n\tlist_for_each_entry_rcu(pkey, &sel_ib_pkey_hash[idx].list, list) {\n\t\tif (pkey->psec.pkey == pkey_num &&\n\t\t    pkey->psec.subnet_prefix == subnet_prefix)\n\t\t\treturn pkey;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"ibpkey.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "pkey",
            "&sel_ib_pkey_hash[idx].list",
            "list"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_ib_pkey_hashfn",
          "args": [
            "pkey_num"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "sel_ib_pkey_hashfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ibpkey.c",
          "lines": "66-69",
          "snippet": "static unsigned int sel_ib_pkey_hashfn(u16 pkey)\n{\n\treturn (pkey & (SEL_PKEY_HASH_SIZE - 1));\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"ibpkey.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define SEL_PKEY_HASH_SIZE       256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"ibpkey.h\"\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_PKEY_HASH_SIZE       256\n\nstatic unsigned int sel_ib_pkey_hashfn(u16 pkey)\n{\n\treturn (pkey & (SEL_PKEY_HASH_SIZE - 1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"ibpkey.h\"\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\nstatic struct sel_ib_pkey_bkt sel_ib_pkey_hash[SEL_PKEY_HASH_SIZE];\n\nstatic struct sel_ib_pkey *sel_ib_pkey_find(u64 subnet_prefix, u16 pkey_num)\n{\n\tunsigned int idx;\n\tstruct sel_ib_pkey *pkey;\n\n\tidx = sel_ib_pkey_hashfn(pkey_num);\n\tlist_for_each_entry_rcu(pkey, &sel_ib_pkey_hash[idx].list, list) {\n\t\tif (pkey->psec.pkey == pkey_num &&\n\t\t    pkey->psec.subnet_prefix == subnet_prefix)\n\t\t\treturn pkey;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "sel_ib_pkey_hashfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ibpkey.c",
    "lines": "66-69",
    "snippet": "static unsigned int sel_ib_pkey_hashfn(u16 pkey)\n{\n\treturn (pkey & (SEL_PKEY_HASH_SIZE - 1));\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"ibpkey.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define SEL_PKEY_HASH_SIZE       256"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"ibpkey.h\"\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_PKEY_HASH_SIZE       256\n\nstatic unsigned int sel_ib_pkey_hashfn(u16 pkey)\n{\n\treturn (pkey & (SEL_PKEY_HASH_SIZE - 1));\n}"
  }
]