[
  {
    "function_name": "smack_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4853-4900",
    "snippet": "static __init int smack_init(void)\n{\n\tstruct cred *cred;\n\tstruct task_smack *tsp;\n\n\tif (!security_module_enable(\"smack\"))\n\t\treturn 0;\n\n\tsmack_inode_cache = KMEM_CACHE(inode_smack, 0);\n\tif (!smack_inode_cache)\n\t\treturn -ENOMEM;\n\n\ttsp = new_task_smack(&smack_known_floor, &smack_known_floor,\n\t\t\t\tGFP_KERNEL);\n\tif (tsp == NULL) {\n\t\tkmem_cache_destroy(smack_inode_cache);\n\t\treturn -ENOMEM;\n\t}\n\n\tsmack_enabled = 1;\n\n\tpr_info(\"Smack:  Initializing.\\n\");\n#ifdef CONFIG_SECURITY_SMACK_NETFILTER\n\tpr_info(\"Smack:  Netfilter enabled.\\n\");\n#endif\n#ifdef SMACK_IPV6_PORT_LABELING\n\tpr_info(\"Smack:  IPv6 port labeling enabled.\\n\");\n#endif\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\tpr_info(\"Smack:  IPv6 Netfilter enabled.\\n\");\n#endif\n\n\t/*\n\t * Set the security state for the initial task.\n\t */\n\tcred = (struct cred *) current->cred;\n\tcred->security = tsp;\n\n\t/* initialize the smack_known_list */\n\tinit_smack_known_list();\n\n\t/*\n\t * Register with LSM\n\t */\n\tsecurity_add_hooks(smack_hooks, ARRAY_SIZE(smack_hooks), \"smack\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *smack_inode_cache;",
      "int smack_enabled;",
      "static struct security_hook_list smack_hooks[] __lsm_ro_after_init = {\n\tLSM_HOOK_INIT(ptrace_access_check, smack_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, smack_ptrace_traceme),\n\tLSM_HOOK_INIT(syslog, smack_syslog),\n\n\tLSM_HOOK_INIT(sb_alloc_security, smack_sb_alloc_security),\n\tLSM_HOOK_INIT(sb_free_security, smack_sb_free_security),\n\tLSM_HOOK_INIT(sb_copy_data, smack_sb_copy_data),\n\tLSM_HOOK_INIT(sb_kern_mount, smack_sb_kern_mount),\n\tLSM_HOOK_INIT(sb_statfs, smack_sb_statfs),\n\tLSM_HOOK_INIT(sb_set_mnt_opts, smack_set_mnt_opts),\n\tLSM_HOOK_INIT(sb_parse_opts_str, smack_parse_opts_str),\n\n\tLSM_HOOK_INIT(bprm_set_creds, smack_bprm_set_creds),\n\n\tLSM_HOOK_INIT(inode_alloc_security, smack_inode_alloc_security),\n\tLSM_HOOK_INIT(inode_free_security, smack_inode_free_security),\n\tLSM_HOOK_INIT(inode_init_security, smack_inode_init_security),\n\tLSM_HOOK_INIT(inode_link, smack_inode_link),\n\tLSM_HOOK_INIT(inode_unlink, smack_inode_unlink),\n\tLSM_HOOK_INIT(inode_rmdir, smack_inode_rmdir),\n\tLSM_HOOK_INIT(inode_rename, smack_inode_rename),\n\tLSM_HOOK_INIT(inode_permission, smack_inode_permission),\n\tLSM_HOOK_INIT(inode_setattr, smack_inode_setattr),\n\tLSM_HOOK_INIT(inode_getattr, smack_inode_getattr),\n\tLSM_HOOK_INIT(inode_setxattr, smack_inode_setxattr),\n\tLSM_HOOK_INIT(inode_post_setxattr, smack_inode_post_setxattr),\n\tLSM_HOOK_INIT(inode_getxattr, smack_inode_getxattr),\n\tLSM_HOOK_INIT(inode_removexattr, smack_inode_removexattr),\n\tLSM_HOOK_INIT(inode_getsecurity, smack_inode_getsecurity),\n\tLSM_HOOK_INIT(inode_setsecurity, smack_inode_setsecurity),\n\tLSM_HOOK_INIT(inode_listsecurity, smack_inode_listsecurity),\n\tLSM_HOOK_INIT(inode_getsecid, smack_inode_getsecid),\n\n\tLSM_HOOK_INIT(file_alloc_security, smack_file_alloc_security),\n\tLSM_HOOK_INIT(file_free_security, smack_file_free_security),\n\tLSM_HOOK_INIT(file_ioctl, smack_file_ioctl),\n\tLSM_HOOK_INIT(file_lock, smack_file_lock),\n\tLSM_HOOK_INIT(file_fcntl, smack_file_fcntl),\n\tLSM_HOOK_INIT(mmap_file, smack_mmap_file),\n\tLSM_HOOK_INIT(mmap_addr, cap_mmap_addr),\n\tLSM_HOOK_INIT(file_set_fowner, smack_file_set_fowner),\n\tLSM_HOOK_INIT(file_send_sigiotask, smack_file_send_sigiotask),\n\tLSM_HOOK_INIT(file_receive, smack_file_receive),\n\n\tLSM_HOOK_INIT(file_open, smack_file_open),\n\n\tLSM_HOOK_INIT(cred_alloc_blank, smack_cred_alloc_blank),\n\tLSM_HOOK_INIT(cred_free, smack_cred_free),\n\tLSM_HOOK_INIT(cred_prepare, smack_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, smack_cred_transfer),\n\tLSM_HOOK_INIT(kernel_act_as, smack_kernel_act_as),\n\tLSM_HOOK_INIT(kernel_create_files_as, smack_kernel_create_files_as),\n\tLSM_HOOK_INIT(task_setpgid, smack_task_setpgid),\n\tLSM_HOOK_INIT(task_getpgid, smack_task_getpgid),\n\tLSM_HOOK_INIT(task_getsid, smack_task_getsid),\n\tLSM_HOOK_INIT(task_getsecid, smack_task_getsecid),\n\tLSM_HOOK_INIT(task_setnice, smack_task_setnice),\n\tLSM_HOOK_INIT(task_setioprio, smack_task_setioprio),\n\tLSM_HOOK_INIT(task_getioprio, smack_task_getioprio),\n\tLSM_HOOK_INIT(task_setscheduler, smack_task_setscheduler),\n\tLSM_HOOK_INIT(task_getscheduler, smack_task_getscheduler),\n\tLSM_HOOK_INIT(task_movememory, smack_task_movememory),\n\tLSM_HOOK_INIT(task_kill, smack_task_kill),\n\tLSM_HOOK_INIT(task_to_inode, smack_task_to_inode),\n\n\tLSM_HOOK_INIT(ipc_permission, smack_ipc_permission),\n\tLSM_HOOK_INIT(ipc_getsecid, smack_ipc_getsecid),\n\n\tLSM_HOOK_INIT(msg_msg_alloc_security, smack_msg_msg_alloc_security),\n\tLSM_HOOK_INIT(msg_msg_free_security, smack_msg_msg_free_security),\n\n\tLSM_HOOK_INIT(msg_queue_alloc_security, smack_msg_queue_alloc_security),\n\tLSM_HOOK_INIT(msg_queue_free_security, smack_msg_queue_free_security),\n\tLSM_HOOK_INIT(msg_queue_associate, smack_msg_queue_associate),\n\tLSM_HOOK_INIT(msg_queue_msgctl, smack_msg_queue_msgctl),\n\tLSM_HOOK_INIT(msg_queue_msgsnd, smack_msg_queue_msgsnd),\n\tLSM_HOOK_INIT(msg_queue_msgrcv, smack_msg_queue_msgrcv),\n\n\tLSM_HOOK_INIT(shm_alloc_security, smack_shm_alloc_security),\n\tLSM_HOOK_INIT(shm_free_security, smack_shm_free_security),\n\tLSM_HOOK_INIT(shm_associate, smack_shm_associate),\n\tLSM_HOOK_INIT(shm_shmctl, smack_shm_shmctl),\n\tLSM_HOOK_INIT(shm_shmat, smack_shm_shmat),\n\n\tLSM_HOOK_INIT(sem_alloc_security, smack_sem_alloc_security),\n\tLSM_HOOK_INIT(sem_free_security, smack_sem_free_security),\n\tLSM_HOOK_INIT(sem_associate, smack_sem_associate),\n\tLSM_HOOK_INIT(sem_semctl, smack_sem_semctl),\n\tLSM_HOOK_INIT(sem_semop, smack_sem_semop),\n\n\tLSM_HOOK_INIT(d_instantiate, smack_d_instantiate),\n\n\tLSM_HOOK_INIT(getprocattr, smack_getprocattr),\n\tLSM_HOOK_INIT(setprocattr, smack_setprocattr),\n\n\tLSM_HOOK_INIT(unix_stream_connect, smack_unix_stream_connect),\n\tLSM_HOOK_INIT(unix_may_send, smack_unix_may_send),\n\n\tLSM_HOOK_INIT(socket_post_create, smack_socket_post_create),\n#ifdef SMACK_IPV6_PORT_LABELING\n\tLSM_HOOK_INIT(socket_bind, smack_socket_bind),\n#endif\n\tLSM_HOOK_INIT(socket_connect, smack_socket_connect),\n\tLSM_HOOK_INIT(socket_sendmsg, smack_socket_sendmsg),\n\tLSM_HOOK_INIT(socket_sock_rcv_skb, smack_socket_sock_rcv_skb),\n\tLSM_HOOK_INIT(socket_getpeersec_stream, smack_socket_getpeersec_stream),\n\tLSM_HOOK_INIT(socket_getpeersec_dgram, smack_socket_getpeersec_dgram),\n\tLSM_HOOK_INIT(sk_alloc_security, smack_sk_alloc_security),\n\tLSM_HOOK_INIT(sk_free_security, smack_sk_free_security),\n\tLSM_HOOK_INIT(sock_graft, smack_sock_graft),\n\tLSM_HOOK_INIT(inet_conn_request, smack_inet_conn_request),\n\tLSM_HOOK_INIT(inet_csk_clone, smack_inet_csk_clone),\n\n /* key management security hooks */\n#ifdef CONFIG_KEYS\n\tLSM_HOOK_INIT(key_alloc, smack_key_alloc),\n\tLSM_HOOK_INIT(key_free, smack_key_free),\n\tLSM_HOOK_INIT(key_permission, smack_key_permission),\n\tLSM_HOOK_INIT(key_getsecurity, smack_key_getsecurity),\n#endif /* CONFIG_KEYS */\n\n /* Audit hooks */\n#ifdef CONFIG_AUDIT\n\tLSM_HOOK_INIT(audit_rule_init, smack_audit_rule_init),\n\tLSM_HOOK_INIT(audit_rule_known, smack_audit_rule_known),\n\tLSM_HOOK_INIT(audit_rule_match, smack_audit_rule_match),\n#endif /* CONFIG_AUDIT */\n\n\tLSM_HOOK_INIT(ismaclabel, smack_ismaclabel),\n\tLSM_HOOK_INIT(secid_to_secctx, smack_secid_to_secctx),\n\tLSM_HOOK_INIT(secctx_to_secid, smack_secctx_to_secid),\n\tLSM_HOOK_INIT(inode_notifysecctx, smack_inode_notifysecctx),\n\tLSM_HOOK_INIT(inode_setsecctx, smack_inode_setsecctx),\n\tLSM_HOOK_INIT(inode_getsecctx, smack_inode_getsecctx),\n\tLSM_HOOK_INIT(inode_copy_up, smack_inode_copy_up),\n\tLSM_HOOK_INIT(inode_copy_up_xattr, smack_inode_copy_up_xattr),\n\tLSM_HOOK_INIT(dentry_create_files_as, smack_dentry_create_files_as),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_add_hooks",
          "args": [
            "smack_hooks",
            "ARRAY_SIZE(smack_hooks)",
            "\"smack\""
          ],
          "line": 4897
        },
        "resolved": true,
        "details": {
          "function_name": "security_add_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "159-170",
          "snippet": "void __init security_add_hooks(struct security_hook_list *hooks, int count,\n\t\t\t\tchar *lsm)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\thooks[i].lsm = lsm;\n\t\tlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n\t}\n\tif (lsm_append(lsm, &lsm_names) < 0)\n\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *lsm_names;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nchar *lsm_names;\n\nvoid __init security_add_hooks(struct security_hook_list *hooks, int count,\n\t\t\t\tchar *lsm)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\thooks[i].lsm = lsm;\n\t\tlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n\t}\n\tif (lsm_append(lsm, &lsm_names) < 0)\n\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "smack_hooks"
          ],
          "line": 4897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_smack_known_list",
          "args": [],
          "line": 4892
        },
        "resolved": true,
        "details": {
          "function_name": "init_smack_known_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "4820-4846",
          "snippet": "static __init void init_smack_known_list(void)\n{\n\t/*\n\t * Initialize rule list locks\n\t */\n\tmutex_init(&smack_known_huh.smk_rules_lock);\n\tmutex_init(&smack_known_hat.smk_rules_lock);\n\tmutex_init(&smack_known_floor.smk_rules_lock);\n\tmutex_init(&smack_known_star.smk_rules_lock);\n\tmutex_init(&smack_known_web.smk_rules_lock);\n\t/*\n\t * Initialize rule lists\n\t */\n\tINIT_LIST_HEAD(&smack_known_huh.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_hat.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_star.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_floor.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_web.smk_rules);\n\t/*\n\t * Create the known labels list\n\t */\n\tsmk_insert_entry(&smack_known_huh);\n\tsmk_insert_entry(&smack_known_hat);\n\tsmk_insert_entry(&smack_known_star);\n\tsmk_insert_entry(&smack_known_floor);\n\tsmk_insert_entry(&smack_known_web);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic __init void init_smack_known_list(void)\n{\n\t/*\n\t * Initialize rule list locks\n\t */\n\tmutex_init(&smack_known_huh.smk_rules_lock);\n\tmutex_init(&smack_known_hat.smk_rules_lock);\n\tmutex_init(&smack_known_floor.smk_rules_lock);\n\tmutex_init(&smack_known_star.smk_rules_lock);\n\tmutex_init(&smack_known_web.smk_rules_lock);\n\t/*\n\t * Initialize rule lists\n\t */\n\tINIT_LIST_HEAD(&smack_known_huh.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_hat.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_star.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_floor.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_web.smk_rules);\n\t/*\n\t * Create the known labels list\n\t */\n\tsmk_insert_entry(&smack_known_huh);\n\tsmk_insert_entry(&smack_known_hat);\n\tsmk_insert_entry(&smack_known_star);\n\tsmk_insert_entry(&smack_known_floor);\n\tsmk_insert_entry(&smack_known_web);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Smack:  IPv6 Netfilter enabled.\\n\""
          ],
          "line": 4882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Smack:  IPv6 port labeling enabled.\\n\""
          ],
          "line": 4879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Smack:  Netfilter enabled.\\n\""
          ],
          "line": 4876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Smack:  Initializing.\\n\""
          ],
          "line": 4874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "smack_inode_cache"
          ],
          "line": 4868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_task_smack",
          "args": [
            "&smack_known_floor",
            "&smack_known_floor",
            "GFP_KERNEL"
          ],
          "line": 4865
        },
        "resolved": true,
        "details": {
          "function_name": "new_task_smack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "318-334",
          "snippet": "static struct task_smack *new_task_smack(struct smack_known *task,\n\t\t\t\t\tstruct smack_known *forked, gfp_t gfp)\n{\n\tstruct task_smack *tsp;\n\n\ttsp = kzalloc(sizeof(struct task_smack), gfp);\n\tif (tsp == NULL)\n\t\treturn NULL;\n\n\ttsp->smk_task = task;\n\ttsp->smk_forked = forked;\n\tINIT_LIST_HEAD(&tsp->smk_rules);\n\tINIT_LIST_HEAD(&tsp->smk_relabel);\n\tmutex_init(&tsp->smk_rules_lock);\n\n\treturn tsp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct task_smack *new_task_smack(struct smack_known *task,\n\t\t\t\t\tstruct smack_known *forked, gfp_t gfp)\n{\n\tstruct task_smack *tsp;\n\n\ttsp = kzalloc(sizeof(struct task_smack), gfp);\n\tif (tsp == NULL)\n\t\treturn NULL;\n\n\ttsp->smk_task = task;\n\ttsp->smk_forked = forked;\n\tINIT_LIST_HEAD(&tsp->smk_rules);\n\tINIT_LIST_HEAD(&tsp->smk_relabel);\n\tmutex_init(&tsp->smk_rules_lock);\n\n\treturn tsp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "inode_smack",
            "0"
          ],
          "line": 4861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_module_enable",
          "args": [
            "\"smack\""
          ],
          "line": 4858
        },
        "resolved": true,
        "details": {
          "function_name": "security_module_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "146-149",
          "snippet": "int __init security_module_enable(const char *module)\n{\n\treturn !strcmp(module, chosen_lsm);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =\n\tCONFIG_DEFAULT_SECURITY;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nstatic __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =\n\tCONFIG_DEFAULT_SECURITY;\n\nint __init security_module_enable(const char *module)\n{\n\treturn !strcmp(module, chosen_lsm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct kmem_cache *smack_inode_cache;\nint smack_enabled;\nstatic struct security_hook_list smack_hooks[] __lsm_ro_after_init = {\n\tLSM_HOOK_INIT(ptrace_access_check, smack_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, smack_ptrace_traceme),\n\tLSM_HOOK_INIT(syslog, smack_syslog),\n\n\tLSM_HOOK_INIT(sb_alloc_security, smack_sb_alloc_security),\n\tLSM_HOOK_INIT(sb_free_security, smack_sb_free_security),\n\tLSM_HOOK_INIT(sb_copy_data, smack_sb_copy_data),\n\tLSM_HOOK_INIT(sb_kern_mount, smack_sb_kern_mount),\n\tLSM_HOOK_INIT(sb_statfs, smack_sb_statfs),\n\tLSM_HOOK_INIT(sb_set_mnt_opts, smack_set_mnt_opts),\n\tLSM_HOOK_INIT(sb_parse_opts_str, smack_parse_opts_str),\n\n\tLSM_HOOK_INIT(bprm_set_creds, smack_bprm_set_creds),\n\n\tLSM_HOOK_INIT(inode_alloc_security, smack_inode_alloc_security),\n\tLSM_HOOK_INIT(inode_free_security, smack_inode_free_security),\n\tLSM_HOOK_INIT(inode_init_security, smack_inode_init_security),\n\tLSM_HOOK_INIT(inode_link, smack_inode_link),\n\tLSM_HOOK_INIT(inode_unlink, smack_inode_unlink),\n\tLSM_HOOK_INIT(inode_rmdir, smack_inode_rmdir),\n\tLSM_HOOK_INIT(inode_rename, smack_inode_rename),\n\tLSM_HOOK_INIT(inode_permission, smack_inode_permission),\n\tLSM_HOOK_INIT(inode_setattr, smack_inode_setattr),\n\tLSM_HOOK_INIT(inode_getattr, smack_inode_getattr),\n\tLSM_HOOK_INIT(inode_setxattr, smack_inode_setxattr),\n\tLSM_HOOK_INIT(inode_post_setxattr, smack_inode_post_setxattr),\n\tLSM_HOOK_INIT(inode_getxattr, smack_inode_getxattr),\n\tLSM_HOOK_INIT(inode_removexattr, smack_inode_removexattr),\n\tLSM_HOOK_INIT(inode_getsecurity, smack_inode_getsecurity),\n\tLSM_HOOK_INIT(inode_setsecurity, smack_inode_setsecurity),\n\tLSM_HOOK_INIT(inode_listsecurity, smack_inode_listsecurity),\n\tLSM_HOOK_INIT(inode_getsecid, smack_inode_getsecid),\n\n\tLSM_HOOK_INIT(file_alloc_security, smack_file_alloc_security),\n\tLSM_HOOK_INIT(file_free_security, smack_file_free_security),\n\tLSM_HOOK_INIT(file_ioctl, smack_file_ioctl),\n\tLSM_HOOK_INIT(file_lock, smack_file_lock),\n\tLSM_HOOK_INIT(file_fcntl, smack_file_fcntl),\n\tLSM_HOOK_INIT(mmap_file, smack_mmap_file),\n\tLSM_HOOK_INIT(mmap_addr, cap_mmap_addr),\n\tLSM_HOOK_INIT(file_set_fowner, smack_file_set_fowner),\n\tLSM_HOOK_INIT(file_send_sigiotask, smack_file_send_sigiotask),\n\tLSM_HOOK_INIT(file_receive, smack_file_receive),\n\n\tLSM_HOOK_INIT(file_open, smack_file_open),\n\n\tLSM_HOOK_INIT(cred_alloc_blank, smack_cred_alloc_blank),\n\tLSM_HOOK_INIT(cred_free, smack_cred_free),\n\tLSM_HOOK_INIT(cred_prepare, smack_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, smack_cred_transfer),\n\tLSM_HOOK_INIT(kernel_act_as, smack_kernel_act_as),\n\tLSM_HOOK_INIT(kernel_create_files_as, smack_kernel_create_files_as),\n\tLSM_HOOK_INIT(task_setpgid, smack_task_setpgid),\n\tLSM_HOOK_INIT(task_getpgid, smack_task_getpgid),\n\tLSM_HOOK_INIT(task_getsid, smack_task_getsid),\n\tLSM_HOOK_INIT(task_getsecid, smack_task_getsecid),\n\tLSM_HOOK_INIT(task_setnice, smack_task_setnice),\n\tLSM_HOOK_INIT(task_setioprio, smack_task_setioprio),\n\tLSM_HOOK_INIT(task_getioprio, smack_task_getioprio),\n\tLSM_HOOK_INIT(task_setscheduler, smack_task_setscheduler),\n\tLSM_HOOK_INIT(task_getscheduler, smack_task_getscheduler),\n\tLSM_HOOK_INIT(task_movememory, smack_task_movememory),\n\tLSM_HOOK_INIT(task_kill, smack_task_kill),\n\tLSM_HOOK_INIT(task_to_inode, smack_task_to_inode),\n\n\tLSM_HOOK_INIT(ipc_permission, smack_ipc_permission),\n\tLSM_HOOK_INIT(ipc_getsecid, smack_ipc_getsecid),\n\n\tLSM_HOOK_INIT(msg_msg_alloc_security, smack_msg_msg_alloc_security),\n\tLSM_HOOK_INIT(msg_msg_free_security, smack_msg_msg_free_security),\n\n\tLSM_HOOK_INIT(msg_queue_alloc_security, smack_msg_queue_alloc_security),\n\tLSM_HOOK_INIT(msg_queue_free_security, smack_msg_queue_free_security),\n\tLSM_HOOK_INIT(msg_queue_associate, smack_msg_queue_associate),\n\tLSM_HOOK_INIT(msg_queue_msgctl, smack_msg_queue_msgctl),\n\tLSM_HOOK_INIT(msg_queue_msgsnd, smack_msg_queue_msgsnd),\n\tLSM_HOOK_INIT(msg_queue_msgrcv, smack_msg_queue_msgrcv),\n\n\tLSM_HOOK_INIT(shm_alloc_security, smack_shm_alloc_security),\n\tLSM_HOOK_INIT(shm_free_security, smack_shm_free_security),\n\tLSM_HOOK_INIT(shm_associate, smack_shm_associate),\n\tLSM_HOOK_INIT(shm_shmctl, smack_shm_shmctl),\n\tLSM_HOOK_INIT(shm_shmat, smack_shm_shmat),\n\n\tLSM_HOOK_INIT(sem_alloc_security, smack_sem_alloc_security),\n\tLSM_HOOK_INIT(sem_free_security, smack_sem_free_security),\n\tLSM_HOOK_INIT(sem_associate, smack_sem_associate),\n\tLSM_HOOK_INIT(sem_semctl, smack_sem_semctl),\n\tLSM_HOOK_INIT(sem_semop, smack_sem_semop),\n\n\tLSM_HOOK_INIT(d_instantiate, smack_d_instantiate),\n\n\tLSM_HOOK_INIT(getprocattr, smack_getprocattr),\n\tLSM_HOOK_INIT(setprocattr, smack_setprocattr),\n\n\tLSM_HOOK_INIT(unix_stream_connect, smack_unix_stream_connect),\n\tLSM_HOOK_INIT(unix_may_send, smack_unix_may_send),\n\n\tLSM_HOOK_INIT(socket_post_create, smack_socket_post_create),\n#ifdef SMACK_IPV6_PORT_LABELING\n\tLSM_HOOK_INIT(socket_bind, smack_socket_bind),\n#endif\n\tLSM_HOOK_INIT(socket_connect, smack_socket_connect),\n\tLSM_HOOK_INIT(socket_sendmsg, smack_socket_sendmsg),\n\tLSM_HOOK_INIT(socket_sock_rcv_skb, smack_socket_sock_rcv_skb),\n\tLSM_HOOK_INIT(socket_getpeersec_stream, smack_socket_getpeersec_stream),\n\tLSM_HOOK_INIT(socket_getpeersec_dgram, smack_socket_getpeersec_dgram),\n\tLSM_HOOK_INIT(sk_alloc_security, smack_sk_alloc_security),\n\tLSM_HOOK_INIT(sk_free_security, smack_sk_free_security),\n\tLSM_HOOK_INIT(sock_graft, smack_sock_graft),\n\tLSM_HOOK_INIT(inet_conn_request, smack_inet_conn_request),\n\tLSM_HOOK_INIT(inet_csk_clone, smack_inet_csk_clone),\n\n /* key management security hooks */\n#ifdef CONFIG_KEYS\n\tLSM_HOOK_INIT(key_alloc, smack_key_alloc),\n\tLSM_HOOK_INIT(key_free, smack_key_free),\n\tLSM_HOOK_INIT(key_permission, smack_key_permission),\n\tLSM_HOOK_INIT(key_getsecurity, smack_key_getsecurity),\n#endif /* CONFIG_KEYS */\n\n /* Audit hooks */\n#ifdef CONFIG_AUDIT\n\tLSM_HOOK_INIT(audit_rule_init, smack_audit_rule_init),\n\tLSM_HOOK_INIT(audit_rule_known, smack_audit_rule_known),\n\tLSM_HOOK_INIT(audit_rule_match, smack_audit_rule_match),\n#endif /* CONFIG_AUDIT */\n\n\tLSM_HOOK_INIT(ismaclabel, smack_ismaclabel),\n\tLSM_HOOK_INIT(secid_to_secctx, smack_secid_to_secctx),\n\tLSM_HOOK_INIT(secctx_to_secid, smack_secctx_to_secid),\n\tLSM_HOOK_INIT(inode_notifysecctx, smack_inode_notifysecctx),\n\tLSM_HOOK_INIT(inode_setsecctx, smack_inode_setsecctx),\n\tLSM_HOOK_INIT(inode_getsecctx, smack_inode_getsecctx),\n\tLSM_HOOK_INIT(inode_copy_up, smack_inode_copy_up),\n\tLSM_HOOK_INIT(inode_copy_up_xattr, smack_inode_copy_up_xattr),\n\tLSM_HOOK_INIT(dentry_create_files_as, smack_dentry_create_files_as),\n};\n\nstatic __init int smack_init(void)\n{\n\tstruct cred *cred;\n\tstruct task_smack *tsp;\n\n\tif (!security_module_enable(\"smack\"))\n\t\treturn 0;\n\n\tsmack_inode_cache = KMEM_CACHE(inode_smack, 0);\n\tif (!smack_inode_cache)\n\t\treturn -ENOMEM;\n\n\ttsp = new_task_smack(&smack_known_floor, &smack_known_floor,\n\t\t\t\tGFP_KERNEL);\n\tif (tsp == NULL) {\n\t\tkmem_cache_destroy(smack_inode_cache);\n\t\treturn -ENOMEM;\n\t}\n\n\tsmack_enabled = 1;\n\n\tpr_info(\"Smack:  Initializing.\\n\");\n#ifdef CONFIG_SECURITY_SMACK_NETFILTER\n\tpr_info(\"Smack:  Netfilter enabled.\\n\");\n#endif\n#ifdef SMACK_IPV6_PORT_LABELING\n\tpr_info(\"Smack:  IPv6 port labeling enabled.\\n\");\n#endif\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\tpr_info(\"Smack:  IPv6 Netfilter enabled.\\n\");\n#endif\n\n\t/*\n\t * Set the security state for the initial task.\n\t */\n\tcred = (struct cred *) current->cred;\n\tcred->security = tsp;\n\n\t/* initialize the smack_known_list */\n\tinit_smack_known_list();\n\n\t/*\n\t * Register with LSM\n\t */\n\tsecurity_add_hooks(smack_hooks, ARRAY_SIZE(smack_hooks), \"smack\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "init_smack_known_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4820-4846",
    "snippet": "static __init void init_smack_known_list(void)\n{\n\t/*\n\t * Initialize rule list locks\n\t */\n\tmutex_init(&smack_known_huh.smk_rules_lock);\n\tmutex_init(&smack_known_hat.smk_rules_lock);\n\tmutex_init(&smack_known_floor.smk_rules_lock);\n\tmutex_init(&smack_known_star.smk_rules_lock);\n\tmutex_init(&smack_known_web.smk_rules_lock);\n\t/*\n\t * Initialize rule lists\n\t */\n\tINIT_LIST_HEAD(&smack_known_huh.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_hat.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_star.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_floor.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_web.smk_rules);\n\t/*\n\t * Create the known labels list\n\t */\n\tsmk_insert_entry(&smack_known_huh);\n\tsmk_insert_entry(&smack_known_hat);\n\tsmk_insert_entry(&smack_known_star);\n\tsmk_insert_entry(&smack_known_floor);\n\tsmk_insert_entry(&smack_known_web);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_insert_entry",
          "args": [
            "&smack_known_web"
          ],
          "line": 4845
        },
        "resolved": true,
        "details": {
          "function_name": "smk_insert_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "406-416",
          "snippet": "void smk_insert_entry(struct smack_known *skp)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\n\thash = full_name_hash(NULL, skp->smk_known, strlen(skp->smk_known));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_add_head_rcu(&skp->smk_hashed, head);\n\tlist_add_rcu(&skp->list, &smack_known_list);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct hlist_head smack_known_hash[SMACK_HASH_SLOTS];\n\nvoid smk_insert_entry(struct smack_known *skp)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\n\thash = full_name_hash(NULL, skp->smk_known, strlen(skp->smk_known));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_add_head_rcu(&skp->smk_hashed, head);\n\tlist_add_rcu(&skp->list, &smack_known_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&smack_known_web.smk_rules"
          ],
          "line": 4837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&smack_known_floor.smk_rules"
          ],
          "line": 4836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&smack_known_star.smk_rules"
          ],
          "line": 4835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&smack_known_hat.smk_rules"
          ],
          "line": 4834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&smack_known_huh.smk_rules"
          ],
          "line": 4833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&smack_known_web.smk_rules_lock"
          ],
          "line": 4829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&smack_known_star.smk_rules_lock"
          ],
          "line": 4828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&smack_known_floor.smk_rules_lock"
          ],
          "line": 4827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&smack_known_hat.smk_rules_lock"
          ],
          "line": 4826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&smack_known_huh.smk_rules_lock"
          ],
          "line": 4825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic __init void init_smack_known_list(void)\n{\n\t/*\n\t * Initialize rule list locks\n\t */\n\tmutex_init(&smack_known_huh.smk_rules_lock);\n\tmutex_init(&smack_known_hat.smk_rules_lock);\n\tmutex_init(&smack_known_floor.smk_rules_lock);\n\tmutex_init(&smack_known_star.smk_rules_lock);\n\tmutex_init(&smack_known_web.smk_rules_lock);\n\t/*\n\t * Initialize rule lists\n\t */\n\tINIT_LIST_HEAD(&smack_known_huh.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_hat.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_star.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_floor.smk_rules);\n\tINIT_LIST_HEAD(&smack_known_web.smk_rules);\n\t/*\n\t * Create the known labels list\n\t */\n\tsmk_insert_entry(&smack_known_huh);\n\tsmk_insert_entry(&smack_known_hat);\n\tsmk_insert_entry(&smack_known_star);\n\tsmk_insert_entry(&smack_known_floor);\n\tsmk_insert_entry(&smack_known_web);\n}"
  },
  {
    "function_name": "smack_dentry_create_files_as",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4640-4677",
    "snippet": "static int smack_dentry_create_files_as(struct dentry *dentry, int mode,\n\t\t\t\t\tstruct qstr *name,\n\t\t\t\t\tconst struct cred *old,\n\t\t\t\t\tstruct cred *new)\n{\n\tstruct task_smack *otsp = old->security;\n\tstruct task_smack *ntsp = new->security;\n\tstruct inode_smack *isp;\n\tint may;\n\n\t/*\n\t * Use the process credential unless all of\n\t * the transmuting criteria are met\n\t */\n\tntsp->smk_task = otsp->smk_task;\n\n\t/*\n\t * the attribute of the containing directory\n\t */\n\tisp = d_inode(dentry->d_parent)->i_security;\n\n\tif (isp->smk_flags & SMK_INODE_TRANSMUTE) {\n\t\trcu_read_lock();\n\t\tmay = smk_access_entry(otsp->smk_task->smk_known,\n\t\t\t\t       isp->smk_inode->smk_known,\n\t\t\t\t       &otsp->smk_task->smk_rules);\n\t\trcu_read_unlock();\n\n\t\t/*\n\t\t * If the directory is transmuting and the rule\n\t\t * providing access is transmuting use the containing\n\t\t * directory label instead of the process label.\n\t\t */\n\t\tif (may > 0 && (may & MAY_TRANSMUTE))\n\t\t\tntsp->smk_task = isp->smk_inode;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_access_entry",
          "args": [
            "otsp->smk_task->smk_known",
            "isp->smk_inode->smk_known",
            "&otsp->smk_task->smk_rules"
          ],
          "line": 4663
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "85-105",
          "snippet": "int smk_access_entry(char *subject_label, char *object_label,\n\t\t\tstruct list_head *rule_list)\n{\n\tint may = -ENOENT;\n\tstruct smack_rule *srp;\n\n\tlist_for_each_entry_rcu(srp, rule_list, list) {\n\t\tif (srp->smk_object->smk_known == object_label &&\n\t\t    srp->smk_subject->smk_known == subject_label) {\n\t\t\tmay = srp->smk_access;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * MAY_WRITE implies MAY_LOCK.\n\t */\n\tif ((may & MAY_WRITE) == MAY_WRITE)\n\t\tmay |= MAY_LOCK;\n\treturn may;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_access_entry(char *subject_label, char *object_label,\n\t\t\tstruct list_head *rule_list)\n{\n\tint may = -ENOENT;\n\tstruct smack_rule *srp;\n\n\tlist_for_each_entry_rcu(srp, rule_list, list) {\n\t\tif (srp->smk_object->smk_known == object_label &&\n\t\t    srp->smk_subject->smk_known == subject_label) {\n\t\t\tmay = srp->smk_access;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * MAY_WRITE implies MAY_LOCK.\n\t */\n\tif ((may & MAY_WRITE) == MAY_WRITE)\n\t\tmay |= MAY_LOCK;\n\treturn may;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry->d_parent"
          ],
          "line": 4659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_dentry_create_files_as(struct dentry *dentry, int mode,\n\t\t\t\t\tstruct qstr *name,\n\t\t\t\t\tconst struct cred *old,\n\t\t\t\t\tstruct cred *new)\n{\n\tstruct task_smack *otsp = old->security;\n\tstruct task_smack *ntsp = new->security;\n\tstruct inode_smack *isp;\n\tint may;\n\n\t/*\n\t * Use the process credential unless all of\n\t * the transmuting criteria are met\n\t */\n\tntsp->smk_task = otsp->smk_task;\n\n\t/*\n\t * the attribute of the containing directory\n\t */\n\tisp = d_inode(dentry->d_parent)->i_security;\n\n\tif (isp->smk_flags & SMK_INODE_TRANSMUTE) {\n\t\trcu_read_lock();\n\t\tmay = smk_access_entry(otsp->smk_task->smk_known,\n\t\t\t\t       isp->smk_inode->smk_known,\n\t\t\t\t       &otsp->smk_task->smk_rules);\n\t\trcu_read_unlock();\n\n\t\t/*\n\t\t * If the directory is transmuting and the rule\n\t\t * providing access is transmuting use the containing\n\t\t * directory label instead of the process label.\n\t\t */\n\t\tif (may > 0 && (may & MAY_TRANSMUTE))\n\t\t\tntsp->smk_task = isp->smk_inode;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_inode_copy_up_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4629-4638",
    "snippet": "static int smack_inode_copy_up_xattr(const char *name)\n{\n\t/*\n\t * Return 1 if this is the smack access Smack attribute.\n\t */\n\tif (strcmp(name, XATTR_NAME_SMACK) == 0)\n\t\treturn 1;\n\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACK"
          ],
          "line": 4634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_copy_up_xattr(const char *name)\n{\n\t/*\n\t * Return 1 if this is the smack access Smack attribute.\n\t */\n\tif (strcmp(name, XATTR_NAME_SMACK) == 0)\n\t\treturn 1;\n\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "smack_inode_copy_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4603-4627",
    "snippet": "static int smack_inode_copy_up(struct dentry *dentry, struct cred **new)\n{\n\n\tstruct task_smack *tsp;\n\tstruct smack_known *skp;\n\tstruct inode_smack *isp;\n\tstruct cred *new_creds = *new;\n\n\tif (new_creds == NULL) {\n\t\tnew_creds = prepare_creds();\n\t\tif (new_creds == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\ttsp = new_creds->security;\n\n\t/*\n\t * Get label from overlay inode and set it in create_sid\n\t */\n\tisp = d_inode(dentry->d_parent)->i_security;\n\tskp = isp->smk_inode;\n\ttsp->smk_task = skp;\n\t*new = new_creds;\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry->d_parent"
          ],
          "line": 4622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 4612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_copy_up(struct dentry *dentry, struct cred **new)\n{\n\n\tstruct task_smack *tsp;\n\tstruct smack_known *skp;\n\tstruct inode_smack *isp;\n\tstruct cred *new_creds = *new;\n\n\tif (new_creds == NULL) {\n\t\tnew_creds = prepare_creds();\n\t\tif (new_creds == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\ttsp = new_creds->security;\n\n\t/*\n\t * Get label from overlay inode and set it in create_sid\n\t */\n\tisp = d_inode(dentry->d_parent)->i_security;\n\tskp = isp->smk_inode;\n\ttsp->smk_task = skp;\n\t*new = new_creds;\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_inode_getsecctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4592-4601",
    "snippet": "static int smack_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)\n{\n\tint len = 0;\n\tlen = smack_inode_getsecurity(inode, XATTR_SMACK_SUFFIX, ctx, true);\n\n\tif (len < 0)\n\t\treturn len;\n\t*ctxlen = len;\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smack_inode_getsecurity",
          "args": [
            "inode",
            "XATTR_SMACK_SUFFIX",
            "ctx",
            "true"
          ],
          "line": 4595
        },
        "resolved": true,
        "details": {
          "function_name": "smack_inode_getsecurity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "1480-1521",
          "snippet": "static int smack_inode_getsecurity(struct inode *inode,\n\t\t\t\t   const char *name, void **buffer,\n\t\t\t\t   bool alloc)\n{\n\tstruct socket_smack *ssp;\n\tstruct socket *sock;\n\tstruct super_block *sbp;\n\tstruct inode *ip = (struct inode *)inode;\n\tstruct smack_known *isp;\n\n\tif (strcmp(name, XATTR_SMACK_SUFFIX) == 0)\n\t\tisp = smk_of_inode(inode);\n\telse {\n\t\t/*\n\t\t * The rest of the Smack xattrs are only on sockets.\n\t\t */\n\t\tsbp = ip->i_sb;\n\t\tif (sbp->s_magic != SOCKFS_MAGIC)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tsock = SOCKET_I(ip);\n\t\tif (sock == NULL || sock->sk == NULL)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tssp = sock->sk->sk_security;\n\n\t\tif (strcmp(name, XATTR_SMACK_IPIN) == 0)\n\t\t\tisp = ssp->smk_in;\n\t\telse if (strcmp(name, XATTR_SMACK_IPOUT) == 0)\n\t\t\tisp = ssp->smk_out;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (alloc) {\n\t\t*buffer = kstrdup(isp->smk_known, GFP_KERNEL);\n\t\tif (*buffer == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn strlen(isp->smk_known);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_getsecurity(struct inode *inode,\n\t\t\t\t   const char *name, void **buffer,\n\t\t\t\t   bool alloc)\n{\n\tstruct socket_smack *ssp;\n\tstruct socket *sock;\n\tstruct super_block *sbp;\n\tstruct inode *ip = (struct inode *)inode;\n\tstruct smack_known *isp;\n\n\tif (strcmp(name, XATTR_SMACK_SUFFIX) == 0)\n\t\tisp = smk_of_inode(inode);\n\telse {\n\t\t/*\n\t\t * The rest of the Smack xattrs are only on sockets.\n\t\t */\n\t\tsbp = ip->i_sb;\n\t\tif (sbp->s_magic != SOCKFS_MAGIC)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tsock = SOCKET_I(ip);\n\t\tif (sock == NULL || sock->sk == NULL)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tssp = sock->sk->sk_security;\n\n\t\tif (strcmp(name, XATTR_SMACK_IPIN) == 0)\n\t\t\tisp = ssp->smk_in;\n\t\telse if (strcmp(name, XATTR_SMACK_IPOUT) == 0)\n\t\t\tisp = ssp->smk_out;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (alloc) {\n\t\t*buffer = kstrdup(isp->smk_known, GFP_KERNEL);\n\t\tif (*buffer == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn strlen(isp->smk_known);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)\n{\n\tint len = 0;\n\tlen = smack_inode_getsecurity(inode, XATTR_SMACK_SUFFIX, ctx, true);\n\n\tif (len < 0)\n\t\treturn len;\n\t*ctxlen = len;\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_inode_setsecctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4587-4590",
    "snippet": "static int smack_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)\n{\n\treturn __vfs_setxattr_noperm(dentry, XATTR_NAME_SMACK, ctx, ctxlen, 0);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vfs_setxattr_noperm",
          "args": [
            "dentry",
            "XATTR_NAME_SMACK",
            "ctx",
            "ctxlen",
            "0"
          ],
          "line": 4589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)\n{\n\treturn __vfs_setxattr_noperm(dentry, XATTR_NAME_SMACK, ctx, ctxlen, 0);\n}"
  },
  {
    "function_name": "smack_inode_notifysecctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4582-4585",
    "snippet": "static int smack_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)\n{\n\treturn smack_inode_setsecurity(inode, XATTR_SMACK_SUFFIX, ctx, ctxlen, 0);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smack_inode_setsecurity",
          "args": [
            "inode",
            "XATTR_SMACK_SUFFIX",
            "ctx",
            "ctxlen",
            "0"
          ],
          "line": 4584
        },
        "resolved": true,
        "details": {
          "function_name": "smack_inode_setsecurity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2738-2791",
          "snippet": "static int smack_inode_setsecurity(struct inode *inode, const char *name,\n\t\t\t\t   const void *value, size_t size, int flags)\n{\n\tstruct smack_known *skp;\n\tstruct inode_smack *nsp = inode->i_security;\n\tstruct socket_smack *ssp;\n\tstruct socket *sock;\n\tint rc = 0;\n\n\tif (value == NULL || size > SMK_LONGLABEL || size == 0)\n\t\treturn -EINVAL;\n\n\tskp = smk_import_entry(value, size);\n\tif (IS_ERR(skp))\n\t\treturn PTR_ERR(skp);\n\n\tif (strcmp(name, XATTR_SMACK_SUFFIX) == 0) {\n\t\tnsp->smk_inode = skp;\n\t\tnsp->smk_flags |= SMK_INODE_INSTANT;\n\t\treturn 0;\n\t}\n\t/*\n\t * The rest of the Smack xattrs are only on sockets.\n\t */\n\tif (inode->i_sb->s_magic != SOCKFS_MAGIC)\n\t\treturn -EOPNOTSUPP;\n\n\tsock = SOCKET_I(inode);\n\tif (sock == NULL || sock->sk == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tssp = sock->sk->sk_security;\n\n\tif (strcmp(name, XATTR_SMACK_IPIN) == 0)\n\t\tssp->smk_in = skp;\n\telse if (strcmp(name, XATTR_SMACK_IPOUT) == 0) {\n\t\tssp->smk_out = skp;\n\t\tif (sock->sk->sk_family == PF_INET) {\n\t\t\trc = smack_netlabel(sock->sk, SMACK_CIPSO_SOCKET);\n\t\t\tif (rc != 0)\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"Smack: \\\"%s\\\" netlbl error %d.\\n\",\n\t\t\t\t\t__func__, -rc);\n\t\t}\n\t} else\n\t\treturn -EOPNOTSUPP;\n\n#ifdef SMACK_IPV6_PORT_LABELING\n\tif (sock->sk->sk_family == PF_INET6)\n\t\tsmk_ipv6_port_label(sock, NULL);\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_setsecurity(struct inode *inode, const char *name,\n\t\t\t\t   const void *value, size_t size, int flags)\n{\n\tstruct smack_known *skp;\n\tstruct inode_smack *nsp = inode->i_security;\n\tstruct socket_smack *ssp;\n\tstruct socket *sock;\n\tint rc = 0;\n\n\tif (value == NULL || size > SMK_LONGLABEL || size == 0)\n\t\treturn -EINVAL;\n\n\tskp = smk_import_entry(value, size);\n\tif (IS_ERR(skp))\n\t\treturn PTR_ERR(skp);\n\n\tif (strcmp(name, XATTR_SMACK_SUFFIX) == 0) {\n\t\tnsp->smk_inode = skp;\n\t\tnsp->smk_flags |= SMK_INODE_INSTANT;\n\t\treturn 0;\n\t}\n\t/*\n\t * The rest of the Smack xattrs are only on sockets.\n\t */\n\tif (inode->i_sb->s_magic != SOCKFS_MAGIC)\n\t\treturn -EOPNOTSUPP;\n\n\tsock = SOCKET_I(inode);\n\tif (sock == NULL || sock->sk == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tssp = sock->sk->sk_security;\n\n\tif (strcmp(name, XATTR_SMACK_IPIN) == 0)\n\t\tssp->smk_in = skp;\n\telse if (strcmp(name, XATTR_SMACK_IPOUT) == 0) {\n\t\tssp->smk_out = skp;\n\t\tif (sock->sk->sk_family == PF_INET) {\n\t\t\trc = smack_netlabel(sock->sk, SMACK_CIPSO_SOCKET);\n\t\t\tif (rc != 0)\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"Smack: \\\"%s\\\" netlbl error %d.\\n\",\n\t\t\t\t\t__func__, -rc);\n\t\t}\n\t} else\n\t\treturn -EOPNOTSUPP;\n\n#ifdef SMACK_IPV6_PORT_LABELING\n\tif (sock->sk->sk_family == PF_INET6)\n\t\tsmk_ipv6_port_label(sock, NULL);\n#endif\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)\n{\n\treturn smack_inode_setsecurity(inode, XATTR_SMACK_SUFFIX, ctx, ctxlen, 0);\n}"
  },
  {
    "function_name": "smack_secctx_to_secid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4565-4574",
    "snippet": "static int smack_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)\n{\n\tstruct smack_known *skp = smk_find_entry(secdata);\n\n\tif (skp)\n\t\t*secid = skp->smk_secid;\n\telse\n\t\t*secid = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_find_entry",
          "args": [
            "secdata"
          ],
          "line": 4567
        },
        "resolved": true,
        "details": {
          "function_name": "smk_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "425-439",
          "snippet": "struct smack_known *smk_find_entry(const char *string)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\tstruct smack_known *skp;\n\n\thash = full_name_hash(NULL, string, strlen(string));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_for_each_entry_rcu(skp, head, smk_hashed)\n\t\tif (strcmp(skp->smk_known, string) == 0)\n\t\t\treturn skp;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct hlist_head smack_known_hash[SMACK_HASH_SLOTS];\n\nstruct smack_known *smk_find_entry(const char *string)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\tstruct smack_known *skp;\n\n\thash = full_name_hash(NULL, string, strlen(string));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_for_each_entry_rcu(skp, head, smk_hashed)\n\t\tif (strcmp(skp->smk_known, string) == 0)\n\t\t\treturn skp;\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)\n{\n\tstruct smack_known *skp = smk_find_entry(secdata);\n\n\tif (skp)\n\t\t*secid = skp->smk_secid;\n\telse\n\t\t*secid = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_secid_to_secctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4547-4555",
    "snippet": "static int smack_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)\n{\n\tstruct smack_known *skp = smack_from_secid(secid);\n\n\tif (secdata)\n\t\t*secdata = skp->smk_known;\n\t*seclen = strlen(skp->smk_known);\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "skp->smk_known"
          ],
          "line": 4553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_from_secid",
          "args": [
            "secid"
          ],
          "line": 4549
        },
        "resolved": true,
        "details": {
          "function_name": "smack_from_secid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "596-614",
          "snippet": "struct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};\n\nstruct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)\n{\n\tstruct smack_known *skp = smack_from_secid(secid);\n\n\tif (secdata)\n\t\t*secdata = skp->smk_known;\n\t*seclen = strlen(skp->smk_known);\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_ismaclabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4533-4536",
    "snippet": "static int smack_ismaclabel(const char *name)\n{\n\treturn (strcmp(name, XATTR_SMACK_SUFFIX) == 0);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_SMACK_SUFFIX"
          ],
          "line": 4535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_ismaclabel(const char *name)\n{\n\treturn (strcmp(name, XATTR_SMACK_SUFFIX) == 0);\n}"
  },
  {
    "function_name": "smack_audit_rule_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4493-4520",
    "snippet": "static int smack_audit_rule_match(u32 secid, u32 field, u32 op, void *vrule,\n\t\t\t\t  struct audit_context *actx)\n{\n\tstruct smack_known *skp;\n\tchar *rule = vrule;\n\n\tif (unlikely(!rule)) {\n\t\tWARN_ONCE(1, \"Smack: missing rule\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (field != AUDIT_SUBJ_USER && field != AUDIT_OBJ_USER)\n\t\treturn 0;\n\n\tskp = smack_from_secid(secid);\n\n\t/*\n\t * No need to do string comparisons. If a match occurs,\n\t * both pointers will point to the same smack_known\n\t * label.\n\t */\n\tif (op == Audit_equal)\n\t\treturn (rule == skp->smk_known);\n\tif (op == Audit_not_equal)\n\t\treturn (rule != skp->smk_known);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smack_from_secid",
          "args": [
            "secid"
          ],
          "line": 4507
        },
        "resolved": true,
        "details": {
          "function_name": "smack_from_secid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "596-614",
          "snippet": "struct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};\n\nstruct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Smack: missing rule\\n\""
          ],
          "line": 4500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rule"
          ],
          "line": 4499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_audit_rule_match(u32 secid, u32 field, u32 op, void *vrule,\n\t\t\t\t  struct audit_context *actx)\n{\n\tstruct smack_known *skp;\n\tchar *rule = vrule;\n\n\tif (unlikely(!rule)) {\n\t\tWARN_ONCE(1, \"Smack: missing rule\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (field != AUDIT_SUBJ_USER && field != AUDIT_OBJ_USER)\n\t\treturn 0;\n\n\tskp = smack_from_secid(secid);\n\n\t/*\n\t * No need to do string comparisons. If a match occurs,\n\t * both pointers will point to the same smack_known\n\t * label.\n\t */\n\tif (op == Audit_equal)\n\t\treturn (rule == skp->smk_known);\n\tif (op == Audit_not_equal)\n\t\treturn (rule != skp->smk_known);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_audit_rule_known",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4467-4480",
    "snippet": "static int smack_audit_rule_known(struct audit_krule *krule)\n{\n\tstruct audit_field *f;\n\tint i;\n\n\tfor (i = 0; i < krule->field_count; i++) {\n\t\tf = &krule->fields[i];\n\n\t\tif (f->type == AUDIT_SUBJ_USER || f->type == AUDIT_OBJ_USER)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_audit_rule_known(struct audit_krule *krule)\n{\n\tstruct audit_field *f;\n\tint i;\n\n\tfor (i = 0; i < krule->field_count; i++) {\n\t\tf = &krule->fields[i];\n\n\t\tif (f->type == AUDIT_SUBJ_USER || f->type == AUDIT_OBJ_USER)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_audit_rule_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4438-4457",
    "snippet": "static int smack_audit_rule_init(u32 field, u32 op, char *rulestr, void **vrule)\n{\n\tstruct smack_known *skp;\n\tchar **rule = (char **)vrule;\n\t*rule = NULL;\n\n\tif (field != AUDIT_SUBJ_USER && field != AUDIT_OBJ_USER)\n\t\treturn -EINVAL;\n\n\tif (op != Audit_equal && op != Audit_not_equal)\n\t\treturn -EINVAL;\n\n\tskp = smk_import_entry(rulestr, 0);\n\tif (IS_ERR(skp))\n\t\treturn PTR_ERR(skp);\n\n\t*rule = skp->smk_known;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 4452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 4451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "rulestr",
            "0"
          ],
          "line": 4450
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_audit_rule_init(u32 field, u32 op, char *rulestr, void **vrule)\n{\n\tstruct smack_known *skp;\n\tchar **rule = (char **)vrule;\n\t*rule = NULL;\n\n\tif (field != AUDIT_SUBJ_USER && field != AUDIT_OBJ_USER)\n\t\treturn -EINVAL;\n\n\tif (op != Audit_equal && op != Audit_not_equal)\n\t\treturn -EINVAL;\n\n\tskp = smk_import_entry(rulestr, 0);\n\tif (IS_ERR(skp))\n\t\treturn PTR_ERR(skp);\n\n\t*rule = skp->smk_known;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_key_getsecurity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4391-4409",
    "snippet": "static int smack_key_getsecurity(struct key *key, char **_buffer)\n{\n\tstruct smack_known *skp = key->security;\n\tsize_t length;\n\tchar *copy;\n\n\tif (key->security == NULL) {\n\t\t*_buffer = NULL;\n\t\treturn 0;\n\t}\n\n\tcopy = kstrdup(skp->smk_known, GFP_KERNEL);\n\tif (copy == NULL)\n\t\treturn -ENOMEM;\n\tlength = strlen(copy) + 1;\n\n\t*_buffer = copy;\n\treturn length;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "copy"
          ],
          "line": 4405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "skp->smk_known",
            "GFP_KERNEL"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_key_getsecurity(struct key *key, char **_buffer)\n{\n\tstruct smack_known *skp = key->security;\n\tsize_t length;\n\tchar *copy;\n\n\tif (key->security == NULL) {\n\t\t*_buffer = NULL;\n\t\treturn 0;\n\t}\n\n\tcopy = kstrdup(skp->smk_known, GFP_KERNEL);\n\tif (copy == NULL)\n\t\treturn -ENOMEM;\n\tlength = strlen(copy) + 1;\n\n\t*_buffer = copy;\n\treturn length;\n}"
  },
  {
    "function_name": "smack_key_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4345-4380",
    "snippet": "static int smack_key_permission(key_ref_t key_ref,\n\t\t\t\tconst struct cred *cred, unsigned perm)\n{\n\tstruct key *keyp;\n\tstruct smk_audit_info ad;\n\tstruct smack_known *tkp = smk_of_task(cred->security);\n\tint request = 0;\n\tint rc;\n\n\tkeyp = key_ref_to_ptr(key_ref);\n\tif (keyp == NULL)\n\t\treturn -EINVAL;\n\t/*\n\t * If the key hasn't been initialized give it access so that\n\t * it may do so.\n\t */\n\tif (keyp->security == NULL)\n\t\treturn 0;\n\t/*\n\t * This should not occur\n\t */\n\tif (tkp == NULL)\n\t\treturn -EACCES;\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_KEY);\n\tad.a.u.key_struct.key = keyp->serial;\n\tad.a.u.key_struct.key_desc = keyp->description;\n#endif\n\tif (perm & KEY_NEED_READ)\n\t\trequest = MAY_READ;\n\tif (perm & (KEY_NEED_WRITE | KEY_NEED_LINK | KEY_NEED_SETATTR))\n\t\trequest = MAY_WRITE;\n\trc = smk_access(tkp, keyp->security, request, &ad);\n\trc = smk_bu_note(\"key access\", tkp, keyp->security, request, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_note",
          "args": [
            "\"key access\"",
            "tkp",
            "keyp->security",
            "request",
            "rc"
          ],
          "line": 4378
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "101-115",
          "snippet": "static int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_access",
          "args": [
            "tkp",
            "keyp->security",
            "request",
            "&ad"
          ],
          "line": 4377
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "120-209",
          "snippet": "int smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};",
            "struct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};",
            "struct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};",
            "struct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_KEY"
          ],
          "line": 4369
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 4354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_of_task",
          "args": [
            "cred->security"
          ],
          "line": 4350
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "384-392",
          "snippet": "static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_key_permission(key_ref_t key_ref,\n\t\t\t\tconst struct cred *cred, unsigned perm)\n{\n\tstruct key *keyp;\n\tstruct smk_audit_info ad;\n\tstruct smack_known *tkp = smk_of_task(cred->security);\n\tint request = 0;\n\tint rc;\n\n\tkeyp = key_ref_to_ptr(key_ref);\n\tif (keyp == NULL)\n\t\treturn -EINVAL;\n\t/*\n\t * If the key hasn't been initialized give it access so that\n\t * it may do so.\n\t */\n\tif (keyp->security == NULL)\n\t\treturn 0;\n\t/*\n\t * This should not occur\n\t */\n\tif (tkp == NULL)\n\t\treturn -EACCES;\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_KEY);\n\tad.a.u.key_struct.key = keyp->serial;\n\tad.a.u.key_struct.key_desc = keyp->description;\n#endif\n\tif (perm & KEY_NEED_READ)\n\t\trequest = MAY_READ;\n\tif (perm & (KEY_NEED_WRITE | KEY_NEED_LINK | KEY_NEED_SETATTR))\n\t\trequest = MAY_WRITE;\n\trc = smk_access(tkp, keyp->security, request, &ad);\n\trc = smk_bu_note(\"key access\", tkp, keyp->security, request, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_key_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4331-4334",
    "snippet": "static void smack_key_free(struct key *key)\n{\n\tkey->security = NULL;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_key_free(struct key *key)\n{\n\tkey->security = NULL;\n}"
  },
  {
    "function_name": "smack_key_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4316-4323",
    "snippet": "static int smack_key_alloc(struct key *key, const struct cred *cred,\n\t\t\t   unsigned long flags)\n{\n\tstruct smack_known *skp = smk_of_task(cred->security);\n\n\tkey->security = skp;\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_of_task",
          "args": [
            "cred->security"
          ],
          "line": 4319
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "384-392",
          "snippet": "static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_key_alloc(struct key *key, const struct cred *cred,\n\t\t\t   unsigned long flags)\n{\n\tstruct smack_known *skp = smk_of_task(cred->security);\n\n\tkey->security = skp;\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_inet_csk_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4284-4295",
    "snippet": "static void smack_inet_csk_clone(struct sock *sk,\n\t\t\t\t const struct request_sock *req)\n{\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp;\n\n\tif (req->peer_secid != 0) {\n\t\tskp = smack_from_secid(req->peer_secid);\n\t\tssp->smk_packet = skp;\n\t} else\n\t\tssp->smk_packet = NULL;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smack_from_secid",
          "args": [
            "req->peer_secid"
          ],
          "line": 4291
        },
        "resolved": true,
        "details": {
          "function_name": "smack_from_secid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "596-614",
          "snippet": "struct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};\n\nstruct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_inet_csk_clone(struct sock *sk,\n\t\t\t\t const struct request_sock *req)\n{\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp;\n\n\tif (req->peer_secid != 0) {\n\t\tskp = smack_from_secid(req->peer_secid);\n\t\tssp->smk_packet = skp;\n\t} else\n\t\tssp->smk_packet = NULL;\n}"
  },
  {
    "function_name": "smack_inet_conn_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4183-4275",
    "snippet": "static int smack_inet_conn_request(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t   struct request_sock *req)\n{\n\tu16 family = sk->sk_family;\n\tstruct smack_known *skp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct netlbl_lsm_secattr secattr;\n\tstruct sockaddr_in addr;\n\tstruct iphdr *hdr;\n\tstruct smack_known *hskp;\n\tint rc;\n\tstruct smk_audit_info ad;\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (family == PF_INET6) {\n\t\t/*\n\t\t * Handle mapped IPv4 packets arriving\n\t\t * via IPv6 sockets. Don't set up netlabel\n\t\t * processing on IPv6.\n\t\t */\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\tfamily = PF_INET;\n\t\telse\n\t\t\treturn 0;\n\t}\n#endif /* CONFIG_IPV6 */\n\n#ifdef CONFIG_SECURITY_SMACK_NETFILTER\n\t/*\n\t * If there is a secmark use it rather than the CIPSO label.\n\t * If there is no secmark fall back to CIPSO.\n\t * The secmark is assumed to reflect policy better.\n\t */\n\tif (skb && skb->secmark != 0) {\n\t\tskp = smack_from_secid(skb->secmark);\n\t\tgoto access_check;\n\t}\n#endif /* CONFIG_SECURITY_SMACK_NETFILTER */\n\n\tnetlbl_secattr_init(&secattr);\n\trc = netlbl_skbuff_getattr(skb, family, &secattr);\n\tif (rc == 0)\n\t\tskp = smack_from_secattr(&secattr, ssp);\n\telse\n\t\tskp = &smack_known_huh;\n\tnetlbl_secattr_destroy(&secattr);\n\n#ifdef CONFIG_SECURITY_SMACK_NETFILTER\naccess_check:\n#endif\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tad.a.u.net->family = family;\n\tad.a.u.net->netif = skb->skb_iif;\n\tipv4_skb_to_auditdata(skb, &ad.a, NULL);\n#endif\n\t/*\n\t * Receiving a packet requires that the other end be able to write\n\t * here. Read access is not required.\n\t */\n\trc = smk_access(skp, ssp->smk_in, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"IPv4 connect\", skp, ssp->smk_in, MAY_WRITE, rc);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/*\n\t * Save the peer's label in the request_sock so we can later setup\n\t * smk_packet in the child socket so that SO_PEERCRED can report it.\n\t */\n\treq->peer_secid = skp->smk_secid;\n\n\t/*\n\t * We need to decide if we want to label the incoming connection here\n\t * if we do we only need to label the request_sock and the stack will\n\t * propagate the wire-label to the sock when it is created.\n\t */\n\thdr = ip_hdr(skb);\n\taddr.sin_addr.s_addr = hdr->saddr;\n\trcu_read_lock();\n\thskp = smack_ipv4host_label(&addr);\n\trcu_read_unlock();\n\n\tif (hskp == NULL)\n\t\trc = netlbl_req_setattr(req, &skp->smk_netlabel);\n\telse\n\t\tnetlbl_req_delattr(req);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_req_delattr",
          "args": [
            "req"
          ],
          "line": 4272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_req_setattr",
          "args": [
            "req",
            "&skp->smk_netlabel"
          ],
          "line": 4270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_ipv4host_label",
          "args": [
            "&addr"
          ],
          "line": 4266
        },
        "resolved": true,
        "details": {
          "function_name": "smack_ipv4host_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2363-2382",
          "snippet": "static struct smack_known *smack_ipv4host_label(struct sockaddr_in *sip)\n{\n\tstruct smk_net4addr *snp;\n\tstruct in_addr *siap = &sip->sin_addr;\n\n\tif (siap->s_addr == 0)\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net4addr_list, list)\n\t\t/*\n\t\t * we break after finding the first match because\n\t\t * the list is sorted from longest to shortest mask\n\t\t * so we have found the most specific match\n\t\t */\n\t\tif (snp->smk_host.s_addr ==\n\t\t    (siap->s_addr & snp->smk_mask.s_addr))\n\t\t\treturn snp->smk_label;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_ipv4host_label(struct sockaddr_in *sip)\n{\n\tstruct smk_net4addr *snp;\n\tstruct in_addr *siap = &sip->sin_addr;\n\n\tif (siap->s_addr == 0)\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net4addr_list, list)\n\t\t/*\n\t\t * we break after finding the first match because\n\t\t * the list is sorted from longest to shortest mask\n\t\t * so we have found the most specific match\n\t\t */\n\t\tif (snp->smk_host.s_addr ==\n\t\t    (siap->s_addr & snp->smk_mask.s_addr))\n\t\t\treturn snp->smk_label;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_hdr",
          "args": [
            "skb"
          ],
          "line": 4263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_bu_note",
          "args": [
            "\"IPv4 connect\"",
            "skp",
            "ssp->smk_in",
            "MAY_WRITE",
            "rc"
          ],
          "line": 4248
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "101-115",
          "snippet": "static int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_access",
          "args": [
            "skp",
            "ssp->smk_in",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 4247
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "120-209",
          "snippet": "int smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};",
            "struct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};",
            "struct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};",
            "struct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ipv4_skb_to_auditdata",
          "args": [
            "skb",
            "&ad.a",
            "NULL"
          ],
          "line": 4241
        },
        "resolved": true,
        "details": {
          "function_name": "ipv4_skb_to_auditdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/lsm_audit.c",
          "lines": "42-101",
          "snippet": "int ipv4_skb_to_auditdata(struct sk_buff *skb,\n\t\tstruct common_audit_data *ad, u8 *proto)\n{\n\tint ret = 0;\n\tstruct iphdr *ih;\n\n\tih = ip_hdr(skb);\n\tif (ih == NULL)\n\t\treturn -EINVAL;\n\n\tad->u.net->v4info.saddr = ih->saddr;\n\tad->u.net->v4info.daddr = ih->daddr;\n\n\tif (proto)\n\t\t*proto = ih->protocol;\n\t/* non initial fragment */\n\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\treturn 0;\n\n\tswitch (ih->protocol) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr *th = tcp_hdr(skb);\n\t\tif (th == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = th->source;\n\t\tad->u.net->dport = th->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_UDP: {\n\t\tstruct udphdr *uh = udp_hdr(skb);\n\t\tif (uh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = uh->source;\n\t\tad->u.net->dport = uh->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_DCCP: {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\t\tif (dh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = dh->dccph_sport;\n\t\tad->u.net->dport = dh->dccph_dport;\n\t\tbreak;\n\t}\n\tcase IPPROTO_SCTP: {\n\t\tstruct sctphdr *sh = sctp_hdr(skb);\n\t\tif (sh == NULL)\n\t\t\tbreak;\n\t\tad->u.net->sport = sh->source;\n\t\tad->u.net->dport = sh->dest;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/sctp.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <linux/ip.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/sctp.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nint ipv4_skb_to_auditdata(struct sk_buff *skb,\n\t\tstruct common_audit_data *ad, u8 *proto)\n{\n\tint ret = 0;\n\tstruct iphdr *ih;\n\n\tih = ip_hdr(skb);\n\tif (ih == NULL)\n\t\treturn -EINVAL;\n\n\tad->u.net->v4info.saddr = ih->saddr;\n\tad->u.net->v4info.daddr = ih->daddr;\n\n\tif (proto)\n\t\t*proto = ih->protocol;\n\t/* non initial fragment */\n\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\treturn 0;\n\n\tswitch (ih->protocol) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr *th = tcp_hdr(skb);\n\t\tif (th == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = th->source;\n\t\tad->u.net->dport = th->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_UDP: {\n\t\tstruct udphdr *uh = udp_hdr(skb);\n\t\tif (uh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = uh->source;\n\t\tad->u.net->dport = uh->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_DCCP: {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\t\tif (dh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = dh->dccph_sport;\n\t\tad->u.net->dport = dh->dccph_dport;\n\t\tbreak;\n\t}\n\tcase IPPROTO_SCTP: {\n\t\tstruct sctphdr *sh = sctp_hdr(skb);\n\t\tif (sh == NULL)\n\t\t\tbreak;\n\t\tad->u.net->sport = sh->source;\n\t\tad->u.net->dport = sh->dest;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init_net",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_NET",
            "&net"
          ],
          "line": 4238
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "437-443",
          "snippet": "static inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,\n\t\t\t\t   char type, struct lsm_network_audit *net)\n{\n\tsmk_ad_init(a, func, type);\n\tmemset(net, 0, sizeof(*net));\n\ta->a.u.net = net;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,\n\t\t\t\t   char type, struct lsm_network_audit *net)\n{\n\tsmk_ad_init(a, func, type);\n\tmemset(net, 0, sizeof(*net));\n\ta->a.u.net = net;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_secattr_destroy",
          "args": [
            "&secattr"
          ],
          "line": 4231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_from_secattr",
          "args": [
            "&secattr",
            "ssp"
          ],
          "line": 4228
        },
        "resolved": true,
        "details": {
          "function_name": "smack_from_secattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "3831-3897",
          "snippet": "static struct smack_known *smack_from_secattr(struct netlbl_lsm_secattr *sap,\n\t\t\t\t\t\tstruct socket_smack *ssp)\n{\n\tstruct smack_known *skp;\n\tint found = 0;\n\tint acat;\n\tint kcat;\n\n\tif ((sap->flags & NETLBL_SECATTR_MLS_LVL) != 0) {\n\t\t/*\n\t\t * Looks like a CIPSO packet.\n\t\t * If there are flags but no level netlabel isn't\n\t\t * behaving the way we expect it to.\n\t\t *\n\t\t * Look it up in the label table\n\t\t * Without guidance regarding the smack value\n\t\t * for the packet fall back on the network\n\t\t * ambient value.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\t\tif (sap->attr.mls.lvl != skp->smk_netlabel.attr.mls.lvl)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Compare the catsets. Use the netlbl APIs.\n\t\t\t */\n\t\t\tif ((sap->flags & NETLBL_SECATTR_MLS_CAT) == 0) {\n\t\t\t\tif ((skp->smk_netlabel.flags &\n\t\t\t\t     NETLBL_SECATTR_MLS_CAT) == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (acat = -1, kcat = -1; acat == kcat; ) {\n\t\t\t\tacat = netlbl_catmap_walk(sap->attr.mls.cat,\n\t\t\t\t\t\t\t  acat + 1);\n\t\t\t\tkcat = netlbl_catmap_walk(\n\t\t\t\t\tskp->smk_netlabel.attr.mls.cat,\n\t\t\t\t\tkcat + 1);\n\t\t\t\tif (acat < 0 || kcat < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (acat == kcat) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (found)\n\t\t\treturn skp;\n\n\t\tif (ssp != NULL && ssp->smk_in == &smack_known_star)\n\t\t\treturn &smack_known_web;\n\t\treturn &smack_known_star;\n\t}\n\tif ((sap->flags & NETLBL_SECATTR_SECID) != 0)\n\t\t/*\n\t\t * Looks like a fallback, which gives us a secid.\n\t\t */\n\t\treturn smack_from_secid(sap->attr.secid);\n\t/*\n\t * Without guidance regarding the smack value\n\t * for the packet fall back on the network\n\t * ambient value.\n\t */\n\treturn smack_net_ambient;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_from_secattr(struct netlbl_lsm_secattr *sap,\n\t\t\t\t\t\tstruct socket_smack *ssp)\n{\n\tstruct smack_known *skp;\n\tint found = 0;\n\tint acat;\n\tint kcat;\n\n\tif ((sap->flags & NETLBL_SECATTR_MLS_LVL) != 0) {\n\t\t/*\n\t\t * Looks like a CIPSO packet.\n\t\t * If there are flags but no level netlabel isn't\n\t\t * behaving the way we expect it to.\n\t\t *\n\t\t * Look it up in the label table\n\t\t * Without guidance regarding the smack value\n\t\t * for the packet fall back on the network\n\t\t * ambient value.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\t\tif (sap->attr.mls.lvl != skp->smk_netlabel.attr.mls.lvl)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Compare the catsets. Use the netlbl APIs.\n\t\t\t */\n\t\t\tif ((sap->flags & NETLBL_SECATTR_MLS_CAT) == 0) {\n\t\t\t\tif ((skp->smk_netlabel.flags &\n\t\t\t\t     NETLBL_SECATTR_MLS_CAT) == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (acat = -1, kcat = -1; acat == kcat; ) {\n\t\t\t\tacat = netlbl_catmap_walk(sap->attr.mls.cat,\n\t\t\t\t\t\t\t  acat + 1);\n\t\t\t\tkcat = netlbl_catmap_walk(\n\t\t\t\t\tskp->smk_netlabel.attr.mls.cat,\n\t\t\t\t\tkcat + 1);\n\t\t\t\tif (acat < 0 || kcat < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (acat == kcat) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (found)\n\t\t\treturn skp;\n\n\t\tif (ssp != NULL && ssp->smk_in == &smack_known_star)\n\t\t\treturn &smack_known_web;\n\t\treturn &smack_known_star;\n\t}\n\tif ((sap->flags & NETLBL_SECATTR_SECID) != 0)\n\t\t/*\n\t\t * Looks like a fallback, which gives us a secid.\n\t\t */\n\t\treturn smack_from_secid(sap->attr.secid);\n\t/*\n\t * Without guidance regarding the smack value\n\t * for the packet fall back on the network\n\t * ambient value.\n\t */\n\treturn smack_net_ambient;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_skbuff_getattr",
          "args": [
            "skb",
            "family",
            "&secattr"
          ],
          "line": 4226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_secattr_init",
          "args": [
            "&secattr"
          ],
          "line": 4225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_from_secid",
          "args": [
            "skb->secmark"
          ],
          "line": 4220
        },
        "resolved": true,
        "details": {
          "function_name": "smack_from_secid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "596-614",
          "snippet": "struct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};\n\nstruct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "ETH_P_IP"
          ],
          "line": 4206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IPV6"
          ],
          "line": 4199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inet_conn_request(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t   struct request_sock *req)\n{\n\tu16 family = sk->sk_family;\n\tstruct smack_known *skp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct netlbl_lsm_secattr secattr;\n\tstruct sockaddr_in addr;\n\tstruct iphdr *hdr;\n\tstruct smack_known *hskp;\n\tint rc;\n\tstruct smk_audit_info ad;\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (family == PF_INET6) {\n\t\t/*\n\t\t * Handle mapped IPv4 packets arriving\n\t\t * via IPv6 sockets. Don't set up netlabel\n\t\t * processing on IPv6.\n\t\t */\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\tfamily = PF_INET;\n\t\telse\n\t\t\treturn 0;\n\t}\n#endif /* CONFIG_IPV6 */\n\n#ifdef CONFIG_SECURITY_SMACK_NETFILTER\n\t/*\n\t * If there is a secmark use it rather than the CIPSO label.\n\t * If there is no secmark fall back to CIPSO.\n\t * The secmark is assumed to reflect policy better.\n\t */\n\tif (skb && skb->secmark != 0) {\n\t\tskp = smack_from_secid(skb->secmark);\n\t\tgoto access_check;\n\t}\n#endif /* CONFIG_SECURITY_SMACK_NETFILTER */\n\n\tnetlbl_secattr_init(&secattr);\n\trc = netlbl_skbuff_getattr(skb, family, &secattr);\n\tif (rc == 0)\n\t\tskp = smack_from_secattr(&secattr, ssp);\n\telse\n\t\tskp = &smack_known_huh;\n\tnetlbl_secattr_destroy(&secattr);\n\n#ifdef CONFIG_SECURITY_SMACK_NETFILTER\naccess_check:\n#endif\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tad.a.u.net->family = family;\n\tad.a.u.net->netif = skb->skb_iif;\n\tipv4_skb_to_auditdata(skb, &ad.a, NULL);\n#endif\n\t/*\n\t * Receiving a packet requires that the other end be able to write\n\t * here. Read access is not required.\n\t */\n\trc = smk_access(skp, ssp->smk_in, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"IPv4 connect\", skp, ssp->smk_in, MAY_WRITE, rc);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/*\n\t * Save the peer's label in the request_sock so we can later setup\n\t * smk_packet in the child socket so that SO_PEERCRED can report it.\n\t */\n\treq->peer_secid = skp->smk_secid;\n\n\t/*\n\t * We need to decide if we want to label the incoming connection here\n\t * if we do we only need to label the request_sock and the stack will\n\t * propagate the wire-label to the sock when it is created.\n\t */\n\thdr = ip_hdr(skb);\n\taddr.sin_addr.s_addr = hdr->saddr;\n\trcu_read_lock();\n\thskp = smack_ipv4host_label(&addr);\n\trcu_read_unlock();\n\n\tif (hskp == NULL)\n\t\trc = netlbl_req_setattr(req, &skp->smk_netlabel);\n\telse\n\t\tnetlbl_req_delattr(req);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_sock_graft",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4159-4172",
    "snippet": "static void smack_sock_graft(struct sock *sk, struct socket *parent)\n{\n\tstruct socket_smack *ssp;\n\tstruct smack_known *skp = smk_of_current();\n\n\tif (sk == NULL ||\n\t    (sk->sk_family != PF_INET && sk->sk_family != PF_INET6))\n\t\treturn;\n\n\tssp = sk->sk_security;\n\tssp->smk_in = skp;\n\tssp->smk_out = skp;\n\t/* cssp->smk_packet is already set in smack_inet_csk_clone() */\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 4162
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_sock_graft(struct sock *sk, struct socket *parent)\n{\n\tstruct socket_smack *ssp;\n\tstruct smack_known *skp = smk_of_current();\n\n\tif (sk == NULL ||\n\t    (sk->sk_family != PF_INET && sk->sk_family != PF_INET6))\n\t\treturn;\n\n\tssp = sk->sk_security;\n\tssp->smk_in = skp;\n\tssp->smk_out = skp;\n\t/* cssp->smk_packet is already set in smack_inet_csk_clone() */\n}"
  },
  {
    "function_name": "smack_socket_getpeersec_dgram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4093-4149",
    "snippet": "static int smack_socket_getpeersec_dgram(struct socket *sock,\n\t\t\t\t\t struct sk_buff *skb, u32 *secid)\n\n{\n\tstruct netlbl_lsm_secattr secattr;\n\tstruct socket_smack *ssp = NULL;\n\tstruct smack_known *skp;\n\tint family = PF_UNSPEC;\n\tu32 s = 0;\t/* 0 is the invalid secid */\n\tint rc;\n\n\tif (skb != NULL) {\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\tfamily = PF_INET;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\t\tfamily = PF_INET6;\n#endif /* CONFIG_IPV6 */\n\t}\n\tif (family == PF_UNSPEC && sock != NULL)\n\t\tfamily = sock->sk->sk_family;\n\n\tswitch (family) {\n\tcase PF_UNIX:\n\t\tssp = sock->sk->sk_security;\n\t\ts = ssp->smk_out->smk_secid;\n\t\tbreak;\n\tcase PF_INET:\n#ifdef CONFIG_SECURITY_SMACK_NETFILTER\n\t\ts = skb->secmark;\n\t\tif (s != 0)\n\t\t\tbreak;\n#endif\n\t\t/*\n\t\t * Translate what netlabel gave us.\n\t\t */\n\t\tif (sock != NULL && sock->sk != NULL)\n\t\t\tssp = sock->sk->sk_security;\n\t\tnetlbl_secattr_init(&secattr);\n\t\trc = netlbl_skbuff_getattr(skb, family, &secattr);\n\t\tif (rc == 0) {\n\t\t\tskp = smack_from_secattr(&secattr, ssp);\n\t\t\ts = skp->smk_secid;\n\t\t}\n\t\tnetlbl_secattr_destroy(&secattr);\n\t\tbreak;\n\tcase PF_INET6:\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\t\ts = skb->secmark;\n#endif\n\t\tbreak;\n\t}\n\t*secid = s;\n\tif (s == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_secattr_destroy",
          "args": [
            "&secattr"
          ],
          "line": 4137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_from_secattr",
          "args": [
            "&secattr",
            "ssp"
          ],
          "line": 4134
        },
        "resolved": true,
        "details": {
          "function_name": "smack_from_secattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "3831-3897",
          "snippet": "static struct smack_known *smack_from_secattr(struct netlbl_lsm_secattr *sap,\n\t\t\t\t\t\tstruct socket_smack *ssp)\n{\n\tstruct smack_known *skp;\n\tint found = 0;\n\tint acat;\n\tint kcat;\n\n\tif ((sap->flags & NETLBL_SECATTR_MLS_LVL) != 0) {\n\t\t/*\n\t\t * Looks like a CIPSO packet.\n\t\t * If there are flags but no level netlabel isn't\n\t\t * behaving the way we expect it to.\n\t\t *\n\t\t * Look it up in the label table\n\t\t * Without guidance regarding the smack value\n\t\t * for the packet fall back on the network\n\t\t * ambient value.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\t\tif (sap->attr.mls.lvl != skp->smk_netlabel.attr.mls.lvl)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Compare the catsets. Use the netlbl APIs.\n\t\t\t */\n\t\t\tif ((sap->flags & NETLBL_SECATTR_MLS_CAT) == 0) {\n\t\t\t\tif ((skp->smk_netlabel.flags &\n\t\t\t\t     NETLBL_SECATTR_MLS_CAT) == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (acat = -1, kcat = -1; acat == kcat; ) {\n\t\t\t\tacat = netlbl_catmap_walk(sap->attr.mls.cat,\n\t\t\t\t\t\t\t  acat + 1);\n\t\t\t\tkcat = netlbl_catmap_walk(\n\t\t\t\t\tskp->smk_netlabel.attr.mls.cat,\n\t\t\t\t\tkcat + 1);\n\t\t\t\tif (acat < 0 || kcat < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (acat == kcat) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (found)\n\t\t\treturn skp;\n\n\t\tif (ssp != NULL && ssp->smk_in == &smack_known_star)\n\t\t\treturn &smack_known_web;\n\t\treturn &smack_known_star;\n\t}\n\tif ((sap->flags & NETLBL_SECATTR_SECID) != 0)\n\t\t/*\n\t\t * Looks like a fallback, which gives us a secid.\n\t\t */\n\t\treturn smack_from_secid(sap->attr.secid);\n\t/*\n\t * Without guidance regarding the smack value\n\t * for the packet fall back on the network\n\t * ambient value.\n\t */\n\treturn smack_net_ambient;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_from_secattr(struct netlbl_lsm_secattr *sap,\n\t\t\t\t\t\tstruct socket_smack *ssp)\n{\n\tstruct smack_known *skp;\n\tint found = 0;\n\tint acat;\n\tint kcat;\n\n\tif ((sap->flags & NETLBL_SECATTR_MLS_LVL) != 0) {\n\t\t/*\n\t\t * Looks like a CIPSO packet.\n\t\t * If there are flags but no level netlabel isn't\n\t\t * behaving the way we expect it to.\n\t\t *\n\t\t * Look it up in the label table\n\t\t * Without guidance regarding the smack value\n\t\t * for the packet fall back on the network\n\t\t * ambient value.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\t\tif (sap->attr.mls.lvl != skp->smk_netlabel.attr.mls.lvl)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Compare the catsets. Use the netlbl APIs.\n\t\t\t */\n\t\t\tif ((sap->flags & NETLBL_SECATTR_MLS_CAT) == 0) {\n\t\t\t\tif ((skp->smk_netlabel.flags &\n\t\t\t\t     NETLBL_SECATTR_MLS_CAT) == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (acat = -1, kcat = -1; acat == kcat; ) {\n\t\t\t\tacat = netlbl_catmap_walk(sap->attr.mls.cat,\n\t\t\t\t\t\t\t  acat + 1);\n\t\t\t\tkcat = netlbl_catmap_walk(\n\t\t\t\t\tskp->smk_netlabel.attr.mls.cat,\n\t\t\t\t\tkcat + 1);\n\t\t\t\tif (acat < 0 || kcat < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (acat == kcat) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (found)\n\t\t\treturn skp;\n\n\t\tif (ssp != NULL && ssp->smk_in == &smack_known_star)\n\t\t\treturn &smack_known_web;\n\t\treturn &smack_known_star;\n\t}\n\tif ((sap->flags & NETLBL_SECATTR_SECID) != 0)\n\t\t/*\n\t\t * Looks like a fallback, which gives us a secid.\n\t\t */\n\t\treturn smack_from_secid(sap->attr.secid);\n\t/*\n\t * Without guidance regarding the smack value\n\t * for the packet fall back on the network\n\t * ambient value.\n\t */\n\treturn smack_net_ambient;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_skbuff_getattr",
          "args": [
            "skb",
            "family",
            "&secattr"
          ],
          "line": 4132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_secattr_init",
          "args": [
            "&secattr"
          ],
          "line": 4131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IPV6"
          ],
          "line": 4107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "ETH_P_IP"
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_socket_getpeersec_dgram(struct socket *sock,\n\t\t\t\t\t struct sk_buff *skb, u32 *secid)\n\n{\n\tstruct netlbl_lsm_secattr secattr;\n\tstruct socket_smack *ssp = NULL;\n\tstruct smack_known *skp;\n\tint family = PF_UNSPEC;\n\tu32 s = 0;\t/* 0 is the invalid secid */\n\tint rc;\n\n\tif (skb != NULL) {\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\tfamily = PF_INET;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\t\tfamily = PF_INET6;\n#endif /* CONFIG_IPV6 */\n\t}\n\tif (family == PF_UNSPEC && sock != NULL)\n\t\tfamily = sock->sk->sk_family;\n\n\tswitch (family) {\n\tcase PF_UNIX:\n\t\tssp = sock->sk->sk_security;\n\t\ts = ssp->smk_out->smk_secid;\n\t\tbreak;\n\tcase PF_INET:\n#ifdef CONFIG_SECURITY_SMACK_NETFILTER\n\t\ts = skb->secmark;\n\t\tif (s != 0)\n\t\t\tbreak;\n#endif\n\t\t/*\n\t\t * Translate what netlabel gave us.\n\t\t */\n\t\tif (sock != NULL && sock->sk != NULL)\n\t\t\tssp = sock->sk->sk_security;\n\t\tnetlbl_secattr_init(&secattr);\n\t\trc = netlbl_skbuff_getattr(skb, family, &secattr);\n\t\tif (rc == 0) {\n\t\t\tskp = smack_from_secattr(&secattr, ssp);\n\t\t\ts = skp->smk_secid;\n\t\t}\n\t\tnetlbl_secattr_destroy(&secattr);\n\t\tbreak;\n\tcase PF_INET6:\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\t\ts = skb->secmark;\n#endif\n\t\tbreak;\n\t}\n\t*secid = s;\n\tif (s == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_socket_getpeersec_stream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "4058-4082",
    "snippet": "static int smack_socket_getpeersec_stream(struct socket *sock,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen, unsigned len)\n{\n\tstruct socket_smack *ssp;\n\tchar *rcp = \"\";\n\tint slen = 1;\n\tint rc = 0;\n\n\tssp = sock->sk->sk_security;\n\tif (ssp->smk_packet != NULL) {\n\t\trcp = ssp->smk_packet->smk_known;\n\t\tslen = strlen(rcp) + 1;\n\t}\n\n\tif (slen > len)\n\t\trc = -ERANGE;\n\telse if (copy_to_user(optval, rcp, slen) != 0)\n\t\trc = -EFAULT;\n\n\tif (put_user(slen, optlen) != 0)\n\t\trc = -EFAULT;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "slen",
            "optlen"
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "optval",
            "rcp",
            "slen"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rcp"
          ],
          "line": 4070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_socket_getpeersec_stream(struct socket *sock,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen, unsigned len)\n{\n\tstruct socket_smack *ssp;\n\tchar *rcp = \"\";\n\tint slen = 1;\n\tint rc = 0;\n\n\tssp = sock->sk->sk_security;\n\tif (ssp->smk_packet != NULL) {\n\t\trcp = ssp->smk_packet->smk_known;\n\t\tslen = strlen(rcp) + 1;\n\t}\n\n\tif (slen > len)\n\t\trc = -ERANGE;\n\telse if (copy_to_user(optval, rcp, slen) != 0)\n\t\trc = -EFAULT;\n\n\tif (put_user(slen, optlen) != 0)\n\t\trc = -EFAULT;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_socket_sock_rcv_skb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3955-4047",
    "snippet": "static int smack_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct netlbl_lsm_secattr secattr;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp = NULL;\n\tint rc = 0;\n\tstruct smk_audit_info ad;\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct sockaddr_in6 sadd;\n\tint proto;\n#endif /* CONFIG_IPV6 */\n\n\tswitch (sk->sk_family) {\n\tcase PF_INET:\n#ifdef CONFIG_SECURITY_SMACK_NETFILTER\n\t\t/*\n\t\t * If there is a secmark use it rather than the CIPSO label.\n\t\t * If there is no secmark fall back to CIPSO.\n\t\t * The secmark is assumed to reflect policy better.\n\t\t */\n\t\tif (skb && skb->secmark != 0) {\n\t\t\tskp = smack_from_secid(skb->secmark);\n\t\t\tgoto access_check;\n\t\t}\n#endif /* CONFIG_SECURITY_SMACK_NETFILTER */\n\t\t/*\n\t\t * Translate what netlabel gave us.\n\t\t */\n\t\tnetlbl_secattr_init(&secattr);\n\n\t\trc = netlbl_skbuff_getattr(skb, sk->sk_family, &secattr);\n\t\tif (rc == 0)\n\t\t\tskp = smack_from_secattr(&secattr, ssp);\n\t\telse\n\t\t\tskp = smack_net_ambient;\n\n\t\tnetlbl_secattr_destroy(&secattr);\n\n#ifdef CONFIG_SECURITY_SMACK_NETFILTER\naccess_check:\n#endif\n#ifdef CONFIG_AUDIT\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sk->sk_family;\n\t\tad.a.u.net->netif = skb->skb_iif;\n\t\tipv4_skb_to_auditdata(skb, &ad.a, NULL);\n#endif\n\t\t/*\n\t\t * Receiving a packet requires that the other end\n\t\t * be able to write here. Read access is not required.\n\t\t * This is the simplist possible security model\n\t\t * for networking.\n\t\t */\n\t\trc = smk_access(skp, ssp->smk_in, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 delivery\", skp, ssp->smk_in,\n\t\t\t\t\tMAY_WRITE, rc);\n\t\tif (rc != 0)\n\t\t\tnetlbl_skbuff_err(skb, sk->sk_family, rc, 0);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase PF_INET6:\n\t\tproto = smk_skb_to_addr_ipv6(skb, &sadd);\n\t\tif (proto != IPPROTO_UDP && proto != IPPROTO_TCP)\n\t\t\tbreak;\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\t\tif (skb && skb->secmark != 0)\n\t\t\tskp = smack_from_secid(skb->secmark);\n\t\telse\n\t\t\tskp = smack_ipv6host_label(&sadd);\n\t\tif (skp == NULL)\n\t\t\tskp = smack_net_ambient;\n#ifdef CONFIG_AUDIT\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sk->sk_family;\n\t\tad.a.u.net->netif = skb->skb_iif;\n\t\tipv6_skb_to_auditdata(skb, &ad.a, NULL);\n#endif /* CONFIG_AUDIT */\n\t\trc = smk_access(skp, ssp->smk_in, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv6 delivery\", skp, ssp->smk_in,\n\t\t\t\t\tMAY_WRITE, rc);\n#endif /* SMACK_IPV6_SECMARK_LABELING */\n#ifdef SMACK_IPV6_PORT_LABELING\n\t\trc = smk_ipv6_port_check(sk, &sadd, SMK_RECEIVING);\n#endif /* SMACK_IPV6_PORT_LABELING */\n\t\tbreak;\n#endif /* CONFIG_IPV6 */\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [
      "#define SMK_RECEIVING\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_ipv6_port_check",
          "args": [
            "sk",
            "&sadd",
            "SMK_RECEIVING"
          ],
          "line": 4040
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ipv6_port_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2671-2723",
          "snippet": "static int smk_ipv6_port_check(struct sock *sk, struct sockaddr_in6 *address,\n\t\t\t\tint act)\n{\n\tstruct smk_port_label *spp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp = NULL;\n\tunsigned short port;\n\tstruct smack_known *object;\n\n\tif (act == SMK_RECEIVING) {\n\t\tskp = smack_ipv6host_label(address);\n\t\tobject = ssp->smk_in;\n\t} else {\n\t\tskp = ssp->smk_out;\n\t\tobject = smack_ipv6host_label(address);\n\t}\n\n\t/*\n\t * The other end is a single label host.\n\t */\n\tif (skp != NULL && object != NULL)\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\tif (skp == NULL)\n\t\tskp = smack_net_ambient;\n\tif (object == NULL)\n\t\tobject = smack_net_ambient;\n\n\t/*\n\t * It's remote, so port lookup does no good.\n\t */\n\tif (!smk_ipv6_localhost(address))\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\n\t/*\n\t * It's local so the send check has to have passed.\n\t */\n\tif (act == SMK_RECEIVING)\n\t\treturn 0;\n\n\tport = ntohs(address->sin6_port);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sk->sk_type)\n\t\t\tcontinue;\n\t\tobject = spp->smk_in;\n\t\tif (act == SMK_CONNECTING)\n\t\t\tssp->smk_packet = spp->smk_out;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn smk_ipv6_check(skp, object, address, act);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [
            "#define SMK_RECEIVING\t1",
            "#define SMK_CONNECTING\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\n#define SMK_RECEIVING\t1\n#define SMK_CONNECTING\t0\n\nstatic int smk_ipv6_port_check(struct sock *sk, struct sockaddr_in6 *address,\n\t\t\t\tint act)\n{\n\tstruct smk_port_label *spp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp = NULL;\n\tunsigned short port;\n\tstruct smack_known *object;\n\n\tif (act == SMK_RECEIVING) {\n\t\tskp = smack_ipv6host_label(address);\n\t\tobject = ssp->smk_in;\n\t} else {\n\t\tskp = ssp->smk_out;\n\t\tobject = smack_ipv6host_label(address);\n\t}\n\n\t/*\n\t * The other end is a single label host.\n\t */\n\tif (skp != NULL && object != NULL)\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\tif (skp == NULL)\n\t\tskp = smack_net_ambient;\n\tif (object == NULL)\n\t\tobject = smack_net_ambient;\n\n\t/*\n\t * It's remote, so port lookup does no good.\n\t */\n\tif (!smk_ipv6_localhost(address))\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\n\t/*\n\t * It's local so the send check has to have passed.\n\t */\n\tif (act == SMK_RECEIVING)\n\t\treturn 0;\n\n\tport = ntohs(address->sin6_port);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sk->sk_type)\n\t\t\tcontinue;\n\t\tobject = spp->smk_in;\n\t\tif (act == SMK_CONNECTING)\n\t\t\tssp->smk_packet = spp->smk_out;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn smk_ipv6_check(skp, object, address, act);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_bu_note",
          "args": [
            "\"IPv6 delivery\"",
            "skp",
            "ssp->smk_in",
            "MAY_WRITE",
            "rc"
          ],
          "line": 4036
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "101-115",
          "snippet": "static int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_access",
          "args": [
            "skp",
            "ssp->smk_in",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 4035
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "120-209",
          "snippet": "int smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};",
            "struct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};",
            "struct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};",
            "struct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ipv6_skb_to_auditdata",
          "args": [
            "skb",
            "&ad.a",
            "NULL"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "ipv6_skb_to_auditdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/lsm_audit.c",
          "lines": "111-183",
          "snippet": "int ipv6_skb_to_auditdata(struct sk_buff *skb,\n\t\tstruct common_audit_data *ad, u8 *proto)\n{\n\tint offset, ret = 0;\n\tstruct ipv6hdr *ip6;\n\tu8 nexthdr;\n\t__be16 frag_off;\n\n\tip6 = ipv6_hdr(skb);\n\tif (ip6 == NULL)\n\t\treturn -EINVAL;\n\tad->u.net->v6info.saddr = ip6->saddr;\n\tad->u.net->v6info.daddr = ip6->daddr;\n\tret = 0;\n\t/* IPv6 can have several extension header before the Transport header\n\t * skip them */\n\toffset = skb_network_offset(skb);\n\toffset += sizeof(*ip6);\n\tnexthdr = ip6->nexthdr;\n\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr, &frag_off);\n\tif (offset < 0)\n\t\treturn 0;\n\tif (proto)\n\t\t*proto = nexthdr;\n\tswitch (nexthdr) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr _tcph, *th;\n\n\t\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\t\tif (th == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = th->source;\n\t\tad->u.net->dport = th->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_UDP: {\n\t\tstruct udphdr _udph, *uh;\n\n\t\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\t\tif (uh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = uh->source;\n\t\tad->u.net->dport = uh->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_DCCP: {\n\t\tstruct dccp_hdr _dccph, *dh;\n\n\t\tdh = skb_header_pointer(skb, offset, sizeof(_dccph), &_dccph);\n\t\tif (dh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = dh->dccph_sport;\n\t\tad->u.net->dport = dh->dccph_dport;\n\t\tbreak;\n\t}\n\tcase IPPROTO_SCTP: {\n\t\tstruct sctphdr _sctph, *sh;\n\n\t\tsh = skb_header_pointer(skb, offset, sizeof(_sctph), &_sctph);\n\t\tif (sh == NULL)\n\t\t\tbreak;\n\t\tad->u.net->sport = sh->source;\n\t\tad->u.net->dport = sh->dest;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/sctp.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <linux/ip.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/sctp.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nint ipv6_skb_to_auditdata(struct sk_buff *skb,\n\t\tstruct common_audit_data *ad, u8 *proto)\n{\n\tint offset, ret = 0;\n\tstruct ipv6hdr *ip6;\n\tu8 nexthdr;\n\t__be16 frag_off;\n\n\tip6 = ipv6_hdr(skb);\n\tif (ip6 == NULL)\n\t\treturn -EINVAL;\n\tad->u.net->v6info.saddr = ip6->saddr;\n\tad->u.net->v6info.daddr = ip6->daddr;\n\tret = 0;\n\t/* IPv6 can have several extension header before the Transport header\n\t * skip them */\n\toffset = skb_network_offset(skb);\n\toffset += sizeof(*ip6);\n\tnexthdr = ip6->nexthdr;\n\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr, &frag_off);\n\tif (offset < 0)\n\t\treturn 0;\n\tif (proto)\n\t\t*proto = nexthdr;\n\tswitch (nexthdr) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr _tcph, *th;\n\n\t\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\t\tif (th == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = th->source;\n\t\tad->u.net->dport = th->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_UDP: {\n\t\tstruct udphdr _udph, *uh;\n\n\t\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\t\tif (uh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = uh->source;\n\t\tad->u.net->dport = uh->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_DCCP: {\n\t\tstruct dccp_hdr _dccph, *dh;\n\n\t\tdh = skb_header_pointer(skb, offset, sizeof(_dccph), &_dccph);\n\t\tif (dh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = dh->dccph_sport;\n\t\tad->u.net->dport = dh->dccph_dport;\n\t\tbreak;\n\t}\n\tcase IPPROTO_SCTP: {\n\t\tstruct sctphdr _sctph, *sh;\n\n\t\tsh = skb_header_pointer(skb, offset, sizeof(_sctph), &_sctph);\n\t\tif (sh == NULL)\n\t\t\tbreak;\n\t\tad->u.net->sport = sh->source;\n\t\tad->u.net->dport = sh->dest;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init_net",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_NET",
            "&net"
          ],
          "line": 4030
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "437-443",
          "snippet": "static inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,\n\t\t\t\t   char type, struct lsm_network_audit *net)\n{\n\tsmk_ad_init(a, func, type);\n\tmemset(net, 0, sizeof(*net));\n\ta->a.u.net = net;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,\n\t\t\t\t   char type, struct lsm_network_audit *net)\n{\n\tsmk_ad_init(a, func, type);\n\tmemset(net, 0, sizeof(*net));\n\ta->a.u.net = net;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_ipv6host_label",
          "args": [
            "&sadd"
          ],
          "line": 4026
        },
        "resolved": true,
        "details": {
          "function_name": "smack_ipv6host_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2414-2451",
          "snippet": "static struct smack_known *smack_ipv6host_label(struct sockaddr_in6 *sip)\n{\n\tstruct smk_net6addr *snp;\n\tstruct in6_addr *sap = &sip->sin6_addr;\n\tint i;\n\tint found = 0;\n\n\t/*\n\t * It's local. Don't look for a host label.\n\t */\n\tif (smk_ipv6_localhost(sip))\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\n\t\t/*\n\t\t * If the label is NULL the entry has\n\t\t * been renounced. Ignore it.\n\t\t */\n\t\tif (snp->smk_label == NULL)\n\t\t\tcontinue;\n\t\t/*\n\t\t* we break after finding the first match because\n\t\t* the list is sorted from longest to shortest mask\n\t\t* so we have found the most specific match\n\t\t*/\n\t\tfor (found = 1, i = 0; i < 8; i++) {\n\t\t\tif ((sap->s6_addr16[i] & snp->smk_mask.s6_addr16[i]) !=\n\t\t\t    snp->smk_host.s6_addr16[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\treturn snp->smk_label;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_ipv6host_label(struct sockaddr_in6 *sip)\n{\n\tstruct smk_net6addr *snp;\n\tstruct in6_addr *sap = &sip->sin6_addr;\n\tint i;\n\tint found = 0;\n\n\t/*\n\t * It's local. Don't look for a host label.\n\t */\n\tif (smk_ipv6_localhost(sip))\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\n\t\t/*\n\t\t * If the label is NULL the entry has\n\t\t * been renounced. Ignore it.\n\t\t */\n\t\tif (snp->smk_label == NULL)\n\t\t\tcontinue;\n\t\t/*\n\t\t* we break after finding the first match because\n\t\t* the list is sorted from longest to shortest mask\n\t\t* so we have found the most specific match\n\t\t*/\n\t\tfor (found = 1, i = 0; i < 8; i++) {\n\t\t\tif ((sap->s6_addr16[i] & snp->smk_mask.s6_addr16[i]) !=\n\t\t\t    snp->smk_host.s6_addr16[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\treturn snp->smk_label;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_from_secid",
          "args": [
            "skb->secmark"
          ],
          "line": 4024
        },
        "resolved": true,
        "details": {
          "function_name": "smack_from_secid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "596-614",
          "snippet": "struct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};\n\nstruct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_skb_to_addr_ipv6",
          "args": [
            "skb",
            "&sadd"
          ],
          "line": 4019
        },
        "resolved": true,
        "details": {
          "function_name": "smk_skb_to_addr_ipv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "3900-3945",
          "snippet": "static int smk_skb_to_addr_ipv6(struct sk_buff *skb, struct sockaddr_in6 *sip)\n{\n\tu8 nexthdr;\n\tint offset;\n\tint proto = -EINVAL;\n\tstruct ipv6hdr _ipv6h;\n\tstruct ipv6hdr *ip6;\n\t__be16 frag_off;\n\tstruct tcphdr _tcph, *th;\n\tstruct udphdr _udph, *uh;\n\tstruct dccp_hdr _dccph, *dh;\n\n\tsip->sin6_port = 0;\n\n\toffset = skb_network_offset(skb);\n\tip6 = skb_header_pointer(skb, offset, sizeof(_ipv6h), &_ipv6h);\n\tif (ip6 == NULL)\n\t\treturn -EINVAL;\n\tsip->sin6_addr = ip6->saddr;\n\n\tnexthdr = ip6->nexthdr;\n\toffset += sizeof(_ipv6h);\n\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr, &frag_off);\n\tif (offset < 0)\n\t\treturn -EINVAL;\n\n\tproto = nexthdr;\n\tswitch (proto) {\n\tcase IPPROTO_TCP:\n\t\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\t\tif (th != NULL)\n\t\t\tsip->sin6_port = th->source;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\t\tif (uh != NULL)\n\t\t\tsip->sin6_port = uh->source;\n\t\tbreak;\n\tcase IPPROTO_DCCP:\n\t\tdh = skb_header_pointer(skb, offset, sizeof(_dccph), &_dccph);\n\t\tif (dh != NULL)\n\t\t\tsip->sin6_port = dh->dccph_sport;\n\t\tbreak;\n\t}\n\treturn proto;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_skb_to_addr_ipv6(struct sk_buff *skb, struct sockaddr_in6 *sip)\n{\n\tu8 nexthdr;\n\tint offset;\n\tint proto = -EINVAL;\n\tstruct ipv6hdr _ipv6h;\n\tstruct ipv6hdr *ip6;\n\t__be16 frag_off;\n\tstruct tcphdr _tcph, *th;\n\tstruct udphdr _udph, *uh;\n\tstruct dccp_hdr _dccph, *dh;\n\n\tsip->sin6_port = 0;\n\n\toffset = skb_network_offset(skb);\n\tip6 = skb_header_pointer(skb, offset, sizeof(_ipv6h), &_ipv6h);\n\tif (ip6 == NULL)\n\t\treturn -EINVAL;\n\tsip->sin6_addr = ip6->saddr;\n\n\tnexthdr = ip6->nexthdr;\n\toffset += sizeof(_ipv6h);\n\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr, &frag_off);\n\tif (offset < 0)\n\t\treturn -EINVAL;\n\n\tproto = nexthdr;\n\tswitch (proto) {\n\tcase IPPROTO_TCP:\n\t\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\t\tif (th != NULL)\n\t\t\tsip->sin6_port = th->source;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\t\tif (uh != NULL)\n\t\t\tsip->sin6_port = uh->source;\n\t\tbreak;\n\tcase IPPROTO_DCCP:\n\t\tdh = skb_header_pointer(skb, offset, sizeof(_dccph), &_dccph);\n\t\tif (dh != NULL)\n\t\t\tsip->sin6_port = dh->dccph_sport;\n\t\tbreak;\n\t}\n\treturn proto;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IPV6"
          ],
          "line": 4017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_skbuff_err",
          "args": [
            "skb",
            "sk->sk_family",
            "rc",
            "0"
          ],
          "line": 4015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipv4_skb_to_auditdata",
          "args": [
            "skb",
            "&ad.a",
            "NULL"
          ],
          "line": 4003
        },
        "resolved": true,
        "details": {
          "function_name": "ipv4_skb_to_auditdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/lsm_audit.c",
          "lines": "42-101",
          "snippet": "int ipv4_skb_to_auditdata(struct sk_buff *skb,\n\t\tstruct common_audit_data *ad, u8 *proto)\n{\n\tint ret = 0;\n\tstruct iphdr *ih;\n\n\tih = ip_hdr(skb);\n\tif (ih == NULL)\n\t\treturn -EINVAL;\n\n\tad->u.net->v4info.saddr = ih->saddr;\n\tad->u.net->v4info.daddr = ih->daddr;\n\n\tif (proto)\n\t\t*proto = ih->protocol;\n\t/* non initial fragment */\n\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\treturn 0;\n\n\tswitch (ih->protocol) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr *th = tcp_hdr(skb);\n\t\tif (th == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = th->source;\n\t\tad->u.net->dport = th->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_UDP: {\n\t\tstruct udphdr *uh = udp_hdr(skb);\n\t\tif (uh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = uh->source;\n\t\tad->u.net->dport = uh->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_DCCP: {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\t\tif (dh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = dh->dccph_sport;\n\t\tad->u.net->dport = dh->dccph_dport;\n\t\tbreak;\n\t}\n\tcase IPPROTO_SCTP: {\n\t\tstruct sctphdr *sh = sctp_hdr(skb);\n\t\tif (sh == NULL)\n\t\t\tbreak;\n\t\tad->u.net->sport = sh->source;\n\t\tad->u.net->dport = sh->dest;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/sctp.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <linux/ip.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/sctp.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nint ipv4_skb_to_auditdata(struct sk_buff *skb,\n\t\tstruct common_audit_data *ad, u8 *proto)\n{\n\tint ret = 0;\n\tstruct iphdr *ih;\n\n\tih = ip_hdr(skb);\n\tif (ih == NULL)\n\t\treturn -EINVAL;\n\n\tad->u.net->v4info.saddr = ih->saddr;\n\tad->u.net->v4info.daddr = ih->daddr;\n\n\tif (proto)\n\t\t*proto = ih->protocol;\n\t/* non initial fragment */\n\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\treturn 0;\n\n\tswitch (ih->protocol) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr *th = tcp_hdr(skb);\n\t\tif (th == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = th->source;\n\t\tad->u.net->dport = th->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_UDP: {\n\t\tstruct udphdr *uh = udp_hdr(skb);\n\t\tif (uh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = uh->source;\n\t\tad->u.net->dport = uh->dest;\n\t\tbreak;\n\t}\n\tcase IPPROTO_DCCP: {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\t\tif (dh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = dh->dccph_sport;\n\t\tad->u.net->dport = dh->dccph_dport;\n\t\tbreak;\n\t}\n\tcase IPPROTO_SCTP: {\n\t\tstruct sctphdr *sh = sctp_hdr(skb);\n\t\tif (sh == NULL)\n\t\t\tbreak;\n\t\tad->u.net->sport = sh->source;\n\t\tad->u.net->dport = sh->dest;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_secattr_destroy",
          "args": [
            "&secattr"
          ],
          "line": 3994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_from_secattr",
          "args": [
            "&secattr",
            "ssp"
          ],
          "line": 3990
        },
        "resolved": true,
        "details": {
          "function_name": "smack_from_secattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "3831-3897",
          "snippet": "static struct smack_known *smack_from_secattr(struct netlbl_lsm_secattr *sap,\n\t\t\t\t\t\tstruct socket_smack *ssp)\n{\n\tstruct smack_known *skp;\n\tint found = 0;\n\tint acat;\n\tint kcat;\n\n\tif ((sap->flags & NETLBL_SECATTR_MLS_LVL) != 0) {\n\t\t/*\n\t\t * Looks like a CIPSO packet.\n\t\t * If there are flags but no level netlabel isn't\n\t\t * behaving the way we expect it to.\n\t\t *\n\t\t * Look it up in the label table\n\t\t * Without guidance regarding the smack value\n\t\t * for the packet fall back on the network\n\t\t * ambient value.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\t\tif (sap->attr.mls.lvl != skp->smk_netlabel.attr.mls.lvl)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Compare the catsets. Use the netlbl APIs.\n\t\t\t */\n\t\t\tif ((sap->flags & NETLBL_SECATTR_MLS_CAT) == 0) {\n\t\t\t\tif ((skp->smk_netlabel.flags &\n\t\t\t\t     NETLBL_SECATTR_MLS_CAT) == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (acat = -1, kcat = -1; acat == kcat; ) {\n\t\t\t\tacat = netlbl_catmap_walk(sap->attr.mls.cat,\n\t\t\t\t\t\t\t  acat + 1);\n\t\t\t\tkcat = netlbl_catmap_walk(\n\t\t\t\t\tskp->smk_netlabel.attr.mls.cat,\n\t\t\t\t\tkcat + 1);\n\t\t\t\tif (acat < 0 || kcat < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (acat == kcat) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (found)\n\t\t\treturn skp;\n\n\t\tif (ssp != NULL && ssp->smk_in == &smack_known_star)\n\t\t\treturn &smack_known_web;\n\t\treturn &smack_known_star;\n\t}\n\tif ((sap->flags & NETLBL_SECATTR_SECID) != 0)\n\t\t/*\n\t\t * Looks like a fallback, which gives us a secid.\n\t\t */\n\t\treturn smack_from_secid(sap->attr.secid);\n\t/*\n\t * Without guidance regarding the smack value\n\t * for the packet fall back on the network\n\t * ambient value.\n\t */\n\treturn smack_net_ambient;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_from_secattr(struct netlbl_lsm_secattr *sap,\n\t\t\t\t\t\tstruct socket_smack *ssp)\n{\n\tstruct smack_known *skp;\n\tint found = 0;\n\tint acat;\n\tint kcat;\n\n\tif ((sap->flags & NETLBL_SECATTR_MLS_LVL) != 0) {\n\t\t/*\n\t\t * Looks like a CIPSO packet.\n\t\t * If there are flags but no level netlabel isn't\n\t\t * behaving the way we expect it to.\n\t\t *\n\t\t * Look it up in the label table\n\t\t * Without guidance regarding the smack value\n\t\t * for the packet fall back on the network\n\t\t * ambient value.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\t\tif (sap->attr.mls.lvl != skp->smk_netlabel.attr.mls.lvl)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Compare the catsets. Use the netlbl APIs.\n\t\t\t */\n\t\t\tif ((sap->flags & NETLBL_SECATTR_MLS_CAT) == 0) {\n\t\t\t\tif ((skp->smk_netlabel.flags &\n\t\t\t\t     NETLBL_SECATTR_MLS_CAT) == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (acat = -1, kcat = -1; acat == kcat; ) {\n\t\t\t\tacat = netlbl_catmap_walk(sap->attr.mls.cat,\n\t\t\t\t\t\t\t  acat + 1);\n\t\t\t\tkcat = netlbl_catmap_walk(\n\t\t\t\t\tskp->smk_netlabel.attr.mls.cat,\n\t\t\t\t\tkcat + 1);\n\t\t\t\tif (acat < 0 || kcat < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (acat == kcat) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (found)\n\t\t\treturn skp;\n\n\t\tif (ssp != NULL && ssp->smk_in == &smack_known_star)\n\t\t\treturn &smack_known_web;\n\t\treturn &smack_known_star;\n\t}\n\tif ((sap->flags & NETLBL_SECATTR_SECID) != 0)\n\t\t/*\n\t\t * Looks like a fallback, which gives us a secid.\n\t\t */\n\t\treturn smack_from_secid(sap->attr.secid);\n\t/*\n\t * Without guidance regarding the smack value\n\t * for the packet fall back on the network\n\t * ambient value.\n\t */\n\treturn smack_net_ambient;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_skbuff_getattr",
          "args": [
            "skb",
            "sk->sk_family",
            "&secattr"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_secattr_init",
          "args": [
            "&secattr"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IPV6"
          ],
          "line": 3965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\n#define SMK_RECEIVING\t1\n\nstatic int smack_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct netlbl_lsm_secattr secattr;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp = NULL;\n\tint rc = 0;\n\tstruct smk_audit_info ad;\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct sockaddr_in6 sadd;\n\tint proto;\n#endif /* CONFIG_IPV6 */\n\n\tswitch (sk->sk_family) {\n\tcase PF_INET:\n#ifdef CONFIG_SECURITY_SMACK_NETFILTER\n\t\t/*\n\t\t * If there is a secmark use it rather than the CIPSO label.\n\t\t * If there is no secmark fall back to CIPSO.\n\t\t * The secmark is assumed to reflect policy better.\n\t\t */\n\t\tif (skb && skb->secmark != 0) {\n\t\t\tskp = smack_from_secid(skb->secmark);\n\t\t\tgoto access_check;\n\t\t}\n#endif /* CONFIG_SECURITY_SMACK_NETFILTER */\n\t\t/*\n\t\t * Translate what netlabel gave us.\n\t\t */\n\t\tnetlbl_secattr_init(&secattr);\n\n\t\trc = netlbl_skbuff_getattr(skb, sk->sk_family, &secattr);\n\t\tif (rc == 0)\n\t\t\tskp = smack_from_secattr(&secattr, ssp);\n\t\telse\n\t\t\tskp = smack_net_ambient;\n\n\t\tnetlbl_secattr_destroy(&secattr);\n\n#ifdef CONFIG_SECURITY_SMACK_NETFILTER\naccess_check:\n#endif\n#ifdef CONFIG_AUDIT\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sk->sk_family;\n\t\tad.a.u.net->netif = skb->skb_iif;\n\t\tipv4_skb_to_auditdata(skb, &ad.a, NULL);\n#endif\n\t\t/*\n\t\t * Receiving a packet requires that the other end\n\t\t * be able to write here. Read access is not required.\n\t\t * This is the simplist possible security model\n\t\t * for networking.\n\t\t */\n\t\trc = smk_access(skp, ssp->smk_in, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 delivery\", skp, ssp->smk_in,\n\t\t\t\t\tMAY_WRITE, rc);\n\t\tif (rc != 0)\n\t\t\tnetlbl_skbuff_err(skb, sk->sk_family, rc, 0);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase PF_INET6:\n\t\tproto = smk_skb_to_addr_ipv6(skb, &sadd);\n\t\tif (proto != IPPROTO_UDP && proto != IPPROTO_TCP)\n\t\t\tbreak;\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\t\tif (skb && skb->secmark != 0)\n\t\t\tskp = smack_from_secid(skb->secmark);\n\t\telse\n\t\t\tskp = smack_ipv6host_label(&sadd);\n\t\tif (skp == NULL)\n\t\t\tskp = smack_net_ambient;\n#ifdef CONFIG_AUDIT\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sk->sk_family;\n\t\tad.a.u.net->netif = skb->skb_iif;\n\t\tipv6_skb_to_auditdata(skb, &ad.a, NULL);\n#endif /* CONFIG_AUDIT */\n\t\trc = smk_access(skp, ssp->smk_in, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv6 delivery\", skp, ssp->smk_in,\n\t\t\t\t\tMAY_WRITE, rc);\n#endif /* SMACK_IPV6_SECMARK_LABELING */\n#ifdef SMACK_IPV6_PORT_LABELING\n\t\trc = smk_ipv6_port_check(sk, &sadd, SMK_RECEIVING);\n#endif /* SMACK_IPV6_PORT_LABELING */\n\t\tbreak;\n#endif /* CONFIG_IPV6 */\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_skb_to_addr_ipv6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3900-3945",
    "snippet": "static int smk_skb_to_addr_ipv6(struct sk_buff *skb, struct sockaddr_in6 *sip)\n{\n\tu8 nexthdr;\n\tint offset;\n\tint proto = -EINVAL;\n\tstruct ipv6hdr _ipv6h;\n\tstruct ipv6hdr *ip6;\n\t__be16 frag_off;\n\tstruct tcphdr _tcph, *th;\n\tstruct udphdr _udph, *uh;\n\tstruct dccp_hdr _dccph, *dh;\n\n\tsip->sin6_port = 0;\n\n\toffset = skb_network_offset(skb);\n\tip6 = skb_header_pointer(skb, offset, sizeof(_ipv6h), &_ipv6h);\n\tif (ip6 == NULL)\n\t\treturn -EINVAL;\n\tsip->sin6_addr = ip6->saddr;\n\n\tnexthdr = ip6->nexthdr;\n\toffset += sizeof(_ipv6h);\n\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr, &frag_off);\n\tif (offset < 0)\n\t\treturn -EINVAL;\n\n\tproto = nexthdr;\n\tswitch (proto) {\n\tcase IPPROTO_TCP:\n\t\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\t\tif (th != NULL)\n\t\t\tsip->sin6_port = th->source;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\t\tif (uh != NULL)\n\t\t\tsip->sin6_port = uh->source;\n\t\tbreak;\n\tcase IPPROTO_DCCP:\n\t\tdh = skb_header_pointer(skb, offset, sizeof(_dccph), &_dccph);\n\t\tif (dh != NULL)\n\t\t\tsip->sin6_port = dh->dccph_sport;\n\t\tbreak;\n\t}\n\treturn proto;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "skb_header_pointer",
          "args": [
            "skb",
            "offset",
            "sizeof(_dccph)",
            "&_dccph"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_header_pointer",
          "args": [
            "skb",
            "offset",
            "sizeof(_udph)",
            "&_udph"
          ],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_header_pointer",
          "args": [
            "skb",
            "offset",
            "sizeof(_tcph)",
            "&_tcph"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipv6_skip_exthdr",
          "args": [
            "skb",
            "offset",
            "&nexthdr",
            "&frag_off"
          ],
          "line": 3922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_header_pointer",
          "args": [
            "skb",
            "offset",
            "sizeof(_ipv6h)",
            "&_ipv6h"
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_network_offset",
          "args": [
            "skb"
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_skb_to_addr_ipv6(struct sk_buff *skb, struct sockaddr_in6 *sip)\n{\n\tu8 nexthdr;\n\tint offset;\n\tint proto = -EINVAL;\n\tstruct ipv6hdr _ipv6h;\n\tstruct ipv6hdr *ip6;\n\t__be16 frag_off;\n\tstruct tcphdr _tcph, *th;\n\tstruct udphdr _udph, *uh;\n\tstruct dccp_hdr _dccph, *dh;\n\n\tsip->sin6_port = 0;\n\n\toffset = skb_network_offset(skb);\n\tip6 = skb_header_pointer(skb, offset, sizeof(_ipv6h), &_ipv6h);\n\tif (ip6 == NULL)\n\t\treturn -EINVAL;\n\tsip->sin6_addr = ip6->saddr;\n\n\tnexthdr = ip6->nexthdr;\n\toffset += sizeof(_ipv6h);\n\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr, &frag_off);\n\tif (offset < 0)\n\t\treturn -EINVAL;\n\n\tproto = nexthdr;\n\tswitch (proto) {\n\tcase IPPROTO_TCP:\n\t\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\t\tif (th != NULL)\n\t\t\tsip->sin6_port = th->source;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\t\tif (uh != NULL)\n\t\t\tsip->sin6_port = uh->source;\n\t\tbreak;\n\tcase IPPROTO_DCCP:\n\t\tdh = skb_header_pointer(skb, offset, sizeof(_dccph), &_dccph);\n\t\tif (dh != NULL)\n\t\t\tsip->sin6_port = dh->dccph_sport;\n\t\tbreak;\n\t}\n\treturn proto;\n}"
  },
  {
    "function_name": "smack_from_secattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3831-3897",
    "snippet": "static struct smack_known *smack_from_secattr(struct netlbl_lsm_secattr *sap,\n\t\t\t\t\t\tstruct socket_smack *ssp)\n{\n\tstruct smack_known *skp;\n\tint found = 0;\n\tint acat;\n\tint kcat;\n\n\tif ((sap->flags & NETLBL_SECATTR_MLS_LVL) != 0) {\n\t\t/*\n\t\t * Looks like a CIPSO packet.\n\t\t * If there are flags but no level netlabel isn't\n\t\t * behaving the way we expect it to.\n\t\t *\n\t\t * Look it up in the label table\n\t\t * Without guidance regarding the smack value\n\t\t * for the packet fall back on the network\n\t\t * ambient value.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\t\tif (sap->attr.mls.lvl != skp->smk_netlabel.attr.mls.lvl)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Compare the catsets. Use the netlbl APIs.\n\t\t\t */\n\t\t\tif ((sap->flags & NETLBL_SECATTR_MLS_CAT) == 0) {\n\t\t\t\tif ((skp->smk_netlabel.flags &\n\t\t\t\t     NETLBL_SECATTR_MLS_CAT) == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (acat = -1, kcat = -1; acat == kcat; ) {\n\t\t\t\tacat = netlbl_catmap_walk(sap->attr.mls.cat,\n\t\t\t\t\t\t\t  acat + 1);\n\t\t\t\tkcat = netlbl_catmap_walk(\n\t\t\t\t\tskp->smk_netlabel.attr.mls.cat,\n\t\t\t\t\tkcat + 1);\n\t\t\t\tif (acat < 0 || kcat < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (acat == kcat) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (found)\n\t\t\treturn skp;\n\n\t\tif (ssp != NULL && ssp->smk_in == &smack_known_star)\n\t\t\treturn &smack_known_web;\n\t\treturn &smack_known_star;\n\t}\n\tif ((sap->flags & NETLBL_SECATTR_SECID) != 0)\n\t\t/*\n\t\t * Looks like a fallback, which gives us a secid.\n\t\t */\n\t\treturn smack_from_secid(sap->attr.secid);\n\t/*\n\t * Without guidance regarding the smack value\n\t * for the packet fall back on the network\n\t * ambient value.\n\t */\n\treturn smack_net_ambient;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smack_from_secid",
          "args": [
            "sap->attr.secid"
          ],
          "line": 3890
        },
        "resolved": true,
        "details": {
          "function_name": "smack_from_secid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "596-614",
          "snippet": "struct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};\n\nstruct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_catmap_walk",
          "args": [
            "skp->smk_netlabel.attr.mls.cat",
            "kcat + 1"
          ],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_catmap_walk",
          "args": [
            "sap->attr.mls.cat",
            "acat + 1"
          ],
          "line": 3864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "skp",
            "&smack_known_list",
            "list"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_from_secattr(struct netlbl_lsm_secattr *sap,\n\t\t\t\t\t\tstruct socket_smack *ssp)\n{\n\tstruct smack_known *skp;\n\tint found = 0;\n\tint acat;\n\tint kcat;\n\n\tif ((sap->flags & NETLBL_SECATTR_MLS_LVL) != 0) {\n\t\t/*\n\t\t * Looks like a CIPSO packet.\n\t\t * If there are flags but no level netlabel isn't\n\t\t * behaving the way we expect it to.\n\t\t *\n\t\t * Look it up in the label table\n\t\t * Without guidance regarding the smack value\n\t\t * for the packet fall back on the network\n\t\t * ambient value.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\t\tif (sap->attr.mls.lvl != skp->smk_netlabel.attr.mls.lvl)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Compare the catsets. Use the netlbl APIs.\n\t\t\t */\n\t\t\tif ((sap->flags & NETLBL_SECATTR_MLS_CAT) == 0) {\n\t\t\t\tif ((skp->smk_netlabel.flags &\n\t\t\t\t     NETLBL_SECATTR_MLS_CAT) == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (acat = -1, kcat = -1; acat == kcat; ) {\n\t\t\t\tacat = netlbl_catmap_walk(sap->attr.mls.cat,\n\t\t\t\t\t\t\t  acat + 1);\n\t\t\t\tkcat = netlbl_catmap_walk(\n\t\t\t\t\tskp->smk_netlabel.attr.mls.cat,\n\t\t\t\t\tkcat + 1);\n\t\t\t\tif (acat < 0 || kcat < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (acat == kcat) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (found)\n\t\t\treturn skp;\n\n\t\tif (ssp != NULL && ssp->smk_in == &smack_known_star)\n\t\t\treturn &smack_known_web;\n\t\treturn &smack_known_star;\n\t}\n\tif ((sap->flags & NETLBL_SECATTR_SECID) != 0)\n\t\t/*\n\t\t * Looks like a fallback, which gives us a secid.\n\t\t */\n\t\treturn smack_from_secid(sap->attr.secid);\n\t/*\n\t * Without guidance regarding the smack value\n\t * for the packet fall back on the network\n\t * ambient value.\n\t */\n\treturn smack_net_ambient;\n}"
  },
  {
    "function_name": "smack_socket_sendmsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3786-3822",
    "snippet": "static int smack_socket_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t\tint size)\n{\n\tstruct sockaddr_in *sip = (struct sockaddr_in *) msg->msg_name;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct sockaddr_in6 *sap = (struct sockaddr_in6 *) msg->msg_name;\n#endif\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n\tstruct smack_known *rsp;\n#endif\n\tint rc = 0;\n\n\t/*\n\t * Perfectly reasonable for this to be NULL\n\t */\n\tif (sip == NULL)\n\t\treturn 0;\n\n\tswitch (sock->sk->sk_family) {\n\tcase AF_INET:\n\t\trc = smack_netlabel_send(sock->sk, sip);\n\t\tbreak;\n\tcase AF_INET6:\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\t\trsp = smack_ipv6host_label(sap);\n\t\tif (rsp != NULL)\n\t\t\trc = smk_ipv6_check(ssp->smk_out, rsp, sap,\n\t\t\t\t\t\tSMK_CONNECTING);\n#endif\n#ifdef SMACK_IPV6_PORT_LABELING\n\t\trc = smk_ipv6_port_check(sock->sk, sap, SMK_SENDING);\n#endif\n\t\tbreak;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [
      "#define SMK_SENDING\t2",
      "#define SMK_CONNECTING\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_ipv6_port_check",
          "args": [
            "sock->sk",
            "sap",
            "SMK_SENDING"
          ],
          "line": 3817
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ipv6_port_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2671-2723",
          "snippet": "static int smk_ipv6_port_check(struct sock *sk, struct sockaddr_in6 *address,\n\t\t\t\tint act)\n{\n\tstruct smk_port_label *spp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp = NULL;\n\tunsigned short port;\n\tstruct smack_known *object;\n\n\tif (act == SMK_RECEIVING) {\n\t\tskp = smack_ipv6host_label(address);\n\t\tobject = ssp->smk_in;\n\t} else {\n\t\tskp = ssp->smk_out;\n\t\tobject = smack_ipv6host_label(address);\n\t}\n\n\t/*\n\t * The other end is a single label host.\n\t */\n\tif (skp != NULL && object != NULL)\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\tif (skp == NULL)\n\t\tskp = smack_net_ambient;\n\tif (object == NULL)\n\t\tobject = smack_net_ambient;\n\n\t/*\n\t * It's remote, so port lookup does no good.\n\t */\n\tif (!smk_ipv6_localhost(address))\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\n\t/*\n\t * It's local so the send check has to have passed.\n\t */\n\tif (act == SMK_RECEIVING)\n\t\treturn 0;\n\n\tport = ntohs(address->sin6_port);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sk->sk_type)\n\t\t\tcontinue;\n\t\tobject = spp->smk_in;\n\t\tif (act == SMK_CONNECTING)\n\t\t\tssp->smk_packet = spp->smk_out;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn smk_ipv6_check(skp, object, address, act);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [
            "#define SMK_RECEIVING\t1",
            "#define SMK_CONNECTING\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\n#define SMK_RECEIVING\t1\n#define SMK_CONNECTING\t0\n\nstatic int smk_ipv6_port_check(struct sock *sk, struct sockaddr_in6 *address,\n\t\t\t\tint act)\n{\n\tstruct smk_port_label *spp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp = NULL;\n\tunsigned short port;\n\tstruct smack_known *object;\n\n\tif (act == SMK_RECEIVING) {\n\t\tskp = smack_ipv6host_label(address);\n\t\tobject = ssp->smk_in;\n\t} else {\n\t\tskp = ssp->smk_out;\n\t\tobject = smack_ipv6host_label(address);\n\t}\n\n\t/*\n\t * The other end is a single label host.\n\t */\n\tif (skp != NULL && object != NULL)\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\tif (skp == NULL)\n\t\tskp = smack_net_ambient;\n\tif (object == NULL)\n\t\tobject = smack_net_ambient;\n\n\t/*\n\t * It's remote, so port lookup does no good.\n\t */\n\tif (!smk_ipv6_localhost(address))\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\n\t/*\n\t * It's local so the send check has to have passed.\n\t */\n\tif (act == SMK_RECEIVING)\n\t\treturn 0;\n\n\tport = ntohs(address->sin6_port);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sk->sk_type)\n\t\t\tcontinue;\n\t\tobject = spp->smk_in;\n\t\tif (act == SMK_CONNECTING)\n\t\t\tssp->smk_packet = spp->smk_out;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn smk_ipv6_check(skp, object, address, act);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ipv6_check",
          "args": [
            "ssp->smk_out",
            "rsp",
            "sap",
            "SMK_CONNECTING"
          ],
          "line": 3813
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ipv6_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2551-2573",
          "snippet": "static int smk_ipv6_check(struct smack_known *subject,\n\t\t\t\tstruct smack_known *object,\n\t\t\t\tstruct sockaddr_in6 *address, int act)\n{\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tad.a.u.net->family = PF_INET6;\n\tad.a.u.net->dport = ntohs(address->sin6_port);\n\tif (act == SMK_RECEIVING)\n\t\tad.a.u.net->v6info.saddr = address->sin6_addr;\n\telse\n\t\tad.a.u.net->v6info.daddr = address->sin6_addr;\n#endif\n\trc = smk_access(subject, object, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"IPv6 check\", subject, object, MAY_WRITE, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [
            "#define SMK_RECEIVING\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\n#define SMK_RECEIVING\t1\n\nstatic int smk_ipv6_check(struct smack_known *subject,\n\t\t\t\tstruct smack_known *object,\n\t\t\t\tstruct sockaddr_in6 *address, int act)\n{\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tad.a.u.net->family = PF_INET6;\n\tad.a.u.net->dport = ntohs(address->sin6_port);\n\tif (act == SMK_RECEIVING)\n\t\tad.a.u.net->v6info.saddr = address->sin6_addr;\n\telse\n\t\tad.a.u.net->v6info.daddr = address->sin6_addr;\n#endif\n\trc = smk_access(subject, object, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"IPv6 check\", subject, object, MAY_WRITE, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_ipv6host_label",
          "args": [
            "sap"
          ],
          "line": 3811
        },
        "resolved": true,
        "details": {
          "function_name": "smack_ipv6host_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2414-2451",
          "snippet": "static struct smack_known *smack_ipv6host_label(struct sockaddr_in6 *sip)\n{\n\tstruct smk_net6addr *snp;\n\tstruct in6_addr *sap = &sip->sin6_addr;\n\tint i;\n\tint found = 0;\n\n\t/*\n\t * It's local. Don't look for a host label.\n\t */\n\tif (smk_ipv6_localhost(sip))\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\n\t\t/*\n\t\t * If the label is NULL the entry has\n\t\t * been renounced. Ignore it.\n\t\t */\n\t\tif (snp->smk_label == NULL)\n\t\t\tcontinue;\n\t\t/*\n\t\t* we break after finding the first match because\n\t\t* the list is sorted from longest to shortest mask\n\t\t* so we have found the most specific match\n\t\t*/\n\t\tfor (found = 1, i = 0; i < 8; i++) {\n\t\t\tif ((sap->s6_addr16[i] & snp->smk_mask.s6_addr16[i]) !=\n\t\t\t    snp->smk_host.s6_addr16[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\treturn snp->smk_label;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_ipv6host_label(struct sockaddr_in6 *sip)\n{\n\tstruct smk_net6addr *snp;\n\tstruct in6_addr *sap = &sip->sin6_addr;\n\tint i;\n\tint found = 0;\n\n\t/*\n\t * It's local. Don't look for a host label.\n\t */\n\tif (smk_ipv6_localhost(sip))\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\n\t\t/*\n\t\t * If the label is NULL the entry has\n\t\t * been renounced. Ignore it.\n\t\t */\n\t\tif (snp->smk_label == NULL)\n\t\t\tcontinue;\n\t\t/*\n\t\t* we break after finding the first match because\n\t\t* the list is sorted from longest to shortest mask\n\t\t* so we have found the most specific match\n\t\t*/\n\t\tfor (found = 1, i = 0; i < 8; i++) {\n\t\t\tif ((sap->s6_addr16[i] & snp->smk_mask.s6_addr16[i]) !=\n\t\t\t    snp->smk_host.s6_addr16[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\treturn snp->smk_label;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_netlabel_send",
          "args": [
            "sock->sk",
            "sip"
          ],
          "line": 3807
        },
        "resolved": true,
        "details": {
          "function_name": "smack_netlabel_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2506-2539",
          "snippet": "static int smack_netlabel_send(struct sock *sk, struct sockaddr_in *sap)\n{\n\tstruct smack_known *skp;\n\tint rc;\n\tint sk_lbl;\n\tstruct smack_known *hkp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smk_audit_info ad;\n\n\trcu_read_lock();\n\thkp = smack_ipv4host_label(sap);\n\tif (hkp != NULL) {\n#ifdef CONFIG_AUDIT\n\t\tstruct lsm_network_audit net;\n\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sap->sin_family;\n\t\tad.a.u.net->dport = sap->sin_port;\n\t\tad.a.u.net->v4info.daddr = sap->sin_addr.s_addr;\n#endif\n\t\tsk_lbl = SMACK_UNLABELED_SOCKET;\n\t\tskp = ssp->smk_out;\n\t\trc = smk_access(skp, hkp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 host check\", skp, hkp, MAY_WRITE, rc);\n\t} else {\n\t\tsk_lbl = SMACK_CIPSO_SOCKET;\n\t\trc = 0;\n\t}\n\trcu_read_unlock();\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn smack_netlabel(sk, sk_lbl);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_netlabel_send(struct sock *sk, struct sockaddr_in *sap)\n{\n\tstruct smack_known *skp;\n\tint rc;\n\tint sk_lbl;\n\tstruct smack_known *hkp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smk_audit_info ad;\n\n\trcu_read_lock();\n\thkp = smack_ipv4host_label(sap);\n\tif (hkp != NULL) {\n#ifdef CONFIG_AUDIT\n\t\tstruct lsm_network_audit net;\n\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sap->sin_family;\n\t\tad.a.u.net->dport = sap->sin_port;\n\t\tad.a.u.net->v4info.daddr = sap->sin_addr.s_addr;\n#endif\n\t\tsk_lbl = SMACK_UNLABELED_SOCKET;\n\t\tskp = ssp->smk_out;\n\t\trc = smk_access(skp, hkp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 host check\", skp, hkp, MAY_WRITE, rc);\n\t} else {\n\t\tsk_lbl = SMACK_CIPSO_SOCKET;\n\t\trc = 0;\n\t}\n\trcu_read_unlock();\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn smack_netlabel(sk, sk_lbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IPV6"
          ],
          "line": 3790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\n#define SMK_SENDING\t2\n#define SMK_CONNECTING\t0\n\nstatic int smack_socket_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t\tint size)\n{\n\tstruct sockaddr_in *sip = (struct sockaddr_in *) msg->msg_name;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct sockaddr_in6 *sap = (struct sockaddr_in6 *) msg->msg_name;\n#endif\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n\tstruct smack_known *rsp;\n#endif\n\tint rc = 0;\n\n\t/*\n\t * Perfectly reasonable for this to be NULL\n\t */\n\tif (sip == NULL)\n\t\treturn 0;\n\n\tswitch (sock->sk->sk_family) {\n\tcase AF_INET:\n\t\trc = smack_netlabel_send(sock->sk, sip);\n\t\tbreak;\n\tcase AF_INET6:\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\t\trsp = smack_ipv6host_label(sap);\n\t\tif (rsp != NULL)\n\t\t\trc = smk_ipv6_check(ssp->smk_out, rsp, sap,\n\t\t\t\t\t\tSMK_CONNECTING);\n#endif\n#ifdef SMACK_IPV6_PORT_LABELING\n\t\trc = smk_ipv6_port_check(sock->sk, sap, SMK_SENDING);\n#endif\n\t\tbreak;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_unix_may_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3754-3774",
    "snippet": "static int smack_unix_may_send(struct socket *sock, struct socket *other)\n{\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n\tstruct socket_smack *osp = other->sk->sk_security;\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tsmk_ad_setfield_u_net_sk(&ad, other->sk);\n#endif\n\n\tif (smack_privileged(CAP_MAC_OVERRIDE))\n\t\treturn 0;\n\n\trc = smk_access(ssp->smk_out, osp->smk_in, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"UDS send\", ssp->smk_out, osp->smk_in, MAY_WRITE, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_note",
          "args": [
            "\"UDS send\"",
            "ssp->smk_out",
            "osp->smk_in",
            "MAY_WRITE",
            "rc"
          ],
          "line": 3772
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "101-115",
          "snippet": "static int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_access",
          "args": [
            "ssp->smk_out",
            "osp->smk_in",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 3771
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "120-209",
          "snippet": "int smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};",
            "struct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};",
            "struct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};",
            "struct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_OVERRIDE"
          ],
          "line": 3768
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_net_sk",
          "args": [
            "&ad",
            "other->sk"
          ],
          "line": 3765
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_net_sk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "497-500",
          "snippet": "static inline void smk_ad_setfield_u_net_sk(struct smk_audit_info *a,\n\t\t\t\t\t    struct sock *sk)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_net_sk(struct smk_audit_info *a,\n\t\t\t\t\t    struct sock *sk)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init_net",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_NET",
            "&net"
          ],
          "line": 3764
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "437-443",
          "snippet": "static inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,\n\t\t\t\t   char type, struct lsm_network_audit *net)\n{\n\tsmk_ad_init(a, func, type);\n\tmemset(net, 0, sizeof(*net));\n\ta->a.u.net = net;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,\n\t\t\t\t   char type, struct lsm_network_audit *net)\n{\n\tsmk_ad_init(a, func, type);\n\tmemset(net, 0, sizeof(*net));\n\ta->a.u.net = net;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_unix_may_send(struct socket *sock, struct socket *other)\n{\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n\tstruct socket_smack *osp = other->sk->sk_security;\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tsmk_ad_setfield_u_net_sk(&ad, other->sk);\n#endif\n\n\tif (smack_privileged(CAP_MAC_OVERRIDE))\n\t\treturn 0;\n\n\trc = smk_access(ssp->smk_out, osp->smk_in, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"UDS send\", ssp->smk_out, osp->smk_in, MAY_WRITE, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_unix_stream_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3703-3744",
    "snippet": "static int smack_unix_stream_connect(struct sock *sock,\n\t\t\t\t     struct sock *other, struct sock *newsk)\n{\n\tstruct smack_known *skp;\n\tstruct smack_known *okp;\n\tstruct socket_smack *ssp = sock->sk_security;\n\tstruct socket_smack *osp = other->sk_security;\n\tstruct socket_smack *nsp = newsk->sk_security;\n\tstruct smk_audit_info ad;\n\tint rc = 0;\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\n\tif (!smack_privileged(CAP_MAC_OVERRIDE)) {\n\t\tskp = ssp->smk_out;\n\t\tokp = osp->smk_in;\n#ifdef CONFIG_AUDIT\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tsmk_ad_setfield_u_net_sk(&ad, other);\n#endif\n\t\trc = smk_access(skp, okp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"UDS connect\", skp, okp, MAY_WRITE, rc);\n\t\tif (rc == 0) {\n\t\t\tokp = osp->smk_out;\n\t\t\tskp = ssp->smk_in;\n\t\t\trc = smk_access(okp, skp, MAY_WRITE, &ad);\n\t\t\trc = smk_bu_note(\"UDS connect\", okp, skp,\n\t\t\t\t\t\tMAY_WRITE, rc);\n\t\t}\n\t}\n\n\t/*\n\t * Cross reference the peer labels for SO_PEERSEC.\n\t */\n\tif (rc == 0) {\n\t\tnsp->smk_packet = ssp->smk_out;\n\t\tssp->smk_packet = osp->smk_out;\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_note",
          "args": [
            "\"UDS connect\"",
            "okp",
            "skp",
            "MAY_WRITE",
            "rc"
          ],
          "line": 3730
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "101-115",
          "snippet": "static int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_access",
          "args": [
            "okp",
            "skp",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 3729
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "120-209",
          "snippet": "int smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};",
            "struct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};",
            "struct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};",
            "struct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_net_sk",
          "args": [
            "&ad",
            "other"
          ],
          "line": 3722
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_net_sk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "497-500",
          "snippet": "static inline void smk_ad_setfield_u_net_sk(struct smk_audit_info *a,\n\t\t\t\t\t    struct sock *sk)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_net_sk(struct smk_audit_info *a,\n\t\t\t\t\t    struct sock *sk)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init_net",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_NET",
            "&net"
          ],
          "line": 3721
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "437-443",
          "snippet": "static inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,\n\t\t\t\t   char type, struct lsm_network_audit *net)\n{\n\tsmk_ad_init(a, func, type);\n\tmemset(net, 0, sizeof(*net));\n\ta->a.u.net = net;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,\n\t\t\t\t   char type, struct lsm_network_audit *net)\n{\n\tsmk_ad_init(a, func, type);\n\tmemset(net, 0, sizeof(*net));\n\ta->a.u.net = net;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_OVERRIDE"
          ],
          "line": 3717
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_unix_stream_connect(struct sock *sock,\n\t\t\t\t     struct sock *other, struct sock *newsk)\n{\n\tstruct smack_known *skp;\n\tstruct smack_known *okp;\n\tstruct socket_smack *ssp = sock->sk_security;\n\tstruct socket_smack *osp = other->sk_security;\n\tstruct socket_smack *nsp = newsk->sk_security;\n\tstruct smk_audit_info ad;\n\tint rc = 0;\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\n\tif (!smack_privileged(CAP_MAC_OVERRIDE)) {\n\t\tskp = ssp->smk_out;\n\t\tokp = osp->smk_in;\n#ifdef CONFIG_AUDIT\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tsmk_ad_setfield_u_net_sk(&ad, other);\n#endif\n\t\trc = smk_access(skp, okp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"UDS connect\", skp, okp, MAY_WRITE, rc);\n\t\tif (rc == 0) {\n\t\t\tokp = osp->smk_out;\n\t\t\tskp = ssp->smk_in;\n\t\t\trc = smk_access(okp, skp, MAY_WRITE, &ad);\n\t\t\trc = smk_bu_note(\"UDS connect\", okp, skp,\n\t\t\t\t\t\tMAY_WRITE, rc);\n\t\t}\n\t}\n\n\t/*\n\t * Cross reference the peer labels for SO_PEERSEC.\n\t */\n\tif (rc == 0) {\n\t\tnsp->smk_packet = ssp->smk_out;\n\t\tssp->smk_packet = osp->smk_out;\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_setprocattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3640-3692",
    "snippet": "static int smack_setprocattr(const char *name, void *value, size_t size)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct cred *new;\n\tstruct smack_known *skp;\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN) && list_empty(&tsp->smk_relabel))\n\t\treturn -EPERM;\n\n\tif (value == NULL || size == 0 || size >= SMK_LONGLABEL)\n\t\treturn -EINVAL;\n\n\tif (strcmp(name, \"current\") != 0)\n\t\treturn -EINVAL;\n\n\tskp = smk_import_entry(value, size);\n\tif (IS_ERR(skp))\n\t\treturn PTR_ERR(skp);\n\n\t/*\n\t * No process is ever allowed the web (\"@\") label\n\t * and the star (\"*\") label.\n\t */\n\tif (skp == &smack_known_web || skp == &smack_known_star)\n\t\treturn -EINVAL;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN)) {\n\t\trc = -EPERM;\n\t\tlist_for_each_entry(sklep, &tsp->smk_relabel, list)\n\t\t\tif (sklep->smk_label == skp) {\n\t\t\t\trc = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tnew = prepare_creds();\n\tif (new == NULL)\n\t\treturn -ENOMEM;\n\n\ttsp = new->security;\n\ttsp->smk_task = skp;\n\t/*\n\t * process can change its label only once\n\t */\n\tsmk_destroy_label_list(&tsp->smk_relabel);\n\n\tcommit_creds(new);\n\treturn size;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 3690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_destroy_label_list",
          "args": [
            "&tsp->smk_relabel"
          ],
          "line": 3688
        },
        "resolved": true,
        "details": {
          "function_name": "smk_destroy_label_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "1988-1997",
          "snippet": "void smk_destroy_label_list(struct list_head *list)\n{\n\tstruct smack_known_list_elem *sklep;\n\tstruct smack_known_list_elem *sklep2;\n\n\tlist_for_each_entry_safe(sklep, sklep2, list, list)\n\t\tkfree(sklep);\n\n\tINIT_LIST_HEAD(list);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nvoid smk_destroy_label_list(struct list_head *list)\n{\n\tstruct smack_known_list_elem *sklep;\n\tstruct smack_known_list_elem *sklep2;\n\n\tlist_for_each_entry_safe(sklep, sklep2, list, list)\n\t\tkfree(sklep);\n\n\tINIT_LIST_HEAD(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sklep",
            "&tsp->smk_relabel",
            "list"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 3668
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "value",
            "size"
          ],
          "line": 3657
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"current\""
          ],
          "line": 3654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tsp->smk_relabel"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 3642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_setprocattr(const char *name, void *value, size_t size)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct cred *new;\n\tstruct smack_known *skp;\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN) && list_empty(&tsp->smk_relabel))\n\t\treturn -EPERM;\n\n\tif (value == NULL || size == 0 || size >= SMK_LONGLABEL)\n\t\treturn -EINVAL;\n\n\tif (strcmp(name, \"current\") != 0)\n\t\treturn -EINVAL;\n\n\tskp = smk_import_entry(value, size);\n\tif (IS_ERR(skp))\n\t\treturn PTR_ERR(skp);\n\n\t/*\n\t * No process is ever allowed the web (\"@\") label\n\t * and the star (\"*\") label.\n\t */\n\tif (skp == &smack_known_web || skp == &smack_known_star)\n\t\treturn -EINVAL;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN)) {\n\t\trc = -EPERM;\n\t\tlist_for_each_entry(sklep, &tsp->smk_relabel, list)\n\t\t\tif (sklep->smk_label == skp) {\n\t\t\t\trc = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tnew = prepare_creds();\n\tif (new == NULL)\n\t\treturn -ENOMEM;\n\n\ttsp = new->security;\n\ttsp->smk_task = skp;\n\t/*\n\t * process can change its label only once\n\t */\n\tsmk_destroy_label_list(&tsp->smk_relabel);\n\n\tcommit_creds(new);\n\treturn size;\n}"
  },
  {
    "function_name": "smack_getprocattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3611-3627",
    "snippet": "static int smack_getprocattr(struct task_struct *p, char *name, char **value)\n{\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tchar *cp;\n\tint slen;\n\n\tif (strcmp(name, \"current\") != 0)\n\t\treturn -EINVAL;\n\n\tcp = kstrdup(skp->smk_known, GFP_KERNEL);\n\tif (cp == NULL)\n\t\treturn -ENOMEM;\n\n\tslen = strlen(cp);\n\t*value = cp;\n\treturn slen;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "skp->smk_known",
            "GFP_KERNEL"
          ],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"current\""
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_of_task_struct",
          "args": [
            "p"
          ],
          "line": 3613
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "384-392",
          "snippet": "static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_getprocattr(struct task_struct *p, char *name, char **value)\n{\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tchar *cp;\n\tint slen;\n\n\tif (strcmp(name, \"current\") != 0)\n\t\treturn -EINVAL;\n\n\tcp = kstrdup(skp->smk_known, GFP_KERNEL);\n\tif (cp == NULL)\n\t\treturn -ENOMEM;\n\n\tslen = strlen(cp);\n\t*value = cp;\n\treturn slen;\n}"
  },
  {
    "function_name": "smack_d_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3387-3599",
    "snippet": "static void smack_d_instantiate(struct dentry *opt_dentry, struct inode *inode)\n{\n\tstruct super_block *sbp;\n\tstruct superblock_smack *sbsp;\n\tstruct inode_smack *isp;\n\tstruct smack_known *skp;\n\tstruct smack_known *ckp = smk_of_current();\n\tstruct smack_known *final;\n\tchar trattr[TRANS_TRUE_SIZE];\n\tint transflag = 0;\n\tint rc;\n\tstruct dentry *dp;\n\n\tif (inode == NULL)\n\t\treturn;\n\n\tisp = inode->i_security;\n\n\tmutex_lock(&isp->smk_lock);\n\t/*\n\t * If the inode is already instantiated\n\t * take the quick way out\n\t */\n\tif (isp->smk_flags & SMK_INODE_INSTANT)\n\t\tgoto unlockandout;\n\n\tsbp = inode->i_sb;\n\tsbsp = sbp->s_security;\n\t/*\n\t * We're going to use the superblock default label\n\t * if there's no label on the file.\n\t */\n\tfinal = sbsp->smk_default;\n\n\t/*\n\t * If this is the root inode the superblock\n\t * may be in the process of initialization.\n\t * If that is the case use the root value out\n\t * of the superblock.\n\t */\n\tif (opt_dentry->d_parent == opt_dentry) {\n\t\tswitch (sbp->s_magic) {\n\t\tcase CGROUP_SUPER_MAGIC:\n\t\t\t/*\n\t\t\t * The cgroup filesystem is never mounted,\n\t\t\t * so there's no opportunity to set the mount\n\t\t\t * options.\n\t\t\t */\n\t\t\tsbsp->smk_root = &smack_known_star;\n\t\t\tsbsp->smk_default = &smack_known_star;\n\t\t\tisp->smk_inode = sbsp->smk_root;\n\t\t\tbreak;\n\t\tcase TMPFS_MAGIC:\n\t\t\t/*\n\t\t\t * What about shmem/tmpfs anonymous files with dentry\n\t\t\t * obtained from d_alloc_pseudo()?\n\t\t\t */\n\t\t\tisp->smk_inode = smk_of_current();\n\t\t\tbreak;\n\t\tcase PIPEFS_MAGIC:\n\t\t\tisp->smk_inode = smk_of_current();\n\t\t\tbreak;\n\t\tcase SOCKFS_MAGIC:\n\t\t\t/*\n\t\t\t * Socket access is controlled by the socket\n\t\t\t * structures associated with the task involved.\n\t\t\t */\n\t\t\tisp->smk_inode = &smack_known_star;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tisp->smk_inode = sbsp->smk_root;\n\t\t\tbreak;\n\t\t}\n\t\tisp->smk_flags |= SMK_INODE_INSTANT;\n\t\tgoto unlockandout;\n\t}\n\n\t/*\n\t * This is pretty hackish.\n\t * Casey says that we shouldn't have to do\n\t * file system specific code, but it does help\n\t * with keeping it simple.\n\t */\n\tswitch (sbp->s_magic) {\n\tcase SMACK_MAGIC:\n\tcase CGROUP_SUPER_MAGIC:\n\t\t/*\n\t\t * Casey says that it's a little embarrassing\n\t\t * that the smack file system doesn't do\n\t\t * extended attributes.\n\t\t *\n\t\t * Cgroupfs is special\n\t\t */\n\t\tfinal = &smack_known_star;\n\t\tbreak;\n\tcase DEVPTS_SUPER_MAGIC:\n\t\t/*\n\t\t * devpts seems content with the label of the task.\n\t\t * Programs that change smack have to treat the\n\t\t * pty with respect.\n\t\t */\n\t\tfinal = ckp;\n\t\tbreak;\n\tcase PROC_SUPER_MAGIC:\n\t\t/*\n\t\t * Casey says procfs appears not to care.\n\t\t * The superblock default suffices.\n\t\t */\n\t\tbreak;\n\tcase TMPFS_MAGIC:\n\t\t/*\n\t\t * Device labels should come from the filesystem,\n\t\t * but watch out, because they're volitile,\n\t\t * getting recreated on every reboot.\n\t\t */\n\t\tfinal = &smack_known_star;\n\t\t/*\n\t\t * No break.\n\t\t *\n\t\t * If a smack value has been set we want to use it,\n\t\t * but since tmpfs isn't giving us the opportunity\n\t\t * to set mount options simulate setting the\n\t\t * superblock default.\n\t\t */\n\tdefault:\n\t\t/*\n\t\t * This isn't an understood special case.\n\t\t * Get the value from the xattr.\n\t\t */\n\n\t\t/*\n\t\t * UNIX domain sockets use lower level socket data.\n\t\t */\n\t\tif (S_ISSOCK(inode->i_mode)) {\n\t\t\tfinal = &smack_known_star;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * No xattr support means, alas, no SMACK label.\n\t\t * Use the aforeapplied default.\n\t\t * It would be curious if the label of the task\n\t\t * does not match that assigned.\n\t\t */\n\t\tif (!(inode->i_opflags & IOP_XATTR))\n\t\t        break;\n\t\t/*\n\t\t * Get the dentry for xattr.\n\t\t */\n\t\tdp = dget(opt_dentry);\n\t\tskp = smk_fetch(XATTR_NAME_SMACK, inode, dp);\n\t\tif (!IS_ERR_OR_NULL(skp))\n\t\t\tfinal = skp;\n\n\t\t/*\n\t\t * Transmuting directory\n\t\t */\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\t/*\n\t\t\t * If this is a new directory and the label was\n\t\t\t * transmuted when the inode was initialized\n\t\t\t * set the transmute attribute on the directory\n\t\t\t * and mark the inode.\n\t\t\t *\n\t\t\t * If there is a transmute attribute on the\n\t\t\t * directory mark the inode.\n\t\t\t */\n\t\t\tif (isp->smk_flags & SMK_INODE_CHANGED) {\n\t\t\t\tisp->smk_flags &= ~SMK_INODE_CHANGED;\n\t\t\t\trc = __vfs_setxattr(dp, inode,\n\t\t\t\t\tXATTR_NAME_SMACKTRANSMUTE,\n\t\t\t\t\tTRANS_TRUE, TRANS_TRUE_SIZE,\n\t\t\t\t\t0);\n\t\t\t} else {\n\t\t\t\trc = __vfs_getxattr(dp, inode,\n\t\t\t\t\tXATTR_NAME_SMACKTRANSMUTE, trattr,\n\t\t\t\t\tTRANS_TRUE_SIZE);\n\t\t\t\tif (rc >= 0 && strncmp(trattr, TRANS_TRUE,\n\t\t\t\t\t\t       TRANS_TRUE_SIZE) != 0)\n\t\t\t\t\trc = -EINVAL;\n\t\t\t}\n\t\t\tif (rc >= 0)\n\t\t\t\ttransflag = SMK_INODE_TRANSMUTE;\n\t\t}\n\t\t/*\n\t\t * Don't let the exec or mmap label be \"*\" or \"@\".\n\t\t */\n\t\tskp = smk_fetch(XATTR_NAME_SMACKEXEC, inode, dp);\n\t\tif (IS_ERR(skp) || skp == &smack_known_star ||\n\t\t    skp == &smack_known_web)\n\t\t\tskp = NULL;\n\t\tisp->smk_task = skp;\n\n\t\tskp = smk_fetch(XATTR_NAME_SMACKMMAP, inode, dp);\n\t\tif (IS_ERR(skp) || skp == &smack_known_star ||\n\t\t    skp == &smack_known_web)\n\t\t\tskp = NULL;\n\t\tisp->smk_mmap = skp;\n\n\t\tdput(dp);\n\t\tbreak;\n\t}\n\n\tif (final == NULL)\n\t\tisp->smk_inode = ckp;\n\telse\n\t\tisp->smk_inode = final;\n\n\tisp->smk_flags |= (SMK_INODE_INSTANT | transflag);\n\nunlockandout:\n\tmutex_unlock(&isp->smk_lock);\n\treturn;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [
      "#define TRANS_TRUE_SIZE\t4",
      "#define TRANS_TRUE\t\"TRUE\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&isp->smk_lock"
          ],
          "line": 3597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dp"
          ],
          "line": 3585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 3580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_fetch",
          "args": [
            "XATTR_NAME_SMACKMMAP",
            "inode",
            "dp"
          ],
          "line": 3579
        },
        "resolved": true,
        "details": {
          "function_name": "smk_fetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "262-287",
          "snippet": "static struct smack_known *smk_fetch(const char *name, struct inode *ip,\n\t\t\t\t\tstruct dentry *dp)\n{\n\tint rc;\n\tchar *buffer;\n\tstruct smack_known *skp = NULL;\n\n\tif (!(ip->i_opflags & IOP_XATTR))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tbuffer = kzalloc(SMK_LONGLABEL, GFP_KERNEL);\n\tif (buffer == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = __vfs_getxattr(dp, ip, name, buffer, SMK_LONGLABEL);\n\tif (rc < 0)\n\t\tskp = ERR_PTR(rc);\n\telse if (rc == 0)\n\t\tskp = NULL;\n\telse\n\t\tskp = smk_import_entry(buffer, rc);\n\n\tkfree(buffer);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smk_fetch(const char *name, struct inode *ip,\n\t\t\t\t\tstruct dentry *dp)\n{\n\tint rc;\n\tchar *buffer;\n\tstruct smack_known *skp = NULL;\n\n\tif (!(ip->i_opflags & IOP_XATTR))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tbuffer = kzalloc(SMK_LONGLABEL, GFP_KERNEL);\n\tif (buffer == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = __vfs_getxattr(dp, ip, name, buffer, SMK_LONGLABEL);\n\tif (rc < 0)\n\t\tskp = ERR_PTR(rc);\n\telse if (rc == 0)\n\t\tskp = NULL;\n\telse\n\t\tskp = smk_import_entry(buffer, rc);\n\n\tkfree(buffer);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "trattr",
            "TRANS_TRUE",
            "TRANS_TRUE_SIZE"
          ],
          "line": 3563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vfs_getxattr",
          "args": [
            "dp",
            "inode",
            "XATTR_NAME_SMACKTRANSMUTE",
            "trattr",
            "TRANS_TRUE_SIZE"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vfs_setxattr",
          "args": [
            "dp",
            "inode",
            "XATTR_NAME_SMACKTRANSMUTE",
            "TRANS_TRUE",
            "TRANS_TRUE_SIZE",
            "0"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 3543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "skp"
          ],
          "line": 3537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "opt_dentry"
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "inode->i_mode"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 3447
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&isp->smk_lock"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\n#define TRANS_TRUE_SIZE\t4\n#define TRANS_TRUE\t\"TRUE\"\n\nstatic void smack_d_instantiate(struct dentry *opt_dentry, struct inode *inode)\n{\n\tstruct super_block *sbp;\n\tstruct superblock_smack *sbsp;\n\tstruct inode_smack *isp;\n\tstruct smack_known *skp;\n\tstruct smack_known *ckp = smk_of_current();\n\tstruct smack_known *final;\n\tchar trattr[TRANS_TRUE_SIZE];\n\tint transflag = 0;\n\tint rc;\n\tstruct dentry *dp;\n\n\tif (inode == NULL)\n\t\treturn;\n\n\tisp = inode->i_security;\n\n\tmutex_lock(&isp->smk_lock);\n\t/*\n\t * If the inode is already instantiated\n\t * take the quick way out\n\t */\n\tif (isp->smk_flags & SMK_INODE_INSTANT)\n\t\tgoto unlockandout;\n\n\tsbp = inode->i_sb;\n\tsbsp = sbp->s_security;\n\t/*\n\t * We're going to use the superblock default label\n\t * if there's no label on the file.\n\t */\n\tfinal = sbsp->smk_default;\n\n\t/*\n\t * If this is the root inode the superblock\n\t * may be in the process of initialization.\n\t * If that is the case use the root value out\n\t * of the superblock.\n\t */\n\tif (opt_dentry->d_parent == opt_dentry) {\n\t\tswitch (sbp->s_magic) {\n\t\tcase CGROUP_SUPER_MAGIC:\n\t\t\t/*\n\t\t\t * The cgroup filesystem is never mounted,\n\t\t\t * so there's no opportunity to set the mount\n\t\t\t * options.\n\t\t\t */\n\t\t\tsbsp->smk_root = &smack_known_star;\n\t\t\tsbsp->smk_default = &smack_known_star;\n\t\t\tisp->smk_inode = sbsp->smk_root;\n\t\t\tbreak;\n\t\tcase TMPFS_MAGIC:\n\t\t\t/*\n\t\t\t * What about shmem/tmpfs anonymous files with dentry\n\t\t\t * obtained from d_alloc_pseudo()?\n\t\t\t */\n\t\t\tisp->smk_inode = smk_of_current();\n\t\t\tbreak;\n\t\tcase PIPEFS_MAGIC:\n\t\t\tisp->smk_inode = smk_of_current();\n\t\t\tbreak;\n\t\tcase SOCKFS_MAGIC:\n\t\t\t/*\n\t\t\t * Socket access is controlled by the socket\n\t\t\t * structures associated with the task involved.\n\t\t\t */\n\t\t\tisp->smk_inode = &smack_known_star;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tisp->smk_inode = sbsp->smk_root;\n\t\t\tbreak;\n\t\t}\n\t\tisp->smk_flags |= SMK_INODE_INSTANT;\n\t\tgoto unlockandout;\n\t}\n\n\t/*\n\t * This is pretty hackish.\n\t * Casey says that we shouldn't have to do\n\t * file system specific code, but it does help\n\t * with keeping it simple.\n\t */\n\tswitch (sbp->s_magic) {\n\tcase SMACK_MAGIC:\n\tcase CGROUP_SUPER_MAGIC:\n\t\t/*\n\t\t * Casey says that it's a little embarrassing\n\t\t * that the smack file system doesn't do\n\t\t * extended attributes.\n\t\t *\n\t\t * Cgroupfs is special\n\t\t */\n\t\tfinal = &smack_known_star;\n\t\tbreak;\n\tcase DEVPTS_SUPER_MAGIC:\n\t\t/*\n\t\t * devpts seems content with the label of the task.\n\t\t * Programs that change smack have to treat the\n\t\t * pty with respect.\n\t\t */\n\t\tfinal = ckp;\n\t\tbreak;\n\tcase PROC_SUPER_MAGIC:\n\t\t/*\n\t\t * Casey says procfs appears not to care.\n\t\t * The superblock default suffices.\n\t\t */\n\t\tbreak;\n\tcase TMPFS_MAGIC:\n\t\t/*\n\t\t * Device labels should come from the filesystem,\n\t\t * but watch out, because they're volitile,\n\t\t * getting recreated on every reboot.\n\t\t */\n\t\tfinal = &smack_known_star;\n\t\t/*\n\t\t * No break.\n\t\t *\n\t\t * If a smack value has been set we want to use it,\n\t\t * but since tmpfs isn't giving us the opportunity\n\t\t * to set mount options simulate setting the\n\t\t * superblock default.\n\t\t */\n\tdefault:\n\t\t/*\n\t\t * This isn't an understood special case.\n\t\t * Get the value from the xattr.\n\t\t */\n\n\t\t/*\n\t\t * UNIX domain sockets use lower level socket data.\n\t\t */\n\t\tif (S_ISSOCK(inode->i_mode)) {\n\t\t\tfinal = &smack_known_star;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * No xattr support means, alas, no SMACK label.\n\t\t * Use the aforeapplied default.\n\t\t * It would be curious if the label of the task\n\t\t * does not match that assigned.\n\t\t */\n\t\tif (!(inode->i_opflags & IOP_XATTR))\n\t\t        break;\n\t\t/*\n\t\t * Get the dentry for xattr.\n\t\t */\n\t\tdp = dget(opt_dentry);\n\t\tskp = smk_fetch(XATTR_NAME_SMACK, inode, dp);\n\t\tif (!IS_ERR_OR_NULL(skp))\n\t\t\tfinal = skp;\n\n\t\t/*\n\t\t * Transmuting directory\n\t\t */\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\t/*\n\t\t\t * If this is a new directory and the label was\n\t\t\t * transmuted when the inode was initialized\n\t\t\t * set the transmute attribute on the directory\n\t\t\t * and mark the inode.\n\t\t\t *\n\t\t\t * If there is a transmute attribute on the\n\t\t\t * directory mark the inode.\n\t\t\t */\n\t\t\tif (isp->smk_flags & SMK_INODE_CHANGED) {\n\t\t\t\tisp->smk_flags &= ~SMK_INODE_CHANGED;\n\t\t\t\trc = __vfs_setxattr(dp, inode,\n\t\t\t\t\tXATTR_NAME_SMACKTRANSMUTE,\n\t\t\t\t\tTRANS_TRUE, TRANS_TRUE_SIZE,\n\t\t\t\t\t0);\n\t\t\t} else {\n\t\t\t\trc = __vfs_getxattr(dp, inode,\n\t\t\t\t\tXATTR_NAME_SMACKTRANSMUTE, trattr,\n\t\t\t\t\tTRANS_TRUE_SIZE);\n\t\t\t\tif (rc >= 0 && strncmp(trattr, TRANS_TRUE,\n\t\t\t\t\t\t       TRANS_TRUE_SIZE) != 0)\n\t\t\t\t\trc = -EINVAL;\n\t\t\t}\n\t\t\tif (rc >= 0)\n\t\t\t\ttransflag = SMK_INODE_TRANSMUTE;\n\t\t}\n\t\t/*\n\t\t * Don't let the exec or mmap label be \"*\" or \"@\".\n\t\t */\n\t\tskp = smk_fetch(XATTR_NAME_SMACKEXEC, inode, dp);\n\t\tif (IS_ERR(skp) || skp == &smack_known_star ||\n\t\t    skp == &smack_known_web)\n\t\t\tskp = NULL;\n\t\tisp->smk_task = skp;\n\n\t\tskp = smk_fetch(XATTR_NAME_SMACKMMAP, inode, dp);\n\t\tif (IS_ERR(skp) || skp == &smack_known_star ||\n\t\t    skp == &smack_known_web)\n\t\t\tskp = NULL;\n\t\tisp->smk_mmap = skp;\n\n\t\tdput(dp);\n\t\tbreak;\n\t}\n\n\tif (final == NULL)\n\t\tisp->smk_inode = ckp;\n\telse\n\t\tisp->smk_inode = final;\n\n\tisp->smk_flags |= (SMK_INODE_INSTANT | transflag);\n\nunlockandout:\n\tmutex_unlock(&isp->smk_lock);\n\treturn;\n}"
  },
  {
    "function_name": "smack_ipc_getsecid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3373-3378",
    "snippet": "static void smack_ipc_getsecid(struct kern_ipc_perm *ipp, u32 *secid)\n{\n\tstruct smack_known *iskp = ipp->security;\n\n\t*secid = iskp->smk_secid;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_ipc_getsecid(struct kern_ipc_perm *ipp, u32 *secid)\n{\n\tstruct smack_known *iskp = ipp->security;\n\n\t*secid = iskp->smk_secid;\n}"
  },
  {
    "function_name": "smack_ipc_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3352-3366",
    "snippet": "static int smack_ipc_permission(struct kern_ipc_perm *ipp, short flag)\n{\n\tstruct smack_known *iskp = ipp->security;\n\tint may = smack_flags_to_may(flag);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = ipp->id;\n#endif\n\trc = smk_curacc(iskp, may, &ad);\n\trc = smk_bu_current(\"svipc\", iskp, may, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_current",
          "args": [
            "\"svipc\"",
            "iskp",
            "may",
            "rc"
          ],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "121-137",
          "snippet": "static int smk_bu_current(char *note, struct smack_known *oskp,\n\t\t\t  int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, oskp->smk_known,\n\t\tacc, current->comm, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_current(char *note, struct smack_known *oskp,\n\t\t\t  int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, oskp->smk_known,\n\t\tacc, current->comm, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "iskp",
            "may",
            "&ad"
          ],
          "line": 3363
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_IPC"
          ],
          "line": 3360
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_flags_to_may",
          "args": [
            "flag"
          ],
          "line": 3355
        },
        "resolved": true,
        "details": {
          "function_name": "smack_flags_to_may",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2904-2916",
          "snippet": "static int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_ipc_permission(struct kern_ipc_perm *ipp, short flag)\n{\n\tstruct smack_known *iskp = ipp->security;\n\tint may = smack_flags_to_may(flag);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = ipp->id;\n#endif\n\trc = smk_curacc(iskp, may, &ad);\n\trc = smk_bu_current(\"svipc\", iskp, may, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_msg_queue_msgrcv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3339-3343",
    "snippet": "static int smack_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,\n\t\t\tstruct task_struct *target, long type, int mode)\n{\n\treturn smk_curacc_msq(msq, MAY_READWRITE);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_msq",
          "args": [
            "msq",
            "MAY_READWRITE"
          ],
          "line": 3342
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_msq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "3249-3262",
          "snippet": "static int smk_curacc_msq(struct msg_queue *msq, int access)\n{\n\tstruct smack_known *msp = smack_of_msq(msq);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = msq->q_perm.id;\n#endif\n\trc = smk_curacc(msp, access, &ad);\n\trc = smk_bu_current(\"msq\", msp, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_msq(struct msg_queue *msq, int access)\n{\n\tstruct smack_known *msp = smack_of_msq(msq);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = msq->q_perm.id;\n#endif\n\trc = smk_curacc(msp, access, &ad);\n\trc = smk_bu_current(\"msq\", msp, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,\n\t\t\tstruct task_struct *target, long type, int mode)\n{\n\treturn smk_curacc_msq(msq, MAY_READWRITE);\n}"
  },
  {
    "function_name": "smack_msg_queue_msgsnd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3320-3327",
    "snippet": "static int smack_msg_queue_msgsnd(struct msg_queue *msq, struct msg_msg *msg,\n\t\t\t\t  int msqflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(msqflg);\n\treturn smk_curacc_msq(msq, may);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_msq",
          "args": [
            "msq",
            "may"
          ],
          "line": 3326
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_msq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "3249-3262",
          "snippet": "static int smk_curacc_msq(struct msg_queue *msq, int access)\n{\n\tstruct smack_known *msp = smack_of_msq(msq);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = msq->q_perm.id;\n#endif\n\trc = smk_curacc(msp, access, &ad);\n\trc = smk_bu_current(\"msq\", msp, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_msq(struct msg_queue *msq, int access)\n{\n\tstruct smack_known *msp = smack_of_msq(msq);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = msq->q_perm.id;\n#endif\n\trc = smk_curacc(msp, access, &ad);\n\trc = smk_bu_current(\"msq\", msp, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_flags_to_may",
          "args": [
            "msqflg"
          ],
          "line": 3325
        },
        "resolved": true,
        "details": {
          "function_name": "smack_flags_to_may",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2904-2916",
          "snippet": "static int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_msg_queue_msgsnd(struct msg_queue *msq, struct msg_msg *msg,\n\t\t\t\t  int msqflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(msqflg);\n\treturn smk_curacc_msq(msq, may);\n}"
  },
  {
    "function_name": "smack_msg_queue_msgctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3286-3310",
    "snippet": "static int smack_msg_queue_msgctl(struct msg_queue *msq, int cmd)\n{\n\tint may;\n\n\tswitch (cmd) {\n\tcase IPC_STAT:\n\tcase MSG_STAT:\n\t\tmay = MAY_READ;\n\t\tbreak;\n\tcase IPC_SET:\n\tcase IPC_RMID:\n\t\tmay = MAY_READWRITE;\n\t\tbreak;\n\tcase IPC_INFO:\n\tcase MSG_INFO:\n\t\t/*\n\t\t * System level information\n\t\t */\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn smk_curacc_msq(msq, may);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_msq",
          "args": [
            "msq",
            "may"
          ],
          "line": 3309
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_msq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "3249-3262",
          "snippet": "static int smk_curacc_msq(struct msg_queue *msq, int access)\n{\n\tstruct smack_known *msp = smack_of_msq(msq);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = msq->q_perm.id;\n#endif\n\trc = smk_curacc(msp, access, &ad);\n\trc = smk_bu_current(\"msq\", msp, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_msq(struct msg_queue *msq, int access)\n{\n\tstruct smack_known *msp = smack_of_msq(msq);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = msq->q_perm.id;\n#endif\n\trc = smk_curacc(msp, access, &ad);\n\trc = smk_bu_current(\"msq\", msp, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_msg_queue_msgctl(struct msg_queue *msq, int cmd)\n{\n\tint may;\n\n\tswitch (cmd) {\n\tcase IPC_STAT:\n\tcase MSG_STAT:\n\t\tmay = MAY_READ;\n\t\tbreak;\n\tcase IPC_SET:\n\tcase IPC_RMID:\n\t\tmay = MAY_READWRITE;\n\t\tbreak;\n\tcase IPC_INFO:\n\tcase MSG_INFO:\n\t\t/*\n\t\t * System level information\n\t\t */\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn smk_curacc_msq(msq, may);\n}"
  },
  {
    "function_name": "smack_msg_queue_associate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3271-3277",
    "snippet": "static int smack_msg_queue_associate(struct msg_queue *msq, int msqflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(msqflg);\n\treturn smk_curacc_msq(msq, may);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_msq",
          "args": [
            "msq",
            "may"
          ],
          "line": 3276
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_msq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "3249-3262",
          "snippet": "static int smk_curacc_msq(struct msg_queue *msq, int access)\n{\n\tstruct smack_known *msp = smack_of_msq(msq);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = msq->q_perm.id;\n#endif\n\trc = smk_curacc(msp, access, &ad);\n\trc = smk_bu_current(\"msq\", msp, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_msq(struct msg_queue *msq, int access)\n{\n\tstruct smack_known *msp = smack_of_msq(msq);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = msq->q_perm.id;\n#endif\n\trc = smk_curacc(msp, access, &ad);\n\trc = smk_bu_current(\"msq\", msp, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_flags_to_may",
          "args": [
            "msqflg"
          ],
          "line": 3275
        },
        "resolved": true,
        "details": {
          "function_name": "smack_flags_to_may",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2904-2916",
          "snippet": "static int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_msg_queue_associate(struct msg_queue *msq, int msqflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(msqflg);\n\treturn smk_curacc_msq(msq, may);\n}"
  },
  {
    "function_name": "smk_curacc_msq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3249-3262",
    "snippet": "static int smk_curacc_msq(struct msg_queue *msq, int access)\n{\n\tstruct smack_known *msp = smack_of_msq(msq);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = msq->q_perm.id;\n#endif\n\trc = smk_curacc(msp, access, &ad);\n\trc = smk_bu_current(\"msq\", msp, access, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_current",
          "args": [
            "\"msq\"",
            "msp",
            "access",
            "rc"
          ],
          "line": 3260
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "121-137",
          "snippet": "static int smk_bu_current(char *note, struct smack_known *oskp,\n\t\t\t  int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, oskp->smk_known,\n\t\tacc, current->comm, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_current(char *note, struct smack_known *oskp,\n\t\t\t  int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, oskp->smk_known,\n\t\tacc, current->comm, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "msp",
            "access",
            "&ad"
          ],
          "line": 3259
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_IPC"
          ],
          "line": 3256
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_of_msq",
          "args": [
            "msq"
          ],
          "line": 3251
        },
        "resolved": true,
        "details": {
          "function_name": "smack_of_msq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "3237-3240",
          "snippet": "static struct smack_known *smack_of_msq(struct msg_queue *msq)\n{\n\treturn (struct smack_known *)msq->q_perm.security;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_of_msq(struct msg_queue *msq)\n{\n\treturn (struct smack_known *)msq->q_perm.security;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_msq(struct msg_queue *msq, int access)\n{\n\tstruct smack_known *msp = smack_of_msq(msq);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = msq->q_perm.id;\n#endif\n\trc = smk_curacc(msp, access, &ad);\n\trc = smk_bu_current(\"msq\", msp, access, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_of_msq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3237-3240",
    "snippet": "static struct smack_known *smack_of_msq(struct msg_queue *msq)\n{\n\treturn (struct smack_known *)msq->q_perm.security;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_of_msq(struct msg_queue *msq)\n{\n\treturn (struct smack_known *)msq->q_perm.security;\n}"
  },
  {
    "function_name": "smack_msg_queue_free_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3224-3229",
    "snippet": "static void smack_msg_queue_free_security(struct msg_queue *msq)\n{\n\tstruct kern_ipc_perm *kisp = &msq->q_perm;\n\n\tkisp->security = NULL;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_msg_queue_free_security(struct msg_queue *msq)\n{\n\tstruct kern_ipc_perm *kisp = &msq->q_perm;\n\n\tkisp->security = NULL;\n}"
  },
  {
    "function_name": "smack_msg_queue_alloc_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3209-3216",
    "snippet": "static int smack_msg_queue_alloc_security(struct msg_queue *msq)\n{\n\tstruct kern_ipc_perm *kisp = &msq->q_perm;\n\tstruct smack_known *skp = smk_of_current();\n\n\tkisp->security = skp;\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 3212
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_msg_queue_alloc_security(struct msg_queue *msq)\n{\n\tstruct kern_ipc_perm *kisp = &msq->q_perm;\n\tstruct smack_known *skp = smk_of_current();\n\n\tkisp->security = skp;\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_sem_semop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3197-3201",
    "snippet": "static int smack_sem_semop(struct sem_array *sma, struct sembuf *sops,\n\t\t\t   unsigned nsops, int alter)\n{\n\treturn smk_curacc_sem(sma, MAY_READWRITE);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_sem",
          "args": [
            "sma",
            "MAY_READWRITE"
          ],
          "line": 3200
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_sem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "3116-3129",
          "snippet": "static int smk_curacc_sem(struct sem_array *sma, int access)\n{\n\tstruct smack_known *ssp = smack_of_sem(sma);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = sma->sem_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"sem\", ssp, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_sem(struct sem_array *sma, int access)\n{\n\tstruct smack_known *ssp = smack_of_sem(sma);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = sma->sem_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"sem\", ssp, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_sem_semop(struct sem_array *sma, struct sembuf *sops,\n\t\t\t   unsigned nsops, int alter)\n{\n\treturn smk_curacc_sem(sma, MAY_READWRITE);\n}"
  },
  {
    "function_name": "smack_sem_semctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3153-3184",
    "snippet": "static int smack_sem_semctl(struct sem_array *sma, int cmd)\n{\n\tint may;\n\n\tswitch (cmd) {\n\tcase GETPID:\n\tcase GETNCNT:\n\tcase GETZCNT:\n\tcase GETVAL:\n\tcase GETALL:\n\tcase IPC_STAT:\n\tcase SEM_STAT:\n\t\tmay = MAY_READ;\n\t\tbreak;\n\tcase SETVAL:\n\tcase SETALL:\n\tcase IPC_RMID:\n\tcase IPC_SET:\n\t\tmay = MAY_READWRITE;\n\t\tbreak;\n\tcase IPC_INFO:\n\tcase SEM_INFO:\n\t\t/*\n\t\t * System level information\n\t\t */\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn smk_curacc_sem(sma, may);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_sem",
          "args": [
            "sma",
            "may"
          ],
          "line": 3183
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_sem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "3116-3129",
          "snippet": "static int smk_curacc_sem(struct sem_array *sma, int access)\n{\n\tstruct smack_known *ssp = smack_of_sem(sma);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = sma->sem_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"sem\", ssp, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_sem(struct sem_array *sma, int access)\n{\n\tstruct smack_known *ssp = smack_of_sem(sma);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = sma->sem_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"sem\", ssp, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_sem_semctl(struct sem_array *sma, int cmd)\n{\n\tint may;\n\n\tswitch (cmd) {\n\tcase GETPID:\n\tcase GETNCNT:\n\tcase GETZCNT:\n\tcase GETVAL:\n\tcase GETALL:\n\tcase IPC_STAT:\n\tcase SEM_STAT:\n\t\tmay = MAY_READ;\n\t\tbreak;\n\tcase SETVAL:\n\tcase SETALL:\n\tcase IPC_RMID:\n\tcase IPC_SET:\n\t\tmay = MAY_READWRITE;\n\t\tbreak;\n\tcase IPC_INFO:\n\tcase SEM_INFO:\n\t\t/*\n\t\t * System level information\n\t\t */\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn smk_curacc_sem(sma, may);\n}"
  },
  {
    "function_name": "smack_sem_associate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3138-3144",
    "snippet": "static int smack_sem_associate(struct sem_array *sma, int semflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(semflg);\n\treturn smk_curacc_sem(sma, may);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_sem",
          "args": [
            "sma",
            "may"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_sem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "3116-3129",
          "snippet": "static int smk_curacc_sem(struct sem_array *sma, int access)\n{\n\tstruct smack_known *ssp = smack_of_sem(sma);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = sma->sem_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"sem\", ssp, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_sem(struct sem_array *sma, int access)\n{\n\tstruct smack_known *ssp = smack_of_sem(sma);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = sma->sem_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"sem\", ssp, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_flags_to_may",
          "args": [
            "semflg"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "smack_flags_to_may",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2904-2916",
          "snippet": "static int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_sem_associate(struct sem_array *sma, int semflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(semflg);\n\treturn smk_curacc_sem(sma, may);\n}"
  },
  {
    "function_name": "smk_curacc_sem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3116-3129",
    "snippet": "static int smk_curacc_sem(struct sem_array *sma, int access)\n{\n\tstruct smack_known *ssp = smack_of_sem(sma);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = sma->sem_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"sem\", ssp, access, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_current",
          "args": [
            "\"sem\"",
            "ssp",
            "access",
            "rc"
          ],
          "line": 3127
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "121-137",
          "snippet": "static int smk_bu_current(char *note, struct smack_known *oskp,\n\t\t\t  int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, oskp->smk_known,\n\t\tacc, current->comm, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_current(char *note, struct smack_known *oskp,\n\t\t\t  int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, oskp->smk_known,\n\t\tacc, current->comm, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "ssp",
            "access",
            "&ad"
          ],
          "line": 3126
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_IPC"
          ],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_of_sem",
          "args": [
            "sma"
          ],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "smack_of_sem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "3076-3079",
          "snippet": "static struct smack_known *smack_of_sem(struct sem_array *sma)\n{\n\treturn (struct smack_known *)sma->sem_perm.security;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_of_sem(struct sem_array *sma)\n{\n\treturn (struct smack_known *)sma->sem_perm.security;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_sem(struct sem_array *sma, int access)\n{\n\tstruct smack_known *ssp = smack_of_sem(sma);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = sma->sem_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"sem\", ssp, access, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_sem_free_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3102-3107",
    "snippet": "static void smack_sem_free_security(struct sem_array *sma)\n{\n\tstruct kern_ipc_perm *isp = &sma->sem_perm;\n\n\tisp->security = NULL;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_sem_free_security(struct sem_array *sma)\n{\n\tstruct kern_ipc_perm *isp = &sma->sem_perm;\n\n\tisp->security = NULL;\n}"
  },
  {
    "function_name": "smack_sem_alloc_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3087-3094",
    "snippet": "static int smack_sem_alloc_security(struct sem_array *sma)\n{\n\tstruct kern_ipc_perm *isp = &sma->sem_perm;\n\tstruct smack_known *skp = smk_of_current();\n\n\tisp->security = skp;\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 3090
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_sem_alloc_security(struct sem_array *sma)\n{\n\tstruct kern_ipc_perm *isp = &sma->sem_perm;\n\tstruct smack_known *skp = smk_of_current();\n\n\tisp->security = skp;\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_of_sem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3076-3079",
    "snippet": "static struct smack_known *smack_of_sem(struct sem_array *sma)\n{\n\treturn (struct smack_known *)sma->sem_perm.security;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_of_sem(struct sem_array *sma)\n{\n\treturn (struct smack_known *)sma->sem_perm.security;\n}"
  },
  {
    "function_name": "smack_shm_shmat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3061-3068",
    "snippet": "static int smack_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr,\n\t\t\t   int shmflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(shmflg);\n\treturn smk_curacc_shm(shp, may);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_shm",
          "args": [
            "shp",
            "may"
          ],
          "line": 3067
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_shm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2989-3002",
          "snippet": "static int smk_curacc_shm(struct shmid_kernel *shp, int access)\n{\n\tstruct smack_known *ssp = smack_of_shm(shp);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = shp->shm_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"shm\", ssp, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_shm(struct shmid_kernel *shp, int access)\n{\n\tstruct smack_known *ssp = smack_of_shm(shp);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = shp->shm_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"shm\", ssp, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_flags_to_may",
          "args": [
            "shmflg"
          ],
          "line": 3066
        },
        "resolved": true,
        "details": {
          "function_name": "smack_flags_to_may",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2904-2916",
          "snippet": "static int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr,\n\t\t\t   int shmflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(shmflg);\n\treturn smk_curacc_shm(shp, may);\n}"
  },
  {
    "function_name": "smack_shm_shmctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3026-3051",
    "snippet": "static int smack_shm_shmctl(struct shmid_kernel *shp, int cmd)\n{\n\tint may;\n\n\tswitch (cmd) {\n\tcase IPC_STAT:\n\tcase SHM_STAT:\n\t\tmay = MAY_READ;\n\t\tbreak;\n\tcase IPC_SET:\n\tcase SHM_LOCK:\n\tcase SHM_UNLOCK:\n\tcase IPC_RMID:\n\t\tmay = MAY_READWRITE;\n\t\tbreak;\n\tcase IPC_INFO:\n\tcase SHM_INFO:\n\t\t/*\n\t\t * System level information.\n\t\t */\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn smk_curacc_shm(shp, may);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_shm",
          "args": [
            "shp",
            "may"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_shm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2989-3002",
          "snippet": "static int smk_curacc_shm(struct shmid_kernel *shp, int access)\n{\n\tstruct smack_known *ssp = smack_of_shm(shp);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = shp->shm_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"shm\", ssp, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_shm(struct shmid_kernel *shp, int access)\n{\n\tstruct smack_known *ssp = smack_of_shm(shp);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = shp->shm_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"shm\", ssp, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_shm_shmctl(struct shmid_kernel *shp, int cmd)\n{\n\tint may;\n\n\tswitch (cmd) {\n\tcase IPC_STAT:\n\tcase SHM_STAT:\n\t\tmay = MAY_READ;\n\t\tbreak;\n\tcase IPC_SET:\n\tcase SHM_LOCK:\n\tcase SHM_UNLOCK:\n\tcase IPC_RMID:\n\t\tmay = MAY_READWRITE;\n\t\tbreak;\n\tcase IPC_INFO:\n\tcase SHM_INFO:\n\t\t/*\n\t\t * System level information.\n\t\t */\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn smk_curacc_shm(shp, may);\n}"
  },
  {
    "function_name": "smack_shm_associate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "3011-3017",
    "snippet": "static int smack_shm_associate(struct shmid_kernel *shp, int shmflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(shmflg);\n\treturn smk_curacc_shm(shp, may);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_shm",
          "args": [
            "shp",
            "may"
          ],
          "line": 3016
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_shm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2989-3002",
          "snippet": "static int smk_curacc_shm(struct shmid_kernel *shp, int access)\n{\n\tstruct smack_known *ssp = smack_of_shm(shp);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = shp->shm_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"shm\", ssp, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_shm(struct shmid_kernel *shp, int access)\n{\n\tstruct smack_known *ssp = smack_of_shm(shp);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = shp->shm_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"shm\", ssp, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_flags_to_may",
          "args": [
            "shmflg"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "smack_flags_to_may",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2904-2916",
          "snippet": "static int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_shm_associate(struct shmid_kernel *shp, int shmflg)\n{\n\tint may;\n\n\tmay = smack_flags_to_may(shmflg);\n\treturn smk_curacc_shm(shp, may);\n}"
  },
  {
    "function_name": "smk_curacc_shm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2989-3002",
    "snippet": "static int smk_curacc_shm(struct shmid_kernel *shp, int access)\n{\n\tstruct smack_known *ssp = smack_of_shm(shp);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = shp->shm_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"shm\", ssp, access, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_current",
          "args": [
            "\"shm\"",
            "ssp",
            "access",
            "rc"
          ],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "121-137",
          "snippet": "static int smk_bu_current(char *note, struct smack_known *oskp,\n\t\t\t  int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, oskp->smk_known,\n\t\tacc, current->comm, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_current(char *note, struct smack_known *oskp,\n\t\t\t  int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, oskp->smk_known,\n\t\tacc, current->comm, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "ssp",
            "access",
            "&ad"
          ],
          "line": 2999
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_IPC"
          ],
          "line": 2996
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_of_shm",
          "args": [
            "shp"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "smack_of_shm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2949-2952",
          "snippet": "static struct smack_known *smack_of_shm(struct shmid_kernel *shp)\n{\n\treturn (struct smack_known *)shp->shm_perm.security;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_of_shm(struct shmid_kernel *shp)\n{\n\treturn (struct smack_known *)shp->shm_perm.security;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_shm(struct shmid_kernel *shp, int access)\n{\n\tstruct smack_known *ssp = smack_of_shm(shp);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_IPC);\n\tad.a.u.ipc_id = shp->shm_perm.id;\n#endif\n\trc = smk_curacc(ssp, access, &ad);\n\trc = smk_bu_current(\"shm\", ssp, access, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_shm_free_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2975-2980",
    "snippet": "static void smack_shm_free_security(struct shmid_kernel *shp)\n{\n\tstruct kern_ipc_perm *isp = &shp->shm_perm;\n\n\tisp->security = NULL;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_shm_free_security(struct shmid_kernel *shp)\n{\n\tstruct kern_ipc_perm *isp = &shp->shm_perm;\n\n\tisp->security = NULL;\n}"
  },
  {
    "function_name": "smack_shm_alloc_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2960-2967",
    "snippet": "static int smack_shm_alloc_security(struct shmid_kernel *shp)\n{\n\tstruct kern_ipc_perm *isp = &shp->shm_perm;\n\tstruct smack_known *skp = smk_of_current();\n\n\tisp->security = skp;\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 2963
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_shm_alloc_security(struct shmid_kernel *shp)\n{\n\tstruct kern_ipc_perm *isp = &shp->shm_perm;\n\tstruct smack_known *skp = smk_of_current();\n\n\tisp->security = skp;\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_of_shm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2949-2952",
    "snippet": "static struct smack_known *smack_of_shm(struct shmid_kernel *shp)\n{\n\treturn (struct smack_known *)shp->shm_perm.security;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_of_shm(struct shmid_kernel *shp)\n{\n\treturn (struct smack_known *)shp->shm_perm.security;\n}"
  },
  {
    "function_name": "smack_msg_msg_free_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2938-2941",
    "snippet": "static void smack_msg_msg_free_security(struct msg_msg *msg)\n{\n\tmsg->security = NULL;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_msg_msg_free_security(struct msg_msg *msg)\n{\n\tmsg->security = NULL;\n}"
  },
  {
    "function_name": "smack_msg_msg_alloc_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2924-2930",
    "snippet": "static int smack_msg_msg_alloc_security(struct msg_msg *msg)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tmsg->security = skp;\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_msg_msg_alloc_security(struct msg_msg *msg)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tmsg->security = skp;\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_flags_to_may",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2904-2916",
    "snippet": "static int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_flags_to_may(int flags)\n{\n\tint may = 0;\n\n\tif (flags & S_IRUGO)\n\t\tmay |= MAY_READ;\n\tif (flags & S_IWUGO)\n\t\tmay |= MAY_WRITE;\n\tif (flags & S_IXUGO)\n\t\tmay |= MAY_EXEC;\n\n\treturn may;\n}"
  },
  {
    "function_name": "smack_socket_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2860-2896",
    "snippet": "static int smack_socket_connect(struct socket *sock, struct sockaddr *sap,\n\t\t\t\tint addrlen)\n{\n\tint rc = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct sockaddr_in6 *sip = (struct sockaddr_in6 *)sap;\n#endif\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\tstruct smack_known *rsp;\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n#endif\n\n\tif (sock->sk == NULL)\n\t\treturn 0;\n\n\tswitch (sock->sk->sk_family) {\n\tcase PF_INET:\n\t\tif (addrlen < sizeof(struct sockaddr_in))\n\t\t\treturn -EINVAL;\n\t\trc = smack_netlabel_send(sock->sk, (struct sockaddr_in *)sap);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tif (addrlen < sizeof(struct sockaddr_in6))\n\t\t\treturn -EINVAL;\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\t\trsp = smack_ipv6host_label(sip);\n\t\tif (rsp != NULL)\n\t\t\trc = smk_ipv6_check(ssp->smk_out, rsp, sip,\n\t\t\t\t\t\tSMK_CONNECTING);\n#endif\n#ifdef SMACK_IPV6_PORT_LABELING\n\t\trc = smk_ipv6_port_check(sock->sk, sip, SMK_CONNECTING);\n#endif\n\t\tbreak;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [
      "#define SMK_CONNECTING\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_ipv6_port_check",
          "args": [
            "sock->sk",
            "sip",
            "SMK_CONNECTING"
          ],
          "line": 2891
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ipv6_port_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2671-2723",
          "snippet": "static int smk_ipv6_port_check(struct sock *sk, struct sockaddr_in6 *address,\n\t\t\t\tint act)\n{\n\tstruct smk_port_label *spp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp = NULL;\n\tunsigned short port;\n\tstruct smack_known *object;\n\n\tif (act == SMK_RECEIVING) {\n\t\tskp = smack_ipv6host_label(address);\n\t\tobject = ssp->smk_in;\n\t} else {\n\t\tskp = ssp->smk_out;\n\t\tobject = smack_ipv6host_label(address);\n\t}\n\n\t/*\n\t * The other end is a single label host.\n\t */\n\tif (skp != NULL && object != NULL)\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\tif (skp == NULL)\n\t\tskp = smack_net_ambient;\n\tif (object == NULL)\n\t\tobject = smack_net_ambient;\n\n\t/*\n\t * It's remote, so port lookup does no good.\n\t */\n\tif (!smk_ipv6_localhost(address))\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\n\t/*\n\t * It's local so the send check has to have passed.\n\t */\n\tif (act == SMK_RECEIVING)\n\t\treturn 0;\n\n\tport = ntohs(address->sin6_port);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sk->sk_type)\n\t\t\tcontinue;\n\t\tobject = spp->smk_in;\n\t\tif (act == SMK_CONNECTING)\n\t\t\tssp->smk_packet = spp->smk_out;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn smk_ipv6_check(skp, object, address, act);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [
            "#define SMK_RECEIVING\t1",
            "#define SMK_CONNECTING\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\n#define SMK_RECEIVING\t1\n#define SMK_CONNECTING\t0\n\nstatic int smk_ipv6_port_check(struct sock *sk, struct sockaddr_in6 *address,\n\t\t\t\tint act)\n{\n\tstruct smk_port_label *spp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp = NULL;\n\tunsigned short port;\n\tstruct smack_known *object;\n\n\tif (act == SMK_RECEIVING) {\n\t\tskp = smack_ipv6host_label(address);\n\t\tobject = ssp->smk_in;\n\t} else {\n\t\tskp = ssp->smk_out;\n\t\tobject = smack_ipv6host_label(address);\n\t}\n\n\t/*\n\t * The other end is a single label host.\n\t */\n\tif (skp != NULL && object != NULL)\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\tif (skp == NULL)\n\t\tskp = smack_net_ambient;\n\tif (object == NULL)\n\t\tobject = smack_net_ambient;\n\n\t/*\n\t * It's remote, so port lookup does no good.\n\t */\n\tif (!smk_ipv6_localhost(address))\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\n\t/*\n\t * It's local so the send check has to have passed.\n\t */\n\tif (act == SMK_RECEIVING)\n\t\treturn 0;\n\n\tport = ntohs(address->sin6_port);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sk->sk_type)\n\t\t\tcontinue;\n\t\tobject = spp->smk_in;\n\t\tif (act == SMK_CONNECTING)\n\t\t\tssp->smk_packet = spp->smk_out;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn smk_ipv6_check(skp, object, address, act);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ipv6_check",
          "args": [
            "ssp->smk_out",
            "rsp",
            "sip",
            "SMK_CONNECTING"
          ],
          "line": 2887
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ipv6_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2551-2573",
          "snippet": "static int smk_ipv6_check(struct smack_known *subject,\n\t\t\t\tstruct smack_known *object,\n\t\t\t\tstruct sockaddr_in6 *address, int act)\n{\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tad.a.u.net->family = PF_INET6;\n\tad.a.u.net->dport = ntohs(address->sin6_port);\n\tif (act == SMK_RECEIVING)\n\t\tad.a.u.net->v6info.saddr = address->sin6_addr;\n\telse\n\t\tad.a.u.net->v6info.daddr = address->sin6_addr;\n#endif\n\trc = smk_access(subject, object, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"IPv6 check\", subject, object, MAY_WRITE, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [
            "#define SMK_RECEIVING\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\n#define SMK_RECEIVING\t1\n\nstatic int smk_ipv6_check(struct smack_known *subject,\n\t\t\t\tstruct smack_known *object,\n\t\t\t\tstruct sockaddr_in6 *address, int act)\n{\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tad.a.u.net->family = PF_INET6;\n\tad.a.u.net->dport = ntohs(address->sin6_port);\n\tif (act == SMK_RECEIVING)\n\t\tad.a.u.net->v6info.saddr = address->sin6_addr;\n\telse\n\t\tad.a.u.net->v6info.daddr = address->sin6_addr;\n#endif\n\trc = smk_access(subject, object, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"IPv6 check\", subject, object, MAY_WRITE, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_ipv6host_label",
          "args": [
            "sip"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "smack_ipv6host_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2414-2451",
          "snippet": "static struct smack_known *smack_ipv6host_label(struct sockaddr_in6 *sip)\n{\n\tstruct smk_net6addr *snp;\n\tstruct in6_addr *sap = &sip->sin6_addr;\n\tint i;\n\tint found = 0;\n\n\t/*\n\t * It's local. Don't look for a host label.\n\t */\n\tif (smk_ipv6_localhost(sip))\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\n\t\t/*\n\t\t * If the label is NULL the entry has\n\t\t * been renounced. Ignore it.\n\t\t */\n\t\tif (snp->smk_label == NULL)\n\t\t\tcontinue;\n\t\t/*\n\t\t* we break after finding the first match because\n\t\t* the list is sorted from longest to shortest mask\n\t\t* so we have found the most specific match\n\t\t*/\n\t\tfor (found = 1, i = 0; i < 8; i++) {\n\t\t\tif ((sap->s6_addr16[i] & snp->smk_mask.s6_addr16[i]) !=\n\t\t\t    snp->smk_host.s6_addr16[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\treturn snp->smk_label;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_ipv6host_label(struct sockaddr_in6 *sip)\n{\n\tstruct smk_net6addr *snp;\n\tstruct in6_addr *sap = &sip->sin6_addr;\n\tint i;\n\tint found = 0;\n\n\t/*\n\t * It's local. Don't look for a host label.\n\t */\n\tif (smk_ipv6_localhost(sip))\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\n\t\t/*\n\t\t * If the label is NULL the entry has\n\t\t * been renounced. Ignore it.\n\t\t */\n\t\tif (snp->smk_label == NULL)\n\t\t\tcontinue;\n\t\t/*\n\t\t* we break after finding the first match because\n\t\t* the list is sorted from longest to shortest mask\n\t\t* so we have found the most specific match\n\t\t*/\n\t\tfor (found = 1, i = 0; i < 8; i++) {\n\t\t\tif ((sap->s6_addr16[i] & snp->smk_mask.s6_addr16[i]) !=\n\t\t\t    snp->smk_host.s6_addr16[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\treturn snp->smk_label;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_netlabel_send",
          "args": [
            "sock->sk",
            "(struct sockaddr_in *)sap"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "smack_netlabel_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2506-2539",
          "snippet": "static int smack_netlabel_send(struct sock *sk, struct sockaddr_in *sap)\n{\n\tstruct smack_known *skp;\n\tint rc;\n\tint sk_lbl;\n\tstruct smack_known *hkp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smk_audit_info ad;\n\n\trcu_read_lock();\n\thkp = smack_ipv4host_label(sap);\n\tif (hkp != NULL) {\n#ifdef CONFIG_AUDIT\n\t\tstruct lsm_network_audit net;\n\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sap->sin_family;\n\t\tad.a.u.net->dport = sap->sin_port;\n\t\tad.a.u.net->v4info.daddr = sap->sin_addr.s_addr;\n#endif\n\t\tsk_lbl = SMACK_UNLABELED_SOCKET;\n\t\tskp = ssp->smk_out;\n\t\trc = smk_access(skp, hkp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 host check\", skp, hkp, MAY_WRITE, rc);\n\t} else {\n\t\tsk_lbl = SMACK_CIPSO_SOCKET;\n\t\trc = 0;\n\t}\n\trcu_read_unlock();\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn smack_netlabel(sk, sk_lbl);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_netlabel_send(struct sock *sk, struct sockaddr_in *sap)\n{\n\tstruct smack_known *skp;\n\tint rc;\n\tint sk_lbl;\n\tstruct smack_known *hkp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smk_audit_info ad;\n\n\trcu_read_lock();\n\thkp = smack_ipv4host_label(sap);\n\tif (hkp != NULL) {\n#ifdef CONFIG_AUDIT\n\t\tstruct lsm_network_audit net;\n\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sap->sin_family;\n\t\tad.a.u.net->dport = sap->sin_port;\n\t\tad.a.u.net->v4info.daddr = sap->sin_addr.s_addr;\n#endif\n\t\tsk_lbl = SMACK_UNLABELED_SOCKET;\n\t\tskp = ssp->smk_out;\n\t\trc = smk_access(skp, hkp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 host check\", skp, hkp, MAY_WRITE, rc);\n\t} else {\n\t\tsk_lbl = SMACK_CIPSO_SOCKET;\n\t\trc = 0;\n\t}\n\trcu_read_unlock();\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn smack_netlabel(sk, sk_lbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IPV6"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\n#define SMK_CONNECTING\t0\n\nstatic int smack_socket_connect(struct socket *sock, struct sockaddr *sap,\n\t\t\t\tint addrlen)\n{\n\tint rc = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct sockaddr_in6 *sip = (struct sockaddr_in6 *)sap;\n#endif\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\tstruct smack_known *rsp;\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n#endif\n\n\tif (sock->sk == NULL)\n\t\treturn 0;\n\n\tswitch (sock->sk->sk_family) {\n\tcase PF_INET:\n\t\tif (addrlen < sizeof(struct sockaddr_in))\n\t\t\treturn -EINVAL;\n\t\trc = smack_netlabel_send(sock->sk, (struct sockaddr_in *)sap);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tif (addrlen < sizeof(struct sockaddr_in6))\n\t\t\treturn -EINVAL;\n#ifdef SMACK_IPV6_SECMARK_LABELING\n\t\trsp = smack_ipv6host_label(sip);\n\t\tif (rsp != NULL)\n\t\t\trc = smk_ipv6_check(ssp->smk_out, rsp, sip,\n\t\t\t\t\t\tSMK_CONNECTING);\n#endif\n#ifdef SMACK_IPV6_PORT_LABELING\n\t\trc = smk_ipv6_port_check(sock->sk, sip, SMK_CONNECTING);\n#endif\n\t\tbreak;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_socket_bind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2841-2847",
    "snippet": "static int smack_socket_bind(struct socket *sock, struct sockaddr *address,\n\t\t\t\tint addrlen)\n{\n\tif (sock->sk != NULL && sock->sk->sk_family == PF_INET6)\n\t\tsmk_ipv6_port_label(sock, address);\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_ipv6_port_label",
          "args": [
            "sock",
            "address"
          ],
          "line": 2845
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ipv6_port_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2584-2662",
          "snippet": "static void smk_ipv6_port_label(struct socket *sock, struct sockaddr *address)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_in6 *addr6;\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n\tstruct smk_port_label *spp;\n\tunsigned short port = 0;\n\n\tif (address == NULL) {\n\t\t/*\n\t\t * This operation is changing the Smack information\n\t\t * on the bound socket. Take the changes to the port\n\t\t * as well.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\t\tif (sk != spp->smk_sock)\n\t\t\t\tcontinue;\n\t\t\tspp->smk_in = ssp->smk_in;\n\t\t\tspp->smk_out = ssp->smk_out;\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * A NULL address is only used for updating existing\n\t\t * bound entries. If there isn't one, it's OK.\n\t\t */\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\taddr6 = (struct sockaddr_in6 *)address;\n\tport = ntohs(addr6->sin6_port);\n\t/*\n\t * This is a special case that is safely ignored.\n\t */\n\tif (port == 0)\n\t\treturn;\n\n\t/*\n\t * Look for an existing port list entry.\n\t * This is an indication that a port is getting reused.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sock->type)\n\t\t\tcontinue;\n\t\tif (spp->smk_can_reuse != 1) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\tspp->smk_port = port;\n\t\tspp->smk_sock = sk;\n\t\tspp->smk_in = ssp->smk_in;\n\t\tspp->smk_out = ssp->smk_out;\n\t\tspp->smk_can_reuse = 0;\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\t/*\n\t * A new port entry is required.\n\t */\n\tspp = kzalloc(sizeof(*spp), GFP_KERNEL);\n\tif (spp == NULL)\n\t\treturn;\n\n\tspp->smk_port = port;\n\tspp->smk_sock = sk;\n\tspp->smk_in = ssp->smk_in;\n\tspp->smk_out = ssp->smk_out;\n\tspp->smk_sock_type = sock->type;\n\tspp->smk_can_reuse = 0;\n\n\tmutex_lock(&smack_ipv6_lock);\n\tlist_add_rcu(&spp->list, &smk_ipv6_port_list);\n\tmutex_unlock(&smack_ipv6_lock);\n\treturn;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smk_ipv6_port_label(struct socket *sock, struct sockaddr *address)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_in6 *addr6;\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n\tstruct smk_port_label *spp;\n\tunsigned short port = 0;\n\n\tif (address == NULL) {\n\t\t/*\n\t\t * This operation is changing the Smack information\n\t\t * on the bound socket. Take the changes to the port\n\t\t * as well.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\t\tif (sk != spp->smk_sock)\n\t\t\t\tcontinue;\n\t\t\tspp->smk_in = ssp->smk_in;\n\t\t\tspp->smk_out = ssp->smk_out;\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * A NULL address is only used for updating existing\n\t\t * bound entries. If there isn't one, it's OK.\n\t\t */\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\taddr6 = (struct sockaddr_in6 *)address;\n\tport = ntohs(addr6->sin6_port);\n\t/*\n\t * This is a special case that is safely ignored.\n\t */\n\tif (port == 0)\n\t\treturn;\n\n\t/*\n\t * Look for an existing port list entry.\n\t * This is an indication that a port is getting reused.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sock->type)\n\t\t\tcontinue;\n\t\tif (spp->smk_can_reuse != 1) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\tspp->smk_port = port;\n\t\tspp->smk_sock = sk;\n\t\tspp->smk_in = ssp->smk_in;\n\t\tspp->smk_out = ssp->smk_out;\n\t\tspp->smk_can_reuse = 0;\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\t/*\n\t * A new port entry is required.\n\t */\n\tspp = kzalloc(sizeof(*spp), GFP_KERNEL);\n\tif (spp == NULL)\n\t\treturn;\n\n\tspp->smk_port = port;\n\tspp->smk_sock = sk;\n\tspp->smk_in = ssp->smk_in;\n\tspp->smk_out = ssp->smk_out;\n\tspp->smk_sock_type = sock->type;\n\tspp->smk_can_reuse = 0;\n\n\tmutex_lock(&smack_ipv6_lock);\n\tlist_add_rcu(&spp->list, &smk_ipv6_port_list);\n\tmutex_unlock(&smack_ipv6_lock);\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_socket_bind(struct socket *sock, struct sockaddr *address,\n\t\t\t\tint addrlen)\n{\n\tif (sock->sk != NULL && sock->sk->sk_family == PF_INET6)\n\t\tsmk_ipv6_port_label(sock, address);\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_socket_post_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2805-2828",
    "snippet": "static int smack_socket_post_create(struct socket *sock, int family,\n\t\t\t\t    int type, int protocol, int kern)\n{\n\tstruct socket_smack *ssp;\n\n\tif (sock->sk == NULL)\n\t\treturn 0;\n\n\t/*\n\t * Sockets created by kernel threads receive web label.\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD)) {\n\t\tssp = sock->sk->sk_security;\n\t\tssp->smk_in = &smack_known_web;\n\t\tssp->smk_out = &smack_known_web;\n\t}\n\n\tif (family != PF_INET)\n\t\treturn 0;\n\t/*\n\t * Set the outbound netlbl.\n\t */\n\treturn smack_netlabel(sock->sk, SMACK_CIPSO_SOCKET);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smack_netlabel",
          "args": [
            "sock->sk",
            "SMACK_CIPSO_SOCKET"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "smack_netlabel_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2506-2539",
          "snippet": "static int smack_netlabel_send(struct sock *sk, struct sockaddr_in *sap)\n{\n\tstruct smack_known *skp;\n\tint rc;\n\tint sk_lbl;\n\tstruct smack_known *hkp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smk_audit_info ad;\n\n\trcu_read_lock();\n\thkp = smack_ipv4host_label(sap);\n\tif (hkp != NULL) {\n#ifdef CONFIG_AUDIT\n\t\tstruct lsm_network_audit net;\n\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sap->sin_family;\n\t\tad.a.u.net->dport = sap->sin_port;\n\t\tad.a.u.net->v4info.daddr = sap->sin_addr.s_addr;\n#endif\n\t\tsk_lbl = SMACK_UNLABELED_SOCKET;\n\t\tskp = ssp->smk_out;\n\t\trc = smk_access(skp, hkp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 host check\", skp, hkp, MAY_WRITE, rc);\n\t} else {\n\t\tsk_lbl = SMACK_CIPSO_SOCKET;\n\t\trc = 0;\n\t}\n\trcu_read_unlock();\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn smack_netlabel(sk, sk_lbl);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_netlabel_send(struct sock *sk, struct sockaddr_in *sap)\n{\n\tstruct smack_known *skp;\n\tint rc;\n\tint sk_lbl;\n\tstruct smack_known *hkp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smk_audit_info ad;\n\n\trcu_read_lock();\n\thkp = smack_ipv4host_label(sap);\n\tif (hkp != NULL) {\n#ifdef CONFIG_AUDIT\n\t\tstruct lsm_network_audit net;\n\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sap->sin_family;\n\t\tad.a.u.net->dport = sap->sin_port;\n\t\tad.a.u.net->v4info.daddr = sap->sin_addr.s_addr;\n#endif\n\t\tsk_lbl = SMACK_UNLABELED_SOCKET;\n\t\tskp = ssp->smk_out;\n\t\trc = smk_access(skp, hkp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 host check\", skp, hkp, MAY_WRITE, rc);\n\t} else {\n\t\tsk_lbl = SMACK_CIPSO_SOCKET;\n\t\trc = 0;\n\t}\n\trcu_read_unlock();\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn smack_netlabel(sk, sk_lbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->flags & PF_KTHREAD"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_socket_post_create(struct socket *sock, int family,\n\t\t\t\t    int type, int protocol, int kern)\n{\n\tstruct socket_smack *ssp;\n\n\tif (sock->sk == NULL)\n\t\treturn 0;\n\n\t/*\n\t * Sockets created by kernel threads receive web label.\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD)) {\n\t\tssp = sock->sk->sk_security;\n\t\tssp->smk_in = &smack_known_web;\n\t\tssp->smk_out = &smack_known_web;\n\t}\n\n\tif (family != PF_INET)\n\t\treturn 0;\n\t/*\n\t * Set the outbound netlbl.\n\t */\n\treturn smack_netlabel(sock->sk, SMACK_CIPSO_SOCKET);\n}"
  },
  {
    "function_name": "smack_inode_setsecurity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2738-2791",
    "snippet": "static int smack_inode_setsecurity(struct inode *inode, const char *name,\n\t\t\t\t   const void *value, size_t size, int flags)\n{\n\tstruct smack_known *skp;\n\tstruct inode_smack *nsp = inode->i_security;\n\tstruct socket_smack *ssp;\n\tstruct socket *sock;\n\tint rc = 0;\n\n\tif (value == NULL || size > SMK_LONGLABEL || size == 0)\n\t\treturn -EINVAL;\n\n\tskp = smk_import_entry(value, size);\n\tif (IS_ERR(skp))\n\t\treturn PTR_ERR(skp);\n\n\tif (strcmp(name, XATTR_SMACK_SUFFIX) == 0) {\n\t\tnsp->smk_inode = skp;\n\t\tnsp->smk_flags |= SMK_INODE_INSTANT;\n\t\treturn 0;\n\t}\n\t/*\n\t * The rest of the Smack xattrs are only on sockets.\n\t */\n\tif (inode->i_sb->s_magic != SOCKFS_MAGIC)\n\t\treturn -EOPNOTSUPP;\n\n\tsock = SOCKET_I(inode);\n\tif (sock == NULL || sock->sk == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tssp = sock->sk->sk_security;\n\n\tif (strcmp(name, XATTR_SMACK_IPIN) == 0)\n\t\tssp->smk_in = skp;\n\telse if (strcmp(name, XATTR_SMACK_IPOUT) == 0) {\n\t\tssp->smk_out = skp;\n\t\tif (sock->sk->sk_family == PF_INET) {\n\t\t\trc = smack_netlabel(sock->sk, SMACK_CIPSO_SOCKET);\n\t\t\tif (rc != 0)\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"Smack: \\\"%s\\\" netlbl error %d.\\n\",\n\t\t\t\t\t__func__, -rc);\n\t\t}\n\t} else\n\t\treturn -EOPNOTSUPP;\n\n#ifdef SMACK_IPV6_PORT_LABELING\n\tif (sock->sk->sk_family == PF_INET6)\n\t\tsmk_ipv6_port_label(sock, NULL);\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_ipv6_port_label",
          "args": [
            "sock",
            "NULL"
          ],
          "line": 2787
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ipv6_port_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2584-2662",
          "snippet": "static void smk_ipv6_port_label(struct socket *sock, struct sockaddr *address)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_in6 *addr6;\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n\tstruct smk_port_label *spp;\n\tunsigned short port = 0;\n\n\tif (address == NULL) {\n\t\t/*\n\t\t * This operation is changing the Smack information\n\t\t * on the bound socket. Take the changes to the port\n\t\t * as well.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\t\tif (sk != spp->smk_sock)\n\t\t\t\tcontinue;\n\t\t\tspp->smk_in = ssp->smk_in;\n\t\t\tspp->smk_out = ssp->smk_out;\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * A NULL address is only used for updating existing\n\t\t * bound entries. If there isn't one, it's OK.\n\t\t */\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\taddr6 = (struct sockaddr_in6 *)address;\n\tport = ntohs(addr6->sin6_port);\n\t/*\n\t * This is a special case that is safely ignored.\n\t */\n\tif (port == 0)\n\t\treturn;\n\n\t/*\n\t * Look for an existing port list entry.\n\t * This is an indication that a port is getting reused.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sock->type)\n\t\t\tcontinue;\n\t\tif (spp->smk_can_reuse != 1) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\tspp->smk_port = port;\n\t\tspp->smk_sock = sk;\n\t\tspp->smk_in = ssp->smk_in;\n\t\tspp->smk_out = ssp->smk_out;\n\t\tspp->smk_can_reuse = 0;\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\t/*\n\t * A new port entry is required.\n\t */\n\tspp = kzalloc(sizeof(*spp), GFP_KERNEL);\n\tif (spp == NULL)\n\t\treturn;\n\n\tspp->smk_port = port;\n\tspp->smk_sock = sk;\n\tspp->smk_in = ssp->smk_in;\n\tspp->smk_out = ssp->smk_out;\n\tspp->smk_sock_type = sock->type;\n\tspp->smk_can_reuse = 0;\n\n\tmutex_lock(&smack_ipv6_lock);\n\tlist_add_rcu(&spp->list, &smk_ipv6_port_list);\n\tmutex_unlock(&smack_ipv6_lock);\n\treturn;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smk_ipv6_port_label(struct socket *sock, struct sockaddr *address)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_in6 *addr6;\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n\tstruct smk_port_label *spp;\n\tunsigned short port = 0;\n\n\tif (address == NULL) {\n\t\t/*\n\t\t * This operation is changing the Smack information\n\t\t * on the bound socket. Take the changes to the port\n\t\t * as well.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\t\tif (sk != spp->smk_sock)\n\t\t\t\tcontinue;\n\t\t\tspp->smk_in = ssp->smk_in;\n\t\t\tspp->smk_out = ssp->smk_out;\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * A NULL address is only used for updating existing\n\t\t * bound entries. If there isn't one, it's OK.\n\t\t */\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\taddr6 = (struct sockaddr_in6 *)address;\n\tport = ntohs(addr6->sin6_port);\n\t/*\n\t * This is a special case that is safely ignored.\n\t */\n\tif (port == 0)\n\t\treturn;\n\n\t/*\n\t * Look for an existing port list entry.\n\t * This is an indication that a port is getting reused.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sock->type)\n\t\t\tcontinue;\n\t\tif (spp->smk_can_reuse != 1) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\tspp->smk_port = port;\n\t\tspp->smk_sock = sk;\n\t\tspp->smk_in = ssp->smk_in;\n\t\tspp->smk_out = ssp->smk_out;\n\t\tspp->smk_can_reuse = 0;\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\t/*\n\t * A new port entry is required.\n\t */\n\tspp = kzalloc(sizeof(*spp), GFP_KERNEL);\n\tif (spp == NULL)\n\t\treturn;\n\n\tspp->smk_port = port;\n\tspp->smk_sock = sk;\n\tspp->smk_in = ssp->smk_in;\n\tspp->smk_out = ssp->smk_out;\n\tspp->smk_sock_type = sock->type;\n\tspp->smk_can_reuse = 0;\n\n\tmutex_lock(&smack_ipv6_lock);\n\tlist_add_rcu(&spp->list, &smk_ipv6_port_list);\n\tmutex_unlock(&smack_ipv6_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\t\t\"Smack: \\\"%s\\\" netlbl error %d.\\n\"",
            "__func__",
            "-rc"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_netlabel",
          "args": [
            "sock->sk",
            "SMACK_CIPSO_SOCKET"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "smack_netlabel_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2506-2539",
          "snippet": "static int smack_netlabel_send(struct sock *sk, struct sockaddr_in *sap)\n{\n\tstruct smack_known *skp;\n\tint rc;\n\tint sk_lbl;\n\tstruct smack_known *hkp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smk_audit_info ad;\n\n\trcu_read_lock();\n\thkp = smack_ipv4host_label(sap);\n\tif (hkp != NULL) {\n#ifdef CONFIG_AUDIT\n\t\tstruct lsm_network_audit net;\n\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sap->sin_family;\n\t\tad.a.u.net->dport = sap->sin_port;\n\t\tad.a.u.net->v4info.daddr = sap->sin_addr.s_addr;\n#endif\n\t\tsk_lbl = SMACK_UNLABELED_SOCKET;\n\t\tskp = ssp->smk_out;\n\t\trc = smk_access(skp, hkp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 host check\", skp, hkp, MAY_WRITE, rc);\n\t} else {\n\t\tsk_lbl = SMACK_CIPSO_SOCKET;\n\t\trc = 0;\n\t}\n\trcu_read_unlock();\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn smack_netlabel(sk, sk_lbl);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_netlabel_send(struct sock *sk, struct sockaddr_in *sap)\n{\n\tstruct smack_known *skp;\n\tint rc;\n\tint sk_lbl;\n\tstruct smack_known *hkp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smk_audit_info ad;\n\n\trcu_read_lock();\n\thkp = smack_ipv4host_label(sap);\n\tif (hkp != NULL) {\n#ifdef CONFIG_AUDIT\n\t\tstruct lsm_network_audit net;\n\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sap->sin_family;\n\t\tad.a.u.net->dport = sap->sin_port;\n\t\tad.a.u.net->v4info.daddr = sap->sin_addr.s_addr;\n#endif\n\t\tsk_lbl = SMACK_UNLABELED_SOCKET;\n\t\tskp = ssp->smk_out;\n\t\trc = smk_access(skp, hkp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 host check\", skp, hkp, MAY_WRITE, rc);\n\t} else {\n\t\tsk_lbl = SMACK_CIPSO_SOCKET;\n\t\trc = 0;\n\t}\n\trcu_read_unlock();\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn smack_netlabel(sk, sk_lbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_SMACK_IPOUT"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_SMACK_IPIN"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOCKET_I",
          "args": [
            "inode"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_SMACK_SUFFIX"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "value",
            "size"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_setsecurity(struct inode *inode, const char *name,\n\t\t\t\t   const void *value, size_t size, int flags)\n{\n\tstruct smack_known *skp;\n\tstruct inode_smack *nsp = inode->i_security;\n\tstruct socket_smack *ssp;\n\tstruct socket *sock;\n\tint rc = 0;\n\n\tif (value == NULL || size > SMK_LONGLABEL || size == 0)\n\t\treturn -EINVAL;\n\n\tskp = smk_import_entry(value, size);\n\tif (IS_ERR(skp))\n\t\treturn PTR_ERR(skp);\n\n\tif (strcmp(name, XATTR_SMACK_SUFFIX) == 0) {\n\t\tnsp->smk_inode = skp;\n\t\tnsp->smk_flags |= SMK_INODE_INSTANT;\n\t\treturn 0;\n\t}\n\t/*\n\t * The rest of the Smack xattrs are only on sockets.\n\t */\n\tif (inode->i_sb->s_magic != SOCKFS_MAGIC)\n\t\treturn -EOPNOTSUPP;\n\n\tsock = SOCKET_I(inode);\n\tif (sock == NULL || sock->sk == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tssp = sock->sk->sk_security;\n\n\tif (strcmp(name, XATTR_SMACK_IPIN) == 0)\n\t\tssp->smk_in = skp;\n\telse if (strcmp(name, XATTR_SMACK_IPOUT) == 0) {\n\t\tssp->smk_out = skp;\n\t\tif (sock->sk->sk_family == PF_INET) {\n\t\t\trc = smack_netlabel(sock->sk, SMACK_CIPSO_SOCKET);\n\t\t\tif (rc != 0)\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"Smack: \\\"%s\\\" netlbl error %d.\\n\",\n\t\t\t\t\t__func__, -rc);\n\t\t}\n\t} else\n\t\treturn -EOPNOTSUPP;\n\n#ifdef SMACK_IPV6_PORT_LABELING\n\tif (sock->sk->sk_family == PF_INET6)\n\t\tsmk_ipv6_port_label(sock, NULL);\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_ipv6_port_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2671-2723",
    "snippet": "static int smk_ipv6_port_check(struct sock *sk, struct sockaddr_in6 *address,\n\t\t\t\tint act)\n{\n\tstruct smk_port_label *spp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp = NULL;\n\tunsigned short port;\n\tstruct smack_known *object;\n\n\tif (act == SMK_RECEIVING) {\n\t\tskp = smack_ipv6host_label(address);\n\t\tobject = ssp->smk_in;\n\t} else {\n\t\tskp = ssp->smk_out;\n\t\tobject = smack_ipv6host_label(address);\n\t}\n\n\t/*\n\t * The other end is a single label host.\n\t */\n\tif (skp != NULL && object != NULL)\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\tif (skp == NULL)\n\t\tskp = smack_net_ambient;\n\tif (object == NULL)\n\t\tobject = smack_net_ambient;\n\n\t/*\n\t * It's remote, so port lookup does no good.\n\t */\n\tif (!smk_ipv6_localhost(address))\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\n\t/*\n\t * It's local so the send check has to have passed.\n\t */\n\tif (act == SMK_RECEIVING)\n\t\treturn 0;\n\n\tport = ntohs(address->sin6_port);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sk->sk_type)\n\t\t\tcontinue;\n\t\tobject = spp->smk_in;\n\t\tif (act == SMK_CONNECTING)\n\t\t\tssp->smk_packet = spp->smk_out;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn smk_ipv6_check(skp, object, address, act);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [
      "#define SMK_RECEIVING\t1",
      "#define SMK_CONNECTING\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_ipv6_check",
          "args": [
            "skp",
            "object",
            "address",
            "act"
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ipv6_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2551-2573",
          "snippet": "static int smk_ipv6_check(struct smack_known *subject,\n\t\t\t\tstruct smack_known *object,\n\t\t\t\tstruct sockaddr_in6 *address, int act)\n{\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tad.a.u.net->family = PF_INET6;\n\tad.a.u.net->dport = ntohs(address->sin6_port);\n\tif (act == SMK_RECEIVING)\n\t\tad.a.u.net->v6info.saddr = address->sin6_addr;\n\telse\n\t\tad.a.u.net->v6info.daddr = address->sin6_addr;\n#endif\n\trc = smk_access(subject, object, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"IPv6 check\", subject, object, MAY_WRITE, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [
            "#define SMK_RECEIVING\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\n#define SMK_RECEIVING\t1\n\nstatic int smk_ipv6_check(struct smack_known *subject,\n\t\t\t\tstruct smack_known *object,\n\t\t\t\tstruct sockaddr_in6 *address, int act)\n{\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tad.a.u.net->family = PF_INET6;\n\tad.a.u.net->dport = ntohs(address->sin6_port);\n\tif (act == SMK_RECEIVING)\n\t\tad.a.u.net->v6info.saddr = address->sin6_addr;\n\telse\n\t\tad.a.u.net->v6info.daddr = address->sin6_addr;\n#endif\n\trc = smk_access(subject, object, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"IPv6 check\", subject, object, MAY_WRITE, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "spp",
            "&smk_ipv6_port_list",
            "list"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "address->sin6_port"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ipv6_localhost",
          "args": [
            "address"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ipv6_localhost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2391-2400",
          "snippet": "static bool smk_ipv6_localhost(struct sockaddr_in6 *sip)\n{\n\t__be16 *be16p = (__be16 *)&sip->sin6_addr;\n\t__be32 *be32p = (__be32 *)&sip->sin6_addr;\n\n\tif (be32p[0] == 0 && be32p[1] == 0 && be32p[2] == 0 && be16p[6] == 0 &&\n\t    ntohs(be16p[7]) == 1)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic bool smk_ipv6_localhost(struct sockaddr_in6 *sip)\n{\n\t__be16 *be16p = (__be16 *)&sip->sin6_addr;\n\t__be32 *be32p = (__be32 *)&sip->sin6_addr;\n\n\tif (be32p[0] == 0 && be32p[1] == 0 && be32p[2] == 0 && be16p[6] == 0 &&\n\t    ntohs(be16p[7]) == 1)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_ipv6host_label",
          "args": [
            "address"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "smack_ipv6host_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2414-2451",
          "snippet": "static struct smack_known *smack_ipv6host_label(struct sockaddr_in6 *sip)\n{\n\tstruct smk_net6addr *snp;\n\tstruct in6_addr *sap = &sip->sin6_addr;\n\tint i;\n\tint found = 0;\n\n\t/*\n\t * It's local. Don't look for a host label.\n\t */\n\tif (smk_ipv6_localhost(sip))\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\n\t\t/*\n\t\t * If the label is NULL the entry has\n\t\t * been renounced. Ignore it.\n\t\t */\n\t\tif (snp->smk_label == NULL)\n\t\t\tcontinue;\n\t\t/*\n\t\t* we break after finding the first match because\n\t\t* the list is sorted from longest to shortest mask\n\t\t* so we have found the most specific match\n\t\t*/\n\t\tfor (found = 1, i = 0; i < 8; i++) {\n\t\t\tif ((sap->s6_addr16[i] & snp->smk_mask.s6_addr16[i]) !=\n\t\t\t    snp->smk_host.s6_addr16[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\treturn snp->smk_label;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_ipv6host_label(struct sockaddr_in6 *sip)\n{\n\tstruct smk_net6addr *snp;\n\tstruct in6_addr *sap = &sip->sin6_addr;\n\tint i;\n\tint found = 0;\n\n\t/*\n\t * It's local. Don't look for a host label.\n\t */\n\tif (smk_ipv6_localhost(sip))\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\n\t\t/*\n\t\t * If the label is NULL the entry has\n\t\t * been renounced. Ignore it.\n\t\t */\n\t\tif (snp->smk_label == NULL)\n\t\t\tcontinue;\n\t\t/*\n\t\t* we break after finding the first match because\n\t\t* the list is sorted from longest to shortest mask\n\t\t* so we have found the most specific match\n\t\t*/\n\t\tfor (found = 1, i = 0; i < 8; i++) {\n\t\t\tif ((sap->s6_addr16[i] & snp->smk_mask.s6_addr16[i]) !=\n\t\t\t    snp->smk_host.s6_addr16[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\treturn snp->smk_label;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\n#define SMK_RECEIVING\t1\n#define SMK_CONNECTING\t0\n\nstatic int smk_ipv6_port_check(struct sock *sk, struct sockaddr_in6 *address,\n\t\t\t\tint act)\n{\n\tstruct smk_port_label *spp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smack_known *skp = NULL;\n\tunsigned short port;\n\tstruct smack_known *object;\n\n\tif (act == SMK_RECEIVING) {\n\t\tskp = smack_ipv6host_label(address);\n\t\tobject = ssp->smk_in;\n\t} else {\n\t\tskp = ssp->smk_out;\n\t\tobject = smack_ipv6host_label(address);\n\t}\n\n\t/*\n\t * The other end is a single label host.\n\t */\n\tif (skp != NULL && object != NULL)\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\tif (skp == NULL)\n\t\tskp = smack_net_ambient;\n\tif (object == NULL)\n\t\tobject = smack_net_ambient;\n\n\t/*\n\t * It's remote, so port lookup does no good.\n\t */\n\tif (!smk_ipv6_localhost(address))\n\t\treturn smk_ipv6_check(skp, object, address, act);\n\n\t/*\n\t * It's local so the send check has to have passed.\n\t */\n\tif (act == SMK_RECEIVING)\n\t\treturn 0;\n\n\tport = ntohs(address->sin6_port);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sk->sk_type)\n\t\t\tcontinue;\n\t\tobject = spp->smk_in;\n\t\tif (act == SMK_CONNECTING)\n\t\t\tssp->smk_packet = spp->smk_out;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn smk_ipv6_check(skp, object, address, act);\n}"
  },
  {
    "function_name": "smk_ipv6_port_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2584-2662",
    "snippet": "static void smk_ipv6_port_label(struct socket *sock, struct sockaddr *address)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_in6 *addr6;\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n\tstruct smk_port_label *spp;\n\tunsigned short port = 0;\n\n\tif (address == NULL) {\n\t\t/*\n\t\t * This operation is changing the Smack information\n\t\t * on the bound socket. Take the changes to the port\n\t\t * as well.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\t\tif (sk != spp->smk_sock)\n\t\t\t\tcontinue;\n\t\t\tspp->smk_in = ssp->smk_in;\n\t\t\tspp->smk_out = ssp->smk_out;\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * A NULL address is only used for updating existing\n\t\t * bound entries. If there isn't one, it's OK.\n\t\t */\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\taddr6 = (struct sockaddr_in6 *)address;\n\tport = ntohs(addr6->sin6_port);\n\t/*\n\t * This is a special case that is safely ignored.\n\t */\n\tif (port == 0)\n\t\treturn;\n\n\t/*\n\t * Look for an existing port list entry.\n\t * This is an indication that a port is getting reused.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sock->type)\n\t\t\tcontinue;\n\t\tif (spp->smk_can_reuse != 1) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\tspp->smk_port = port;\n\t\tspp->smk_sock = sk;\n\t\tspp->smk_in = ssp->smk_in;\n\t\tspp->smk_out = ssp->smk_out;\n\t\tspp->smk_can_reuse = 0;\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\t/*\n\t * A new port entry is required.\n\t */\n\tspp = kzalloc(sizeof(*spp), GFP_KERNEL);\n\tif (spp == NULL)\n\t\treturn;\n\n\tspp->smk_port = port;\n\tspp->smk_sock = sk;\n\tspp->smk_in = ssp->smk_in;\n\tspp->smk_out = ssp->smk_out;\n\tspp->smk_sock_type = sock->type;\n\tspp->smk_can_reuse = 0;\n\n\tmutex_lock(&smack_ipv6_lock);\n\tlist_add_rcu(&spp->list, &smk_ipv6_port_list);\n\tmutex_unlock(&smack_ipv6_lock);\n\treturn;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&smack_ipv6_lock"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&spp->list",
            "&smk_ipv6_port_list"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&smack_ipv6_lock"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*spp)",
            "GFP_KERNEL"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "spp",
            "&smk_ipv6_port_list",
            "list"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "addr6->sin6_port"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "spp",
            "&smk_ipv6_port_list",
            "list"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smk_ipv6_port_label(struct socket *sock, struct sockaddr *address)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_in6 *addr6;\n\tstruct socket_smack *ssp = sock->sk->sk_security;\n\tstruct smk_port_label *spp;\n\tunsigned short port = 0;\n\n\tif (address == NULL) {\n\t\t/*\n\t\t * This operation is changing the Smack information\n\t\t * on the bound socket. Take the changes to the port\n\t\t * as well.\n\t\t */\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\t\tif (sk != spp->smk_sock)\n\t\t\t\tcontinue;\n\t\t\tspp->smk_in = ssp->smk_in;\n\t\t\tspp->smk_out = ssp->smk_out;\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t * A NULL address is only used for updating existing\n\t\t * bound entries. If there isn't one, it's OK.\n\t\t */\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\taddr6 = (struct sockaddr_in6 *)address;\n\tport = ntohs(addr6->sin6_port);\n\t/*\n\t * This is a special case that is safely ignored.\n\t */\n\tif (port == 0)\n\t\treturn;\n\n\t/*\n\t * Look for an existing port list entry.\n\t * This is an indication that a port is getting reused.\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\tif (spp->smk_port != port || spp->smk_sock_type != sock->type)\n\t\t\tcontinue;\n\t\tif (spp->smk_can_reuse != 1) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t\tspp->smk_port = port;\n\t\tspp->smk_sock = sk;\n\t\tspp->smk_in = ssp->smk_in;\n\t\tspp->smk_out = ssp->smk_out;\n\t\tspp->smk_can_reuse = 0;\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\t/*\n\t * A new port entry is required.\n\t */\n\tspp = kzalloc(sizeof(*spp), GFP_KERNEL);\n\tif (spp == NULL)\n\t\treturn;\n\n\tspp->smk_port = port;\n\tspp->smk_sock = sk;\n\tspp->smk_in = ssp->smk_in;\n\tspp->smk_out = ssp->smk_out;\n\tspp->smk_sock_type = sock->type;\n\tspp->smk_can_reuse = 0;\n\n\tmutex_lock(&smack_ipv6_lock);\n\tlist_add_rcu(&spp->list, &smk_ipv6_port_list);\n\tmutex_unlock(&smack_ipv6_lock);\n\treturn;\n}"
  },
  {
    "function_name": "smk_ipv6_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2551-2573",
    "snippet": "static int smk_ipv6_check(struct smack_known *subject,\n\t\t\t\tstruct smack_known *object,\n\t\t\t\tstruct sockaddr_in6 *address, int act)\n{\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tad.a.u.net->family = PF_INET6;\n\tad.a.u.net->dport = ntohs(address->sin6_port);\n\tif (act == SMK_RECEIVING)\n\t\tad.a.u.net->v6info.saddr = address->sin6_addr;\n\telse\n\t\tad.a.u.net->v6info.daddr = address->sin6_addr;\n#endif\n\trc = smk_access(subject, object, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"IPv6 check\", subject, object, MAY_WRITE, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [
      "#define SMK_RECEIVING\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_note",
          "args": [
            "\"IPv6 check\"",
            "subject",
            "object",
            "MAY_WRITE",
            "rc"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "101-115",
          "snippet": "static int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_access",
          "args": [
            "subject",
            "object",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "120-209",
          "snippet": "int smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};",
            "struct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};",
            "struct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};",
            "struct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "address->sin6_port"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ad_init_net",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_NET",
            "&net"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "437-443",
          "snippet": "static inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,\n\t\t\t\t   char type, struct lsm_network_audit *net)\n{\n\tsmk_ad_init(a, func, type);\n\tmemset(net, 0, sizeof(*net));\n\ta->a.u.net = net;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,\n\t\t\t\t   char type, struct lsm_network_audit *net)\n{\n\tsmk_ad_init(a, func, type);\n\tmemset(net, 0, sizeof(*net));\n\ta->a.u.net = net;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\n#define SMK_RECEIVING\t1\n\nstatic int smk_ipv6_check(struct smack_known *subject,\n\t\t\t\tstruct smack_known *object,\n\t\t\t\tstruct sockaddr_in6 *address, int act)\n{\n#ifdef CONFIG_AUDIT\n\tstruct lsm_network_audit net;\n#endif\n\tstruct smk_audit_info ad;\n\tint rc;\n\n#ifdef CONFIG_AUDIT\n\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\tad.a.u.net->family = PF_INET6;\n\tad.a.u.net->dport = ntohs(address->sin6_port);\n\tif (act == SMK_RECEIVING)\n\t\tad.a.u.net->v6info.saddr = address->sin6_addr;\n\telse\n\t\tad.a.u.net->v6info.daddr = address->sin6_addr;\n#endif\n\trc = smk_access(subject, object, MAY_WRITE, &ad);\n\trc = smk_bu_note(\"IPv6 check\", subject, object, MAY_WRITE, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_netlabel_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2506-2539",
    "snippet": "static int smack_netlabel_send(struct sock *sk, struct sockaddr_in *sap)\n{\n\tstruct smack_known *skp;\n\tint rc;\n\tint sk_lbl;\n\tstruct smack_known *hkp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smk_audit_info ad;\n\n\trcu_read_lock();\n\thkp = smack_ipv4host_label(sap);\n\tif (hkp != NULL) {\n#ifdef CONFIG_AUDIT\n\t\tstruct lsm_network_audit net;\n\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sap->sin_family;\n\t\tad.a.u.net->dport = sap->sin_port;\n\t\tad.a.u.net->v4info.daddr = sap->sin_addr.s_addr;\n#endif\n\t\tsk_lbl = SMACK_UNLABELED_SOCKET;\n\t\tskp = ssp->smk_out;\n\t\trc = smk_access(skp, hkp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 host check\", skp, hkp, MAY_WRITE, rc);\n\t} else {\n\t\tsk_lbl = SMACK_CIPSO_SOCKET;\n\t\trc = 0;\n\t}\n\trcu_read_unlock();\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn smack_netlabel(sk, sk_lbl);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smack_netlabel",
          "args": [
            "sk",
            "sk_lbl"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "smack_netlabel_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2506-2539",
          "snippet": "static int smack_netlabel_send(struct sock *sk, struct sockaddr_in *sap)\n{\n\tstruct smack_known *skp;\n\tint rc;\n\tint sk_lbl;\n\tstruct smack_known *hkp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smk_audit_info ad;\n\n\trcu_read_lock();\n\thkp = smack_ipv4host_label(sap);\n\tif (hkp != NULL) {\n#ifdef CONFIG_AUDIT\n\t\tstruct lsm_network_audit net;\n\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sap->sin_family;\n\t\tad.a.u.net->dport = sap->sin_port;\n\t\tad.a.u.net->v4info.daddr = sap->sin_addr.s_addr;\n#endif\n\t\tsk_lbl = SMACK_UNLABELED_SOCKET;\n\t\tskp = ssp->smk_out;\n\t\trc = smk_access(skp, hkp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 host check\", skp, hkp, MAY_WRITE, rc);\n\t} else {\n\t\tsk_lbl = SMACK_CIPSO_SOCKET;\n\t\trc = 0;\n\t}\n\trcu_read_unlock();\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn smack_netlabel(sk, sk_lbl);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_bu_note",
          "args": [
            "\"IPv4 host check\"",
            "skp",
            "hkp",
            "MAY_WRITE",
            "rc"
          ],
          "line": 2529
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "101-115",
          "snippet": "static int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_access",
          "args": [
            "skp",
            "hkp",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "120-209",
          "snippet": "int smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};",
            "struct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};",
            "struct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};",
            "struct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init_net",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_NET",
            "&net"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "437-443",
          "snippet": "static inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,\n\t\t\t\t   char type, struct lsm_network_audit *net)\n{\n\tsmk_ad_init(a, func, type);\n\tmemset(net, 0, sizeof(*net));\n\ta->a.u.net = net;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init_net(struct smk_audit_info *a, const char *func,\n\t\t\t\t   char type, struct lsm_network_audit *net)\n{\n\tsmk_ad_init(a, func, type);\n\tmemset(net, 0, sizeof(*net));\n\ta->a.u.net = net;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_ipv4host_label",
          "args": [
            "sap"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "smack_ipv4host_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2363-2382",
          "snippet": "static struct smack_known *smack_ipv4host_label(struct sockaddr_in *sip)\n{\n\tstruct smk_net4addr *snp;\n\tstruct in_addr *siap = &sip->sin_addr;\n\n\tif (siap->s_addr == 0)\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net4addr_list, list)\n\t\t/*\n\t\t * we break after finding the first match because\n\t\t * the list is sorted from longest to shortest mask\n\t\t * so we have found the most specific match\n\t\t */\n\t\tif (snp->smk_host.s_addr ==\n\t\t    (siap->s_addr & snp->smk_mask.s_addr))\n\t\t\treturn snp->smk_label;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_ipv4host_label(struct sockaddr_in *sip)\n{\n\tstruct smk_net4addr *snp;\n\tstruct in_addr *siap = &sip->sin_addr;\n\n\tif (siap->s_addr == 0)\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net4addr_list, list)\n\t\t/*\n\t\t * we break after finding the first match because\n\t\t * the list is sorted from longest to shortest mask\n\t\t * so we have found the most specific match\n\t\t */\n\t\tif (snp->smk_host.s_addr ==\n\t\t    (siap->s_addr & snp->smk_mask.s_addr))\n\t\t\treturn snp->smk_label;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_netlabel_send(struct sock *sk, struct sockaddr_in *sap)\n{\n\tstruct smack_known *skp;\n\tint rc;\n\tint sk_lbl;\n\tstruct smack_known *hkp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tstruct smk_audit_info ad;\n\n\trcu_read_lock();\n\thkp = smack_ipv4host_label(sap);\n\tif (hkp != NULL) {\n#ifdef CONFIG_AUDIT\n\t\tstruct lsm_network_audit net;\n\n\t\tsmk_ad_init_net(&ad, __func__, LSM_AUDIT_DATA_NET, &net);\n\t\tad.a.u.net->family = sap->sin_family;\n\t\tad.a.u.net->dport = sap->sin_port;\n\t\tad.a.u.net->v4info.daddr = sap->sin_addr.s_addr;\n#endif\n\t\tsk_lbl = SMACK_UNLABELED_SOCKET;\n\t\tskp = ssp->smk_out;\n\t\trc = smk_access(skp, hkp, MAY_WRITE, &ad);\n\t\trc = smk_bu_note(\"IPv4 host check\", skp, hkp, MAY_WRITE, rc);\n\t} else {\n\t\tsk_lbl = SMACK_CIPSO_SOCKET;\n\t\trc = 0;\n\t}\n\trcu_read_unlock();\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn smack_netlabel(sk, sk_lbl);\n}"
  },
  {
    "function_name": "smack_netlabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2464-2493",
    "snippet": "static int smack_netlabel(struct sock *sk, int labeled)\n{\n\tstruct smack_known *skp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tint rc = 0;\n\n\t/*\n\t * Usually the netlabel code will handle changing the\n\t * packet labeling based on the label.\n\t * The case of a single label host is different, because\n\t * a single label host should never get a labeled packet\n\t * even though the label is usually associated with a packet\n\t * label.\n\t */\n\tlocal_bh_disable();\n\tbh_lock_sock_nested(sk);\n\n\tif (ssp->smk_out == smack_net_ambient ||\n\t    labeled == SMACK_UNLABELED_SOCKET)\n\t\tnetlbl_sock_delattr(sk);\n\telse {\n\t\tskp = ssp->smk_out;\n\t\trc = netlbl_sock_setattr(sk, sk->sk_family, &skp->smk_netlabel);\n\t}\n\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_unlock_sock",
          "args": [
            "sk"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_sock_setattr",
          "args": [
            "sk",
            "sk->sk_family",
            "&skp->smk_netlabel"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_sock_delattr",
          "args": [
            "sk"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_lock_sock_nested",
          "args": [
            "sk"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_netlabel(struct sock *sk, int labeled)\n{\n\tstruct smack_known *skp;\n\tstruct socket_smack *ssp = sk->sk_security;\n\tint rc = 0;\n\n\t/*\n\t * Usually the netlabel code will handle changing the\n\t * packet labeling based on the label.\n\t * The case of a single label host is different, because\n\t * a single label host should never get a labeled packet\n\t * even though the label is usually associated with a packet\n\t * label.\n\t */\n\tlocal_bh_disable();\n\tbh_lock_sock_nested(sk);\n\n\tif (ssp->smk_out == smack_net_ambient ||\n\t    labeled == SMACK_UNLABELED_SOCKET)\n\t\tnetlbl_sock_delattr(sk);\n\telse {\n\t\tskp = ssp->smk_out;\n\t\trc = netlbl_sock_setattr(sk, sk->sk_family, &skp->smk_netlabel);\n\t}\n\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_ipv6host_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2414-2451",
    "snippet": "static struct smack_known *smack_ipv6host_label(struct sockaddr_in6 *sip)\n{\n\tstruct smk_net6addr *snp;\n\tstruct in6_addr *sap = &sip->sin6_addr;\n\tint i;\n\tint found = 0;\n\n\t/*\n\t * It's local. Don't look for a host label.\n\t */\n\tif (smk_ipv6_localhost(sip))\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\n\t\t/*\n\t\t * If the label is NULL the entry has\n\t\t * been renounced. Ignore it.\n\t\t */\n\t\tif (snp->smk_label == NULL)\n\t\t\tcontinue;\n\t\t/*\n\t\t* we break after finding the first match because\n\t\t* the list is sorted from longest to shortest mask\n\t\t* so we have found the most specific match\n\t\t*/\n\t\tfor (found = 1, i = 0; i < 8; i++) {\n\t\t\tif ((sap->s6_addr16[i] & snp->smk_mask.s6_addr16[i]) !=\n\t\t\t    snp->smk_host.s6_addr16[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\treturn snp->smk_label;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "snp",
            "&smk_net6addr_list",
            "list"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ipv6_localhost",
          "args": [
            "sip"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ipv6_localhost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2391-2400",
          "snippet": "static bool smk_ipv6_localhost(struct sockaddr_in6 *sip)\n{\n\t__be16 *be16p = (__be16 *)&sip->sin6_addr;\n\t__be32 *be32p = (__be32 *)&sip->sin6_addr;\n\n\tif (be32p[0] == 0 && be32p[1] == 0 && be32p[2] == 0 && be16p[6] == 0 &&\n\t    ntohs(be16p[7]) == 1)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic bool smk_ipv6_localhost(struct sockaddr_in6 *sip)\n{\n\t__be16 *be16p = (__be16 *)&sip->sin6_addr;\n\t__be32 *be32p = (__be32 *)&sip->sin6_addr;\n\n\tif (be32p[0] == 0 && be32p[1] == 0 && be32p[2] == 0 && be16p[6] == 0 &&\n\t    ntohs(be16p[7]) == 1)\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_ipv6host_label(struct sockaddr_in6 *sip)\n{\n\tstruct smk_net6addr *snp;\n\tstruct in6_addr *sap = &sip->sin6_addr;\n\tint i;\n\tint found = 0;\n\n\t/*\n\t * It's local. Don't look for a host label.\n\t */\n\tif (smk_ipv6_localhost(sip))\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\n\t\t/*\n\t\t * If the label is NULL the entry has\n\t\t * been renounced. Ignore it.\n\t\t */\n\t\tif (snp->smk_label == NULL)\n\t\t\tcontinue;\n\t\t/*\n\t\t* we break after finding the first match because\n\t\t* the list is sorted from longest to shortest mask\n\t\t* so we have found the most specific match\n\t\t*/\n\t\tfor (found = 1, i = 0; i < 8; i++) {\n\t\t\tif ((sap->s6_addr16[i] & snp->smk_mask.s6_addr16[i]) !=\n\t\t\t    snp->smk_host.s6_addr16[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\treturn snp->smk_label;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "smk_ipv6_localhost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2391-2400",
    "snippet": "static bool smk_ipv6_localhost(struct sockaddr_in6 *sip)\n{\n\t__be16 *be16p = (__be16 *)&sip->sin6_addr;\n\t__be32 *be32p = (__be32 *)&sip->sin6_addr;\n\n\tif (be32p[0] == 0 && be32p[1] == 0 && be32p[2] == 0 && be16p[6] == 0 &&\n\t    ntohs(be16p[7]) == 1)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "be16p[7]"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic bool smk_ipv6_localhost(struct sockaddr_in6 *sip)\n{\n\t__be16 *be16p = (__be16 *)&sip->sin6_addr;\n\t__be32 *be32p = (__be32 *)&sip->sin6_addr;\n\n\tif (be32p[0] == 0 && be32p[1] == 0 && be32p[2] == 0 && be16p[6] == 0 &&\n\t    ntohs(be16p[7]) == 1)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "smack_ipv4host_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2363-2382",
    "snippet": "static struct smack_known *smack_ipv4host_label(struct sockaddr_in *sip)\n{\n\tstruct smk_net4addr *snp;\n\tstruct in_addr *siap = &sip->sin_addr;\n\n\tif (siap->s_addr == 0)\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net4addr_list, list)\n\t\t/*\n\t\t * we break after finding the first match because\n\t\t * the list is sorted from longest to shortest mask\n\t\t * so we have found the most specific match\n\t\t */\n\t\tif (snp->smk_host.s_addr ==\n\t\t    (siap->s_addr & snp->smk_mask.s_addr))\n\t\t\treturn snp->smk_label;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "snp",
            "&smk_net4addr_list",
            "list"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smack_ipv4host_label(struct sockaddr_in *sip)\n{\n\tstruct smk_net4addr *snp;\n\tstruct in_addr *siap = &sip->sin_addr;\n\n\tif (siap->s_addr == 0)\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(snp, &smk_net4addr_list, list)\n\t\t/*\n\t\t * we break after finding the first match because\n\t\t * the list is sorted from longest to shortest mask\n\t\t * so we have found the most specific match\n\t\t */\n\t\tif (snp->smk_host.s_addr ==\n\t\t    (siap->s_addr & snp->smk_mask.s_addr))\n\t\t\treturn snp->smk_label;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "smack_sk_free_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2332-2349",
    "snippet": "static void smack_sk_free_security(struct sock *sk)\n{\n#ifdef SMACK_IPV6_PORT_LABELING\n\tstruct smk_port_label *spp;\n\n\tif (sk->sk_family == PF_INET6) {\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\t\tif (spp->smk_sock != sk)\n\t\t\t\tcontinue;\n\t\t\tspp->smk_can_reuse = 1;\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n#endif\n\tkfree(sk->sk_security);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sk->sk_security"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "spp",
            "&smk_ipv6_port_list",
            "list"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_sk_free_security(struct sock *sk)\n{\n#ifdef SMACK_IPV6_PORT_LABELING\n\tstruct smk_port_label *spp;\n\n\tif (sk->sk_family == PF_INET6) {\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {\n\t\t\tif (spp->smk_sock != sk)\n\t\t\t\tcontinue;\n\t\t\tspp->smk_can_reuse = 1;\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n#endif\n\tkfree(sk->sk_security);\n}"
  },
  {
    "function_name": "smack_sk_alloc_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2300-2324",
    "snippet": "static int smack_sk_alloc_security(struct sock *sk, int family, gfp_t gfp_flags)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct socket_smack *ssp;\n\n\tssp = kzalloc(sizeof(struct socket_smack), gfp_flags);\n\tif (ssp == NULL)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Sockets created by kernel threads receive web label.\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD)) {\n\t\tssp->smk_in = &smack_known_web;\n\t\tssp->smk_out = &smack_known_web;\n\t} else {\n\t\tssp->smk_in = skp;\n\t\tssp->smk_out = skp;\n\t}\n\tssp->smk_packet = NULL;\n\n\tsk->sk_security = ssp;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->flags & PF_KTHREAD"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct socket_smack)",
            "gfp_flags"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_sk_alloc_security(struct sock *sk, int family, gfp_t gfp_flags)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct socket_smack *ssp;\n\n\tssp = kzalloc(sizeof(struct socket_smack), gfp_flags);\n\tif (ssp == NULL)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Sockets created by kernel threads receive web label.\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD)) {\n\t\tssp->smk_in = &smack_known_web;\n\t\tssp->smk_out = &smack_known_web;\n\t} else {\n\t\tssp->smk_in = skp;\n\t\tssp->smk_out = skp;\n\t}\n\tssp->smk_packet = NULL;\n\n\tsk->sk_security = ssp;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_task_to_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2278-2284",
    "snippet": "static void smack_task_to_inode(struct task_struct *p, struct inode *inode)\n{\n\tstruct inode_smack *isp = inode->i_security;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\n\tisp->smk_inode = skp;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_of_task_struct",
          "args": [
            "p"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "384-392",
          "snippet": "static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_task_to_inode(struct task_struct *p, struct inode *inode)\n{\n\tstruct inode_smack *isp = inode->i_security;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\n\tisp->smk_inode = skp;\n}"
  },
  {
    "function_name": "smack_task_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2238-2269",
    "snippet": "static int smack_task_kill(struct task_struct *p, struct siginfo *info,\n\t\t\t   int sig, u32 secid)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp;\n\tstruct smack_known *tkp = smk_of_task_struct(p);\n\tint rc;\n\n\tif (!sig)\n\t\treturn 0; /* null signal; existence test */\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\t/*\n\t * Sending a signal requires that the sender\n\t * can write the receiver.\n\t */\n\tif (secid == 0) {\n\t\trc = smk_curacc(tkp, MAY_DELIVER, &ad);\n\t\trc = smk_bu_task(p, MAY_DELIVER, rc);\n\t\treturn rc;\n\t}\n\t/*\n\t * If the secid isn't 0 we're dealing with some USB IO\n\t * specific behavior. This is not clean. For one thing\n\t * we can't take privilege into account.\n\t */\n\tskp = smack_from_secid(secid);\n\trc = smk_access(skp, tkp, MAY_DELIVER, &ad);\n\trc = smk_bu_note(\"USB signal\", skp, tkp, MAY_DELIVER, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_note",
          "args": [
            "\"USB signal\"",
            "skp",
            "tkp",
            "MAY_DELIVER",
            "rc"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "101-115",
          "snippet": "static int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_access",
          "args": [
            "skp",
            "tkp",
            "MAY_DELIVER",
            "&ad"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "120-209",
          "snippet": "int smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};",
            "struct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};",
            "struct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};",
            "struct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_from_secid",
          "args": [
            "secid"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "smack_from_secid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "596-614",
          "snippet": "struct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};\n\nstruct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_bu_task",
          "args": [
            "p",
            "MAY_DELIVER",
            "rc"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "143-159",
          "snippet": "static int smk_bu_task(struct task_struct *otp, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *smk_task = smk_of_task_struct(otp);\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s to %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, smk_task->smk_known, acc,\n\t\tcurrent->comm, otp->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_task(struct task_struct *otp, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *smk_task = smk_of_task_struct(otp);\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s to %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, smk_task->smk_known, acc,\n\t\tcurrent->comm, otp->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "tkp",
            "MAY_DELIVER",
            "&ad"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_tsk",
          "args": [
            "&ad",
            "p"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_tsk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "477-480",
          "snippet": "static inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,\n\t\t\t\t\t struct task_struct *t)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,\n\t\t\t\t\t struct task_struct *t)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_TASK"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_task_struct",
          "args": [
            "p"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "384-392",
          "snippet": "static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_task_kill(struct task_struct *p, struct siginfo *info,\n\t\t\t   int sig, u32 secid)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp;\n\tstruct smack_known *tkp = smk_of_task_struct(p);\n\tint rc;\n\n\tif (!sig)\n\t\treturn 0; /* null signal; existence test */\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\t/*\n\t * Sending a signal requires that the sender\n\t * can write the receiver.\n\t */\n\tif (secid == 0) {\n\t\trc = smk_curacc(tkp, MAY_DELIVER, &ad);\n\t\trc = smk_bu_task(p, MAY_DELIVER, rc);\n\t\treturn rc;\n\t}\n\t/*\n\t * If the secid isn't 0 we're dealing with some USB IO\n\t * specific behavior. This is not clean. For one thing\n\t * we can't take privilege into account.\n\t */\n\tskp = smack_from_secid(secid);\n\trc = smk_access(skp, tkp, MAY_DELIVER, &ad);\n\trc = smk_bu_note(\"USB signal\", skp, tkp, MAY_DELIVER, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_task_movememory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2221-2224",
    "snippet": "static int smack_task_movememory(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_on_task",
          "args": [
            "p",
            "MAY_WRITE",
            "__func__"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_task_movememory(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}"
  },
  {
    "function_name": "smack_task_getscheduler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2210-2213",
    "snippet": "static int smack_task_getscheduler(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_READ, __func__);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_on_task",
          "args": [
            "p",
            "MAY_READ",
            "__func__"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_task_getscheduler(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_READ, __func__);\n}"
  },
  {
    "function_name": "smack_task_setscheduler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2199-2202",
    "snippet": "static int smack_task_setscheduler(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_on_task",
          "args": [
            "p",
            "MAY_WRITE",
            "__func__"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_task_setscheduler(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}"
  },
  {
    "function_name": "smack_task_getioprio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2186-2189",
    "snippet": "static int smack_task_getioprio(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_READ, __func__);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_on_task",
          "args": [
            "p",
            "MAY_READ",
            "__func__"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_task_getioprio(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_READ, __func__);\n}"
  },
  {
    "function_name": "smack_task_setioprio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2175-2178",
    "snippet": "static int smack_task_setioprio(struct task_struct *p, int ioprio)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_on_task",
          "args": [
            "p",
            "MAY_WRITE",
            "__func__"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_task_setioprio(struct task_struct *p, int ioprio)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}"
  },
  {
    "function_name": "smack_task_setnice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2163-2166",
    "snippet": "static int smack_task_setnice(struct task_struct *p, int nice)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_on_task",
          "args": [
            "p",
            "MAY_WRITE",
            "__func__"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_task_setnice(struct task_struct *p, int nice)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}"
  },
  {
    "function_name": "smack_task_getsecid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2149-2154",
    "snippet": "static void smack_task_getsecid(struct task_struct *p, u32 *secid)\n{\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\n\t*secid = skp->smk_secid;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_of_task_struct",
          "args": [
            "p"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "384-392",
          "snippet": "static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_task_getsecid(struct task_struct *p, u32 *secid)\n{\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\n\t*secid = skp->smk_secid;\n}"
  },
  {
    "function_name": "smack_task_getsid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2137-2140",
    "snippet": "static int smack_task_getsid(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_READ, __func__);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_on_task",
          "args": [
            "p",
            "MAY_READ",
            "__func__"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_task_getsid(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_READ, __func__);\n}"
  },
  {
    "function_name": "smack_task_getpgid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2126-2129",
    "snippet": "static int smack_task_getpgid(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_READ, __func__);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_on_task",
          "args": [
            "p",
            "MAY_READ",
            "__func__"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_task_getpgid(struct task_struct *p)\n{\n\treturn smk_curacc_on_task(p, MAY_READ, __func__);\n}"
  },
  {
    "function_name": "smack_task_setpgid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2115-2118",
    "snippet": "static int smack_task_setpgid(struct task_struct *p, pid_t pgid)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_curacc_on_task",
          "args": [
            "p",
            "MAY_WRITE",
            "__func__"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_task_setpgid(struct task_struct *p, pid_t pgid)\n{\n\treturn smk_curacc_on_task(p, MAY_WRITE, __func__);\n}"
  },
  {
    "function_name": "smk_curacc_on_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2094-2106",
    "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_task",
          "args": [
            "p",
            "access",
            "rc"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "143-159",
          "snippet": "static int smk_bu_task(struct task_struct *otp, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *smk_task = smk_of_task_struct(otp);\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s to %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, smk_task->smk_known, acc,\n\t\tcurrent->comm, otp->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_task(struct task_struct *otp, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *smk_task = smk_of_task_struct(otp);\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s to %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, smk_task->smk_known, acc,\n\t\tcurrent->comm, otp->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "skp",
            "access",
            "&ad"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_tsk",
          "args": [
            "&ad",
            "p"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_tsk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "477-480",
          "snippet": "static inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,\n\t\t\t\t\t struct task_struct *t)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,\n\t\t\t\t\t struct task_struct *t)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "caller",
            "LSM_AUDIT_DATA_TASK"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_task_struct",
          "args": [
            "p"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "384-392",
          "snippet": "static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_kernel_create_files_as",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2075-2084",
    "snippet": "static int smack_kernel_create_files_as(struct cred *new,\n\t\t\t\t\tstruct inode *inode)\n{\n\tstruct inode_smack *isp = inode->i_security;\n\tstruct task_smack *tsp = new->security;\n\n\ttsp->smk_forked = isp->smk_inode;\n\ttsp->smk_task = tsp->smk_forked;\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_kernel_create_files_as(struct cred *new,\n\t\t\t\t\tstruct inode *inode)\n{\n\tstruct inode_smack *isp = inode->i_security;\n\tstruct task_smack *tsp = new->security;\n\n\ttsp->smk_forked = isp->smk_inode;\n\ttsp->smk_task = tsp->smk_forked;\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_kernel_act_as",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2059-2065",
    "snippet": "static int smack_kernel_act_as(struct cred *new, u32 secid)\n{\n\tstruct task_smack *new_tsp = new->security;\n\n\tnew_tsp->smk_task = smack_from_secid(secid);\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smack_from_secid",
          "args": [
            "secid"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "smack_from_secid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "596-614",
          "snippet": "struct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_huh = {\n\t.smk_known\t= \"?\",\n\t.smk_secid\t= 2,\n};\n\nstruct smack_known *smack_from_secid(const u32 secid)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(skp, &smack_known_list, list) {\n\t\tif (skp->smk_secid == secid) {\n\t\t\trcu_read_unlock();\n\t\t\treturn skp;\n\t\t}\n\t}\n\n\t/*\n\t * If we got this far someone asked for the translation\n\t * of a secid that is not on the list.\n\t */\n\trcu_read_unlock();\n\treturn &smack_known_huh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_kernel_act_as(struct cred *new, u32 secid)\n{\n\tstruct task_smack *new_tsp = new->security;\n\n\tnew_tsp->smk_task = smack_from_secid(secid);\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_cred_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2038-2050",
    "snippet": "static void smack_cred_transfer(struct cred *new, const struct cred *old)\n{\n\tstruct task_smack *old_tsp = old->security;\n\tstruct task_smack *new_tsp = new->security;\n\n\tnew_tsp->smk_task = old_tsp->smk_task;\n\tnew_tsp->smk_forked = old_tsp->smk_task;\n\tmutex_init(&new_tsp->smk_rules_lock);\n\tINIT_LIST_HEAD(&new_tsp->smk_rules);\n\n\n\t/* cbs copy rule list */\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new_tsp->smk_rules"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&new_tsp->smk_rules_lock"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_cred_transfer(struct cred *new, const struct cred *old)\n{\n\tstruct task_smack *old_tsp = old->security;\n\tstruct task_smack *new_tsp = new->security;\n\n\tnew_tsp->smk_task = old_tsp->smk_task;\n\tnew_tsp->smk_forked = old_tsp->smk_task;\n\tmutex_init(&new_tsp->smk_rules_lock);\n\tINIT_LIST_HEAD(&new_tsp->smk_rules);\n\n\n\t/* cbs copy rule list */\n}"
  },
  {
    "function_name": "smack_cred_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "2006-2029",
    "snippet": "static int smack_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t      gfp_t gfp)\n{\n\tstruct task_smack *old_tsp = old->security;\n\tstruct task_smack *new_tsp;\n\tint rc;\n\n\tnew_tsp = new_task_smack(old_tsp->smk_task, old_tsp->smk_task, gfp);\n\tif (new_tsp == NULL)\n\t\treturn -ENOMEM;\n\n\tnew->security = new_tsp;\n\n\trc = smk_copy_rules(&new_tsp->smk_rules, &old_tsp->smk_rules, gfp);\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = smk_copy_relabel(&new_tsp->smk_relabel, &old_tsp->smk_relabel,\n\t\t\t\tgfp);\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_copy_relabel",
          "args": [
            "&new_tsp->smk_relabel",
            "&old_tsp->smk_relabel",
            "gfp"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "smk_copy_relabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "371-388",
          "snippet": "static int smk_copy_relabel(struct list_head *nhead, struct list_head *ohead,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct smack_known_list_elem *nklep;\n\tstruct smack_known_list_elem *oklep;\n\n\tlist_for_each_entry(oklep, ohead, list) {\n\t\tnklep = kzalloc(sizeof(struct smack_known_list_elem), gfp);\n\t\tif (nklep == NULL) {\n\t\t\tsmk_destroy_label_list(nhead);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnklep->smk_label = oklep->smk_label;\n\t\tlist_add(&nklep->list, nhead);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_copy_relabel(struct list_head *nhead, struct list_head *ohead,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct smack_known_list_elem *nklep;\n\tstruct smack_known_list_elem *oklep;\n\n\tlist_for_each_entry(oklep, ohead, list) {\n\t\tnklep = kzalloc(sizeof(struct smack_known_list_elem), gfp);\n\t\tif (nklep == NULL) {\n\t\t\tsmk_destroy_label_list(nhead);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnklep->smk_label = oklep->smk_label;\n\t\tlist_add(&nklep->list, nhead);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_copy_rules",
          "args": [
            "&new_tsp->smk_rules",
            "&old_tsp->smk_rules",
            "gfp"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "smk_copy_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "344-361",
          "snippet": "static int smk_copy_rules(struct list_head *nhead, struct list_head *ohead,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct smack_rule *nrp;\n\tstruct smack_rule *orp;\n\tint rc = 0;\n\n\tlist_for_each_entry_rcu(orp, ohead, list) {\n\t\tnrp = kzalloc(sizeof(struct smack_rule), gfp);\n\t\tif (nrp == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t*nrp = *orp;\n\t\tlist_add_rcu(&nrp->list, nhead);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_copy_rules(struct list_head *nhead, struct list_head *ohead,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct smack_rule *nrp;\n\tstruct smack_rule *orp;\n\tint rc = 0;\n\n\tlist_for_each_entry_rcu(orp, ohead, list) {\n\t\tnrp = kzalloc(sizeof(struct smack_rule), gfp);\n\t\tif (nrp == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t*nrp = *orp;\n\t\tlist_add_rcu(&nrp->list, nhead);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_task_smack",
          "args": [
            "old_tsp->smk_task",
            "old_tsp->smk_task",
            "gfp"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "new_task_smack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "318-334",
          "snippet": "static struct task_smack *new_task_smack(struct smack_known *task,\n\t\t\t\t\tstruct smack_known *forked, gfp_t gfp)\n{\n\tstruct task_smack *tsp;\n\n\ttsp = kzalloc(sizeof(struct task_smack), gfp);\n\tif (tsp == NULL)\n\t\treturn NULL;\n\n\ttsp->smk_task = task;\n\ttsp->smk_forked = forked;\n\tINIT_LIST_HEAD(&tsp->smk_rules);\n\tINIT_LIST_HEAD(&tsp->smk_relabel);\n\tmutex_init(&tsp->smk_rules_lock);\n\n\treturn tsp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct task_smack *new_task_smack(struct smack_known *task,\n\t\t\t\t\tstruct smack_known *forked, gfp_t gfp)\n{\n\tstruct task_smack *tsp;\n\n\ttsp = kzalloc(sizeof(struct task_smack), gfp);\n\tif (tsp == NULL)\n\t\treturn NULL;\n\n\ttsp->smk_task = task;\n\ttsp->smk_forked = forked;\n\tINIT_LIST_HEAD(&tsp->smk_rules);\n\tINIT_LIST_HEAD(&tsp->smk_relabel);\n\tmutex_init(&tsp->smk_rules_lock);\n\n\treturn tsp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t      gfp_t gfp)\n{\n\tstruct task_smack *old_tsp = old->security;\n\tstruct task_smack *new_tsp;\n\tint rc;\n\n\tnew_tsp = new_task_smack(old_tsp->smk_task, old_tsp->smk_task, gfp);\n\tif (new_tsp == NULL)\n\t\treturn -ENOMEM;\n\n\tnew->security = new_tsp;\n\n\trc = smk_copy_rules(&new_tsp->smk_rules, &old_tsp->smk_rules, gfp);\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = smk_copy_relabel(&new_tsp->smk_relabel, &old_tsp->smk_relabel,\n\t\t\t\tgfp);\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_cred_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1977-1996",
    "snippet": "static void smack_cred_free(struct cred *cred)\n{\n\tstruct task_smack *tsp = cred->security;\n\tstruct smack_rule *rp;\n\tstruct list_head *l;\n\tstruct list_head *n;\n\n\tif (tsp == NULL)\n\t\treturn;\n\tcred->security = NULL;\n\n\tsmk_destroy_label_list(&tsp->smk_relabel);\n\n\tlist_for_each_safe(l, n, &tsp->smk_rules) {\n\t\trp = list_entry(l, struct smack_rule, list);\n\t\tlist_del(&rp->list);\n\t\tkfree(rp);\n\t}\n\tkfree(tsp);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tsp"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rp"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rp->list"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "l",
            "structsmack_rule",
            "list"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "l",
            "n",
            "&tsp->smk_rules"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_destroy_label_list",
          "args": [
            "&tsp->smk_relabel"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "smk_destroy_label_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "1988-1997",
          "snippet": "void smk_destroy_label_list(struct list_head *list)\n{\n\tstruct smack_known_list_elem *sklep;\n\tstruct smack_known_list_elem *sklep2;\n\n\tlist_for_each_entry_safe(sklep, sklep2, list, list)\n\t\tkfree(sklep);\n\n\tINIT_LIST_HEAD(list);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nvoid smk_destroy_label_list(struct list_head *list)\n{\n\tstruct smack_known_list_elem *sklep;\n\tstruct smack_known_list_elem *sklep2;\n\n\tlist_for_each_entry_safe(sklep, sklep2, list, list)\n\t\tkfree(sklep);\n\n\tINIT_LIST_HEAD(list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_cred_free(struct cred *cred)\n{\n\tstruct task_smack *tsp = cred->security;\n\tstruct smack_rule *rp;\n\tstruct list_head *l;\n\tstruct list_head *n;\n\n\tif (tsp == NULL)\n\t\treturn;\n\tcred->security = NULL;\n\n\tsmk_destroy_label_list(&tsp->smk_relabel);\n\n\tlist_for_each_safe(l, n, &tsp->smk_rules) {\n\t\trp = list_entry(l, struct smack_rule, list);\n\t\tlist_del(&rp->list);\n\t\tkfree(rp);\n\t}\n\tkfree(tsp);\n}"
  },
  {
    "function_name": "smack_cred_alloc_blank",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1958-1969",
    "snippet": "static int smack_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\tstruct task_smack *tsp;\n\n\ttsp = new_task_smack(NULL, NULL, gfp);\n\tif (tsp == NULL)\n\t\treturn -ENOMEM;\n\n\tcred->security = tsp;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_task_smack",
          "args": [
            "NULL",
            "NULL",
            "gfp"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "new_task_smack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "318-334",
          "snippet": "static struct task_smack *new_task_smack(struct smack_known *task,\n\t\t\t\t\tstruct smack_known *forked, gfp_t gfp)\n{\n\tstruct task_smack *tsp;\n\n\ttsp = kzalloc(sizeof(struct task_smack), gfp);\n\tif (tsp == NULL)\n\t\treturn NULL;\n\n\ttsp->smk_task = task;\n\ttsp->smk_forked = forked;\n\tINIT_LIST_HEAD(&tsp->smk_rules);\n\tINIT_LIST_HEAD(&tsp->smk_relabel);\n\tmutex_init(&tsp->smk_rules_lock);\n\n\treturn tsp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct task_smack *new_task_smack(struct smack_known *task,\n\t\t\t\t\tstruct smack_known *forked, gfp_t gfp)\n{\n\tstruct task_smack *tsp;\n\n\ttsp = kzalloc(sizeof(struct task_smack), gfp);\n\tif (tsp == NULL)\n\t\treturn NULL;\n\n\ttsp->smk_task = task;\n\ttsp->smk_forked = forked;\n\tINIT_LIST_HEAD(&tsp->smk_rules);\n\tINIT_LIST_HEAD(&tsp->smk_relabel);\n\tmutex_init(&tsp->smk_rules_lock);\n\n\treturn tsp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\tstruct task_smack *tsp;\n\n\ttsp = new_task_smack(NULL, NULL, gfp);\n\tif (tsp == NULL)\n\t\treturn -ENOMEM;\n\n\tcred->security = tsp;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1930-1943",
    "snippet": "static int smack_file_open(struct file *file, const struct cred *cred)\n{\n\tstruct task_smack *tsp = cred->security;\n\tstruct inode *inode = file_inode(file);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\trc = smk_tskacc(tsp, smk_of_inode(inode), MAY_READ, &ad);\n\trc = smk_bu_credfile(cred, file, MAY_READ, rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_credfile",
          "args": [
            "cred",
            "file",
            "MAY_READ",
            "rc"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_credfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "224-248",
          "snippet": "static int smk_bu_credfile(const struct cred *cred, struct file *file,\n\t\t\t\tint mode, int rc)\n{\n\tstruct task_smack *tsp = cred->security;\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_credfile(const struct cred *cred, struct file *file,\n\t\t\t\tint mode, int rc)\n{\n\tstruct task_smack *tsp = cred->security;\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_tskacc",
          "args": [
            "tsp",
            "smk_of_inode(inode)",
            "MAY_READ",
            "&ad"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "smk_tskacc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "223-262",
          "snippet": "int smk_tskacc(struct task_smack *tsp, struct smack_known *obj_known,\n\t       u32 mode, struct smk_audit_info *a)\n{\n\tstruct smack_known *sbj_known = smk_of_task(tsp);\n\tint may;\n\tint rc;\n\n\t/*\n\t * Check the global rule list\n\t */\n\trc = smk_access(sbj_known, obj_known, mode, NULL);\n\tif (rc >= 0) {\n\t\t/*\n\t\t * If there is an entry in the task's rule list\n\t\t * it can further restrict access.\n\t\t */\n\t\tmay = smk_access_entry(sbj_known->smk_known,\n\t\t\t\t       obj_known->smk_known,\n\t\t\t\t       &tsp->smk_rules);\n\t\tif (may < 0)\n\t\t\tgoto out_audit;\n\t\tif ((mode & may) == mode)\n\t\t\tgoto out_audit;\n\t\trc = -EACCES;\n\t}\n\n\t/*\n\t * Allow for priviliged to override policy.\n\t */\n\tif (rc != 0 && smack_privileged(CAP_MAC_OVERRIDE))\n\t\trc = 0;\n\nout_audit:\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(sbj_known->smk_known, obj_known->smk_known,\n\t\t\t  mode, rc, a);\n#endif\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_tskacc(struct task_smack *tsp, struct smack_known *obj_known,\n\t       u32 mode, struct smk_audit_info *a)\n{\n\tstruct smack_known *sbj_known = smk_of_task(tsp);\n\tint may;\n\tint rc;\n\n\t/*\n\t * Check the global rule list\n\t */\n\trc = smk_access(sbj_known, obj_known, mode, NULL);\n\tif (rc >= 0) {\n\t\t/*\n\t\t * If there is an entry in the task's rule list\n\t\t * it can further restrict access.\n\t\t */\n\t\tmay = smk_access_entry(sbj_known->smk_known,\n\t\t\t\t       obj_known->smk_known,\n\t\t\t\t       &tsp->smk_rules);\n\t\tif (may < 0)\n\t\t\tgoto out_audit;\n\t\tif ((mode & may) == mode)\n\t\t\tgoto out_audit;\n\t\trc = -EACCES;\n\t}\n\n\t/*\n\t * Allow for priviliged to override policy.\n\t */\n\tif (rc != 0 && smack_privileged(CAP_MAC_OVERRIDE))\n\t\trc = 0;\n\nout_audit:\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(sbj_known->smk_known, obj_known->smk_known,\n\t\t\t  mode, rc, a);\n#endif\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "inode"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path",
          "args": [
            "&ad",
            "file->f_path"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "493-496",
          "snippet": "static inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_PATH"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_file_open(struct file *file, const struct cred *cred)\n{\n\tstruct task_smack *tsp = cred->security;\n\tstruct inode *inode = file_inode(file);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\trc = smk_tskacc(tsp, smk_of_inode(inode), MAY_READ, &ad);\n\trc = smk_bu_credfile(cred, file, MAY_READ, rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_file_receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1871-1916",
    "snippet": "static int smack_file_receive(struct file *file)\n{\n\tint rc;\n\tint may = 0;\n\tstruct smk_audit_info ad;\n\tstruct inode *inode = file_inode(file);\n\tstruct socket *sock;\n\tstruct task_smack *tsp;\n\tstruct socket_smack *ssp;\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\n\tif (inode->i_sb->s_magic == SOCKFS_MAGIC) {\n\t\tsock = SOCKET_I(inode);\n\t\tssp = sock->sk->sk_security;\n\t\ttsp = current_security();\n\t\t/*\n\t\t * If the receiving process can't write to the\n\t\t * passed socket or if the passed socket can't\n\t\t * write to the receiving process don't accept\n\t\t * the passed socket.\n\t\t */\n\t\trc = smk_access(tsp->smk_task, ssp->smk_out, MAY_WRITE, &ad);\n\t\trc = smk_bu_file(file, may, rc);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = smk_access(ssp->smk_in, tsp->smk_task, MAY_WRITE, &ad);\n\t\trc = smk_bu_file(file, may, rc);\n\t\treturn rc;\n\t}\n\t/*\n\t * This code relies on bitmasks.\n\t */\n\tif (file->f_mode & FMODE_READ)\n\t\tmay = MAY_READ;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tmay |= MAY_WRITE;\n\n\trc = smk_curacc(smk_of_inode(inode), may, &ad);\n\trc = smk_bu_file(file, may, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_file",
          "args": [
            "file",
            "may",
            "rc"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "195-218",
          "snippet": "static int smk_bu_file(struct file *file, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_file(struct file *file, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "smk_of_inode(inode)",
            "may",
            "&ad"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "inode"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_access",
          "args": [
            "ssp->smk_in",
            "tsp->smk_task",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "120-209",
          "snippet": "int smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};",
            "struct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};",
            "struct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};",
            "struct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOCKET_I",
          "args": [
            "inode"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path",
          "args": [
            "&ad",
            "file->f_path"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "493-496",
          "snippet": "static inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_PATH"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_PRIVATE(inode)"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "inode"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_file_receive(struct file *file)\n{\n\tint rc;\n\tint may = 0;\n\tstruct smk_audit_info ad;\n\tstruct inode *inode = file_inode(file);\n\tstruct socket *sock;\n\tstruct task_smack *tsp;\n\tstruct socket_smack *ssp;\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\n\tif (inode->i_sb->s_magic == SOCKFS_MAGIC) {\n\t\tsock = SOCKET_I(inode);\n\t\tssp = sock->sk->sk_security;\n\t\ttsp = current_security();\n\t\t/*\n\t\t * If the receiving process can't write to the\n\t\t * passed socket or if the passed socket can't\n\t\t * write to the receiving process don't accept\n\t\t * the passed socket.\n\t\t */\n\t\trc = smk_access(tsp->smk_task, ssp->smk_out, MAY_WRITE, &ad);\n\t\trc = smk_bu_file(file, may, rc);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = smk_access(ssp->smk_in, tsp->smk_task, MAY_WRITE, &ad);\n\t\trc = smk_bu_file(file, may, rc);\n\t\treturn rc;\n\t}\n\t/*\n\t * This code relies on bitmasks.\n\t */\n\tif (file->f_mode & FMODE_READ)\n\t\tmay = MAY_READ;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tmay |= MAY_WRITE;\n\n\trc = smk_curacc(smk_of_inode(inode), may, &ad);\n\trc = smk_bu_file(file, may, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_file_send_sigiotask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1838-1863",
    "snippet": "static int smack_file_send_sigiotask(struct task_struct *tsk,\n\t\t\t\t     struct fown_struct *fown, int signum)\n{\n\tstruct smack_known *skp;\n\tstruct smack_known *tkp = smk_of_task(tsk->cred->security);\n\tstruct file *file;\n\tint rc;\n\tstruct smk_audit_info ad;\n\n\t/*\n\t * struct fown_struct is never outside the context of a struct file\n\t */\n\tfile = container_of(fown, struct file, f_owner);\n\n\t/* we don't log here as rc can be overriden */\n\tskp = file->f_security;\n\trc = smk_access(skp, tkp, MAY_DELIVER, NULL);\n\trc = smk_bu_note(\"sigiotask\", skp, tkp, MAY_DELIVER, rc);\n\tif (rc != 0 && has_capability(tsk, CAP_MAC_OVERRIDE))\n\t\trc = 0;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, tsk);\n\tsmack_log(skp->smk_known, tkp->smk_known, MAY_DELIVER, rc, &ad);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smack_log",
          "args": [
            "skp->smk_known",
            "tkp->smk_known",
            "MAY_DELIVER",
            "rc",
            "&ad"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "smack_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "391-394",
          "snippet": "void smack_log(char *subject_label, char *object_label, int request,\n               int result, struct smk_audit_info *ad)\n{\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid smack_log(char *subject_label, char *object_label, int request,\n               int result, struct smk_audit_info *ad)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_tsk",
          "args": [
            "&ad",
            "tsk"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_tsk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "477-480",
          "snippet": "static inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,\n\t\t\t\t\t struct task_struct *t)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,\n\t\t\t\t\t struct task_struct *t)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_TASK"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_capability",
          "args": [
            "tsk",
            "CAP_MAC_OVERRIDE"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_bu_note",
          "args": [
            "\"sigiotask\"",
            "skp",
            "tkp",
            "MAY_DELIVER",
            "rc"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "101-115",
          "snippet": "static int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_access",
          "args": [
            "skp",
            "tkp",
            "MAY_DELIVER",
            "NULL"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "120-209",
          "snippet": "int smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};",
            "struct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};",
            "struct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};",
            "struct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fown",
            "structfile",
            "f_owner"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_of_task",
          "args": [
            "tsk->cred->security"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "384-392",
          "snippet": "static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_file_send_sigiotask(struct task_struct *tsk,\n\t\t\t\t     struct fown_struct *fown, int signum)\n{\n\tstruct smack_known *skp;\n\tstruct smack_known *tkp = smk_of_task(tsk->cred->security);\n\tstruct file *file;\n\tint rc;\n\tstruct smk_audit_info ad;\n\n\t/*\n\t * struct fown_struct is never outside the context of a struct file\n\t */\n\tfile = container_of(fown, struct file, f_owner);\n\n\t/* we don't log here as rc can be overriden */\n\tskp = file->f_security;\n\trc = smk_access(skp, tkp, MAY_DELIVER, NULL);\n\trc = smk_bu_note(\"sigiotask\", skp, tkp, MAY_DELIVER, rc);\n\tif (rc != 0 && has_capability(tsk, CAP_MAC_OVERRIDE))\n\t\trc = 0;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, tsk);\n\tsmack_log(skp->smk_known, tkp->smk_known, MAY_DELIVER, rc, &ad);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_file_set_fowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1822-1825",
    "snippet": "static void smack_file_set_fowner(struct file *file)\n{\n\tfile->f_security = smk_of_current();\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_file_set_fowner(struct file *file)\n{\n\tfile->f_security = smk_of_current();\n}"
  },
  {
    "function_name": "smack_mmap_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1715-1815",
    "snippet": "static int smack_mmap_file(struct file *file,\n\t\t\t   unsigned long reqprot, unsigned long prot,\n\t\t\t   unsigned long flags)\n{\n\tstruct smack_known *skp;\n\tstruct smack_known *mkp;\n\tstruct smack_rule *srp;\n\tstruct task_smack *tsp;\n\tstruct smack_known *okp;\n\tstruct inode_smack *isp;\n\tstruct superblock_smack *sbsp;\n\tint may;\n\tint mmay;\n\tint tmay;\n\tint rc;\n\n\tif (file == NULL)\n\t\treturn 0;\n\n\tif (unlikely(IS_PRIVATE(file_inode(file))))\n\t\treturn 0;\n\n\tisp = file_inode(file)->i_security;\n\tif (isp->smk_mmap == NULL)\n\t\treturn 0;\n\tsbsp = file_inode(file)->i_sb->s_security;\n\tif (sbsp->smk_flags & SMK_SB_UNTRUSTED &&\n\t    isp->smk_mmap != sbsp->smk_root)\n\t\treturn -EACCES;\n\tmkp = isp->smk_mmap;\n\n\ttsp = current_security();\n\tskp = smk_of_current();\n\trc = 0;\n\n\trcu_read_lock();\n\t/*\n\t * For each Smack rule associated with the subject\n\t * label verify that the SMACK64MMAP also has access\n\t * to that rule's object label.\n\t */\n\tlist_for_each_entry_rcu(srp, &skp->smk_rules, list) {\n\t\tokp = srp->smk_object;\n\t\t/*\n\t\t * Matching labels always allows access.\n\t\t */\n\t\tif (mkp->smk_known == okp->smk_known)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If there is a matching local rule take\n\t\t * that into account as well.\n\t\t */\n\t\tmay = smk_access_entry(srp->smk_subject->smk_known,\n\t\t\t\t       okp->smk_known,\n\t\t\t\t       &tsp->smk_rules);\n\t\tif (may == -ENOENT)\n\t\t\tmay = srp->smk_access;\n\t\telse\n\t\t\tmay &= srp->smk_access;\n\t\t/*\n\t\t * If may is zero the SMACK64MMAP subject can't\n\t\t * possibly have less access.\n\t\t */\n\t\tif (may == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Fetch the global list entry.\n\t\t * If there isn't one a SMACK64MMAP subject\n\t\t * can't have as much access as current.\n\t\t */\n\t\tmmay = smk_access_entry(mkp->smk_known, okp->smk_known,\n\t\t\t\t\t&mkp->smk_rules);\n\t\tif (mmay == -ENOENT) {\n\t\t\trc = -EACCES;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If there is a local entry it modifies the\n\t\t * potential access, too.\n\t\t */\n\t\ttmay = smk_access_entry(mkp->smk_known, okp->smk_known,\n\t\t\t\t\t&tsp->smk_rules);\n\t\tif (tmay != -ENOENT)\n\t\t\tmmay &= tmay;\n\n\t\t/*\n\t\t * If there is any access available to current that is\n\t\t * not available to a SMACK64MMAP subject\n\t\t * deny access.\n\t\t */\n\t\tif ((may | mmay) != mmay) {\n\t\t\trc = -EACCES;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_access_entry",
          "args": [
            "mkp->smk_known",
            "okp->smk_known",
            "&tsp->smk_rules"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "85-105",
          "snippet": "int smk_access_entry(char *subject_label, char *object_label,\n\t\t\tstruct list_head *rule_list)\n{\n\tint may = -ENOENT;\n\tstruct smack_rule *srp;\n\n\tlist_for_each_entry_rcu(srp, rule_list, list) {\n\t\tif (srp->smk_object->smk_known == object_label &&\n\t\t    srp->smk_subject->smk_known == subject_label) {\n\t\t\tmay = srp->smk_access;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * MAY_WRITE implies MAY_LOCK.\n\t */\n\tif ((may & MAY_WRITE) == MAY_WRITE)\n\t\tmay |= MAY_LOCK;\n\treturn may;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_access_entry(char *subject_label, char *object_label,\n\t\t\tstruct list_head *rule_list)\n{\n\tint may = -ENOENT;\n\tstruct smack_rule *srp;\n\n\tlist_for_each_entry_rcu(srp, rule_list, list) {\n\t\tif (srp->smk_object->smk_known == object_label &&\n\t\t    srp->smk_subject->smk_known == subject_label) {\n\t\t\tmay = srp->smk_access;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * MAY_WRITE implies MAY_LOCK.\n\t */\n\tif ((may & MAY_WRITE) == MAY_WRITE)\n\t\tmay |= MAY_LOCK;\n\treturn may;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "srp",
            "&skp->smk_rules",
            "list"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_PRIVATE(file_inode(file))"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "file_inode(file)"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_mmap_file(struct file *file,\n\t\t\t   unsigned long reqprot, unsigned long prot,\n\t\t\t   unsigned long flags)\n{\n\tstruct smack_known *skp;\n\tstruct smack_known *mkp;\n\tstruct smack_rule *srp;\n\tstruct task_smack *tsp;\n\tstruct smack_known *okp;\n\tstruct inode_smack *isp;\n\tstruct superblock_smack *sbsp;\n\tint may;\n\tint mmay;\n\tint tmay;\n\tint rc;\n\n\tif (file == NULL)\n\t\treturn 0;\n\n\tif (unlikely(IS_PRIVATE(file_inode(file))))\n\t\treturn 0;\n\n\tisp = file_inode(file)->i_security;\n\tif (isp->smk_mmap == NULL)\n\t\treturn 0;\n\tsbsp = file_inode(file)->i_sb->s_security;\n\tif (sbsp->smk_flags & SMK_SB_UNTRUSTED &&\n\t    isp->smk_mmap != sbsp->smk_root)\n\t\treturn -EACCES;\n\tmkp = isp->smk_mmap;\n\n\ttsp = current_security();\n\tskp = smk_of_current();\n\trc = 0;\n\n\trcu_read_lock();\n\t/*\n\t * For each Smack rule associated with the subject\n\t * label verify that the SMACK64MMAP also has access\n\t * to that rule's object label.\n\t */\n\tlist_for_each_entry_rcu(srp, &skp->smk_rules, list) {\n\t\tokp = srp->smk_object;\n\t\t/*\n\t\t * Matching labels always allows access.\n\t\t */\n\t\tif (mkp->smk_known == okp->smk_known)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If there is a matching local rule take\n\t\t * that into account as well.\n\t\t */\n\t\tmay = smk_access_entry(srp->smk_subject->smk_known,\n\t\t\t\t       okp->smk_known,\n\t\t\t\t       &tsp->smk_rules);\n\t\tif (may == -ENOENT)\n\t\t\tmay = srp->smk_access;\n\t\telse\n\t\t\tmay &= srp->smk_access;\n\t\t/*\n\t\t * If may is zero the SMACK64MMAP subject can't\n\t\t * possibly have less access.\n\t\t */\n\t\tif (may == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Fetch the global list entry.\n\t\t * If there isn't one a SMACK64MMAP subject\n\t\t * can't have as much access as current.\n\t\t */\n\t\tmmay = smk_access_entry(mkp->smk_known, okp->smk_known,\n\t\t\t\t\t&mkp->smk_rules);\n\t\tif (mmay == -ENOENT) {\n\t\t\trc = -EACCES;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If there is a local entry it modifies the\n\t\t * potential access, too.\n\t\t */\n\t\ttmay = smk_access_entry(mkp->smk_known, okp->smk_known,\n\t\t\t\t\t&tsp->smk_rules);\n\t\tif (tmay != -ENOENT)\n\t\t\tmmay &= tmay;\n\n\t\t/*\n\t\t * If there is any access available to current that is\n\t\t * not available to a SMACK64MMAP subject\n\t\t * deny access.\n\t\t */\n\t\tif ((may | mmay) != mmay) {\n\t\t\trc = -EACCES;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_file_fcntl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1671-1703",
    "snippet": "static int smack_file_fcntl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct smk_audit_info ad;\n\tint rc = 0;\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tswitch (cmd) {\n\tcase F_GETLK:\n\t\tbreak;\n\tcase F_SETLK:\n\tcase F_SETLKW:\n\t\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\t\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\t\trc = smk_curacc(smk_of_inode(inode), MAY_LOCK, &ad);\n\t\trc = smk_bu_file(file, MAY_LOCK, rc);\n\t\tbreak;\n\tcase F_SETOWN:\n\tcase F_SETSIG:\n\t\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\t\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\t\trc = smk_curacc(smk_of_inode(inode), MAY_WRITE, &ad);\n\t\trc = smk_bu_file(file, MAY_WRITE, rc);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_file",
          "args": [
            "file",
            "MAY_WRITE",
            "rc"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "195-218",
          "snippet": "static int smk_bu_file(struct file *file, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_file(struct file *file, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "smk_of_inode(inode)",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "inode"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path",
          "args": [
            "&ad",
            "file->f_path"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "493-496",
          "snippet": "static inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_PATH"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_PRIVATE(inode)"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "inode"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_file_fcntl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct smk_audit_info ad;\n\tint rc = 0;\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tswitch (cmd) {\n\tcase F_GETLK:\n\t\tbreak;\n\tcase F_SETLK:\n\tcase F_SETLKW:\n\t\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\t\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\t\trc = smk_curacc(smk_of_inode(inode), MAY_LOCK, &ad);\n\t\trc = smk_bu_file(file, MAY_LOCK, rc);\n\t\tbreak;\n\tcase F_SETOWN:\n\tcase F_SETSIG:\n\t\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\t\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\t\trc = smk_curacc(smk_of_inode(inode), MAY_WRITE, &ad);\n\t\trc = smk_bu_file(file, MAY_WRITE, rc);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_file_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1643-1657",
    "snippet": "static int smack_file_lock(struct file *file, unsigned int cmd)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\trc = smk_curacc(smk_of_inode(inode), MAY_LOCK, &ad);\n\trc = smk_bu_file(file, MAY_LOCK, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_file",
          "args": [
            "file",
            "MAY_LOCK",
            "rc"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "195-218",
          "snippet": "static int smk_bu_file(struct file *file, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_file(struct file *file, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "smk_of_inode(inode)",
            "MAY_LOCK",
            "&ad"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "inode"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path",
          "args": [
            "&ad",
            "file->f_path"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "493-496",
          "snippet": "static inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_PATH"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_PRIVATE(inode)"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "inode"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_file_lock(struct file *file, unsigned int cmd)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\trc = smk_curacc(smk_of_inode(inode), MAY_LOCK, &ad);\n\trc = smk_bu_file(file, MAY_LOCK, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_file_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1610-1634",
    "snippet": "static int smack_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tint rc = 0;\n\tstruct smk_audit_info ad;\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\n\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\trc = smk_curacc(smk_of_inode(inode), MAY_WRITE, &ad);\n\t\trc = smk_bu_file(file, MAY_WRITE, rc);\n\t}\n\n\tif (rc == 0 && (_IOC_DIR(cmd) & _IOC_READ)) {\n\t\trc = smk_curacc(smk_of_inode(inode), MAY_READ, &ad);\n\t\trc = smk_bu_file(file, MAY_READ, rc);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_file",
          "args": [
            "file",
            "MAY_READ",
            "rc"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "195-218",
          "snippet": "static int smk_bu_file(struct file *file, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_file(struct file *file, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "smk_of_inode(inode)",
            "MAY_READ",
            "&ad"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "inode"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_IOC_DIR",
          "args": [
            "cmd"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_IOC_DIR",
          "args": [
            "cmd"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path",
          "args": [
            "&ad",
            "file->f_path"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "493-496",
          "snippet": "static inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_PATH"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_PRIVATE(inode)"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "inode"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tint rc = 0;\n\tstruct smk_audit_info ad;\n\tstruct inode *inode = file_inode(file);\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, file->f_path);\n\n\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\trc = smk_curacc(smk_of_inode(inode), MAY_WRITE, &ad);\n\t\trc = smk_bu_file(file, MAY_WRITE, rc);\n\t}\n\n\tif (rc == 0 && (_IOC_DIR(cmd) & _IOC_READ)) {\n\t\trc = smk_curacc(smk_of_inode(inode), MAY_READ, &ad);\n\t\trc = smk_bu_file(file, MAY_READ, rc);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_file_free_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1595-1598",
    "snippet": "static void smack_file_free_security(struct file *file)\n{\n\tfile->f_security = NULL;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_file_free_security(struct file *file)\n{\n\tfile->f_security = NULL;\n}"
  },
  {
    "function_name": "smack_file_alloc_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1580-1586",
    "snippet": "static int smack_file_alloc_security(struct file *file)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tfile->f_security = skp;\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_file_alloc_security(struct file *file)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tfile->f_security = skp;\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_inode_getsecid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1546-1551",
    "snippet": "static void smack_inode_getsecid(struct inode *inode, u32 *secid)\n{\n\tstruct inode_smack *isp = inode->i_security;\n\n\t*secid = isp->smk_inode->smk_secid;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_inode_getsecid(struct inode *inode, u32 *secid)\n{\n\tstruct inode_smack *isp = inode->i_security;\n\n\t*secid = isp->smk_inode->smk_secid;\n}"
  },
  {
    "function_name": "smack_inode_listsecurity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1530-1539",
    "snippet": "static int smack_inode_listsecurity(struct inode *inode, char *buffer,\n\t\t\t\t    size_t buffer_size)\n{\n\tint len = sizeof(XATTR_NAME_SMACK);\n\n\tif (buffer != NULL && len <= buffer_size)\n\t\tmemcpy(buffer, XATTR_NAME_SMACK, len);\n\n\treturn len;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "XATTR_NAME_SMACK",
            "len"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_listsecurity(struct inode *inode, char *buffer,\n\t\t\t\t    size_t buffer_size)\n{\n\tint len = sizeof(XATTR_NAME_SMACK);\n\n\tif (buffer != NULL && len <= buffer_size)\n\t\tmemcpy(buffer, XATTR_NAME_SMACK, len);\n\n\treturn len;\n}"
  },
  {
    "function_name": "smack_inode_getsecurity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1480-1521",
    "snippet": "static int smack_inode_getsecurity(struct inode *inode,\n\t\t\t\t   const char *name, void **buffer,\n\t\t\t\t   bool alloc)\n{\n\tstruct socket_smack *ssp;\n\tstruct socket *sock;\n\tstruct super_block *sbp;\n\tstruct inode *ip = (struct inode *)inode;\n\tstruct smack_known *isp;\n\n\tif (strcmp(name, XATTR_SMACK_SUFFIX) == 0)\n\t\tisp = smk_of_inode(inode);\n\telse {\n\t\t/*\n\t\t * The rest of the Smack xattrs are only on sockets.\n\t\t */\n\t\tsbp = ip->i_sb;\n\t\tif (sbp->s_magic != SOCKFS_MAGIC)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tsock = SOCKET_I(ip);\n\t\tif (sock == NULL || sock->sk == NULL)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tssp = sock->sk->sk_security;\n\n\t\tif (strcmp(name, XATTR_SMACK_IPIN) == 0)\n\t\t\tisp = ssp->smk_in;\n\t\telse if (strcmp(name, XATTR_SMACK_IPOUT) == 0)\n\t\t\tisp = ssp->smk_out;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (alloc) {\n\t\t*buffer = kstrdup(isp->smk_known, GFP_KERNEL);\n\t\tif (*buffer == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn strlen(isp->smk_known);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "isp->smk_known"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "isp->smk_known",
            "GFP_KERNEL"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_SMACK_IPOUT"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_SMACK_IPIN"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOCKET_I",
          "args": [
            "ip"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "inode"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_SMACK_SUFFIX"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_getsecurity(struct inode *inode,\n\t\t\t\t   const char *name, void **buffer,\n\t\t\t\t   bool alloc)\n{\n\tstruct socket_smack *ssp;\n\tstruct socket *sock;\n\tstruct super_block *sbp;\n\tstruct inode *ip = (struct inode *)inode;\n\tstruct smack_known *isp;\n\n\tif (strcmp(name, XATTR_SMACK_SUFFIX) == 0)\n\t\tisp = smk_of_inode(inode);\n\telse {\n\t\t/*\n\t\t * The rest of the Smack xattrs are only on sockets.\n\t\t */\n\t\tsbp = ip->i_sb;\n\t\tif (sbp->s_magic != SOCKFS_MAGIC)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tsock = SOCKET_I(ip);\n\t\tif (sock == NULL || sock->sk == NULL)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tssp = sock->sk->sk_security;\n\n\t\tif (strcmp(name, XATTR_SMACK_IPIN) == 0)\n\t\t\tisp = ssp->smk_in;\n\t\telse if (strcmp(name, XATTR_SMACK_IPOUT) == 0)\n\t\t\tisp = ssp->smk_out;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (alloc) {\n\t\t*buffer = kstrdup(isp->smk_known, GFP_KERNEL);\n\t\tif (*buffer == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn strlen(isp->smk_known);\n}"
  },
  {
    "function_name": "smack_inode_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1422-1469",
    "snippet": "static int smack_inode_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode_smack *isp;\n\tstruct smk_audit_info ad;\n\tint rc = 0;\n\n\tif (strcmp(name, XATTR_NAME_SMACK) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKIPIN) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKIPOUT) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKEXEC) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKMMAP) == 0) {\n\t\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\t\trc = -EPERM;\n\t} else\n\t\trc = cap_inode_removexattr(dentry, name);\n\n\tif (rc != 0)\n\t\treturn rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tisp = d_backing_inode(dentry)->i_security;\n\t/*\n\t * Don't do anything special for these.\n\t *\tXATTR_NAME_SMACKIPIN\n\t *\tXATTR_NAME_SMACKIPOUT\n\t */\n\tif (strcmp(name, XATTR_NAME_SMACK) == 0) {\n\t\tstruct super_block *sbp = dentry->d_sb;\n\t\tstruct superblock_smack *sbsp = sbp->s_security;\n\n\t\tisp->smk_inode = sbsp->smk_default;\n\t} else if (strcmp(name, XATTR_NAME_SMACKEXEC) == 0)\n\t\tisp->smk_task = NULL;\n\telse if (strcmp(name, XATTR_NAME_SMACKMMAP) == 0)\n\t\tisp->smk_mmap = NULL;\n\telse if (strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0)\n\t\tisp->smk_flags &= ~SMK_INODE_TRANSMUTE;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKTRANSMUTE"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKMMAP"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKEXEC"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACK"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_bu_inode",
          "args": [
            "d_backing_inode(dentry)",
            "MAY_WRITE",
            "rc"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "165-189",
          "snippet": "static int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "smk_of_inode(d_backing_inode(dentry))",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "d_backing_inode(dentry)"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path_dentry",
          "args": [
            "&ad",
            "dentry"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "481-484",
          "snippet": "static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_DENTRY"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_inode_removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "cap_inode_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "951-971",
          "snippet": "int cap_inode_removexattr(struct dentry *dentry, const char *name)\n{\n\t/* Ignore non-security xattrs */\n\tif (strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tsizeof(XATTR_SECURITY_PREFIX) - 1) != 0)\n\t\treturn 0;\n\n\tif (strcmp(name, XATTR_NAME_CAPS) == 0) {\n\t\t/* security.capability gets namespaced */\n\t\tstruct inode *inode = d_backing_inode(dentry);\n\t\tif (!inode)\n\t\t\treturn -EINVAL;\n\t\tif (!capable_wrt_inode_uidgid(inode, CAP_SETFCAP))\n\t\t\treturn -EPERM;\n\t\treturn 0;\n\t}\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_inode_removexattr(struct dentry *dentry, const char *name)\n{\n\t/* Ignore non-security xattrs */\n\tif (strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tsizeof(XATTR_SECURITY_PREFIX) - 1) != 0)\n\t\treturn 0;\n\n\tif (strcmp(name, XATTR_NAME_CAPS) == 0) {\n\t\t/* security.capability gets namespaced */\n\t\tstruct inode *inode = d_backing_inode(dentry);\n\t\tif (!inode)\n\t\t\treturn -EINVAL;\n\t\tif (!capable_wrt_inode_uidgid(inode, CAP_SETFCAP))\n\t\t\treturn -EPERM;\n\t\treturn 0;\n\t}\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKMMAP"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKTRANSMUTE"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKEXEC"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKIPOUT"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKIPIN"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACK"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode_smack *isp;\n\tstruct smk_audit_info ad;\n\tint rc = 0;\n\n\tif (strcmp(name, XATTR_NAME_SMACK) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKIPIN) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKIPOUT) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKEXEC) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKMMAP) == 0) {\n\t\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\t\trc = -EPERM;\n\t} else\n\t\trc = cap_inode_removexattr(dentry, name);\n\n\tif (rc != 0)\n\t\treturn rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tisp = d_backing_inode(dentry)->i_security;\n\t/*\n\t * Don't do anything special for these.\n\t *\tXATTR_NAME_SMACKIPIN\n\t *\tXATTR_NAME_SMACKIPOUT\n\t */\n\tif (strcmp(name, XATTR_NAME_SMACK) == 0) {\n\t\tstruct super_block *sbp = dentry->d_sb;\n\t\tstruct superblock_smack *sbsp = sbp->s_security;\n\n\t\tisp->smk_inode = sbsp->smk_default;\n\t} else if (strcmp(name, XATTR_NAME_SMACKEXEC) == 0)\n\t\tisp->smk_task = NULL;\n\telse if (strcmp(name, XATTR_NAME_SMACKMMAP) == 0)\n\t\tisp->smk_mmap = NULL;\n\telse if (strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0)\n\t\tisp->smk_flags &= ~SMK_INODE_TRANSMUTE;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_inode_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1400-1411",
    "snippet": "static int smack_inode_getxattr(struct dentry *dentry, const char *name)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_READ, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_READ, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_inode",
          "args": [
            "d_backing_inode(dentry)",
            "MAY_READ",
            "rc"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "165-189",
          "snippet": "static int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "smk_of_inode(d_backing_inode(dentry))",
            "MAY_READ",
            "&ad"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "d_backing_inode(dentry)"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path_dentry",
          "args": [
            "&ad",
            "dentry"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "481-484",
          "snippet": "static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_DENTRY"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_getxattr(struct dentry *dentry, const char *name)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_READ, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_READ, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_inode_post_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1365-1391",
    "snippet": "static void smack_inode_post_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\t      const void *value, size_t size, int flags)\n{\n\tstruct smack_known *skp;\n\tstruct inode_smack *isp = d_backing_inode(dentry)->i_security;\n\n\tif (strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0) {\n\t\tisp->smk_flags |= SMK_INODE_TRANSMUTE;\n\t\treturn;\n\t}\n\n\tif (strcmp(name, XATTR_NAME_SMACK) == 0) {\n\t\tskp = smk_import_entry(value, size);\n\t\tif (!IS_ERR(skp))\n\t\t\tisp->smk_inode = skp;\n\t} else if (strcmp(name, XATTR_NAME_SMACKEXEC) == 0) {\n\t\tskp = smk_import_entry(value, size);\n\t\tif (!IS_ERR(skp))\n\t\t\tisp->smk_task = skp;\n\t} else if (strcmp(name, XATTR_NAME_SMACKMMAP) == 0) {\n\t\tskp = smk_import_entry(value, size);\n\t\tif (!IS_ERR(skp))\n\t\t\tisp->smk_mmap = skp;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "value",
            "size"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKMMAP"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKEXEC"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACK"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKTRANSMUTE"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_inode_post_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\t      const void *value, size_t size, int flags)\n{\n\tstruct smack_known *skp;\n\tstruct inode_smack *isp = d_backing_inode(dentry)->i_security;\n\n\tif (strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0) {\n\t\tisp->smk_flags |= SMK_INODE_TRANSMUTE;\n\t\treturn;\n\t}\n\n\tif (strcmp(name, XATTR_NAME_SMACK) == 0) {\n\t\tskp = smk_import_entry(value, size);\n\t\tif (!IS_ERR(skp))\n\t\t\tisp->smk_inode = skp;\n\t} else if (strcmp(name, XATTR_NAME_SMACKEXEC) == 0) {\n\t\tskp = smk_import_entry(value, size);\n\t\tif (!IS_ERR(skp))\n\t\t\tisp->smk_task = skp;\n\t} else if (strcmp(name, XATTR_NAME_SMACKMMAP) == 0) {\n\t\tskp = smk_import_entry(value, size);\n\t\tif (!IS_ERR(skp))\n\t\t\tisp->smk_mmap = skp;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "smack_inode_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1300-1352",
    "snippet": "static int smack_inode_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\tconst void *value, size_t size, int flags)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp;\n\tint check_priv = 0;\n\tint check_import = 0;\n\tint check_star = 0;\n\tint rc = 0;\n\n\t/*\n\t * Check label validity here so import won't fail in post_setxattr\n\t */\n\tif (strcmp(name, XATTR_NAME_SMACK) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKIPIN) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKIPOUT) == 0) {\n\t\tcheck_priv = 1;\n\t\tcheck_import = 1;\n\t} else if (strcmp(name, XATTR_NAME_SMACKEXEC) == 0 ||\n\t\t   strcmp(name, XATTR_NAME_SMACKMMAP) == 0) {\n\t\tcheck_priv = 1;\n\t\tcheck_import = 1;\n\t\tcheck_star = 1;\n\t} else if (strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0) {\n\t\tcheck_priv = 1;\n\t\tif (size != TRANS_TRUE_SIZE ||\n\t\t    strncmp(value, TRANS_TRUE, TRANS_TRUE_SIZE) != 0)\n\t\t\trc = -EINVAL;\n\t} else\n\t\trc = cap_inode_setxattr(dentry, name, value, size, flags);\n\n\tif (check_priv && !smack_privileged(CAP_MAC_ADMIN))\n\t\trc = -EPERM;\n\n\tif (rc == 0 && check_import) {\n\t\tskp = size ? smk_import_entry(value, size) : NULL;\n\t\tif (IS_ERR(skp))\n\t\t\trc = PTR_ERR(skp);\n\t\telse if (skp == NULL || (check_star &&\n\t\t    (skp == &smack_known_star || skp == &smack_known_web)))\n\t\t\trc = -EINVAL;\n\t}\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\tif (rc == 0) {\n\t\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\t\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [
      "#define TRANS_TRUE_SIZE\t4",
      "#define TRANS_TRUE\t\"TRUE\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_inode",
          "args": [
            "d_backing_inode(dentry)",
            "MAY_WRITE",
            "rc"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "165-189",
          "snippet": "static int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "smk_of_inode(d_backing_inode(dentry))",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "d_backing_inode(dentry)"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path_dentry",
          "args": [
            "&ad",
            "dentry"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "481-484",
          "snippet": "static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_DENTRY"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "value",
            "size"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_inode_setxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "cap_inode_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "920-938",
          "snippet": "int cap_inode_setxattr(struct dentry *dentry, const char *name,\n\t\t       const void *value, size_t size, int flags)\n{\n\t/* Ignore non-security xattrs */\n\tif (strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tsizeof(XATTR_SECURITY_PREFIX) - 1) != 0)\n\t\treturn 0;\n\n\t/*\n\t * For XATTR_NAME_CAPS the check will be done in\n\t * cap_convert_nscap(), called by setxattr()\n\t */\n\tif (strcmp(name, XATTR_NAME_CAPS) == 0)\n\t\treturn 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nint cap_inode_setxattr(struct dentry *dentry, const char *name,\n\t\t       const void *value, size_t size, int flags)\n{\n\t/* Ignore non-security xattrs */\n\tif (strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\tsizeof(XATTR_SECURITY_PREFIX) - 1) != 0)\n\t\treturn 0;\n\n\t/*\n\t * For XATTR_NAME_CAPS the check will be done in\n\t * cap_convert_nscap(), called by setxattr()\n\t */\n\tif (strcmp(name, XATTR_NAME_CAPS) == 0)\n\t\treturn 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "value",
            "TRANS_TRUE",
            "TRANS_TRUE_SIZE"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKTRANSMUTE"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKMMAP"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKEXEC"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKIPOUT"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACKIPIN"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "XATTR_NAME_SMACK"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\n#define TRANS_TRUE_SIZE\t4\n#define TRANS_TRUE\t\"TRUE\"\n\nstatic int smack_inode_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\tconst void *value, size_t size, int flags)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp;\n\tint check_priv = 0;\n\tint check_import = 0;\n\tint check_star = 0;\n\tint rc = 0;\n\n\t/*\n\t * Check label validity here so import won't fail in post_setxattr\n\t */\n\tif (strcmp(name, XATTR_NAME_SMACK) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKIPIN) == 0 ||\n\t    strcmp(name, XATTR_NAME_SMACKIPOUT) == 0) {\n\t\tcheck_priv = 1;\n\t\tcheck_import = 1;\n\t} else if (strcmp(name, XATTR_NAME_SMACKEXEC) == 0 ||\n\t\t   strcmp(name, XATTR_NAME_SMACKMMAP) == 0) {\n\t\tcheck_priv = 1;\n\t\tcheck_import = 1;\n\t\tcheck_star = 1;\n\t} else if (strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0) {\n\t\tcheck_priv = 1;\n\t\tif (size != TRANS_TRUE_SIZE ||\n\t\t    strncmp(value, TRANS_TRUE, TRANS_TRUE_SIZE) != 0)\n\t\t\trc = -EINVAL;\n\t} else\n\t\trc = cap_inode_setxattr(dentry, name, value, size, flags);\n\n\tif (check_priv && !smack_privileged(CAP_MAC_ADMIN))\n\t\trc = -EPERM;\n\n\tif (rc == 0 && check_import) {\n\t\tskp = size ? smk_import_entry(value, size) : NULL;\n\t\tif (IS_ERR(skp))\n\t\t\trc = PTR_ERR(skp);\n\t\telse if (skp == NULL || (check_star &&\n\t\t    (skp == &smack_known_star || skp == &smack_known_web)))\n\t\t\trc = -EINVAL;\n\t}\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\tif (rc == 0) {\n\t\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\t\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_inode_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1275-1286",
    "snippet": "static int smack_inode_getattr(const struct path *path)\n{\n\tstruct smk_audit_info ad;\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, *path);\n\trc = smk_curacc(smk_of_inode(inode), MAY_READ, &ad);\n\trc = smk_bu_inode(inode, MAY_READ, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_inode",
          "args": [
            "inode",
            "MAY_READ",
            "rc"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "165-189",
          "snippet": "static int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "smk_of_inode(inode)",
            "MAY_READ",
            "&ad"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "inode"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path",
          "args": [
            "&ad",
            "*path"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "493-496",
          "snippet": "static inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path(struct smk_audit_info *a,\n\t\t\t\t\t     struct path p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_PATH"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "path->dentry"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_getattr(const struct path *path)\n{\n\tstruct smk_audit_info ad;\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_PATH);\n\tsmk_ad_setfield_u_fs_path(&ad, *path);\n\trc = smk_curacc(smk_of_inode(inode), MAY_READ, &ad);\n\trc = smk_bu_inode(inode, MAY_READ, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_inode_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1250-1266",
    "snippet": "static int smack_inode_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\t/*\n\t * Need to allow for clearing the setuid bit.\n\t */\n\tif (iattr->ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_inode",
          "args": [
            "d_backing_inode(dentry)",
            "MAY_WRITE",
            "rc"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "165-189",
          "snippet": "static int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "smk_of_inode(d_backing_inode(dentry))",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "d_backing_inode(dentry)"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path_dentry",
          "args": [
            "&ad",
            "dentry"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "481-484",
          "snippet": "static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_DENTRY"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\t/*\n\t * Need to allow for clearing the setuid bit.\n\t */\n\tif (iattr->ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_inode_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1214-1241",
    "snippet": "static int smack_inode_permission(struct inode *inode, int mask)\n{\n\tstruct superblock_smack *sbsp = inode->i_sb->s_security;\n\tstruct smk_audit_info ad;\n\tint no_block = mask & MAY_NOT_BLOCK;\n\tint rc;\n\n\tmask &= (MAY_READ|MAY_WRITE|MAY_EXEC|MAY_APPEND);\n\t/*\n\t * No permission to check. Existence test. Yup, it's there.\n\t */\n\tif (mask == 0)\n\t\treturn 0;\n\n\tif (sbsp->smk_flags & SMK_SB_UNTRUSTED) {\n\t\tif (smk_of_inode(inode) != sbsp->smk_root)\n\t\t\treturn -EACCES;\n\t}\n\n\t/* May be droppable after audit */\n\tif (no_block)\n\t\treturn -ECHILD;\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_INODE);\n\tsmk_ad_setfield_u_fs_inode(&ad, inode);\n\trc = smk_curacc(smk_of_inode(inode), mask, &ad);\n\trc = smk_bu_inode(inode, mask, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_inode",
          "args": [
            "inode",
            "mask",
            "rc"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "165-189",
          "snippet": "static int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "smk_of_inode(inode)",
            "mask",
            "&ad"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "inode"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_inode",
          "args": [
            "&ad",
            "inode"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "489-492",
          "snippet": "static inline void smk_ad_setfield_u_fs_inode(struct smk_audit_info *a,\n\t\t\t\t\t      struct inode *i)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_inode(struct smk_audit_info *a,\n\t\t\t\t\t      struct inode *i)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_INODE"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_permission(struct inode *inode, int mask)\n{\n\tstruct superblock_smack *sbsp = inode->i_sb->s_security;\n\tstruct smk_audit_info ad;\n\tint no_block = mask & MAY_NOT_BLOCK;\n\tint rc;\n\n\tmask &= (MAY_READ|MAY_WRITE|MAY_EXEC|MAY_APPEND);\n\t/*\n\t * No permission to check. Existence test. Yup, it's there.\n\t */\n\tif (mask == 0)\n\t\treturn 0;\n\n\tif (sbsp->smk_flags & SMK_SB_UNTRUSTED) {\n\t\tif (smk_of_inode(inode) != sbsp->smk_root)\n\t\t\treturn -EACCES;\n\t}\n\n\t/* May be droppable after audit */\n\tif (no_block)\n\t\treturn -ECHILD;\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_INODE);\n\tsmk_ad_setfield_u_fs_inode(&ad, inode);\n\trc = smk_curacc(smk_of_inode(inode), mask, &ad);\n\trc = smk_bu_inode(inode, mask, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_inode_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1180-1203",
    "snippet": "static int smack_inode_rename(struct inode *old_inode,\n\t\t\t      struct dentry *old_dentry,\n\t\t\t      struct inode *new_inode,\n\t\t\t      struct dentry *new_dentry)\n{\n\tint rc;\n\tstruct smack_known *isp;\n\tstruct smk_audit_info ad;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, old_dentry);\n\n\tisp = smk_of_inode(d_backing_inode(old_dentry));\n\trc = smk_curacc(isp, MAY_READWRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(old_dentry), MAY_READWRITE, rc);\n\n\tif (rc == 0 && d_is_positive(new_dentry)) {\n\t\tisp = smk_of_inode(d_backing_inode(new_dentry));\n\t\tsmk_ad_setfield_u_fs_path_dentry(&ad, new_dentry);\n\t\trc = smk_curacc(isp, MAY_READWRITE, &ad);\n\t\trc = smk_bu_inode(d_backing_inode(new_dentry), MAY_READWRITE, rc);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_inode",
          "args": [
            "d_backing_inode(new_dentry)",
            "MAY_READWRITE",
            "rc"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "165-189",
          "snippet": "static int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "new_dentry"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "isp",
            "MAY_READWRITE",
            "&ad"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path_dentry",
          "args": [
            "&ad",
            "new_dentry"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "481-484",
          "snippet": "static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "d_backing_inode(new_dentry)"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "new_dentry"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_positive",
          "args": [
            "new_dentry"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "old_dentry"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "old_dentry"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_DENTRY"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_rename(struct inode *old_inode,\n\t\t\t      struct dentry *old_dentry,\n\t\t\t      struct inode *new_inode,\n\t\t\t      struct dentry *new_dentry)\n{\n\tint rc;\n\tstruct smack_known *isp;\n\tstruct smk_audit_info ad;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, old_dentry);\n\n\tisp = smk_of_inode(d_backing_inode(old_dentry));\n\trc = smk_curacc(isp, MAY_READWRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(old_dentry), MAY_READWRITE, rc);\n\n\tif (rc == 0 && d_is_positive(new_dentry)) {\n\t\tisp = smk_of_inode(d_backing_inode(new_dentry));\n\t\tsmk_ad_setfield_u_fs_path_dentry(&ad, new_dentry);\n\t\trc = smk_curacc(isp, MAY_READWRITE, &ad);\n\t\trc = smk_bu_inode(d_backing_inode(new_dentry), MAY_READWRITE, rc);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_inode_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1142-1166",
    "snippet": "static int smack_inode_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\t/*\n\t * You need write access to the thing you're removing\n\t */\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\tif (rc == 0) {\n\t\t/*\n\t\t * You also need write access to the containing directory\n\t\t */\n\t\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_INODE);\n\t\tsmk_ad_setfield_u_fs_inode(&ad, dir);\n\t\trc = smk_curacc(smk_of_inode(dir), MAY_WRITE, &ad);\n\t\trc = smk_bu_inode(dir, MAY_WRITE, rc);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_inode",
          "args": [
            "dir",
            "MAY_WRITE",
            "rc"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "165-189",
          "snippet": "static int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "smk_of_inode(dir)",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "dir"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_inode",
          "args": [
            "&ad",
            "dir"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "489-492",
          "snippet": "static inline void smk_ad_setfield_u_fs_inode(struct smk_audit_info *a,\n\t\t\t\t\t      struct inode *i)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_inode(struct smk_audit_info *a,\n\t\t\t\t\t      struct inode *i)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_INODE"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path_dentry",
          "args": [
            "&ad",
            "dentry"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "481-484",
          "snippet": "static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\t/*\n\t * You need write access to the thing you're removing\n\t */\n\trc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);\n\tif (rc == 0) {\n\t\t/*\n\t\t * You also need write access to the containing directory\n\t\t */\n\t\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_INODE);\n\t\tsmk_ad_setfield_u_fs_inode(&ad, dir);\n\t\trc = smk_curacc(smk_of_inode(dir), MAY_WRITE, &ad);\n\t\trc = smk_bu_inode(dir, MAY_WRITE, rc);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_inode_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1108-1132",
    "snippet": "static int smack_inode_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *ip = d_backing_inode(dentry);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\t/*\n\t * You need write access to the thing you're unlinking\n\t */\n\trc = smk_curacc(smk_of_inode(ip), MAY_WRITE, &ad);\n\trc = smk_bu_inode(ip, MAY_WRITE, rc);\n\tif (rc == 0) {\n\t\t/*\n\t\t * You also need write access to the containing directory\n\t\t */\n\t\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_INODE);\n\t\tsmk_ad_setfield_u_fs_inode(&ad, dir);\n\t\trc = smk_curacc(smk_of_inode(dir), MAY_WRITE, &ad);\n\t\trc = smk_bu_inode(dir, MAY_WRITE, rc);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_inode",
          "args": [
            "dir",
            "MAY_WRITE",
            "rc"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "165-189",
          "snippet": "static int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "smk_of_inode(dir)",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "dir"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_inode",
          "args": [
            "&ad",
            "dir"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "489-492",
          "snippet": "static inline void smk_ad_setfield_u_fs_inode(struct smk_audit_info *a,\n\t\t\t\t\t      struct inode *i)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_inode(struct smk_audit_info *a,\n\t\t\t\t\t      struct inode *i)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_INODE"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path_dentry",
          "args": [
            "&ad",
            "dentry"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "481-484",
          "snippet": "static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *ip = d_backing_inode(dentry);\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\t/*\n\t * You need write access to the thing you're unlinking\n\t */\n\trc = smk_curacc(smk_of_inode(ip), MAY_WRITE, &ad);\n\trc = smk_bu_inode(ip, MAY_WRITE, rc);\n\tif (rc == 0) {\n\t\t/*\n\t\t * You also need write access to the containing directory\n\t\t */\n\t\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_INODE);\n\t\tsmk_ad_setfield_u_fs_inode(&ad, dir);\n\t\trc = smk_curacc(smk_of_inode(dir), MAY_WRITE, &ad);\n\t\trc = smk_bu_inode(dir, MAY_WRITE, rc);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_inode_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1076-1098",
    "snippet": "static int smack_inode_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t    struct dentry *new_dentry)\n{\n\tstruct smack_known *isp;\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, old_dentry);\n\n\tisp = smk_of_inode(d_backing_inode(old_dentry));\n\trc = smk_curacc(isp, MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(old_dentry), MAY_WRITE, rc);\n\n\tif (rc == 0 && d_is_positive(new_dentry)) {\n\t\tisp = smk_of_inode(d_backing_inode(new_dentry));\n\t\tsmk_ad_setfield_u_fs_path_dentry(&ad, new_dentry);\n\t\trc = smk_curacc(isp, MAY_WRITE, &ad);\n\t\trc = smk_bu_inode(d_backing_inode(new_dentry), MAY_WRITE, rc);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_inode",
          "args": [
            "d_backing_inode(new_dentry)",
            "MAY_WRITE",
            "rc"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "165-189",
          "snippet": "static int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "new_dentry"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "isp",
            "MAY_WRITE",
            "&ad"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path_dentry",
          "args": [
            "&ad",
            "new_dentry"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "481-484",
          "snippet": "static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "d_backing_inode(new_dentry)"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "new_dentry"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_positive",
          "args": [
            "new_dentry"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "old_dentry"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "old_dentry"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_DENTRY"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_link(struct dentry *old_dentry, struct inode *dir,\n\t\t\t    struct dentry *new_dentry)\n{\n\tstruct smack_known *isp;\n\tstruct smk_audit_info ad;\n\tint rc;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, old_dentry);\n\n\tisp = smk_of_inode(d_backing_inode(old_dentry));\n\trc = smk_curacc(isp, MAY_WRITE, &ad);\n\trc = smk_bu_inode(d_backing_inode(old_dentry), MAY_WRITE, rc);\n\n\tif (rc == 0 && d_is_positive(new_dentry)) {\n\t\tisp = smk_of_inode(d_backing_inode(new_dentry));\n\t\tsmk_ad_setfield_u_fs_path_dentry(&ad, new_dentry);\n\t\trc = smk_curacc(isp, MAY_WRITE, &ad);\n\t\trc = smk_bu_inode(d_backing_inode(new_dentry), MAY_WRITE, rc);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_inode_init_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1027-1066",
    "snippet": "static int smack_inode_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\t     const struct qstr *qstr, const char **name,\n\t\t\t\t     void **value, size_t *len)\n{\n\tstruct inode_smack *issp = inode->i_security;\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known *isp = smk_of_inode(inode);\n\tstruct smack_known *dsp = smk_of_inode(dir);\n\tint may;\n\n\tif (name)\n\t\t*name = XATTR_SMACK_SUFFIX;\n\n\tif (value && len) {\n\t\trcu_read_lock();\n\t\tmay = smk_access_entry(skp->smk_known, dsp->smk_known,\n\t\t\t\t       &skp->smk_rules);\n\t\trcu_read_unlock();\n\n\t\t/*\n\t\t * If the access rule allows transmutation and\n\t\t * the directory requests transmutation then\n\t\t * by all means transmute.\n\t\t * Mark the inode as changed.\n\t\t */\n\t\tif (may > 0 && ((may & MAY_TRANSMUTE) != 0) &&\n\t\t    smk_inode_transmutable(dir)) {\n\t\t\tisp = dsp;\n\t\t\tissp->smk_flags |= SMK_INODE_CHANGED;\n\t\t}\n\n\t\t*value = kstrdup(isp->smk_known, GFP_NOFS);\n\t\tif (*value == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\t*len = strlen(isp->smk_known);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "isp->smk_known"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "isp->smk_known",
            "GFP_NOFS"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_inode_transmutable",
          "args": [
            "dir"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "smk_inode_transmutable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "361-365",
          "snippet": "static inline int smk_inode_transmutable(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn (sip->smk_flags & SMK_INODE_TRANSMUTE) != 0;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define\tSMK_INODE_TRANSMUTE\t0x02\t/* directory is transmuting */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\n#define\tSMK_INODE_TRANSMUTE\t0x02\t/* directory is transmuting */\n\nstatic inline int smk_inode_transmutable(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn (sip->smk_flags & SMK_INODE_TRANSMUTE) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_access_entry",
          "args": [
            "skp->smk_known",
            "dsp->smk_known",
            "&skp->smk_rules"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "85-105",
          "snippet": "int smk_access_entry(char *subject_label, char *object_label,\n\t\t\tstruct list_head *rule_list)\n{\n\tint may = -ENOENT;\n\tstruct smack_rule *srp;\n\n\tlist_for_each_entry_rcu(srp, rule_list, list) {\n\t\tif (srp->smk_object->smk_known == object_label &&\n\t\t    srp->smk_subject->smk_known == subject_label) {\n\t\t\tmay = srp->smk_access;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * MAY_WRITE implies MAY_LOCK.\n\t */\n\tif ((may & MAY_WRITE) == MAY_WRITE)\n\t\tmay |= MAY_LOCK;\n\treturn may;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_access_entry(char *subject_label, char *object_label,\n\t\t\tstruct list_head *rule_list)\n{\n\tint may = -ENOENT;\n\tstruct smack_rule *srp;\n\n\tlist_for_each_entry_rcu(srp, rule_list, list) {\n\t\tif (srp->smk_object->smk_known == object_label &&\n\t\t    srp->smk_subject->smk_known == subject_label) {\n\t\t\tmay = srp->smk_access;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * MAY_WRITE implies MAY_LOCK.\n\t */\n\tif ((may & MAY_WRITE) == MAY_WRITE)\n\t\tmay |= MAY_LOCK;\n\treturn may;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "dir"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\t     const struct qstr *qstr, const char **name,\n\t\t\t\t     void **value, size_t *len)\n{\n\tstruct inode_smack *issp = inode->i_security;\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known *isp = smk_of_inode(inode);\n\tstruct smack_known *dsp = smk_of_inode(dir);\n\tint may;\n\n\tif (name)\n\t\t*name = XATTR_SMACK_SUFFIX;\n\n\tif (value && len) {\n\t\trcu_read_lock();\n\t\tmay = smk_access_entry(skp->smk_known, dsp->smk_known,\n\t\t\t\t       &skp->smk_rules);\n\t\trcu_read_unlock();\n\n\t\t/*\n\t\t * If the access rule allows transmutation and\n\t\t * the directory requests transmutation then\n\t\t * by all means transmute.\n\t\t * Mark the inode as changed.\n\t\t */\n\t\tif (may > 0 && ((may & MAY_TRANSMUTE) != 0) &&\n\t\t    smk_inode_transmutable(dir)) {\n\t\t\tisp = dsp;\n\t\t\tissp->smk_flags |= SMK_INODE_CHANGED;\n\t\t}\n\n\t\t*value = kstrdup(isp->smk_known, GFP_NOFS);\n\t\tif (*value == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\t*len = strlen(isp->smk_known);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_inode_free_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "1001-1014",
    "snippet": "static void smack_inode_free_security(struct inode *inode)\n{\n\tstruct inode_smack *issp = inode->i_security;\n\n\t/*\n\t * The inode may still be referenced in a path walk and\n\t * a call to smack_inode_permission() can be made\n\t * after smack_inode_free_security() is called.\n\t * To avoid race condition free the i_security via RCU\n\t * and leave the current inode->i_security pointer intact.\n\t * The inode will be freed after the RCU grace period too.\n\t */\n\tcall_rcu(&issp->smk_rcu, smack_inode_free_rcu);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&issp->smk_rcu",
            "smack_inode_free_rcu"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_inode_free_security(struct inode *inode)\n{\n\tstruct inode_smack *issp = inode->i_security;\n\n\t/*\n\t * The inode may still be referenced in a path walk and\n\t * a call to smack_inode_permission() can be made\n\t * after smack_inode_free_security() is called.\n\t * To avoid race condition free the i_security via RCU\n\t * and leave the current inode->i_security pointer intact.\n\t * The inode will be freed after the RCU grace period too.\n\t */\n\tcall_rcu(&issp->smk_rcu, smack_inode_free_rcu);\n}"
  },
  {
    "function_name": "smack_inode_free_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "987-993",
    "snippet": "static void smack_inode_free_rcu(struct rcu_head *head)\n{\n\tstruct inode_smack *issp;\n\n\tissp = container_of(head, struct inode_smack, smk_rcu);\n\tkmem_cache_free(smack_inode_cache, issp);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *smack_inode_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "smack_inode_cache",
            "issp"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode_smack",
            "smk_rcu"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct kmem_cache *smack_inode_cache;\n\nstatic void smack_inode_free_rcu(struct rcu_head *head)\n{\n\tstruct inode_smack *issp;\n\n\tissp = container_of(head, struct inode_smack, smk_rcu);\n\tkmem_cache_free(smack_inode_cache, issp);\n}"
  },
  {
    "function_name": "smack_inode_alloc_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "970-978",
    "snippet": "static int smack_inode_alloc_security(struct inode *inode)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tinode->i_security = new_inode_smack(skp);\n\tif (inode->i_security == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_inode_smack",
          "args": [
            "skp"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_smack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "295-308",
          "snippet": "static struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *smack_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct kmem_cache *smack_inode_cache;\n\nstatic struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_inode_alloc_security(struct inode *inode)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tinode->i_security = new_inode_smack(skp);\n\tif (inode->i_security == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_bprm_set_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "912-958",
    "snippet": "static int smack_bprm_set_creds(struct linux_binprm *bprm)\n{\n\tstruct inode *inode = file_inode(bprm->file);\n\tstruct task_smack *bsp = bprm->cred->security;\n\tstruct inode_smack *isp;\n\tstruct superblock_smack *sbsp;\n\tint rc;\n\n\tif (bprm->called_set_creds)\n\t\treturn 0;\n\n\tisp = inode->i_security;\n\tif (isp->smk_task == NULL || isp->smk_task == bsp->smk_task)\n\t\treturn 0;\n\n\tsbsp = inode->i_sb->s_security;\n\tif ((sbsp->smk_flags & SMK_SB_UNTRUSTED) &&\n\t    isp->smk_task != sbsp->smk_root)\n\t\treturn 0;\n\n\tif (bprm->unsafe & LSM_UNSAFE_PTRACE) {\n\t\tstruct task_struct *tracer;\n\t\trc = 0;\n\n\t\trcu_read_lock();\n\t\ttracer = ptrace_parent(current);\n\t\tif (likely(tracer != NULL))\n\t\t\trc = smk_ptrace_rule_check(tracer,\n\t\t\t\t\t\t   isp->smk_task,\n\t\t\t\t\t\t   PTRACE_MODE_ATTACH,\n\t\t\t\t\t\t   __func__);\n\t\trcu_read_unlock();\n\n\t\tif (rc != 0)\n\t\t\treturn rc;\n\t} else if (bprm->unsafe)\n\t\treturn -EPERM;\n\n\tbsp->smk_task = isp->smk_task;\n\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\n\t/* Decide if this is a secure exec. */\n\tif (bsp->smk_task != bsp->smk_forked)\n\t\tbprm->secureexec = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ptrace_rule_check",
          "args": [
            "tracer",
            "isp->smk_task",
            "PTRACE_MODE_ATTACH",
            "__func__"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ptrace_rule_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "415-460",
          "snippet": "static int smk_ptrace_rule_check(struct task_struct *tracer,\n\t\t\t\t struct smack_known *tracee_known,\n\t\t\t\t unsigned int mode, const char *func)\n{\n\tint rc;\n\tstruct smk_audit_info ad, *saip = NULL;\n\tstruct task_smack *tsp;\n\tstruct smack_known *tracer_known;\n\n\tif ((mode & PTRACE_MODE_NOAUDIT) == 0) {\n\t\tsmk_ad_init(&ad, func, LSM_AUDIT_DATA_TASK);\n\t\tsmk_ad_setfield_u_tsk(&ad, tracer);\n\t\tsaip = &ad;\n\t}\n\n\trcu_read_lock();\n\ttsp = __task_cred(tracer)->security;\n\ttracer_known = smk_of_task(tsp);\n\n\tif ((mode & PTRACE_MODE_ATTACH) &&\n\t    (smack_ptrace_rule == SMACK_PTRACE_EXACT ||\n\t     smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)) {\n\t\tif (tracer_known->smk_known == tracee_known->smk_known)\n\t\t\trc = 0;\n\t\telse if (smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)\n\t\t\trc = -EACCES;\n\t\telse if (capable(CAP_SYS_PTRACE))\n\t\t\trc = 0;\n\t\telse\n\t\t\trc = -EACCES;\n\n\t\tif (saip)\n\t\t\tsmack_log(tracer_known->smk_known,\n\t\t\t\t  tracee_known->smk_known,\n\t\t\t\t  0, rc, saip);\n\n\t\trcu_read_unlock();\n\t\treturn rc;\n\t}\n\n\t/* In case of rule==SMACK_PTRACE_DEFAULT or mode==PTRACE_MODE_READ */\n\trc = smk_tskacc(tsp, tracee_known, smk_ptrace_mode(mode), saip);\n\n\trcu_read_unlock();\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_ptrace_rule_check(struct task_struct *tracer,\n\t\t\t\t struct smack_known *tracee_known,\n\t\t\t\t unsigned int mode, const char *func)\n{\n\tint rc;\n\tstruct smk_audit_info ad, *saip = NULL;\n\tstruct task_smack *tsp;\n\tstruct smack_known *tracer_known;\n\n\tif ((mode & PTRACE_MODE_NOAUDIT) == 0) {\n\t\tsmk_ad_init(&ad, func, LSM_AUDIT_DATA_TASK);\n\t\tsmk_ad_setfield_u_tsk(&ad, tracer);\n\t\tsaip = &ad;\n\t}\n\n\trcu_read_lock();\n\ttsp = __task_cred(tracer)->security;\n\ttracer_known = smk_of_task(tsp);\n\n\tif ((mode & PTRACE_MODE_ATTACH) &&\n\t    (smack_ptrace_rule == SMACK_PTRACE_EXACT ||\n\t     smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)) {\n\t\tif (tracer_known->smk_known == tracee_known->smk_known)\n\t\t\trc = 0;\n\t\telse if (smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)\n\t\t\trc = -EACCES;\n\t\telse if (capable(CAP_SYS_PTRACE))\n\t\t\trc = 0;\n\t\telse\n\t\t\trc = -EACCES;\n\n\t\tif (saip)\n\t\t\tsmack_log(tracer_known->smk_known,\n\t\t\t\t  tracee_known->smk_known,\n\t\t\t\t  0, rc, saip);\n\n\t\trcu_read_unlock();\n\t\treturn rc;\n\t}\n\n\t/* In case of rule==SMACK_PTRACE_DEFAULT or mode==PTRACE_MODE_READ */\n\trc = smk_tskacc(tsp, tracee_known, smk_ptrace_mode(mode), saip);\n\n\trcu_read_unlock();\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "tracer != NULL"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_parent",
          "args": [
            "current"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "bprm->file"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_bprm_set_creds(struct linux_binprm *bprm)\n{\n\tstruct inode *inode = file_inode(bprm->file);\n\tstruct task_smack *bsp = bprm->cred->security;\n\tstruct inode_smack *isp;\n\tstruct superblock_smack *sbsp;\n\tint rc;\n\n\tif (bprm->called_set_creds)\n\t\treturn 0;\n\n\tisp = inode->i_security;\n\tif (isp->smk_task == NULL || isp->smk_task == bsp->smk_task)\n\t\treturn 0;\n\n\tsbsp = inode->i_sb->s_security;\n\tif ((sbsp->smk_flags & SMK_SB_UNTRUSTED) &&\n\t    isp->smk_task != sbsp->smk_root)\n\t\treturn 0;\n\n\tif (bprm->unsafe & LSM_UNSAFE_PTRACE) {\n\t\tstruct task_struct *tracer;\n\t\trc = 0;\n\n\t\trcu_read_lock();\n\t\ttracer = ptrace_parent(current);\n\t\tif (likely(tracer != NULL))\n\t\t\trc = smk_ptrace_rule_check(tracer,\n\t\t\t\t\t\t   isp->smk_task,\n\t\t\t\t\t\t   PTRACE_MODE_ATTACH,\n\t\t\t\t\t\t   __func__);\n\t\trcu_read_unlock();\n\n\t\tif (rc != 0)\n\t\t\treturn rc;\n\t} else if (bprm->unsafe)\n\t\treturn -EPERM;\n\n\tbsp->smk_task = isp->smk_task;\n\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\n\t/* Decide if this is a secure exec. */\n\tif (bsp->smk_task != bsp->smk_forked)\n\t\tbprm->secureexec = 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_sb_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "888-900",
    "snippet": "static int smack_sb_statfs(struct dentry *dentry)\n{\n\tstruct superblock_smack *sbp = dentry->d_sb->s_security;\n\tint rc;\n\tstruct smk_audit_info ad;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(sbp->smk_floor, MAY_READ, &ad);\n\trc = smk_bu_current(\"statfs\", sbp->smk_floor, MAY_READ, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_bu_current",
          "args": [
            "\"statfs\"",
            "sbp->smk_floor",
            "MAY_READ",
            "rc"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "121-137",
          "snippet": "static int smk_bu_current(char *note, struct smack_known *oskp,\n\t\t\t  int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, oskp->smk_known,\n\t\tacc, current->comm, note);\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_current(char *note, struct smack_known *oskp,\n\t\t\t  int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, oskp->smk_known,\n\t\tacc, current->comm, note);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_curacc",
          "args": [
            "sbp->smk_floor",
            "MAY_READ",
            "&ad"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "smk_curacc_on_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "2094-2106",
          "snippet": "static int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_curacc_on_task(struct task_struct *p, int access,\n\t\t\t\tconst char *caller)\n{\n\tstruct smk_audit_info ad;\n\tstruct smack_known *skp = smk_of_task_struct(p);\n\tint rc;\n\n\tsmk_ad_init(&ad, caller, LSM_AUDIT_DATA_TASK);\n\tsmk_ad_setfield_u_tsk(&ad, p);\n\trc = smk_curacc(skp, access, &ad);\n\trc = smk_bu_task(p, access, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_fs_path_dentry",
          "args": [
            "&ad",
            "dentry"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_fs_path_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "481-484",
          "snippet": "static inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_fs_path_dentry(struct smk_audit_info *a,\n\t\t\t\t\t\t    struct dentry *d)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "__func__",
            "LSM_AUDIT_DATA_DENTRY"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_sb_statfs(struct dentry *dentry)\n{\n\tstruct superblock_smack *sbp = dentry->d_sb->s_security;\n\tint rc;\n\tstruct smk_audit_info ad;\n\n\tsmk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);\n\tsmk_ad_setfield_u_fs_path_dentry(&ad, dentry);\n\n\trc = smk_curacc(sbp->smk_floor, MAY_READ, &ad);\n\trc = smk_bu_current(\"statfs\", sbp->smk_floor, MAY_READ, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_sb_kern_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "858-879",
    "snippet": "static int smack_sb_kern_mount(struct super_block *sb, int flags, void *data)\n{\n\tint rc = 0;\n\tchar *options = data;\n\tstruct security_mnt_opts opts;\n\n\tsecurity_init_mnt_opts(&opts);\n\n\tif (!options)\n\t\tgoto out;\n\n\trc = smack_parse_opts_str(options, &opts);\n\tif (rc)\n\t\tgoto out_err;\n\nout:\n\trc = smack_set_mnt_opts(sb, &opts, 0, NULL);\n\nout_err:\n\tsecurity_free_mnt_opts(&opts);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_free_mnt_opts",
          "args": [
            "&opts"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_set_mnt_opts",
          "args": [
            "sb",
            "&opts",
            "0",
            "NULL"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "smack_set_mnt_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "750-848",
          "snippet": "static int smack_set_mnt_opts(struct super_block *sb,\n\t\tstruct security_mnt_opts *opts,\n\t\tunsigned long kern_flags,\n\t\tunsigned long *set_kern_flags)\n{\n\tstruct dentry *root = sb->s_root;\n\tstruct inode *inode = d_backing_inode(root);\n\tstruct superblock_smack *sp = sb->s_security;\n\tstruct inode_smack *isp;\n\tstruct smack_known *skp;\n\tint i;\n\tint num_opts = opts->num_mnt_opts;\n\tint transmute = 0;\n\n\tif (sp->smk_flags & SMK_SB_INITIALIZED)\n\t\treturn 0;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN)) {\n\t\t/*\n\t\t * Unprivileged mounts don't get to specify Smack values.\n\t\t */\n\t\tif (num_opts)\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Unprivileged mounts get root and default from the caller.\n\t\t */\n\t\tskp = smk_of_current();\n\t\tsp->smk_root = skp;\n\t\tsp->smk_default = skp;\n\t\t/*\n\t\t * For a handful of fs types with no user-controlled\n\t\t * backing store it's okay to trust security labels\n\t\t * in the filesystem. The rest are untrusted.\n\t\t */\n\t\tif (sb->s_user_ns != &init_user_ns &&\n\t\t    sb->s_magic != SYSFS_MAGIC && sb->s_magic != TMPFS_MAGIC &&\n\t\t    sb->s_magic != RAMFS_MAGIC) {\n\t\t\ttransmute = 1;\n\t\t\tsp->smk_flags |= SMK_SB_UNTRUSTED;\n\t\t}\n\t}\n\n\tsp->smk_flags |= SMK_SB_INITIALIZED;\n\n\tfor (i = 0; i < num_opts; i++) {\n\t\tswitch (opts->mnt_opts_flags[i]) {\n\t\tcase FSDEFAULT_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_default = skp;\n\t\t\tbreak;\n\t\tcase FSFLOOR_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_floor = skp;\n\t\t\tbreak;\n\t\tcase FSHAT_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_hat = skp;\n\t\t\tbreak;\n\t\tcase FSROOT_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_root = skp;\n\t\t\tbreak;\n\t\tcase FSTRANS_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_root = skp;\n\t\t\ttransmute = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Initialize the root inode.\n\t */\n\tisp = inode->i_security;\n\tif (isp == NULL) {\n\t\tisp = new_inode_smack(sp->smk_root);\n\t\tif (isp == NULL)\n\t\t\treturn -ENOMEM;\n\t\tinode->i_security = isp;\n\t} else\n\t\tisp->smk_inode = sp->smk_root;\n\n\tif (transmute)\n\t\tisp->smk_flags |= SMK_INODE_TRANSMUTE;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_set_mnt_opts(struct super_block *sb,\n\t\tstruct security_mnt_opts *opts,\n\t\tunsigned long kern_flags,\n\t\tunsigned long *set_kern_flags)\n{\n\tstruct dentry *root = sb->s_root;\n\tstruct inode *inode = d_backing_inode(root);\n\tstruct superblock_smack *sp = sb->s_security;\n\tstruct inode_smack *isp;\n\tstruct smack_known *skp;\n\tint i;\n\tint num_opts = opts->num_mnt_opts;\n\tint transmute = 0;\n\n\tif (sp->smk_flags & SMK_SB_INITIALIZED)\n\t\treturn 0;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN)) {\n\t\t/*\n\t\t * Unprivileged mounts don't get to specify Smack values.\n\t\t */\n\t\tif (num_opts)\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Unprivileged mounts get root and default from the caller.\n\t\t */\n\t\tskp = smk_of_current();\n\t\tsp->smk_root = skp;\n\t\tsp->smk_default = skp;\n\t\t/*\n\t\t * For a handful of fs types with no user-controlled\n\t\t * backing store it's okay to trust security labels\n\t\t * in the filesystem. The rest are untrusted.\n\t\t */\n\t\tif (sb->s_user_ns != &init_user_ns &&\n\t\t    sb->s_magic != SYSFS_MAGIC && sb->s_magic != TMPFS_MAGIC &&\n\t\t    sb->s_magic != RAMFS_MAGIC) {\n\t\t\ttransmute = 1;\n\t\t\tsp->smk_flags |= SMK_SB_UNTRUSTED;\n\t\t}\n\t}\n\n\tsp->smk_flags |= SMK_SB_INITIALIZED;\n\n\tfor (i = 0; i < num_opts; i++) {\n\t\tswitch (opts->mnt_opts_flags[i]) {\n\t\tcase FSDEFAULT_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_default = skp;\n\t\t\tbreak;\n\t\tcase FSFLOOR_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_floor = skp;\n\t\t\tbreak;\n\t\tcase FSHAT_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_hat = skp;\n\t\t\tbreak;\n\t\tcase FSROOT_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_root = skp;\n\t\t\tbreak;\n\t\tcase FSTRANS_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_root = skp;\n\t\t\ttransmute = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Initialize the root inode.\n\t */\n\tisp = inode->i_security;\n\tif (isp == NULL) {\n\t\tisp = new_inode_smack(sp->smk_root);\n\t\tif (isp == NULL)\n\t\t\treturn -ENOMEM;\n\t\tinode->i_security = isp;\n\t} else\n\t\tisp->smk_inode = sp->smk_root;\n\n\tif (transmute)\n\t\tisp->smk_flags |= SMK_INODE_TRANSMUTE;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_parse_opts_str",
          "args": [
            "options",
            "&opts"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "smack_parse_opts_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "623-736",
          "snippet": "static int smack_parse_opts_str(char *options,\n\t\tstruct security_mnt_opts *opts)\n{\n\tchar *p;\n\tchar *fsdefault = NULL;\n\tchar *fsfloor = NULL;\n\tchar *fshat = NULL;\n\tchar *fsroot = NULL;\n\tchar *fstransmute = NULL;\n\tint rc = -ENOMEM;\n\tint num_mnt_opts = 0;\n\tint token;\n\n\topts->num_mnt_opts = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, smk_mount_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_fsdefault:\n\t\t\tif (fsdefault)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfsdefault = match_strdup(&args[0]);\n\t\t\tif (!fsdefault)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fsfloor:\n\t\t\tif (fsfloor)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfsfloor = match_strdup(&args[0]);\n\t\t\tif (!fsfloor)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fshat:\n\t\t\tif (fshat)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfshat = match_strdup(&args[0]);\n\t\t\tif (!fshat)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fsroot:\n\t\t\tif (fsroot)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfsroot = match_strdup(&args[0]);\n\t\t\tif (!fsroot)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fstransmute:\n\t\t\tif (fstransmute)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfstransmute = match_strdup(&args[0]);\n\t\t\tif (!fstransmute)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EINVAL;\n\t\t\tpr_warn(\"Smack:  unknown mount option\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\topts->mnt_opts = kcalloc(NUM_SMK_MNT_OPTS, sizeof(char *), GFP_KERNEL);\n\tif (!opts->mnt_opts)\n\t\tgoto out_err;\n\n\topts->mnt_opts_flags = kcalloc(NUM_SMK_MNT_OPTS, sizeof(int),\n\t\t\tGFP_KERNEL);\n\tif (!opts->mnt_opts_flags)\n\t\tgoto out_err;\n\n\tif (fsdefault) {\n\t\topts->mnt_opts[num_mnt_opts] = fsdefault;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSDEFAULT_MNT;\n\t}\n\tif (fsfloor) {\n\t\topts->mnt_opts[num_mnt_opts] = fsfloor;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSFLOOR_MNT;\n\t}\n\tif (fshat) {\n\t\topts->mnt_opts[num_mnt_opts] = fshat;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSHAT_MNT;\n\t}\n\tif (fsroot) {\n\t\topts->mnt_opts[num_mnt_opts] = fsroot;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSROOT_MNT;\n\t}\n\tif (fstransmute) {\n\t\topts->mnt_opts[num_mnt_opts] = fstransmute;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSTRANS_MNT;\n\t}\n\n\topts->num_mnt_opts = num_mnt_opts;\n\treturn 0;\n\nout_opt_err:\n\trc = -EINVAL;\n\tpr_warn(\"Smack: duplicate mount options\\n\");\n\nout_err:\n\tkfree(fsdefault);\n\tkfree(fsfloor);\n\tkfree(fshat);\n\tkfree(fsroot);\n\tkfree(fstransmute);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t smk_mount_tokens = {\n\t{Opt_fsdefault, SMK_FSDEFAULT \"%s\"},\n\t{Opt_fsfloor, SMK_FSFLOOR \"%s\"},\n\t{Opt_fshat, SMK_FSHAT \"%s\"},\n\t{Opt_fsroot, SMK_FSROOT \"%s\"},\n\t{Opt_fstransmute, SMK_FSTRANS \"%s\"},\n\t{Opt_error, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic const match_table_t smk_mount_tokens = {\n\t{Opt_fsdefault, SMK_FSDEFAULT \"%s\"},\n\t{Opt_fsfloor, SMK_FSFLOOR \"%s\"},\n\t{Opt_fshat, SMK_FSHAT \"%s\"},\n\t{Opt_fsroot, SMK_FSROOT \"%s\"},\n\t{Opt_fstransmute, SMK_FSTRANS \"%s\"},\n\t{Opt_error, NULL},\n};\n\nstatic int smack_parse_opts_str(char *options,\n\t\tstruct security_mnt_opts *opts)\n{\n\tchar *p;\n\tchar *fsdefault = NULL;\n\tchar *fsfloor = NULL;\n\tchar *fshat = NULL;\n\tchar *fsroot = NULL;\n\tchar *fstransmute = NULL;\n\tint rc = -ENOMEM;\n\tint num_mnt_opts = 0;\n\tint token;\n\n\topts->num_mnt_opts = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, smk_mount_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_fsdefault:\n\t\t\tif (fsdefault)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfsdefault = match_strdup(&args[0]);\n\t\t\tif (!fsdefault)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fsfloor:\n\t\t\tif (fsfloor)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfsfloor = match_strdup(&args[0]);\n\t\t\tif (!fsfloor)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fshat:\n\t\t\tif (fshat)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfshat = match_strdup(&args[0]);\n\t\t\tif (!fshat)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fsroot:\n\t\t\tif (fsroot)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfsroot = match_strdup(&args[0]);\n\t\t\tif (!fsroot)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fstransmute:\n\t\t\tif (fstransmute)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfstransmute = match_strdup(&args[0]);\n\t\t\tif (!fstransmute)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EINVAL;\n\t\t\tpr_warn(\"Smack:  unknown mount option\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\topts->mnt_opts = kcalloc(NUM_SMK_MNT_OPTS, sizeof(char *), GFP_KERNEL);\n\tif (!opts->mnt_opts)\n\t\tgoto out_err;\n\n\topts->mnt_opts_flags = kcalloc(NUM_SMK_MNT_OPTS, sizeof(int),\n\t\t\tGFP_KERNEL);\n\tif (!opts->mnt_opts_flags)\n\t\tgoto out_err;\n\n\tif (fsdefault) {\n\t\topts->mnt_opts[num_mnt_opts] = fsdefault;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSDEFAULT_MNT;\n\t}\n\tif (fsfloor) {\n\t\topts->mnt_opts[num_mnt_opts] = fsfloor;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSFLOOR_MNT;\n\t}\n\tif (fshat) {\n\t\topts->mnt_opts[num_mnt_opts] = fshat;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSHAT_MNT;\n\t}\n\tif (fsroot) {\n\t\topts->mnt_opts[num_mnt_opts] = fsroot;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSROOT_MNT;\n\t}\n\tif (fstransmute) {\n\t\topts->mnt_opts[num_mnt_opts] = fstransmute;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSTRANS_MNT;\n\t}\n\n\topts->num_mnt_opts = num_mnt_opts;\n\treturn 0;\n\nout_opt_err:\n\trc = -EINVAL;\n\tpr_warn(\"Smack: duplicate mount options\\n\");\n\nout_err:\n\tkfree(fsdefault);\n\tkfree(fsfloor);\n\tkfree(fshat);\n\tkfree(fsroot);\n\tkfree(fstransmute);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_init_mnt_opts",
          "args": [
            "&opts"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_sb_kern_mount(struct super_block *sb, int flags, void *data)\n{\n\tint rc = 0;\n\tchar *options = data;\n\tstruct security_mnt_opts opts;\n\n\tsecurity_init_mnt_opts(&opts);\n\n\tif (!options)\n\t\tgoto out;\n\n\trc = smack_parse_opts_str(options, &opts);\n\tif (rc)\n\t\tgoto out_err;\n\nout:\n\trc = smack_set_mnt_opts(sb, &opts, 0, NULL);\n\nout_err:\n\tsecurity_free_mnt_opts(&opts);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_set_mnt_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "750-848",
    "snippet": "static int smack_set_mnt_opts(struct super_block *sb,\n\t\tstruct security_mnt_opts *opts,\n\t\tunsigned long kern_flags,\n\t\tunsigned long *set_kern_flags)\n{\n\tstruct dentry *root = sb->s_root;\n\tstruct inode *inode = d_backing_inode(root);\n\tstruct superblock_smack *sp = sb->s_security;\n\tstruct inode_smack *isp;\n\tstruct smack_known *skp;\n\tint i;\n\tint num_opts = opts->num_mnt_opts;\n\tint transmute = 0;\n\n\tif (sp->smk_flags & SMK_SB_INITIALIZED)\n\t\treturn 0;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN)) {\n\t\t/*\n\t\t * Unprivileged mounts don't get to specify Smack values.\n\t\t */\n\t\tif (num_opts)\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Unprivileged mounts get root and default from the caller.\n\t\t */\n\t\tskp = smk_of_current();\n\t\tsp->smk_root = skp;\n\t\tsp->smk_default = skp;\n\t\t/*\n\t\t * For a handful of fs types with no user-controlled\n\t\t * backing store it's okay to trust security labels\n\t\t * in the filesystem. The rest are untrusted.\n\t\t */\n\t\tif (sb->s_user_ns != &init_user_ns &&\n\t\t    sb->s_magic != SYSFS_MAGIC && sb->s_magic != TMPFS_MAGIC &&\n\t\t    sb->s_magic != RAMFS_MAGIC) {\n\t\t\ttransmute = 1;\n\t\t\tsp->smk_flags |= SMK_SB_UNTRUSTED;\n\t\t}\n\t}\n\n\tsp->smk_flags |= SMK_SB_INITIALIZED;\n\n\tfor (i = 0; i < num_opts; i++) {\n\t\tswitch (opts->mnt_opts_flags[i]) {\n\t\tcase FSDEFAULT_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_default = skp;\n\t\t\tbreak;\n\t\tcase FSFLOOR_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_floor = skp;\n\t\t\tbreak;\n\t\tcase FSHAT_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_hat = skp;\n\t\t\tbreak;\n\t\tcase FSROOT_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_root = skp;\n\t\t\tbreak;\n\t\tcase FSTRANS_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_root = skp;\n\t\t\ttransmute = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Initialize the root inode.\n\t */\n\tisp = inode->i_security;\n\tif (isp == NULL) {\n\t\tisp = new_inode_smack(sp->smk_root);\n\t\tif (isp == NULL)\n\t\t\treturn -ENOMEM;\n\t\tinode->i_security = isp;\n\t} else\n\t\tisp->smk_inode = sp->smk_root;\n\n\tif (transmute)\n\t\tisp->smk_flags |= SMK_INODE_TRANSMUTE;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_inode_smack",
          "args": [
            "sp->smk_root"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_smack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "295-308",
          "snippet": "static struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *smack_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct kmem_cache *smack_inode_cache;\n\nstatic struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "opts->mnt_opts[i]",
            "0"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "root"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_set_mnt_opts(struct super_block *sb,\n\t\tstruct security_mnt_opts *opts,\n\t\tunsigned long kern_flags,\n\t\tunsigned long *set_kern_flags)\n{\n\tstruct dentry *root = sb->s_root;\n\tstruct inode *inode = d_backing_inode(root);\n\tstruct superblock_smack *sp = sb->s_security;\n\tstruct inode_smack *isp;\n\tstruct smack_known *skp;\n\tint i;\n\tint num_opts = opts->num_mnt_opts;\n\tint transmute = 0;\n\n\tif (sp->smk_flags & SMK_SB_INITIALIZED)\n\t\treturn 0;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN)) {\n\t\t/*\n\t\t * Unprivileged mounts don't get to specify Smack values.\n\t\t */\n\t\tif (num_opts)\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Unprivileged mounts get root and default from the caller.\n\t\t */\n\t\tskp = smk_of_current();\n\t\tsp->smk_root = skp;\n\t\tsp->smk_default = skp;\n\t\t/*\n\t\t * For a handful of fs types with no user-controlled\n\t\t * backing store it's okay to trust security labels\n\t\t * in the filesystem. The rest are untrusted.\n\t\t */\n\t\tif (sb->s_user_ns != &init_user_ns &&\n\t\t    sb->s_magic != SYSFS_MAGIC && sb->s_magic != TMPFS_MAGIC &&\n\t\t    sb->s_magic != RAMFS_MAGIC) {\n\t\t\ttransmute = 1;\n\t\t\tsp->smk_flags |= SMK_SB_UNTRUSTED;\n\t\t}\n\t}\n\n\tsp->smk_flags |= SMK_SB_INITIALIZED;\n\n\tfor (i = 0; i < num_opts; i++) {\n\t\tswitch (opts->mnt_opts_flags[i]) {\n\t\tcase FSDEFAULT_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_default = skp;\n\t\t\tbreak;\n\t\tcase FSFLOOR_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_floor = skp;\n\t\t\tbreak;\n\t\tcase FSHAT_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_hat = skp;\n\t\t\tbreak;\n\t\tcase FSROOT_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_root = skp;\n\t\t\tbreak;\n\t\tcase FSTRANS_MNT:\n\t\t\tskp = smk_import_entry(opts->mnt_opts[i], 0);\n\t\t\tif (IS_ERR(skp))\n\t\t\t\treturn PTR_ERR(skp);\n\t\t\tsp->smk_root = skp;\n\t\t\ttransmute = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Initialize the root inode.\n\t */\n\tisp = inode->i_security;\n\tif (isp == NULL) {\n\t\tisp = new_inode_smack(sp->smk_root);\n\t\tif (isp == NULL)\n\t\t\treturn -ENOMEM;\n\t\tinode->i_security = isp;\n\t} else\n\t\tisp->smk_inode = sp->smk_root;\n\n\tif (transmute)\n\t\tisp->smk_flags |= SMK_INODE_TRANSMUTE;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_parse_opts_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "623-736",
    "snippet": "static int smack_parse_opts_str(char *options,\n\t\tstruct security_mnt_opts *opts)\n{\n\tchar *p;\n\tchar *fsdefault = NULL;\n\tchar *fsfloor = NULL;\n\tchar *fshat = NULL;\n\tchar *fsroot = NULL;\n\tchar *fstransmute = NULL;\n\tint rc = -ENOMEM;\n\tint num_mnt_opts = 0;\n\tint token;\n\n\topts->num_mnt_opts = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, smk_mount_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_fsdefault:\n\t\t\tif (fsdefault)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfsdefault = match_strdup(&args[0]);\n\t\t\tif (!fsdefault)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fsfloor:\n\t\t\tif (fsfloor)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfsfloor = match_strdup(&args[0]);\n\t\t\tif (!fsfloor)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fshat:\n\t\t\tif (fshat)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfshat = match_strdup(&args[0]);\n\t\t\tif (!fshat)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fsroot:\n\t\t\tif (fsroot)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfsroot = match_strdup(&args[0]);\n\t\t\tif (!fsroot)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fstransmute:\n\t\t\tif (fstransmute)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfstransmute = match_strdup(&args[0]);\n\t\t\tif (!fstransmute)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EINVAL;\n\t\t\tpr_warn(\"Smack:  unknown mount option\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\topts->mnt_opts = kcalloc(NUM_SMK_MNT_OPTS, sizeof(char *), GFP_KERNEL);\n\tif (!opts->mnt_opts)\n\t\tgoto out_err;\n\n\topts->mnt_opts_flags = kcalloc(NUM_SMK_MNT_OPTS, sizeof(int),\n\t\t\tGFP_KERNEL);\n\tif (!opts->mnt_opts_flags)\n\t\tgoto out_err;\n\n\tif (fsdefault) {\n\t\topts->mnt_opts[num_mnt_opts] = fsdefault;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSDEFAULT_MNT;\n\t}\n\tif (fsfloor) {\n\t\topts->mnt_opts[num_mnt_opts] = fsfloor;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSFLOOR_MNT;\n\t}\n\tif (fshat) {\n\t\topts->mnt_opts[num_mnt_opts] = fshat;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSHAT_MNT;\n\t}\n\tif (fsroot) {\n\t\topts->mnt_opts[num_mnt_opts] = fsroot;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSROOT_MNT;\n\t}\n\tif (fstransmute) {\n\t\topts->mnt_opts[num_mnt_opts] = fstransmute;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSTRANS_MNT;\n\t}\n\n\topts->num_mnt_opts = num_mnt_opts;\n\treturn 0;\n\nout_opt_err:\n\trc = -EINVAL;\n\tpr_warn(\"Smack: duplicate mount options\\n\");\n\nout_err:\n\tkfree(fsdefault);\n\tkfree(fsfloor);\n\tkfree(fshat);\n\tkfree(fsroot);\n\tkfree(fstransmute);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t smk_mount_tokens = {\n\t{Opt_fsdefault, SMK_FSDEFAULT \"%s\"},\n\t{Opt_fsfloor, SMK_FSFLOOR \"%s\"},\n\t{Opt_fshat, SMK_FSHAT \"%s\"},\n\t{Opt_fsroot, SMK_FSROOT \"%s\"},\n\t{Opt_fstransmute, SMK_FSTRANS \"%s\"},\n\t{Opt_error, NULL},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fstransmute"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fsroot"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fshat"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fsfloor"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fsdefault"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Smack: duplicate mount options\\n\""
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "NUM_SMK_MNT_OPTS",
            "sizeof(int)",
            "GFP_KERNEL"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "NUM_SMK_MNT_OPTS",
            "sizeof(char *)",
            "GFP_KERNEL"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Smack:  unknown mount option\\n\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "smk_mount_tokens",
            "args"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic const match_table_t smk_mount_tokens = {\n\t{Opt_fsdefault, SMK_FSDEFAULT \"%s\"},\n\t{Opt_fsfloor, SMK_FSFLOOR \"%s\"},\n\t{Opt_fshat, SMK_FSHAT \"%s\"},\n\t{Opt_fsroot, SMK_FSROOT \"%s\"},\n\t{Opt_fstransmute, SMK_FSTRANS \"%s\"},\n\t{Opt_error, NULL},\n};\n\nstatic int smack_parse_opts_str(char *options,\n\t\tstruct security_mnt_opts *opts)\n{\n\tchar *p;\n\tchar *fsdefault = NULL;\n\tchar *fsfloor = NULL;\n\tchar *fshat = NULL;\n\tchar *fsroot = NULL;\n\tchar *fstransmute = NULL;\n\tint rc = -ENOMEM;\n\tint num_mnt_opts = 0;\n\tint token;\n\n\topts->num_mnt_opts = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, smk_mount_tokens, args);\n\n\t\tswitch (token) {\n\t\tcase Opt_fsdefault:\n\t\t\tif (fsdefault)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfsdefault = match_strdup(&args[0]);\n\t\t\tif (!fsdefault)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fsfloor:\n\t\t\tif (fsfloor)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfsfloor = match_strdup(&args[0]);\n\t\t\tif (!fsfloor)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fshat:\n\t\t\tif (fshat)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfshat = match_strdup(&args[0]);\n\t\t\tif (!fshat)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fsroot:\n\t\t\tif (fsroot)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfsroot = match_strdup(&args[0]);\n\t\t\tif (!fsroot)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tcase Opt_fstransmute:\n\t\t\tif (fstransmute)\n\t\t\t\tgoto out_opt_err;\n\t\t\tfstransmute = match_strdup(&args[0]);\n\t\t\tif (!fstransmute)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EINVAL;\n\t\t\tpr_warn(\"Smack:  unknown mount option\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\topts->mnt_opts = kcalloc(NUM_SMK_MNT_OPTS, sizeof(char *), GFP_KERNEL);\n\tif (!opts->mnt_opts)\n\t\tgoto out_err;\n\n\topts->mnt_opts_flags = kcalloc(NUM_SMK_MNT_OPTS, sizeof(int),\n\t\t\tGFP_KERNEL);\n\tif (!opts->mnt_opts_flags)\n\t\tgoto out_err;\n\n\tif (fsdefault) {\n\t\topts->mnt_opts[num_mnt_opts] = fsdefault;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSDEFAULT_MNT;\n\t}\n\tif (fsfloor) {\n\t\topts->mnt_opts[num_mnt_opts] = fsfloor;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSFLOOR_MNT;\n\t}\n\tif (fshat) {\n\t\topts->mnt_opts[num_mnt_opts] = fshat;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSHAT_MNT;\n\t}\n\tif (fsroot) {\n\t\topts->mnt_opts[num_mnt_opts] = fsroot;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSROOT_MNT;\n\t}\n\tif (fstransmute) {\n\t\topts->mnt_opts[num_mnt_opts] = fstransmute;\n\t\topts->mnt_opts_flags[num_mnt_opts++] = FSTRANS_MNT;\n\t}\n\n\topts->num_mnt_opts = num_mnt_opts;\n\treturn 0;\n\nout_opt_err:\n\trc = -EINVAL;\n\tpr_warn(\"Smack: duplicate mount options\\n\");\n\nout_err:\n\tkfree(fsdefault);\n\tkfree(fsfloor);\n\tkfree(fshat);\n\tkfree(fsroot);\n\tkfree(fstransmute);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_sb_copy_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "577-612",
    "snippet": "static int smack_sb_copy_data(char *orig, char *smackopts)\n{\n\tchar *cp, *commap, *otheropts, *dp;\n\n\totheropts = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (otheropts == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (cp = orig, commap = orig; commap != NULL; cp = commap + 1) {\n\t\tif (strstr(cp, SMK_FSDEFAULT) == cp)\n\t\t\tdp = smackopts;\n\t\telse if (strstr(cp, SMK_FSFLOOR) == cp)\n\t\t\tdp = smackopts;\n\t\telse if (strstr(cp, SMK_FSHAT) == cp)\n\t\t\tdp = smackopts;\n\t\telse if (strstr(cp, SMK_FSROOT) == cp)\n\t\t\tdp = smackopts;\n\t\telse if (strstr(cp, SMK_FSTRANS) == cp)\n\t\t\tdp = smackopts;\n\t\telse\n\t\t\tdp = otheropts;\n\n\t\tcommap = strchr(cp, ',');\n\t\tif (commap != NULL)\n\t\t\t*commap = '\\0';\n\n\t\tif (*dp != '\\0')\n\t\t\tstrcat(dp, \",\");\n\t\tstrcat(dp, cp);\n\t}\n\n\tstrcpy(orig, otheropts);\n\tfree_page((unsigned long)otheropts);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)otheropts"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "orig",
            "otheropts"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "dp",
            "cp"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "dp",
            "\",\""
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "','"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cp",
            "SMK_FSTRANS"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cp",
            "SMK_FSROOT"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cp",
            "SMK_FSHAT"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cp",
            "SMK_FSFLOOR"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cp",
            "SMK_FSDEFAULT"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_sb_copy_data(char *orig, char *smackopts)\n{\n\tchar *cp, *commap, *otheropts, *dp;\n\n\totheropts = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (otheropts == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (cp = orig, commap = orig; commap != NULL; cp = commap + 1) {\n\t\tif (strstr(cp, SMK_FSDEFAULT) == cp)\n\t\t\tdp = smackopts;\n\t\telse if (strstr(cp, SMK_FSFLOOR) == cp)\n\t\t\tdp = smackopts;\n\t\telse if (strstr(cp, SMK_FSHAT) == cp)\n\t\t\tdp = smackopts;\n\t\telse if (strstr(cp, SMK_FSROOT) == cp)\n\t\t\tdp = smackopts;\n\t\telse if (strstr(cp, SMK_FSTRANS) == cp)\n\t\t\tdp = smackopts;\n\t\telse\n\t\t\tdp = otheropts;\n\n\t\tcommap = strchr(cp, ',');\n\t\tif (commap != NULL)\n\t\t\t*commap = '\\0';\n\n\t\tif (*dp != '\\0')\n\t\t\tstrcat(dp, \",\");\n\t\tstrcat(dp, cp);\n\t}\n\n\tstrcpy(orig, otheropts);\n\tfree_page((unsigned long)otheropts);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_sb_free_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "561-565",
    "snippet": "static void smack_sb_free_security(struct super_block *sb)\n{\n\tkfree(sb->s_security);\n\tsb->s_security = NULL;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sb->s_security"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smack_sb_free_security(struct super_block *sb)\n{\n\tkfree(sb->s_security);\n\tsb->s_security = NULL;\n}"
  },
  {
    "function_name": "smack_sb_alloc_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "535-554",
    "snippet": "static int smack_sb_alloc_security(struct super_block *sb)\n{\n\tstruct superblock_smack *sbsp;\n\n\tsbsp = kzalloc(sizeof(struct superblock_smack), GFP_KERNEL);\n\n\tif (sbsp == NULL)\n\t\treturn -ENOMEM;\n\n\tsbsp->smk_root = &smack_known_floor;\n\tsbsp->smk_default = &smack_known_floor;\n\tsbsp->smk_floor = &smack_known_floor;\n\tsbsp->smk_hat = &smack_known_hat;\n\t/*\n\t * SMK_SB_INITIALIZED will be zero from kzalloc.\n\t */\n\tsb->s_security = sbsp;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct superblock_smack)",
            "GFP_KERNEL"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_sb_alloc_security(struct super_block *sb)\n{\n\tstruct superblock_smack *sbsp;\n\n\tsbsp = kzalloc(sizeof(struct superblock_smack), GFP_KERNEL);\n\n\tif (sbsp == NULL)\n\t\treturn -ENOMEM;\n\n\tsbsp->smk_root = &smack_known_floor;\n\tsbsp->smk_default = &smack_known_floor;\n\tsbsp->smk_floor = &smack_known_floor;\n\tsbsp->smk_hat = &smack_known_hat;\n\t/*\n\t * SMK_SB_INITIALIZED will be zero from kzalloc.\n\t */\n\tsb->s_security = sbsp;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smack_syslog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "510-522",
    "snippet": "static int smack_syslog(int typefrom_file)\n{\n\tint rc = 0;\n\tstruct smack_known *skp = smk_of_current();\n\n\tif (smack_privileged(CAP_MAC_OVERRIDE))\n\t\treturn 0;\n\n\tif (smack_syslog_label != NULL && smack_syslog_label != skp)\n\t\trc = -EACCES;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_OVERRIDE"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_syslog(int typefrom_file)\n{\n\tint rc = 0;\n\tstruct smack_known *skp = smk_of_current();\n\n\tif (smack_privileged(CAP_MAC_OVERRIDE))\n\t\treturn 0;\n\n\tif (smack_syslog_label != NULL && smack_syslog_label != skp)\n\t\trc = -EACCES;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_ptrace_traceme",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "493-502",
    "snippet": "static int smack_ptrace_traceme(struct task_struct *ptp)\n{\n\tint rc;\n\tstruct smack_known *skp;\n\n\tskp = smk_of_task(current_security());\n\n\trc = smk_ptrace_rule_check(ptp, skp, PTRACE_MODE_ATTACH, __func__);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_ptrace_rule_check",
          "args": [
            "ptp",
            "skp",
            "PTRACE_MODE_ATTACH",
            "__func__"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ptrace_rule_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "415-460",
          "snippet": "static int smk_ptrace_rule_check(struct task_struct *tracer,\n\t\t\t\t struct smack_known *tracee_known,\n\t\t\t\t unsigned int mode, const char *func)\n{\n\tint rc;\n\tstruct smk_audit_info ad, *saip = NULL;\n\tstruct task_smack *tsp;\n\tstruct smack_known *tracer_known;\n\n\tif ((mode & PTRACE_MODE_NOAUDIT) == 0) {\n\t\tsmk_ad_init(&ad, func, LSM_AUDIT_DATA_TASK);\n\t\tsmk_ad_setfield_u_tsk(&ad, tracer);\n\t\tsaip = &ad;\n\t}\n\n\trcu_read_lock();\n\ttsp = __task_cred(tracer)->security;\n\ttracer_known = smk_of_task(tsp);\n\n\tif ((mode & PTRACE_MODE_ATTACH) &&\n\t    (smack_ptrace_rule == SMACK_PTRACE_EXACT ||\n\t     smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)) {\n\t\tif (tracer_known->smk_known == tracee_known->smk_known)\n\t\t\trc = 0;\n\t\telse if (smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)\n\t\t\trc = -EACCES;\n\t\telse if (capable(CAP_SYS_PTRACE))\n\t\t\trc = 0;\n\t\telse\n\t\t\trc = -EACCES;\n\n\t\tif (saip)\n\t\t\tsmack_log(tracer_known->smk_known,\n\t\t\t\t  tracee_known->smk_known,\n\t\t\t\t  0, rc, saip);\n\n\t\trcu_read_unlock();\n\t\treturn rc;\n\t}\n\n\t/* In case of rule==SMACK_PTRACE_DEFAULT or mode==PTRACE_MODE_READ */\n\trc = smk_tskacc(tsp, tracee_known, smk_ptrace_mode(mode), saip);\n\n\trcu_read_unlock();\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_ptrace_rule_check(struct task_struct *tracer,\n\t\t\t\t struct smack_known *tracee_known,\n\t\t\t\t unsigned int mode, const char *func)\n{\n\tint rc;\n\tstruct smk_audit_info ad, *saip = NULL;\n\tstruct task_smack *tsp;\n\tstruct smack_known *tracer_known;\n\n\tif ((mode & PTRACE_MODE_NOAUDIT) == 0) {\n\t\tsmk_ad_init(&ad, func, LSM_AUDIT_DATA_TASK);\n\t\tsmk_ad_setfield_u_tsk(&ad, tracer);\n\t\tsaip = &ad;\n\t}\n\n\trcu_read_lock();\n\ttsp = __task_cred(tracer)->security;\n\ttracer_known = smk_of_task(tsp);\n\n\tif ((mode & PTRACE_MODE_ATTACH) &&\n\t    (smack_ptrace_rule == SMACK_PTRACE_EXACT ||\n\t     smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)) {\n\t\tif (tracer_known->smk_known == tracee_known->smk_known)\n\t\t\trc = 0;\n\t\telse if (smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)\n\t\t\trc = -EACCES;\n\t\telse if (capable(CAP_SYS_PTRACE))\n\t\t\trc = 0;\n\t\telse\n\t\t\trc = -EACCES;\n\n\t\tif (saip)\n\t\t\tsmack_log(tracer_known->smk_known,\n\t\t\t\t  tracee_known->smk_known,\n\t\t\t\t  0, rc, saip);\n\n\t\trcu_read_unlock();\n\t\treturn rc;\n\t}\n\n\t/* In case of rule==SMACK_PTRACE_DEFAULT or mode==PTRACE_MODE_READ */\n\trc = smk_tskacc(tsp, tracee_known, smk_ptrace_mode(mode), saip);\n\n\trcu_read_unlock();\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_task",
          "args": [
            "current_security()"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "384-392",
          "snippet": "static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_ptrace_traceme(struct task_struct *ptp)\n{\n\tint rc;\n\tstruct smack_known *skp;\n\n\tskp = smk_of_task(current_security());\n\n\trc = smk_ptrace_rule_check(ptp, skp, PTRACE_MODE_ATTACH, __func__);\n\treturn rc;\n}"
  },
  {
    "function_name": "smack_ptrace_access_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "476-483",
    "snippet": "static int smack_ptrace_access_check(struct task_struct *ctp, unsigned int mode)\n{\n\tstruct smack_known *skp;\n\n\tskp = smk_of_task_struct(ctp);\n\n\treturn smk_ptrace_rule_check(current, skp, mode, __func__);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_ptrace_rule_check",
          "args": [
            "current",
            "skp",
            "mode",
            "__func__"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ptrace_rule_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "415-460",
          "snippet": "static int smk_ptrace_rule_check(struct task_struct *tracer,\n\t\t\t\t struct smack_known *tracee_known,\n\t\t\t\t unsigned int mode, const char *func)\n{\n\tint rc;\n\tstruct smk_audit_info ad, *saip = NULL;\n\tstruct task_smack *tsp;\n\tstruct smack_known *tracer_known;\n\n\tif ((mode & PTRACE_MODE_NOAUDIT) == 0) {\n\t\tsmk_ad_init(&ad, func, LSM_AUDIT_DATA_TASK);\n\t\tsmk_ad_setfield_u_tsk(&ad, tracer);\n\t\tsaip = &ad;\n\t}\n\n\trcu_read_lock();\n\ttsp = __task_cred(tracer)->security;\n\ttracer_known = smk_of_task(tsp);\n\n\tif ((mode & PTRACE_MODE_ATTACH) &&\n\t    (smack_ptrace_rule == SMACK_PTRACE_EXACT ||\n\t     smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)) {\n\t\tif (tracer_known->smk_known == tracee_known->smk_known)\n\t\t\trc = 0;\n\t\telse if (smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)\n\t\t\trc = -EACCES;\n\t\telse if (capable(CAP_SYS_PTRACE))\n\t\t\trc = 0;\n\t\telse\n\t\t\trc = -EACCES;\n\n\t\tif (saip)\n\t\t\tsmack_log(tracer_known->smk_known,\n\t\t\t\t  tracee_known->smk_known,\n\t\t\t\t  0, rc, saip);\n\n\t\trcu_read_unlock();\n\t\treturn rc;\n\t}\n\n\t/* In case of rule==SMACK_PTRACE_DEFAULT or mode==PTRACE_MODE_READ */\n\trc = smk_tskacc(tsp, tracee_known, smk_ptrace_mode(mode), saip);\n\n\trcu_read_unlock();\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_ptrace_rule_check(struct task_struct *tracer,\n\t\t\t\t struct smack_known *tracee_known,\n\t\t\t\t unsigned int mode, const char *func)\n{\n\tint rc;\n\tstruct smk_audit_info ad, *saip = NULL;\n\tstruct task_smack *tsp;\n\tstruct smack_known *tracer_known;\n\n\tif ((mode & PTRACE_MODE_NOAUDIT) == 0) {\n\t\tsmk_ad_init(&ad, func, LSM_AUDIT_DATA_TASK);\n\t\tsmk_ad_setfield_u_tsk(&ad, tracer);\n\t\tsaip = &ad;\n\t}\n\n\trcu_read_lock();\n\ttsp = __task_cred(tracer)->security;\n\ttracer_known = smk_of_task(tsp);\n\n\tif ((mode & PTRACE_MODE_ATTACH) &&\n\t    (smack_ptrace_rule == SMACK_PTRACE_EXACT ||\n\t     smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)) {\n\t\tif (tracer_known->smk_known == tracee_known->smk_known)\n\t\t\trc = 0;\n\t\telse if (smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)\n\t\t\trc = -EACCES;\n\t\telse if (capable(CAP_SYS_PTRACE))\n\t\t\trc = 0;\n\t\telse\n\t\t\trc = -EACCES;\n\n\t\tif (saip)\n\t\t\tsmack_log(tracer_known->smk_known,\n\t\t\t\t  tracee_known->smk_known,\n\t\t\t\t  0, rc, saip);\n\n\t\trcu_read_unlock();\n\t\treturn rc;\n\t}\n\n\t/* In case of rule==SMACK_PTRACE_DEFAULT or mode==PTRACE_MODE_READ */\n\trc = smk_tskacc(tsp, tracee_known, smk_ptrace_mode(mode), saip);\n\n\trcu_read_unlock();\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_task_struct",
          "args": [
            "ctp"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "384-392",
          "snippet": "static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smack_ptrace_access_check(struct task_struct *ctp, unsigned int mode)\n{\n\tstruct smack_known *skp;\n\n\tskp = smk_of_task_struct(ctp);\n\n\treturn smk_ptrace_rule_check(current, skp, mode, __func__);\n}"
  },
  {
    "function_name": "smk_ptrace_rule_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "415-460",
    "snippet": "static int smk_ptrace_rule_check(struct task_struct *tracer,\n\t\t\t\t struct smack_known *tracee_known,\n\t\t\t\t unsigned int mode, const char *func)\n{\n\tint rc;\n\tstruct smk_audit_info ad, *saip = NULL;\n\tstruct task_smack *tsp;\n\tstruct smack_known *tracer_known;\n\n\tif ((mode & PTRACE_MODE_NOAUDIT) == 0) {\n\t\tsmk_ad_init(&ad, func, LSM_AUDIT_DATA_TASK);\n\t\tsmk_ad_setfield_u_tsk(&ad, tracer);\n\t\tsaip = &ad;\n\t}\n\n\trcu_read_lock();\n\ttsp = __task_cred(tracer)->security;\n\ttracer_known = smk_of_task(tsp);\n\n\tif ((mode & PTRACE_MODE_ATTACH) &&\n\t    (smack_ptrace_rule == SMACK_PTRACE_EXACT ||\n\t     smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)) {\n\t\tif (tracer_known->smk_known == tracee_known->smk_known)\n\t\t\trc = 0;\n\t\telse if (smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)\n\t\t\trc = -EACCES;\n\t\telse if (capable(CAP_SYS_PTRACE))\n\t\t\trc = 0;\n\t\telse\n\t\t\trc = -EACCES;\n\n\t\tif (saip)\n\t\t\tsmack_log(tracer_known->smk_known,\n\t\t\t\t  tracee_known->smk_known,\n\t\t\t\t  0, rc, saip);\n\n\t\trcu_read_unlock();\n\t\treturn rc;\n\t}\n\n\t/* In case of rule==SMACK_PTRACE_DEFAULT or mode==PTRACE_MODE_READ */\n\trc = smk_tskacc(tsp, tracee_known, smk_ptrace_mode(mode), saip);\n\n\trcu_read_unlock();\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_tskacc",
          "args": [
            "tsp",
            "tracee_known",
            "smk_ptrace_mode(mode)",
            "saip"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "smk_tskacc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "223-262",
          "snippet": "int smk_tskacc(struct task_smack *tsp, struct smack_known *obj_known,\n\t       u32 mode, struct smk_audit_info *a)\n{\n\tstruct smack_known *sbj_known = smk_of_task(tsp);\n\tint may;\n\tint rc;\n\n\t/*\n\t * Check the global rule list\n\t */\n\trc = smk_access(sbj_known, obj_known, mode, NULL);\n\tif (rc >= 0) {\n\t\t/*\n\t\t * If there is an entry in the task's rule list\n\t\t * it can further restrict access.\n\t\t */\n\t\tmay = smk_access_entry(sbj_known->smk_known,\n\t\t\t\t       obj_known->smk_known,\n\t\t\t\t       &tsp->smk_rules);\n\t\tif (may < 0)\n\t\t\tgoto out_audit;\n\t\tif ((mode & may) == mode)\n\t\t\tgoto out_audit;\n\t\trc = -EACCES;\n\t}\n\n\t/*\n\t * Allow for priviliged to override policy.\n\t */\n\tif (rc != 0 && smack_privileged(CAP_MAC_OVERRIDE))\n\t\trc = 0;\n\nout_audit:\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(sbj_known->smk_known, obj_known->smk_known,\n\t\t\t  mode, rc, a);\n#endif\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_tskacc(struct task_smack *tsp, struct smack_known *obj_known,\n\t       u32 mode, struct smk_audit_info *a)\n{\n\tstruct smack_known *sbj_known = smk_of_task(tsp);\n\tint may;\n\tint rc;\n\n\t/*\n\t * Check the global rule list\n\t */\n\trc = smk_access(sbj_known, obj_known, mode, NULL);\n\tif (rc >= 0) {\n\t\t/*\n\t\t * If there is an entry in the task's rule list\n\t\t * it can further restrict access.\n\t\t */\n\t\tmay = smk_access_entry(sbj_known->smk_known,\n\t\t\t\t       obj_known->smk_known,\n\t\t\t\t       &tsp->smk_rules);\n\t\tif (may < 0)\n\t\t\tgoto out_audit;\n\t\tif ((mode & may) == mode)\n\t\t\tgoto out_audit;\n\t\trc = -EACCES;\n\t}\n\n\t/*\n\t * Allow for priviliged to override policy.\n\t */\n\tif (rc != 0 && smack_privileged(CAP_MAC_OVERRIDE))\n\t\trc = 0;\n\nout_audit:\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(sbj_known->smk_known, obj_known->smk_known,\n\t\t\t  mode, rc, a);\n#endif\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ptrace_mode",
          "args": [
            "mode"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ptrace_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "396-404",
          "snippet": "static inline unsigned int smk_ptrace_mode(unsigned int mode)\n{\n\tif (mode & PTRACE_MODE_ATTACH)\n\t\treturn MAY_READWRITE;\n\tif (mode & PTRACE_MODE_READ)\n\t\treturn MAY_READ;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic inline unsigned int smk_ptrace_mode(unsigned int mode)\n{\n\tif (mode & PTRACE_MODE_ATTACH)\n\t\treturn MAY_READWRITE;\n\tif (mode & PTRACE_MODE_READ)\n\t\treturn MAY_READ;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_log",
          "args": [
            "tracer_known->smk_known",
            "tracee_known->smk_known",
            "0",
            "rc",
            "saip"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "smack_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "391-394",
          "snippet": "void smack_log(char *subject_label, char *object_label, int request,\n               int result, struct smk_audit_info *ad)\n{\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid smack_log(char *subject_label, char *object_label, int request,\n               int result, struct smk_audit_info *ad)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_PTRACE"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_task",
          "args": [
            "tsp"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "384-392",
          "snippet": "static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "tracer"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_ad_setfield_u_tsk",
          "args": [
            "&ad",
            "tracer"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_setfield_u_tsk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "477-480",
          "snippet": "static inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,\n\t\t\t\t\t struct task_struct *t)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_setfield_u_tsk(struct smk_audit_info *a,\n\t\t\t\t\t struct task_struct *t)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_ad_init",
          "args": [
            "&ad",
            "func",
            "LSM_AUDIT_DATA_TASK"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "smk_ad_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "473-476",
          "snippet": "static inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline void smk_ad_init(struct smk_audit_info *a, const char *func,\n\t\t\t       char type)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_ptrace_rule_check(struct task_struct *tracer,\n\t\t\t\t struct smack_known *tracee_known,\n\t\t\t\t unsigned int mode, const char *func)\n{\n\tint rc;\n\tstruct smk_audit_info ad, *saip = NULL;\n\tstruct task_smack *tsp;\n\tstruct smack_known *tracer_known;\n\n\tif ((mode & PTRACE_MODE_NOAUDIT) == 0) {\n\t\tsmk_ad_init(&ad, func, LSM_AUDIT_DATA_TASK);\n\t\tsmk_ad_setfield_u_tsk(&ad, tracer);\n\t\tsaip = &ad;\n\t}\n\n\trcu_read_lock();\n\ttsp = __task_cred(tracer)->security;\n\ttracer_known = smk_of_task(tsp);\n\n\tif ((mode & PTRACE_MODE_ATTACH) &&\n\t    (smack_ptrace_rule == SMACK_PTRACE_EXACT ||\n\t     smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)) {\n\t\tif (tracer_known->smk_known == tracee_known->smk_known)\n\t\t\trc = 0;\n\t\telse if (smack_ptrace_rule == SMACK_PTRACE_DRACONIAN)\n\t\t\trc = -EACCES;\n\t\telse if (capable(CAP_SYS_PTRACE))\n\t\t\trc = 0;\n\t\telse\n\t\t\trc = -EACCES;\n\n\t\tif (saip)\n\t\t\tsmack_log(tracer_known->smk_known,\n\t\t\t\t  tracee_known->smk_known,\n\t\t\t\t  0, rc, saip);\n\n\t\trcu_read_unlock();\n\t\treturn rc;\n\t}\n\n\t/* In case of rule==SMACK_PTRACE_DEFAULT or mode==PTRACE_MODE_READ */\n\trc = smk_tskacc(tsp, tracee_known, smk_ptrace_mode(mode), saip);\n\n\trcu_read_unlock();\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_ptrace_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "396-404",
    "snippet": "static inline unsigned int smk_ptrace_mode(unsigned int mode)\n{\n\tif (mode & PTRACE_MODE_ATTACH)\n\t\treturn MAY_READWRITE;\n\tif (mode & PTRACE_MODE_READ)\n\t\treturn MAY_READ;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic inline unsigned int smk_ptrace_mode(unsigned int mode)\n{\n\tif (mode & PTRACE_MODE_ATTACH)\n\t\treturn MAY_READWRITE;\n\tif (mode & PTRACE_MODE_READ)\n\t\treturn MAY_READ;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_copy_relabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "371-388",
    "snippet": "static int smk_copy_relabel(struct list_head *nhead, struct list_head *ohead,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct smack_known_list_elem *nklep;\n\tstruct smack_known_list_elem *oklep;\n\n\tlist_for_each_entry(oklep, ohead, list) {\n\t\tnklep = kzalloc(sizeof(struct smack_known_list_elem), gfp);\n\t\tif (nklep == NULL) {\n\t\t\tsmk_destroy_label_list(nhead);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnklep->smk_label = oklep->smk_label;\n\t\tlist_add(&nklep->list, nhead);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&nklep->list",
            "nhead"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_destroy_label_list",
          "args": [
            "nhead"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "smk_destroy_label_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "1988-1997",
          "snippet": "void smk_destroy_label_list(struct list_head *list)\n{\n\tstruct smack_known_list_elem *sklep;\n\tstruct smack_known_list_elem *sklep2;\n\n\tlist_for_each_entry_safe(sklep, sklep2, list, list)\n\t\tkfree(sklep);\n\n\tINIT_LIST_HEAD(list);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nvoid smk_destroy_label_list(struct list_head *list)\n{\n\tstruct smack_known_list_elem *sklep;\n\tstruct smack_known_list_elem *sklep2;\n\n\tlist_for_each_entry_safe(sklep, sklep2, list, list)\n\t\tkfree(sklep);\n\n\tINIT_LIST_HEAD(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct smack_known_list_elem)",
            "gfp"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "oklep",
            "ohead",
            "list"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_copy_relabel(struct list_head *nhead, struct list_head *ohead,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct smack_known_list_elem *nklep;\n\tstruct smack_known_list_elem *oklep;\n\n\tlist_for_each_entry(oklep, ohead, list) {\n\t\tnklep = kzalloc(sizeof(struct smack_known_list_elem), gfp);\n\t\tif (nklep == NULL) {\n\t\t\tsmk_destroy_label_list(nhead);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnklep->smk_label = oklep->smk_label;\n\t\tlist_add(&nklep->list, nhead);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_copy_rules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "344-361",
    "snippet": "static int smk_copy_rules(struct list_head *nhead, struct list_head *ohead,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct smack_rule *nrp;\n\tstruct smack_rule *orp;\n\tint rc = 0;\n\n\tlist_for_each_entry_rcu(orp, ohead, list) {\n\t\tnrp = kzalloc(sizeof(struct smack_rule), gfp);\n\t\tif (nrp == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t*nrp = *orp;\n\t\tlist_add_rcu(&nrp->list, nhead);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&nrp->list",
            "nhead"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct smack_rule)",
            "gfp"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "orp",
            "ohead",
            "list"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_copy_rules(struct list_head *nhead, struct list_head *ohead,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct smack_rule *nrp;\n\tstruct smack_rule *orp;\n\tint rc = 0;\n\n\tlist_for_each_entry_rcu(orp, ohead, list) {\n\t\tnrp = kzalloc(sizeof(struct smack_rule), gfp);\n\t\tif (nrp == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t*nrp = *orp;\n\t\tlist_add_rcu(&nrp->list, nhead);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "new_task_smack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "318-334",
    "snippet": "static struct task_smack *new_task_smack(struct smack_known *task,\n\t\t\t\t\tstruct smack_known *forked, gfp_t gfp)\n{\n\tstruct task_smack *tsp;\n\n\ttsp = kzalloc(sizeof(struct task_smack), gfp);\n\tif (tsp == NULL)\n\t\treturn NULL;\n\n\ttsp->smk_task = task;\n\ttsp->smk_forked = forked;\n\tINIT_LIST_HEAD(&tsp->smk_rules);\n\tINIT_LIST_HEAD(&tsp->smk_relabel);\n\tmutex_init(&tsp->smk_rules_lock);\n\n\treturn tsp;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&tsp->smk_rules_lock"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tsp->smk_relabel"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tsp->smk_rules"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct task_smack)",
            "gfp"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct task_smack *new_task_smack(struct smack_known *task,\n\t\t\t\t\tstruct smack_known *forked, gfp_t gfp)\n{\n\tstruct task_smack *tsp;\n\n\ttsp = kzalloc(sizeof(struct task_smack), gfp);\n\tif (tsp == NULL)\n\t\treturn NULL;\n\n\ttsp->smk_task = task;\n\ttsp->smk_forked = forked;\n\tINIT_LIST_HEAD(&tsp->smk_rules);\n\tINIT_LIST_HEAD(&tsp->smk_relabel);\n\tmutex_init(&tsp->smk_rules_lock);\n\n\treturn tsp;\n}"
  },
  {
    "function_name": "new_inode_smack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "295-308",
    "snippet": "static struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *smack_inode_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&isp->smk_lock"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "smack_inode_cache",
            "GFP_NOFS"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct kmem_cache *smack_inode_cache;\n\nstatic struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}"
  },
  {
    "function_name": "smk_fetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "262-287",
    "snippet": "static struct smack_known *smk_fetch(const char *name, struct inode *ip,\n\t\t\t\t\tstruct dentry *dp)\n{\n\tint rc;\n\tchar *buffer;\n\tstruct smack_known *skp = NULL;\n\n\tif (!(ip->i_opflags & IOP_XATTR))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tbuffer = kzalloc(SMK_LONGLABEL, GFP_KERNEL);\n\tif (buffer == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = __vfs_getxattr(dp, ip, name, buffer, SMK_LONGLABEL);\n\tif (rc < 0)\n\t\tskp = ERR_PTR(rc);\n\telse if (rc == 0)\n\t\tskp = NULL;\n\telse\n\t\tskp = smk_import_entry(buffer, rc);\n\n\tkfree(buffer);\n\n\treturn skp;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "buffer",
            "rc"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vfs_getxattr",
          "args": [
            "dp",
            "ip",
            "name",
            "buffer",
            "SMK_LONGLABEL"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "SMK_LONGLABEL",
            "GFP_KERNEL"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct smack_known *smk_fetch(const char *name, struct inode *ip,\n\t\t\t\t\tstruct dentry *dp)\n{\n\tint rc;\n\tchar *buffer;\n\tstruct smack_known *skp = NULL;\n\n\tif (!(ip->i_opflags & IOP_XATTR))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tbuffer = kzalloc(SMK_LONGLABEL, GFP_KERNEL);\n\tif (buffer == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = __vfs_getxattr(dp, ip, name, buffer, SMK_LONGLABEL);\n\tif (rc < 0)\n\t\tskp = ERR_PTR(rc);\n\telse if (rc == 0)\n\t\tskp = NULL;\n\telse\n\t\tskp = smk_import_entry(buffer, rc);\n\n\tkfree(buffer);\n\n\treturn skp;\n}"
  },
  {
    "function_name": "smk_bu_credfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "224-248",
    "snippet": "static int smk_bu_credfile(const struct cred *cred, struct file *file,\n\t\t\t\tint mode, int rc)\n{\n\tstruct task_smack *tsp = cred->security;\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\"",
            "smk_bu_mess[rc]",
            "sskp->smk_known",
            "smk_of_inode(inode)->smk_known",
            "acc",
            "inode->i_sb->s_id",
            "inode->i_ino",
            "file",
            "current->comm"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "inode"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_bu_mode",
          "args": [
            "mode",
            "acc"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "78-97",
          "snippet": "static void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\"",
            "inode->i_sb->s_id",
            "inode->i_ino",
            "current->comm"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_credfile(const struct cred *cred, struct file *file,\n\t\t\t\tint mode, int rc)\n{\n\tstruct task_smack *tsp = cred->security;\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_bu_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "195-218",
    "snippet": "static int smk_bu_file(struct file *file, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\"",
            "smk_bu_mess[rc]",
            "sskp->smk_known",
            "smk_of_inode(inode)->smk_known",
            "acc",
            "inode->i_sb->s_id",
            "inode->i_ino",
            "file",
            "current->comm"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_of_inode",
          "args": [
            "inode"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "370-374",
          "snippet": "static inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_inode(const struct inode *isp)\n{\n\tstruct inode_smack *sip = isp->i_security;\n\treturn sip->smk_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_bu_mode",
          "args": [
            "mode",
            "acc"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "78-97",
          "snippet": "static void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\"",
            "inode->i_sb->s_id",
            "inode->i_ino",
            "current->comm"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_file(struct file *file, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *sskp = tsp->smk_task;\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) file=(%s %ld %pD) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, smk_of_inode(inode)->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, file,\n\t\tcurrent->comm);\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_bu_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "165-189",
    "snippet": "static int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\"",
            "smk_bu_mess[rc]",
            "tsp->smk_task->smk_known",
            "isp->smk_inode->smk_known",
            "acc",
            "inode->i_sb->s_id",
            "inode->i_ino",
            "current->comm"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_bu_mode",
          "args": [
            "mode",
            "acc"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "78-97",
          "snippet": "static void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\"",
            "inode->i_sb->s_id",
            "inode->i_ino",
            "current->comm"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_inode(struct inode *inode, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct inode_smack *isp = inode->i_security;\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (isp->smk_flags & SMK_INODE_IMPURE)\n\t\tpr_info(\"Smack Unconfined Corruption: inode=(%s %ld) %s\\n\",\n\t\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\tif (rc == SMACK_UNCONFINED_SUBJECT &&\n\t    (mode & (MAY_WRITE | MAY_APPEND)))\n\t\tisp->smk_flags |= SMK_INODE_IMPURE;\n\n\tsmk_bu_mode(mode, acc);\n\n\tpr_info(\"Smack %s: (%s %s %s) inode=(%s %ld) %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, isp->smk_inode->smk_known, acc,\n\t\tinode->i_sb->s_id, inode->i_ino, current->comm);\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_bu_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "143-159",
    "snippet": "static int smk_bu_task(struct task_struct *otp, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *smk_task = smk_of_task_struct(otp);\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s to %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, smk_task->smk_known, acc,\n\t\tcurrent->comm, otp->comm);\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Smack %s: (%s %s %s) %s to %s\\n\"",
            "smk_bu_mess[rc]",
            "tsp->smk_task->smk_known",
            "smk_task->smk_known",
            "acc",
            "current->comm",
            "otp->comm"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_bu_mode",
          "args": [
            "mode",
            "acc"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "78-97",
          "snippet": "static void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_of_task_struct",
          "args": [
            "otp"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "384-392",
          "snippet": "static inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_task_struct(const struct task_struct *t)\n{\n\tstruct smack_known *skp;\n\n\trcu_read_lock();\n\tskp = smk_of_task(__task_cred(t)->security);\n\trcu_read_unlock();\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_task(struct task_struct *otp, int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tstruct smack_known *smk_task = smk_of_task_struct(otp);\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s to %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, smk_task->smk_known, acc,\n\t\tcurrent->comm, otp->comm);\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_bu_current",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "121-137",
    "snippet": "static int smk_bu_current(char *note, struct smack_known *oskp,\n\t\t\t  int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, oskp->smk_known,\n\t\tacc, current->comm, note);\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Smack %s: (%s %s %s) %s %s\\n\"",
            "smk_bu_mess[rc]",
            "tsp->smk_task->smk_known",
            "oskp->smk_known",
            "acc",
            "current->comm",
            "note"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_bu_mode",
          "args": [
            "mode",
            "acc"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "78-97",
          "snippet": "static void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_current(char *note, struct smack_known *oskp,\n\t\t\t  int mode, int rc)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s %s\\n\", smk_bu_mess[rc],\n\t\ttsp->smk_task->smk_known, oskp->smk_known,\n\t\tacc, current->comm, note);\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_bu_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "101-115",
    "snippet": "static int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Smack %s: (%s %s %s) %s\\n\"",
            "smk_bu_mess[rc]",
            "sskp->smk_known",
            "oskp->smk_known",
            "acc",
            "note"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_bu_mode",
          "args": [
            "mode",
            "acc"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "smk_bu_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "78-97",
          "snippet": "static void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic int smk_bu_note(char *note, struct smack_known *sskp,\n\t\t       struct smack_known *oskp, int mode, int rc)\n{\n\tchar acc[SMK_NUM_ACCESS_TYPE + 1];\n\n\tif (rc <= 0)\n\t\treturn rc;\n\tif (rc > SMACK_UNCONFINED_OBJECT)\n\t\trc = 0;\n\n\tsmk_bu_mode(mode, acc);\n\tpr_info(\"Smack %s: (%s %s %s) %s\\n\", smk_bu_mess[rc],\n\t\tsskp->smk_known, oskp->smk_known, acc, note);\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_bu_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
    "lines": "78-97",
    "snippet": "static void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/parser.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/shm.h>",
      "#include <linux/msg.h>",
      "#include <linux/personality.h>",
      "#include <linux/dcache.h>",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/dccp.h>",
      "#include <linux/udp.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <asm/ioctls.h>",
      "#include <linux/kd.h>",
      "#include <linux/stat.h>",
      "#include <linux/mount.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic void smk_bu_mode(int mode, char *s)\n{\n\tint i = 0;\n\n\tif (mode & MAY_READ)\n\t\ts[i++] = 'r';\n\tif (mode & MAY_WRITE)\n\t\ts[i++] = 'w';\n\tif (mode & MAY_EXEC)\n\t\ts[i++] = 'x';\n\tif (mode & MAY_APPEND)\n\t\ts[i++] = 'a';\n\tif (mode & MAY_TRANSMUTE)\n\t\ts[i++] = 't';\n\tif (mode & MAY_LOCK)\n\t\ts[i++] = 'l';\n\tif (i == 0)\n\t\ts[i++] = '-';\n\ts[i] = '\\0';\n}"
  }
]